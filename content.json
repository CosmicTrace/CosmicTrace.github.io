{"meta":{"title":"角灯随笔","subtitle":"全栈也不是不行","description":"谦逊","author":"Yiuhang Chan","url":"https://www.yiuhangblog.com","root":"/"},"pages":[{"title":"一个整数据的俗人","date":"2024-04-25T07:42:58.064Z","updated":"2024-02-06T03:28:37.000Z","comments":true,"path":"about/index.html","permalink":"https://www.yiuhangblog.com/about/index.html","excerpt":"","text":"悉尼大学数据分析与管理硕士毕业，爱整些有的没的。这个工具箱初衷为了辅助自己榆木脑袋所用，希望也能对路过的你带来些许帮助。"},{"title":"categories","date":"2018-12-03T11:46:15.000Z","updated":"2023-12-08T05:02:52.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.yiuhangblog.com/categories/index.html","excerpt":"","text":""},{"title":"娱乐","date":"2018-05-14T03:45:14.000Z","updated":"2023-12-14T14:59:07.000Z","comments":true,"path":"cod/index.html","permalink":"https://www.yiuhangblog.com/cod/index.html","excerpt":"","text":"使命召唤 /* 容器样式 */ .gallery-container { display: flex; flex-wrap: wrap; justify-content: space-between; } /* 视频容器样式 */ .gallery-column { text-align: center; flex: 1 0 45%; /* flex-grow为1，flex-basis为45%，确保两个元素并排排列 */ margin: 22px; box-sizing: border-box; } iframe { width: 100%; height: auto; aspect-ratio: 16 / 9; } /* 媒体查询 */ @media screen and (max-width: 768px) { .gallery-column { flex: 1 0 100%; /* 在小屏幕上每个容器宽度为100%，单列显示 */ } } 远距离对狙 水塔打配合"},{"title":"娱乐","date":"2018-05-14T03:45:14.000Z","updated":"2024-04-22T09:55:58.378Z","comments":true,"path":"hok/index.html","permalink":"https://www.yiuhangblog.com/hok/index.html","excerpt":"","text":"王者荣耀 /* 容器样式 */ .gallery-container { display: flex; flex-wrap: wrap; justify-content: space-between; } /* 视频容器样式 */ .gallery-column { text-align: center; flex: 1 0 45%; /* flex-grow为1，flex-basis为45%，确保两个元素并排排列 */ margin: 22px; box-sizing: border-box; } iframe { width: 100%; height: auto; aspect-ratio: 16 / 9; } /* 媒体查询 */ @media screen and (max-width: 768px) { .gallery-column { flex: 1 0 100%; /* 在小屏幕上每个容器宽度为100%，单列显示 */ } } 雅典娜四杀 雅典娜2v3 达摩逆风秒双C 达摩秒嬴政 西施碾压局 雅典娜飞雷神 阿古多1v2反杀"},{"title":"娱乐","date":"2018-05-14T03:45:14.000Z","updated":"2023-12-14T14:57:28.000Z","comments":true,"path":"ow/index.html","permalink":"https://www.yiuhangblog.com/ow/index.html","excerpt":"","text":"守望先锋 /* 容器样式 */ .gallery-container { display: flex; flex-wrap: wrap; justify-content: space-between; } /* 视频容器样式 */ .gallery-column { text-align: center; flex: 1 0 45%; /* flex-grow为1，flex-basis为45%，确保两个元素并排排列 */ margin: 22px; box-sizing: border-box; } iframe { width: 100%; height: auto; aspect-ratio: 16 / 9; } /* 媒体查询 */ @media screen and (max-width: 768px) { .gallery-column { flex: 1 0 100%; /* 在小屏幕上每个容器宽度为100%，单列显示 */ } } 拔刀砍两个 奥丽莎守车翻盘 朴素拔刀切后排"},{"title":"tags","date":"2018-12-03T11:44:14.000Z","updated":"2023-12-08T05:02:52.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.yiuhangblog.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Robot Framework教程","slug":"20240419RobotFramework教程","date":"2024-04-19T03:17:08.000Z","updated":"2024-04-25T07:57:48.126Z","comments":true,"path":"2024/04/19/20240419RobotFramework教程/","permalink":"https://www.yiuhangblog.com/2024/04/19/20240419RobotFramework%E6%95%99%E7%A8%8B/","excerpt":"Robot Framewor教程","text":"Robot Framework 简介Robot Framework是一个通用的开源自动化框架。它可用于测试自动化和机器人流程自动化（RPA）。 Robot Framework受Robot Framework基金会支持。许多行业领先的公司在其软件开发中使用该工具。 Robot Framework是开放且可扩展的。Robot Framework可以与几乎任何其他工具集成，以创建强大且灵活的自动化解决方案。Robot Framework可以免费使用，无需许可费用。 Robot Framework具有易于理解的语法，利用人类可读的关键字。其功能可以通过使用Python、Java或许多其他编程语言实现的库来扩展。Robot Framework周围有一个丰富的生态系统，包括作为单独项目开发的库和工具。 Robot Framework的开发由非营利性的Robot Framework基金会资助。它由希望确保Robot Framework现在和将来持续发展的公司和组织组成。Robot Framework仍然完全免费使用，并且在积极进行维护和开发。基金会还覆盖其他相关费用，如开发此网站和组织各种聚会。 基金会成员： 为什么选择 Robot Framework？ 提供了易于使用的表格语法，以统一的方式创建测试用例。 允许从现有关键字创建可重用的高级关键字。 提供易于阅读的以 HTML 格式的结果报告和日志。 平台和应用程序无关。 提供了一个简单的库 API，用于创建可以使用 Python 原生实现的定制测试库。 提供了命令行界面和基于 XML 的输出文件，用于集成到现有的构建基础设施（连续集成系统）中。 支持测试 Web 应用程序、REST API、移动应用程序、运行的进程、通过 Telnet 或 SSH 连接到远程系统等。 支持创建数据驱动的测试用例。 具有内置的变量支持，特别适用于在不同环境中进行测试。 提供标记以对测试用例进行分类和选择执行。 可以与源代码控制轻松集成：测试套件只是可以与生产代码一起进行版本控制的文件和目录。 提供了测试用例和测试套件级别的设置和拆卸。 模块化架构支持为具有多个不同接口的应用程序创建测试。 高级架构Robot Framework 是一个通用的、与应用程序和技术无关的框架。它具有高度模块化的架构，如下图所示： 测试数据以简单、易于编辑的表格格式存在。当启动 Robot Framework 时，它会处理数据，执行测试用例，并生成日志和报告。核心框架对被测试对象一无所知，与其交互由库处理。库可以直接使用应用程序接口，也可以使用较低级别的测试工具作为驱动程序。 截屏以下截屏展示了测试数据以及生成的报告和日志的示例。 测试用例文件： 报告和日志： 获取更多信息项目页面有关 Robot Framework 及其丰富生态系统的更多信息，首要去处是 http://robotframework.org 。Robot Framework 本身托管在 GitHub 上。 邮件列表有几个 Robot Framework 邮件列表可供询问和搜索更多信息。邮件列表存档对所有人（包括搜索引擎）开放，每个人也可以自由加入这些列表。但只有列表成员才能发送邮件，为了防止垃圾邮件，新用户需要经过审核，这意味着的第一条消息可能需要一些时间才能通过。不要害怕向邮件列表发送问题，但请记住如何聪明地提问。 robotframework-users（Robot Framework 用户）：关于所有与 Robot Framework 相关问题的一般讨论。可以将问题和问题发送到此列表。也用于向所有用户共享信息。 robotframework-announce（Robot Framework 公告）：仅供公告的邮件列表，只有管理员才能发送消息。所有公告也发送到 robotframework-users 邮件列表，因此没有必要加入两个列表。 robotframework-devel（Robot Framework 开发）：关于 Robot Framework 开发的讨论。 版权和许可证Robot Framework 是一款开源软件，采用 Apache License 2.0 提供。Robot Framework 的文档，例如本用户指南，使用 Creative Commons Attribution 3.0 Unported 许可证。围绕该框架的更大生态系统中的大多数库和工具也是开源的，但它们可能使用不同的许可证。 完整的 Robot Framework 版权声明如下： 1234567891011121314Copyright 2008-2015 Nokia NetworksCopyright 2016- Robot Framework FoundationLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License. 根据 Apache 许可证第 2.0 版（“许可证”）许可；除非符合许可证的规定，否则不得使用此文件。可以在以下网址获取许可证的副本：http://www.apache.org/licenses/LICENSE-2.0 除非适用法律要求或书面同意，否则根据许可证分发的软件以“原样”分发，不附带任何明示或暗示的保证或条件。请参阅许可证以了解特定语言下的权限和限制。 安装指南这些指南涵盖了在不同操作系统上安装Robot Framework及其前置条件的步骤。如果已经安装了Python，可以使用标准的软件包管理器pip来安装Robot Framework： 1pip install robotframework Python 安装Robot Framework 是使用 Python 实现的，安装它的前提条件是已经安装了 Python 或其替代实现 PyPy。另一个推荐的前提条件是有 pip 包管理器可用。 Robot Framework 需要 Python 3.8 或更新版本。支持 Python 3.6 和 3.7 的最新版本是 Robot Framework 6.1.1。如果需要使用 Python 2，Jython 或 IronPython，可以使用 Robot Framework 4.1.3。 在 Linux 上安装 Python在 Linux 上，默认应该已经安装了适合的 Python 版本和 pip。如果没有，需要查阅发行版的文档来了解如何安装它们。如果想使用默认提供的 Python 版本之外的其他版本，这同样适用。 要检查已安装的 Python 版本，可以在终端运行 python --version 命令： 12$ python --versionPython 3.10.13 注意，如果的发行版也提供了较旧的 Python 2，运行 python 可能会使用那个。要使用 Python 3，可以使用 python3 命令，或者更具体的版本命令，如 python3.8。如果安装了多个 Python 3 版本，也需要使用这些具体版本的变体来确定使用哪一个： 1234$ python3.11 --versionPython 3.11.7$ python3.12 --versionPython 3.12.1 直接在系统提供的 Python 下安装 Robot Framework 存在风险，可能的问题会影响到操作系统本身也在使用的整个 Python 安装。现在的 Linux 发行版通常默认使用用户安装来避免此类问题，但用户也可以自己决定使用虚拟环境。 Windows 上的 Python 安装 Windows 默认不提供 Python，但安装起来很简单。推荐使用官方 Windows 安装程序，可在 http://python.org 获取。 安装 Python 时，建议将 Python 添加到 PATH，以便从命令行更容易执行 Python 及其工具，如 pip 和 Robot Framework。使用官方安装程序时，只需在第一个对话框中选择 Add Python 3.x to PATH 复选框。 验证 Python 安装是否成功并已添加到 PATH： 12C:\\&gt;python --versionPython 3.10.9 如果在 Windows 上安装了多个 Python 版本，执行 python 时使用的是 PATH 中排在首位的版本。要使用其他版本，最简单的方法是使用 py 启动器： 1234C:\\&gt;py --versionPython 3.10.9C:\\&gt;py -3.12 --versionPython 3.12.1 macOS 上的 Python 安装 macOS 默认不提供与 Python 3 兼容的 Python 版本，需要单独安装。推荐使用官方 macOS 安装程序，可在 http://python.org 获取。如果使用包管理器如 Homebrew，也可以通过它安装 Python。 PyPy 安装 PyPy 是 Python 的替代实现。与标准 Python 实现相比，其主要优势是可能更快且使用更少内存，但这取决于使用的上下文。如果执行速度重要，至少测试 PyPy 是个好主意。 PyPy 安装是一个简单的过程，可以在 http://pypy.org 找到安装程序和安装说明。验证 PyPy 安装是否成功： 12$ pypy --version$ pypy3 --version 注意：仅在 Linux 上官方支持使用 PyPy 的 Robot Framework。 配置 PATH PATH 环境变量列出了系统中执行命令时搜索的目录。为了便于从命令行使用 Python、pip 和 Robot Framework，建议将 Python 安装目录以及 pip 和 robot 等命令安装的目录添加到 PATH。 在 Linux 或 macOS 上使用 Python 时，Python 及其安装的工具应自动在 PATH 中。如果仍需更新 PATH，则通常需要编辑某些系统范围或用户特定的配置文件。具体编辑哪个文件以及如何编辑取决于操作系统，需要查阅其文档了解更多详情。 在 Windows 上，确保 PATH 配置正确的最简单方法是在运行安装程序时勾选 Add Python 3.x to PATH 复选框。手动修改 Windows 上的 PATH，请按照以下步骤操作： 在设置中找到环境变量。有影响整个系统的变量和仅影响当前用户的变量。修改前者将需要管理员权限，但通常只需修改后者。 选择 PATH（通常写作 Path）并点击编辑。如果正在编辑用户变量且 PATH 不存在，则点击新建。 将 Python 安装目录和安装目录下的 Scripts 目录都添加到 PATH 中。 点击确定退出对话框以保存更改。 启动新的命令提示符以使更改生效。 使用 pip 安装pip 命令的运行 在 Linux 上，可能需要使用 pip3 或更具体的 Python 版本命令，如 pip3.8。 在 Windows 上，当执行 python 时，PATH 中首先找到的版本将被使用。如果需要使用其他版本，可以运行 py 启动器。 验证 pip 是否可用 Linux 示例： 1234$ pip --versionpip 23.2.1 from ... (python 3.10)$ python3.12 -m pip --versionpip 23.3.1 from ... (python 3.12) Windows 示例： 1234C:\\&gt; pip --versionpip 23.2.1 from ... (python 3.10)C:\\&gt; py -m 3.12 -m pip --versionpip 23.3.2 from ... (python 3.12) 安装与卸载 Robot Framework 从 Python 包索引 (PyPI) 安装和下载包是 pip 的常用方法。 1234567891011121314151617181920# 安装最新版本（不升级）pip install robotframework# 升级到最新稳定版本pip install --upgrade robotframework# 升级到最新版本，即使它是预发布版本pip install --upgrade --pre robotframework# 安装特定版本pip install robotframework==7.0# 安装单独下载的包（无需网络连接）pip install robotframework-7.0-py3-none-any.whl# 直接从 GitHub 安装最新（可能未发布）的代码pip install https://github.com/robotframework/robotframework/archive/master.zip# 卸载pip uninstall robotframework 从源代码安装如果没有pip可用，可以通过下载PyPI上的zip包并解压，或者克隆GitHub仓库并检出所需的发布标签来获取Robot Framework源代码。 安装源代码的命令如下： 1python setup.py install setup.py 脚本接受多个参数，例如允许安装到不需要管理员权限的非默认位置。此外，该脚本也用于创建不同的发行包。运行 python setup.py --help 可以获取更多详情。 验证安装为了确保安装了正确版本的Robot Framework，可以运行以下命令： 1$ robot --version 如果出现命令未找到或无法识别的消息，首先应该检查PATH配置。 如果在多个Python版本下安装了Robot Framework，运行 robot 将执行PATH中的第一个。要显式选择，可以运行 python -m robot 并用正确的Python版本替换 python。 例如： 1$ python3.12 -m robot --version 或在Windows上： 1C:\\&gt;py -3.11 -m robot --version 虚拟环境Python虚拟环境允许将Python包安装在特定系统或应用程序的隔离位置，而不是将所有包安装在同一全局位置。主要有两个用途： 为不同项目将所需包安装在各自的环境中，避免如果项目需要不同版本的同一包时发生冲突。 避免在全局Python安装下安装所有内容。这在Linux上尤其重要，因为全局Python安装可能被发行版本身使用，搞乱它可能会导致严重问题。 设置集成开发环境IDE Visual Studio Code 代码编辑。重新定义。免费。基于开源。无处不在。 PyCharm 专业开发人员的Python集成开发环境 安装IDE和扩展许多IDE和代码编辑器支持开发Robot Framework测试。 支持范围从简单的代码高亮、代码完成到测试执行和调试。 这里列出了几个IDE和扩展，但还有很多其他的选择。 Visual Studio Code由Microsoft开发的开源轻量级代码编辑器。它提供了许多不同语言和技术的扩展。 VS Code 针对Robot Framework的常用扩展： Robot Code Robot Framework Language Server 安装Visual Studio Code查看VS Code设置指南以获取更多信息。 从Visual Studio Code下载Windows安装程序 使用默认设置运行安装程序 启动Visual Studio Code，方式有： 按下 Windows键 + R，键入 code，然后按 Enter 打开开始菜单，搜索 Visual Studio Code并单击打开 Visual Studio Code扩展 注意 确保仅安装了一个Robot Framework扩展。 RobotCode是Visual Studio Code的一个Robot Framework扩展。 打开Visual Studio Code 点击扩展图标或按 Ctrl + Shift + X 搜索 RobotCode并点击安装 点击安装 Robot Framework Language Server是Visual Studio Code的一个Robot Framework扩展。 打开Visual Studio Code 点击扩展图标或按 Ctrl + Shift + X 搜索 Robot Framework Language Server并点击安装 点击安装 PyCharmPyCharm是一个免费开源的Python集成开发环境。 针对Robot Framework的常用扩展： Robot Framework Language Server 安装PyCharm查看PyCharm安装指南以获取更多信息。 有两种安装方法： 推荐使用JetBrains的Toolbox App。 替代的独立安装方法 PyCharm扩展 注意 确保仅安装了一个Robot Framework扩展。 Robot Framework Language Server 按 Ctrl + Alt + S打开设置对话框 选择 插件 选择 市场选项卡 搜索 Robot Framework Language Server并点击安装 为Robot Framework添加调试配置以运行当前测试套件 为Robot Framework添加调试配置以运行当前测试用例（通过选择的文本） 注意 如果控制台输出问号或者乱码则在环境变量(Environment variables) 添加编码变量PYTHONIOENCODING&#x3D;UTF-8 运行和调试Robot Framework测试使用Visual Studio Code和RobotCode运行 调试 在测试套件或资源文件中点击行的左侧添加断点。 右键单击播放按钮 从上下文菜单中选择“调试测试”，测试执行将开始，并在断点处停止。 使用调试工具栏选择操作，如单步执行、进入、跳出、继续、暂停等。 在调试控制台中调试时运行Robot Framework命令。 命令需要以！开头。 使用PyCharm和Robot Framework Language Server运行 运行当前测试套件 运行当前测试用例（通过选择的文本） 调试 调试测试 使用Poetry管理依赖Poetry是Python的一个依赖管理和打包工具。 它允许声明项目所依赖的库，并会为管理（安装&#x2F;更新）它们。在开始任何新的Python或Robot Framework项目时，都可以使用它。 按照官方指南安装Poetry。 在PowerShell中运行以下命令： 1(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py - 如果通过Microsoft Store安装了Python，将上述命令中的py替换为python。 运行一次poetry以检查是否已安装。 1poetry --version 虚拟环境文件夹Poetry会在 .poetry/envs文件夹中保存虚拟环境。可以更改该设置，并通过运行以下命令将虚拟环境存储在项目文件夹中： 1poetry config virtualenvs.in-project true 初始化新项目要初始化新项目，在终端中运行以下命令： 1poetry init Poetry会询问一些关于项目的问题。可以通过按Enter键留下默认值，或者输入自己的值。 示例： 此命令将引导创建 pyproject.toml配置。 123456789Package name [your-project-name]:Version [0.1.0]:Description []:Author [Your Name &lt;your.email@example.com&gt;, n to skip]:License []:Compatible Python versions [^3.10]:Would you like to define your main dependencies interactively? (yes/no) [yes] noWould you like to define your development dependencies interactively? (yes/no) [yes] no 初始化后，会在项目文件夹中看到一个名为 pyproject.toml的新文件。此文件包含有关项目和依赖项的所有信息。 添加依赖项要添加依赖项，在终端中运行以下命令： 1poetry add robotframework 也可以一次添加多个依赖项： 1poetry add robotframework robotframework-browser robotframework-requests 在首次运行时，poetry将为项目创建一个虚拟环境并安装依赖项。 在虚拟环境中运行命令要在虚拟环境中运行命令，可以使用 poetry run命令。 1poetry run robot --version 例如，要安装 robotframework-browser的playwright依赖项，可以运行以下命令： 1poetry run rfbrowser init 还可以使用 poetry shell命令在虚拟环境中打开一个shell。 在此shell中运行的所有命令都将在虚拟环境中执行。 12poetry shell(.venv) robot --version 演示有几个演示项目介绍了Robot Framework并帮助开始使用它： 快速入门指南：介绍Robot Framework最重要的特性，并作为可执行演示。 https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst Robot Framework演示：简单的示例测试用例。还演示了如何创建自定义测试库。 https://github.com/robotframework/RobotDemo 网页测试演示：演示如何创建测试和更高级别的关键字。测试的系统是一个简单的网页，使用SeleniumLibrary进行测试。 https://github.com/robotframework/WebDemo 使用Robot Framework进行ATDD：演示如何在遵循接受测试驱动开发（ATDD）过程时使用Robot Framework。 https://code.google.com/p/atdd-with-robot-framework 创建测试数据测试数据语法此部分涵盖Robot Framework的整体测试数据语法。以下各节将解释如何实际创建测试用例、测试套件等。尽管本节主要使用测试一词，但创建任务时也适用相同规则。 文件和目录安排测试用例的层次结构建立如下： 测试用例在套件文件中创建。 测试用例文件自动创建一个包含该文件中测试用例的测试套件。 包含测试用例文件的目录形成一个更高级别的测试套件。这样的套件目录拥有从测试用例文件创建的子测试套件。 测试套件目录也可以包含其他测试套件目录，这种层次结构可以根据需要深入嵌套。 测试套件目录可以有一个特殊的初始化文件，用于配置创建的测试套件。 此外，还包括： 包含最低级关键字的测试库。 带有变量和更高级用户关键字的资源文件。 提供比资源文件更灵活的创建变量方式的变量文件。 测试用例文件、测试套件初始化文件和资源文件都使用Robot Framework测试数据语法创建。测试库和变量文件使用“真实”编程语言创建，通常是Python。 测试数据部分Robot Framework数据在不同部分定义，这些部分通常也称为表格，如下所列： 部分 用途 Settings 1) 导入测试库、资源文件和变量文件。2) 定义测试套件和测试用例的元数据。 Variables 定义可以在测试数据中其他地方使用的变量。 Test Cases 从可用关键字创建测试用例。 Tasks 使用可用关键字创建任务。单个文件只能包含测试或任务。 Keywords 从现有的低级关键字创建用户关键字。 Comments 额外的评论或数据。被Robot Framework忽略。 不同部分通过其标题行被识别。推荐的标题格式是 *** Settings***，但标题不区分大小写，周围的空格是可选的，星号字符的数量可以变化，只要开头至少有一个星号。例如，*Settings也会被识别为部分标题。 Robot Framework也支持单数标题，如 *** Setting***，但该支持在Robot Framework 6.0中已被弃用。从Robot Framework 7.0开始会有可见的弃用警告，最终单数标题将完全不被支持。 标题行也可以包含实际部分标题以外的其他数据。额外的数据必须使用数据格式依赖的分隔符与部分标题分开，通常是两个或更多空格。这些额外的标题在解析时会被忽略，但它们可以用于文档记录目的。在使用数据驱动风格创建测试用例时，这特别有用。 第一部分之前的可能数据被忽略。 注意 部分标题可以本地化。有关支持的翻译，请参阅翻译。 支持的文件格式创建Robot Framework数据的最常见方法是使用空格分隔的格式，其中数据的各个部分，例如关键字及其参数，用两个或更多空格分隔。 另一种方法是使用管道分隔的格式，其中分隔符是用空格括起来的管道字符 |。 套件文件通常使用 .robot扩展名，但可以配置解析哪些文件。资源文件也可以使用 .robot扩展名，但建议使用专用的 .resource扩展名，并且在将来可能会被强制执行。 包含非ASCII字符的文件必须使用UTF-8编码保存。 Robot Framework还支持reStructuredText文件，以便将普通的Robot Framework数据嵌入到代码块中。默认情况下，仅解析具有 .robot.rst扩展名的文件。如果更喜欢使用 .rst或 .rest扩展名，那么需要单独配置。 Robot Framework数据还可以以JSON格式创建，该格式更针对工具开发人员而不是普通的Robot Framework用户。默认情况下，仅解析具有自定义 .rbt扩展名的JSON文件。 较早的Robot Framework版本还支持HTML和TSV格式的数据。如果数据与空格分隔格式兼容，则TSV格式仍然有效，但完全删除了对HTML格式的支持。如果遇到此类数据文件，需要将其转换为纯文本格式，以便在Robot Framework 3.2或更新版本中使用。最简单的方法是使用Tidy工具，但必须使用Robot Framework 3.1附带的版本，因为更新版本根本不理解HTML格式。 空格分隔格式当Robot Framework解析数据时，它首先将数据拆分为行，然后将行拆分为诸如关键字和参数之类的标记。在使用空格分隔格式时，标记之间的分隔符是两个或更多空格，或者是一个或多个制表符。除了正常的ASCII空格之外，任何被视为空格的Unicode字符（例如不间断空格）都可以作为分隔符。分隔标记所使用的空格数量可以变化，只要至少有两个，这样在设置和其他地方对齐数据时就可以使数据更易于理解。 1234567891011121314151617181920*** Settings ***Documentation 使用空格分隔格式的示例。Library OperatingSystem*** Variables ***$&#123;MESSAGE&#125; Hello, world!*** Test Cases ***My Test [Documentation] Example test. Log $&#123;MESSAGE&#125; My Keyword $&#123;CURDIR&#125;Another Test Should Be Equal $&#123;MESSAGE&#125; Hello, world!*** Keywords ***My Keyword [Arguments] $&#123;path&#125; Directory Should Exist $&#123;path&#125; 在这个示例中： *** Settings ***：定义了测试或任务的设置。 Documentation：提供了对测试或任务的描述。 Library：指定了测试或任务中将使用的库。 *** Variables ***：声明了在测试中使用的变量。 $&#123;MESSAGE&#125;：变量的名称，其值为“好，世界！”。 *** Test Cases ***：标记了测试用例的开始。 的测试和 另一个测试：测试用例的名称。 [Documentation]：为测试用例提供了额外的描述。 Log：一个关键字，用于记录信息。 My Keyword：自定义关键字的名称。 Should Be Equal：一个内置关键字，用于断言两个值是否相等。 *** Keywords ***：标记了自定义关键字的开始。 [Arguments]：定义了关键字的参数。 Directory Should Exist：一个内置关键字，用于验证指定路径的目录是否存在。 因为制表符和连续的空格被视为分隔符，所以如果在关键字参数或实际数据的其他位置需要它们，则必须对它们进行转义。可以使用特殊的转义语法，如 \\t表示制表符，\\xA0表示不间断空格，以及内置变量 $&#123;SPACE&#125;和 $&#123;EMPTY&#125;。详情请参阅转义部分。 信息 虽然使用两个空格作为分隔符就足够了，但建议使用四个空格，以便更容易识别分隔符。 注意 在Robot Framework 3.2之前，数据中使用的非ASCII空格在解析过程中会被转换为ASCII空格。现在所有数据都保持原样。 管道分隔格式空格分隔格式的最大问题是在视觉上将关键字与参数分开可能会很棘手。这个问题特别突出，特别是如果关键字需要很多参数和&#x2F;或参数包含空格的情况下。在这种情况下，管道分隔的变体可能会更好，因为它使分隔符更加明显可见。 一个文件可以同时包含空格分隔和管道分隔的行。管道分隔的行通过强制性的前导管道字符进行识别，但行尾的管道是可选的。除了在行的开头和结尾，管道的两侧始终必须至少有一个空格或制表符。不需要对齐管道，但通常这样做会使数据更易于阅读。 12345678910111213141516| *** Settings *** || Documentation | Example using the pipe separated format.| Library | OperatingSystem| *** Variables *** || $&#123;MESSAGE&#125; | Hello, world!| *** Test Cases *** | | || My Test | [Documentation] | Example test. || | Log | $&#123;MESSAGE&#125; || | My Keyword | $&#123;CURDIR&#125; || Another Test | Should Be Equal | $&#123;MESSAGE&#125; | Hello, world!| *** Keywords *** | | || My Keyword | [Arguments] | $&#123;path&#125; || | Directory Should Exist | $&#123;path&#125; | 在使用管道分隔格式时，参数内部的连续空格或制表符不需要转义。同样，空列不需要转义，除非它们位于末尾。然而，在实际测试数据中可能被空格包围的管道必须使用反斜杠进行转义： 123| *** Test Cases *** | | | || Escaping Pipe | $&#123;file count&#125; = | Execute Command | ls -1 *.txt \\| wc -l || | Should Be Equal | $&#123;file count&#125; | 42 | Execute Command 关键字执行了 ls -1 *.txt | wc -l 命令。 ls -1 *.txt 列出了当前目录中所有以 .txt 结尾的文件。 wc -l 统计了文件的行数。 最终，验证了文件的行数是否等于 42。 注意 保留参数中的连续空格和制表符是Robot Framework 3.2的新功能。在此之前，数据中使用的非ASCII空格也会被转换为ASCII空格。 reStructuredText 格式reStructuredText（reST）是一种易于阅读的纯文本标记语法，通常用于Python项目的文档，包括Python本身以及本用户指南。reST文档最常编译为HTML，但也支持其他输出格式。使用reST与Robot Framework结合使用，允许在简洁的文本格式中混合富格式文档和测试数据，这样就可以使用简单的文本编辑器、差异工具和源代码控制系统轻松地处理。 注意 使用reStructuredText文件与Robot Framework需要安装Python docutils模块。 当使用Robot Framework与reStructuredText文件时，普通的Robot Framework数据被嵌入到所谓的代码块中。在标准reST中，代码块使用代码指令进行标记，但Robot Framework还支持Sphinx工具使用的code-block或sourcecode指令。 reStructuredText 示例123456789101112131415161718192021222324252627282930313233343536373839reStructuredText example------------------------This text is outside code blocks and thus ignored... code:: robotframework *** Settings *** Documentation Example using the reStructuredText format. Library OperatingSystem *** Variables *** $&#123;MESSAGE&#125; Hello, world! *** Test Cases *** My Test [Documentation] Example test. Log $&#123;MESSAGE&#125; My Keyword $&#123;CURDIR&#125; Another Test Should Be Equal $&#123;MESSAGE&#125; Hello, world!Also this text is outside code blocks and ignored. Code blocks notcontaining Robot Framework data are ignored as well... code:: robotframework # Both space and pipe separated formats are supported. | *** Keywords *** | | | | My Keyword | [Arguments] | $&#123;path&#125; | | | Directory Should Exist | $&#123;path&#125; |.. code:: python # This code block is ignored. def example(): print(&#x27;Hello, world!&#x27;) Robot Framework支持使用 .robot.rst、.rst和 .rest扩展名的reStructuredText文件。为了避免解析不相关的reStructuredText文件，当执行目录时，默认情况下仅解析具有 .robot.rst扩展名的文件。可以通过使用 --parseinclude或 --extension选项来启用解析具有其他扩展名的文件。 当Robot Framework解析reStructuredText文件时，忽略严重级别以下的错误，以避免可能的非标准指令和其他标记的噪音。这也可能隐藏了真正的错误，但在通常使用reStructuredText工具处理文件时可以看到它们。 注意 自动解析 .robot.rst文件是Robot Framework 6.1的新功能。 JSON 格式Robot Framework 支持 JSON 格式的数据。这种格式主要为工具开发者设计，而不是为常规的 Robot Framework 用户设计，因此不建议手动编辑。它的主要用途包括： 在进程和机器之间传输数据。可以在一台机器上将套件转换为 JSON，然后在其他地方重新创建。 将可能是嵌套套件的套件，从常规的 Robot Framework 数据构建成单个的 JSON 文件，这样解析起来更快。 为生成测试或任务的外部工具提供替代的数据格式。 注意 JSON 数据支持是在 Robot Framework 6.1 中新增的，未来的 Robot Framework 版本中可能会进行增强。 将套件转换为 JSON可以使用 TestSuite.to_json 方法将套件结构序列化为 JSON。如果没有参数，它会返回 JSON 数据作为字符串，但它也接受一个路径或一个打开的文件，以及与 JSON 格式相关的配置选项： 12345678910from robot.running import TestSuite# 基于文件系统上的数据创建套件。suite = TestSuite.from_file_system(&#x27;/path/to/data&#x27;)# 获取 JSON 数据作为字符串。data = suite.to_json()# 将 JSON 数据保存到文件中，自定义缩进。suite.to_json(&#x27;data.rbt&#x27;, indent=2) 如果更愿意使用 Python 数据，然后自己将其转换为 JSON 或其他格式，可以使用 TestSuite.to_dict。 从 JSON 创建套件可以使用 TestSuite.from_json 方法从 JSON 数据构建套件。它既可以处理 JSON 字符串，也可以处理 JSON 文件的路径： 12345678910from robot.running import TestSuite# 从文件中的 JSON 数据创建套件。suite = TestSuite.from_json(&#x27;data.rbt&#x27;)# 从 JSON 字符串创建套件。suite = TestSuite.from_json(&#x27;&#123;&quot;name&quot;: &quot;Suite&quot;, &quot;tests&quot;: [&#123;&quot;name&quot;: &quot;Test&quot;&#125;]&#125;&#x27;)# 执行套件。注意，日志和报告需要单独创建。suite.run(output=&#x27;example.xml&#x27;) 如果有一个 Python 字典的数据，可以使用 TestSuite.from_dict。无论套件是如何重新创建的，它只存在于内存中，原始的数据文件在文件系统上不会被重新创建。 如上例所示，可以使用 TestSuite.run 方法执行创建的套件。然而，直接执行 JSON 文件可能更容易，如下一节所述。 执行 JSON 文件当使用 robot 命令执行测试或任务时，带有自定义 .rbt 扩展名的 JSON 文件会被自动解析。这包括运行像 robot tests.rbt 这样的单个 JSON 文件，以及运行包含 .rbt 文件的目录。如果更愿意使用标准的 .json 扩展名，需要配置哪些文件需要解析。 调整套件源从 TestSuite.to_json 和 TestSuite.to_dict 获取的数据中的套件源是绝对格式的。如果稍后在不同的机器上重新创建套件，源可能不匹配该机器上的目录结构。为了避免这种情况，可以使用 TestSuite.adjust_source 方法在获取数据之前使套件源相对化，并在套件重新创建后添加正确的根目录： 12345678910from robot.running import TestSuite# 创建套件，调整源并转换为 JSON。suite = TestSuite.from_file_system(&#x27;/path/to/data&#x27;)suite.adjust_source(relative_to=&#x27;/path/to&#x27;)suite.to_json(&#x27;data.rbt&#x27;)# 在其他地方重新创建套件并相应地调整源。suite = TestSuite.from_json(&#x27;data.rbt&#x27;)suite.adjust_source(root=&#x27;/new/path/to&#x27;) JSON 结构在套件文件中创建的导入项、变量和关键字都包含在生成的 JSON 中，以及测试和任务。具体的 JSON 结构在 running.json 架构文件中有文档说明。 数据解析规则忽略的数据当 Robot Framework 解析测试数据文件时，它会忽略： 第一个测试数据部分之前的所有数据。 评论部分中的数据。 所有空行。 当使用管道分隔格式时，行尾的所有空单元格。 当不用于转义时，所有的单个反斜杠（\\）。 当它是单元格的第一个字符时，井号（#）后面的所有字符。这意味着可以使用井号在测试数据中输入注释。 当 Robot Framework 忽略一些数据时，这些数据在任何生成的报告中都不可用，此外，大多数与 Robot Framework 一起使用的工具也会忽略它们。要添加在 Robot Framework 输出中可见的信息，请将其放在测试用例或套件的文档或其他元数据中，或使用 BuiltIn 关键字 Log 或 Comment 进行记录。 转义Robot Framework 测试数据中的转义字符是反斜杠 \\，此外，内置变量 EMPTY和{SPACE} 通常也可以用于转义。下面的各节将讨论不同的转义机制。 转义特殊字符反斜杠字符可以用来转义特殊字符，以便使用它们的字面值: 字符 含义 示例 $ 美元符号，不会开始标量变量。 ${notvar} @ 电子邮件符号，不会开始列表变量。 @{notvar} &amp; 和号，不会开始字典变量。 &amp;{notvar} % 百分号，不会开始环境变量。 %{notvar} # 井号，不会开始注释。 # not comment = 等号，不会成为命名参数语法的一部分。 not=named | 管道字符，不是管道分隔格式的分隔符。 ls -1 *.txt| wc -l \\ 反斜杠字符，不会转义任何东西。 c:\\temp, \\${var} 形成转义序列反斜杠字符也允许创建特殊的转义序列，这些序列被识别为在测试数据中难以或无法创建的字符: 转义序列： 序列 含义 示例 \\n 换行符 first line\\n2nd line \\r 回车符 text\\rmore text \\t 制表符 text\\tmore text \\xhh 十六进制值为 hh 的字符 空字节：\\x00，ä：\\xE4 \\uhhhh 十六进制值为 hhhh 的字符 雪人：\\u2603 \\Uhhhhhhhh 十六进制值为 hhhhhhhh 的字符 爱情旅馆：\\U0001f3e9 注意 在测试数据中创建的所有字符串，包括像 \\x02 这样的字符，都是 Unicode，如果需要，必须显式地转换为字节字符串。这可以通过使用 BuiltIn 和 String 库中的 Convert To Bytes 或 Encode String To Bytes 关键字来完成，或者在 Python 代码中使用类似于 value.encode(&#39;UTF-8&#39;) 的语句来完成。 注意 如果在 \\x、\\u 或 \\U 转义中使用了无效的十六进制值，最终的结果是原始值，但没有反斜杠字符。例如，\\xAX（不是十六进制）和 \\U00110000（值过大）分别会得到 xAX 和 U00110000。尽管如此，这种行为在未来可能会改变。 注意 如果需要操作系统依赖的行终止符，可以使用内置变量 ${\\n}（在 Windows 上是 \\r\\n，在其他地方是 \\n）。 处理空值当使用空格分隔格式时，用作分隔符的空格数量可以变化，因此除非进行转义，否则无法识别空值。空单元格可以用反斜杠字符或内置变量 $&#123;EMPTY&#125; 进行转义。通常推荐使用后者，因为它更容易理解。 12345678*** Test Cases ***Using backslash Do Something first arg \\ Do Something \\ second argUsing $&#123;EMPTY&#125; Do Something first arg $&#123;EMPTY&#125; Do Something $&#123;EMPTY&#125; second arg 当使用管道分隔格式时，只有当空值位于行尾时，才需要对空值进行转义： 123456| *** Test Cases *** | | | || Using backslash | Do Something | first arg | \\ || | Do Something | | second arg || | | | || Using $&#123;EMPTY&#125; | Do Something | first arg | $&#123;EMPTY&#125; || | Do Something | | second arg | 处理空格空格，尤其是连续的空格，作为关键字的参数或者其他需要的一部分，会有两个问题： 当使用空格分隔格式时，两个或更多连续的空格被视为分隔符。 当使用管道分隔格式时，忽略前导和尾随空格。 在这些情况下，需要对空格进行转义。与转义空值类似，可以通过使用反斜杠字符或使用内置变量 $&#123;SPACE&#125; 来实现。 转义空格示例： 使用反斜杠转义 使用 $&#123;SPACE&#125; 转义 注释 \\ leading space $&#123;SPACE&#125;leading space trailing space \\ trailing space $&#123;SPACE&#125; 反斜杠必须在空格后面。 \\ \\ $&#123;SPACE&#125; 两边都需要反斜杠。 consecutive \\ \\ spaces consecutive $&#123;SPACE * 3&#125;spaces 使用扩展变量语法。 如上例所示，使用 $&#123;SPACE&#125; 变量通常使测试数据更容易理解。当需要多个空格时，它与扩展变量语法结合使用特别方便。 将数据分割到多行如果一行的数据过多，可以将其分割，并使用省略号（…）开始连续的行。省略号可以缩进以匹配起始行的缩进，并且必须始终跟随正常的测试数据分隔符。 在大多数地方，分割的行与未分割的行具有完全相同的语义。此规则的例外是套件、测试和关键字文档以及套件元数据。对于它们，分割的值会自动用换行符连接在一起，以便创建多行值。 ... 语法也允许在变量部分分割变量。当长标量变量（例如 $&#123;STRING&#125;）被分割到多行时，最终的值是通过将行连接在一起得到的。默认的分隔符是空格，但可以通过以 SEPARATOR=&lt;sep&gt; 开始值来更改。 以下两个示例说明了分割行，它们包含了完全相同的数据，但一个没有分割，一个进行了分割: 123456789101112131415*** Settings ***Documentation Here we have documentation for this suite.\\nDocumentation is often quite long.\\n\\nIt can also contain multiple paragraphs.Default Tags default tag 1 default tag 2 default tag 3 default tag 4 default tag 5*** Variables ***$&#123;STRING&#125; This is a long string. It has multiple sentences. It does not have newlines.$&#123;MULTILINE&#125; This is a long multiline string.\\nThis is the second line.\\nThis is the third and the last line.@&#123;LIST&#125; this list is quite long and items in it can also be long&amp;&#123;DICT&#125; first=This value is pretty long. second=This value is even longer. It has two sentences.*** Test Cases ***Example [Tags] you probably do not have this many tags in real life Do X first argument second argument third argument fourth argument fifth argument sixth argument $&#123;var&#125; = Get X first argument passed to this keyword is pretty long second argument passed to this keyword is long too 123456789101112131415161718192021222324252627282930*** Settings ***Documentation Here we have documentation for this suite.... Documentation is often quite long....... It can also contain multiple paragraphs.Default Tags default tag 1 default tag 2 default tag 3... default tag 4 default tag 5*** Variables ***$&#123;STRING&#125; This is a long string.... It has multiple sentences.... It does not have newlines.$&#123;MULTILINE&#125; SEPARATOR=\\n... This is a long multiline string.... This is the second line.... This is the third and the last line.@&#123;LIST&#125; this list is quite long and... items in it can also be long&amp;&#123;DICT&#125; first=This value is pretty long.... second=This value is even longer. It has two sentences.*** Test Cases ***Example [Tags] you probably do not have this many ... tags in real life Do X first argument second argument third argument ... fourth argument fifth argument sixth argument $&#123;var&#125; = Get X ... first argument passed to this keyword is pretty long ... second argument passed to this keyword is long too 本地化Robot Framework 的本地化工作始于 Robot Framework 6.0，它允许翻译部分标题、设置、在行为驱动开发（BDD）中使用的 Given&#x2F;When&#x2F;Then 前缀，以及在自动布尔参数转换中使用的 true 和 false 字符串。未来计划扩展本地化支持，例如，到日志和报告，甚至可能也包括控制结构。 本节解释如何激活语言，支持哪些内置语言，如何创建自定义语言文件，以及如何贡献新的翻译。 启用语言使用命令行选项 激活语言的主要机制是使用 --language 选项从命令行指定它们。当启用内置语言时，可以使用语言名称（如 Chinese Simplified）或语言代码（如 fi）。名称和代码都不区分大小写和空格，也忽略连字符（-）。要启用多种语言，需要多次使用 --language 选项： 12robot --language Chinese Simplified testit.robotrobot --language pt --language ptbr testes.robot 当激活自定义语言文件时，也使用相同的 --language 选项。对于它们，值可以是文件的路径，或者，如果文件在模块搜索路径中，可以是模块名称： 12robot --language Custom.py tests.robotrobot --language MyLang tests.robot 出于向后兼容性的原因，以及为了支持部分翻译，英语总是自动激活的。未来的版本可能允许禁用它。 预文件配置 也可以直接在数据文件中启用语言，方法是在任何部分标题之前有一行 Language: &lt;value&gt;（不区分大小写）。冒号后的值与 --language 选项的解释方式相同： 1234Language: Chinese Simplified*** Asetukset ***Dokumentaatio Example using Chinese Simplified. 如果需要启用多种语言，可以重复 Language: 行。这些配置行不能在注释中，所以像 # Language: Chinese Simplified 这样的内容没有效果。 由于技术限制，每个文件的语言配置也会影响后续文件的解析以及整个执行。这种行为可能在未来会改变，因此不应依赖它。如果使用每个文件的配置，应该在所有文件中使用它，或者使用 --language 选项全局启用语言。 自定义语言文件如果需要的语言不是内置语言，或者想为某些特定需求创建一个完全自定义的语言，可以轻松地创建一个自定义语言文件。语言文件是 Python 文件，包含一个或多个语言定义，当语言文件被使用时，所有的语言定义都会被加载。语言定义是通过扩展 robot.api.Language 基类并根据需要覆盖类属性来创建的： 1234567from robot.api import Languageclass Example(Language): test_cases_header = &#x27;Validations&#x27; tags_setting = &#x27;Labels&#x27; given_prefixes = [&#x27;Assuming&#x27;] true_strings = [&#x27;OK&#x27;, &#x27;\\N&#123;THUMBS UP SIGN&#125;&#x27;] 假设上述代码位于 example.py 文件中，当激活语言文件时，可以使用该文件的路径或仅使用模块名称 example。 上述示例只添加了一些可能的翻译。这是可以的，因为英语总是会自动启用。大多数值必须指定为字符串，但 BDD 前缀和 true&#x2F;false 字符串允许多个值，并且必须给出列表。有关更多示例，请参见 Robot Framework 的内部语言模块，该模块包含 Language 类以及所有内置语言定义。 创建测试用例当创建测试用例时，通常会采用以下的测试用例语法。将测试用例组织成测试套件，可以使用套件文件和套件目录，具体内容请参阅下一节。 当在使用机器人框架进行除了测试自动化以外的其他自动化任务时，建议创建任务而不是测试。任务的语法在大部分情况下与测试的语法相同，不同之处将在创建任务部分进行解释。 测试用例语法基本语法测试用例是在测试用例部分中从可用关键字构建的。关键字可以从测试库或资源文件导入，或者在测试用例文件本身的关键字部分中创建。 测试用例部分的第一列包含测试用例名称。测试用例从此列中有内容的行开始，并继续到下一个测试用例名称或部分的结束。在部分标题和第一个测试之间有内容是错误的。 第二列通常有关键字名称。此规则的一个例外是从关键字返回值设置变量，当第二列和可能的后续列包含变量名称，并且关键字名称位于它们之后。在任一情况下，关键字名称后的列包含指定关键字的可能参数。 12345678910111213*** Test Cases ***Valid Login Open Login Page Input Username demo Input Password mode Submit Credentials Welcome Page Should Be OpenSetting Variables Do Something first argument second argument $&#123;value&#125; = Get Some Value Should Be Equal $&#123;value&#125; Expected valueNote 注意 虽然测试用例名称可以包含任何字符，但通常不建议使用 ? 和尤其是 *，因为它们在选择测试用例时被视为通配符。例如，尝试只运行名为 Example * 的测试，如 --test &#39;Example *&#39;，实际上会运行以 Example 开头的任何测试。 在测试用例部分的设置测试用例也可以有自己的设置。设置名称总是在第二列，通常是关键字的位置，它们的值在后续的列中。设置名称周围有方括号，以便将它们与关键字区分开来。下面列出了可用的设置，并在本节后面进行了解释。 [Documentation] [文档] 用于指定测试用例文档。 [Setup], [Teardown] [设置], [拆卸] 指定测试设置和拆卸。 [Tags] [标签] 用于标记测试用例。 [Template] [模板] 指定要使用的模板关键字。测试本身将只包含用作该关键字参数的数据。 [Timeout] [超时] 用于设置测试用例超时。超时在其自己的部分中进行了讨论。 注意 设置名称不区分大小写，但推荐使用上述格式。设置曾经也不区分空格，但在 Robot Framework 3.1 中已被弃用，尝试使用像 [T a g s] 这样的东西会在 Robot Framework 3.2 中引发错误。仍然允许在括号和名称之间可能存在的空格（例如 [ 标签 ]）。 带有设置的测试用例示例： 12345*** Test Cases ***Test With Settings [Documentation] Another dummy test [Tags] dummy owner-johndoe Log Hello, world! 在设置部分的测试用例相关设置设置部分可以有以下与测试用例相关的设置。这些设置主要是前面列出的特定于测试用例的设置的默认值。 测试设置，测试拆卸 测试设置和拆卸的默认值。 测试标签 套件中所有测试将获得的标签，除了它们可能自己的标签。 测试模板 要使用的默认模板关键字。 测试超时 测试用例超时的默认值。超时在其自己的部分中进行了讨论。 [Test Setup, Test Teardown] [测试设置，测试拆卸] 默认值为测试设置和拆卸。 [Test Tags] [测试标签] 套件中所有测试将获得的标签，除了它们可能自己的标签。 [Test Template] [测试模板] 要使用的默认模板关键字。 [Test Timeout] [测试超时] 测试用例超时的默认值。超时在其自己的部分中进行了讨论。 使用参数前面的例子已经展示了关键字如何接受不同的参数，本节将更全面地讨论这一重要功能。如何实际实现带有不同参数的用户定义关键字和库关键字将在后续章节中讨论。 关键字可以接受零个或多个参数，某些参数可能具有默认值。关键字接受哪些参数取决于其实现，通常最好的信息来源是关键字的文档。在本节的例子中，文档预期是使用Libdoc工具生成的，但相同的信息也可在使用通用文档工具如pydoc生成的文档中找到。 位置参数大多数关键字都有一定数量的参数，必须始终给出。在关键字文档中，这通过指定用逗号分隔的参数名表示，如 first, second, third。在这种情况下，参数名实际上并不重要，除了它们应该解释参数的作用，但重要的是必须有与文档中指定的完全相同数量的参数。使用的参数太少或太多都会导致错误。 下面的测试使用了来自OperatingSystem 库的关键字 Create Directory 和 Copy File。它们的参数分别指定为 path 和 source, destination，这意味着它们分别接受一个和两个参数。最后一个关键字，来自BuiltIn的 No Operation，不接受任何参数。 12345*** Test Cases ***Example Create Directory $&#123;TEMPDIR&#125;/stuff Copy File $&#123;CURDIR&#125;/file.txt $&#123;TEMPDIR&#125;/stuff No Operation 默认值参数通常具有默认值，可以给出或不给出。在文档中，默认值通常与参数名称用等号分隔，如 name=default value。所有参数都有默认值是可能的，但在具有默认值的参数之后不能有任何位置参数。 使用默认值的示例如下所示，其中使用了 Create File 关键字，其参数为 path、content= 和 encoding=UTF-8。尝试在没有任何参数或多于三个参数的情况下使用它将无法正常工作。 12345*** Test Cases ***Example Create File $&#123;TEMPDIR&#125;/empty.txt Create File $&#123;TEMPDIR&#125;/utf-8.txt Hyvä esimerkki Create File $&#123;TEMPDIR&#125;/iso-8859-1.txt Hyvä esimerkki ISO-8859-1 可变数量的参数也有可能某个关键字接受任意数量的参数。这些所谓的变长参数可以与必需参数和具有默认值的参数组合使用，但它们始终在它们之后给出。在文档中，它们的参数名称前面有一个星号，如 *varargs。 例如，操作系统库中的 Remove Files 和 Join Paths 关键字具有参数 paths 和 base、parts，分别。前者可以接受任意数量的参数，但后者至少需要一个参数。 1234*** Test Cases ***Example Remove Files $&#123;TEMPDIR&#125;/f1.txt $&#123;TEMPDIR&#125;/f2.txt $&#123;TEMPDIR&#125;/f3.txt @&#123;paths&#125; = Join Paths $&#123;TEMPDIR&#125; f1.txt f2.txt f3.txt f4.txt 在这个示例中： *** Test Cases ***：定义了测试用例的开始。 Example：测试用例的名称。 Remove Files $&#123;TEMPDIR&#125;/f1.txt $&#123;TEMPDIR&#125;/f2.txt $&#123;TEMPDIR&#125;/f3.txt：执行了一个关键字，删除了指定的文件。 @&#123;paths&#125; = Join Paths $&#123;TEMPDIR&#125; f1.txt f2.txt f3.txt f4.txt：执行了另一个关键字，将路径组合在一起。 命名参数命名参数语法使得使用具有默认值的参数更加灵活，并允许明确标记某个参数值的含义。从技术上讲，命名参数的工作方式与Python中的关键字参数完全相同。 基本语法可以通过在值前加上参数名（如 arg=value）来命名给关键字的参数。当多个参数具有默认值时，这特别有用，因为可以只命名一些参数，让其他参数使用其默认值。例如，如果一个关键字接受参数 arg1=a，arg2=b，arg3=c，并且它被调用时只有一个参数 arg3=override，那么参数 arg1 和 arg2 将获得其默认值，但 arg3 将获得值 override。如果这听起来很复杂，下面的命名参数示例应该会使其更清晰。 命名参数语法对大小写和空格都很敏感。前者意味着，如果有一个参数 arg，必须像 arg=value 这样使用它，而 Arg=value 或 ARG=value 都不行。后者意味着，在 = 符号前不允许有空格，可能在其后的空格将被视为给定值的一部分。 当命名参数语法与用户关键字一起使用时，必须在不带 $&#123;&#125; 装饰的情况下给出参数名。例如，带有参数 $&#123;arg1&#125;=first，$&#123;arg2&#125;=second 的用户关键字必须像 arg2=override 这样使用。 在命名参数之后使用普通位置参数，例如 | Keyword | arg=value | positional |，是不行的。命名参数的相对顺序并不重要。 命名参数与变量在命名参数的名称和值中都可以使用变量。如果值是单个标量变量，它将按原样传递给关键字。这允许在使用命名参数语法时，也可以使用任何对象，而不仅仅是字符串，作为值。例如，调用像 arg=$&#123;object&#125; 这样的关键字将把变量 $&#123;object&#125; 传递给关键字，而不会将其转换为字符串。 如果在命名参数名称中使用变量，变量在与参数名称匹配之前就会被解析。 命名参数语法要求在关键字调用中直接写入等号。这意味着，即使变量具有像 foo=bar 这样的值，单独的变量也永远不会触发命名参数语法。这一点在将关键字包装到其他关键字中时尤其需要记住。例如，如果一个关键字接受像 @&#123;args&#125; 这样的变量数量的参数，并使用相同的 @&#123;args&#125; 语法将所有参数传递给另一个关键字，那么在调用端使用的可能的 named=arg 语法将不会被识别。下面的示例进行了说明。 12345678*** Test Cases ***Example Run Program shell=True # 这将不会作为一个命名参数传递给 Run Process*** Keywords ***Run Program [Arguments] @&#123;args&#125; Run Process program.py @&#123;args&#125; # 在 @&#123;args&#125; 内部不会识别命名参数 如果关键字需要接受并传递任何命名参数，它必须被改变以接受自由命名参数。参见自由命名参数示例，了解一个可以传递位置参数和命名参数的包装关键字版本。 转义命名参数语法命名参数语法仅在等号前的参数部分与关键字的某个参数匹配时使用。可能存在一个位置参数，其字面值如 foo=quux，并且还有一个名为 foo 的无关参数。在这种情况下，参数 foo 可能错误地获取值 quux，或者更可能的是，出现语法错误。 在这些偶尔出现的匹配错误的情况下，可以使用反斜杠字符来转义语法，如 foo\\=quux。现在，参数将获得字面值 foo=quux。请注意，如果没有名为 foo 的参数，那么不需要转义，但是因为它使情况更加明确，所以可能仍然是个好主意。 命名参数支持的位置如前所述，命名参数语法适用于关键字。除此之外，它还适用于导入库时。 用户关键字和大多数测试库都支持命名参数。唯一的例外是明确使用位置参数的Python关键字。 命名参数示例以下示例演示了如何在库关键字、用户关键字以及导入 Telnet 测试库时使用命名参数语法。 12345678910111213*** Settings ***Library Telnet prompt=$ default_log_level=DEBUG*** Test Cases ***Example Open connection 10.0.0.42 port=$&#123;PORT&#125; alias=example List files options=-lh List files path=/tmp options=-l*** Keywords ***List files [Arguments] $&#123;path&#125;=. $&#123;options&#125;= Execute command ls $&#123;options&#125; $&#123;path&#125; 自由命名参数Robot Framework支持自由命名参数，通常也被称为自由关键字参数或kwargs，类似于Python支持的**kwargs。这意味着一个关键字可以接收所有使用命名参数语法（name=value）的参数，并且不匹配关键字签名中指定的任何参数。 自由命名参数由与普通命名参数相同的关键字类型支持。关键字如何指定它们接受自由命名参数取决于关键字类型。例如，基于Python的关键字简单地使用**kwargs，用户关键字使用 &amp;&#123;kwargs&#125;。 自由命名参数支持变量，就像命名参数一样。在实践中，这意味着变量可以同时用在名称和值中，但是转义符必须始终直接可见。例如，只要使用的变量存在，foo=$&#123;bar&#125;和 $&#123;foo&#125;=$&#123;bar&#125;都是有效的。额外的限制是自由参数名称必须始终是字符串。 示例作为使用自由命名参数的第一个示例，看一下Process库中的Run Process关键字。它有一个签名 command，*arguments，**configuration，这意味着它接收要执行的命令（command），其参数作为可变数量的参数（*arguments）以及最后的可选配置参数作为自由命名参数（**configuration）。下面的示例还显示了变量与自由关键字参数一起工作的方式，就像使用命名参数语法时一样。 1234*** Test Cases ***Free Named Arguments Run Process program.py arg1 arg2 cwd=/home/user Run Process program.py argument shell=True env=$&#123;ENVIRON&#125; 请参阅创建测试库下的自由关键字参数（**kwargs）部分，以获取有关在自定义测试库中使用自由命名参数语法的更多信息。 作为第二个示例，创建一个包装用户关键字，用于运行上述示例中的program.py。包装关键字Run Program接受所有位置和命名参数，并将它们连同要执行的命令名称一起传递给Run Process。 123456789*** Test Cases ***Free Named Arguments Run Program arg1 arg2 cwd=/home/user Run Program argument shell=True env=$&#123;ENVIRON&#125;*** Keywords ***Run Program [Arguments] @&#123;args&#125; &amp;&#123;config&#125; Run Process program.py @&#123;args&#125; &amp;&#123;config&#125; 仅命名参数从Robot Framework 3.1开始，关键字可以接受必须始终使用命名参数语法进行命名的参数。例如，如果一个关键字接受一个仅命名参数 example，那么它必须始终像 example=value 这样使用，而不能仅使用 value。这种语法受到了Python 3支持的仅关键字参数语法的启发。 在大多数情况下，仅命名参数的工作方式与命名参数相同。主要的区别是，使用静态库API实现的Python 2库不支持此语法。 作为使用用户关键字的仅命名参数的一个示例，下面是上述自由命名参数示例中的Run Program的一个变体，它只支持配置shell： 123456789*** Test Cases ***Named-only Arguments Run Program arg1 arg2 # &#x27;shell&#x27; 是 False (默认) Run Program argument shell=True # &#x27;shell&#x27; 是 True*** Keywords ***Run Program [Arguments] @&#123;args&#125; $&#123;shell&#125;=False Run Process program.py @&#123;args&#125; shell=$&#123;shell&#125; 嵌入到关键字名称中的参数指定参数的一种完全不同的方法是将参数嵌入到关键字名称中。这种语法由测试库关键字和用户关键字都支持。 失败测试用例失败时如果测试用例使用的任何关键字失败，测试用例就会失败。通常，这意味着该测试用例的执行将停止，可能执行测试拆解，然后从下一个测试用例继续执行。如果不希望停止测试执行，也可以使用特殊的可继续失败。 错误消息分配给失败的测试用例的错误消息直接来自失败的关键字。通常，错误消息是由关键字本身创建的，但是一些关键字允许配置它们。 在某些情况下，例如当使用可继续失败时，一个测试用例可能会失败多次。在这种情况下，最终的错误消息是通过组合各个错误得到的。非常长的错误消息会自动从中间切断，以使报告更易于阅读，但完整的错误消息始终作为失败关键字的消息在日志文件中可见。 默认情况下，错误消息是普通文本，但它们可以包含HTML格式。这通过在错误消息开始处使用标记字符串 HTML 来启用。这个标记将从报告和日志中显示的最终错误消息中删除。下面的第二个示例显示了在自定义消息中使用HTML。 1234567*** Test Cases ***Normal Error Fail 这是一个相当无聊的例子...HTML Error $&#123;number&#125; = Get Number Should Be Equal $&#123;number&#125; 42 *HTML* 数字不是的&lt;b&gt;魔法&lt;/b&gt;数字。 测试用例名称和文档测试用例名称直接来自测试用例部分：它就是输入到测试用例列中的内容。一个测试套件中的测试用例应该有唯一的名称。关于这一点，也可以在测试本身中使用自动变量 $&#123;TEST_NAME&#125; 来引用测试名称。无论何时执行测试，包括所有用户关键字，以及测试设置和测试拆解，它都是可用的。 从Robot Framework 3.2开始，测试用例名称中可能的变量会被解析，以便最终名称将包含变量值。如果变量不存在，其名称将保持不变。 123456*** Variables ***$&#123;MAX AMOUNT&#125; $&#123;5000000&#125;*** Test Cases ***Amount cannot be larger than $&#123;MAX AMOUNT&#125; # ... [Documentation] 设置允许为测试用例设置自由形式的文档。该文本将显示在命令行输出和生成的日志和报告中。如果文档过长，可以将其分割成多行。可以使用简单的HTML格式，并且可以使用变量使文档动态化。可能不存在的变量将保持不变。 1234567891011121314151617181920212223*** Test Cases ***Simple [Documentation] 简单且短小的文档。 No OperationMultiple lines [Documentation] 文档的第一行。 ... ... 文档在这里继续。这些行在HTML输出中形成 ... 一个段落。 No OperationFormatting [Documentation] ... 这个列表有： ... - *粗体* ... - _斜体_ ... - 链接: http://robotframework.org No OperationVariables [Documentation] 在 $&#123;HOST&#125; 上由 $&#123;USER&#125; 执行 No Operation 测试用例有清晰和描述性的名称是很重要的，而在这种情况下，它们通常不需要任何文档。如果测试用例的逻辑需要文档化，这通常是一个信号，表示测试用例中的关键字需要更好的名称，它们需要被增强，而不是添加额外的文档。最后，元数据，如上述最后一个示例中的环境和用户信息，通常最好使用标签来指定。 标记测试用例在Robot Framework中使用标签是一种简单而强大的机制，用于分类测试用例和用户关键字。标签是自由文本，Robot Framework本身对它们没有特殊的含义，除了下面讨论的保留标签。标签至少可以用于以下目的： 它们显示在测试报告、日志以及测试数据中，因此它们为测试用例提供元数据。 基于它们自动收集关于测试用例（总数、通过、失败和跳过）的统计信息。 它们可以用于包含和排除以及跳过测试用例。 有多种方式可以为测试用例指定标签，如下所述： 在设置部分中的测试标签设置 具有此设置的测试用例文件中的所有测试始终获得指定的标签。如果在套件初始化文件中使用此设置，所有子套件中的测试都会获得这些标签。 每个测试用例的[Tags]设置 测试将获得这些标签，除了使用测试标签设置指定的标签。[Tags]设置还允许使用-tag语法删除使用测试标签设置的标签。 –settag命令行选项 所有测试都会获得此选项设置的标签，除了它们在其他地方获得的标签。 Set Tags，Remove Tags，Fail和Pass Execution关键字 这些BuiltIn关键字可以用于在测试执行期间动态操作标签。 示例： 1234567891011121314151617181920212223242526272829303132333435*** Settings ***git fetch originTest Tags requirement: 42 smoke*** Variables ***$&#123;HOST&#125; 10.0.1.42*** Test Cases ***No own tags [Documentation] 测试有标签 &#x27;requirement: 42&#x27; 和 &#x27;smoke&#x27;。 No OperationOwn tags [Documentation] 测试有标签 &#x27;requirement: 42&#x27;，&#x27;smoke&#x27; 和 &#x27;not ready&#x27;。 [Tags] not ready No OperationOwn tags with variable [Documentation] 测试有标签 &#x27;requirement: 42&#x27;，&#x27;smoke&#x27; 和 &#x27;host: 10.0.1.42&#x27;。 [Tags] host: $&#123;HOST&#125; No OperationRemove common tag [Documentation] 测试只有标签 &#x27;requirement: 42&#x27;。 [Tags] -smoke No OperationRemove common tag using a pattern [Documentation] 测试只有标签 &#x27;smoke&#x27;。 [Tags] -requirement: * No OperationSet Tags and Remove Tags keywords [Documentation] 这个测试有标签 &#x27;smoke&#x27;，&#x27;example&#x27; 和 &#x27;another&#x27;。 Set Tags example another Remove Tags requirement: * 如示例所示，可以使用变量创建标签，但否则它们保留数据中使用的确切名称。当比较标签时，例如，收集统计信息，选择要执行的测试，或者删除重复项，比较是大小写、空格和下划线不敏感的。 如上述示例所示，使用-tag语法删除标签支持简单的模式，如-requirement: *。以连字符开头的标签除了在[Tags]设置中没有其他特殊含义。如果需要使用[Tags]设置一个以连字符开头的标签，可以使用转义格式，如-tag。 注意 测试标签设置是在Robot Framework 6.0中新增的。早期版本支持Force Tags和Default Tags设置，这将在下一节中讨论。 注意 删除常见标签的-tag语法是在Robot Framework 7.0中新增的。 弃用 Force Tags 和 Default Tags在Robot Framework 6.0之前，可以使用两种不同的设置在设置部分为测试指定标签： Force Tags 所有测试无条件地获得这些标签。这与现在的Test Tags完全相同。 Default Tags 所有测试默认获得这些标签。如果测试有[Tags]，它将不会获得这些标签。 这两种设置仍然可以工作，但它们被认为是已弃用的。将来会添加一个可见的弃用警告，最可能在Robot Framework 8.0中，最终这些设置将被删除。可以使用像Tidy这样的工具来简化过渡。 更新Force Tags只需要将其重命名为Test Tags。Default Tags设置将被完全删除，但在Robot Framework 7.0中引入的-tag功能提供了相同的基础功能。下面的示例演示了所需的更改。 旧语法： 123456789101112131415161718*** Settings ***Force Tags allDefault Tags default*** Test Cases ***Common only [Documentation] 测试有标签 &#x27;all&#x27; 和 &#x27;default&#x27;。 No OperationNo default [Documentation] 测试只有标签 &#x27;all&#x27;。 [Tags] No OperationOwn and no default [Documentation] 测试有标签 &#x27;all&#x27; 和 &#x27;own&#x27;。 [Tags] own No Operation 新语法： 1234567891011121314151617*** Settings ***Test Tags all default*** Test Cases ***Common only [Documentation] 测试有标签 &#x27;all&#x27; 和 &#x27;default&#x27;。 No OperationNo default [Documentation] 测试只有标签 &#x27;all&#x27;。 [Tags] -default No OperationOwn and no default [Documentation] 测试有标签 &#x27;all&#x27; 和 &#x27;own&#x27;。 [Tags] own -default No Operation 保留标签用户通常可以自由地使用在他们的上下文中工作的任何标签。然而，有一些标签对于Robot Framework本身有预定义的含义，用它们来做其他用途可能会有意想不到的结果。Robot Framework现在和将来所有的特殊标签都有 robot: 前缀。为了避免问题，用户因此不应该使用任何带有这个前缀的标签，除非实际激活特殊功能。当前的保留标签列在下面，但是未来可能会添加更多这样的标签。 robot:continue-on-failure 123和 robot:recursive-continue-on-failure 1234 - 用于启用继续失败模式。- ``` robot:stop-on-failure 和 1robot:recursive-stop-on-failure - 用于禁用继续失败模式。 robot:skip-on-failure 1234 - 如果测试失败，则标记为跳过。- ``` robot:skip - 无条件跳过测试。 robot:exclude 1234 - 无条件排除测试。- ``` robot:private - 标记关键字为私有。 robot:no-dry-run 1234 - 标记关键字在干运行模式下不执行。- ``` robot:exit - 当执行停止时，自动添加到测试中。 robot:flatten 123456789101112131415161718192021222324252627282930313233343536373839404142434445 - 在执行时间启用平铺关键字。从RobotFramework 4.1开始，默认情况下在标签统计中抑制保留标签。当它们通过 `--tagstatinclude robot:*` 命令行选项明确包含时，它们将被显示。#### 测试设置和拆解Robot Framework具有与许多其他测试自动化框架类似的测试设置和拆解功能。简单来说，测试设置是在测试用例之前执行的操作，而测试拆解是在测试用例之后执行的操作。在Robot Framework中，设置和拆解只是具有可能参数的普通关键字。设置和拆解总是单个关键字。如果它们需要处理多个独立的任务，可以创建高级用户关键字来实现。另一种解决方案是使用BuiltIn关键字Run Keywords执行多个关键字。测试拆解在两个方面特殊。首先，即使测试用例失败，它也会被执行，所以它可以用于必须完成的清理活动，无论测试用例的状态如何。此外，即使其中一个关键字失败，拆解中的所有关键字也会被执行。这种继续失败的功能也可以用于普通关键字，但在拆解中它默认是开启的。在测试用例文件中为测试用例指定设置或拆解的最简单方法是使用设置部分中的Test Setup和Test Teardown设置。单个测试用例也可以有自己的设置或拆解。它们是在测试用例部分的[Setup]或[Teardown]设置中定义的，并且它们会覆盖可能的Test Setup和Test Teardown设置。在[Setup]或[Teardown]设置后没有关键字意味着没有设置或拆解。也可以使用值NONE来表示测试没有设置/拆解。```robotframework*** Settings ***Test Setup Open Application App ATest Teardown Close Application*** Test Cases ***Default values [Documentation] 设置和拆解来自设置部分 Do SomethingOverridden setup [Documentation] 自己的设置，拆解来自设置部分 [Setup] Open Application App B Do SomethingNo teardown [Documentation] 默认设置，完全没有拆解 Do Something [Teardown]No teardown 2 [Documentation] 设置和拆解也可以通过特殊值NONE禁用 Do Something [Teardown] NONEUsing variables [Documentation] 使用变量指定设置和拆解 [Setup] $&#123;SETUP&#125; Do Something [Teardown] $&#123;TEARDOWN&#125; 作为设置或拆解执行的关键字的名称可以是一个变量。这通过从命令行给出关键字名称作为变量，便于在不同环境中有不同的设置或拆解。 注意 测试套件可以有自己的设置和拆解。套件设置在该测试套件中的任何测试用例或子测试套件之前执行，同样，套件拆解在它们之后执行。 测试模板测试模板将普通的关键字驱动测试用例转换为数据驱动的测试。关键字驱动的测试用例的主体是由关键字和它们可能的参数构成的，而带有模板的测试用例只包含模板关键字的参数。与其在每个测试和&#x2F;或文件中的所有测试中多次重复相同的关键字，不如只在每个测试或文件中使用一次。 模板关键字可以接受正常的位置参数和命名参数，以及嵌入到关键字名称中的参数。与其他设置不同，不能使用变量定义模板。 基本用法以下示例测试用例说明了如何将接受正常位置参数的关键字用作模板。这两个测试在功能上完全相同。 1234567*** Test Cases ***Normal test case Example keyword first argument second argumentTemplated test case [Template] Example keyword first argument second argument 如示例所示，可以使用 [Template] 设置为单个测试用例指定模板。另一种方法是在设置部分使用 Test Template 设置，在这种情况下，模板将应用于该测试用例文件中的所有测试用例。[Template] 设置会覆盖设置部分设置的可能的模板，而 [Template] 的空值意味着测试没有模板，即使使用了 Test Template。也可以使用值 NONE 来表示测试没有模板。 如果一个带模板的测试用例在其主体中有多个数据行，那么模板将逐行应用于所有行。这意味着相同的关键字会被执行多次，每行数据执行一次。模板化的测试也是特殊的，因为即使其中一个或多个失败，所有的轮次也会被执行。这种继续失败模式也可以用于普通测试，但在模板化的测试中，该模式是自动开启的。 12345678*** Settings ***Test Template Example keyword*** Test Cases ***Templated test case first round 1 first round 2 second round 1 second round 2 third round 1 third round 2 使用具有默认值或接受可变数量参数的关键字，以及使用命名参数和自由命名参数，与模板的工作方式完全相同。在参数中使用变量也是正常支持的。 嵌入参数的模板模板支持嵌入参数语法的变体。使用模板时，此语法的工作方式是，如果模板关键字的名称中有变量，它们被视为参数的占位符，并用模板使用的实际参数替换。然后使用结果关键字，而不使用位置参数。这最好通过一个例子来说明： 1234567891011121314*** Test Cases ***带嵌入参数的普通测试用例 1 + 1 的结果应该是 2 1 + 2 的结果应该是 3带嵌入参数的模板 [Template] $&#123;calculation&#125; 的结果应该是 $&#123;expected&#125; 1 + 1 2 1 + 2 3*** Keywords ***$&#123;calculation&#125; 的结果应该是 $&#123;expected&#125; $&#123;result&#125; = 计算 $&#123;calculation&#125; 应该相等 $&#123;result&#125; $&#123;expected&#125; 当使用模板的嵌入参数时，模板关键字名称中的参数数量必须与其使用的参数数量匹配。尽管参数名称不需要匹配原始关键字的参数，也可以完全使用不同的参数： 1234567891011121314*** Test Cases ***不同的参数名称 [Template] $&#123;foo&#125; 的结果应该是 $&#123;bar&#125; 1 + 1 2 1 + 2 3只有一些参数 [Template] $&#123;calculation&#125; 的结果应该是 3 1 + 2 4 - 1新的参数 [Template] $&#123;life&#125; 的 $&#123;meaning&#125; 应该是 42 result 21 * 2 使用模板的嵌入参数的主要好处是参数名称被明确指定。当使用普通参数时，可以通过命名包含参数的列来达到相同的效果。这在下一节的数据驱动样式示例中有所说明。 使用FOR循环的模板如果模板与FOR循环一起使用，模板将应用于循环内的所有步骤。在这种情况下，也会使用继续失败模式，这意味着即使有失败，所有的步骤也会与所有的循环元素一起执行。 123456789*** Test Cases ***带FOR循环的模板 [Template] Example keyword FOR $&#123;item&#125; IN @&#123;ITEMS&#125; $&#123;item&#125; 2nd arg END FOR $&#123;index&#125; IN RANGE 42 1st arg $&#123;index&#125; END 使用IF&#x2F;ELSE结构的模板IF&#x2F;ELSE结构也可以与模板一起使用。例如，当与FOR循环一起使用时，这可以用于过滤执行的参数，这可能很有用。 12345678*** Test Cases ***带FOR和IF的模板 [Template] Example keyword FOR $&#123;item&#125; IN @&#123;ITEMS&#125; IF $&#123;item&#125; &lt; 5 $&#123;item&#125; 2nd arg END END 不同的测试用例风格测试用例可以以多种不同的方式编写。描述某种工作流的测试用例可以以关键字驱动或行为驱动的风格编写。数据驱动的风格可以用于测试具有不同输入数据的相同工作流。 关键字驱动风格工作流测试，如前面描述的有效登录测试，是由几个关键字及其可能的参数构建的。它们的正常结构是首先将系统置于初始状态（在有效登录示例中打开登录页面），然后对系统进行一些操作（输入名称，输入密码，提交凭据），最后验证系统的行为是否符合预期（应打开欢迎页面）。 数据驱动风格编写测试用例的另一种风格是数据驱动的方法，其中测试用例只使用一个高级关键字（通常作为用户关键字创建），该关键字隐藏了实际的测试工作流。当需要使用不同的输入和&#x2F;或输出数据测试相同的场景时，这些测试非常有用。可以在每个测试中重复相同的关键字，但是测试模板功能允许只指定一次要使用的关键字。 12345678910*** Settings ***Test Template Login with invalid credentials should fail*** Test Cases *** USERNAME PASSWORDInvalid User Name invalid $&#123;VALID PASSWORD&#125;Invalid Password $&#123;VALID USER&#125; invalidInvalid User Name and Password invalid invalidEmpty User Name $&#123;EMPTY&#125; $&#123;VALID PASSWORD&#125;Empty Password $&#123;VALID USER&#125; $&#123;EMPTY&#125;Empty User Name and Password $&#123;EMPTY&#125; $&#123;EMPTY&#125; 信息 像上面的例子那样命名列可以使测试更易于理解。这是可能的，因为在标题行中，除第一个单元格外的其他单元格都被忽略。 上面的示例有六个独立的测试，每个无效的用户&#x2F;密码组合一个，下面的示例说明了如何只有一个测试包含所有的组合。使用测试模板时，即使有失败，测试中的所有轮次也会被执行，所以这两种风格之间没有真正的功能差异。在上面的示例中，单独的组合被命名，所以更容易看出它们测试了什么，但是可能有大量的这些测试可能会混乱统计数据。使用哪种风格取决于上下文和个人偏好。 123456789*** Test Cases ***Invalid Password [Template] Login with invalid credentials should fail invalid $&#123;VALID PASSWORD&#125; $&#123;VALID USER&#125; invalid invalid whatever $&#123;EMPTY&#125; $&#123;VALID PASSWORD&#125; $&#123;VALID USER&#125; $&#123;EMPTY&#125; $&#123;EMPTY&#125; $&#123;EMPTY&#125; 行为驱动风格也可以将测试用例编写为非技术项目利益相关者也必须理解的需求。这些可执行的需求是通常被称为接受测试驱动开发（ATDD）或示例规范化的过程的基石。 编写这些需求&#x2F;测试的一种方式是由行为驱动开发（BDD）普及的Given-When-Then风格。在这种风格的测试用例中，初始状态通常用以Given开头的关键字表示，动作用以When开头的关键字描述，预期用以Then开头的关键字表示。如果一个步骤有多个动作，可以使用以And或But开头的关键字。 123456*** Test Cases ***Valid Login Given 登录页面已打开 When 插入有效的用户名和密码 and 提交凭据 Then 应该打开欢迎页面 忽略Given&#x2F;When&#x2F;Then&#x2F;And&#x2F;But前缀当搜索匹配的关键字时，如果没有找到全名匹配，将丢弃前缀Given、When、Then、And和But。这对于用户关键字和库关键字都有效。例如，在上面的示例中，Given登录页面已打开可以实现为用户关键字，无论是否带有单词Given。忽略前缀还允许使用不同的前缀使用相同的关键字。例如，欢迎页面应该打开也可以用作And欢迎页面应该打开。 注意 这些前缀可以本地化。请参阅翻译附录以获取支持的翻译。 嵌入数据到关键字在编写具体示例时，能够将实际数据传递给关键字实现是很有用的。用户关键字通过允许将参数嵌入到关键字名称中来支持这一点。 创建任务除了测试自动化，Robot Framework还可以用于其他自动化目的，包括机器人流程自动化（RPA）。这一直是可能的，但Robot Framework 3.1添加了对自动化任务的官方支持，而不仅仅是测试。在大多数情况下，创建任务的工作方式与创建测试相同，唯一的实质区别在于术语。任务也可以像测试用例一样组织成套件。 任务语法任务是基于可用关键字创建的，就像测试用例一样，任务语法通常与测试用例语法相同。主要区别在于，任务是在任务部分创建的，而不是在测试用例部分： 123456*** Tasks ***Process invoice Read information from PDF Validate information Submit information to backend system Validate information is visible in web UI 在同一文件中同时有测试和任务是错误的。 与任务相关的设置可以在任务部分使用的设置与测试用例部分中可以使用的设置完全相同。在设置部分，可以使用任务设置、任务拆解、任务模板和任务超时，而不是它们的测试变体。 创建测试套件Robot Framework的测试用例是在测试用例文件中创建的，这些文件可以组织成目录。这些文件和目录创建了一个分层的测试套件结构。创建任务时也适用相同的概念，但术语有所不同。 套件文件Robot Framework的测试用例是在套件文件（也称为测试用例文件）中的测试用例部分创建的。这样的文件会自动从它包含的所有测试用例创建一个测试套件。测试用例的数量没有上限，但建议少于十个，除非使用数据驱动的方法，其中一个测试用例只包含一个高级关键字。 在设置部分，可以使用以下设置来自定义套件： Name 用于设置自定义套件名称。默认名称是根据文件或目录名称创建的。 Documentation 用于指定套件文档。 Metadata 用于设置自由套件元数据作为名称-值对。 Suite Setup, Suite Teardown 指定套件设置和拆解。 注意 设置名称是不区分大小写的，但推荐使用上述格式。 套件目录测试用例文件可以组织成目录，这些目录创建了更高级别的测试套件。从目录创建的测试套件不能直接包含任何测试用例，而是包含其他包含测试用例的测试套件。然后，这些目录可以放置到其他目录中，创建更高级别的套件。结构没有限制，所以可以根据需要组织测试用例。 当执行一个测试目录时，它包含的文件和目录会被递归处理，如下所示： 以点（.）或下划线（_）开头的文件和目录名会被忽略。 名称为CVS的目录会被忽略（区分大小写）。 支持的文件格式的文件会被处理。 其他文件会被忽略。 如果处理的文件或目录不包含任何测试用例，它会被静默忽略（向系统日志写入一条消息），并继续处理。 套件初始化文件从目录创建的测试套件可以有与从测试用例文件创建的套件相似的设置。因为目录本身不能包含这种信息，所以必须将其放入一个特殊的测试套件初始化文件中。初始化文件的名称必须始终采用__init__.ext的格式，其中扩展名必须是支持的文件格式之一（通常是__init__.robot）。这种命名格式借鉴自Python，其中以这种方式命名的文件表示目录是一个模块。 从Robot Framework 6.1开始，也可以为通过给出多个路径启动测试执行时自动创建的套件定义套件初始化文件。 初始化文件的结构和语法与测试用例文件相同，只是它们不能有测试用例部分，而且不是所有的设置都被支持。在初始化文件中创建或导入的变量和关键字在较低级别的测试套件中不可用。如果需要共享变量或关键字，可以将它们放入资源文件中，这些文件可以由初始化和测试用例文件导入。 初始化文件的主要用途是指定与套件文件类似的测试套件相关设置，但也可以设置一些与测试用例相关的设置。如何在初始化文件中使用不同的设置在下面解释。 Name, Documentation, Metadata, Suite Setup, Suite Teardown 这些套件特定的设置在套件初始化文件中的工作方式与套件文件中的工作方式相同。 Test Tags 指定的标签无条件地设置为此目录包含的所有套件文件中的所有测试，递归地。新的在Robot Framework 6.1。需要使用旧版本的Force Tags。 Test Setup, Test Teardown, Test Timeout 将测试设置&#x2F;拆解或测试超时的默认值设置为此目录包含的所有测试用例。可以在较低级别覆盖。注意，用作设置和拆解的关键字必须在使用它们的测试的测试用例文件中可用。在初始化文件本身中定义关键字是不够的。 Task Setup, Task Teardown, Task Tags, Task Timeout 分别是Test Setup, Test Teardown, Test Tags和Test Timeout的别名，可以在创建任务，而不是测试时使用。 Default Tags, Test Template 在初始化文件中不支持。 1234567891011121314*** Settings ***Documentation 示例套件Suite Setup Do Something $&#123;MESSAGE&#125;Test Tags exampleLibrary SomeLibrary*** Variables ***$&#123;MESSAGE&#125; Hello, world!*** Keywords ***Do Something [Arguments] $&#123;args&#125; Some Keyword $&#123;arg&#125; Another Keyword 套件名称测试套件的名称默认由文件或目录名称构造。创建名称时，将忽略扩展名，可能的下划线被替换为空格，全小写的名称被转换为标题大小写。例如，some_tests.robot变成Some Tests，My_test_directory变成My test directory。 文件或目录名称可以包含一个前缀来控制套件的执行顺序。前缀与基本名称之间用两个下划线分隔，当构造实际的测试套件名称时，前缀和下划线都被删除。例如，文件01__some_tests.robot和02__more_tests.robot分别创建测试套件Some Tests和More Tests，前者在后者之前执行。 从Robot Framework 6.1开始，也可以通过在设置部分使用Name设置为套件指定一个自定义名称： 12*** Settings ***Name Custom suite name 可以使用--name选项从命令行覆盖顶级套件的名称。 套件文档使用设置部分中的Documentation设置设置测试套件的文档。它可以在套件文件和套件初始化文件中使用。套件文档与测试用例文档在显示位置和创建方式上具有完全相同的特性。有关语法的详细信息，请参阅文档格式化附录。 123*** Settings ***Documentation An example suite documentation with *some* _formatting_.... Long documentation can be split into multiple lines. 可以使用--doc选项从命令行覆盖顶级套件的文档。 自由套件元数据除了文档外，套件还可以有自由元数据。这些元数据以名称-值对的形式在设置部分使用Metadata设置定义。它在报告和日志中的显示方式与文档类似。 元数据的名称是给Metadata设置的第一个参数，剩余的参数指定其值。值的处理方式与文档相同，这意味着它支持HTML格式和变量，而且较长的值可以分成多行。 1234567*** Settings ***Metadata Version 2.0Metadata Robot Framework http://robotframework.orgMetadata Platform $&#123;PLATFORM&#125;Metadata Longer Value... Longer metadata values can be split into multiple... rows. Also *simple* _formatting_ is supported. 可以使用--metadata选项从命令行设置顶级套件的自由元数据。 套件设置和拆解不仅测试用例，而且测试套件也可以有一个设置和一个拆解。套件设置在运行任何套件的测试用例或子测试套件之前执行，套件拆解在它们之后执行。所有的测试套件都可以有一个设置和一个拆解；对于从目录创建的套件，它们必须在套件初始化文件中指定。 与测试用例类似，套件设置和拆解是可能带有参数的关键字。它们在设置部分中使用Suite Setup和Suite Teardown设置定义，分别。关键字名称和可能的参数位于设置名称后的列中。 如果套件设置失败，那么它和其子测试套件中的所有测试用例都会立即被分配一个失败状态，并且它们实际上不会被执行。这使得套件设置成为在可能运行测试用例之前必须满足的预条件的理想选择。 套件拆解通常用于在所有测试用例执行完毕后进行清理。即使同一套件的设置失败，它也会被执行。如果套件拆解失败，那么套件中的所有测试用例都会被标记为失败，无论它们的原始执行状态如何。注意，即使其中一个失败，套件拆解中的所有关键字也会被执行。 作为设置或拆解执行的关键字的名称可以是一个变量。这通过从命令行给出关键字名称作为变量，便于在不同环境中有不同的设置或拆解。 使用测试库测试库包含那些最低级别的关键字，通常被称为库关键字，它们实际上与被测试的系统进行交互。所有的测试用例总是使用来自某个库的关键字，通常通过高级用户关键字。本节解释如何使用测试库以及如何使用它们提供的关键字。创建测试库在另一节中描述。 导入库测试库通常使用Library设置导入，但也可以使用Import Library关键字。 使用Library设置测试库通常使用设置部分中的Library设置导入，并在后续列中有库名称。与大多数其他数据不同，库名称既区分大小写又区分空格。如果库在一个包中，必须使用包括包名在内的全名。 在那些库需要参数的情况下，它们列在库名称后的列中。在测试库导入中可以像关键字的参数一样使用默认值、可变数量的参数和命名参数。库名称和参数都可以使用变量设置。 12345*** Settings ***Library OperatingSystemLibrary my.package.TestLibraryLibrary MyLibrary arg1 arg2Library $&#123;LIBRARY&#125; 可以在套件文件、资源文件和套件初始化文件中导入测试库。在所有这些情况下，导入的库中的所有关键字都在该文件中可用。对于资源文件，这些关键字也在使用它们的其他文件中可用。 使用Import Library关键字另一种使用测试库的可能性是使用BuiltIn库中的关键字Import Library。这个关键字接受库名称和可能的参数，就像Library设置一样。导入的库中的关键字在使用Import Library关键字的测试套件中可用。这种方法在库在测试执行开始时不可用，只有其他一些关键字使其可用的情况下很有用。 12345*** Test Cases ***Example Do Something Import Library MyLibrary arg1 arg2 KW From MyLibrary 指定要导入的库要导入的库可以通过使用库名称或库路径来指定。无论是使用Library设置还是Import Library关键字导入库，这些方法的工作方式都是相同的。 使用库名称指定要导入的测试库的最常见方法是使用其名称，就像本节中的所有示例所做的那样。在这些情况下，Robot Framework试图从模块搜索路径中找到实现库的类或模块。以某种方式安装的库应该自动在模块搜索路径中，但对于其他库，可能需要单独配置搜索路径。 这种方法的最大好处是，当配置了模块搜索路径（通常使用自定义的启动脚本）后，普通用户不需要考虑库实际上安装在哪里。缺点是，将自己的（可能非常简单的）库放入搜索路径可能需要一些额外的配置。 使用库的物理路径指定要导入的库的另一种机制是使用文件系统中的路径。这个路径被认为是相对于当前测试数据文件所在的目录的，就像资源和变量文件的路径一样。这种方法的主要好处是不需要配置模块搜索路径。 如果库是一个文件，那么它的路径必须包含扩展名，即.py。如果库是作为目录实现的，那么如果路径是相对的，它的路径必须有一个尾随的正斜杠（&#x2F;）。对于绝对路径，尾随的斜杠是可选的。以下示例演示了这些不同的用法。 1234*** Settings ***Library PythonLibrary.pyLibrary relative/path/PythonDirLib/ possible argumentsLibrary $&#123;RESOURCES&#125;/Example.class 这种方法的一个限制是，作为Python类实现的库必须在与类同名的模块中。 设置库的自定义名称库名称在关键字名称之前显示在测试日志中，如果多个关键字有相同的名称，它们必须使用关键字名称前缀为库名称。库名称通常从实现它的模块或类名称中获取，但在某些情况下，更改它是可取的： 需要多次导入相同的库，但参数不同。否则这是不可能的。 库名称过长不便。 希望使用变量在不同的环境中导入不同的库，但用相同的名称引用它们。 库名称误导或其他贫穷。在这种情况下，更改实际名称当然是更好的解决方案。 指定新名称的基本语法是在库名称后面有文本AS（区分大小写），然后在其后面有新名称。指定的名称显示在日志中，并且在使用关键字的全名（LibraryName.Keyword Name）时必须在测试数据中使用。 123*** Settings ***Library packagename.TestLib AS TestLibLibrary $&#123;LIBRARY&#125; AS MyName 库的可能参数放在原始库名称和AS标记之间。以下示例说明了如何使用不同的参数多次导入相同的库： 123456789*** Settings ***Library SomeLibrary localhost 1234 AS LocalLibLibrary SomeLibrary server.domain 8080 AS RemoteLib*** Test Cases ***Example LocalLib.Some Keyword some arg second arg RemoteLib.Some Keyword another arg whatever LocalLib.Another Keyword 在设置部分导入库和使用Import Library关键字时，都可以为测试库设置自定义名称。 注意 在Robot Framework 6.0之前，给库指定自定义名称时使用的标记是WITH NAME，而不是AS。旧的语法继续工作，但它被认为是已弃用的，最终将被删除。 标准库有些测试库是与Robot Framework一起分发的，这些库被称为标准库。BuiltIn库是特殊的，因为它是自动使用的，因此它的关键字总是可用的。其他标准库需要像任何其他库一样导入，但是不需要安装它们。 普通标准库下面列出了可用的普通标准库，并附有链接到它们的文档： BuiltIn Collections DateTime Dialogs OperatingSystem Process Screenshot String Telnet XML 远程库除了上面列出的普通标准库，还有一个远程库，它与其他标准库完全不同。它本身没有任何关键字，但它作为Robot Framework和实际测试库实现之间的代理。这些库可以在核心框架之外的其他机器上运行，甚至可以使用Robot Framework原生不支持的语言实现。 有关此概念的更多信息，请参阅单独的远程库接口部分。 外部库任何不是标准库的测试库，按定义，都是外部库。Robot Framework的开源社区已经实现了几个通用库，如SeleniumLibrary和SwingLibrary，这些库没有与核心框架一起打包。可以从http://robotframework.org找到公开可用的库列表。 显然，使用Robot Framework的团队也可以实现通用和自定义库。有关该主题的更多信息，请参阅创建测试库部分。 不同的外部库可能有完全不同的安装和使用机制。有时，它们可能还需要单独安装一些其他依赖项。所有的库都应该有清晰的安装和使用文档，最好能自动化安装过程。 变量简介变量是Robot Framework的一个重要特性，它们可以在测试数据的大多数地方使用。最常见的是在测试用例和关键字部分的关键字参数中使用，但所有设置也允许在其值中使用变量。普通的关键字名称不能用变量指定，但可以使用BuiltIn关键字Run Keyword来达到同样的效果。 Robot Framework有自己的变量，可以分别使用语法$&#123;SCALAR&#125;、@&#123;LIST&#125;和&amp;&#123;DICT&#125;作为标量、列表或字典使用。除此之外，还可以直接使用语法%&#123;ENV_VAR&#125;使用环境变量。 变量在以下情况下很有用： 当测试数据中的字符串经常变化时。使用变量，只需要在一个地方做这些更改。 当创建系统独立和操作系统独立的测试数据时。使用变量而不是硬编码的字符串可以大大简化这个过程（例如，使用$&#123;RESOURCES&#125;代替c:\\resources，或者使用$&#123;HOST&#125;代替10.0.0.1:8080）。因为变量可以在启动测试时从命令行设置，所以更改系统特定的变量很容易（例如，--variable HOST:10.0.0.2:1234 --variable RESOURCES:/opt/resources）。这也有助于本地化测试，这通常涉及使用不同的字符串运行相同的测试。 当需要将除字符串以外的对象作为关键字的参数时。没有变量，这是不可能的。 当不同的关键字，甚至在不同的测试库中，需要通信时。可以将一个关键字的返回值分配给一个变量，并将它作为另一个的参数传递。 当测试数据中的值很长或者复杂时。例如，$&#123;URL&#125;比http://long.domain.name:8080/path/to/service?foo=1&amp;bar=2&amp;zap=42短。 如果在测试数据中使用了不存在的变量，使用它的关键字会失败。如果需要将用于变量的相同语法作为字面字符串，必须使用反斜杠转义，如\\$&#123;NAME&#125;。 使用变量本节解释如何使用变量，包括常规标量变量语法$&#123;var&#125;，如何在列表和字典上下文中使用变量，如@&#123;var&#125;和&amp;&#123;var&#125;，以及如何使用环境变量，如%&#123;var&#125;。后续部分将讨论创建变量的不同方式。 Robot Framework的变量，类似于关键字，是不区分大小写的，而且也忽略空格和下划线。然而，建议使用大写字母表示全局变量（例如，$&#123;PATH&#125;或$&#123;TWO WORDS&#125;），使用小写字母表示只在某些测试用例或用户关键字中可用的局部变量（例如，$&#123;my var&#125;）。更重要的是，应该一致地使用大小写。 变量名由变量类型标识符（$，@，&amp;，%），花括号（{，}）和花括号之间的实际变量名组成。与使用类似变量语法的某些编程语言不同，花括号总是必需的。变量名基本上可以在花括号之间有任何字符。然而，建议只使用从a到z的字母、数字、下划线和空格，这甚至是使用扩展变量语法的要求。 标量变量语法在Robot Framework测试数据中使用变量的最常见方式是使用标量变量语法，如$&#123;var&#125;。当使用这种语法时，变量名被其值替换。大多数时候，变量值是字符串，但变量可以包含任何对象，包括数字、列表、字典，甚至自定义对象。 下面的例子说明了标量变量的使用。假设变量$&#123;GREET&#125;和$&#123;NAME&#125;可用，并分别赋值为字符串Hello和world，那么下面的示例测试用例是等价的。 12345678*** Test Cases ***Constants Log Hello Log Hello, world!!Variables Log $&#123;GREET&#125; Log $&#123;GREET&#125;, $&#123;NAME&#125;!! 当一个标量变量单独使用，没有其他文本或变量围绕它，就像上面的$&#123;GREET&#125;，变量被其值替换，值可以是任何对象。如果变量不是单独使用，就像上面的$&#123;GREER&#125;, $&#123;NAME&#125;!!，它的值首先被转换为字符串，然后与其他数据连接。 注意 当使用命名参数语法向关键字传递参数时，也会按原样使用变量值，如argname=${var}。 下面的例子演示了变量单独使用和与其他内容一起使用的区别。首先，假设有一个变量$&#123;STR&#125;设置为字符串Hello, world!和$&#123;OBJ&#125;设置为以下Python对象的实例： 1234class MyObj: def __str__(): return &quot;Hi, terra!&quot; 设置了这两个变量后，有以下测试数据： 123456*** Test Cases ***Objects KW 1 $&#123;STR&#125; KW 2 $&#123;OBJ&#125; KW 3 I said &quot;$&#123;STR&#125;&quot; KW 4 You said &quot;$&#123;OBJ&#125;&quot; 最后，当执行这个测试数据时，不同的关键字接收到的参数如下所示： KW 1得到一个字符串Hello, world! KW 2得到存储在变量$&#123;OBJ&#125;中的对象 KW 3得到一个字符串I said “Hello, world!” KW 4得到一个字符串You said “Hi, terra!” 注意 如果变量不能表示为Unicode，那么将变量转换为Unicode显然会失败。例如，如果试图使用字节序列作为关键字的参数，那么将值连接在一起，如${byte1}${byte2}。一个解决方法是创建一个包含整个值的变量，并在单元格中单独使用它（例如，${bytes}），因为这样值就会按原样使用。 列表变量语法当一个变量像$&#123;EXAMPLE&#125;那样作为标量使用时，它的值会被原样使用。如果一个变量的值是一个列表或类似列表，那么也可以像@&#123;EXAMPLE&#125;那样将它作为一个列表变量使用。在这种情况下，列表会被展开，单个项会作为单独的参数传入。这最容易通过一个例子来解释。假设一个变量@&#123;USER&#125;的值是[&#39;robot&#39;, &#39;secret&#39;]，那么下面的两个测试用例是等价的： 123456*** Test Cases ***Constants Login robot secretList Variable Login @&#123;USER&#125; Robot Framework将其自己的变量存储在一个内部存储中，并允许将它们作为标量、列表或字典使用。将一个变量作为列表使用需要它的值是一个Python列表或类似列表的对象。Robot Framework不允许将字符串用作列表，但接受其他可迭代的对象，如元组或字典。 从Robot Framework 4.0开始，可以将列表扩展与列表项访问结合使用，使得以下用法成为可能： 123456789*** Test Cases ***Nested container $&#123;nested&#125; = Evaluate [[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#123;&#x27;key&#x27;: [&#x27;x&#x27;, &#x27;y&#x27;]&#125;] Log Many @&#123;nested&#125;[0] # Logs &#x27;a&#x27;, &#x27;b&#x27; and &#x27;c&#x27;. Log Many @&#123;nested&#125;[1][key] # Logs &#x27;x&#x27; and &#x27;y&#x27;.Slice $&#123;items&#125; = Create List first second third Log Many @&#123;items&#125;[1:] # Logs &#x27;second&#x27; and &#x27;third&#x27;. 使用列表变量与其他数据可以将列表变量与其他参数一起使用，包括其他列表变量。 12345*** Test Cases ***Example Keyword @&#123;LIST&#125; more args Keyword $&#123;SCALAR&#125; @&#123;LIST&#125; constant Keyword @&#123;LIST&#125; @&#123;ANOTHER&#125; @&#123;ONE MORE&#125; 使用列表变量与设置列表变量只能与一些设置一起使用。它们可以用作导入的库和变量文件的参数，但库和变量文件的名称本身不能是列表变量。也可以在设置和拆解中使用列表变量作为关键字的参数，但不能用作关键字的名称。对于与标签相关的设置，它们可以自由地使用。在不支持列表变量的地方，可以使用标量变量。 12345678*** Settings ***Library ExampleLibrary @&#123;LIB ARGS&#125; # This worksLibrary $&#123;LIBRARY&#125; @&#123;LIB ARGS&#125; # This worksLibrary @&#123;LIBRARY AND ARGS&#125; # This does not workSuite Setup Some Keyword @&#123;KW ARGS&#125; # This worksSuite Setup $&#123;KEYWORD&#125; @&#123;KW ARGS&#125; # This worksSuite Setup @&#123;KEYWORD AND ARGS&#125; # This does not workDefault Tags @&#123;TAGS&#125; # This works 字典变量语法如上所述，包含列表的变量可以作为列表变量使用，将列表项作为单独的参数传递给关键字。类似地，包含Python字典或类似字典的对象的变量可以像&amp;&#123;EXAMPLE&#125;那样作为字典变量使用。实际上，这意味着字典被展开，单个项作为命名参数传递给关键字。假设一个变量&amp;&#123;USER&#125;的值是&#123;&#39;name&#39;: &#39;robot&#39;, &#39;password&#39;: &#39;secret&#39;&#125;，那么下面的两个测试用例是等价的。 123456*** Test Cases ***Constants Login name=robot password=secretDict Variable Login &amp;&#123;USER&#125; 注意 从Robot Framework 4.0开始，可以将字典扩展与字典项访问结合使用，使得像&amp;{nested}[key]这样的用法成为可能。 使用字典变量与其他数据可以将字典变量与其他参数一起使用，包括其他字典变量。因为命名参数语法要求位置参数在命名参数之前，所以字典只能跟在命名参数或其他字典后面。 12345*** Test Cases ***Example Keyword &amp;&#123;DICT&#125; named=arg Keyword positional @&#123;LIST&#125; &amp;&#123;DICT&#125; Keyword &amp;&#123;DICT&#125; &amp;&#123;ANOTHER&#125; &amp;&#123;ONE MORE&#125; 使用字典变量与设置字典变量通常不能与设置一起使用。唯一的例外是导入、设置和拆解，其中字典可以作为参数使用。 123*** Settings ***Library ExampleLibrary &amp;&#123;LIB ARGS&#125;Suite Setup Some Keyword &amp;&#123;KW ARGS&#125; named=arg 访问列表和字典项可以使用特殊语法$&#123;var&#125;[item]或$&#123;var&#125;[nested][item]访问可下标的变量（例如，列表和字典）的项。从Robot Framework 4.0开始，也可以通过使用语法@&#123;var&#125;[item]和&amp;&#123;var&#125;[item]将项访问与列表扩展和字典扩展一起使用。 注意 在Robot Framework 3.1之前，正常的项访问语法是列表的@{var}[item]和字典的&amp;{var}[item]。Robot Framework 3.1引入了通用的${var}[item]语法以及一些其他的好的增强，旧的项访问语法在Robot Framework 3.2中被弃用。 访问序列项可以使用语法$&#123;var&#125;[index]访问包含序列（例如，列表、字符串或字节）的变量的某个项，其中index是所选值的索引。索引从零开始，可以使用负索引从末尾访问项，尝试访问索引过大的项会导致错误。索引会自动转换为整数，也可以使用变量作为索引。 12345678910*** Test Cases ***Positive index Login $&#123;USER&#125;[0] $&#123;USER&#125;[1] Title Should Be Welcome $&#123;USER&#125;[0]!Negative index Keyword $&#123;SEQUENCE&#125;[-1]Index defined as variable Keyword $&#123;SEQUENCE&#125;[$&#123;INDEX&#125;] 序列项访问也支持Python的相同的”切片”功能，语法如$&#123;var&#125;[1:]。使用这种语法，不会得到一个单独的项，而是得到原始序列的一个切片。与Python一样，可以指定开始索引、结束索引和步长： 12345678910111213*** Test Cases ***Start index Keyword $&#123;SEQUENCE&#125;[1:]End index Keyword $&#123;SEQUENCE&#125;[:4]Start and end Keyword $&#123;SEQUENCE&#125;[2:-1]Step Keyword $&#123;SEQUENCE&#125;[::2] Keyword $&#123;SEQUENCE&#125;[1:-1:10] 注意 切片语法在Robot Framework 3.1中是新的。它在Robot Framework 4.0中被扩展，可以与列表扩展像@{var}[1:]这样一起工作。 注意 在Robot Framework 3.2之前，只有包含列表、元组或其他被认为是类似列表的对象的变量支持项和切片访问。现在，所有的序列，包括字符串和字节，都被支持。 访问单个字典项可以使用语法$&#123;NAME&#125;[key]访问字典变量的某个值，其中key是所选值的名称。键被认为是字符串，但非字符串键可以作为变量使用。以这种方式访问的字典值可以像标量变量一样使用。 如果一个键是一个字符串，也可以使用属性访问语法$&#123;NAME.key&#125;访问它的值。有关此语法的更多详细信息，请参阅创建字典变量。 1234567891011*** Test Cases ***Dictionary variable item Login $&#123;USER&#125;[name] $&#123;USER&#125;[password] Title Should Be Welcome $&#123;USER&#125;[name]!Key defined as variable Log Many $&#123;DICT&#125;[$&#123;KEY&#125;] $&#123;DICT&#125;[$&#123;42&#125;]Attribute access Login $&#123;USER.name&#125; $&#123;USER.password&#125; Title Should Be Welcome $&#123;USER.name&#125;! 嵌套项访问也可以使用相同的项访问语法$&#123;var&#125;[item1][item2]访问嵌套的可下标变量。这在处理经常由REST服务返回的JSON数据时特别有用。例如，如果一个变量$&#123;DATA&#125;包含[&#123;&#39;id&#39;: 1, &#39;name&#39;: &#39;Robot&#39;&#125;, &#123;&#39;id&#39;: 2, &#39;name&#39;: &#39;Mr. X&#39;&#125;]，这个测试将通过： 1234*** Test Cases ***Nested item access Should Be Equal $&#123;DATA&#125;[0][name] Robot Should Be Equal $&#123;DATA&#125;[1][id] $&#123;2&#125; 环境变量Robot Framework允许在测试数据中使用环境变量，语法为%&#123;ENV_VAR_NAME&#125;。它们限制为字符串值。可以通过将变量名和默认值用等号分隔，如%&#123;ENV_VAR_NAME=default value&#125;，来指定一个默认值，如果环境变量不存在，则使用该默认值。 在测试执行之前在操作系统中设置的环境变量在执行期间是可用的，可以使用OperatingSystem库中的关键字Set Environment Variable创建新的环境变量，或者使用关键字Delete Environment Variable删除现有的环境变量。因为环境变量是全局的，所以在一个测试用例中设置的环境变量可以在执行后的其他测试用例中使用。然而，对环境变量的更改在测试执行后不会生效。 1234567*** Test Cases ***Environment variables Log Current user: %&#123;USER&#125; Run %&#123;JAVA_HOME&#125;$&#123;/&#125;javacEnvironment variables with defaults Set port %&#123;APPLICATION_PORT=8080&#125; 注意 在Robot Framework 3.2中，新增了指定默认值的支持。 创建变量变量可以从不同的来源产生。 变量部分变量最常见的来源是套件文件和资源文件中的变量部分。变量部分很方便，因为它们允许在与其他测试数据相同的地方创建变量，而且所需的语法非常简单。它们的主要缺点是值总是字符串，而且不能动态创建。如果这两者中的任何一个是问题，可以使用变量文件代替。 创建标量变量最简单的变量赋值就是将一个字符串设置为一个标量变量。这是通过在变量部分的第一列给出变量名（包括$&#123;&#125;），在第二列给出值来完成的。如果第二列为空，则设置一个空字符串作为值。也可以在值中使用已定义的变量。 1234*** Variables ***$&#123;NAME&#125; Robot Framework$&#123;VERSION&#125; 2.0$&#123;ROBOT&#125; $&#123;NAME&#125; $&#123;VERSION&#125; 也可以（但不是必须）在变量名后面使用等号=，使变量赋值稍微明确一些。 123*** Variables ***$&#123;NAME&#125; = Robot Framework$&#123;VERSION&#125; = 2.0 如果一个标量变量有一个长值，可以使用...语法将它分割成多行。默认情况下，行是用一个空格连接在一起的，但是可以通过在最后一个值后面使用一个分隔符配置选项来改变这一点： 1234567*** Variables ***$&#123;EXAMPLE&#125; This value is joined... together with a space.$&#123;MULTILINE&#125; First line.... Second line.... Third line.... separator=\\n 分隔符选项在Robot Framework 7.0中是新的，但也支持旧版本的分隔符配置。在它们中，第一个值可以包含一个特殊的SEPARATOR标记： 12345*** Variables ***$&#123;MULTILINE&#125; SEPARATOR=\\n... First line.... Second line.... Third line. 分隔符选项和SEPARATOR标记都是区分大小写的。建议使用分隔符选项，除非需要支持旧版本。 创建列表变量创建列表变量和创建标量变量一样容易。同样，变量名在变量部分的第一列，值在后续的列中。一个列表变量可以有任意数量的值，从零开始，如果需要多个值，它们可以分割成几行。 123456*** Variables ***@&#123;NAMES&#125; Matti Teppo@&#123;NAMES2&#125; @&#123;NAMES&#125; Seppo@&#123;NOTHING&#125;@&#123;MANY&#125; one two three four... five six seven 创建字典变量在变量部分创建字典变量与创建列表变量类似。区别在于，项需要使用name=value语法或现有的字典变量创建。如果有多个具有相同名称的项，最后一个值具有优先权。如果名称包含一个字面等号，可以使用反斜杠\\=进行转义。 123456*** Variables ***&amp;&#123;USER 1&#125; name=Matti address=xxx phone=123&amp;&#123;USER 2&#125; name=Teppo address=yyy phone=456&amp;&#123;MANY&#125; first=1 second=$&#123;2&#125; $&#123;3&#125;=third&amp;&#123;EVEN MORE&#125; &amp;&#123;MANY&#125; first=override empty=... =empty key\\=here=value 字典变量与普通Python字典相比有两个额外的属性。首先，这些字典的值可以像属性一样访问，这意味着可以使用扩展变量语法，如$&#123;VAR.key&#125;。这只有在键是一个有效的属性名称，并且不匹配Python字典有的任何正常属性时才有效。例如，单个值&amp;&#123;USER&#125;[name]也可以像$&#123;USER.name&#125;（注意在这种情况下需要$）那样访问，但是使用$&#123;MANY.3&#125;是不可能的。 信息 对于嵌套的字典变量，键可以像${VAR.nested.key}那样访问。这简化了处理嵌套数据结构的工作。 字典变量的另一个特殊属性是它们是有序的。这意味着，如果遍历这些字典，它们的项总是按照它们定义的顺序出现。如果字典被用作列表变量与FOR循环或其他方式一起使用，这可能很有用。当一个字典被用作一个列表变量时，实际的值包含字典键。例如，@&#123;MANY&#125;变量将具有值[&#39;first&#39;, &#39;second&#39;, 3]。 基于另一个变量创建变量名从Robot Framework 7.0开始，可以根据另一个变量动态创建变量名： 1234567*** Variables ***$&#123;X&#125; Y$&#123;$&#123;X&#125;&#125; Z # Name is created based on &#x27;$&#123;X&#125;&#x27;.*** Test Cases ***Dynamically created name Should Be Equal $&#123;Y&#125; Z 变量文件变量文件是创建不同类型变量的最强大的机制。使用它们，可以将变量赋值给任何对象，并且它们还支持动态创建变量。变量文件的语法和如何使用变量文件在资源和变量文件部分有解释。 在命令行中设置变量可以在命令行中单独使用--variable（-v）选项或使用变量文件与--variablefile（-V）选项来设置变量。从命令行设置的变量对所有执行的测试数据文件全局可用，并且它们还会覆盖变量部分和测试数据中导入的变量文件中具有相同名称的可能变量。 设置单个变量的语法是--variable name:value，其中name是变量的名称（不包括$&#123;&#125;），value是它的值。可以通过多次使用此选项来设置多个变量。只有标量变量可以使用此语法设置，它们只能获取字符串值。 12--variable EXAMPLE:value--variable HOST:localhost:7272 --variable USER:robot 在上面的例子中，设置了变量，使得 $&#123;EXAMPLE&#125;得到值value $&#123;HOST&#125;和$&#123;USER&#125;得到值localhost:7272和robot 从命令行使用变量文件的基本语法是--variablefile path/to/variables.py，在使用变量文件部分有更多的细节。实际创建的变量取决于引用的变量文件中有哪些变量。 如果从命令行给出了变量文件和单个变量，那么后者具有更高的优先级。 关键字的返回值关键字的返回值也可以设置为变量。这允许在不同的测试库中的不同关键字之间进行通信。 以这种方式设置的变量与其他任何变量在其他方面是相似的，但它们只在创建它们的局部范围内可用。因此，例如，不可能在一个测试用例中设置一个变量，然后在另一个测试用例中使用它。这是因为，一般来说，自动化测试用例不应该相互依赖，而且意外地设置一个在其他地方使用的变量可能会导致难以调试的错误。如果真正需要在一个测试用例中设置一个变量，并在另一个测试用例中使用它，可以使用BuiltIn关键字，如下一节所解释的。 分配标量变量任何由关键字返回的值都可以分配给一个标量变量。如下例所示，所需的语法非常简单： 1234*** Test Cases ***Returning $&#123;x&#125; = Get X an argument Log We got $&#123;x&#125;! 在上述例子中，Get X关键字返回的值首先被设置到变量$&#123;x&#125;中，然后被Log关键字使用。在变量名后面有等号=不是必须的，但它使赋值更明确。像这样在测试用例和用户关键字级别创建局部变量都可以工作。 注意 虽然一个值被赋值给一个标量变量，但如果它有一个类似列表的值，它可以作为一个列表变量使用，如果它有一个类似字典的值，它可以作为一个字典变量使用。 12345*** Test Cases ***Example $&#123;list&#125; = Create List first second third Length Should Be $&#123;list&#125; 3 Log Many @&#123;list&#125; 分配带有项值的变量从Robot Framework 6.1开始，当使用支持项赋值的变量，如列表或字典，可以通过使用语法$&#123;var&#125;[item]指定项的索引或键来设置它们的值，其中item部分本身可以包含一个变量： 1234567891011121314*** Test Cases ***Item assignment to list $&#123;list&#125; = Create List one two three four $&#123;list&#125;[0] = Set Variable first $&#123;list&#125;[$&#123;1&#125;] = Set Variable second $&#123;list&#125;[2:3] = Evaluate [&#x27;third&#x27;] $&#123;list&#125;[-1] = Set Variable last Log Many @&#123;list&#125; # Logs &#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27; and &#x27;last&#x27;Item assignment to dictionary $&#123;dict&#125; = Create Dictionary first_name=unknown $&#123;dict&#125;[first_name] = Set Variable John $&#123;dict&#125;[last_name] = Set Variable Doe Log $&#123;dictionary&#125; # Logs &#123;&#x27;first_name&#x27;: &#x27;John&#x27;, &#x27;last_name&#x27;: &#x27;Doe&#x27;&#125; 基于另一个变量创建变量名从Robot Framework 7.0开始，可以根据另一个变量动态创建被赋值变量的名称： 12345*** Test Cases ***Dynamically created name $&#123;x&#125; = Set Variable y $&#123;$&#123;x&#125;&#125; = Set Variable z # Name is created based on &#x27;$&#123;x&#125;&#x27;. Should Be Equal $&#123;y&#125; z 分配列表变量如果一个关键字返回一个列表或任何类似列表的对象，可以将其分配给一个列表变量： 12345*** Test Cases ***Example @&#123;list&#125; = Create List first second third Length Should Be $&#123;list&#125; 3 Log Many @&#123;list&#125; 因为所有的Robot Framework变量都存储在同一个命名空间中，所以将一个值分配给一个标量变量或一个列表变量之间没有太大的区别。这可以通过比较上面的最后两个例子来看出。主要的区别是，当创建一个列表变量时，Robot Framework会自动验证该值是否是一个列表或类似列表，存储的变量值将是从返回值创建的一个新列表。当分配给一个标量变量时，返回值不会被验证，存储的值将是返回的完全相同的对象。 分配字典变量如果一个关键字返回一个字典或任何类似字典的对象，可以将其分配给一个字典变量： 123456*** Test Cases ***Example &amp;&#123;dict&#125; = Create Dictionary first=1 second=$&#123;2&#125; $&#123;3&#125;=third Length Should Be $&#123;dict&#125; 3 Do Something &amp;&#123;dict&#125; Log $&#123;dict.first&#125; 因为所有的Robot Framework变量都存储在同一个命名空间中，也可以将一个字典分配给一个标量变量，然后在需要的时候将其作为一个字典使用。然而，显式创建一个字典变量有一些实际的好处。首先，Robot Framework验证返回的值是否是一个字典或类似字典，就像它验证列表变量只能得到一个类似列表的值一样。 一个更大的好处是，该值被转换为一个特殊的字典，它也在创建变量部分中创建字典变量时使用。这些字典中的值可以使用属性访问，如上例中的$&#123;dict.first&#125;。这些字典也是有序的，但如果原始字典不是有序的，结果的顺序是任意的。 分配多个变量如果一个关键字返回一个列表或一个类似列表的对象，可以将单个值分配给多个标量变量或标量变量和一个列表变量。 123456*** Test Cases ***Assign multiple $&#123;a&#125; $&#123;b&#125; $&#123;c&#125; = Get Three $&#123;first&#125; @&#123;rest&#125; = Get Three @&#123;before&#125; $&#123;last&#125; = Get Three $&#123;begin&#125; @&#123;middle&#125; $&#123;end&#125; = Get Three 假设关键字Get Three返回一个列表[1, 2, 3]，则创建以下变量： $&#123;a&#125;、$&#123;b&#125;和$&#123;c&#125;的值分别为1、2和3。 $&#123;first&#125;的值为1，@&#123;rest&#125;的值为[2, 3]。 @&#123;before&#125;的值为[1, 2]，$&#123;last&#125;的值为3。 $&#123;begin&#125;的值为1，@&#123;middle&#125;的值为[2]，$&#123;end&#125;的值为3。 如果返回的列表的值多于或少于要分配的标量变量的数量，那么这是一个错误。此外，只允许一个列表变量，字典变量只能单独分配。 自动记录分配的变量值为了更容易理解执行过程中发生了什么，分配的值的开始部分会被自动记录。默认情况下，显示前200个字符，但可以通过在运行测试时使用--maxassignlength命令行选项来改变这个值。如果值为零或负数，整个分配的值将被隐藏。 12--maxassignlength 1000--maxassignlength 0 不完全记录值的原因是，它可能非常大。如果总是想完全看到某个值，可以使用BuiltIn Log关键字在分配后记录它。 注意 --maxassignlength选项在Robot Framework 5.0中是新的。 VAR语法从Robot Framework 7.0开始，可以使用VAR语法在测试和用户关键字内部创建变量。VAR标记是区分大小写的，必须跟着一个变量名和值。除了必须的VAR，整体语法大多与在变量部分创建变量时的语法相同。 新的语法旨在使创建变量更简单、更统一。它特别用于替代BuiltIn关键字Set Variable、Set Test Variable、Set Suite Variable和Set Global Variable，但也可以用来替代Catenate、Create List和Create Dictionary。 创建标量变量在简单的情况下，通过给出一个变量名和它的值来创建标量变量。值可以是一个硬编码的字符串，也可以包含一个变量。如果值很长，可以将其分割成多个列和行。在这种情况下，默认情况下，部分会用一个空格连接在一起，但可以使用分隔符配置选项来指定要使用的分隔符。在创建基于关键字的返回值的变量和在变量部分中的变量时，变量名后面可以有一个可选的=。 123456789101112*** Test Cases ***Scalar examples VAR $&#123;simple&#125; variable VAR $&#123;equals&#125; = this works too VAR $&#123;variable&#125; value contains $&#123;simple&#125; VAR $&#123;sentence&#125; This is a bit longer variable value ... that is split into multiple rows. ... These parts are joined with a space. VAR $&#123;multiline&#125; This is another longer value. ... This time there is a custom separator. ... As the result this becomes a multiline string. ... separator=\\n 创建列表和字典变量列表和字典变量的创建与标量变量类似。创建字典时，必须使用name=value语法指定项。 1234567891011121314151617181920*** Test Cases ***List examples VAR @&#123;two items&#125; Robot Framework VAR @&#123;empty list&#125; VAR @&#123;lot of stuff&#125; ... first item ... second item ... third item ... fourth item ... last itemDictionary examples VAR &amp;&#123;two items&#125; name=Robot Framework url=http://robotframework.org VAR &amp;&#123;empty dict&#125; VAR &amp;&#123;lot of stuff&#125; ... first=1 ... second=2 ... third=3 ... fourth=4 ... last=5 作用域使用VAR语法创建的变量只在创建它们的测试或用户关键字内部可用。然而，可以通过使用作用域配置选项来改变这一点。支持的值有LOCAL（默认）、TEST（在当前测试中可用）、TASK（TEST的别名）、SUITE（在当前套件中可用）和GLOBAL（全局可用）。尽管Robot Framework变量是不区分大小写的，但建议使用大写字母表示非局部变量名。 123456789101112131415161718192021222324252627282930313233*** Variables ***$&#123;SUITE&#125; this value is overridden*** Test Cases ***Scope example VAR $&#123;local&#125; local value VAR $&#123;TEST&#125; test value scope=TEST VAR $&#123;SUITE&#125; suite value scope=SUITE VAR $&#123;GLOBAL&#125; global value scope=GLOBAL Should Be Equal $&#123;local&#125; local value Should Be Equal $&#123;TEST&#125; test value Should Be Equal $&#123;SUITE&#125; suite value Should Be Equal $&#123;GLOBAL&#125; global value Keyword Should Be Equal $&#123;TEST&#125; new test value Should Be Equal $&#123;SUITE&#125; new suite value Should Be Equal $&#123;GLOBAL&#125; new global valueScope example, part 2 Should Be Equal $&#123;SUITE&#125; new suite value Should Be Equal $&#123;GLOBAL&#125; new global value*** Keywords ***Keyword Should Be Equal $&#123;TEST&#125; test value Should Be Equal $&#123;SUITE&#125; suite value Should Be Equal $&#123;GLOBAL&#125; global value VAR $&#123;TEST&#125; new $&#123;TEST&#125; scope=TEST VAR $&#123;SUITE&#125; new $&#123;SUITE&#125; scope=SUITE VAR $&#123;GLOBAL&#125; new $&#123;GLOBAL&#125; scope=GLOBAL Should Be Equal $&#123;TEST&#125; new test value Should Be Equal $&#123;SUITE&#125; new suite value Should Be Equal $&#123;GLOBAL&#125; new global value 条件创建变量VAR语法可以与IF&#x2F;ELSE结构一起工作，这使得条件创建变量变得容易。在简单的情况下，使用内联IF可能很方便。 123456789101112*** Test Cases ***IF/ELSE example IF &quot;$&#123;ENV&#125;&quot; == &quot;devel&quot; VAR $&#123;address&#125; 127.0.0.1 VAR $&#123;name&#125; demo ELSE VAR $&#123;address&#125; 192.168.1.42 VAR $&#123;name&#125; robot ENDInline IF IF &quot;$&#123;ENV&#125;&quot; == &quot;devel&quot; VAR $&#123;name&#125; demo ELSE VAR $&#123;name&#125; robot 基于另一个变量创建变量名如果有需要，也可以根据另一个变量动态创建变量名。 12345*** Test Cases ***Dynamic name VAR $&#123;x&#125; y # Normal assignment. VAR $&#123;$&#123;x&#125;&#125; z # Name created dynamically. Should Be Equal $&#123;y&#125; z 使用Set Test&#x2F;Suite&#x2F;Global Variable关键字 注意 在使用Robot Framework 7.0或更高版本时，推荐使用VAR语法而不是这些关键字。 BuiltIn库有Set Test Variable、Set Suite Variable和Set Global Variable关键字，可以用于在测试执行期间动态设置变量。如果一个变量已经存在于新的作用域中，其值将被覆盖，否则将创建一个新的变量。 使用Set Test Variable关键字设置的变量在当前执行的测试用例的作用域内处处可用。例如，如果在一个用户关键字中设置了一个变量，它既可以在测试用例级别使用，也可以在当前测试中使用的所有其他用户关键字中使用。其他的测试用例将不会看到用这个关键字设置的变量。在测试的作用域之外调用Set Test Variable（例如，在套件设置或拆卸中）是一个错误。 使用Set Suite Variable关键字设置的变量在当前执行的测试套件的作用域内处处可用。因此，使用这个关键字设置变量具有与在测试数据文件中使用变量部分创建它们或从变量文件中导入它们相同的效果。其他的测试套件，包括可能的子测试套件，将不会看到用这个关键字设置的变量。 使用Set Global Variable关键字设置的变量在设置它们后执行的所有测试用例和套件中全局可用。因此，使用这个关键字设置变量具有与使用--variable或--variablefile选项从命令行创建它们相同的效果。因为这个关键字可以在任何地方改变变量，所以应该小心使用。 注意 Set Test/Suite/Global Variable关键字直接将命名变量设置到测试、套件或全局变量作用域，并且不返回任何东西。另一方面，另一个BuiltIn关键字Set Variable使用返回值设置局部变量。 内置变量Robot Framework自动提供了一些内置变量。 操作系统变量与操作系统相关的内置变量使得测试数据对操作系统无关。 变量 说明 $&#123;CURDIR&#125; 测试数据文件所在目录的绝对路径。此变量区分大小写。 $&#123;TEMPDIR&#125; 系统临时目录的绝对路径。在类 UNIX 系统中通常是 /tmp，在 Windows 中是 c:\\Documents and Settings\\&lt;user&gt;\\Local Settings\\Temp。 $&#123;EXECDIR&#125; 测试执行开始的目录的绝对路径。 $&#123;/&#125; 系统目录路径分隔符。在类 UNIX 系统中是 /，在 Windows 中是 \\。 $&#123;:&#125; 系统路径元素分隔符。在类 UNIX 系统中是 :，在 Windows 中是 ;。 $&#123;\\n&#125; 系统行分隔符。在类 UNIX 系统中是 \\n，在 Windows 中是 \\r\\n。 1234*** Test Cases ***Example Create Binary File $&#123;CURDIR&#125;$&#123;/&#125;input.data Some text here$&#123;\\n&#125;on two lines Set Environment Variable CLASSPATH $&#123;TEMPDIR&#125;$&#123;:&#125;$&#123;CURDIR&#125;$&#123;/&#125;foo.jar 数字变量变量语法可以用于创建整数和浮点数，如下例所示。当一个关键字期望得到一个实际的数字，而不是一个看起来像数字的字符串作为参数时，这是有用的。 123456789*** Test Cases ***Example 1A Connect example.com 80 # Connect gets two strings as argumentsExample 1B Connect example.com $&#123;80&#125; # Connect gets a string and an integerExample 2 Do X $&#123;3.14&#125; $&#123;-1e-4&#125; # Do X gets floating point numbers 3.14 and -0.0001 也可以使用0b、0o和0x前缀分别从二进制、八进制和十六进制值创建整数。语法不区分大小写。 123456*** Test Cases ***Example Should Be Equal $&#123;0b1011&#125; $&#123;11&#125; Should Be Equal $&#123;0o10&#125; $&#123;8&#125; Should Be Equal $&#123;0xff&#125; $&#123;255&#125; Should Be Equal $&#123;0B1010&#125; $&#123;0XA&#125; 布尔和None&#x2F;null变量也可以使用变量语法创建布尔值和Python的None，就像创建数字一样。 1234567*** Test Cases ***Boolean Set Status $&#123;true&#125; # Set Status gets Boolean true as an argument Create Y something $&#123;false&#125; # Create Y gets a string and Boolean falseNone Do XYZ $&#123;None&#125; # Do XYZ gets Python None as an argument 这些变量是不区分大小写的，所以例如$&#123;True&#125;和$&#123;true&#125;是等价的。 空格和空变量可以使用变量$&#123;SPACE&#125;和$&#123;EMPTY&#125;分别创建空格和空字符串。这些变量在需要转义空格或空单元格时很有用。如果需要多个空格，可以使用扩展变量语法，如$&#123;SPACE * 5&#125;。在下面的例子中，Should Be Equal关键字得到相同的参数，但使用变量的那些比使用反斜杠的更容易理解。 123456789101112131415161718*** Test Cases ***One space Should Be Equal $&#123;SPACE&#125; \\ \\Four spaces Should Be Equal $&#123;SPACE * 4&#125; \\ \\ \\ \\ \\Ten spaces Should Be Equal $&#123;SPACE * 10&#125; \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\Quoted space Should Be Equal &quot;$&#123;SPACE&#125;&quot; &quot; &quot;Quoted spaces Should Be Equal &quot;$&#123;SPACE * 2&#125;&quot; &quot; \\ &quot;Empty Should Be Equal $&#123;EMPTY&#125; \\ 还有一个空列表变量@&#123;EMPTY&#125;和一个空字典变量&amp;&#123;EMPTY&#125;。因为它们没有内容，所以当它们在测试数据中被使用时，基本上就消失了。它们在测试模板中很有用，例如当模板关键字没有参数时，或者在不同的作用域中覆盖列表或字典变量时。不能修改@&#123;EMPTY&#125;或&amp;&#123;EMPTY&#125;的值。 12345678*** Test Cases ***Template [Template] Some keyword @&#123;EMPTY&#125;Override Set Global Variable @&#123;LIST&#125; @&#123;EMPTY&#125; Set Suite Variable &amp;&#123;DICT&#125; &amp;&#123;EMPTY&#125; 信息 ${SPACE}表示ASCII空格（\\x20），其他空格应使用转义序列指定，如\\xA0（NO-BREAK SPACE）和\\u3000（IDEOGRAPHIC SPACE）。 自动变量在测试数据中也可以使用一些自动变量。这些变量在测试执行期间可以有不同的值，有些甚至不是一直可用。改变这些变量的值不会影响原始值，但是一些值可以使用BuiltIn库的关键字动态改变。 可用的自动变量如下： 变量 解释 可用性 ${TEST NAME} 当前测试用例的名称。 测试用例 @{TEST TAGS} 包含当前测试用例的标签，按字母顺序排列。可以使用Set Tags和Remove Tags关键字动态修改。 测试用例 ${TEST DOCUMENTATION} 当前测试用例的文档。可以使用Set Test Documentation关键字动态设置。 测试用例 ${TEST STATUS} 当前测试用例的状态，PASS或FAIL。 测试拆卸 ${TEST MESSAGE} 当前测试用例的消息。 测试拆卸 ${PREV TEST NAME} 上一个测试用例的名称，如果没有执行过测试，则为空字符串。 任何地方 ${PREV TEST STATUS} 上一个测试用例的状态：PASS、FAIL，或者当没有执行过测试时为空字符串。 任何地方 ${PREV TEST MESSAGE} 上一个测试用例可能的错误消息。 任何地方 ${SUITE NAME} 当前测试套件的全名。 任何地方 ${SUITE SOURCE} 套件文件或目录的绝对路径。 任何地方 ${SUITE DOCUMENTATION} 当前测试套件的文档。可以使用Set Suite Documentation关键字动态设置。 任何地方 &amp;{SUITE METADATA} 当前测试套件的自由元数据。可以使用Set Suite Metadata关键字设置。 任何地方 ${SUITE STATUS} 当前测试套件的状态，PASS或FAIL。 套件拆卸 ${SUITE MESSAGE} 当前测试套件的完整消息，包括统计信息。 套件拆卸 ${KEYWORD STATUS} 当前关键字的状态，PASS或FAIL。 用户关键字拆卸 ${KEYWORD MESSAGE} 当前关键字可能的错误消息。 用户关键字拆卸 ${LOG LEVEL} 当前日志级别。 任何地方 ${OUTPUT DIR} 输出目录的绝对路径，为字符串。 任何地方 ${OUTPUT FILE} 输出文件的绝对路径，为字符串，如果输出文件未创建，则为字符串NONE。 任何地方 ${LOG FILE} 日志文件的绝对路径，为字符串，如果日志文件未创建，则为字符串NONE。 任何地方 ${REPORT FILE} 报告文件的绝对路径，为字符串，如果报告文件未创建，则为字符串NONE。 任何地方 ${DEBUG FILE} 调试文件的绝对路径，为字符串，如果调试文件未创建，则为字符串NONE。 任何地方 &amp;{OPTIONS} 一个暴露命令行选项的字典。字典的键匹配命令行选项，可以像{OPTIONS}[key]和OPTIONS[key]和{OPTIONS.key}这样访问。可用的选项有：{OPTIONS.exclude} (–exclude)、OPTIONS.exclude(−−exclude)、{OPTIONS.include} (–include)、{OPTIONS.skip} (–skip)、OPTIONS.skip(−−skip)、{OPTIONS.skip_on_failure} (–skiponfailure)。在RF 5.0中新增。以后可以暴露更多的选项。 任何地方 套件相关的变量$&#123;SUITE SOURCE&#125;、$&#123;SUITE NAME&#125;、$&#123;SUITE DOCUMENTATION&#125;和&amp;&#123;SUITE METADATA&#125;以及与命令行选项相关的选项，如$&#123;LOG FILE&#125;和&amp;&#123;OPTIONS&#125;，在导入库和变量文件时就已经可用。然而，在导入时，这些自动变量中可能的变量还没有被解析。 变量优先级和作用域来自不同来源的变量有不同的优先级，并且在不同的作用域中可用。 变量优先级命令行中的变量在实际的测试执行开始之前，可以设置的所有变量中，命令行中设置的变量具有最高的优先级。它们会覆盖在测试用例文件的变量部分创建的可能的变量，以及在测试数据中导入的资源和变量文件中的变量。 单独设置的变量（--variable选项）会覆盖使用变量文件设置的变量（--variablefile选项）。如果多次指定同一个单独的变量，最后指定的那个将覆盖前面的。这允许在启动脚本中为变量设置默认值，并从命令行中覆盖它们。注意，如果多个变量文件有相同的变量，那么在首先指定的文件中的变量具有最高的优先级。 测试用例文件中的变量部分在测试用例文件的变量部分创建的变量对该文件中的所有测试用例都可用。这些变量会覆盖在导入的资源和变量文件中具有相同名称的可能的变量。 在变量部分创建的变量在创建它们的文件中的所有其他部分都可用。这意味着它们也可以在设置部分中使用，例如，用于从资源和变量文件中导入更多的变量。 导入的资源和变量文件从资源和变量文件导入的变量在测试数据中创建的所有变量中具有最低的优先级。资源文件和变量文件中的变量具有相同的优先级。如果几个资源和&#x2F;或变量文件有相同的变量，那么首先导入的文件中的变量将被使用。 如果一个资源文件导入资源文件或变量文件，那么它自己的变量部分中的变量具有比它导入的变量更高的优先级。所有这些变量都可用于导入此资源文件的文件。 注意，从资源和变量文件导入的变量在导入它们的文件的变量部分中不可用。这是因为在处理设置部分（其中导入资源文件和变量文件）之前，已经处理了变量部分。 在测试执行期间设置的变量在测试执行期间设置的变量，无论是使用关键字的返回值还是使用Set Test/Suite/Global Variable关键字，总是覆盖在它们被设置的作用域中可能存在的变量。从某种意义上说，它们因此具有最高的优先级，但另一方面，它们不影响它们定义的作用域之外的变量。 内置变量像$&#123;TEMPDIR&#125;和$&#123;TEST_NAME&#125;这样的内置变量具有所有变量中最高的优先级。它们不能使用变量部分或从命令行覆盖，但即使它们也可以在测试执行期间重置。这个规则的一个例外是数字变量，如果没有找到其他变量，它们会动态地被解析。因此，它们可以被覆盖，但这通常是一个坏主意。此外，$&#123;CURDIR&#125;是特殊的，因为它在测试数据处理时间就已经被替换了。 变量作用域根据它们的创建位置和方式，变量可以具有全局、测试套件、测试用例或局部作用域。 全局作用域全局变量在测试数据中的任何地方都可用。这些变量通常在命令行中使用--variable和--variablefile选项设置，但也可以在测试数据的任何地方使用VAR语法或Set Global Variable关键字创建新的全局变量或更改现有的全局变量。此外，内置变量也是全局的。 建议使用大写字母表示所有全局变量。 测试套件作用域具有测试套件作用域的变量在定义或导入它们的测试套件的任何地方都可用。它们可以在变量部分中创建，从资源和变量文件中导入，或者在测试执行期间使用VAR语法或Set Suite Variable关键字设置。 测试套件作用域不是递归的，这意味着在高级测试套件中可用的变量在低级套件中不可用。如果需要，可以使用资源和变量文件共享变量。 由于这些变量在使用它们的测试套件中可以被认为是全局的，因此也建议使用大写字母表示它们。 测试用例作用域具有测试用例作用域的变量在测试用例和测试使用的所有用户关键字中可见。最初在这个作用域中没有变量，但是可以在测试用例的任何地方使用VAR语法或Set Test Variable关键字创建它们。在套件设置或套件拆卸中尝试创建测试变量会导致错误。 测试用例作用域中的变量也在某种程度上是全局的。因此，通常建议使用大写字母表示它们。 局部作用域测试用例和用户关键字有一个局部变量作用域，其他测试或关键字看不到。局部变量可以使用执行的关键字的返回值和VAR语法创建，用户关键字也可以将它们作为参数获取。 建议使用小写字母表示局部变量。 高级变量特性扩展变量语法扩展变量语法允许访问分配给变量的对象的属性（例如，$&#123;object.attribute&#125;）甚至调用其方法（例如，$&#123;obj.getName()&#125;）。它既适用于标量变量，也适用于列表变量，但主要用于前者。 扩展变量语法是一个强大的特性，但应谨慎使用。访问属性通常不是问题，相反，因为一个包含多个属性的对象的变量通常比有多个变量更好。另一方面，调用方法，特别是当它们带有参数时，可能会使测试数据变得相当复杂。如果发生这种情况，建议将代码移动到测试库中。 下面的例子说明了扩展变量语法的最常见用法。首先假设有以下变量文件和测试用例： 123456789101112131415161718class MyObject: def __init__(self, name): self.name = name def eat(self, what): return &#x27;%s eats %s&#x27; % (self.name, what) def __str__(self): return self.nameOBJECT = MyObject(&#x27;Robot&#x27;)DICTIONARY = &#123;1: &#x27;one&#x27;, 2: &#x27;two&#x27;, 3: &#x27;three&#x27;&#125;*** Test Cases ***Example KW 1 $&#123;OBJECT.name&#125; KW 2 $&#123;OBJECT.eat(&#x27;Cucumber&#x27;)&#125; KW 3 $&#123;DICTIONARY[2]&#125; 当执行这个测试数据时，关键字得到的参数如下： KW 1得到字符串Robot KW 2得到字符串Robot eats Cucumber KW 3得到字符串two 扩展变量语法按以下顺序进行评估： 使用完整的变量名搜索变量。只有在没有找到匹配的变量时，才会评估扩展变量语法。 创建基变量的名称。名称的主体由打开&#123;后的所有字符组成，直到第一个不是字母数字字符或空格的字符出现。例如，$&#123;OBJECT.name&#125;和$&#123;DICTIONARY[2]&#125;的基变量分别是OBJECT和DICTIONARY。 搜索与主体匹配的变量。如果没有匹配，将引发异常并使测试用例失败。 将花括号内的表达式作为Python表达式进行评估，以便将基变量名替换为其值。如果评估失败，因为语法无效或查询的属性不存在，将引发异常并使测试失败。 将整个扩展变量替换为从评估返回的值。 许多标准的Python对象，包括字符串和数字，都有可以使用扩展变量语法显式或隐式使用的方法。有时这可能非常有用，减少了设置临时变量的需要，但也很容易过度使用它，创建真正的神秘测试数据。下面的例子展示了一些相当好的用法。 12345678910*** Test Cases ***String $&#123;string&#125; = Set Variable abc Log $&#123;string.upper()&#125; # Logs &#x27;ABC&#x27; Log $&#123;string * 2&#125; # Logs &#x27;abcabc&#x27;Number $&#123;number&#125; = Set Variable $&#123;-2&#125; Log $&#123;number * 10&#125; # Logs -20 Log $&#123;number.__abs__()&#125; # Logs 2 注意 尽管在正常的Python代码中推荐使用abs(number)而不是number.__abs__()，但使用${abs(number)}是不起作用的。这是因为变量名必须在扩展语法的开始。在测试数据中像这样使用__xxx__方法已经有点可疑了，通常最好将这种逻辑移动到测试库中。 扩展变量语法也适用于列表变量上下文。例如，如果一个分配给变量$&#123;EXTENDED&#125;的对象有一个包含列表值的属性，它可以被用作列表变量@&#123;EXTENDED.attribute&#125;。 扩展变量赋值可以使用关键字返回值和扩展变量语法的变体，将对象的属性设置到标量变量中。假设有前面例子中的变量$&#123;OBJECT&#125;，可以像下面的例子那样设置它的属性。 1234*** Test Cases ***Example $&#123;OBJECT.name&#125; = Set Variable New name $&#123;OBJECT.new_attr&#125; = Set Variable New attribute 扩展变量赋值语法按照以下规则进行评估： 被赋值的变量必须是一个标量变量，并且至少有一个点。否则，不使用扩展赋值语法，而是正常赋值变量。 如果存在一个与完整名称相匹配的变量（例如，上面例子中的$&#123;OBJECT.name&#125;），那么该变量将被赋予一个新的值，不使用扩展语法。 创建基变量的名称。名称的主体由打开$&#123;和最后一个点之间的所有字符组成，例如，$&#123;OBJECT.name&#125;中的OBJECT和$&#123;foo.bar.zap&#125;中的foo.bar。正如第二个例子所示，基名称可能包含正常的扩展变量语法。 通过取最后一个点和闭合&#125;之间的所有字符来创建要设置的属性的名称，例如，$&#123;OBJECT.name&#125;中的name。如果名称不是以字母或下划线开头，并且只包含这些字符和数字，那么该属性被认为是无效的，不使用扩展语法。而是创建一个具有完整名称的新变量。 搜索与基名称匹配的变量。如果没有找到变量，那么不使用扩展语法，而是使用完整的变量名称创建一个新的变量。 如果找到的变量是一个字符串或一个数字，那么忽略扩展语法，并使用完整的名称创建一个新的变量。这是因为不能向Python字符串或数字添加新的属性，这样新的语法也不会向后不兼容。 如果所有前面的规则都匹配，那么属性被设置到基变量。如果设置失败，由于任何原因，将引发异常并使测试失败。 注意 与通常使用关键字返回值赋值变量不同，使用扩展赋值语法对变量进行的更改不限于当前作用域。因为没有创建新的变量，而是改变了现有变量的状态，所以所有看到该变量的测试和关键字也会看到这些更改。 变量内的变量变量也可以在变量内部，当使用这种语法时，变量从内到外进行解析。例如，如果有一个变量$&#123;var$&#123;x&#125;&#125;，那么$&#123;x&#125;首先被解析。如果它的值是name，那么最终的值就是变量$&#123;varname&#125;的值。可以有多个嵌套的变量，但如果它们中的任何一个不存在，解析最外层的变量就会失败。 在下面的例子中，Do X获取的值是$&#123;JOHN HOME&#125;或$&#123;JANE HOME&#125;，取决于Get Name返回的是john还是jane。如果它返回其他的东西，解析$&#123;$&#123;name&#125; HOME&#125;就会失败。 12345678*** Variables ***$&#123;JOHN HOME&#125; /home/john$&#123;JANE HOME&#125; /home/jane*** Test Cases ***Example $&#123;name&#125; = Get Name Do X $&#123;$&#123;name&#125; HOME&#125; 内联Python评估变量语法也可以用于评估Python表达式。基本语法是$&#123;&#123;expression&#125;&#125;，即表达式周围有双花括号。表达式可以是任何有效的Python表达式，如$&#123;&#123;1 + 2&#125;&#125;或$&#123;&#123;['a', 'list']&#125;&#125;。允许在表达式周围有空格，所以$&#123;&#123; 1 + 2 &#125;&#125;和$&#123;&#123; ['a', 'list'] &#125;&#125;也是有效的。除了使用正常的标量变量，列表变量和字典变量也分别支持@&#123;&#123;expression&#125;&#125;和&amp;&#123;&#123;expression&#125;&#125;语法。 这个相当高级的功能的主要用途是： 评估涉及Robot Framework的变量的Python表达式（$&#123;&#123;len('$&#123;var&#125;') > 3&#125;&#125;，$&#123;&#123;$var[0] if $var is not None else None&#125;&#125;）。 创建不是Python基本类型的值（$&#123;&#123;decimal.Decimal('0.11')&#125;&#125;，$&#123;&#123;datetime.date(2019, 11, 5)&#125;&#125;）。 动态创建值（$&#123;&#123;random.randint(0, 100)&#125;&#125;，$&#123;&#123;datetime.date.today()&#125;&#125;）。 构造集合，特别是嵌套的集合（$&#123;&#123;[1, 2, 3, 4]&#125;&#125;，$&#123;&#123; &#123;'id': 1, 'name': 'Example', 'children': [7, 9]&#125; &#125;&#125;）。 访问Python模块中的常量和其他有用的属性（$&#123;&#123;math.pi&#125;&#125;，$&#123;&#123;platform.system()&#125;&#125;）。 这与前面讨论的扩展变量语法有一些类似的功能。如上面的例子所示，这种语法更强大，因为它提供了访问Python内置函数如len()和模块如math的能力。除了能够在表达式中使用像$&#123;var&#125;这样的变量（它们在评估之前被替换），在评估期间还可以使用特殊的$var语法使用变量。整个表达式语法在评估表达式附录中有解释。 信息 与其创建复杂的表达式，通常最好将逻辑移动到自定义库中。这样可以简化维护，使测试数据更容易理解，也可以提高执行速度。 注意 内联Python评估语法是在Robot Framework 3.2中新增的。 创建用户关键字关键字部分用于通过组合现有关键字来创建新的高级关键字。这些关键字被称为用户关键字，以区别于在测试库中实现的最低级别的库关键字。创建用户关键字的语法与创建测试用例的语法非常接近，这使得学习变得容易。 基本语法在很多方面，用户关键字的整体语法与测试用例语法相同。用户关键字在关键字部分中创建，这与测试用例部分的区别仅在于用于标识它们的名称。用户关键字的名称与测试用例名称一样，位于第一列。此外，用户关键字也是由关键字创建的，无论是来自测试库的关键字还是其他用户关键字。关键字名称通常在第二列，但是在从关键字返回值设置变量时，它们在后续列中。 123456789*** Keywords ***Open Login Page Open Browser http://host/login.html Title Should Be Login PageTitle Should Start With [Arguments] $&#123;expected&#125; $&#123;title&#125; = Get Title Should Start With $&#123;title&#125; $&#123;expected&#125; 大多数用户关键字需要一些参数。这个重要的特性已经在上面的第二个例子中使用了，它在本节后面详细解释，与用户关键字返回值类似。 用户关键字可以在套件文件、资源文件和套件初始化文件中创建。在资源文件中创建的关键字对使用它们的文件可用，而其他关键字只在创建它们的文件中可用。 关键字部分中的设置用户关键字可以有与测试用例类似的设置，它们有相同的方括号语法将它们与关键字名称分开。所有可用的设置都列在下面，并在本节后面解释。 [Documentation] 用于设置用户关键字文档。 [Tags] 为关键字设置标签。 [Arguments] 指定用户关键字参数。 [Setup], [Teardown] 指定用户关键字的设置和拆卸。[Setup]是在Robot Framework 7.0中新增的。 [Timeout] 设置可能的用户关键字超时。超时在自己的部分中讨论。 [Return] 指定用户关键字返回值。在Robot Framework 7.0中已弃用，应使用RETURN语句。 注意 上面使用的格式是推荐的，但设置名称不区分大小写，方括号和名称之间允许有空格。例如，[ TAGS ]:setting是有效的。 用户关键字的名称和文档用户关键字的名称在关键字部分的第一列中定义。当然，名称应该是描述性的，接受有相当长的关键字名称。实际上，当创建用例样式的测试用例时，最高级别的关键字通常被构造为句子甚至段落。 用户关键字可以有一个文档，通过[Documentation]设置进行设置。它支持与测试用例文档相同的格式，分割到多行，以及其他特性。这个设置在测试数据中记录了用户关键字。它也显示在更正式的关键字文档中，Libdoc工具可以从资源文件中创建这个文档。最后，文档的第一行逻辑行，直到第一个空行，显示为测试日志中的关键字文档。 1234567891011121314151617181920*** Keywords ***One line documentation [Documentation] One line documentation. No OperationMultiline documentation [Documentation] The first line creates the short doc. ... ... This is the body of the documentation. ... It is not shown in Libdoc outputs but only ... the short doc is shown in logs. No OperationShort documentation in multiple lines [Documentation] If the short doc gets longer, it can span ... multiple physical lines. ... ... The body is separated from the short doc with ... an empty line. No Operation 有时候，关键字需要被移除，替换为新的，或者由于其他原因被弃用。用户关键字可以通过在文档开始处标记DEPRECATED来标记为弃用，这将在使用关键字时引发警告。有关更多信息，请参见弃用关键字部分。 注意 在Robot Framework 3.1之前，简短的文档只包含关键字文档的第一行物理行。 用户关键字标签用户关键字和库关键字都可以有标签。与标记测试用例类似，有两个设置影响用户关键字标签： 在设置部分的关键字标签设置 所有在此设置的文件中的关键字总是获得指定的标签。 每个关键字的[Tags]设置 关键字获得这些标签，除了可能使用关键字标签设置指定的标签。[Tags]设置还允许使用-tag语法删除关键字标签设置的标签。 1234567891011121314151617*** Settings ***Keyword Tags gui html*** Keywords ***No own tags [Documentation] Keyword has tags &#x27;gui&#x27; and &#x27;html&#x27;. No OperationOwn tags [Documentation] Keyword has tags &#x27;gui&#x27;, &#x27;html&#x27;, &#x27;own&#x27; and &#x27;tags&#x27;. [Tags] own tags No OperationRemove common tag [Documentation] Test has tags &#x27;gui&#x27; and &#x27;own&#x27;. [Tags] own -html No Operation 关键字标签可以使用变量指定，-tag语法支持模式等，与测试用例标签完全一样。 除了使用专用设置外，关键字标签也可以在文档的最后一行使用Tags:前缀指定，以便用逗号分隔标签。例如，以下两个关键字获得相同的三个标签： 123456789*** Keywords ***Settings tags using separate setting [Tags] my fine tags No OperationSettings tags using documentation [Documentation] I have documentation. And my documentation has tags. ... Tags: my, fine, tags No Operation 关键字标签显示在日志和由Libdoc生成的文档中，其中关键字也可以基于标签进行搜索。--removekeywords和--flattenkeywords命令行选项也支持通过标签选择关键字，以后可能会添加关键字标签的新用途。 与测试用例标签类似，用户关键字标签带有robot:前缀是由Robot Framework本身保留的特殊功能。因此，用户不应使用这些前缀的任何标签，除非实际激活特殊功能。从Robot Framework 6.1开始，可以使用保留的标签robot:flatten在执行时间内展开关键字。 注意 关键字标签是在Robot Framework 6.0中新增的。在早期版本中，所有关键字标签都需要使用[Tags]设置指定。 注意 删除常见标签的-tag语法是在Robot Framework 7.0中新增的。 用户关键字参数大多数用户关键字需要接受一些参数。指定它们的语法可能是使用Robot Framework通常需要的最复杂的特性，但即使是这样，它也相对容易，特别是在最常见的情况下。参数通常使用[Arguments]设置指定，参数名称使用与变量相同的语法，例如$&#123;arg&#125;。 用户关键字的位置参数指定参数的最简单方式（除了根本不需要它们）是只使用位置参数。在大多数情况下，这就是所有需要的。 语法是这样的，首先给出[Arguments]设置，然后在后续的单元格中定义参数名称。每个参数都在自己的单元格中，使用与变量相同的语法。关键字必须使用与其签名中的参数名称一样多的参数。实际的参数名称对框架来说并不重要，但从用户的角度来看，它们应该尽可能具有描述性。建议在变量名称中使用小写字母，无论是$&#123;my_arg&#125;，$&#123;my arg&#125;还是$&#123;myArg&#125;。 12345678910*** Keywords ***One Argument [Arguments] $&#123;arg_name&#125; Log Got argument $&#123;arg_name&#125;Three Arguments [Arguments] $&#123;arg1&#125; $&#123;arg2&#125; $&#123;arg3&#125; Log 1st argument: $&#123;arg1&#125; Log 2nd argument: $&#123;arg2&#125; Log 3rd argument: $&#123;arg3&#125; 用户关键字的默认值在创建用户关键字时，位置参数在大多数情况下是足够的。然而，有时候关键字对一些或所有的参数有默认值是有用的。用户关键字也支持默认值，需要的新语法并没有给已经讨论过的基本语法增加很多内容。 简单来说，默认值被添加到参数中，首先是等号（&#x3D;），然后是值，例如$&#123;arg&#125;=default。可以有许多带有默认值的参数，但它们都必须在正常的位置参数之后给出。默认值可以包含在测试、套件或全局范围内创建的变量，但不能使用关键字执行器的局部变量。默认值也可以根据关键字接受的早期参数定义。 注意 默认值的语法对空格敏感。等号前不允许有空格，等号后可能的空格被认为是默认值本身的一部分。 12345678910111213141516171819202122*** Keywords ***One Argument With Default Value [Arguments] $&#123;arg&#125;=default value [Documentation] This keyword takes 0-1 arguments Log Got argument $&#123;arg&#125;Two Arguments With Defaults [Arguments] $&#123;arg1&#125;=default 1 $&#123;arg2&#125;=$&#123;VARIABLE&#125; [Documentation] This keyword takes 0-2 arguments Log 1st argument $&#123;arg1&#125; Log 2nd argument $&#123;arg2&#125;One Required And One With Default [Arguments] $&#123;required&#125; $&#123;optional&#125;=default [Documentation] This keyword takes 1-2 arguments Log Required: $&#123;required&#125; Log Optional: $&#123;optional&#125; Default Based On Earlier Argument [Arguments] $&#123;a&#125; $&#123;b&#125;=$&#123;a&#125; $&#123;c&#125;=$&#123;a&#125; and $&#123;b&#125; Should Be Equal $&#123;a&#125; $&#123;b&#125; Should Be Equal $&#123;c&#125; $&#123;a&#125; and $&#123;b&#125; 当一个关键字接受几个带有默认值的参数，只有其中一些需要被覆盖时，通常使用命名参数语法是方便的。当这种语法用于用户关键字时，参数被指定，而不使用$&#123;&#125;装饰。例如，上面的第二个关键字可以像下面这样使用，$&#123;arg1&#125;仍然会得到它的默认值。 123*** Test Cases ***Example Two Arguments With Defaults arg2=new value 所有的Pythonistas都已经注意到，指定默认参数的语法大量借鉴了Python函数默认值的语法。 用户关键字的可变数量参数有时候，即使有默认值也不够，需要一个关键字接受可变数量的参数。用户关键字也支持这个特性。所有需要的就是在关键字签名中可能的位置参数之后有一个列表变量，如@&#123;varargs&#125;。这个语法可以与前面描述的默认值结合使用，最后，列表变量得到所有剩余的参数，这些参数不匹配其他参数。因此，列表变量可以有任何数量的项，甚至是零。 1234567891011121314151617*** Keywords ***Any Number Of Arguments [Arguments] @&#123;varargs&#125; Log Many @&#123;varargs&#125;One Or More Arguments [Arguments] $&#123;required&#125; @&#123;rest&#125; Log Many $&#123;required&#125; @&#123;rest&#125;Required, Default, Varargs [Arguments] $&#123;req&#125; $&#123;opt&#125;=42 @&#123;others&#125; Log Required: $&#123;req&#125; Log Optional: $&#123;opt&#125; Log Others: FOR $&#123;item&#125; IN @&#123;others&#125; Log $&#123;item&#125; END 注意 如果上面的最后一个关键字用多于一个的参数使用，第二个参数${opt}总是得到给定的值，而不是默认值。即使给定的值是空的，也会发生这样的情况。最后一个例子也说明了用户关键字接受的可变数量的参数如何在for循环中使用。这种两个相当高级的函数的组合有时候可能非常有用。 上面的例子中的关键字可以像这样使用： 12345678910*** Test Cases ***Varargs with user keywords Any Number Of Arguments Any Number Of Arguments arg Any Number Of Arguments arg1 arg2 arg3 arg4 One Or More Arguments required One Or More Arguments arg1 arg2 arg3 arg4 Required, Default, Varargs required Required, Default, Varargs required optional Required, Default, Varargs arg1 arg2 arg3 arg4 arg5 再次，Pythonistas可能注意到，可变数量的参数语法非常接近Python中的语法。 用户关键字的自由命名参数用户关键字也可以通过在关键字签名中将字典变量（如&amp;&#123;named&#125;）作为绝对最后的参数来接受自由命名的参数。当调用关键字时，这个变量将得到所有不匹配关键字签名中的任何位置参数或仅命名参数的命名参数。 123456789101112*** Keywords ***Free Named Only [Arguments] &amp;&#123;named&#125; Log Many &amp;&#123;named&#125;Positional And Free Named [Arguments] $&#123;required&#125; &amp;&#123;extra&#125; Log Many $&#123;required&#125; &amp;&#123;extra&#125;Run Program [Arguments] @&#123;args&#125; &amp;&#123;config&#125; Run Process program.py @&#123;args&#125; &amp;&#123;config&#125; 上面的最后一个例子显示了如何创建一个包装关键字，它接受任何位置或命名参数，并将它们传递。参见自由命名参数示例以获取同一关键字的完整示例。 用户关键字的自由命名参数支持与Python中的kwargs工作方式类似。在签名中，以及在传递参数时，&amp;&#123;kwargs&#125;与Python的**kwargs几乎相同。 用户关键字的仅命名参数从Robot Framework 3.1开始，用户关键字支持仅命名参数，这些参数受到Python 3关键字仅参数的启发。这种语法通常是在可变数量的参数（@&#123;varargs&#125;）之后有正常的参数。如果关键字不使用varargs，可以只使用@&#123;&#125;来表示后续的参数是仅命名的： 12345678*** Keywords ***With Varargs [Arguments] @&#123;varargs&#125; $&#123;named&#125; Log Many @&#123;varargs&#125; $&#123;named&#125;Without Varargs [Arguments] @&#123;&#125; $&#123;first&#125; $&#123;second&#125; Log Many $&#123;first&#125; $&#123;second&#125; 仅命名参数可以与位置参数以及自由命名参数一起使用。当使用自由命名参数时，它们必须是最后的： 12345678*** Keywords ***With Positional [Arguments] $&#123;positional&#125; @&#123;&#125; $&#123;named&#125; Log Many $&#123;positional&#125; $&#123;named&#125;With Free Named [Arguments] @&#123;varargs&#125; $&#123;named only&#125; &amp;&#123;free named&#125; Log Many @&#123;varargs&#125; $&#123;named only&#125; &amp;&#123;free named&#125; 当向关键字传递仅命名参数时，它们的顺序并不重要，只要它们遵循可能的位置参数。例如，上面的关键字可以像这样使用： 12345678910*** Test Cases ***Example With Varargs named=value With Varargs positional second positional named=foobar Without Varargs first=1 second=2 Without Varargs second=toka first=eka With Positional foo named=bar With Positional named=2 positional=1 With Free Named positional named only=value x=1 y=2 With Free Named foo=a bar=b named only=c quux=d 仅命名参数可以有默认值，与正常的用户关键字参数类似。一个小的区别是，有和没有默认值的参数的顺序并不重要。 12345678*** Keywords ***With Default [Arguments] @&#123;&#125; $&#123;named&#125;=default Log Many $&#123;named&#125;With And Without Defaults [Arguments] @&#123;&#125; $&#123;optional&#125;=default $&#123;mandatory&#125; $&#123;mandatory 2&#125; $&#123;optional 2&#125;=default 2 $&#123;mandatory 3&#125; Log Many $&#123;optional&#125; $&#123;mandatory&#125; $&#123;mandatory 2&#125; $&#123;optional 2&#125; $&#123;mandatory 3&#125; 将参数嵌入到关键字名称中上一节解释了如何将参数传递给关键字，使它们在关键字名称后单独列出。Robot Framework还有另一种传递参数的方法，即直接将参数嵌入到关键字名称中，如下面的第二个测试所使用： 123456*** Test Cases ***Normal arguments Select from list catEmbedded arguments Select cat from list 如上例所示，将参数嵌入到关键字名称中可以使数据更易于阅读和理解，即使对没有任何Robot Framework经验的人也是如此。 基本语法上一个例子展示了如何使用关键字Select cat from list比使用Select from list将cat作为参数传递给它更流畅。显然可以将Select cat from list实现为一个正常的关键字，不接受任何参数，但是然后需要为其他动物实现各种其他关键字，如Select dog from list。嵌入式参数简化了这个问题，可以代替实现只有一个关键字，名称为Select $&#123;animal&#125; from list，并用任何动物使用它： 123456789*** Test Cases ***Embedded arguments Select cat from list Select dog from list*** Keywords ***Select $&#123;animal&#125; from list Open Page Pet Selection Select Item From List animal_list $&#123;animal&#125; 如上例所示，嵌入式参数只是通过在关键字名称中使用变量来指定。在名称中使用的参数自然地在关键字内部可用，并且它们的值取决于如何调用关键字。在上面的例子中，当关键字第一次使用时，$&#123;animal&#125;的值是cat，当它第二次使用时，值是dog。 从Robot Framework 6.1开始，可以创建接受嵌入式和”正常”参数的用户关键字： 1234567891011*** Test Cases ***Embedded and normal arguments Number of cats should be 2 Number of dogs should be count=3*** Keywords ***Number of $&#123;animals&#125; should be [Arguments] $&#123;count&#125; Open Page Pet Selection Select Items From List animal_list $&#123;animals&#125; Number of Selected List Items Should Be $&#123;count&#125; 除了特殊的名称，嵌入式参数的关键字就像其他用户关键字一样创建。它们也像其他关键字一样使用，除了在匹配关键字时，它们的名称中不忽略空格和下划线。然而，它们像其他关键字一样不区分大小写。例如，关键字Select $&#123;animal&#125; from list可以像select cow from list那样使用，但不能像Select cow fromlist那样使用。 嵌入式参数不支持像正常参数那样的默认值或可变数量的参数。如果需要这样的功能，应该使用正常参数。可以将嵌入式参数作为变量传递，但这可能会降低可读性： 1234567891011*** Variables ***$&#123;SELECT&#125; cat*** Test Cases ***Embedded arguments with variable Select $&#123;SELECT&#125; from list*** Keywords ***Select $&#123;animal&#125; from list Open Page Pet Selection Select Item From List animal_list $&#123;animal&#125; 嵌入参数匹配错误的值使用嵌入参数的一个棘手部分是确保在调用关键字时使用的值匹配正确的参数。这是一个问题，特别是如果有多个参数，并且分隔它们的字符也可能出现在给定的值中。例如，在下面的例子中，Select Los Angeles Lakers匹配Select $&#123;city&#125; $&#123;team&#125;，使得$&#123;city&#125;包含Los，$&#123;team&#125;包含Angeles Lakers： 12345678*** Test Cases ***Example Select Chicago Bulls Select Los Angeles Lakers*** Keywords ***Select $&#123;city&#125; $&#123;team&#125; Log Selected $&#123;team&#125; from $&#123;city&#125;. 解决这个问题的一个简单方法是用双引号或其他实际值中未使用的字符包围参数。这个修复的例子工作得很好，城市和团队匹配正确： 12345678*** Test Cases ***Example Select &quot;Chicago&quot; &quot;Bulls&quot; Select &quot;Los Angeles&quot; &quot;Lakers&quot;*** Keywords ***Select &quot;$&#123;city&#125;&quot; &quot;$&#123;team&#125;&quot; Log Selected $&#123;team&#125; from $&#123;city&#125;. 这种方法不能解决所有的冲突，但它在常见的情况下有所帮助，通常推荐使用。另一个好处是，它使参数从关键字的其余部分突出出来。 当创建忽略Behavior Driven Development (BDD)中通常使用的given&#x2F;when&#x2F;then&#x2F;and&#x2F;but前缀的关键字时，参数匹配过多的问题经常出现。例如，$&#123;name&#125; goes home匹配Given Janne goes home，使得$&#123;name&#125;得到Given Janne的值。像&quot;$&#123;name&#125;&quot; goes home这样的参数周围的引号，可以轻松解决这个问题。 限制参数匹配什么值的另一种解决方案是使用自定义正则表达式。 解决冲突当使用嵌入参数时，很常见的一种情况是有多个关键字实现与使用的关键字匹配。例如，在下面的例子中，Execute &quot;ls&quot; with &quot;lf&quot;匹配了两个关键字。它匹配Execute &quot;$&#123;cmd&#125;&quot; with &quot;$&#123;opts&#125;&quot;是非常明显的，也是想要的，但它也匹配Execute &quot;$&#123;cmd&#125;&quot;，使得$&#123;cmd&#125;匹配ls&quot; with &quot;-lh。 1234567891011121314*** Settings ***Library Process*** Test Cases ***Automatic conflict resolution Execute &quot;ls&quot; Execute &quot;ls&quot; with &quot;-lh&quot;*** Keywords ***Execute &quot;$&#123;cmd&#125;&quot; Run Process $&#123;cmd&#125; shell=TrueExecute &quot;$&#123;cmd&#125;&quot; with &quot;$&#123;opts&#125;&quot; Run Process $&#123;cmd&#125; $&#123;opts&#125; shell=True 当这种冲突发生时，Robot Framework试图自动选择最佳匹配并使用它。在上面的例子中，Execute &quot;$&#123;cmd&#125;&quot; with &quot;$&#123;opts&#125;&quot;被认为是比更通用的Execute &quot;$&#123;cmd&#125;&quot;更好的匹配，因此运行示例就成功了，没有冲突。 并不总是可能找到一个比其他的更好的匹配。例如，下面的第二个测试失败，因为Robot Framework将两个关键字匹配得同样好。这种冲突需要手动解决，要么通过重命名关键字，要么通过使用自定义正则表达式。 1234567891011121314*** Test Cases ***No conflict Automation framework Robot uprisingUnresolvable conflict Robot Framework*** Keywords ***$&#123;type&#125; Framework Should Be Equal $&#123;type&#125; AutomationRobot $&#123;action&#125; Should Be Equal $&#123;action&#125; uprising 接受只有”正常”参数或根本没有参数的关键字被认为比接受嵌入参数的关键字匹配得更好。例如，如果将以下关键字添加到上面的例子中，Robot Framework在后面的测试中使用的关键字匹配它，测试成功： 123*** Keywords ***Robot Framework No Operation 在查看哪个匹配最好之前，Robot Framework检查是否有一些匹配的关键字在调用者关键字的同一文件中实现。如果有这样的关键字，它们将优先于其他关键字。或者，可以使用库搜索顺序来控制Robot Framework在资源和库中查找关键字的顺序。 注意 如果多个带有嵌入参数的关键字匹配，自动解决冲突是Robot Framework 6.0中的新特性。在早期版本中，可以使用下面解释的自定义正则表达式代替。 使用自定义正则表达式当调用带有嵌入参数的关键字时，内部使用正则表达式（简称regexps）匹配值。默认的逻辑是，名称中的每个参数都被替换为一个模式.*?，该模式匹配任何字符串，并尽可能少地匹配。这个逻辑通常工作得相当好，但如上所述，有时关键字匹配错误的值，有时存在无法解决的冲突。在这些情况下，解决方案是指定一个自定义的正则表达式，确保关键字只匹配它应该在那个特定上下文中匹配的内容。要能够使用这个特性，并完全理解本节中的例子，需要至少理解正则表达式语法的基础。 自定义嵌入参数的正则表达式在参数的基本名称之后定义，参数和regexp用冒号分隔。例如，应该只匹配数字的参数可以定义为$&#123;arg:\\d+&#125;。 使用自定义正则表达式的示例如下。注意，第一个例子显示了如何解决Select $&#123;city&#125; $&#123;team&#125;不正确匹配Select Los Angeles Lakers的早期问题，而不需要引用。这是通过实现关键字来实现的，使得$&#123;team&#125;只能包含非空白字符。 12345678910111213141516171819202122232425262728293031*** Settings ***Library DateTime*** Test Cases ***Do not match whitespace characters Select Chicago Bulls Select Los Angeles LakersMatch numbers and characters from set 1 + 2 = 3 53 - 11 = 42Match either date or literal &#x27;today&#x27; Deadline is 2022-09-21 Deadline is today*** Keywords ***Select $&#123;city&#125; $&#123;team:\\S+&#125; Log Selected $&#123;team&#125; from $&#123;city&#125;.$&#123;number1:\\d+&#125; $&#123;operator:[+-]&#125; $&#123;number2:\\d+&#125; = $&#123;expected:\\d+&#125; $&#123;result&#125; = Evaluate $&#123;number1&#125; $&#123;operator&#125; $&#123;number2&#125; Should Be Equal As Integers $&#123;result&#125; $&#123;expected&#125;Deadline is $&#123;date:(\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;|today)&#125; IF &#x27;$&#123;date&#125;&#x27; == &#x27;today&#x27; $&#123;date&#125; = Get Current Date ELSE $&#123;date&#125; = Convert Date $&#123;date&#125; END Log Deadline is on $&#123;date&#125;. 支持的正则表达式语法由于是用Python实现的，Robot Framework自然使用Python的re模块，它有相当标准的正则表达式语法。这种语法在其他方面都得到了嵌入参数的完全支持，但不能使用格式为(?...)的regexp扩展。如果正则表达式语法无效，创建关键字会失败，错误可在测试执行错误中看到。 转义特殊字符正则表达式大量使用反斜杠字符（\\），既用于形成特殊序列（例如\\d），也用于转义在regexps中有特殊含义的字符（例如\\$）。通常在Robot Framework数据中，反斜杠字符需要用另一个反斜杠转义，但在这个上下文中不需要。如果需要在模式中有一个字面反斜杠，那么反斜杠必须像$&#123;path:c:\\\\temp\\\\.*&#125;那样被转义。 在模式中可能的孤立的开放和关闭的大括号必须像$&#123;open:\\&#123;&#125;和$&#123;close:\\&#125;&#125;那样被转义，否则Robot Framework无法正确解析变量语法。如果有匹配的大括号，像$&#123;digits:\\d&#123;2&#125;&#125;那样，不需要转义。 注意 在Robot Framework 3.2之前，必须像${digits:\\d{2\\}}那样在模式中转义所有的关闭大括号。这种语法不幸的是不被Robot Framework 3.2或更高版本支持，使用它的关键字必须在升级时更新。 注意 在Robot Framework 6.0之前，在模式中使用字面反斜杠需要像${path:c:\\\\\\\\temp\\\\\\\\.*}那样将它们双重转义。使用字面反斜杠的模式需要在升级时更新。 使用自定义嵌入参数的正则表达式当使用自定义正则表达式的嵌入参数时，Robot Framework会自动增强指定的正则表达式，使它们匹配变量以及匹配模式的文本。例如，使用前面例子中的关键字，下面的测试用例将通过。 1234567*** Variables ***$&#123;DATE&#125; 2011-06-27*** Test Cases ***Example Deadline is $&#123;DATE&#125; $&#123;1&#125; + $&#123;2&#125; = $&#123;3&#125; 使用变量的一个限制是，它们的实际值不会与自定义正则表达式进行匹配。结果是，关键字可能会被调用，其值可能不允许其自定义正则表达式。从Robot Framework 6.0开始，这种行为已被弃用，未来将对值进行验证。有关更多信息，请参阅问题#4462。 行为驱动开发示例将参数作为关键字名称的一部分的一个大的好处是，当使用行为驱动风格编写测试时，它使得使用更高级别的类似句子的关键字更容易。如下面的例子所示，这种支持通常与在关键字定义中省略Given、When和Then前缀的可能性结合使用： 123456789101112131415161718192021222324*** Test Cases ***Add two numbers Given I have Calculator open When I add 2 and 40 Then result should be 42Add negative numbers Given I have Calculator open When I add 1 and -2 Then result should be -1*** Keywords ***I have $&#123;program&#125; open Start Program $&#123;program&#125;I add $&#123;number 1&#125; and $&#123;number 2&#125; Input Number $&#123;number 1&#125; Push Button + Input Number $&#123;number 2&#125; Push Button =Result should be $&#123;expected&#125; $&#123;result&#125; = Get Result Should Be Equal $&#123;result&#125; $&#123;expected&#125; 注意 Robot Framework中的嵌入参数特性受到了流行的BDD工具Cucumber中创建步骤定义的启发。 用户关键字返回值与库关键字一样，用户关键字也可以返回值。当使用Robot Framework 5.0或更高版本时，推荐的方法是使用原生的RETURN语句。旧的[Return]设置在Robot Framework 7.0中被弃用，同时BuiltIn关键字Return From Keyword和Return From Keyword If也被认为是弃用的。 无论如何返回值，它们都可以在测试用例和其他用户关键字中分配给变量。 使用RETURN语句返回值的推荐方法是使用RETURN语句。它接受可选的返回值，并可以与IF和内联IF结构一起使用。它的用法最容易通过例子来解释： 123456789101112131415161718192021222324252627282930*** Keywords ***Return One Value [Arguments] $&#123;arg&#125; [Documentation] Return a value unconditionally. ... Notice that keywords after RETURN are not executed. $&#123;value&#125; = Convert To Upper Case $&#123;arg&#125; RETURN $&#123;value&#125; Fail Not executedReturn Three Values [Documentation] Return multiple values. RETURN a b cConditional Return [Arguments] $&#123;arg&#125; [Documentation] Return conditionally. Log Before IF $&#123;arg&#125; == 1 Log Returning! RETURN END Log AfterFind Index [Arguments] $&#123;test&#125; $&#123;items&#125; [Documentation] Advanced example involving FOR loop, inline IF and @&#123;list&#125; variable syntax. FOR $&#123;index&#125; $&#123;item&#125; IN ENUMERATE @&#123;items&#125; IF $item == $test RETURN $&#123;index&#125; END RETURN $&#123;-1&#125; 如果想自己测试上面的例子，可以使用这些测试用例： 12345678910111213141516171819202122*** Settings ***Library String*** Test Cases ***One return value $&#123;ret&#125; = Return One Value argument Should Be Equal $&#123;ret&#125; ARGUMENTMultiple return values $&#123;a&#125; $&#123;b&#125; $&#123;c&#125; = Return Three Values Should Be Equal $&#123;a&#125;, $&#123;b&#125;, $&#123;c&#125; a, b, cConditional return Conditional Return 1 Conditional Return 2Advanced @&#123;list&#125; = Create List foo bar baz $&#123;index&#125; = Find Index bar $&#123;list&#125; Should Be Equal $&#123;index&#125; $&#123;1&#125; $&#123;index&#125; = Find Index non existing $&#123;list&#125; Should Be Equal $&#123;index&#125; $&#123;-1&#125; 注意 RETURN语法是区分大小写的，就像IF和FOR一样。 注意 RETURN是Robot Framework 5.0中的新特性。如果需要支持旧版本，请使用下面解释的方法。 使用[Return]设置[Return]设置定义了关键字在执行后应返回什么。虽然推荐将它放在关键字的末尾，这在逻辑上是合理的，但它的位置并不影响它的使用方式。 [Return]设置的一个固有限制是它不能被条件性地使用。因此，只有前两个RETURN语句的例子可以使用它来创建。 12345678*** Keywords ***Return One Value [Arguments] $&#123;arg&#125; $&#123;value&#125; = Convert To Upper Case $&#123;arg&#125; [Return] $&#123;value&#125;Return Three Values [Return] a b c 注意 在Robot Framework 7.0中，[Return]设置被弃用，应该使用RETURN语句。如果需要支持不支持RETURN的旧版本的Robot Framework，可以使用下一节讨论的特殊关键字。 使用特殊关键字返回BuiltIn关键字Return From Keyword和Return From Keyword If允许在关键字的中间条件性地从用户关键字返回。它们两者也接受可选的返回值，这些返回值的处理方式与上面讨论的RETURN语句和[Return]设置完全相同。 引入RETURN语句使这些关键字变得多余。下面的例子包含了与早期RETURN例子相同的关键字，但这些关键字更冗长： 12345678910111213141516171819202122232425*** Keywords ***Return One Value [Arguments] $&#123;arg&#125; $&#123;value&#125; = Convert To Upper Case $&#123;arg&#125; Return From Keyword $&#123;value&#125; Fail Not executedReturn Three Values Return From Keyword a b cConditional Return [Arguments] $&#123;arg&#125; Log Before IF $&#123;arg&#125; == 1 Log Returning! Return From Keyword END Log AfterFind Index [Arguments] $&#123;test&#125; $&#123;items&#125; FOR $&#123;index&#125; $&#123;item&#125; IN ENUMERATE @&#123;items&#125; Return From Keyword If $item == $test $&#123;index&#125; END Return From Keyword $&#123;-1&#125; 注意 这些关键字实际上已经被弃用，除非需要支持Robot Framework 5.0之前的版本，否则应该使用RETURN语句。使用这些关键字时还没有可见的弃用警告，但它们将在未来被大声地弃用，并最终被移除。 用户关键字设置和拆卸用户关键字可以有一个设置和一个拆卸，就像测试一样。它们分别使用[Setup]和[Teardown]设置直接指定给拥有它们的关键字。与测试不同，无法为某个文件中的所有关键字指定一个公共的设置或拆卸。 设置和拆卸总是一个单独的关键字，但它们自己可以是执行多个关键字的用户关键字。可以将它们指定为变量，使用特殊的NONE值（不区分大小写）与根本没有设置或拆卸是一样的。 用户关键字设置与创建的用户关键字中的第一个关键字没有太大的不同。唯一的功能性差异是，设置可以被指定为一个变量，但能够明确地标记一个关键字为设置也可能是有用的。 用户关键字的拆卸，就像测试的拆卸一样，即使用户关键字失败也会被执行。因此，当需要在关键字结束时做一些事情，无论其状态如何，它们都非常有用。为了确保所有的清理活动都被完成，与测试拆卸一样，用户关键字拆卸默认启用了失败后继续模式。 12345678910*** Keywords ***Setup and teardown [Setup] Log New in RF 7! Do Something [Teardown] Log Old feature.Using variables [Setup] $&#123;SETUP&#125; Do Something [Teardown] $&#123;TEARDOWN&#125; 注意 用户关键字设置是Robot Framework 7.0中的新特性。 私有用户关键字用户关键字可以被标记为一个特殊的robot:private标签，以表示它们只应该在创建它们的文件中使用： 1234567*** Keywords ***Public Keyword Private KeywordPrivate Keyword [Tags] robot:private No Operation 使用robot:private标签并不直接阻止在创建它的文件之外使用关键字，但这样的用法会引发警告。如果有一个公共的和一个私有的具有相同名称的关键字，将使用公共的，但这种情况也会引发警告。 私有关键字包含在Libdoc创建的规格文件中，但不包含在其HTML输出文件中。 注意 私有用户关键字是Robot Framework 6.0中的新特性。 资源和变量文件套件文件和套件初始化文件中的用户关键字和变量只能在创建它们的文件中使用，但资源文件提供了共享它们的机制。创建资源文件的高级语法与创建套件文件完全相同，支持的文件格式也相同。主要的区别是资源文件不能有测试。 变量文件提供了一个强大的机制来创建和共享变量。例如，它们允许除字符串之外的值，并启用动态创建变量。它们的灵活性来自于它们是使用Python或YAML创建的，这也使它们比变量部分稍微复杂一些。 资源文件资源文件通常使用纯文本格式创建，但也支持reStructuredText格式和JSON格式。 使用资源文件资源文件是使用Settings部分的Resource设置导入的，以便将资源文件的路径作为设置的参数给出。资源文件的推荐扩展名是.resource。出于向后兼容性的原因，.robot、.txt和.tsv也可以工作，但在未来可能会强制使用.resource。 如果资源文件路径是绝对的，那么直接使用它。否则，首先相对于导入文件所在的目录搜索资源文件。如果在那里没有找到文件，那么就从Python的模块搜索路径中的目录中搜索。从模块搜索路径搜索资源文件使得可以将它们打包到Python包中作为包数据，并像package&#x2F;example.resource那样导入它们。 资源文件路径可以包含变量，建议使用它们来使路径系统无关（例如，{RESOURCES}&#x2F;login.resource或者只是RESOURCES&#x2F;login.resource或者只是{RESOURCE_PATH}）。此外，路径中的正斜杠（&#x2F;）在Windows上自动改为反斜杠（\\）。 12345*** Settings ***Resource example.resourceResource ../resources/login.resourceResource package/example.resourceResource $&#123;RESOURCES&#125;/common.resource 在资源文件中定义的用户关键字和变量在使用该资源文件的文件中可用。同样可用的还有该资源文件导入的所有库、资源文件和变量文件中的所有关键字和变量。 注意 .resource扩展名是Robot Framework 3.1中的新特性。 资源文件结构资源文件的高级结构与套件文件的结构相同，但它们不能包含测试或任务。此外，资源文件中的Setting部分只能包含导入（Library、Resource、Variables）、Documentation和Keyword Tags。Variable部分和Keyword部分的使用方式与套件文件完全相同。 如果几个资源文件有一个用户关键字具有相同的名称，它们必须被使用，以便关键字名称前缀为资源文件名称而不带扩展名（例如，myresources.Some Keyword和common.Some Keyword）。此外，如果几个资源文件包含相同的变量，首先导入的那个将被使用。 记录资源文件在资源文件中创建的关键字可以使用[Documentation]设置进行记录。资源文件本身可以在Setting部分有Documentation，就像套件一样。 Libdoc和各种编辑器使用这些文档，它们自然地对任何打开资源文件的人都可用。当运行关键字时，关键字的文档的第一个逻辑行，直到第一个空行，被记录下来，但在测试执行期间，资源文件文档被忽略。 示例资源文件123456789101112131415161718192021222324*** Settings ***Documentation An example resource fileLibrary SeleniumLibraryResource $&#123;RESOURCES&#125;/common.resource*** Variables ***$&#123;HOST&#125; localhost:7272$&#123;LOGIN URL&#125; http://$&#123;HOST&#125;/$&#123;WELCOME URL&#125; http://$&#123;HOST&#125;/welcome.html$&#123;BROWSER&#125; Firefox*** Keywords ***Open Login Page [Documentation] Opens browser to login page Open Browser $&#123;LOGIN URL&#125; $&#123;BROWSER&#125; Title Should Be Login PageInput Name [Arguments] $&#123;name&#125; Input Text username_field $&#123;name&#125;Input Password [Arguments] $&#123;password&#125; Input Text password_field $&#123;password&#125; 使用reStructured文本格式的资源文件可以使用套件文件的reStructuredText格式也适用于资源文件。这样的资源文件可以使用.rst或.rest扩展名，它们在其他方面与普通资源文件的导入方式完全相同： 12*** Settings ***Resource example.rst 当使用reStructuredText格式解析资源文件时，Robot Framework忽略所有包含Robot Framework数据的代码块之外的所有数据，就像解析reStructuredText套件文件一样。例如，下面的资源文件导入OperatingSystem库，定义${MESSAGE}变量并创建My Keyword关键字： 1234567891011121314151617181920212223Resource file using reStructuredText------------------------------------This text is outside code blocks and thus ignored... code:: robotframework *** Settings *** Library OperatingSystem *** Variables *** $&#123;MESSAGE&#125; Hello, world!Also this text is outside code blocks and ignored. Code blocks notcontaining Robot Framework data are ignored as well... code:: robotframework # Both space and pipe separated formats are supported. | *** Keywords *** | | | | My Keyword | [Arguments] | $&#123;path&#125; | | | Directory Should Exist | $&#123;path&#125; | 使用JSON格式的资源文件资源文件可以使用JSON创建，就像套件文件一样。这样的JSON资源文件必须使用标准的.json扩展名或自定义的.rsrc扩展名。它们在其他方面与普通资源文件的导入方式完全相同： 12*** Settings ***Resource example.rsrc 资源文件可以使用ResourceFile.to_json转换为JSON，并使用ResourceFile.from_json重新创建： 12345678910from robot.running import ResourceFile# 基于文件系统上的数据创建资源文件。resource = ResourceFile.from_file_system(&#x27;example.resource&#x27;)# 将JSON数据保存到文件。resource.to_json(&#x27;example.rsrc&#x27;)# 从JSON数据重新创建资源。resource = ResourceFile.from_json(&#x27;example.rsrc&#x27;) 变量文件变量文件包含可以在测试数据中使用的变量。变量也可以使用Variable部分创建或从命令行设置，但变量文件允许动态创建它们，并且使创建除字符串之外的其他变量值变得容易。 变量文件通常作为模块实现，有两种不同的方法来创建变量： 从模块直接获取变量 变量被指定为模块属性。在简单的情况下，语法非常简单，不需要真正的编程。例如，MY_VAR = &#39;my value&#39;创建一个变量$&#123;MY_VAR&#125;，其值为指定的文本。这种方法的一个限制是它不允许使用参数。 从特殊函数获取变量 变量文件可以有一个特殊的get_variables（或getVariables）方法，该方法返回变量作为映射。因为该方法可以接受参数，所以这种方法非常灵活。 或者，变量文件可以被实现为类，框架将实例化这些类。在这种情况下，也可以将变量创建为属性，或者从get_variables方法动态获取它们。变量文件也可以创建为YAML和JSON。 使用变量文件设置部分所有的测试数据文件都可以使用设置部分的Variables设置导入变量文件。变量文件通常使用文件的路径进行导入，就像使用Resource设置导入资源文件一样。与资源文件相似，导入的变量文件的路径被认为是相对于导入文件所在的目录的，如果没有找到，它会从模块搜索路径中的目录中搜索。路径也可以包含变量，斜杠在Windows上被转换为反斜杠。 示例： 1234*** Settings ***Variables myvariables.pyVariables ../data/variables.pyVariables $&#123;RESOURCES&#125;/common.yaml 从Robot Framework 5.0开始，使用Python实现的变量文件也可以使用模块名称导入，就像库一样。使用这种方法时，模块需要在模块搜索路径中。 示例： 123*** Settings ***Variables myvariablesVariables rootmodule.Variables 如果一个变量文件接受参数，它们被指定为导入的变量文件的路径或名称之后： 123*** Settings ***Variables arguments.py arg1 $&#123;ARG2&#125;Variables arguments argument 一个变量文件中的所有变量都在导入它的测试数据文件中可用。如果导入了几个变量文件，它们包含一个具有相同名称的变量，最早导入的文件中的那个将被使用。此外，在Variable部分创建的变量和从命令行设置的变量覆盖变量文件中的变量。 命令行使用变量文件的另一种方式是使用命令行选项--variablefile。变量文件是使用路径或模块名称引用的，就像使用Variables设置导入它们一样。可能的参数用冒号（:）连接到路径： 123456--variablefile myvariables.py--variablefile path/variables.py--variablefile /absolute/path/common.py--variablefile variablemodule--variablefile arguments.py:arg1:arg2--variablefile rootmodule.Variables:arg1:arg2 从命令行使用的变量文件也会从模块搜索路径中搜索，就像在Setting部分导入的变量文件一样。相对路径被认为是相对于开始执行的目录的。 如果一个变量文件被给定为一个绝对的Windows路径，那么驱动器字母后的冒号不被认为是一个分隔符： 1--variablefile C:\\path\\variables.py 也可以使用分号（;）作为参数分隔符。这在变量文件参数本身包含冒号的情况下很有用，但在UNIX-like操作系统上需要用引号包围整个值： 12--variablefile C:\\path\\variables.py;D:\\data.xls--variablefile &quot;myvariables.py;argument:with:colons&quot; 在命令行中使用的变量文件中的变量在所有测试数据文件中都全局可用，就像使用--variable选项设置的单个变量一样。如果使用了--variablefile和--variable选项，并且有相同名称的变量，那么使用--variable选项单独设置的那些将优先。 从模块直接获取变量基本语法当变量文件被使用时，它们被导入为Python模块，所有不以下划线（_）开头的模块级别属性默认被认为是变量。因为变量名是不区分大小写的，所以既可以使用小写也可以使用大写名称，但一般来说，推荐使用大写字母表示全局变量和属性。 123456VARIABLE = &quot;An example string&quot;ANOTHER_VARIABLE = &quot;This is pretty easy!&quot;INTEGER = 42STRINGS = [&quot;one&quot;, &quot;two&quot;, &quot;kolme&quot;, &quot;four&quot;]NUMBERS = [1, INTEGER, 3.14]MAPPING = &#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3&#125; 在上面的例子中，创建了变量$&#123;VARIABLE&#125;、$&#123;ANOTHER VARIABLE&#125;等。前两个变量是字符串，第三个是整数，然后是两个列表，最后的值是一个字典。所有这些变量都可以作为标量变量使用，列表和字典也可以作为列表变量，如@&#123;STRINGS&#125;（在字典的情况下，该变量只包含键），字典也可以作为字典变量，如&amp;&#123;MAPPING&#125;。 为了使创建列表变量或字典变量更明确，可以在变量名前加上LIST__或DICT__前缀： 1234from collections import OrderedDictLIST__ANIMALS = [&quot;cat&quot;, &quot;dog&quot;]DICT__FINNISH = OrderedDict([(&quot;cat&quot;, &quot;kissa&quot;), (&quot;dog&quot;, &quot;koira&quot;)]) 这些前缀不会成为最终变量名的一部分，但它们会使Robot Framework验证值实际上是列表型或字典型。对于字典，实际存储的值也会转换为一个特殊的字典，这个字典也在Variable部分创建字典变量时使用。这些字典的值可以作为属性访问，如$&#123;FINNISH.cat&#125;。这些字典也是有序的，但保留源顺序也需要原始字典是有序的。 上面两个例子中的变量也可以使用下面的Variable部分创建。 123456789*** Variables ***$&#123;VARIABLE&#125; An example string$&#123;ANOTHER VARIABLE&#125; This is pretty easy!$&#123;INTEGER&#125; $&#123;42&#125;@&#123;STRINGS&#125; one two kolme four@&#123;NUMBERS&#125; $&#123;1&#125; $&#123;INTEGER&#125; $&#123;3.14&#125;&amp;&#123;MAPPING&#125; one=$&#123;1&#125; two=$&#123;2&#125; three=$&#123;3&#125;@&#123;ANIMALS&#125; cat dog&amp;&#123;FINNISH&#125; cat=kissa dog=koira 注意 从变量文件获取的字符串中不替换变量。例如，VAR = &quot;an ${example}&quot;将创建一个变量${VAR}，其值为字面字符串an ${example}，无论变量${example}是否存在。 使用对象作为值变量文件中的变量不限于只有字符串或其他基本类型作为值，如Variable部分。相反，它们的变量可以包含任何对象。在下面的例子中，变量$&#123;MAPPING&#125;包含一个Python字典，还有两个变量是从同一文件中实现的自定义对象创建的。 12345678MAPPING = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2&#125;class MyObject: def __init__(self, name): self.name = nameOBJ1 = MyObject(&#x27;John&#x27;)OBJ2 = MyObject(&#x27;Jane&#x27;) 动态创建变量因为变量文件是使用真正的编程语言创建的，所以它们可以有动态的逻辑来设置变量。 1234567891011import osimport randomimport timeUSER = os.getlogin() # 当前登录名RANDOM_INT = random.randint(0, 10) # 范围[0,10]内的随机整数CURRENT_TIME = time.asctime() # 时间戳，如 &#x27;Thu Apr 6 12:45:21 2006&#x27;if time.localtime()[3] &gt; 12: AFTERNOON = Trueelse: AFTERNOON = False 上面的例子使用标准的Python库来设置不同的变量，但可以使用自己的代码来构造值。下面的例子说明了这个概念，但同样地，代码可以从数据库、外部文件甚至从用户那里读取数据。 123456789import mathdef get_area(diameter): radius = diameter / 2 area = math.pi * radius * radius return areaAREA1 = get_area(1)AREA2 = get_area(2) 选择要包含的变量当Robot Framework处理变量文件时，所有不以下划线开始的属性都被认为是变量。这意味着，即使是在变量文件中创建的函数或类，或者从其他地方导入的，也被认为是变量。例如，最后一个例子中除了$&#123;AREA1&#125;和$&#123;AREA2&#125;之外，还包含了变量$&#123;math&#125;和$&#123;get_area&#125;。 通常，额外的变量不会引起问题，但它们可能会覆盖一些其他变量，导致难以调试的错误。忽略其他属性的一种可能性是在它们前面加上下划线： 123456789import math as _mathdef _get_area(diameter): radius = diameter / 2.0 area = _math.pi * radius * radius return areaAREA1 = _get_area(1)AREA2 = _get_area(2) 如果有大量的其他属性，而不是给它们所有的前缀，通常更容易使用一个特殊的属性__all__，并给它一个要作为变量处理的属性名列表。 1234567891011import math__all__ = [&#x27;AREA1&#x27;, &#x27;AREA2&#x27;]def get_area(diameter): radius = diameter / 2.0 area = math.pi * radius * radius return areaAREA1 = get_area(1)AREA2 = get_area(2) 注意 __all__属性也是，最初是由Python用来决定在使用from modulename import *语法时要导入哪些属性。 选择实际创建哪些变量的第三个选项是使用下面讨论的特殊get_variables函数。 从特殊函数获取变量获取变量的另一种方法是在变量文件中有一个特殊的get_variables函数（也可以使用驼峰式语法getVariables）。如果存在这样的函数，Robot Framework会调用它，并期望以Python字典的形式接收变量，其中变量名作为键，变量值作为值。创建的变量可以像直接从模块获取变量一样用作标量、列表和字典，也可以使用LIST__和DICT__前缀来使创建列表和字典变量更明确。下面的例子在功能上与直接从模块获取变量的第一个例子完全相同。 12345678def get_variables(): variables = &#123;&quot;VARIABLE &quot;: &quot;An example string&quot;, &quot;ANOTHER VARIABLE&quot;: &quot;This is pretty easy!&quot;, &quot;INTEGER&quot;: 42, &quot;STRINGS&quot;: [&quot;one&quot;, &quot;two&quot;, &quot;kolme&quot;, &quot;four&quot;], &quot;NUMBERS&quot;: [1, 42, 3.14], &quot;MAPPING&quot;: &#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3&#125;&#125; return variables get_variables也可以接受参数，这有助于改变实际创建的变量。函数的参数就像为Python函数设置的任何其他参数一样。当使用变量文件时，参数在变量文件的路径之后指定，在命令行中，它们与路径用冒号或分号分隔。 下面的虚拟例子展示了如何使用变量文件的参数。在一个更现实的例子中，参数可能是一个路径，指向一个要从中读取变量的外部文本文件或数据库。 1234567891011variables1 = &#123;&#x27;scalar&#x27;: &#x27;Scalar variable&#x27;, &#x27;LIST__list&#x27;: [&#x27;List&#x27;,&#x27;variable&#x27;]&#125;variables2 = &#123;&#x27;scalar&#x27; : &#x27;Some other value&#x27;, &#x27;LIST__list&#x27;: [&#x27;Some&#x27;,&#x27;other&#x27;,&#x27;value&#x27;], &#x27;extra&#x27;: &#x27;variables1 does not have this at all&#x27;&#125;def get_variables(arg): if arg == &#x27;one&#x27;: return variables1 else: return variables2 从Robot Framework 7.0开始，变量文件的参数支持自动参数转换以及命名参数语法。例如，一个带有get_variables(first: int = 0, second: str = &#39;&#39;)的变量文件可以这样导入： 123*** Settings ***Variables example.py 42 # 转换为整数。Variables example.py second=value # 命名参数语法。 将变量文件实现为类也可以将变量文件实现为类。 实现因为变量文件总是使用文件系统路径导入，所以类必须和它所在的模块有相同的名称。 框架将使用无参数创建类的实例，并从实例中获取变量。与模块一样，变量可以直接在实例中定义为属性，或者从特殊的get_variables方法中获取。 当变量直接在实例中定义时，所有包含可调用值的属性都被忽略，以避免从可能的方法中创建变量。如果实际上需要可调用的变量，需要使用其他方法来创建变量文件。 示例第一个示例从属性创建变量。它从类属性创建变量$&#123;VARIABLE&#125;和@&#123;LIST&#125;，从实例属性创建$&#123;ANOTHER VARIABLE&#125;。 1234567class StaticExample: variable = &#x27;value&#x27; LIST__list = [1, 2, 3] _not_variable = &#x27;starts with an underscore&#x27; def __init__(self): self.another_variable = &#x27;another value&#x27; 第二个示例利用动态方法获取变量。它只创建一个变量$&#123;DYNAMIC VARIABLE&#125;。 1234class DynamicExample: def get_variables(self, *args): return &#123;&#x27;dynamic variable&#x27;: &#x27; &#x27;.join(args)&#125; 变量文件作为YAML变量文件也可以实现为YAML文件。YAML是一种数据序列化语言，具有简单且对人类友好的语法，但对机器来说解析起来仍然很容易。下面的例子演示了一个简单的YAML文件： 123456789string: Hello, world!integer: 42list: - one - twodict: one: yksi two: kaksi with spaces: kolme YAML变量文件可以像普通的变量文件一样从命令行使用--variablefile选项、在Settings部分使用Variables设置，以及动态地使用Import Variables关键字。它们会被自动识别为其扩展名，必须是.yaml或.yml。如果导入了上面的YAML文件，它将创建与此Variable部分完全相同的变量： 12345*** Variables ***$&#123;STRING&#125; Hello, world!$&#123;INTEGER&#125; $&#123;42&#125;@&#123;LIST&#125; one two&amp;&#123;DICT&#125; one=yksi two=kaksi with spaces=kolme 用作变量文件的YAML文件必须始终在顶层是映射。如上例所示，映射中的键和值分别成为变量名和值。变量值可以是YAML语法支持的任何数据类型。如果名称或值包含非ASCII字符，YAML变量文件必须是UTF-8编码的。 用作值的映射会自动转换为特殊的字典，这些字典也在Variable部分创建字典变量时使用。最重要的是，这些字典的值可以作为属性访问，如$&#123;DICT.one&#125;，假设它们的名称作为Python属性名称是有效的。如果名称包含空格或者其他不是有效属性名称的字符，总是可以使用像$&#123;DICT&#125;[with spaces]这样的语法访问字典值。 注意 使用Robot Framework的YAML文件需要安装PyYAML模块。通常可以使用pip安装它，像这样：pip install pyyaml。 变量文件作为JSON变量文件也可以实现为JSON文件。与上一节讨论的YAML一样，JSON是一种针对人类和机器的数据序列化格式。它基于JavaScript语法，虽然不如YAML对人类友好，但仍然相对容易理解和修改。下面的例子包含了与早期YAML例子完全相同的数据： 12345678910111213&#123; &quot;string&quot;: &quot;Hello, world!&quot;, &quot;integer&quot;: 42, &quot;list&quot;: [ &quot;one&quot;, &quot;two&quot; ], &quot;dict&quot;: &#123; &quot;one&quot;: &quot;yksi&quot;, &quot;two&quot;: &quot;kaksi&quot;, &quot;with spaces&quot;: &quot;kolme&quot; &#125;&#125; JSON变量文件会被自动识别为它们的.json扩展名，它们可以像YAML变量文件一样使用。它们对结构、编码等的要求也完全相同。与YAML不同，Python支持JSON，所以不需要安装额外的模块。 注意 对JSON变量文件的支持是Robot Framework 6.1中的新特性。 控制结构本节描述了可以用来控制测试执行流程的各种结构。这些结构在大多数编程语言中都很常见，它们允许条件执行，重复执行一组关键字和进行精细的错误处理。出于可读性的原因，应谨慎使用这些结构，并且更复杂的用例最好在测试库中实现。 FOR循环在测试自动化中，重复执行相同的操作是很常见的需求。在Robot Framework中，测试库可以有任何类型的循环结构，大多数时候应该在它们中实现循环。Robot Framework也有自己的FOR循环语法，这在需要重复执行来自不同库的关键字时非常有用。 FOR循环可以用于测试用例和用户关键字。除了非常简单的情况外，用户关键字更好，因为它们隐藏了FOR循环引入的复杂性。基本的FOR循环语法，FOR item IN sequence，源自Python，但其他各种编程语言也支持类似的语法。 简单的FOR循环在普通的FOR循环中，一个变量根据一组值被赋值，每次迭代一个值。语法以FOR（区分大小写）作为标记开始，然后是循环变量，然后是一个必须的IN（区分大小写）作为分隔符，最后是要迭代的值。这些值可以包含变量，包括列表变量。 在FOR循环中使用的关键字在以下的行中，循环以END（区分大小写）在其自己的行中结束。循环内的关键字不需要缩进，但强烈建议缩进，以使语法更易于阅读。 12345678910111213*** Test Cases ***Example FOR $&#123;animal&#125; IN cat dog Log $&#123;animal&#125; Log 2nd keyword END Log Outside loopSecond Example FOR $&#123;var&#125; IN one two $&#123;3&#125; four $&#123;five&#125; ... kuusi 7 eight nine $&#123;last&#125; Log $&#123;var&#125; END 上面的Example中的FOR循环执行了两次，所以首先循环变量$&#123;animal&#125;的值是cat，然后是dog。循环由两个Log关键字组成。在第二个例子中，循环值被分成两行，循环总共运行了十次。 使用列表变量的FOR循环通常很方便。下面的例子说明了这一点，其中@&#123;ELEMENTS&#125;包含了一个任意长的元素列表，关键字Start Element被用于逐一使用所有的元素。 12345*** Test Cases ***Example FOR $&#123;element&#125; IN @&#123;ELEMENTS&#125; Start Element $&#123;element&#125; END 旧的FOR循环语法在Robot Framework 3.1之前，FOR循环的语法与现在不同。开始循环的标记是:FOR而不是FOR，循环内容需要用反斜杠明确标记，而不是使用END标记来结束循环。上面的第一个例子使用旧语法会是这样的： 123456*** Test Cases ***Example :FOR $&#123;animal&#125; IN cat dog \\ Log $&#123;animal&#125; \\ Log 2nd keyword Log Outside loop 旧语法在Robot Framework 3.2中被弃用，并在Robot Framework 4.0中完全移除。 嵌套FOR循环从Robot Framework 4.0开始，可以通过在另一个循环内添加循环来简单地使用嵌套FOR循环： 12345678*** Keywords ***Handle Table [Arguments] @&#123;table&#125; FOR $&#123;row&#125; IN @&#123;table&#125; FOR $&#123;cell&#125; IN @&#123;row&#125; Handle Cell $&#123;cell&#125; END END 可以有多个嵌套级别，循环也可以与其他控制结构组合： 1234567891011121314*** Test Cases ***Multiple nesting levels FOR $&#123;root&#125; IN r1 r2 FOR $&#123;child&#125; IN c1 c2 c3 FOR $&#123;grandchild&#125; IN g1 g2 Log Many $&#123;root&#125; $&#123;child&#125; $&#123;grandchild&#125; END END FOR $&#123;sibling&#125; IN s1 s2 s3 IF &#x27;$&#123;sibling&#125;&#x27; != &#x27;s2&#x27; Log Many $&#123;root&#125; $&#123;sibling&#125; END END END 使用多个循环变量通过在FOR和IN标记之间使用多个循环变量，可以在一次迭代中遍历多个值。可以有任意数量的循环变量，但值的数量必须能被变量的数量整除。每次迭代消耗的值的数量与变量的数量相同。 如果有很多值需要迭代，通常方便的做法是将它们组织在循环变量下面，如下面的例子中的第一个循环： 1234567891011*** Test Cases ***Multiple loop variables FOR $&#123;index&#125; $&#123;english&#125; $&#123;finnish&#125; IN ... 1 cat kissa ... 2 dog koira ... 3 horse hevonen Add Translation $&#123;english&#125; $&#123;finnish&#125; $&#123;index&#125; END FOR $&#123;name&#125; $&#123;id&#125; IN @&#123;EMPLOYERS&#125; Create $&#123;name&#125; $&#123;id&#125; END FOR-IN-RANGE循环前一节中的所有FOR循环都是遍历一个序列。这是最常见的用例，但有时候需要一个循环执行特定次数。为此，Robot Framework有一个特殊的FOR index IN RANGE limit循环语法，它源自Python中使用内置的range()函数的类似习语。 与其他FOR循环一样，FOR-IN-RANGE循环以FOR开始，后面跟着一个循环变量。在这种格式中，只能有一个循环变量，它包含当前的循环索引。在变量之后，必须有IN RANGE标记（区分大小写），后面跟着循环限制。 在最简单的情况下，只指定了循环的上限。在这种情况下，循环索引从零开始，增加一直到，但不包括，限制。也可以给出开始和结束限制。然后索引从开始限制开始，但增加类似于简单情况。最后，也可以给出步长值，指定要使用的增量。如果步长是负的，它被用作递减。 可以使用简单的算术，如加法和减法，与范围限制一起使用。当限制用变量指定时，这特别有用。开始、结束和步长通常给出为整数，但也可以使用浮点值。 123456789101112131415161718192021222324252627282930313233343536*** Test Cases ***Only upper limit [Documentation] Loops over values from 0 to 9. FOR $&#123;index&#125; IN RANGE 10 Log $&#123;index&#125; ENDStart and end [Documentation] Loops over values from 1 to 10. FOR $&#123;index&#125; IN RANGE 1 11 Log $&#123;index&#125; ENDAlso step given [Documentation] Loops over values 5, 15, and 25. FOR $&#123;index&#125; IN RANGE 5 26 10 Log $&#123;index&#125; ENDNegative step [Documentation] Loops over values 13, 3, and -7. FOR $&#123;index&#125; IN RANGE 13 -13 -10 Log $&#123;index&#125; ENDArithmetic [Documentation] Arithmetic with variable. FOR $&#123;index&#125; IN RANGE $&#123;var&#125; + 1 Log $&#123;index&#125; ENDFloat parameters [Documentation] Loops over values 3.14, 4.34, and 5.54. FOR $&#123;index&#125; IN RANGE 3.14 6.09 1.2 Log $&#123;index&#125; END FOR-IN-ENUMERATE循环有时候，遍历列表并跟踪在列表中的位置是很有用的。Robot Framework有一个特殊的FOR index … IN ENUMERATE …语法来处理这种情况。这种语法源自Python内置的enumerate()函数。 FOR-IN-ENUMERATE循环的语法就像常规的FOR循环语法一样，只是变量和值之间的分隔符是IN ENUMERATE（区分大小写）。通常，它们被用来在任何其他循环变量之前有一个额外的索引变量。默认情况下，索引在第一次迭代时的值为0，第二次迭代时的值为1，依此类推。 例如，下面的两个测试用例做了同样的事情： 123456789101112131415*** Variables ***@&#123;LIST&#125; a b c*** Test Cases ***Manage index manually $&#123;index&#125; = Set Variable -1 FOR $&#123;item&#125; IN @&#123;LIST&#125; $&#123;index&#125; = Evaluate $&#123;index&#125; + 1 My Keyword $&#123;index&#125; $&#123;item&#125; ENDFOR-IN-ENUMERATE FOR $&#123;index&#125; $&#123;item&#125; IN ENUMERATE @&#123;LIST&#125; My Keyword $&#123;index&#125; $&#123;item&#125; END 从Robot Framework 4.0开始，可以通过在FOR … IN ENUMERATE …头部的最后一项使用start&#x3D;语法来指定自定义的开始索引： 1234567891011121314*** Variables ***@&#123;LIST&#125; a b c$&#123;START&#125; 10*** Test Cases ***FOR-IN-ENUMERATE with start FOR $&#123;index&#125; $&#123;item&#125; IN ENUMERATE @&#123;LIST&#125; start=1 My Keyword $&#123;index&#125; $&#123;item&#125; ENDStart as variable FOR $&#123;index&#125; $&#123;item&#125; IN ENUMERATE @&#123;LIST&#125; start=$&#123;start&#125; My Keyword $&#123;index&#125; $&#123;item&#125; END start&#x3D;语法必须在FOR头部明确使用，它不能自身来自变量。如果要枚举的最后一个实际项以start&#x3D;开始，需要像start&#x3D;这样进行转义。 就像常规的FOR循环一样，只要列表中的值的数量能被循环变量的数量（不包括索引变量）整除，就可以在每次循环迭代中遍历多个值： 12345678*** Test Cases ***FOR-IN-ENUMERATE with two values per iteration FOR $&#123;index&#125; $&#123;en&#125; $&#123;fi&#125; IN ENUMERATE ... cat kissa ... dog koira ... horse hevonen Log &quot;$&#123;en&#125;&quot; in English is &quot;$&#123;fi&#125;&quot; in Finnish (index: $&#123;index&#125;) END 如果只使用一个循环变量与FOR-IN-ENUMERATE循环，那个变量将成为一个包含索引和迭代值的Python元组： 123456*** Test Cases ***FOR-IN-ENUMERATE with one loop variable FOR $&#123;x&#125; IN ENUMERATE @&#123;LIST&#125; Length Should Be $&#123;x&#125; 2 Log Index is $&#123;x&#125;[0] and item is $&#123;x&#125;[1]. END 注意 只使用一个循环变量的FOR-IN-ENUMERATE循环是Robot Framework 3.2中的新特性。 FOR-IN-ZIP循环有些测试会构建几个相关的列表，然后一起遍历它们。Robot Framework为这种情况提供了一个快捷方式：FOR … IN ZIP …，这是从Python内置的zip()函数派生出来的。 这可能最容易通过一个例子来展示： 123456789101112131415*** Variables ***@&#123;NUMBERS&#125; $&#123;1&#125; $&#123;2&#125; $&#123;5&#125;@&#123;NAMES&#125; one two five*** Test Cases ***Iterate over two lists manually $&#123;length&#125;= Get Length $&#123;NUMBERS&#125; FOR $&#123;index&#125; IN RANGE $&#123;length&#125; Log Many $&#123;NUMBERS&#125;[$&#123;index&#125;] $&#123;NAMES&#125;[$&#123;index&#125;] ENDFOR-IN-ZIP FOR $&#123;number&#125; $&#123;name&#125; IN ZIP $&#123;NUMBERS&#125; $&#123;NAMES&#125; Log Many $&#123;number&#125; $&#123;name&#125; END 如上面的例子所示，FOR-IN-ZIP循环需要在循环变量和值之间有自己的自定义分隔符IN ZIP（区分大小写）。与FOR-IN-ZIP循环一起使用的值必须是列表或类似列表的对象。 要迭代的项目必须始终以标量变量（如${items}）或列表变量（如@{lists}）的形式给出，这些变量产生实际的迭代列表。前一种方法更常见，已经在上面演示过。后一种方法的工作方式如下： 12345678910*** Variables ***@&#123;NUMBERS&#125; $&#123;1&#125; $&#123;2&#125; $&#123;5&#125;@&#123;NAMES&#125; one two five@&#123;LISTS&#125; $&#123;NUMBERS&#125; $&#123;NAMES&#125;*** Test Cases ***FOR-IN-ZIP with lists from variable FOR $&#123;number&#125; $&#123;name&#125; IN ZIP @&#123;LISTS&#125; Log Many $&#123;number&#125; $&#123;name&#125; END 要迭代的列表的数量不受限制，但必须与循环变量的数量匹配。或者，可以只有一个循环变量，然后它变成一个Python元组，获取所有列表的项目。 12345678910111213141516*** Variables ***@&#123;ABC&#125; a b c@&#123;XYZ&#125; x y z@&#123;NUM&#125; 1 2 3*** Test Cases ***FOR-IN-ZIP with multiple lists FOR $&#123;a&#125; $&#123;x&#125; $&#123;n&#125; IN ZIP $&#123;ABC&#125; $&#123;XYZ&#125; $&#123;NUM&#125; Log Many $&#123;a&#125; $&#123;x&#125; $&#123;n&#125; ENDFOR-IN-ZIP with one variable FOR $&#123;items&#125; IN ZIP $&#123;ABC&#125; $&#123;XYZ&#125; $&#123;NUM&#125; Length Should Be $&#123;items&#125; 3 Log Many $&#123;items&#125;[0] $&#123;items&#125;[1] $&#123;items&#125;[2] END 从Robot Framework 6.1开始，可以配置如果迭代的项目的长度不同应该怎么做。默认情况下，最短的项目定义了有多少次迭代，较长的项目的末尾的值被忽略。这可以通过使用mode选项来改变，该选项有三个可能的值： STRICT：项目必须有相等的长度。如果没有，执行失败。这与使用Python的zip函数的strict&#x3D;True是一样的。 SHORTEST：较长的项目中的项目被忽略。只要其中一个项目被耗尽，就支持无限迭代器。这是默认行为。 LONGEST：最长的项目定义了有多少次迭代。较短的项目中缺失的值用fill选项指定的值填充，如果没有使用fill选项，则用None填充。这与使用Python的zip_longest函数是一样的，只是它有fillvalue参数而不是fill。 以下示例说明了所有这些模式： 123456789101112131415161718192021222324252627282930*** Variables ***@&#123;CHARACTERS&#125; a b c d f@&#123;NUMBERS&#125; 1 2 3*** Test Cases ***STRICT mode [Documentation] 由于列表长度不同，此循环失败。 FOR $&#123;c&#125; $&#123;n&#125; IN ZIP $&#123;CHARACTERS&#125; $&#123;NUMBERS&#125; mode=STRICT Log $&#123;c&#125;: $&#123;n&#125; ENDSHORTEST mode [Documentation] 此循环执行三次。 FOR $&#123;c&#125; $&#123;n&#125; IN ZIP $&#123;CHARACTERS&#125; $&#123;NUMBERS&#125; mode=SHORTEST Log $&#123;c&#125;: $&#123;n&#125; ENDLONGEST mode [Documentation] 此循环执行五次。 ... 在最后两轮中，`$&#123;n&#125;`的值为`None`。 FOR $&#123;c&#125; $&#123;n&#125; IN ZIP $&#123;CHARACTERS&#125; $&#123;NUMBERS&#125; mode=LONGEST Log $&#123;c&#125;: $&#123;n&#125; ENDLONGEST mode with custom fill value [Documentation] 此循环执行五次。 ... 在最后两轮中，`$&#123;n&#125;`的值为`0`。 FOR $&#123;c&#125; $&#123;n&#125; IN ZIP $&#123;CHARACTERS&#125; $&#123;NUMBERS&#125; mode=LONGEST fill=0 Log $&#123;c&#125;: $&#123;n&#125; END 注意 如果列表长度不同的行为将在未来改变，以便STRICT模式将成为默认。如果不希望这样，需要显式使用SHORTEST模式。 字典迭代普通的FOR循环和FOR-IN-ENUMERATE循环支持在字典中迭代键和值。这种语法要求至少有一个循环值是字典变量。可以使用多个字典变量，并以key&#x3D;value语法给出额外的项。项目按照它们定义的顺序进行迭代，如果同一个键获得多个值，将使用最后的值。 12345678910111213141516171819*** Variables ***&amp;&#123;DICT&#125; a=1 b=2 c=3*** Test Cases ***Dictionary iteration with FOR loop FOR $&#123;key&#125; $&#123;value&#125; IN &amp;&#123;DICT&#125; Log Key is &#x27;$&#123;key&#125;&#x27; and value is &#x27;$&#123;value&#125;&#x27;. ENDDictionary iteration with FOR-IN-ENUMERATE loop FOR $&#123;index&#125; $&#123;key&#125; $&#123;value&#125; IN ENUMERATE &amp;&#123;DICT&#125; Log On round $&#123;index&#125; key is &#x27;$&#123;key&#125;&#x27; and value is &#x27;$&#123;value&#125;&#x27;. ENDMultiple dictionaries and extra items in &#x27;key=value&#x27; syntax &amp;&#123;more&#125; = Create Dictionary e=5 f=6 FOR $&#123;key&#125; $&#123;value&#125; IN &amp;&#123;DICT&#125; d=4 &amp;&#123;more&#125; g=7 Log Key is &#x27;$&#123;key&#125;&#x27; and value is &#x27;$&#123;value&#125;&#x27;. END 通常，最容易使用字典迭代语法，使键和值获得单独的变量，就像上面的例子那样。对于普通的FOR循环，也可以只使用一个变量，该变量将成为一个包含键和值的元组。如果只使用一个变量与FOR-IN-ENUMERATE循环，它将成为一个包含索引、键和值的元组。FOR-IN-ENUMERATE循环中的两个变量意味着将索引赋给第一个变量，并使第二个变量成为一个包含键和值的元组。 123456789101112131415*** Test Cases ***One loop variable FOR $&#123;item&#125; IN &amp;&#123;DICT&#125; Log Key is &#x27;$&#123;item&#125;[0]&#x27; and value is &#x27;$&#123;item&#125;[1]&#x27;. ENDOne loop variable with FOR-IN-ENUMERATE FOR $&#123;item&#125; IN ENUMERATE &amp;&#123;DICT&#125; Log On round $&#123;item&#125;[0] key is &#x27;$&#123;item&#125;[1]&#x27; and value is &#x27;$&#123;item&#125;[2]&#x27;. ENDTwo loop variables with FOR-IN-ENUMERATE FOR $&#123;index&#125; $&#123;item&#125; IN ENUMERATE &amp;&#123;DICT&#125; Log On round $&#123;index&#125; key is &#x27;$&#123;item&#125;[0]&#x27; and value is &#x27;$&#123;item&#125;[1]&#x27;. END 除了在字典中迭代名称和值，还可以迭代键，然后可能根据键获取值。这种语法需要将字典作为列表变量使用： 12345*** Test Cases ***Iterate over keys FOR $&#123;key&#125; IN @&#123;DICT&#125; Log Key is &#x27;$&#123;key&#125;&#x27; and value is &#x27;$&#123;DICT&#125;[$&#123;key&#125;]&#x27;. END 注意 在字典中迭代键和值是Robot Framework 3.2中的新特性。在早期版本中，可以像上面的最后一个例子那样迭代字典键。 移除不必要的关键字输出具有多次迭代的FOR循环通常会产生大量的输出，并显著增加生成的输出和日志文件的大小。可以使用–removekeywords和–flattenkeywords命令行选项移除或扁平化不必要的关键字。 重复单个关键字在只需要重复一个关键字的情况下，FOR循环可能过于复杂。在这些情况下，通常更容易使用BuiltIn关键字Repeat Keyword。这个关键字接受一个关键字和重复它的次数作为参数。重复关键字的次数可以有一个可选的后缀times或x，使语法更易读。 12345*** Test Cases ***Example Repeat Keyword 5 Some Keyword arg1 arg2 Repeat Keyword 42 times My Keyword Repeat Keyword $&#123;var&#125; Another Keyword argument WHILE循环WHILE循环结合了FOR循环和IF&#x2F;ELSE结构的特性。它们指定一个条件，并在条件保持为真的情况下重复循环体。例如，可以利用这一点来重复一个非确定性序列，直到发生期望的结果，或者在某些情况下，它们可以用作FOR循环的替代品。 注意 WHILE循环是Robot Framework 5.0中的新特性。 基本的WHILE语法123456*** Test Cases ***Example VAR $&#123;rc&#125; 1 WHILE $&#123;rc&#125; != 0 $&#123;rc&#125; = Keyword that returns zero on success END WHILE循环的条件在Python中进行评估，因此可以使用Python内置的如len()等函数，并自动导入模块以支持像math.pi * math.pow({radius}, 2) &lt; 10这样的用法。像上面的例子中的radius,2)&lt;10这样的用法。像上面的例子中的{rc}这样的普通变量在评估之前被替换，但变量也可以在评估命名空间中使用特殊的$rc语法。后一种方法在变量的字符串表示不能直接用于条件时很方便。例如，字符串需要引号，多行字符串和包含引号的字符串本身会引起额外的问题。有关评估语法的更多信息和示例，请参见评估表达式附录。 从Robot Framework 6.1开始，WHILE语句中的条件可以省略。这被解释为条件始终为真，这在使用下面描述的limit选项时可能有用。 限制WHILE循环的迭代次数对于WHILE循环，总是有可能实现一个无限循环，无论是有意的还是无意的。这发生在循环条件永远不变为假的情况下。虽然在应用程序编程中无限循环有一些用途，但在自动化中，无限循环很少是期望的结果。如果在Robot Framework中发生这样的循环，必须强制停止执行，并且不能创建日志或报告。因此，Robot Framework中的WHILE循环默认有10 000次迭代的限制。如果超过了限制，循环就会失败。 可以使用limit配置参数设置限制，要么作为最大迭代次数，要么作为整个循环的最大时间。当限制是迭代次数时，可以只使用像100这样的整数，并在值后面添加times或x后缀，如100 times。当限制是超时时，可以使用像10 s或1 hour 10 minutes这样的时间字符串。也可以通过使用NONE（不区分大小写）来完全禁用限制。下面的示例说明了所有这些选项。 123456789101112131415161718192021*** Test Cases ***Limit as iteration count WHILE True limit=100 Log This is run 100 times. END WHILE True limit=10 times Log This is run 10 times. END WHILE True limit=42x Log This is run 42 times. ENDLimit as time WHILE True limit=10 seconds Log This is run 10 seconds. ENDNo limit WHILE True limit=NONE Log This runs forever. END 注意 在Robot Framework 7.0中，使用times和x后缀与迭代次数是新特性。 如果超过了限制，循环中的关键字不会被强制停止。相反，循环将以类似于循环条件变为假的方式退出。主要的区别是，在这种情况下，循环的状态将是FAIL。 从Robot Framework 6.1开始，可以使用on_limit参数来配置超过限制时的行为。它支持两个值pass和fail，不区分大小写。如果值是pass，当达到限制时，执行将正常继续，WHILE循环的状态将是PASS。fail的值与默认行为类似，例如，如果超过了限制，循环和测试将失败。 12345678910111213*** Test Cases ***Continue when iteration limit is reached WHILE True limit=5 on_limit=pass Log Loop will be executed five times END Log This will be executed normally.Continue when time limit is reached WHILE True limit=10s on_limit=pass Log Loop will be executed for 10 seconds. Sleep 0.5s END Log This will be executed normally. 默认情况下，当达到限制时，会引发错误消息WHILE loop was aborted because it did not finish within the limit of 0.5 seconds. Use the ‘limit’ argument to increase or remove the limit if needed.。从Robot Framework 6.1开始，可以使用on_limit_message配置参数更改错误消息。 12345*** Test Cases ***Limit as iteration count WHILE True limit=0.5s on_limit_message=Custom While loop error message Log This is run 0.5 seconds. END 注意 on_limit_message配置参数是Robot Framework 6.1中的新特性。 嵌套WHILE循环WHILE循环可以嵌套，并且可以与其他控制结构组合： 1234567891011121314*** Test Cases ***Nesting WHILE $&#123;x&#125; = Set Variable 10 WHILE $&#123;x&#125; &gt; 0 $&#123;y&#125; = Set Variable $&#123;x&#125; WHILE $&#123;y&#125; &gt; 0 $&#123;y&#125; = Evaluate $&#123;y&#125; - 1 END IF $&#123;x&#125; &gt; 5 $&#123;x&#125; = Evaluate $&#123;x&#125; - 1 ELSE $&#123;x&#125; = Evaluate $&#123;x&#125; - 2 END END 移除不必要的关键字输出具有多次迭代的WHILE循环通常会产生大量的输出，并显著增加生成的输出和日志文件的大小。可以使用–removekeywords和–flattenkeywords命令行选项移除或扁平化不必要的关键字。 使用BREAK和CONTINUE控制循环FOR循环和WHILE循环的执行都可以用BREAK和CONTINUE语句来控制。前者提前退出整个循环，后者停止执行当前的循环迭代并继续下一个。在实践中，它们与Python、Java和许多其他编程语言中的break和continue语句具有相同的语义。 BREAK和CONTINUE通常在IF&#x2F;ELSE或TRY&#x2F;EXCEPT结构中有条件地使用，特别是与它们一起使用的内联IF语法通常很方便。这些语句必须在循环体中使用，可能在上述控制结构内部，并且在循环体中调用的关键字中使用它们是无效的。 123456789101112131415161718192021222324252627282930313233343536373839*** Test Cases ***BREAK with FOR $&#123;text&#125; = Set Variable zero FOR $&#123;var&#125; IN one two three IF &#x27;$&#123;var&#125;&#x27; == &#x27;two&#x27; BREAK $&#123;text&#125; = Set Variable $&#123;text&#125;-$&#123;var&#125; END Should Be Equal $&#123;text&#125; zero-oneCONTINUE with FOR $&#123;text&#125; = Set Variable zero FOR $&#123;var&#125; IN one two three IF &#x27;$&#123;var&#125;&#x27; == &#x27;two&#x27; CONTINUE $&#123;text&#125; = Set Variable $&#123;text&#125;-$&#123;var&#125; END Should Be Equal $&#123;text&#125; zero-one-threeCONTINUE and BREAK with WHILE WHILE True TRY $&#123;value&#125; = Do Something EXCEPT CONTINUE END Do something with value $&#123;value&#125; BREAK ENDInvalid BREAK usage [Documentation] BREAK and CONTINUE can only be used in the loop body, ... not in keywords used in the loop. FOR $&#123;var&#125; IN one two three Invalid BREAK END*** Keywords ***Invalid BREAK [Documentation] This keyword fails due to invalid syntax. BREAK 注意 BREAK和CONTINUE语句是Robot Framework 5.0中的新特性，与WHILE类似。早期版本支持使用BuiltIn关键字Exit For Loop、Exit For Loop If、Continue For Loop和Continue For Loop If来控制FOR循环。这些关键字仍然可以继续工作，但将来将被弃用和删除。 注意 也可以使用RETURN语句来退出循环。它只在循环用于用户关键字内部时才起作用。 IF&#x2F;ELSE语法有时候，需要有条件地执行一些关键字。从Robot Framework 4.0开始，有一个单独的IF&#x2F;ELSE语法，但也有其他方式可以有条件地执行关键字。注意，如果逻辑变得复杂，通常最好将其移动到测试库中。 基本的IF语法Robot Framework的原生IF语法以IF（区分大小写）开始，并以END（区分大小写）结束。IF标记需要一个值，该值是要评估的条件。如果条件为真，则在IF和END标记之间的自己的行上执行关键字。强烈推荐在IF块中缩进关键字，但这不是强制的。 在下面的例子中，如果${rc}大于零，则执行关键字Some keyword和Another keyword： 123456*** Test Cases ***Example IF $&#123;rc&#125; &gt; 0 Some keyword Another keyword END 条件在Python中进行评估，因此可以使用Python内置的如len()等函数，并自动导入模块以支持像platform.system() &#x3D;&#x3D; ‘Linux’和math.ceil({x}) &#x3D;&#x3D; 1这样的用法。像上面的例子中的x)&#x3D;&#x3D;1这样的用法。像上面的例子中的{rc}这样的普通变量在评估之前被替换，但变量也可以在评估命名空间中使用特殊的$rc语法。后一种方法在变量的字符串表示不能直接用于条件时很方便。例如，字符串需要引号，多行字符串和包含引号的字符串本身会引起额外的问题。有关评估语法的更多信息和示例，请参见评估表达式附录。 ELSE分支像大多数其他支持条件执行的语言一样，Robot Framework的IF语法也支持ELSE分支，如果IF条件不为真，则执行ELSE分支。 在这个例子中，如果${rc}大于零，则执行Some keyword，否则执行Another keyword： 1234567*** Test Cases ***Example IF $&#123;rc&#125; &gt; 0 Some keyword ELSE Another keyword END ELSE IF分支Robot Framework还支持ELSE IF分支，它们有自己的条件，如果初始条件不为真，则评估这些条件。可以有任意数量的ELSE IF分支，它们按照指定的顺序进行。如果其中一个ELSE IF条件为真，则执行其后的块，并忽略剩余的ELSE IF分支。一个可选的ELSE分支可以跟在ELSE IF分支后面，如果所有条件都为假，则执行它。 在下面的例子中，根据${rc}是正数、负数、零还是其他东西（如字符串或None），执行不同的关键字： 1234567891011*** Test Cases ***Example IF $rc &gt; 0 Positive keyword ELSE IF $rc &lt; 0 Negative keyword ELSE IF $rc == 0 Zero keyword ELSE Fail Unexpected rc: $&#123;rc&#125; END 注意 这个例子使用了特殊的rc格式的{rc}变量，以避免在它不是数字的情况下出现评估失败。有关这种语法的更多信息，请参见上述的评估表达式附录。 内联IF如果需要执行只有一个语句的条件，那么普通的IF&#x2F;ELSE结构可能有点冗长。它的替代方案是使用内联IF语法，其中要执行的语句直接跟在IF标记和条件后面，不需要END标记。例如，下面的两个关键字是等价的： 123456789101112*** Keywords ***Normal IF IF $condition1 Keyword argument END IF $condition2 RETURN ENDInline IF IF $condition1 Keyword argument IF $condition2 RETURN 内联IF语法也支持ELSE和ELSE IF分支： 123456*** Keywords ***Inline IF/ELSE IF $condition Keyword argument ELSE Another KeywordInline IF/ELSE IF/ELSE IF $cond1 Keyword 1 ELSE IF $cond2 Keyword 2 ELSE IF $cond3 Keyword 3 ELSE Keyword 4 如上面的后一个例子所示，带有几个ELSE IF和ELSE分支的内联IF开始变得难以理解。长的内联IF结构可以使用常见的…连续语法分成多行，但使用普通的IF&#x2F;ELSE结构或将逻辑移动到测试库可能是更好的主意。每个内联IF分支只能包含一个语句。如果需要更多的语句，需要使用普通的IF&#x2F;ELSE结构。 如果需要用内联IF进行赋值，要赋值的变量或变量必须在开始的IF之前。否则，逻辑与基于关键字返回值赋值变量的逻辑完全相同。如果使用了赋值并且没有运行任何分支，变量将获得None值。 123456*** Keywords ***Inline IF/ELSE with assignment $&#123;var&#125; = IF $condition Keyword argument ELSE Another KeywordInline IF/ELSE with assignment having multiple variables $&#123;host&#125; $&#123;port&#125; = IF $production Get Production Config ELSE Get Testing Config 注意 内联IF语法是Robot Framework 5.0中的新特性。 嵌套的IF结构IF结构可以与其他IF结构和FOR循环嵌套。下面的例子使用了高级特性，如FOR-IN-ENUMERATE循环、带有用户关键字的命名只参数和内联Python评估语法 ($&#123;&#123;len($&#123;items&#125;)&#125;&#125;): 1234567891011121314151617181920212223242526272829*** Keywords ***Log items [Arguments] @&#123;items&#125; $&#123;log_values&#125;=True IF not $&#123;items&#125; Log to console No items. ELSE IF len($&#123;items&#125;) == 1 IF $&#123;log_values&#125; Log to console One item: $&#123;items&#125;[0] ELSE Log to console One item. END ELSE Log to console $&#123;&#123;len($&#123;items&#125;)&#125;&#125; items. IF $&#123;log_values&#125; FOR $&#123;index&#125; $&#123;item&#125; IN ENUMERATE @&#123;items&#125; start=1 Log to console Item $&#123;index&#125;: $&#123;item&#125; END END END*** Test Cases ***No items Log itemsOne item without logging value Log items xxx log_values=FalseMultiple items Log items a b c 有条件地执行关键字的其他方式还有其他方法可以有条件地执行关键字： 可以使用变量指定用作套件、测试和关键字的设置或拆卸的关键字的名称。这便于从命令行更改它们。 BuiltIn 关键字 Run Keyword 将实际执行的关键字作为参数，因此它可以是一个变量。例如，可以从早期的关键字动态获取变量的值，或者从命令行给出。 BuiltIn 关键字 Run Keyword If 和 Run Keyword Unless 分别只在某个表达式为真或假时执行一个命名关键字。一般推荐使用上面解释的新的 IF&#x2F;ELSE 语法。 另一个 BuiltIn 关键字，Set Variable If，可以根据给定的表达式动态设置变量。 有几个 BuiltIn 关键字允许只在测试用例或测试套件失败或通过时执行一个命名关键字。 TRY&#x2F;EXCEPT语法当一个关键字失败时，Robot Framework的默认行为是停止当前的测试并执行可能的清理操作。然而，也可能需要在执行过程中处理这些失败。Robot Framework 5.0引入了原生的TRY&#x2F;EXCEPT语法来实现这个目的，但也有其他方式来处理错误。 Robot Framework的TRY&#x2F;EXCEPT语法受到Python的异常处理语法的启发。它有与Python相同的TRY、EXCEPT、ELSE和FINALLY分支，它们的工作方式也大致相同。一个区别是Python使用小写的try、except等，但在Robot Framework中，所有这种语法必须使用大写字母。更大的区别是，在Python中，异常是对象，而在Robot Framework中，处理的是字符串形式的错误消息。 使用EXCEPT捕获异常基本的TRY&#x2F;EXCEPT语法可以用来处理基于错误消息的失败： 12345678*** Test Cases ***First example TRY Some Keyword EXCEPT Error message Error Handler Keyword END Keyword Outside 在上面的例子中，如果Some Keyword通过，EXCEPT分支不会运行，执行会在TRY&#x2F;EXCEPT结构之后继续。如果关键字以错误消息Error message（区分大小写）失败，那么执行EXCEPT分支。如果EXCEPT分支成功，执行会在TRY&#x2F;EXCEPT结构之后继续。如果它失败，测试失败并且剩余的关键字不会被执行。如果Some Keyword以任何其他异常失败，那么该失败不会被处理，测试失败而不执行剩余的关键字。 可以有多个EXCEPT分支。在这种情况下，它们会一个接一个地进行匹配，第一个匹配的分支会被执行。一个EXCEPT也可以有多个消息来匹配，如果其中任何一个消息匹配，那么这样的分支会被执行。在所有这些情况下，消息可以使用变量来指定，除了字面字符串。 123456789101112131415161718*** Test Cases ***Multiple EXCEPT branches TRY Some Keyword EXCEPT Error message # Try matching this first. Error Handler 1 EXCEPT Another error # Try this if above did not match. Error Handler 2 EXCEPT $&#123;message&#125; # Last match attempt, this time using a variable. Error Handler 3 ENDMultiple messages with one EXCEPT TRY Some Keyword EXCEPT Error message Another error $&#123;message&#125; # Match any of these. Error handler END 也可以有一个没有消息的EXCEPT，在这种情况下，它匹配任何错误。只能有一个这样的EXCEPT，它必须在可能的其他EXCEPT分支之后： 12345678910111213141516*** Test Cases ***Match any error TRY Some Keyword EXCEPT # Match any error. Error Handler ENDMatch any after testing more specific errors TRY Some Keyword EXCEPT Error message # Try matching this first Error Handler 1 EXCEPT # Match any that did not match the above. Error Handler 2 END 注意 无法捕获由无效语法引起的异常。 使用模式匹配错误默认情况下，使用EXCEPT匹配错误需要完全匹配。这可以通过将配置选项type&#x3D;作为except子句的参数来改变。该选项的有效值是GLOB、REGEXP或START（不区分大小写），分别用于进行全局模式匹配、正则表达式匹配或仅匹配错误的开头。使用值LITERAL具有与默认行为相同的效果。如果一个EXCEPT有多个消息，这个选项适用于所有的消息。该选项的值可以用变量来定义。 12345678910111213141516171819202122232425262728293031323334353637*** Variables ***$&#123;MATCH TYPE&#125; regexp*** Test Cases ***Glob pattern TRY Some Keyword EXCEPT ValueError: * type=GLOB Error Handler 1 EXCEPT [Ee]rror ?? occurred $&#123;pattern&#125; type=glob Error Handler 2 ENDRegular expression TRY Some Keyword EXCEPT ValueError: .* type=$&#123;MATCH TYPE&#125; Error Handler 1 EXCEPT [Ee]rror \\\\d+ occurred type=Regexp # Backslash needs to be escaped. Error Handler 2 ENDMatch start TRY Some Keyword EXCEPT ValueError: $&#123;beginning&#125; type=start Error Handler ENDExplicit exact match TRY Some Keyword EXCEPT ValueError: invalid literal for int() with base 10: &#x27;ooops&#x27; type=LITERAL Error Handler EXCEPT Error 13 occurred type=LITERAL Error Handler 2 END 注意 记住，正则表达式中经常使用的反斜杠字符在Robot Framework数据中是转义字符。因此，在正则表达式中使用它时需要用另一个反斜杠来转义。 捕获错误消息当使用模式匹配错误，以及在没有任何消息匹配任何错误的情况下使用EXCEPT时，通常需要知道实际发生的错误。Robot Framework通过在EXCEPT语句的末尾添加AS ${var}，使得可以将错误消息捕获到一个变量中。 1234567891011*** Test Cases ***Capture error TRY Some Keyword EXCEPT ValueError: * type=GLOB AS $&#123;error&#125; Error Handler 1 $&#123;error&#125; EXCEPT [Ee]rror \\\\d+ (Invalid|Bad) usage type=REGEXP AS $&#123;error&#125; Error Handler 2 $&#123;error&#125; EXCEPT AS $&#123;error&#125; Error Handler 3 $&#123;error&#125; END 使用ELSE在没有错误时执行关键字可选的ELSE分支使得在没有错误的情况下可以执行关键字。只能有一个ELSE分支，并且只有在一个或多个EXCEPT分支之后才允许： 123456789101112*** Test Cases ***ELSE branch TRY Some Keyword EXCEPT X Log Error &#x27;X&#x27; occurred! EXCEPT Y Log Error &#x27;Y&#x27; occurred! ELSE Log No error occurred! END Keyword Outside 在上面的例子中，如果Some Keyword通过，那么执行ELSE分支，如果它以消息X或Y失败，那么运行适当的EXCEPT分支。在所有这些情况下，执行在整个TRY&#x2F;EXCEPT&#x2F;ELSE结构之后继续。如果Some Keyword以任何其他方式失败，EXCEPT和ELSE分支不会运行，TRY&#x2F;EXCEPT&#x2F;ELSE结构失败。 要处理有任何错误和没有错误的情况，可以使用没有任何消息的EXCEPT与ELSE结合使用： 123456789*** Test Cases ***Handle everything TRY Some Keyword EXCEPT AS $&#123;err&#125; Log Error occurred: $&#123;err&#125; ELSE Log No error occurred! END 使用FINALLY无论是否有错误都执行关键字可选的FINALLY分支使得在有错误和没有错误的情况下都可以执行关键字。因此，它们适合在关键字执行后进行清理，类似于清理操作。只能有一个FINALLY分支，它必须始终在最后。它们可以与EXCEPT和ELSE分支结合使用，也可以使用TRY&#x2F;FINALLY结构： 12345678910111213141516171819*** Test Cases ***TRY/EXCEPT/ELSE/FINALLY TRY Some keyword EXCEPT Log Error occurred! ELSE Log No error occurred. FINALLY Log Always executed. ENDTRY/FINALLY Open Connection TRY Use Connection FINALLY Close Connection END 其他处理错误的方式还有其他方法可以有条件地执行关键字： BuiltIn关键字Run Keyword And Expect Error执行一个命名的关键字，并期望它以指定的错误消息失败。它基本上与使用指定消息的TRY&#x2F;EXCEPT相同。指定错误消息的语法也是相同的，除了这个关键字默认使用全局模式匹配，而不是精确匹配。一般推荐使用原生的TRY&#x2F;EXCEPT功能，除非需要支持不支持它的旧版本的Robot Framework。 BuiltIn关键字Run Keyword And Ignore Error执行一个命名的关键字，并返回其状态作为字符串PASS或FAIL，以及可能的返回值或错误消息。它基本上与使用TRY&#x2F;EXCEPT&#x2F;ELSE相同，以便EXCEPT捕获所有错误。推荐使用原生语法，除非需要支持旧版本的Robot Framework。 BuiltIn关键字Run Keyword And Return Status执行一个命名的关键字，并返回其状态作为布尔值true或false。它是前述的Run Keyword And Ignore Error的包装器。现在推荐使用原生语法。 测试清理和关键字清理可以用于清理活动，类似于FINALLY分支。 当关键字在基于Python的库中实现时，所有Python的错误处理特性都是现成可用的。这是推荐的方法，特别是如果需要的逻辑变得更复杂。 高级特性处理同名关键字使用Robot Framework的关键字可以是库关键字或用户关键字。前者来自标准库或外部库，后者要么在使用它们的同一文件中创建，要么从资源文件中导入。当使用许多关键字时，它们中的一些具有相同的名称是很常见的，本节描述了如何处理这些情况下可能的冲突。 关键字作用域当只使用关键字名称并且有几个具有该名称的关键字时，Robot Framework会尝试根据其作用域确定哪个关键字具有最高优先级。关键字的作用域是根据创建关键字的方式确定的： 在当前执行的套件文件中创建为用户关键字。这些关键字具有最高优先级，即使在其他地方有其他同名关键字，它们也总是被使用。 在资源文件中创建并直接或间接从另一个资源文件导入。这是第二高的优先级。 在外部测试库中创建。如果没有同名的用户关键字，这些关键字将被使用。然而，如果在标准库中有一个同名的关键字，将显示警告。 在标准库中创建。这些关键字具有最低优先级。 明确指定关键字仅凭作用域并不是一个足够的解决方案，因为在几个库或资源中可能有同名的关键字，因此，它们提供了一种机制，只使用最高优先级的关键字。在这种情况下，可以使用关键字的全名，其中关键字名称以资源或库的名称为前缀，点号作为分隔符。 对于库关键字，长格式只意味着使用LibraryName.Keyword Name格式。例如，可以使用OperatingSystem.Run作为OperatingSystem库中的Run关键字，即使在其他地方有另一个Run关键字。如果库在模块或包中，必须使用完整的模块或包名称（例如，com.company.Library.Some Keyword）。如果在导入库时给库指定了自定义名称，那么在完整的关键字名称中也必须使用指定的名称。 资源文件在完整的关键字名称中指定，类似于库名称。资源的名称是从资源文件的基本名称中派生出来的，不包括文件扩展名。例如，可以使用myresources.Example作为myresources.html资源文件中的Example关键字。注意，如果几个资源文件有相同的基本名称，这种语法将不起作用。在这种情况下，必须重命名文件或关键字。关键字的全名与普通关键字名称一样，不区分大小写、空格和下划线。 明确指定库和资源之间的优先级如果关键字之间存在多个冲突，指定所有关键字的长格式可能会很麻烦。使用长格式也使得无法创建根据可用的库或资源的不同而工作不同的动态测试用例或用户关键字。解决这两个问题的一个方法是使用BuiltIn库中的关键字Set Library Search Order显式指定关键字优先级。 注意 尽管关键字在其名称中有库这个词，但它也适用于资源文件。如上所述，资源中的关键字总是比库中的关键字具有更高的优先级。 Set Library Search Order接受一个有序的库和资源列表作为参数。当测试数据中的关键字名称与多个关键字匹配时，选择包含关键字的第一个库或资源，并使用该关键字实现。如果在任何指定的库或资源中都找不到关键字，执行失败，冲突的方式与设置搜索顺序时相同。 有关更多信息和示例，请参阅关键字的文档。 超时有时候，关键字可能需要异常长的时间来执行，或者无限期地挂起。Robot Framework允许为测试用例和用户关键字设置超时，如果一个测试或关键字在指定的时间内没有完成，当前正在执行的关键字将被强制停止。 以这种方式停止关键字可能会使库、测试环境或被测试系统处于不稳定状态，只有在没有更安全的选项可用时，才推荐使用超时。一般来说，库应该实现为关键字不能挂起，或者它们有自己的超时机制。 测试用例超时测试用例的超时可以通过在设置部分使用Test Timeout设置，或者在单个测试用例中使用[Timeout]设置来设置。Test Timeout为该套件中的所有测试用例定义了默认超时，而[Timeout]应用于特定的测试用例，并覆盖可能的默认值。 使用空的[Timeout]意味着测试没有超时，即使使用了Test Timeout。也可以为此目的使用显式的NONE值。如果其值为零或负数，超时也会被有效地忽略。 无论测试超时是在哪里定义的，给它的值都包含超时的持续时间。持续时间必须以Robot Framework的时间格式给出，即直接以秒为单位，如10，或以1分钟30秒的格式。超时也可以指定为变量，使得可以例如从命令行给出它们。 如果有超时并且它过期，当前正在运行的关键字将被停止，测试用例失败。如果发生测试超时，作为测试清理部分执行的关键字不会被中断，但测试仍然被标记为失败。如果清理中的关键字可能挂起，可以使用用户关键字超时来停止它。 123456789101112131415161718192021222324252627*** Settings ***Test Timeout 2 minutes*** Test Cases ***Default timeout [Documentation] Default timeout from Settings is used. Some Keyword argumentOverride [Documentation] Override default, use 10 seconds timeout. [Timeout] 10 Some Keyword argumentVariables [Documentation] It is possible to use variables too. [Timeout] $&#123;TIMEOUT&#125; Some Keyword argumentNo timeout [Documentation] Empty timeout means no timeout even when Test Timeout has been used. [Timeout] Some Keyword argumentNo timeout 2 [Documentation] Disabling timeout with NONE works too and is more explicit. [Timeout] NONE Some Keyword argument 用户关键字超时可以使用[Timeout]设置为用户关键字设置超时。语法与测试用例超时完全相同，但用户关键字超时没有任何默认值。如果使用变量指定用户关键字超时，也可以将值作为关键字参数给出。 12345678910111213141516*** Keywords ***Hardcoded [Arguments] $&#123;arg&#125; [Timeout] 1 minute 42 seconds Some Keyword $&#123;arg&#125;Configurable [Arguments] $&#123;arg&#125; $&#123;timeout&#125; [Timeout] $&#123;timeout&#125; Some Keyword $&#123;arg&#125;Run Keyword with Timeout [Arguments] $&#123;keyword&#125; @&#123;args&#125; &amp;&#123;kwargs&#125; $&#123;timeout&#125;=1 minute [Documentation] Wrapper that runs another keyword with a configurable timeout. [Timeout] $&#123;timeout&#125; Run Keyword $&#123;keyword&#125; @&#123;args&#125; &amp;&#123;kwargs&#125; 用户关键字超时在该用户关键字的执行期间适用。如果整个关键字的总时间超过超时值，当前正在执行的关键字将被停止。用户关键字超时也适用于测试用例的清理过程，而测试超时则不适用。 如果测试用例和其中的一些关键字（或几个嵌套关键字）都有超时，活动超时是剩余时间最少的那个。 注意 在早期的Robot Framework版本中，可以指定一个自定义错误消息，以便在超时过期时使用。这个功能在Robot Framework 3.0.1中被弃用，并在Robot Framework 3.2中被移除。 并行执行关键字当需要并行执行时，必须在测试库级别实现，以便库在后台执行代码。通常，这意味着库需要一个像Start Something这样的关键字来开始执行并立即返回，以及另一个像Get Results From Something这样的关键字来等待结果可用并返回它。参见Process库关键字Start Process和Wait For Process的示例。 执行测试用例 基本使用 Robot Framework 的测试用例从命令行执行，其结果默认为 XML 格式的输出文件以及 HTML 报告和日志。执行后，可以使用 Rebot 工具合并输出文件并进行其他后处理。 测试用例执行基本使用开始执行测试概要123robot [options] datapython -m robot [options] datapython path/to/robot/ [options] data 执行通常是使用安装时创建的 robot 命令开始的。或者，也可以使用选定的 Python 解释器执行已安装的 robot 模块。这在 Robot Framework 已在多个 Python 版本下安装的情况下特别方便。最后，如果知道已安装的 robot 目录在哪里，也可以使用 Python 执行它。 无论执行方法如何，要执行的测试数据的路径（或路径）都作为命令后的参数给出。此外，可以使用不同的命令行选项以多种方式更改测试执行或生成的输出。 指定要执行的测试数据指定要执行的测试数据 Robot Framework 的测试用例在文件和目录中创建，通过将文件或目录的路径给到选定的运行脚本来执行它们。路径可以是绝对的，或者更常见的，相对于从其中执行测试的目录。给定的文件或目录创建顶级测试套件，该套件默认从文件或目录名获取其名称。以下示例中说明了不同的执行可能性。请注意，在这些示例中，以及在本节中的其他示例中，只使用了 robot 脚本，但其他执行方法也可以类似地使用。 123robot tests.robotrobot path/to/my_tests/robot c:\\robot\\tests.robot 注意 执行目录时，所有以点（.）或下划线（_）开头的文件和目录都会被忽略，且默认只执行 .robot 扩展名的文件。有关更多详细信息，请参阅选择要解析的文件部分。 也可以一次给出多个测试用例文件或目录的路径，用空格分隔。在这种情况下，Robot Framework 会自动创建顶级测试套件，指定的文件和目录成为其子测试套件。创建的测试套件的名称是通过将子套件名称用和号（&amp;）和空格连接在一起得到的。例如，下面第一个示例中的顶级套件的名称是 My Tests &amp; Your Tests。这些自动创建的名称通常很长且复杂。在大多数情况下，因此最好使用 –name 选项来覆盖它，如下面的第二个示例所示： 12robot my_tests.robot your_tests.robotrobot --name Example path/to/tests/pattern_*.robot 从 Robot Framework 6.1 开始，也可以为自动创建的顶级套件定义测试套件初始化文件。给出 init 文件的路径与给出测试用例文件的方式类似： 1robot __init__.robot my_tests.robot other_tests.robot 使用命令行选项Robot Framework 提供了许多命令行选项，可以用来控制如何执行测试用例以及生成哪些输出。本节将解释选项语法，以及实际存在的选项。它们如何被使用将在本章的其他部分进行讨论。 使用选项当使用选项时，它们必须始终在运行脚本和数据源之间给出。例如： 12robot -L debug my_tests.robotrobot --include smoke --variable HOST:10.0.0.42 path/to/tests/ 短选项和长选项选项总是有一个长名称，如 --name，最常用的选项也有一个短名称，如 -N。除此之外，只要它们是唯一的，长选项可以被缩短。例如，--logle DEBUG 是有效的，而 --lo log.html 则不行，因为前者只匹配 --loglevel，但后者匹配了多个选项。在手动执行测试用例时，短选项和缩短的选项是实用的，但在启动脚本中，建议使用长选项，因为它们更容易理解。 长选项名称是不区分大小写和连字符的，这有助于以易于阅读的格式编写选项名称。例如，--SuiteStatLevel 和 --suite-stat-level 等同于，但比 --suitestatlevel 更易于阅读。 注意 Robot Framework 6.1 中新增了长选项不区分连字符。 设置选项值大多数选项需要一个值，该值在选项名称之后给出。短选项和长选项都接受用空格从选项名称分隔的值，如 --include tag 或 -i tag。对于长选项，分隔符也可以是等号，例如 --include=tag，对于短选项，分隔符可以省略，如 -itag。 有些选项可以指定多次。例如，--variable VAR1:value --variable VAR2:another 设置了两个变量。如果多次使用只接受一个值的选项，最后给出的值是有效的。 禁用不接受值的选项不接受值的选项可以通过再次使用相同的选项并添加或删除无前缀来禁用。无论选项使用多少次，最后的选项都有优先权。例如，--dryrun --dryrun --nodryrun --nostatusrc --statusrc 将不会激活 dry-run 模式，并将返回正常的状态 rc。 简单模式许多命令行选项接受参数作为简单模式。这些类似于全局的模式根据以下规则进行匹配： * 匹配任何字符串，甚至是空字符串。 ? 匹配任何单个字符。 [abc] 匹配括号中的一个字符。 [!abc] 匹配不在括号中的一个字符。 [a-z] 匹配括号中范围内的一个字符。 [!a-z] 匹配不在括号中范围内的一个字符。 与通常的全局模式不同，路径分隔符 / 和 \\ 以及换行符 \\n 由上述通配符匹配。 除非另有说明，模式匹配对大小写、空格和下划线不敏感。 示例： 123--test Example* # 匹配以 &#x27;Example&#x27; 开头的测试名称。--test Example[1-2] # 匹配 &#x27;Example1&#x27; 和 &#x27;Example2&#x27; 测试。--include f?? # 匹配以 &#x27;f&#x27; 开头且长度为三个字符的标签的测试。 上述示例中的所有匹配对大小写、空格和下划线不敏感。例如，第二个示例也会匹配名为 example 1 的测试。 如果匹配的文本恰好包含一些通配符字符，并且需要将它们按字面意义匹配，那么可以通过使用 [...] 语法来实现。模式 [*] 匹配字面 * 字符，[?] 匹配 ?，[[] 匹配 [。单独的 [ 和 ] 不需要转义。 注意 Robot Framework 3.1 中新增了像 [abc] 和 [!a-z] 这样的括号支持。 标签模式大多数与标签相关的选项接受参数作为标签模式。它们支持与简单模式相同的通配符（例如 examp??，ex*le），但它们还支持下面解释的 AND、OR 和 NOT 运算符。这些运算符可以用于将两个或更多个独立的标签或模式组合在一起。 AND 或 &amp;如果所有的单个模式都匹配，那么整个模式就匹配。AND 和 &amp; 是等价的： 12--include fooANDbar # 匹配包含标签 &#x27;foo&#x27; 和 &#x27;bar&#x27; 的测试。--exclude xx&amp;yy&amp;zz # 匹配包含标签 &#x27;xx&#x27;、&#x27;yy&#x27; 和 &#x27;zz&#x27; 的测试。 OR如果任何单个模式匹配，那么整个模式就匹配： 12--include fooORbar # 匹配包含标签 &#x27;foo&#x27; 或 &#x27;bar&#x27; 的测试。--exclude xxORyyORzz # 匹配包含任何标签 &#x27;xx&#x27;、&#x27;yy&#x27; 或 &#x27;zz&#x27; 的测试。 NOT如果左侧的模式匹配，但右侧的模式不匹配，那么整个模式就匹配。如果多次使用，第一个 NOT 之后的所有模式都不能匹配： 12--include fooNOTbar # 匹配包含标签 &#x27;foo&#x27; 但不包含标签 &#x27;bar&#x27; 的测试。--exclude xxNOTyyNOTzz # 匹配包含标签 &#x27;xx&#x27; 但不包含标签 &#x27;yy&#x27; 或 &#x27;zz&#x27; 的测试。 模式也可以以 NOT 开始，在这种情况下，如果 NOT 后的模式不匹配，那么模式就匹配： 12--include NOTfoo # 匹配不包含标签 &#x27;foo&#x27; 的测试--include NOTfooANDbar # 匹配不包含标签 &#x27;foo&#x27; 和 &#x27;bar&#x27; 的测试 上述运算符也可以一起使用。运算符的优先级，从高到低，是 AND、OR 和 NOT： 123--include xANDyORz # 匹配包含标签 &#x27;x&#x27; 和 &#x27;y&#x27;，或标签 &#x27;z&#x27; 的测试。--include xORyNOTz # 匹配包含标签 &#x27;x&#x27; 或 &#x27;y&#x27;，但不包含标签 &#x27;z&#x27; 的测试。--include xNOTyANDz # 匹配包含标签 &#x27;x&#x27;，但不包含标签 &#x27;y&#x27; 和 &#x27;z&#x27; 的测试。 虽然标签匹配本身是不区分大小写的，但所有运算符都是区分大小写的，必须用大写字母写。如果标签本身恰好包含大写的 AND、OR 或 NOT，它们需要使用小写字母指定，以避免意外的运算符使用： 123--include port # 匹配包含标签 &#x27;port&#x27; 的测试，不区分大小写--include PORT # 匹配包含标签 &#x27;P&#x27; 或 &#x27;T&#x27; 的测试，不区分大小写--exclude handoverORportNOTnotification ROBOT_OPTIONS 和 REBOT_OPTIONS 环境变量环境变量 ROBOT_OPTIONS 和 REBOT_OPTIONS 可以用来分别为测试执行和结果后处理指定默认选项。选项及其值必须定义为一个空格分隔的列表，并且它们被放在命令行上的任何显式选项之前。这些环境变量的主要用途是为某些选项设置全局默认值，以避免每次运行测试或使用 Rebot 时都需要重复它们。 1234export ROBOT_OPTIONS=&quot;--outputdir results --tagdoc &#x27;mytag:Example doc with spaces&#x27;&quot;robot tests.robotexport REBOT_OPTIONS=&quot;--reportbackground blue:red:yellow&quot;rebot --name example output.xml 测试结果命令行输出测试执行的最直观的输出是在命令行中显示的输出。所有执行的测试套件和测试用例，以及它们的状态，都会实时显示在那里。下面的示例显示了执行一个只有两个测试用例的简单测试套件的输出： 1234567891011121314==============================================================================示例测试套件==============================================================================第一个测试 :: 可能的测试文档 | 通过 |------------------------------------------------------------------------------第二个测试 | 失败 |这里显示错误消息==============================================================================示例测试套件 | 失败 |2个测试，1个通过，1个失败==============================================================================输出： /path/to/output.xml报告： /path/to/report.html日志： /path/to/log.html 每当测试用例中的顶级关键字结束时，控制台上也会有一个通知。如果关键字通过，则使用绿色的点，如果失败，则使用红色的F。这些标记被写到行的末尾，当测试本身结束时，它们被测试状态覆盖。如果将控制台输出重定向到文件，将禁用写入标记。 生成的输出文件命令行输出非常有限，通常需要单独的输出文件来调查测试结果。如上面的示例所示，默认情况下会生成三个输出文件。第一个是XML格式的，包含了关于测试执行的所有信息。第二个是更高级别的报告，第三个是更详细的日志文件。这些文件和其他可能的输出文件在不同的输出文件部分中讨论得更详细。 返回代码运行脚本使用返回代码向运行它们的系统通信总体测试执行状态。当执行成功开始并且没有测试失败时，返回代码为零。下表解释了所有可能的返回代码。 可能的返回代码 RC 解释 0 所有测试通过。 1-249 返回失败的测试数量。 250 250个或更多的失败。 251 打印了帮助或版本信息。 252 无效的测试数据或命令行选项。 253 测试执行被用户停止。 255 意外的内部错误。 返回代码应该在执行后始终容易获得，这使得自动确定总体执行状态变得容易。例如，在bash shell中，返回代码在特殊变量$?中，在Windows中，它在%ERRORLEVEL%变量中。如果使用一些外部工具来运行测试，查阅其文档以了解如何获取返回代码。 即使有失败，也可以使用--NoStatusRC命令行选项将返回代码设置为0。例如，在连续集成服务器中，可能需要在确定测试执行的总体状态之前对结果进行后处理，这可能很有用。 注意 Rebot也使用相同的返回代码。 执行过程中的错误和警告在测试执行过程中，可能会出现意外的问题，比如无法导入库或资源文件，或者关键字已被弃用。根据严重程度，这些问题被分类为错误或警告，并被写入控制台（使用标准错误流），在日志文件的单独 “Test Execution Errors” 部分中显示，并写入 Robot Framework 自己的系统日志。通常，这些错误和警告是由 Robot Framework 本身生成的，但库也可以记录错误和警告。下面的示例说明了日志文件中的错误和警告是什么样子的。 1220090322 19:58:42.528 ERROR 文件 &#x27;/home/robot/tests.robot&#x27; 中的 &#x27;Setting&#x27; 表格的第 2 行元素出错：资源文件 &#x27;resource.robot&#x27; 不存在20090322 19:58:43.931 WARN 关键字 &#x27;SomeLibrary.Example Keyword&#x27; 已被弃用。请使用关键字 `Other Keyword`。 参数文件参数文件允许将所有或部分命令行选项和参数放置在一个外部文件中进行读取。这避免了命令行中存在的问题字符。如果需要大量的选项或参数，参数文件也可以防止在命令行中使用的命令变得过长。 参数文件通过 --argumentfile（-A）选项以及可能的其他命令行选项进行使用。 注意 与其他长命令行选项不同，--argumentfile 不能以缩短的格式（如 --argumentf）给出。 参数文件语法参数文件可以包含命令行选项和测试数据的路径，每行一个选项或数据源。支持短选项和长选项，但推荐使用后者，因为它们更容易理解。参数文件可以包含任何字符，无需转义，但行首和行尾的空格会被忽略。此外，空行和以井号（#）开头的行也会被忽略： 12345--doc 这是一个示例（其中&quot;特殊字符&quot;是可以的！）--metadata X:带空格的值--variable VAR:Hello, world!# 这是一个注释path/to/my/tests 在上述示例中，选项和它们的值之间的分隔符是一个空格。可以使用等号（&#x3D;）或任意数量的空格。例如，以下三行是相同的： 123--name An Example--name=An Example--name An Example 如果参数文件包含非ASCII字符，它们必须使用UTF-8编码保存。 使用参数文件参数文件可以单独使用，以便它们包含所有的选项和测试数据的路径，或者与其他选项和路径一起使用。当一个参数文件与其他参数一起使用时，它的内容被放置到原始参数列表的与参数文件选项相同的位置。这意味着参数文件中的选项可以覆盖它之前的选项，它的选项可以被它之后的选项覆盖。可以多次甚至递归地使用 --argumentfile 选项： 1234robot --argumentfile all_arguments.robotrobot --name Example --argumentfile other_options_and_paths.robotrobot --argumentfile default_options.txt --name Example my_tests.robotrobot -A first.txt -A second.txt -A third.txt tests.robot 从标准输入读取参数文件可以使用特殊的参数文件名 STDIN 从标准输入流而不是文件中读取参数。当使用脚本生成参数时，这可能很有用： 12generate_arguments.sh | robot --argumentfile STDINgenerate_arguments.sh | robot --name Example --argumentfile STDIN tests.robot 获取帮助和版本信息无论是在执行测试用例还是在后处理输出时，都可以通过 --help（-h）选项获取命令行帮助。这些帮助文本有一个简短的概述，并简要解释了可用的命令行选项。 所有的运行脚本也支持使用 --version 选项获取版本信息。这些信息还包含 Python 版本和平台类型： 12345$ robot --versionRobot Framework 7.0 (Python 3.12.1 on darwin)C:\\&gt;rebot --versionRebot 6.1.1 (Python 3.11.0 on win32) ​ 创建启动脚本测试用例通常由持续集成系统或其他一些机制自动执行。在这种情况下，需要有一个脚本来启动测试执行，可能还需要以某种方式对输出进行后处理。类似的脚本在手动运行测试时也很有用，特别是当需要大量的命令行选项或设置测试环境比较复杂时。 在类 UNIX 环境中，shell 脚本提供了一种简单但强大的机制来创建自定义的启动脚本。Windows 批处理文件也可以使用，但它们更有限，通常也更复杂。一个平台无关的替代方案是使用 Python 或其他高级编程语言。无论使用哪种语言，都建议使用长选项名称，因为它们比短名称更容易理解。 Shell 脚本示例在这个示例中，登录目录中的相同网络测试在不同的浏览器上执行，并使用 Rebot 在之后合并结果。该脚本也接受命令行选项本身，并使用方便的 $* 变量简单地将它们转发给 robot 命令： 1234#!/bin/bashrobot --name Firefox --variable BROWSER:Firefox --output out/fx.xml --log none --report none $* loginrobot --name IE --variable BROWSER:IE --output out/ie.xml --log none --report none $* loginrebot --name Login --outputdir out --output login.xml out/fx.xml out/ie.xml 批处理文件示例使用批处理文件实现上述 shell 脚本示例也不是很复杂。注意，批处理文件的参数可以使用 %* 转发给执行的命令： 1234@echo offrobot --name Firefox --variable BROWSER:Firefox --output out\\fx.xml --log none --report none %* loginrobot --name IE --variable BROWSER:IE --log none --output out\\ie.xml --report none %* loginrebot --name Login --outputdir out --output login.xml out\\fx.xml out\\ie.xml 注意 在 Robot Framework 3.1 之前，robot 和 rebot 命令在 Windows 上是作为批处理文件实现的，而在另一个批处理文件中使用它们需要在整个命令前加上 call。 Python 示例当启动脚本变得更复杂时，使用 shell 脚本或批处理文件实现它们就不那么方便了。这尤其是在需要两种变体并且需要两次实现相同逻辑的情况下。在这种情况下，通常最好切换到 Python。可以使用 subprocess 模块从 Python 执行 Robot Framework，但通常使用 Robot Framework 自己的程序化 API 更方便。最容易使用的 API 是 robot.run_cli 和 robot.rebot_cli，它们接受与 robot 和 rebot 命令相同的命令行参数。 以下示例实现了与前面的 shell 脚本和批处理文件示例相同的逻辑。在 Python 中，脚本本身的参数可以在 sys.argv 中获取： 12345678#!/usr/bin/env pythonimport sysfrom robot import run_cli, rebot_clicommon = [&#x27;--log&#x27;, &#x27;none&#x27;, &#x27;--report&#x27;, &#x27;none&#x27;] + sys.argv[1:] + [&#x27;login&#x27;]run_cli([&#x27;--name&#x27;, &#x27;Firefox&#x27;, &#x27;--variable&#x27;, &#x27;BROWSER:Firefox&#x27;, &#x27;--output&#x27;, &#x27;out/fx.xml&#x27;] + common, exit=False)run_cli([&#x27;--name&#x27;, &#x27;IE&#x27;, &#x27;--variable&#x27;, &#x27;BROWSER:IE&#x27;, &#x27;--output&#x27;, &#x27;out/ie.xml&#x27;] + common, exit=False)rebot_cli([&#x27;--name&#x27;, &#x27;Login&#x27;, &#x27;--outputdir&#x27;, &#x27;out&#x27;, &#x27;out/fx.xml&#x27;, &#x27;out/ie.xml&#x27;]) 注意 需要 exit=False，因为默认情况下 run_cli 会以正确的返回代码退出到系统。rebot_cli 也是如此，但在上述示例中这是可以的。 使 *.robot 文件可执行在类 UNIX 的操作系统上，可以通过赋予它们执行权限并添加像这样的 shebang 来使 *.robot 文件可执行： 12345#!/usr/bin/env robot*** Test Cases ***Example Log to console Executing! 如果上述内容位于一个名为 example.robot 的文件中，并且该文件是可执行的，那么它可以像下面这样从命令行执行。从 Robot Framework 3.2 开始，单独执行的文件可以有任何扩展名，或者根本没有扩展名，所以如果文件只是命名为 example，同样也可以工作。 1./example.robot 这个技巧在执行目录时不起作用，但在执行单个文件时可能很方便。在自动化任务时，这可能更常用一些，而不是在自动化测试时。 调试问题测试用例可能会失败，因为被测试的系统不正常工作，在这种情况下，测试发现了一个 bug，或者因为测试本身有 bug。解释失败的错误消息显示在命令行输出和报告文件中，有时错误消息本身就足以找出问题。然而，更多的时候，需要日志文件，因为它们还有其他日志消息，并且它们显示了哪个关键字实际上失败了。 当失败是由被测试的应用程序引起的，错误消息和日志消息应该足以理解导致它的原因。如果不是这样，测试库没有提供足够的信息，需要进行增强。在这种情况下，如果可能，手动运行相同的测试也可能揭示有关问题的更多信息。 由测试用例本身或它们使用的关键字引起的失败有时可能很难调试。例如，如果错误消息告诉一个关键字使用了错误数量的参数，修复问题显然很容易，但如果一个关键字缺失或以意外的方式失败，找到根本原因可能会更难。寻找更多信息的第一个地方是日志文件中的执行错误部分。例如，关于失败的测试库导入的错误可能很好地解释了为什么由于缺少关键字而导致测试失败。 如果日志文件默认情况下没有提供足够的信息，可以使用较低的日志级别执行测试。例如，显示失败发生在代码中哪里的回溯是使用 DEBUG 级别记录的，当问题出在单个库关键字时，这些信息是无价的。 记录的回溯不包含 Robot Framework 本身内部方法的信息。如果怀疑错误是由框架的 bug 导致的，可以通过将环境变量 ROBOT_INTERNAL_TRACES 设置为任何非空值来启用显示内部跟踪。 如果日志文件仍然没有足够的信息，启用 syslog 并查看它提供的信息是个好主意。也可以向测试用例添加一些关键字来查看正在发生什么。特别是 BuiltIn 关键字 Log 和 Log Variables 是有用的。如果其他方法都不起作用，总是可以从邮件列表或其他地方寻求帮助。 使用 Python 调试器 (pdb)也可以使用 Python 标准库中的 pdb 模块来设置断点并交互式地调试正在运行的测试。通常通过在想要进入调试器的位置插入： 1import pdb; pdb.set_trace() 这种方式调用 pdb 在 Robot Framework 中无法正确工作，因为在关键字执行期间重定向了标准输出流。相反，可以使用以下方式： 1import sys, pdb; pdb.Pdb(stdout=sys.__stdout__).set_trace() 在 Python 库中，或者作为替代，可以直接在测试用例中使用： 1Evaluate pdb.Pdb(stdout=sys.__stdout__).set_trace() modules=sys, pdb ​ 测试执行本节描述了如何执行从解析的测试数据创建的测试套件结构，如何确定测试状态，以及如果有失败，如何继续执行测试用例，以及如何优雅地停止整个测试执行。 执行流程执行的套件和测试测试用例总是在测试套件中执行。从套件文件创建的测试套件直接拥有测试，而从目录创建的套件拥有子测试套件，这些子套件要么拥有测试，要么拥有它们自己的子套件。默认情况下，执行的套件中的所有测试都会运行，但可以使用选项 --test、--suite、--include 和 --exclude 来选择测试。不包含测试的套件将被忽略。 执行从顶级测试套件开始。如果套件有测试，它们将逐一执行，如果套件有套件，它们将以深度优先的顺序递归执行。当执行单个测试用例时，它包含的关键字将按顺序运行。通常，如果任何关键字失败，当前测试的执行就会结束，但也可以在失败后继续。以下各节将讨论确切的执行顺序以及可能的设置和拆卸如何影响执行。 设置和拆卸设置和拆卸可以在测试套件、测试用例和用户关键字级别使用。 套件设置如果测试套件有一个设置，它将在其测试和子套件之前执行。如果套件设置通过，测试执行将正常继续。如果失败，套件及其子套件包含的所有测试用例都将被标记为失败。子测试套件中的测试和可能的套件设置和拆卸不会被执行。 套件设置通常用于设置测试环境。因为如果套件设置失败，测试就不会运行，所以使用套件设置来验证环境是否处于可以执行测试的状态是很容易的。 套件拆卸如果测试套件有一个拆卸，它将在所有测试用例和子套件之后执行。无论测试状态如何，甚至如果匹配的套件设置失败，套件拆卸都会被执行。如果套件拆卸失败，之后在报告和日志中，套件中的所有测试都将被标记为失败。 套件拆卸主要用于在执行后清理测试环境。为了确保所有这些任务都完成，拆卸中使用的所有关键字都会被执行，即使其中一些关键字失败。 测试设置可能的测试设置在测试用例的关键字之前执行。如果设置失败，关键字将不会被执行。测试设置的主要用途是为特定的测试用例设置环境。 测试拆卸可能的测试拆卸在测试用例执行后执行。无论测试状态如何，甚至如果测试设置失败，都会执行它。 与套件拆卸类似，测试拆卸主要用于清理活动。它们也会被完全执行，即使其中一些关键字失败。 用户关键字设置用户关键字设置在执行关键字主体之前执行。如果设置失败，主体将不会被执行。关键字设置和主体中的第一个关键字之间没有太大的区别。 注意 用户关键字设置是在 Robot Framework 7.0 中新增的。 用户关键字拆卸用户关键字拆卸在关键字以其他方式执行后运行，无论状态如何。即使其中一些关键字失败，用户关键字拆卸也会被完全执行。 执行顺序测试套件中的测试用例按照它们在测试用例文件中定义的顺序执行。高级测试套件内的测试套件按照文件或目录名的不区分大小写的字母顺序执行。如果从命令行给出了多个文件和&#x2F;或目录，它们将按照给出的顺序执行。 如果需要在目录内使用特定的测试套件执行顺序，可以将前缀如 01 和 02 添加到文件和目录名中。如果这些前缀与套件的基本名称用两个下划线分隔，那么在生成的测试套件名称中不会包含这些前缀： 1201__my_suite.robot -&gt; My Suite02__another_suite.robot -&gt; Another Suite 如果套件内的测试套件的字母顺序有问题，一个好的解决方法是按照所需的顺序单独给出它们。这很容易导致启动命令过长，但参数文件允许每行列出一个文件，这样很好。 也可以使用 --randomize 选项随机化执行顺序。 测试和套件状态本节解释了测试如何获得 PASS、FAIL 或 SKIP 状态，以及如何根据测试状态确定套件状态。 注意 SKIP 状态是在 Robot Framework 4.0 中新增的。 PASS如果一个测试被执行并且它包含的所有关键字都没有失败，那么它将获得 PASS 状态。 提前通过的测试通常情况下，所有的关键字都会被执行，但也可以使用 BuiltIn 关键字 Pass Execution 和 Pass Execution If 来停止执行，并且不运行剩余的关键字。 以下是 Pass Execution 和 Pass Execution If 在不同情况下的行为： 当它们用在任何设置或拆卸（套件、测试或关键字）中时，这些关键字会使该设置或拆卸通过。可能的已启动关键字的拆卸会被执行。测试执行或状态不会受到其他影响。 当它们在设置或拆卸之外的测试用例中使用时，关键字会使该特定的测试用例通过。可能的测试和关键字拆卸会被执行。 在使用这些关键字之前发生的可能的可继续的失败，以及之后执行的拆卸中的失败，都会导致执行失败。 必须给出一个解释为什么执行被中断的消息，也可以修改测试用例标签。更多的细节和使用示例，请参阅这些关键字的文档。 在测试、设置或拆卸的中间阶段通过执行应该谨慎使用。在最坏的情况下，它可能导致跳过所有可能实际揭示被测试应用程序问题的部分。在执行由于外部因素无法继续的情况下，通常更安全的做法是跳过测试。 FAIL测试获得 FAIL 状态的最常见原因是它包含的某个关键字失败。关键字本身可以通过引发异常失败，或者关键字可以被错误地调用。其他失败的原因包括语法错误和测试为空。 如果套件设置失败，套件中的测试将在不运行它们的情况下被标记为失败。如果套件拆卸失败，测试将在之后被追溯性地标记为失败。 SKIP从 Robot Framework 4.0 开始，测试可以获得 SKIP 状态，除了 PASS 和 FAIL。有许多不同的方式可以获得这个状态。 执行前跳过命令行选项 --skip 可以用来跳过指定的测试，而不需要完全运行它们。它基于标签工作，并支持标签模式，如 examp?? 和 tagANDanother。如果多次使用，所有匹配任何指定标签或标签模式的测试都会被跳过： 123--skip require-network--skip windowsANDversion9?--skip python2.* --skip python3.[0-6] 从 Robot Framework 5.0 开始，也可以通过给测试添加保留标签 robot:skip 来跳过测试用例： 1234*** Test Cases ***Example [Tags] robot:skip Log This is not executed --skip 和 --exclude 的区别在于，使用后者的测试将被完全排除在执行之外，它们将不会显示在日志和报告中。使用前者，它们被包含在内，但实际上并未执行，它们将在日志和报告中可见。 执行过程中动态跳过在执行过程中，测试可以通过多种方式获得 SKIP 状态： 在测试用例中的任何地方，包括设置或拆卸，使用 BuiltIn 关键字 Skip。使用 Skip 关键字有两个效果：测试获得 SKIP 状态，测试的其余部分不会被执行。然而，如果测试有一个拆卸，它将被运行。 使用 BuiltIn 关键字 Skip If，它接受一个条件，并在条件为真时跳过测试。 库关键字也可以通过使用特殊的异常来触发跳过行为。这在创建测试库章节的跳过测试部分有解释。 如果使用任何上述方法跳过套件设置，套件中的所有测试都会被跳过，而不执行它们。 如果套件拆卸被跳过，所有的测试将被追溯性地标记为跳过。 自动跳过失败的测试命令行选项 --skiponfailure 可以用来自动将失败的测试标记为跳过。它基于标签工作，并支持像上面讨论的 --skip 选项那样的标签模式： 12--skiponfailure not-ready--skiponfailure experimentalANDmobile 从 RF 5.0 开始，可以选择使用保留标签 robot:skip-on-failure 来达到上述相同的效果： 1234*** Test Cases ***Example [Tags] robot:skip-on-failure Fail this test will be marked as skipped instead of failed 这个功能的动机是允许执行那些还没有准备好的测试，或者测试一个还没有准备好的功能。这样的测试不会失败，而是会被标记为跳过，它们的标签可以用来将它们与可能的其他跳过的测试分开。 从关键性迁移到 SKIP早期的 Robot Framework 版本支持关键性概念，允许将测试标记为关键或非关键。默认情况下，所有测试都是关键的，但可以使用 --critical 和 --noncritical 选项进行配置。关键测试和非关键测试的区别在于，当确定执行的测试套件或整个测试运行的最终状态时，非关键测试不会被包含。实际上，测试状态是二维的，一轴是 PASS 和 FAIL，另一轴是关键性。 非关键的失败测试在许多方面类似于当前的跳过测试。因为这些特性相似，同时拥有 SKIP 和关键性会创建出像非关键 SKIP 这样的奇怪测试状态，所以在 Robot Framework 4.0 中引入 SKIP 状态时，移除了关键性概念。关键性问题的详细解释在提出移除它的问题中。 关键性概念的主要用例是能够运行尚未准备好的测试，或者测试尚未准备好的功能。现在，这个用例由前一节讨论的 skip-on-failure 功能覆盖。 为了简化从关键性到跳过的迁移，旧的 --noncritical 选项在 Robot Framework 4.0 中作为新的 --skiponfailure 的别名工作，同时也保留了旧的 --critical 选项。这两个旧选项都已被弃用，并在 Robot Framework 5.0 中被移除。 套件状态套件状态完全根据它包含的测试的状态确定： 如果有任何测试失败，套件状态为 FAIL。 如果没有失败，但至少有一个测试通过，套件状态为 PASS。 如果所有测试都已跳过，或者根本没有测试，套件状态为 SKIP。 失败后继续通常情况下，当测试用例中的任何关键字失败时，测试用例会立即停止。这种行为缩短了测试执行时间，并防止了如果被测试的系统处于不稳定状态时，后续的关键字挂起或者引发其他问题。然而，这有一个缺点，那就是后续的关键字通常会提供更多关于系统状态的信息，而且在某些情况下，这些后续的关键字实际上会负责进行必要的清理活动。因此，Robot Framework 提供了几个即使有失败也可以继续的特性。 自动在拆卸后继续执行为了确保所有的清理活动都得到了处理，套件、测试和关键字拆卸中自动启用了继续失败模式。实际上，这意味着在拆卸中，所有级别的关键字总是会被执行。 如果不希望这种行为，可以使用特殊的 robot:stop-on-failure 和 robot:recursive-stop-on-failure 标签来禁用它。 当测试有模板时，执行所有顶级关键字当使用测试模板时，所有的顶级关键字都会被执行，以确保覆盖所有不同的组合。在这种使用中，继续只限于顶级关键字，而在它们内部，如果有不可继续的失败，执行就会正常结束。 12345*** Test Cases ***Continue with templates [Template] Should be Equal this fails this is run 如果不希望这种行为，可以使用特殊的 robot:stop-on-failure 和 robot:recursive-stop-on-failure 标签来禁用它。 来自关键字的特殊失败库关键字使用异常报告失败，可以使用特殊的异常来告诉 Robot Framework，无论失败与否，执行都可以继续。如何创建这些异常在创建测试库部分的可继续失败部分中有解释。 当一个测试结束并且有可继续的失败时，测试将被标记为失败。如果有多于一个的失败，所有的失败都将在最终的错误消息中列举出来： 12345Several failures occurred:1) First error message.2) Second error message. 如果在可继续的失败之后发生正常的失败，测试执行也会结束。在这种情况下，所有的失败也将在最终的错误消息中列出。 从失败的关键字返回的值，可能被赋值给一个变量，总是 Python 的 None。 Run Keyword And Continue On Failure 关键字BuiltIn 关键字 Run Keyword And Continue On Failure 允许将任何失败转换为可继续的失败。这些失败由框架以与上述来自库关键字的可继续失败完全相同的方式处理。 1234*** Test Cases ***Example Run Keyword and Continue on Failure Should be Equal 1 2 Log This is executed but test fails in the end 使用标签启用失败后继续作为测试用例或用户关键字的一部分执行的所有关键字，如果它们被标记为 robot:continue-on-failure 标签，则默认认为它们是可继续的。例如，以下两个测试的行为是相同的： 12345678910111213141516171819*** Test Cases ***Test 1 Run Keyword and Continue on Failure Should be Equal 1 2 User Keyword 1Test 2 [Tags] robot:continue-on-failure Should be Equal 1 2 User Keyword 2*** Keywords ***User Keyword 1 Run Keyword and Continue on Failure Should be Equal 3 4 Log This is executedUser Keyword 2 [Tags] robot:continue-on-failure Should be Equal 3 4 Log This is executed 这些标签也会影响不同控制结构的继续失败模式。例如，下面的测试用例将执行 Do Something 关键字十次，无论它是否成功： 123456*** Test Cases ***Example [Tags] robot:continue-on-failure FOR $&#123;index&#125; IN RANGE 10 Do Something END 在测试用例或用户关键字中设置 robot:continue-on-failure 不会将继续失败行为传播到它们调用的用户关键字。如果需要这种递归行为，可以使用 robot:recursive-continue-on-failure 标签。例如，以下示例中的所有关键字都被执行： 12345678910111213141516*** Test Cases ***Example [Tags] robot:recursive-continue-on-failure Should be Equal 1 2 User Keyword 1 Log This is executed*** Keywords ***User Keyword 1 Should be Equal 3 4 User Keyword 2 Log This is executedUser Keyword 2 Should be Equal 5 6 Log This is executed 在测试用例中设置 robot:continue-on-failure 或 robot:recursive-continue-on-failure 不会改变作为 [Setup] 的一部分执行的关键字的失败行为：测试用例被标记为失败，并且不执行任何测试用例关键字。 注意 robot:continue-on-failure 和 robot:recursive-continue-on-failure 标签是在 Robot Framework 4.1 中新增的。它们在 Robot Framework 6.0 之前的 WHILE 循环中不能正常工作。 使用标签禁用失败后继续如果需要，可以使用特殊的标签 robot:stop-on-failure 和 robot:recursive-stop-on-failure 来禁用失败后继续模式。它们在使用标签启用失败后继续以及在拆卸和模板中也起作用： 123456789101112131415161718192021*** Test Cases ***Disable continue-in-failure set using tags [Tags] robot:recursive-continue-on-failure Keyword Keyword # 这将被执行Disable continue-in-failure in teardown No Operation [Teardown] KeywordDisable continue-in-failure with templates [Tags] robot:stop-on-failure [Template] Should be Equal this fails this is not run*** Keywords ***Keyword [Tags] robot:stop-on-failure Should be Equal this fails Should be Equal this is not run robot:stop-on-failure 标签只影响使用它的测试用例和用户关键字，并且不会传播到它们调用的用户关键字或它们自己的拆卸。如果需要影响所有调用的用户关键字和拆卸的递归行为，可以使用 robot:recursive-stop-on-failure 标签代替。如果有需要，它的效果可以再次在较低级别的关键字中通过使用 robot:continue-on-failure 或 robot:recursive-continue-on-failure 标签来禁用。 robot:stop-on-failure 和 robot:recursive-stop-on-failure 标签不会改变由库关键字或 Run Keyword And Continue On Failure 引起的可继续失败的行为。例如，尽管使用了 robot:stop-on-failure，但这个示例中的两个关键字都会运行： 12345*** Test Cases ***Example [Tags] robot:stop-on-failure Run Keyword and Continue on Failure Should be Equal 1 2 Log This is executed regardless the tag 如果 robot:recursive-stop-on-failure 和 robot:continue-on-failure 在同一个测试或关键字中一起使用，如果有失败，执行将在调用的关键字中停止，但在使用这些标签的测试或关键字中继续。如果 robot:recursive-continue-on-failure 和 robot:stop-on-failure 在同一个测试或关键字中一起使用，如果有失败，执行将在调用的关键字中继续，但在使用这些标签的测试或关键字中停止。 注意 robot:stop-on-failure 和 robot:recursive-stop-on-failure 标签是在 Robot Framework 6.0 中新增的。 注意 在同一个测试或关键字中同时使用递归和非递归标签是在 Robot Framework 7.0 中新增的。 TRY&#x2F;EXCEPTRobot Framework 5.0 引入了原生的 TRY&#x2F;EXCEPT 语法，可以用于处理失败： 1234567*** 测试用例 ***示例 TRY 某个关键字 EXCEPT 预期的错误信息 错误处理关键字 END 更多详情请参见单独的 TRY&#x2F;EXCEPT 语法部分。 内置关键字有几个内置关键字可以用于执行其他关键字，以便在可能的失败后继续执行： Run Keyword And Expect Error 执行一个关键字并期望它失败，给出指定的错误信息。现在一般推荐使用上述的 TRY&#x2F;EXCEPT 语法。 Run Keyword And Ignore Error 执行一个关键字并忽略可能的错误。它返回状态以及可能的关键字返回值或错误信息。在这种情况下，TRY&#x2F;EXCEPT 语法通常效果更好。 Run Keyword And Warn On Failure 是 Run Keyword And Ignore Error 的包装器，如果执行的关键字失败，它会自动记录警告。 Run Keyword And Return Status 执行一个关键字并返回布尔值 True 或 False，取决于它是否通过。 优雅地停止测试执行有时候，需要在所有测试完成之前停止测试执行，但同时需要生成日志和报告。以下是实现这一目标的不同方法。在所有这些情况下，剩余的测试用例都会被标记为失败。 自动失败的测试会获得 robot:exit 标签，生成的报告将包含 NOT robot:exit 组合标签模式，以便轻松查看那些未被跳过的测试。请注意，发生退出的测试不会获得 robot:exit 标签。 注意 在 Robot Framework 3.1 之前，特殊标签被命名为 robot-exit。 按下 Ctrl-C当在运行测试的控制台中按下 Ctrl-C 时，执行会立即停止，但仍会生成报告和日志。 如果再次按下 Ctrl-C，执行会立即结束，报告和日志不会被创建。 使用信号在类 UNIX 机器上，可以使用 INT 和 TERM 信号来终止测试执行。这些信号可以通过使用 kill 命令从命令行发送，发送信号也可以很容易地自动化。 使用关键字执行也可以通过执行的关键字来停止。有一个单独的 Fatal Error 内置关键字用于此目的，自定义关键字在失败时可以使用致命异常。 当第一个测试用例失败时停止如果使用了 --exitonfailure（-X）选项，如果有任何测试失败，测试执行会立即停止。剩余的测试会被标记为失败，而实际上并没有执行它们。 在解析或执行错误时停止Robot Framework 将由失败的关键字引起的失败与由例如无效设置或失败的测试库导入引起的错误分开。默认情况下，这些错误被报告为测试执行错误，但错误本身不会导致测试失败或以其他方式影响执行。然而，如果使用了 --exitonerror 选项，所有这样的错误都被认为是致命的，并且执行停止，以便剩余的测试被标记为失败。对于在执行开始之前就遇到的解析错误，这意味着实际上没有运行任何测试。 处理 teardowns默认情况下，即使使用上述方法之一停止了测试执行，已经开始的测试和套件的 teardowns 也会被执行。这允许无论执行如何结束，都可以运行清理活动。 也可以使用 --skipteardownonexit 选项在执行停止时跳过 teardowns。例如，如果清理任务需要很长时间，这可能会很有用。 任务执行除了测试自动化之外，Robot Framework 还可以用于其他自动化目的，从 Robot Framework 3.1 开始，可以明确地创建和执行任务。任务执行和测试执行在大多数部分上工作方式相同，本节将解释其中的差异。 通用自动化模式当 Robot Framework 用于执行一个文件，并且注意到该文件有任务，而不是测试时，它会自动设置自己进入通用自动化模式。这种模式并不改变实际的执行，但是当创建日志和报告时，它们使用的是任务（task），而不是测试（test）。例如，它们的标题是 “任务日志”（Task Log）和 “任务统计”（Task Statistics），而不是 “测试日志”（Test Log）和 “测试统计”（Test Statistics）。 通用自动化模式也可以通过使用 --rpa 选项来启用。在这种情况下，执行的文件可以有测试或任务。或者，可以使用 --norpa 来强制测试自动化模式，即使执行的文件包含任务。如果这两个选项都没有使用，那么执行多个文件，使得一些文件有测试，其他文件有任务，将会是一个错误。 执行模式存储在生成的输出文件中，并由 Rebot 读取，如果输出被后处理。如果需要，也可以在使用 Rebot 时设置模式。 任务相关的命令行选项执行任务时可以使用所有正常的命令行选项。如果需要选择只执行某些任务，可以使用 --task 代替 --test。此外，还可以使用前面提到的 --rpa 来控制执行模式。 后处理输出在测试执行期间生成的 XML 输出文件可以在之后由 Rebot 工具进行后处理，Rebot 是 Robot Framework 的一个组成部分。它在测试执行期间自动生成测试报告和日志，单独使用它可以创建自定义报告和日志以及合并结果。 使用 Rebot概述123rebot [options] outputspython -m robot.rebot [options] outputspython path/to/robot/rebot.py [options] outputs 使用 Rebot 的最常见方式是使用 rebot 命令。或者，也可以使用选定的 Python 解释器执行已安装的 robot.rebot 模块或 robot/rebot.py 文件。 指定选项和参数使用 Rebot 的基本语法与启动测试执行时完全相同，大多数命令行选项也是相同的。主要的区别是 Rebot 的参数是 XML 输出文件，而不是测试数据文件或目录。 Rebot 的返回代码Rebot 的返回代码与运行测试时完全相同。 控制执行模式Rebot 注意到已经运行了测试或任务，并默认保留执行模式。该模式影响日志和报告，以便在前一种情况下，它们将使用像 “Test Log” 和 “Test Statistics” 这样的测试术语，在后一种情况下，它们将使用像 “Task Log” 和 “Task Statistics” 这样的任务术语。 Rebot 还支持使用 --rpa 或 --norpa 选项来显式设置执行模式。如果处理多个输出文件并且它们的模式有冲突，这是必要的。 创建报告、日志和输出文件可以使用 Rebot 创建在测试执行期间自动创建的相同的报告和日志。当然，创建完全相同的文件是没有意义的，但是，例如，有一个包含所有测试用例的报告和只包含一些测试子集的另一个报告可能是有用的： 123rebot output.xmlrebot path/to/output_file.xmlrebot --include smoke --name Smoke_Tests c:\\results\\output.xml 另一个常见的用法是在运行测试时只创建输出文件（可以使用 --log NONE --report NONE 禁用日志和报告生成），并稍后生成日志和报告。例如，可以在不同的环境上执行测试，将输出文件收集到一个中心位置，然后在那里创建报告和日志。 默认情况下，Rebot 不创建 XML 输出文件，但是可以使用 --output（-o）选项创建它们。默认情况下会创建日志和报告，但是如果不需要它们，可以使用值 NONE（不区分大小写）禁用它们： 1rebot --include smoke --output smoke.xml --log none --report none original.xml 合并输出Rebot 的一个重要特性是它能够合并来自不同测试执行轮次的输出。这种能力允许，例如，在不同的环境上运行相同的测试用例，并从所有输出中生成一个总体报告。合并输出非常容易，只需要将多个输出文件作为参数给出： 12rebot output1.xml output2.xmlrebot outputs/*.xml 当输出被合并时，会创建一个新的顶级测试套件，使得给定输出文件中的测试套件成为其子套件。当执行多个测试数据文件或目录时，这种情况也是一样的，而且在这种情况下，顶级测试套件的名称是通过用 &amp; 和空格连接子套件名称来创建的。这些自动生成的名称不是那么好，通常使用 --name 给出更有意义的名称是一个好主意： 12rebot --name Browser_Compatibility firefox.xml opera.xml safari.xml ie.xmlrebot --include smoke --name Smoke_Tests c:\\results\\*.xml 融合输出如果相同的测试被重新执行或者一个单独的测试套件被分片执行，像上面讨论的那样合并结果会创建一个不必要的顶级测试套件。在这些情况下，通常更好的做法是融合结果。融合是通过使用 --merge（-R）选项完成的，该选项改变了 Rebot 合并两个或更多输出文件的方式。这个选项本身不需要参数，所有其他的命令行选项都可以正常地与它一起使用： 12rebot --merge original.xml merged.xmlrebot --merge --name Example first.xml second.xml third.xml 当套件被融合时，文档、套件设置和套件拆卸都来自最后融合的套件。所有融合并套件的套件元数据都被保留，以便后面的套件的值具有优先权。 如何合并测试的工作方式在以下讨论两个主要融合用例的部分中进行了解释。 注意 从融合套件获取套件文档和元数据是 Robot Framework 6.0 中的新功能。 重新执行测试并融合结果在测试过程中，经常需要重新执行一部分测试，例如在修复了被测试系统或测试本身的错误后。这可以通过按名称（--test 和 --suite 选项）、标签（--include 和 --exclude）或以前的状态（--rerunfailed 或 --rerunfailedsuites）选择测试用例来实现。 使用默认的输出融合方法将重新执行的结果与原始结果结合起来效果不太好。主要问题是会得到单独的测试套件，可能已经修复的失败也会显示出来。在这种情况下，最好使用 --merge (-R) 选项告诉 Rebot 合并结果。实际上，这意味着后续测试运行中的测试替换了原始测试。此规则的一个例外是，后续运行中跳过的测试被忽略，保留原始测试。 以下是一个实际的例子，使用 --rerunfailed 和 --merge 一起使用： 123robot --output original.xml tests # 首先执行所有测试robot --rerunfailed original.xml --output rerun.xml tests # 然后重新执行失败的测试rebot --merge original.xml rerun.xml # 最后合并结果 融合的测试的消息包含一个注释，说明结果已被替换。消息还显示了测试的旧状态和消息。 融合的结果必须始终具有相同的顶级测试套件。在融合的输出中未从原始输出中找到的测试和套件被添加到结果输出中。这在实践中是如何工作的将在下一节中讨论。 注意：在 Robot Framework 4.1 中，新的特性是在后续运行中忽略跳过的测试。 融合分段执行的套件--merge 选项的另一个重要用例是融合使用 --include 和 --exclude 选项等方式分段运行测试套件时得到的结果： 123robot --include smoke --output smoke.xml tests # 首先运行一些测试robot --exclude smoke --output others.xml tests # 然后运行其他测试rebot --merge smoke.xml others.xml # 最后融合结果 当像这样融合输出时，结果输出包含了所有给定输出文件中找到的所有测试和套件。如果某个测试在多个输出中找到，最新的结果替换早期的结果，就像在前一节中解释的那样。这种融合策略也要求所有输出中的顶级测试套件相同。 JSON 输出文件Rebot 可以创建和处理 JSON 格式的输出文件。创建 JSON 输出文件是使用正常的 --output 选项，指定的文件有 .json 扩展名： 1rebot --output output.json output.xml 当读取输出文件时，JSON 文件会根据扩展名自动识别： 12rebot output.jsonrebot output1.json output2.json 当合并或合并结果时，可以混合 JSON 和 XML 文件： 12rebot output1.xml output2.jsonrebot --merge original.xml rerun.json JSON 输出文件的结构在 result.json schema 文件中有文档。 注意 在 Robot Framework 7.0 中，新的特性是支持 JSON 输出文件。 配置执行本节解释了可以用于配置测试执行或后处理输出的不同命令行选项。与生成的输出文件相关的选项将在下一节中讨论。 选择要解析的文件执行单个文件当执行单个文件时，Robot Framework 会尝试解析并运行它们，而不考虑文件名或文件扩展名。使用哪个解析器取决于扩展名： .robot 文件和未被识别的文件使用正常的 Robot Framework 解析器进行解析。 .rst 和 .rest 文件使用 reStructuredText 解析器进行解析。 .rbt 和 .json 文件使用 JSON 解析器进行解析。 支持自定义解析器的文件由匹配的解析器进行解析。 示例： 1234robot example.robot # 标准的 Robot Framework 解析器。robot example.tsv # 必须与标准解析器兼容。robot example.rst # reStructuredText 解析器。robot x.robot y.rst # 使用适当的解析器解析两个文件。 包含和排除文件当执行一个目录时，文件和目录按照以下规则进行解析： 所有以点（.）或下划线（_）开头的文件和目录都被忽略。 .robot 文件使用正常的 Robot Framework 解析器进行解析。 .robot.rst 文件使用 reStructuredText 解析器进行解析。 .rbt 文件使用 JSON 解析器进行解析。 支持自定义解析器的文件由匹配的解析器进行解析。 其他文件被忽略，除非使用 --parseinclude 或 --extension 选项启用了解析它们，这些选项将在后续部分中讨论。 ​ 选择要解析的文件根据名称或路径选择文件在执行目录时，可以使用 --parseinclude (-I) 选项根据文件的名称或路径来解析特定的文件。这个选项的语义稍有不同，具体取决于它使用的值： 如果值只是一个文件名，如 example.robot，那么所有目录中匹配该名称的文件都将被解析。 要匹配特定目录中的特定文件，可以将文件作为相对或绝对路径给出，如 path/to/tests.robot。 如果值是一个目录的路径，那么该目录内的所有文件都会被解析，递归地。 示例： 1234robot --parseinclude example.robot tests # 解析 `tests` 下的 `example.robot` 文件。robot -I example_*.robot -I ???.robot tests # 解析 `tests` 下匹配 `example_*.robot` 或 `???.robot` 的文件。robot -I tests/example.robot tests # 只解析 `tests/example.robot`。robot --parseinclude tests/example tests # 递归解析 `tests/example` 目录下的文件。 与 --parseinclude 一起使用的值不区分大小写，并支持像 example_*.robot 这样的 glob 模式。然而，与 Robot Framework 通常如何工作的模式相比，有两个小的不同： * 只匹配一个路径段。例如，path/*/tests.robot 匹配 path/to/tests.robot，但不匹配 path/to/nested/tests.robot。 ** 可以用来启用递归匹配。例如，path/**/tests.robot 匹配 path/to/tests.robot 和 path/to/nested/tests.robot。 如果模式包含一个扩展名，那么即使默认情况下不会解析具有该扩展名的文件，也会解析它。使用哪个解析器取决于使用的扩展名： .rst 和 .rest 文件使用 reStructuredText 解析器进行解析。 .json 文件使用 JSON 解析器进行解析。 其他文件使用正常的 Robot Framework 解析器进行解析。 注意 当使用像 *.robot 这样的模式，并且在执行目录中存在匹配该模式的文件时，shell 可能会在调用 Robot Framework 之前解析该模式，传递给它的值是文件名，而不是原始模式。在这种情况下，需要引用或转义模式，如 &#39;*.robot&#39; 或 \\*.robot。 --parseinclude 是 Robot Framework 6.1 中的新特性。 根据扩展名选择文件除了使用上一节中讨论的 --parseinclude 选项外，还可以使用 --extension (-F) 选项来启用解析默认情况下不解析的文件。匹配扩展名不区分大小写，可以省略前导点。如果需要解析多种类型的文件，可以使用冒号 : 来分隔扩展名： 12robot --extension rst path/to/tests # 只解析 *.rst 文件。robot -F robot:rst path/to/tests # 解析 *.robot 和 *.rst 文件。 以上等同于以下的 --parseinclude 使用： 12robot --parseinclude *.rst path/to/testsrobot -I *.robot -I *.rst path/to/tests 因为 --parseinclude 选项更强大，覆盖了 --extension 选项的所有用例，所以后者可能在未来被弃用。建议用户现在就开始使用 --parseinclude。 使用自定义解析器外部解析器可以解析 Robot Framework 否则无法识别的文件。有关创建和使用此类解析器的更多信息，请参见解析器接口部分。 选择测试用例Robot Framework 提供了几个命令行选项用于选择要执行的测试用例。当执行任务和后处理 Rebot 的输出时，这些选项也同样适用。 通过测试名称选择只运行一些测试的最简单方法是使用 --test (-t) 选项。顾名思义，它可以用于通过它们的名称选择测试。给定的名称对大小写、空格和下划线不敏感，也支持简单的模式。该选项可以多次使用以匹配多个测试： 123--test Example # 只匹配名为 &#x27;Example&#x27; 的测试。--test example* # 匹配以 &#x27;example&#x27; 开头的测试。--test first --test second # 匹配名为 &#x27;first&#x27; 或 &#x27;second&#x27; 的测试。 为了更精确地指定一个测试，可以在测试名称前加上套件名称： 123--test mysuite.mytest # 匹配套件 &#x27;mysuite&#x27; 中的测试 &#x27;mytest&#x27;。--test root.sub.test # 匹配套件 &#x27;root&#x27; 中的套件 &#x27;sub&#x27; 中的测试 &#x27;test&#x27;。--test *.sub.test # 匹配任何地方的套件 &#x27;sub&#x27; 中的测试 &#x27;test&#x27;。 注意，当给定的名称包含套件名称时，它必须匹配从根套件开始的整个套件名称。如上面的最后一个例子所示，使用通配符允许匹配具有父套件的测试。 当只需要选择几个测试时，使用 --test 选项很方便。一个常见的用例是只运行当前正在处理的测试。如果需要选择更多的测试，通常通过套件名称或标签名称选择它们会更容易。 在执行任务时，可以使用 --task 选项作为 --test 的别名。 通过套件名称也可以使用 --suite (-s) 选项通过套件名称选择测试，该选项选择匹配套件中的所有测试。与 --test 类似，给定的名称对大小写、空格和下划线不敏感，并支持简单的模式。为了更精确地指定一个套件，可以在名称前加上父套件的名称： 12345--suite Example # 只匹配名为 &#x27;Example&#x27; 的套件。--suite example* # 匹配以 &#x27;example&#x27; 开头的套件。--suite first --suite second # 匹配名为 &#x27;first&#x27; 或 &#x27;second&#x27; 的套件。--suite root.child # 匹配根套件 &#x27;root&#x27; 中的套件 &#x27;child&#x27;。--suite *.parent.child # 匹配任何地方的父套件 &#x27;parent&#x27; 下的套件 &#x27;child&#x27;。 如果名称包含父套件名称，它必须以与 --test 相同的方式匹配整个套件名称。如上面的最后一个例子所示，使用通配符允许匹配具有父套件的套件。 注意 在 Robot Framework 7.0 之前，带有父套件的 --suite 不需要匹配整个套件名称。例如，parent.child 会匹配任何地方的父套件 parent 下的套件 child。如果现在希望这种行为，那么名称必须以通配符为前缀。 如果同时使用 --suite 和 --test 选项，只有指定套件中的指定测试被选择： 1--suite mysuite --test mytest # 如果测试 &#x27;mytest&#x27; 在套件 &#x27;mysuite&#x27; 中，则匹配。 使用 --suite 选项大致相当于直接执行适当的套件文件或目录。主要的区别是，如果直接运行文件或目录，可能的套件设置和拆卸在更高级别上不会被执行： 12345# 根套件是 &#x27;Tests&#x27;，并且可能的设置和拆卸会被运行。robot --suite example path/to/tests# 根套件是 &#x27;Example&#x27;，并且可能的更高级别的设置和拆卸会被忽略。robot path/to/tests/example.robot 在 Robot Framework 6.1 之前，出于性能考虑，不符合 –suite 选项的文件根本不会被解析。然而，当测试套件获得了一个新的 Name 设置，该设置可以覆盖从文件或目录名称获取的默认测试套件名称后，这种优化就不再可能了。因此，如果需要进行这种类型的解析优化，就会新增 –parseinclude 选项，用于显式选择要解析的文件。 通过标签名称可以使用 --include (-i) 和 --exclude (-e) 选项分别根据标签名称包含和排除测试用例。如果使用了 --include 选项，只有具有匹配标签的测试用例会被选中，而使用 --exclude 选项，具有匹配标签的测试用例将不会被选中。如果两者都使用，只有具有匹配前者选项的标签，且没有匹配后者的标签的测试会被选中： 123--include example--exclude not_ready--include regression --exclude long_lasting --include 和 --exclude 都可以多次使用以匹配多个标签。在这种情况下，如果一个测试具有匹配任何包含的标签，并且也没有匹配任何排除的标签，那么该测试就会被选中。 除了指定完全匹配的标签外，还可以使用标签模式，其中 * 和 ? 是通配符，AND、OR 和 NOT 运算符可以用于将单个标签或模式组合在一起： 12345--include feature-4?--exclude bug*--include fooANDbar--exclude xxORyyORzz--include fooNOTbar 从 RF 5.0 开始，也可以使用保留标签 robot:exclude 来达到与使用 --exclude 选项相同的效果： 1234*** Test Cases ***Example [Tags] robot:exclude Fail This is not executed 通过标签选择测试用例是一种非常灵活的机制，允许许多有趣的可能性： 可以用 smoke 标签标记要在其他测试之前执行的测试子集（通常称为烟雾测试），并使用 --include smoke 执行。 可以用 not_ready 等标签将未完成的测试提交到版本控制，并使用 --exclude not_ready 从测试执行中排除。 测试可以用 sprint-&lt;num&gt; 标签标记，其中 &lt;num&gt; 指定当前冲刺的编号，执行所有测试用例后，可以生成一个只包含某个冲刺的测试的单独报告（例如，rebot --include sprint-42 output.xml）。 --include 和 --exclude 选项可以与前一节中讨论的 --suite 和 --test 一起使用。它们如何一起工作的一般规则如下： 如果使用了 --suite，测试必须在指定的套件中，除此之外还要满足其他选择条件。 如果 --include 与 --test 一起使用，对于一个测试来说，匹配其中任何一个就足够了。 如果使用了 --exclude，匹配它的测试永远不会被选中。 以上规则在以下示例中得到了演示： 1234--suite example --include tag # 如果测试在套件 &#x27;example&#x27; 中并且有标签 &#x27;tag&#x27;，则匹配。--suite example --exclude tag # 如果测试在套件 &#x27;example&#x27; 中并且没有标签 &#x27;tag&#x27;，则匹配。--test example --include tag # 如果测试的名称是 &#x27;example&#x27; 或者它有标签 &#x27;tag&#x27;，则匹配。--test ex* --exclude tag # 如果测试的名称以 &#x27;ex&#x27; 开头并且它没有标签 &#x27;tag&#x27;，则匹配。 注意 在 Robot Framework 7.0 之前，使用 --include 和 --test 一起需要测试同时具有匹配的标签和匹配的名称。 重新执行失败的测试用例命令行选项 --rerunfailed (-R) 可以用来从早期的输出文件中选择所有失败的测试用例进行重新执行。例如，如果运行所有测试需要很长时间，而希望迭代修复失败的测试用例，那么这个选项就很有用。 12robot tests # 首先执行所有测试robot --rerunfailed output.xml tests # 然后重新执行失败的测试 在幕后，这个选项选择了失败的测试，就像它们是使用 --test 选项单独选择的一样。可以使用 --test、--suite、--include 和 --exclude 选项进一步微调所选测试的列表。 如果输出中没有失败的测试，那么这是一个错误，但是可以使用下面讨论的 --runemptysuite 选项改变这种行为。使用一个不是来自现在运行的相同测试的输出会导致结果未定义。使用一个特殊的值 NONE 作为输出，就像根本没有指定这个选项一样。 提示：可以使用 --merge 命令行选项将重新执行的结果和原始结果合并在一起。 重新执行失败的测试套件命令行选项 --rerunfailedsuites (-S) 可以用来从早期的输出文件中选择所有失败的套件进行重新执行。像 --rerunfailed (-R) 一样，当完整的测试执行需要很长时间时，这个选项很有用。注意，一个失败的测试套件中的所有测试都将被重新执行，即使是通过的测试。当一个测试套件中的测试相互依赖时，这个选项很有用。 在幕后，这个选项选择了失败的套件，就像它们是使用 --suite 选项单独选择的一样。可以使用 --test、--suite、--include 和 --exclude 选项进一步微调所选测试的列表。 当没有测试匹配选择时默认情况下，当没有测试匹配选择条件时，测试执行会失败，错误如下： 1[ ERROR ] Suite &#x27;Example&#x27; with includes &#x27;xxx&#x27; contains no test cases. 因为没有生成输出，所以如果测试是自动执行和处理结果的，这种行为可能会有问题。幸运的是，可以使用命令行选项 --RunEmptySuite（不区分大小写）强制在这种情况下也执行套件。结果是创建了正常的输出，但显示执行的测试为零。当执行一个空目录或一个不包含测试的测试用例文件时，也可以使用相同的选项来改变行为。 在使用 Rebot 处理输出文件时，也可能出现类似的情况。可能没有测试匹配使用的过滤条件，或者输出文件一开始就没有测试。默认情况下，执行 Rebot 在这些情况下会失败，但是它有一个单独的 --ProcessEmptySuite 选项，可以用来改变行为。实际上，这个选项在运行测试时的工作方式与 --RunEmptySuite 相同。 注意 使用 --RunEmptySuite 与 --ReRunFailed 或 --ReRunFailedSuites 需要 Robot Framework 5.0.1 或更高版本。 设置元数据设置套件名称当 Robot Framework 解析测试数据时，套件名称是从文件和目录名称创建的。然而，可以使用命令行选项 --name (-N) 覆盖顶级测试套件的名称： 1robot --name &quot;Custom name&quot; tests.robot 设置套件文档除了在测试数据中定义文档外，还可以使用选项 --doc (-D) 从命令行给出顶级套件的文档。值可以包含简单的 HTML 格式，如果包含空格，必须加引号。 如果给定的文档是指向现有文件的相对或绝对路径，那么实际的文档将从该文件中读取。如果外部指定的文档很长或包含多行，这特别方便。 示例： 12robot --doc &quot;Example documentation&quot; tests.robotrobot --doc doc.txt tests.robot # 如果存在，文档将从 doc.txt 中读取。 注意 在 Robot Framework 4.1 中，从外部文件读取文档是新的特性。 在 Robot Framework 3.1 之前，文档中的下划线会像 --name 选项一样被转换为空格。 设置自由套件元数据也可以使用选项 --metadata (-M) 从命令行给出自由套件元数据。参数必须以 name:value 的格式给出，其中 name 是要设置的元数据的名称，value 是其值。值可以包含简单的 HTML 格式，如果整个参数包含空格，必须加引号。这个选项可以多次使用以设置多个元数据值。 如果给定的值是指向现有文件的相对或绝对路径，那么实际的值将从该文件中读取。如果值很长或包含多行，这特别方便。如果值应该是一个指向现有文件的路径，而不是从该文件中读取，那么值必须与 name: 部分用空格分隔。 示例： 1234robot --metadata Name:Value tests.robotrobot --metadata &quot;Another Name:Another value, now with spaces&quot; tests.robotrobot --metadata &quot;Read From File:meta.txt&quot; tests.robot # 如果存在，值将从 meta.txt 中读取。robot --metadata &quot;Path As Value: meta.txt&quot; tests.robot # 值始终按原样使用。 注意 在 Robot Framework 4.1 中，从外部文件读取元数据值是新的特性。 在 Robot Framework 3.1 之前，值中的下划线会像 --name 选项一样被转换为空格。 设置测试标签命令行选项 --settag (-G) 可以用来为所有执行的测试用例设置给定的标签。这个选项可以多次使用以设置多个标签。 配置搜索库和其他扩展的位置当 Robot Framework 导入测试库、监听器或其他基于 Python 的扩展时，它使用 Python 解释器从系统中导入包含扩展的模块。查找模块的位置列表被称为模块搜索路径，可以使用本节解释的不同方法配置其内容。 如果指定的路径没有直接匹配任何文件，Robot Framework 也会在导入资源和变量文件时使用 Python 的模块搜索路径。 正确设置模块搜索路径以找到库和其他扩展是成功执行测试的要求。如果需要使用下面解释的方法自定义它，创建一个自定义的启动脚本通常是个好主意。 自动在模块搜索路径中的位置Python 解释器有自己的标准库，以及一个第三方模块自动安装的目录，在模块搜索路径中。这意味着使用 Python 自己的打包系统打包的测试库会自动安装，以便可以导入它们，无需任何额外的配置。 PYTHONPATHPython 从 PYTHONPATH 环境变量中读取要添加到模块搜索路径的额外位置。如果想在其中任何一个环境变量中指定多个位置，需要在类 UNIX 机器上用冒号分隔位置（例如，&#x2F;opt&#x2F;libs:$HOME&#x2F;testlibs），在 Windows 上用分号分隔（例如，D:\\libs;%HOMEPATH%\\testlibs）。 环境变量可以被永久地配置为系统范围，或者只影响某个用户。或者，它们可以在运行命令之前临时设置，这在自定义启动脚本中工作得非常好。 使用 –pythonpath 选项Robot Framework 有一个单独的命令行选项 --pythonpath (-P)，用于向模块搜索路径添加位置。 可以通过用冒号（:）或分号（;）分隔它们，或者多次使用此选项来给出多个位置。如果值包含冒号和分号，那么它将从分号处分割。路径也可以是匹配多个路径的 glob 模式，但是它们通常需要在控制台上使用时进行转义。 示例： 12345--pythonpath libs--pythonpath /opt/testlibs:mylibs.zip:yourlibs--pythonpath /opt/testlibs --pythonpath mylibs.zip --pythonpath yourlibs--pythonpath c:\\temp;d:\\resources--pythonpath lib/\\*.zip # &#x27;*&#x27; 是转义的 注意：无论操作系统如何，冒号和分号都可以工作。在 Robot Framework 5.0 中，使用分号是新的。 以编程方式配置 sys.pathPython 解释器将它们使用的模块搜索路径存储为字符串列表在 sys.path 属性中。这个列表可以在执行过程中动态更新，下次导入某个东西时会考虑到这些更改。 设置变量可以使用 --variable (-v) 选项从命令行单独设置变量，或者通过 --variablefile (-V) 选项通过变量文件设置变量。变量和变量文件在单独的章节中有解释，但以下示例说明了如何使用这些选项： 12345--variable name:value--variable OS:Linux --variable IP:10.0.0.42--variablefile path/to/variables.py--variablefile myvars.py:possible:arguments:here--variable ENVIRONMENT:Windows --variablefile c:\\resources\\windows.py 干运行Robot Framework 支持所谓的干运行模式，在这种模式下，测试通常会正常运行，但来自测试库的关键字根本不会被执行。干运行模式可以用来验证测试数据；如果干运行通过，数据应该在语法上是正确的。这种模式使用选项 --dryrun 触发。 干运行执行可能会因以下原因失败： 使用未找到的关键字。 使用参数数量错误的关键字。 使用语法无效的用户关键字。 除了这些失败之外，还会显示正常执行错误，例如，当无法解析测试库或资源文件导入时。 可以通过向特定用户关键字添加一个特殊的 robot:no-dry-run 关键字标签来禁用干运行验证。如果一个关键字在干运行模式下由于某种原因失败，但在正常执行时工作正常，这将很有用。 注意 干运行模式不验证变量。 随机化执行顺序可以使用选项 --randomize &lt;what&gt;[:&lt;seed&gt;] 来随机化测试执行顺序，其中 &lt;what&gt; 是以下之一： tests：每个测试套件内的测试用例以随机顺序执行。 suites：所有测试套件以随机顺序执行，但套件内的测试用例按照它们定义的顺序运行。 all：测试用例和测试套件都以随机顺序执行。 none：测试和套件的执行顺序都不会被随机化。这个值可以用来覆盖之前用 --randomize 设置的值。 可以给出一个自定义的种子来初始化随机生成器。如果想使用和之前相同的顺序重新运行测试，这将很有用。种子作为 --randomize 的值的一部分给出，格式为 &lt;what&gt;:&lt;seed&gt;，它必须是一个整数。如果没有给出种子，它将被随机生成。执行的顶级测试套件自动获取名为 Randomized 的元数据，它告诉随机化了什么和使用了什么种子。 示例： 12robot --randomize tests my_test.robotrobot --randomize all:12345 path/to/tests 编程修改测试数据如果提供的内置功能在执行前修改测试数据还不够，Robot Framework 允许以编程方式进行自定义修改。这是通过创建一个所谓的预运行修改器并使用 --prerunmodifier 选项激活它来实现的。 预运行修改器应该作为访问者实现，可以遍历可执行的测试套件结构并根据需要修改它。访问者接口是作为 Robot Framework API 文档的一部分进行解释的，可以使用它来修改执行的测试套件、测试用例和关键字。下面的示例应该能给出如何使用预运行修改器以及这个功能有多强大的想法。 当在命令行上使用 --prerunmodifier 选项启用预运行修改器时，可以指定为修改器类的名称或修改器文件的路径。如果修改器作为类名给出，包含该类的模块必须在模块搜索路径中，如果模块名与类名不同，给定的名称必须包含两者，如 module.ModifierClass。如果修改器作为路径给出，类名必须与文件名相同。在大多数情况下，这与导入测试库的方式完全相同。 如果修改器需要参数，像下面的示例那样，它们可以在修改器名称或路径后使用冒号（:）或分号（;）作为分隔符指定。如果值中使用了两者，那么首先使用的那个被认为是实际的分隔符。从 Robot Framework 4.0 开始，参数也支持命名参数语法，以及基于类型提示和默认值的参数转换，就像关键字一样。 如果需要多个预运行修改器，可以通过多次使用 --prerunmodifier 选项来指定。如果在创建日志和报告之前需要类似的修改，可以使用 --prerebotmodifier 选项启用结果的编程修改。 预运行修改器在影响执行的测试套件和测试用例的其他配置之前执行。最重要的是，选择测试用例的选项在修改器之后处理，使得可以使用 --include 等选项，也可以与可能动态添加的测试一起使用。 信息 修改器在命令行上的使用方式与监听器完全相同。请参阅从命令行注册监听器部分以获取更多信息和示例。 示例：选择每个 Xth 测试第一个示例展示了如何通过预运行修改器从执行的测试套件结构中移除测试。在此示例中，只保留每个 Xth 测试，X 是从命令行给出的，还有一个可选的起始索引。 123456789101112131415161718192021222324&quot;&quot;&quot;预运行修改器，仅选择每个 Xth 测试进行执行。默认从第一个测试开始。每个套件选择测试。&quot;&quot;&quot;from robot.api import SuiteVisitorclass SelectEveryXthTest(SuiteVisitor): def __init__(self, x: int, start: int = 0): self.x = x self.start = start def start_suite(self, suite): &quot;&quot;&quot;修改套件的测试，只包含每个 Xth。&quot;&quot;&quot; suite.tests = suite.tests[self.start::self.x] def end_suite(self, suite): &quot;&quot;&quot;移除测试后为空的套件。&quot;&quot;&quot; suite.suites = [s for s in suite.suites if s.test_count &gt; 0] def visit_test(self, test): &quot;&quot;&quot;避免访问测试及其关键字以节省一些时间。&quot;&quot;&quot; pass 如果上述预运行修改器在 SelectEveryXthTest.py 文件中，并且该文件在模块搜索路径中，那么可以这样使用： 12345# 指定修改器为路径。运行每个第二个测试。robot --prerunmodifier path/to/SelectEveryXthTest.py:2 tests.robot# 指定修改器为名称。运行每个第三个测试，从第二个开始。robot --prerunmodifier SelectEveryXthTest:3:1 tests.robot 注意 基于类型提示的参数转换，如上例中的 x: int，是 Robot Framework 4.0 中的新特性，需要 Python 3。 示例：通过名称排除测试第二个示例也移除了测试，这次是基于给定的名称模式。实际上，它的工作方式类似于内置的 –test 选项的负版本。 12345678910111213141516171819202122232425262728&quot;&quot;&quot;预运行修改器，通过它们的名称排除测试。要排除的测试是通过使用模式指定的，该模式既不区分大小写也不区分空格，并支持 &#x27;*&#x27;（匹配任何内容）和 &#x27;?&#x27;（匹配单个字符）作为通配符。&quot;&quot;&quot;from robot.api import SuiteVisitorfrom robot.utils import Matcherclass ExcludeTests(SuiteVisitor): def __init__(self, pattern): self.matcher = Matcher(pattern) def start_suite(self, suite): &quot;&quot;&quot;移除与给定模式匹配的测试。&quot;&quot;&quot; suite.tests = [t for t in suite.tests if not self._is_excluded(t)] def _is_excluded(self, test): return self.matcher.match(test.name) or self.matcher.match(test.longname) def end_suite(self, suite): &quot;&quot;&quot;移除测试后为空的套件。&quot;&quot;&quot; suite.suites = [s for s in suite.suites if s.test_count &gt; 0] def visit_test(self, test): &quot;&quot;&quot;避免访问测试及其关键字以节省一些时间。&quot;&quot;&quot; pass 假设上述修改器在名为 ExcludeTests.py 的文件中，那么可以这样使用： 12345# 排除名为 &#x27;Example&#x27; 的测试。robot --prerunmodifier path/to/ExcludeTests.py:Example tests.robot# 排除所有以 &#x27;something&#x27; 结尾的测试。robot --prerunmodifier path/to/ExcludeTests.py:*something tests.robot ​ 示例：禁用设置和拆卸有时在调试测试时，禁用设置或拆卸可能很有用。这可以通过编辑测试数据来实现，但预运行修改器使得临时进行单次运行变得容易： 1234567891011121314151617181920212223&quot;&quot;&quot;禁用套件和测试设置和拆卸的预运行修改器。&quot;&quot;&quot;from robot.api import SuiteVisitorclass SuiteSetup(SuiteVisitor): def start_suite(self, suite): suite.setup = Noneclass SuiteTeardown(SuiteVisitor): def start_suite(self, suite): suite.teardown = Noneclass TestSetup(SuiteVisitor): def start_test(self, test): test.setup = Noneclass TestTeardown(SuiteVisitor): def start_test(self, test): test.teardown = None 假设上述修改器都在名为 disable.py 的文件中，并且此文件在模块搜索路径中，可以按以下方式禁用设置和拆卸： 12345# 禁用套件拆卸。robot --prerunmodifier disable.SuiteTeardown tests.robot# 通过两次使用 &#x27;--prerunmodifier&#x27; 来禁用测试设置和拆卸。robot --prerunmodifier disable.TestSetup --prerunmodifier disable.TestTeardown tests.robot 注意 在 Robot Framework 4.0 之前，通过中间关键字属性访问设置和拆卸，例如，套件设置被禁用像 suite.keywords.setup &#x3D; None。 控制控制台输出有多种命令行选项可以控制如何在控制台上报告测试执行情况。 控制台输出类型使用 –console 选项设置整体控制台输出类型。它支持以下不区分大小写的值： verbose：每个测试套件和测试用例都单独报告。这是默认设置。 dotted：只显示 . 表示通过的测试，F 表示失败的测试，s 表示跳过的测试，x 表示因测试执行退出而跳过的测试。执行后，失败的测试会单独列出。此输出类型使得即使有很多测试，也能轻松看到执行过程中是否有任何失败。 quiet：除错误和警告外，没有任何输出。 none：完全没有输出。在创建自定义输出时（例如，使用监听器）很有用。 单独的便利选项 –dotted (-.) 和 –quiet 是 –console dotted 和 –console quiet 的快捷方式。 示例： 12robot --console quiet tests.robotrobot --dotted tests.robot 控制台宽度可以使用 –consolewidth (-W) 选项设置控制台中测试执行输出的宽度。默认宽度为78个字符。 提示 在许多类 UNIX 机器上，可以使用方便的 $COLUMNS 环境变量，如 –consolewidth $COLUMNS。 控制台颜色–consolecolors (-C) 选项用于控制是否应在控制台输出中使用颜色。颜色使用 ANSI 颜色实现，除了在 Windows 上，默认情况下使用 Windows API。 此选项支持以下不区分大小写的值： auto：当输出写入控制台时启用颜色，但当它们被重定向到文件或其他地方时不启用。这是默认设置。 on：当输出被重定向时也使用颜色。在 Windows 上不起作用。 ansi：与 on 相同，但在 Windows 上也使用 ANSI 颜色。例如，当将输出重定向到理解 ANSI 颜色的程序时很有用。 off：禁用颜色。 控制台标记当使用详细输出并在测试用例的顶级关键字结束时，控制台上会显示特殊标记 .（成功）和 F（失败）。标记允许在高级别跟踪测试执行，当测试用例结束时，它们会被擦除。 可以使用 –consolemarkers (-K) 选项配置何时使用标记。它支持以下不区分大小写的值： auto：当标准输出写入控制台时启用标记，但当它被重定向到文件或其他地方时不启用。这是默认设置。 on：始终使用标记。 off：禁用标记。 设置监听器监听器可以用来监视测试执行。当它们从命令行中使用时，它们是使用 –listener 命令行选项指定的。值可以是监听器的路径或监听器的名称。有关导入监听器和一般使用它们的更多详细信息，请参见监听器接口部分。 输出文件当执行测试时，会创建多个输出文件，所有这些文件都与测试结果有关。本节讨论创建哪些输出，如何配置它们的创建位置，以及如何微调它们的内容。 不同的输出文件本节解释可以创建哪些不同的输出文件以及如何配置它们的创建位置。输出文件是使用命令行选项配置的，这些选项获取作为参数的输出文件的路径。可以使用特殊值 NONE（不区分大小写）来禁用创建某个特定的输出文件。 输出目录所有输出文件都可以使用绝对路径设置，在这种情况下，它们将被创建到指定的位置，但在其他情况下，路径被认为是相对于输出目录的。默认的输出目录是开始执行的目录，但可以使用 –outputdir (-d) 选项进行更改。此选项设置的路径再次相对于执行目录，但自然也可以作为绝对路径给出。无论如何获取到单个输出文件的路径，如果其父目录尚不存在，将自动创建。 输出文件输出文件包含所有以机器可读的 XML 格式的测试执行结果。日志、报告和 xUnit 文件通常基于它们生成，并且它们也可以与 Rebot 一起进行组合和其他后处理。 信息 在测试执行的过程中生成报告和 xUnit 文件不需要在执行后处理输出文件。因此，运行测试时禁用日志生成可以节省内存。 命令行选项 –output (-o) 确定相对于输出目录创建输出文件的路径。当运行测试时，输出文件的默认名称是 output.xml。 使用 Rebot 对输出进行后处理时，除非明确使用了 –output 选项，否则不会创建新的输出文件。 在运行测试时，可以通过给 –output 选项赋予特殊值 NONE 来禁用创建输出文件。如果不需要任何输出，那么应该使用 –output NONE –report NONE –log NONE 明确禁用所有输出。 XML 输出文件结构在 robot.xsd 架构文件中有文档记录。 信息 从 Robot Framework 7.0 开始，Rebot 可以读取和写入 JSON 输出文件。计划是在未来增强对 JSON 输出文件的支持，以便它们可以在执行期间就创建。有关更多详细信息，请参阅问题 #3423。 旧版输出文件格式在 Robot Framework 7.0 中，输出文件格式发生了一些向后不兼容的更改。为了使得可以使用新版本的 Robot Framework 与尚未更新以支持新格式的外部工具一起使用，有一个 –legacyoutput 选项，该选项生成与 Robot Framework 6.x 及更早版本兼容的输出文件。Robot Framework 本身可以处理旧格式和新格式的输出文件。 日志文件日志文件以 HTML 格式包含有关执行的测试用例的详细信息。它们具有层次结构，显示测试套件、测试用例和关键字详细信息。几乎每次需要详细调查测试结果时，都需要日志文件。尽管日志文件也有统计信息，但报告更适合获取更高级别的概述。 命令行选项 --log (-l) 确定创建日志文件的位置。除非使用特殊值 NONE，否则总是会创建日志文件，其默认名称为 log.html。 示例日志文件的开始： 示例日志文件，可见关键字详细信息： 示例日志文件，跳过和通过的测试： 报告文件报告文件以 HTML 格式包含测试执行结果的概述。它们基于标签和执行的测试套件有统计信息，以及所有执行的测试用例的列表。当生成报告和日志时，报告有链接到日志文件，以便轻松导航到更详细的信息。从报告中很容易看到整体的测试执行状态，因为如果所有测试都通过，其背景颜色为绿色，如果有任何测试失败，背景颜色为亮红色。背景也可以是黄色，这意味着所有测试都被跳过。 命令行选项 –report (-r) 确定创建报告文件的位置。与日志文件类似，除非使用 NONE 作为值，否则总是会创建报告，其默认名称为 report.html。 成功测试执行的示例报告文件： 失败测试执行的示例报告文件： XUnit 兼容结果文件XUnit 结果文件包含以 XUnit 兼容的 XML 格式的测试执行摘要。因此，这些文件可以作为理解 XUnit 报告的外部工具的输入。例如，Jenkins 持续集成服务器支持基于 XUnit 兼容结果生成统计信息。 提示 Jenkins 还有一个单独的 Robot Framework 插件。 除非明确使用命令行选项 –xunit (-x)，否则不会创建 XUnit 输出文件。此选项需要一个路径作为值，该路径是相对于输出目录的生成的 XUnit 文件。 在 Robot Framework 5.0 中，XUnit 输出文件发生了重大变化。它们现在包含每个套件的单独的 元素， 元素具有时间戳属性，套件文档和元数据存储为 元素。 调试文件调试文件是在测试执行期间编写的纯文本文件。所有从测试库获取的消息都写入它们，以及关于开始和结束的测试套件、测试用例和关键字的信息。调试文件可以用于监视测试执行。这可以使用，例如，一个单独的 fileviewer.py 工具，或者在类 UNIX 系统中，简单地使用 tail -f 命令。 除非明确使用命令行选项 –debugfile (-b)，否则不会创建调试文件。 时间戳输出文件Robot Framework 本身生成的所有输出文件都可以使用选项 –timestampoutputs (-T) 自动添加时间戳。当使用此选项时，将在每个文件的扩展名和基本名称之间放置一个格式为 YYYYMMDD-hhmmss 的时间戳。例如，下面的示例将创建像 output-20080604-163225.xml 和 mylog-20080604-163225.html 这样的输出文件： 1robot --timestampoutputs --log mylog.html --report NONE tests.robot 设置标题日志和报告的默认标题是通过在顶级测试套件的名称前加上 Test Log 或 Test Report 来生成的。可以使用选项 –logtitle 和 –reporttitle 分别从命令行给出自定义标题。 示例： 1robot --logtitle &quot;Smoke Test Log&quot; --reporttitle &quot;Smoke Test Report&quot; --include smoke my_tests/ 注意 在 Robot Framework 3.1 之前，给定标题中的下划线被转换为空格。现在，空格需要像上面的示例那样被转义或引用。 设置背景颜色默认情况下，如果有失败，报告文件的背景为红色，如果有通过的测试和可能跳过的一些测试，背景为绿色，如果所有测试都被跳过或没有运行任何测试，背景为黄色。可以使用 –reportbackground 命令行选项自定义这些颜色，该选项接受两个或三个用冒号分隔的颜色作为参数： 123--reportbackground blue:red--reportbackground blue:red:orange--reportbackground #00E:#E00 如果指定了两种颜色，第一种将替代默认的绿色（通过）颜色，第二种将替代默认的红色（失败）。这允许，例如，使用蓝色代替绿色，使得背景更容易为色盲人士分辨。 如果指定了三种颜色，前两种具有与以前相同的语义，最后一种替换默认的黄色（跳过）颜色。 指定的颜色用作 body 元素的背景 CSS 属性的值。该值按原样使用，可以是 HTML 颜色名称（例如，red）、十六进制值（例如，#f00 或 #ff0000）或 RGB 值（例如，rgb(255,0,0)）。默认的绿色、红色和黄色分别使用十六进制值 #9e9、#f66 和 #fed84f 指定。 ​ 日志级别可用的日志级别日志文件中的消息可以有不同的日志级别。一些消息是由 Robot Framework 本身编写的，但也可以执行关键字以使用不同级别的信息进行记录。可用的日志级别有： FAIL：当关键字失败时使用。只能由 Robot Framework 本身使用。 WARN：用于显示警告。它们也会在控制台和日志文件的测试执行错误部分中显示，但它们不会影响测试用例的状态。 INFO：正常消息的默认级别。默认情况下，此级别以下的消息不会显示在日志文件中。 DEBUG：用于调试目的。例如，对于记录库在内部正在做什么很有用。当关键字失败时，将自动使用此级别记录一个回溯，显示代码中失败发生的位置。 TRACE：更详细的调试级别。关键字参数和返回值会自动使用此级别进行记录。 设置日志级别默认情况下，INFO 级别以下的日志消息不会被记录，但可以使用 –loglevel (-L) 选项从命令行更改此阈值。此选项接受任何可用的日志级别作为参数，该级别成为新的阈值级别。还可以使用特殊值 NONE 来完全禁用日志记录。 也可以在使用 Rebot 对输出进行后处理时使用 –loglevel 选项。这允许，例如，首先使用 TRACE 级别运行测试，然后使用 INFO 级别生成较小的日志文件以供正常查看。默认情况下，执行期间包含的所有消息也将包含在 Rebot 中。执行期间忽略的消息无法恢复。 更改日志级别的另一种可能性是在测试数据中使用 BuiltIn 关键字 Set Log Level。它接受与 –loglevel 选项相同的参数，并且它还返回旧的级别，以便稍后可以恢复，例如，在测试拆卸中。 可见的日志级别如果日志文件包含 DEBUG 或 TRACE 级别的消息，则在右上角显示一个可见的日志级别下拉菜单。这允许用户从视图中移除所选级别以下的消息。这在运行 TRACE 级别的测试时尤其有用。 默认情况下，下拉菜单将设置为日志文件中的最低级别，因此所有消息都会显示。可以使用 –loglevel 选项更改默认的可见日志级别，方法是在正常日志级别后面用冒号给出默认值： 1--loglevel DEBUG:INFO 在上面的示例中，测试使用 DEBUG 级别运行，但日志文件中的默认可见级别是 INFO。 分割日志通常，日志文件只是一个单独的 HTML 文件。当测试用例的数量增加时，文件的大小可能会变得如此大，以至于在浏览器中打开它变得不便或甚至不可能。因此，可以使用 –splitlog 选项将日志的部分内容分割到需要时可以透明地加载到浏览器中的外部文件中。 分割日志的主要好处是，单个日志部分非常小，即使测试数据的数量非常大，也可以打开和浏览日志文件。一个小缺点是日志文件占用的总大小会增加。 从技术上讲，与每个测试用例相关的测试数据被保存到与主日志文件相同的文件夹中的 JavaScript 文件中。这些文件的名称如 log-42.js，其中 log 是主日志文件的基本名称，42 是递增的索引。 注意 在复制日志文件时，需要复制所有的 log-*.js 文件，否则一些信息将会丢失。 配置统计信息有几个命令行选项可以用来配置和调整不同输出文件中的“按标签统计”、“按套件统计”和“按标签详细测试”表格的内容。所有这些选项都在执行测试用例和后处理输出时起作用。 配置显示的套件统计信息当执行更深层次的套件结构时，在“按套件统计”表中显示所有测试套件级别可能会使表格有些难以阅读。默认情况下显示所有套件，但可以使用命令行选项 –suitestatlevel 控制显示的套件级别，该选项接受要显示的套件级别作为参数： 1--suitestatlevel 3 包含和排除标签统计信息当使用许多标签时，“按标签统计”表可能会变得相当拥挤。如果发生这种情况，可以使用命令行选项 –tagstatinclude 和 –tagstatexclude 来选择要显示的标签，类似于使用 –include 和 –exclude 来选择测试用例： 123--tagstatinclude some-tag --tagstatinclude another-tag--tagstatexclude owner-*--tagstatinclude prefix-* --tagstatexclude prefix-13 生成组合标签统计信息命令行选项 –tagstatcombine 可用于生成聚合标签，这些标签将多个标签的统计信息组合在一起。组合标签使用标签模式指定，其中 * 和 ? 作为通配符受支持，AND、OR 和 NOT 运算符可用于将单个标签或模式组合在一起。 以下示例说明了使用不同模式创建组合标签统计信息，下面的图表显示了生成的“按标签统计”表的一部分： 123--tagstatcombine owner-*--tagstatcombine smokeANDmytag--tagstatcombine smokeNOTowner-janne* 如上例所示，默认情况下，添加的组合统计的名称只是给定的模式。如果这还不够好，可以在模式后面用冒号 (:) 分隔给出自定义名称： 1--tagstatcombine &quot;prio1ORprio2:High priority tests&quot; 注意 在 Robot Framework 3.1 之前，自定义名称中的下划线被转换为空格。现在，空格需要像上面的示例那样被转义或引用。 从标签名称创建链接可以使用命令行选项 –tagstatlink 向“按标签统计”表添加外部链接。此选项的参数以 tag:link:name 的格式给出，其中 tag 指定要将链接分配给的标签，link 是要创建的链接，name 是要给链接的名称。 tag 可能是一个单一的标签，但更常见的是一个简单的模式，其中 * 匹配任何内容，? 匹配任何单个字符。当 tag 是一个模式时，可以使用语法 %N 在链接和标题中使用通配符的匹配，其中 “N” 是从 1 开始的匹配索引。 以下示例说明了此选项的使用，下面的图表显示了当使用这些选项执行示例测试数据时，生成的“按标签统计”表的一部分： 123--tagstatlink mytag:http://www.google.com:Google--tagstatlink example-bug-*:http://example.com--tagstatlink owner-*:mailto:%1@domain.com?subject=Acceptance_Tests:Send_Mail 为标签添加文档可以使用命令行选项 –tagdoc 给标签添加文档，该选项接受以 tag:doc 格式的参数。tag 是要分配文档的标签的名称，它也可以是匹配多个标签的简单模式。doc 是分配的文档。它可以包含简单的 HTML 格式。 给定的文档将在“按标签详细测试”表中与匹配的标签一起显示，并作为这些标签在“按标签统计”表中的工具提示显示。如果一个标签获得多个文档，它们将被组合在一起，并用和号分隔。 示例： 123--tagdoc mytag:Example--tagdoc &quot;regression:*See* http://info.html&quot;--tagdoc &quot;owner-*:Original author&quot; 注意 在 Robot Framework 3.1 之前，文档中的下划线被转换为空格。现在，空格需要像上面的示例那样被转义或引用。 移除和展平关键字输出文件的大部分内容来自关键字及其日志消息。当创建更高级别的报告时，可能根本不需要日志文件，此时关键字及其消息只会无谓地占用空间。日志文件本身也可能变得过大，尤其是如果它们包含 FOR 循环或其他重复某些关键字多次的结构。 在这些情况下，可以使用命令行选项 –removekeywords 和 –flattenkeywords 来丢弃或展平不必要的关键字。它们可以在执行测试用例和后处理输出时使用。在执行期间使用时，它们只影响日志文件，而不影响 XML 输出文件。使用 rebot 时，它们会影响日志和可能生成的新的输出 XML 文件。 移除关键字–removekeywords 选项完全移除关键字及其消息。它有以下操作模式，可以多次使用以启用多个模式。包含错误或警告的关键字不会被移除，除非使用 ALL 模式。 ALL：无条件地从所有关键字中移除数据。 PASSED：从通过的测试用例中移除关键字数据。在大多数情况下，使用此选项创建的日志文件包含足够的信息来调查可能的失败。 FOR：除最后一个之外，从 FOR 循环中移除所有通过的迭代。 WHILE：除最后一个之外，从 WHILE 循环中移除所有通过的迭代。 WUKS：除最后一个之外，从 BuiltIn 关键字 Wait Until Keyword Succeeds 中移除所有失败的关键字。 **NAME:**：无论关键字状态如何，都从与给定模式匹配的所有关键字中移除数据。该模式与关键字的全名匹配，前缀为可能的库或资源文件名称，如 MyLibrary.Keyword Name。该模式对大小写、空格和下划线不敏感，并支持使用 *, ? 和 [] 作为通配符的简单模式。 **TAG:**：从标签与给定模式匹配的关键字中移除数据。标签对大小写和空格不敏感，可以使用标签模式指定，其中 *, ? 和 [] 作为通配符受支持，AND、OR 和 NOT 运算符可以用于将单个标签或模式组合在一起。可以同时使用库关键字标签和用户关键字标签。 示例： 1234rebot --removekeywords all --output removed.xml output.xmlrobot --removekeywords passed --removekeywords for tests.robotrobot --removekeywords name:HugeKeyword --removekeywords name:resource.* tests.robotrobot --removekeywords tag:huge tests.robot 移除关键字是在解析输出文件并基于它生成内部模型之后完成的。因此，它并不像展平关键字那样减少内存使用。 展平关键字–flattenkeywords 选项会展平匹配的关键字。实际上，这意味着匹配的关键字会递归地获取其子关键字的所有日志消息，而子关键字则被否则丢弃。展平支持以下模式： FOR：完全展平 FOR 循环。 WHILE：完全展平 WHILE 循环。 ITERATION：展平单个 FOR 和 WHILE 循环的迭代。 FORITEM：ITERATION 的已弃用别名。 **NAME:**：展平与给定模式匹配的关键字。模式匹配规则与使用 NAME: 模式移除关键字时相同。 **TAG:**：展平标签与给定模式匹配的关键字。模式匹配规则与使用 TAG: 模式移除关键字时相同。 示例： 12robot --flattenkeywords name:HugeKeyword --flattenkeywords name:resource.* tests.robotrebot --flattenkeywords foritem --output flattened.xml original.xml 展平关键字是在最初解析输出文件并基于它生成内部模型时完成的。这可以节省大量的内存，尤其是在关键字结构深度嵌套的情况下。 在执行时间内展平关键字从 Robot Framework 6.1 开始，可以在执行时间内启用关键字展平。这只能在用户关键字级别上通过定义保留标签 robot:flatten 作为关键字标签来完成。使用此标签的工作方式与前一章中描述的命令行选项类似，例如，除日志消息外，所有内容都从具有该标签的关键字下移除。一个重要的区别是，在这种情况下，移除的内容根本不会写入输出文件，因此无法在以后的时间内访问。 一些示例 1234567891011*** Keywords ***Flattening affects this keyword and all it&#x27;s children [Tags] robot:flatten Log something FOR $&#123;i&#125; IN RANGE 2 Log The message is preserved but for loop iteration is not END*** Settings ***# Flatten content of all uer keywordsKeyword Tags robot:flatten ​ 自动展开关键字默认情况下，通过的关键字在日志文件中是关闭的。因此，除非展开它们，否则它们包含的信息不可见。如果某些关键字有重要的信息，应在打开日志文件时可见，可以使用 –expandkeywords 选项将关键字设置为在日志文件中自动展开，类似于失败的关键字。展开支持以下模式： **NAME:**：展开与给定模式匹配的关键字。模式匹配规则与使用 NAME: 模式移除关键字时相同。 **TAG:**：展开标签与给定模式匹配的关键字。模式匹配规则与使用 TAG: 模式移除关键字时相同。 如果需要展开匹配不同名称或模式的关键字，可以多次使用 –expandkeywords。 示例： 12robot --expandkeywords name:SeleniumLibrary.CapturePageScreenshot tests.robotrebot --expandkeywords tag:example --expandkeywords tag:another output.xml 注意 –expandkeywords 选项是在 Robot Framework 3.2 中新增的。 设置执行的开始和结束时间当使用 Rebot 合并输出时，可以使用选项 –starttime 和 –endtime 分别设置合并测试套件的开始和结束时间。这很方便，因为默认情况下，合并的套件没有这些值。当给出开始和结束时间时，也会根据它们计算经过的时间。否则，经过的时间是通过将子测试套件的经过时间加在一起得到的。 也可以使用上述选项在使用 Rebot 时为单个套件设置开始和结束时间。对单个输出使用这些选项总是会影响套件的经过时间。 时间必须以时间戳的格式给出，格式为 YYYY-MM-DD hh:mm:ss.mil，其中所有分隔符都是可选的，可以省略从毫秒到小时的部分。例如，2008-06-11 17:59:20.495 等同于 20080611-175920.495 和 20080611175920495，而仅仅是 20080611 也可以工作。 示例： 123rebot --starttime 20080611-17:59:20.495 output1.xml output2.xmlrebot --starttime 20080611-175920 --endtime 20080611-180242 *.xmlrebot --starttime 20110302-1317 --endtime 20110302-11418 myoutput.xml 限制报告中错误消息的长度如果一个测试用例失败并且有一个长的错误消息，报告中显示的消息会自动从中间剪切，以保持报告更易于阅读。默认情况下，超过 40 行的消息会被剪切，但可以使用 –maxerrorlines 命令行选项进行配置。此选项的最小值为 10，也可以使用特殊值 NONE 来显示完整的消息。 完整的错误消息始终作为失败关键字的消息在日志文件中可见。 注意 –maxerrorlines 选项是在 Robot Framework 3.1 中新增的。 编程修改结果如果提供的内置功能不足以修改结果，Robot Framework 使得可以通过编程方式进行自定义修改。这是通过创建一个模型修改器并使用 –prerebotmodifier 选项激活它来实现的。 此功能几乎完全像可以使用 –prerunmodifier 选项启用的测试数据的编程修改一样工作。明显的区别是这次修改器操作的是结果模型，而不是运行模型。例如，以下修改器将所有超过允许时间的通过测试标记为失败： 1234567891011from robot.api import SuiteVisitorclass ExecutionTimeChecker(SuiteVisitor): def __init__(self, max_seconds: float): self.max_milliseconds = max_seconds * 1000 def visit_test(self, test): if test.status == &#x27;PASS&#x27; and test.elapsedtime &gt; self.max_milliseconds: test.status = &#x27;FAIL&#x27; test.message = &#x27;Test execution took too long.&#x27; 如果上述修改器位于 ExecutionTimeChecker.py 文件中，例如可以这样使用它： 123456# 在运行测试时指定修改器作为路径。最大时间是42秒。robot --prerebotmodifier path/to/ExecutionTimeChecker.py:42 tests.robot# 在使用 Rebot 时以名称指定修改器。最大时间是3.14秒。# ExecutionTimeChecker.py 必须在模块搜索路径中。rebot --prerebotmodifier ExecutionTimeChecker:3.14 output.xml 如果需要多个模型修改器，可以通过多次使用 –prerebotmodifier 选项来指定它们。在执行测试时，可以同时使用 –prerunmodifier 和 –prerebotmodifier 选项。 注意 基于类型提示（如上例中的 max_seconds: float）的参数转换是在 Robot Framework 4.0 中新增的，并且需要 Python 3。 系统日志Robot Framework 有自己的纯文本系统日志，其中写入了关于以下信息： 处理和跳过的测试数据文件 导入的测试库、资源文件和变量文件 执行的测试套件和测试用例 创建的输出 通常，用户永远不需要这些信息，但在调查测试库或 Robot Framework 本身的问题时，它可能会有用。默认情况下不会创建系统日志，但可以通过设置环境变量 ROBOT_SYSLOG_FILE 以包含所选文件的路径来启用它。 系统日志具有与普通日志文件相同的日志级别，但除了 FAIL，它具有 ERROR 级别。可以使用 ROBOT_SYSLOG_LEVEL 环境变量更改要使用的阈值级别，如下例所示。可能的意外错误和警告除了在控制台和普通日志文件中写入外，还写入系统日志。 123456#!/bin/bashexport ROBOT_SYSLOG_FILE=/tmp/syslog.txtexport ROBOT_SYSLOG_LEVEL=DEBUGrobot --name Syslog_example path/to/tests ​ 扩展 Robot Framework创建测试库Robot Framework 的实际测试能力由测试库提供。有许多现有的库，其中一些甚至与核心框架捆绑在一起，但仍然经常需要创建新的库。这项任务并不复杂，因为如本章所示，Robot Framework 的库 API 是简单直接的。 介绍支持的编程语言Robot Framework 本身是用 Python 编写的，自然地，扩展它的测试库可以使用相同的语言实现。也可以使用 Python C API 用 C 实现库，尽管通常使用 ctypes 模块从 Python 库与 C 代码交互更容易。 使用 Python 实现的库也可以作为包装器来实现使用其他编程语言实现的功能。这种方法的一个好例子是 Remote 库，另一个广泛使用的方法是作为单独的进程运行外部脚本或工具。 不同的测试库 APIRobot Framework 有三种不同的测试库 API。 静态 API：最简单的方法是拥有直接映射到关键字名称的函数&#x2F;方法的模块或类。关键字也接受与实现它们的方法相同的参数。关键字通过异常报告失败，通过写入标准输出进行日志记录，并可以使用 return 语句返回值。 动态 API：动态库是实现一个方法以获取它们实现的关键字的名称，以及另一个方法以给定的参数执行一个命名的关键字的类。关键字的名称以及如何执行它们可以在运行时动态确定，但报告状态、日志记录和返回值的方式与静态 API 中的方式相同。 混合 API：这是静态 API 和动态 API 之间的混合。库是具有告知它们实现了哪些关键字的方法的类，但这些关键字必须直接可用。除了发现实现了哪些关键字之外，其他所有事情都与静态 API 相似。 本章将描述所有这些 API。一切都基于静态 API 的工作方式，因此首先讨论其功能。然后在各自的部分中讨论动态库 API 和混合库 API 与其的区别。 创建测试库类或模块测试库可以实现为 Python 模块或类。 库名称当导入库时使用的测试库的名称与实现它的模块或类的名称相同。例如，如果有一个 Python 模块 MyLibrary（即，文件 MyLibrary.py），它将创建一个名为 MyLibrary 的库。 Python 类总是在模块内部。如果实现库的类的名称与模块的名称相同，Robot Framework 允许在导入库时省略类名。例如，MyLib.py 文件中的类 MyLib 可以仅用名为 MyLib 的库。这也适用于子模块，因此，例如，如果 parent.MyLib 模块有类 MyLib，那么只使用 parent.MyLib 导入它就可以了。如果模块名称和类名称不同，必须使用模块和类名称来使用库，例如 mymodule.MyLibrary 或 parent.submodule.MyLib。 信息 如果库名称真的很长，建议使用 AS 给库一个更简单的别名。 提供库的参数所有作为类实现的测试库都可以接受参数。这些参数在库名称后的 Setting 部分中指定，当 Robot Framework 创建导入库的实例时，它将它们传递给其构造函数。作为模块实现的库不能接受任何参数，因此尝试使用这些结果会出错。 库所需的参数数量与库的构造函数接受的参数数量相同。默认值和变量参数的数量与关键字参数的工作方式类似。传递给库的参数，以及库名称本身，可以使用变量指定，因此可以例如从命令行更改它们。 123*** Settings ***Library MyLibrary 10.0.0.1 8080Library AnotherLib $&#123;VAR&#125; 用于上述示例的库的示例实现： 12345678910111213141516171819from example import Connectionclass MyLibrary: def __init__(self, host, port=80): self._conn = Connection(host, int(port)) def send_message(self, message): self._conn.send(message)class AnotherLib: def __init__(self, environment): self.environment = environment def do_something(self): if self.environment == &#x27;test&#x27;: # 在测试环境中做一些事情 else: # 在其他环境中做一些事情 ​ 库范围作为类实现的库可以有一个内部状态，可以通过关键字和库的构造函数的参数来改变。因为状态可以影响关键字的实际行为，所以确保一个测试用例中的更改不会意外地影响其他测试用例是很重要的。这种类型的依赖关系可能会创建难以调试的问题，例如，当添加新的测试用例并且它们不一致地使用库时。 Robot Framework 尝试保持测试用例彼此独立：默认情况下，它为每个测试用例创建新的测试库实例。然而，这种行为并不总是可取的，因为有时测试用例应该能够共享一个公共状态。此外，并非所有的库都有状态，创建它们的新实例根本就不需要。 测试库可以使用类属性 ROBOT_LIBRARY_SCOPE 控制何时创建新的库。此属性必须是一个字符串，可以有以下三个值： TEST：为每个测试用例创建一个新实例。可能的套件设置和套件拆卸共享另一个实例。 在 Robot Framework 3.2 之前，此值为 TEST CASE，但现在推荐使用 TEST。因为所有无法识别的值都被视为与 TEST 相同，所以两个值在所有版本中都可以工作。出于同样的原因，如果库更多地针对 RPA 使用而不是测试，也可以使用 TASK 值。如果未设置 ROBOT_LIBRARY_SCOPE 属性，TEST 也是默认值。 SUITE：为每个测试套件创建一个新实例。最低级别的测试套件（从测试用例文件创建并包含测试用例）有自己的实例，更高级别的套件都有自己的实例，用于可能的设置和拆卸。 在 Robot Framework 3.2 之前，此值为 TEST SUITE。该值仍然有效，但推荐使用 SUITE，适用于针对 Robot Framework 3.2 及更高版本的库。 GLOBAL：在整个测试执行过程中只创建一个实例，并由所有测试用例和测试套件共享。从模块创建的库始终是全局的。 注意 如果一个库被多次导入并带有不同的参数，那么无论范围如何，每次都会创建一个新实例。 当使用具有状态的库使用 SUITE 或 GLOBAL 范围时，建议库有一些特殊的关键字用于清理状态。然后，这个关键字可以在套件设置或拆卸中使用，以确保下一个测试套件中的测试用例可以从已知状态开始。例如，SeleniumLibrary 使用 GLOBAL 范围来启用在不同的测试用例中使用相同的浏览器，而无需重新打开它，它还有 Close All Browsers 关键字用于轻松关闭所有打开的浏览器。 使用 SUITE 范围的示例库： 123456789101112class ExampleLibrary: ROBOT_LIBRARY_SCOPE = &#x27;SUITE&#x27; def __init__(self): self._counter = 0 def count(self): self._counter += 1 print(self._counter) def clear_counter(self): self._counter = 0 库版本当一个测试库被使用时，Robot Framework 尝试确定其版本。然后，这些信息被写入系统日志以提供调试信息。库文档工具 Libdoc 也将这些信息写入它生成的关键字文档。 版本信息是从属性 ROBOT_LIBRARY_VERSION 中读取的，就像从 ROBOT_LIBRARY_SCOPE 中读取库范围一样。如果 ROBOT_LIBRARY_VERSION 不存在，将尝试从 version 属性中读取信息。这些属性必须是类或模块属性，取决于库是作为类还是模块实现的。 使用 version 的示例模块： 1234__version__ = &#x27;0.1&#x27;def keyword(): pass ​ 文档格式库文档工具 Libdoc 支持多种格式的文档。如果想使用除 Robot Framework 自己的文档格式以外的其他格式，可以在源代码中使用 ROBOT_LIBRARY_DOC_FORMAT 属性指定格式，就像使用自己的 ROBOT_LIBRARY_* 属性设置范围和版本一样。 文档格式的可能值（不区分大小写）为 ROBOT（默认）、HTML、TEXT（纯文本）和 reST（reStructuredText）。使用 reST 格式需要在生成文档时安装 docutils 模块。 以下示例说明了如何设置使用 reStructuredText 格式的文档格式。有关一般性地记录测试库的更多信息，请参见文档库部分和 Libdoc 章节。 1234567891011121314151617181920&quot;&quot;&quot;一个用于*文档格式*演示目的的库。此文档是使用 reStructuredText__ 创建的。这里有一个链接到唯一的\\`Keyword\\`。__ http://docutils.sourceforge.net&quot;&quot;&quot;ROBOT_LIBRARY_DOC_FORMAT = &#x27;reST&#x27;def keyword(): &quot;&quot;&quot;**这里什么都没有**。甚至下面的表格也没有。 ======= ===== ===== Table here has nothing to see. ======= ===== ===== &quot;&quot;&quot; pass 库充当监听器监听器接口允许外部监听器获取关于测试执行的通知。例如，当套件、测试和关键字开始和结束时，它们会被调用。有时，获取这样的通知对于测试库也是有用的，它们可以使用 ROBOT_LIBRARY_LISTENER 属性注册一个自定义监听器。此属性的值应为要使用的监听器的实例，可能是库本身。 有关更多信息和示例，请参见 Libraries as listeners 部分。 @library 装饰器配置作为类实现的库的一种简单方法是使用 robot.api.deco.library 类装饰器。它允许使用可选参数 scope、version、converter、doc_format 和 listener 分别配置库的范围、版本、自定义参数转换器、文档格式和监听器。当使用这些参数时，它们会自动设置匹配的 ROBOT_LIBRARY_SCOPE、ROBOT_LIBRARY_VERSION、ROBOT_LIBRARY_CONVERTERS、ROBOT_LIBRARY_DOC_FORMAT 和 ROBOT_LIBRARY_LISTENER 属性： 12345678from robot.api.deco import libraryfrom example import Listener@library(scope=&#x27;GLOBAL&#x27;, version=&#x27;3.2b1&#x27;, doc_format=&#x27;reST&#x27;, listener=Listener())class Example: # ... @library 装饰器还通过默认将 ROBOT_AUTO_KEYWORDS 参数设置为 False 来禁用自动关键字发现。这意味着必须使用 @keyword 装饰器装饰方法以将它们公开为关键字。如果只需要那种行为并且不需要进一步的配置，装饰器也可以像这样不带括号使用： 123456from robot.api.deco import library@libraryclass Example: # ... 如果需要，可以使用 auto_keywords 参数启用自动关键字发现： 123456from robot.api.deco import library@library(scope=&#x27;GLOBAL&#x27;, auto_keywords=True)class Example: # ... @library 装饰器只有在使用相应的参数 scope、version、converters、doc_format 和 listener 时才设置类属性 ROBOT_LIBRARY_SCOPE、ROBOT_LIBRARY_VERSION、ROBOT_LIBRARY_CONVERTERS、ROBOT_LIBRARY_DOC_FORMAT 和 ROBOT_LIBRARY_LISTENER。ROBOT_AUTO_KEYWORDS 属性始终被设置。当设置属性时，它们会覆盖可能存在的类属性。 注意 @library 装饰器是在 Robot Framework 3.2 中新增的，converters 参数是在 Robot Framework 5.0 中新增的。 创建关键字哪些方法被视为关键字当使用静态库 API 时，Robot Framework 使用内省来找出库类或模块实现了哪些关键字。默认情况下，它排除了以下划线开头的方法和函数。所有未被忽略的方法和函数都被视为关键字。例如，下面的库实现了一个名为 My Keyword 的关键字。 1234567class MyLibrary: def my_keyword(self, arg): return self._helper_method(arg) def _helper_method(self, arg): return arg.upper() 限制公共方法成为关键字通常，自动将所有公共方法和函数视为关键字工作得很好，但有些情况下这是不希望的。还有一些情况下，当没有预期时会创建关键字。例如，当以类实现库时，可能会惊讶地发现可能的基类中的方法也被视为关键字。当以模块实现库时，导入到模块命名空间的函数变成关键字可能会更令人惊讶。 本节解释如何防止方法和函数成为关键字。 基于类的库当库以类的形式实现时，可以通过将 ROBOT_AUTO_KEYWORDS 属性设置为具有 false 值的类，告诉 Robot Framework 不要自动将方法公开为关键字： 12class Example: ROBOT_AUTO_KEYWORDS = False 当像这样设置 ROBOT_AUTO_KEYWORDS 属性时，只有明确用 @keyword 装饰器装饰的方法或者具有 robot_name 属性的方法才会成为关键字。@keyword 装饰器也可以用于为关键字设置自定义名称、标签和参数类型。 尽管可以显式地将 ROBOT_AUTO_KEYWORDS 属性设置为类，但使用 @library 装饰器将其默认设置为 False 更方便： 12345678910111213141516from robot.api.deco import keyword, library@libraryclass Example: @keyword def this_is_keyword(self): pass @keyword(&#x27;This is keyword with custom name&#x27;) def xxx(self): pass def this_is_not_keyword(self): pass 注意 使用 ROBOT_AUTO_KEYWORDS 属性和 @library 装饰器限制哪些方法成为关键字是在 Robot Framework 3.2 中新增的。 另一种明确指定库实现了哪些关键字的方法是使用动态或混合库 API。 基于模块的库当以模块的形式实现库时，模块命名空间中的所有函数都会成为关键字。这也适用于导入的函数，这可能会引起令人不悦的惊喜。例如，如果下面的模块被用作库，它将包含一个预期的关键字 Example Keyword，但也会包含一个关键字 Current Thread。 12345from threading import current_threaddef example_keyword(): print(&#x27;Running in thread &quot;%s&quot;.&#x27; % current_thread().name) 避免导入的函数成为关键字的一种简单方法是只导入模块（例如，import threading）并通过模块使用函数（例如 threading.current_thread()）。或者，可以在导入时给函数一个以下划线开头的别名（例如，from threading import current_thread as _current_thread）。 限制哪些函数成为关键字的更明确的方法是使用 Python 本身用于类似目的的模块级别的 all 属性。如果使用它，只有列出的函数可以是关键字。例如，下面的库只实现了一个关键字 Example Keyword： 1234567891011from threading import current_thread__all__ = [&#x27;example_keyword&#x27;]def example_keyword(): print(&#x27;Running in thread &quot;%s&quot;.&#x27; % current_thread().name)def this_is_not_keyword(): pass 如果库很大，当添加、删除或重命名关键字时，维护 all 属性可能是一项相当大的任务。另一种明确标记哪些函数是关键字的方法是使用 ROBOT_AUTO_KEYWORDS 属性，就像它可以用于基于类的库一样。当此属性设置为 false 值时，只有明确用 @keyword 装饰器装饰的函数才会成为关键字。例如，这个库也只实现了一个关键字 Example Keyword： 1234567891011121314from threading import current_threadfrom robot.api.deco import keywordROBOT_AUTO_KEYWORDS = False@keyworddef example_keyword(): print(&#x27;Running in thread &quot;%s&quot;.&#x27; % current_thread().name)def this_is_not_keyword(): pass 注意 使用 ROBOT_AUTO_KEYWORDS 限制哪些函数成为关键字是 Robot Framework 3.2 中的新功能。 使用 @not_keyword 装饰器可以使用 @not_keyword 装饰器显式地将模块中的函数和类中的方法标记为“非关键字”。当库以模块的形式实现时，这个装饰器也可以用来避免导入的函数成为关键字。 1234567891011121314from threading import current_threadfrom robot.api.deco import not_keywordnot_keyword(current_thread) # Don&#x27;t expose `current_thread` as a keyword.def example_keyword(): print(&#x27;Running in thread &quot;%s&quot;.&#x27; % current_thread().name)@not_keyworddef this_is_not_keyword(): pass 使用 @not_keyword 装饰器避免函数或方法成为关键字的方式几乎与使用 @library 装饰器禁用自动关键字发现或将 ROBOT_AUTO_KEYWORDS 设置为 false 值的方式相反。使用哪一个取决于上下文。 注意 @not_keyword 装饰器是 Robot Framework 3.2 中的新功能。 关键字名称在测试数据中使用的关键字名称与方法名称进行比较，以找到实现这些关键字的方法。名称比较不区分大小写，也忽略空格和下划线。例如，方法 hello 映射到关键字名称 Hello、hello 或甚至 h e l l o。同样，do_nothing 和 doNothing 方法都可以在测试数据中用作 Do Nothing 关键字。 以下是以模块形式实现的示例库 MyLibrary.py 文件： 12345def hello(name): print(&quot;Hello, %s!&quot; % name)def do_nothing(): pass 下面的示例说明了如何使用上面的示例库。如果想自己试试，确保库在模块搜索路径中。 1234567*** Settings ***Library MyLibrary*** Test Cases ***My Test Do Nothing Hello world 设置自定义名称可以为关键字公开一个不同的名称，而不是默认的关键字名称，该名称映射到方法名称。这可以通过将方法的 robot_name 属性设置为所需的自定义名称来实现： 1234def login(username, password): # ...login.robot_name = &#x27;Login via user panel&#x27; *** Test Cases *** My Test Login Via User Panel {username}username{password} 与上述示例中显式设置 robot_name 属性不同，通常最容易使用 @keyword 装饰器： 123456from robot.api.deco import keyword@keyword(&#x27;Login via user panel&#x27;)def login(username, password): # ... 如果没有参数使用此装饰器，将对公开的关键字名称没有影响，但仍会设置 robot_name 属性。这允许标记方法以公开为关键字，而实际上不改变关键字名称。具有 robot_name 属性的方法也会创建关键字，即使方法名称本身以下划线开头。 设置自定义关键字名称还可以启用库关键字使用嵌入式参数语法接受参数。 关键字标签库关键字和用户关键字可以有标签。库关键字可以通过在方法上设置 robot_tags 属性为所需标签的列表来定义它们。与设置自定义名称一样，最容易使用 @keyword 装饰器设置此属性： 12345678910from robot.api.deco import keyword@keyword(tags=[&#x27;tag1&#x27;, &#x27;tag2&#x27;])def login(username, password): # ...@keyword(&#x27;Custom name&#x27;, [&#x27;tags&#x27;, &#x27;here&#x27;])def another_example(): # ... 设置标签的另一种选项是在关键字文档的最后一行使用 Tags: 前缀并用逗号分隔给出它们。例如： 123456def login(username, password): &quot;&quot;&quot;Log user in to SUT. Tags: tag1, tag2 &quot;&quot;&quot; # ... 关键字参数对于静态和混合 API，关键字需要多少个参数的信息直接从实现它的方法中获取。使用动态库 API 的库有其他方式来共享这些信息，因此这一部分对它们来说并不相关。 最常见也是最简单的情况是，关键字需要确切的参数数量。在这种情况下，方法只需接受确切的那些参数。例如，实现没有参数的关键字的方法也不接受参数，实现一个参数的关键字的方法也接受一个参数，依此类推。 示例关键字接受不同数量的参数： 12345678def no_arguments(): print(&quot;Keyword got no arguments.&quot;)def one_argument(arg): print(&quot;Keyword got one argument &#x27;%s&#x27;.&quot; % arg)def three_arguments(a1, a2, a3): print(&quot;Keyword got three arguments &#x27;%s&#x27;, &#x27;%s&#x27; and &#x27;%s&#x27;.&quot; % (a1, a2, a3)) ​ 关键字的默认值关键字的某些参数具有默认值通常是很有用的。 在 Python 中，一个方法总是有且只有一个实现，可能的默认值在方法签名中指定。下面的语法对所有 Python 程序员来说都是熟悉的： 12345def one_default(arg=&#x27;default&#x27;): print(&quot;Argument has value %s&quot; % arg)def multiple_defaults(arg1, arg2=&#x27;default 1&#x27;, arg3=&#x27;default 2&#x27;): print(&quot;Got arguments %s, %s and %s&quot; % (arg1, arg2, arg3)) 上面的第一个示例关键字可以使用零个或一个参数。如果没有给出参数，arg 将获得值 default。如果有一个参数，arg 将获得该值，如果使用超过一个参数调用关键字将失败。在第二个示例中，总是需要一个参数，但第二个和第三个参数有默认值，所以可以使用一个到三个参数的关键字。 1234567*** Test Cases ***Defaults One Default One Default argument Multiple Defaults required arg Multiple Defaults required arg optional Multiple Defaults required arg optional 1 optional 2 变量数量的参数（*varargs）Robot Framework 也支持接受任意数量参数的关键字。 Python 支持接受任意数量参数的方法。相同的语法在库中也适用，如下面的示例所示，它还可以与指定参数的其他方式结合使用： 12345678910111213141516171819202122def any_arguments(*args): print(&quot;Got arguments:&quot;) for arg in args: print(arg)def one_required(required, *others): print(&quot;Required: %s\\nOthers:&quot; % required) for arg in others: print(arg)def also_defaults(req, def1=&quot;default 1&quot;, def2=&quot;default 2&quot;, *rest): print(req, def1, def2, rest)*** Test Cases ***Varargs Any Arguments Any Arguments argument Any Arguments arg 1 arg 2 arg 3 arg 4 arg 5 One Required required arg One Required required arg another arg yet another Also Defaults required Also Defaults required these two have defaults Also Defaults 1 2 3 4 5 6 自由关键字参数（**kwargs）Robot Framework 支持 Python 的 **kwargs 语法。如何使用接受自由关键字参数（也称为自由命名参数）的关键字在创建测试用例部分进行了讨论。在这一部分，将看看如何创建这样的关键字。 如果已经熟悉 Python 中 kwargs 的工作方式，那么理解它们如何在 Robot Framework 测试库中工作就相当简单。下面的示例展示了基本功能： 1234567def example_keyword(**stuff): for name, value in stuff.items(): print(name, value)*** Test Cases ***Keyword Arguments Example Keyword hello=world # Logs &#x27;hello world&#x27;. Example Keyword foo=1 bar=42 # Logs &#x27;foo 1&#x27; and &#x27;bar 42&#x27;. 基本上，关键字调用末尾使用 name&#x3D;value 语法的所有参数，以及不匹配任何其他参数的参数，都作为 kwargs 传递给关键字。为了避免像 foo&#x3D;quux 这样的字面值作为自由关键字参数，必须像 foo&#x3D;quux 这样进行转义。 下面的示例说明了普通参数、varargs 和 kwargs 是如何一起工作的： 123456789101112131415161718192021222324def various_args(arg=None, *varargs, **kwargs): if arg is not None: print(&#x27;arg:&#x27;, arg) for value in varargs: print(&#x27;vararg:&#x27;, value) for name, value in sorted(kwargs.items()): print(&#x27;kwarg:&#x27;, name, value)*** Test Cases ***Positional Various Args hello world # Logs &#x27;arg: hello&#x27; and &#x27;vararg: world&#x27;.Named Various Args arg=value # Logs &#x27;arg: value&#x27;.Kwargs Various Args a=1 b=2 c=3 # Logs &#x27;kwarg: a 1&#x27;, &#x27;kwarg: b 2&#x27; and &#x27;kwarg: c 3&#x27;. Various Args c=3 a=1 b=2 # Same as above. Order does not matter.Positional and kwargs Various Args 1 2 kw=3 # Logs &#x27;arg: 1&#x27;, &#x27;vararg: 2&#x27; and &#x27;kwarg: kw 3&#x27;.Named and kwargs Various Args arg=value hello=world # Logs &#x27;arg: value&#x27; and &#x27;kwarg: hello world&#x27;. Various Args hello=world arg=value # Same as above. Order does not matter. 有关使用与上述示例完全相同的签名的真实世界示例，请参见 Process 库中的 Run Process 和 Start Keyword 关键字。 仅关键字参数从 Robot Framework 3.1 开始，可以在不同的关键字中使用仅命名参数。这种支持是由 Python 的仅关键字参数提供的。仅关键字参数在可能的 *varargs 之后或在不需要 *varargs 时在专用的 * 标记之后指定。可能的 **kwargs 在仅关键字参数之后指定。 示例： 123456789101112131415def sort_words(*words, case_sensitive=False): key = str.lower if case_sensitive else None return sorted(words, key=key)def strip_spaces(word, *, left=True, right=True): if left: word = word.lstrip() if right: word = word.rstrip() return word*** Test Cases ***Example Sort Words Foo bar baZ Sort Words Foo bar baZ case_sensitive=True Strip Spaces $&#123;word&#125; left=False 仅位置参数Python 支持所谓的仅位置参数，使得可以指定一个参数只能作为位置参数给出，而不能像 name&#x3D;value 那样作为命名参数给出。仅位置参数在普通参数之前指定，并且在它们之后必须使用特殊的 &#x2F; 标记： 12def keyword(posonly, /, normal): print(f&quot;Got positional-only argument &#123;posonly&#125; and normal argument &#123;normal&#125;.&quot;) 上述关键字可以像这样使用： 123456*** Test Cases ***Example # 仅位置参数和普通参数作为位置参数使用。 Keyword foo bar # 普通参数也可以命名。 Keyword foo normal=bar 如果一个仅位置参数使用了一个包含等号的值，如 example&#x3D;usage，即使等号前的部分与参数名称匹配，也不会被认为是命名参数语法。然而，这个规则只适用于在没有其他参数在它之前使用命名参数语法的情况下，仅位置参数在其正确位置使用。 123456*** Test Cases ***Example # 在这种情况下，仅位置参数获取字面值 `posonly=foo`。 Keyword posonly=foo normal=bar # 这将失败。 Keyword normal=bar posonly=foo 从 Robot Framework 4.0 开始，完全支持仅位置参数。在早期版本中，也可以将它们作为位置参数使用，但将它们作为命名参数使用会在 Python 端引发错误。 参数转换默认情况下，定义在 Robot Framework 测试数据中的参数作为 Unicode 字符串传递给关键字。然而，也有几种使用非字符串值的方法： 变量可以包含任何类型的对象作为值，作为参数的变量按原样传递给关键字。 关键字本身可以将它们接受的参数转换为其他类型。 可以使用函数注解或 @keyword 装饰器显式指定参数类型。在这些情况下，Robot Framework 会自动转换参数。 也会根据关键字默认值进行自动转换。 库可以注册自定义参数转换器。 基于函数注解、使用 @keyword 装饰器指定的类型以及参数默认值的自动参数转换都是 Robot Framework 3.1 中的新功能。支持的转换部分指定了在这些情况下支持哪些参数转换。 在 Robot Framework 4.0 之前，只有当给定的参数是字符串时才进行自动转换。现在，无论参数类型如何，都会进行转换。 手动参数转换如果没有向 Robot Framework 指定类型信息，所有未作为变量传递的参数都作为 Unicode 字符串给出。这包括以下情况： 123*** Test Cases ***Example Example Keyword 42 False 关键字内部总是可以转换作为字符串传递的参数。在简单的情况下，这意味着使用 int() 或 float() 将参数转换为数字，但也可能进行其他类型的转换。在处理布尔值时，必须小心，因为所有非空字符串，包括字符串 False，都被 Python 视为真。Robot Framework 自己的 robot.utils.is_truthy() 实用程序很好地处理了这个问题，因为它将像 FALSE、NO 和 NONE（不区分大小写）这样的字符串视为假： 1234567from robot.utils import is_truthydef example_keyword(count, case_insensitive): count = int(count) if is_truthy(case_insensitive): # ... 关键字还可以通过 robot.api.TypeInfo 类及其 convert 方法使用 Robot Framework 的参数转换功能。如果需要的转换逻辑更复杂，或者需要比简单使用 int() 提供的更好的错误报告，这可能会很有用。 1234567from robot.api import TypeInfodef example_keyword(count, case_insensitive): count = TypeInfo.from_type(int).convert(count) if TypeInfo.from_type(bool).convert(case_insensitive): # ... 信息 通常建议使用类型提示或其他方式指定类型，并让 Robot Framework 自动处理参数转换。只有在特殊情况下才需要手动参数转换。 注意 robot.api.TypeInfo 是在 Robot Framework 7.0 中新增的。 使用函数注解指定参数类型从 Robot Framework 3.1 开始，如果可用参数类型信息并且类型被识别，传递给关键字的参数将自动转换。指定类型的最自然方式是使用 Python 函数注解。例如，前面的示例中的关键字可以如下实现，参数将自动转换： 123def example_keyword(count: int, case_insensitive: bool = True): if case_insensitive: # ... 请参阅下面的支持的转换部分，了解自动转换的类型列表以及这些类型接受的值。如果一个具有支持类型之一的参数给出了无法转换的值，那么这是一个错误。只注解一部分参数是可以的。 用其他类型注解参数不是错误，也可以使用注解进行其他类型的操作。在这些情况下不进行转换，但注解仍然显示在由 Libdoc 生成的文档中。 关键字也可以有返回类型注解，使用签名末尾的 -&gt; 符号指定，如 def example() -&gt; int:。这个信息在执行过程中不用于任何事情，但从 Robot Framework 7.0 开始，它由 Libdoc 显示用于文档目的。 使用 @keyword 装饰器指定参数类型指定显式参数类型的另一种方式是使用 @keyword 装饰器。从 Robot Framework 3.1 开始，它接受一个可选的 types 参数，可以用来以字典的形式指定参数类型，将参数名称映射到类型，或者以列表的形式基于位置映射参数到类型。下面的示例展示了实现与前面示例中相同的关键字的这些方法： 123456789101112from robot.api.deco import keyword@keyword(types=&#123;&#x27;count&#x27;: int, &#x27;case_insensitive&#x27;: bool&#125;)def example_keyword(count, case_insensitive=True): if case_insensitive: # ...@keyword(types=[int, bool])def example_keyword(count, case_insensitive=True): if case_insensitive: # ... 无论使用哪种方法，都不必为所有参数指定类型。当以列表形式指定类型时，可以使用 None 标记某个参数没有类型信息，并且可以完全省略末尾的参数。例如，这两个关键字都只为第二个参数指定了类型： 1234567@keyword(types=&#123;&#x27;second&#x27;: float&#125;)def example1(first, second, third): # ...@keyword(types=[None, float])def example2(first, second, third): # ... 从 Robot Framework 7.0 开始，可以通过在类型字典中使用键 ‘return’ 和适当的类型来指定关键字返回类型。这个信息在执行过程中不用于任何事情，但它由 Libdoc 显示用于文档目的。 如果使用 @keyword 装饰器指定了任何类型，那么该关键字从注解中获取的类型信息将被忽略。像 @keyword(types&#x3D;None) 这样设置类型为 None 将完全禁用类型转换，因此也会忽略从默认值获取的类型信息。 基于默认值的隐式参数类型如果没有使用注解或 @keyword 装饰器显式获取类型信息，Robot Framework 3.1 及更高版本会尝试基于可能的参数默认值获取它。在这个示例中，count 和 case_insensitive 分别获取类型 int 和 bool： 123def example_keyword(count=-1, case_insensitive=True): if case_insensitive: # ... 当基于默认值隐式获取类型信息时，参数转换本身并不像从显式获取的信息那样严格： 转换也可能尝试到其他”相似”的类型。例如，如果转换为整数失败，将尝试浮点数转换。 转换失败不是错误，在这些情况下，关键字获取原始值。 如果一个参数有一个显式类型和一个默认值，首先尝试基于显式类型进行转换。如果失败，那么将尝试基于默认值进行转换。在这种特殊情况下，基于默认值的转换是严格的，转换失败会导致错误。 如果不希望基于默认值进行参数转换，可以使用 @keyword 装饰器像 @keyword(types&#x3D;None) 这样禁用整个参数转换。 注意 在 Robot Framework 4.0 之前，只有当参数没有显式类型时，才会根据默认值进行转换。 支持的转换下表列出了 Robot Framework 3.1 及更高版本将参数转换为的类型。这些特性适用于所有转换： 类型可以使用函数注解或 @keyword 装饰器显式指定。 如果没有显式指定，类型可以从参数默认值隐式获取。 无论给定参数的类型如何，都会进行转换。如果参数类型与预期类型不兼容，转换失败。 如果类型已经显式指定，转换失败会导致错误。如果根据默认值获取类型，给定参数将按原样使用。 注意 如果一个参数既有类型提示又有默认值，首先尝试基于类型提示进行转换，然后，如果失败，基于默认值类型进行转换。这种行为在未来可能会改变，以便只有在参数没有类型提示时才根据默认值进行转换。这将改变像 arg: list &#x3D; None 这样的情况的转换行为，其中不再尝试 None 转换。强烈建议库创建者像 arg: list | None &#x3D; None 这样显式指定默认值类型。 可以使用具体类型（例如，list）、使用抽象基类（ABC）（例如，Sequence）或使用这些类型的子类（例如，MutableSequence）来指定要使用的类型。也支持在 typing 模块中映射到支持的具体类型或 ABC 的类型（例如，List）。在所有这些情况下，参数都转换为具体类型。 除了使用实际类型（例如，int），还可以使用字符串（例如，‘int’）指定类型，一些类型也有别名（例如，‘integer’）。匹配类型到名称和别名不区分大小写。 “接受”列指定了哪些给定的参数类型被转换。如果给定的参数已经具有预期的类型，不会进行转换。其他类型会导致转换失败。 类型 ABC 别名 接受 解释 示例 bool boolean str, int, float, None 字符串 TRUE, YES, ON 和 1 转换为 True，空字符串以及 FALSE, NO, OFF 和 0 转换为 False，字符串 NONE 转换为 None。其他字符串和其他接受的值按原样传递，允许关键字在需要时特殊处理它们。所有字符串比较都不区分大小写。True 和 false 字符串可以本地化。参见支持的翻译的翻译附录。 TRUE (转换为 True) off (转换为 False) example (按原样使用) int Integral integer, long str, float 使用内置函数 int 进行转换。只有当它们可以精确表示为整数时才接受浮点数。例如，接受 1.0 而不接受 1.1。如果将字符串转换为整数失败，并且根据默认值隐式获取类型，则尝试转换为浮点数。从 Robot Framework 4.1 开始，可以通过在值前加上 0x、0o 和 0b 来使用十六进制、八进制和二进制数字。从 Robot Framework 4.1 开始，可以使用空格和下划线作为数字分组的视觉分隔符。从 Robot Framework 7.0 开始，只要它们的小数部分为零，就接受表示浮点数的字符串。这包括使用科学记数法，如 1e100。 42 -1 10 000 000 1e100 0xFF 0o777 0b1010 0xBAD_C0FFEE {1}1{1.0} float Real double str, Real 使用内置的 float 进行转换。从 Robot Framework 4.1 开始，可以使用空格和下划线作为数字分组的视觉分隔符。 3.14 2.9979e8 10 000.000 01 10_000.000_01 Decimal str, int, float 使用 Decimal 类进行转换。当需要精确表示小数时，推荐使用 Decimal 而不是 float。从 Robot Framework 4.1 开始，可以使用空格和下划线作为数字分组的视觉分隔符。 3.14 10 000.000 01 10_000.000_01 str string, unicode 任何 所有参数都转换为 Unicode 字符串。在 Robot Framework 4.0 中新增。 bytes str, bytearray 字符串被转换为字节，以便每个 Unicode 码点低于 256 的直接映射到匹配的字节。不允许使用更高的码点。 good hyvä (转换为 hyv\\xe4) \\x00 (空字节) bytearray str, bytes 与字节的转换相同，但结果是 bytearray。 datetime str, int, float 预期字符串是 ISO 8601 格式的时间戳，如 YYYY-MM-DD hh:mm:ss.mmmmmm，其中任何非数字字符都可以用作分隔符，或者可以完全省略分隔符。此外，只有日期部分是必需的，所有可能缺失的时间组件都被视为零。整数和浮点数被认为是自 Unix 纪元以来的秒数。 2022-02-09T16:39:43.632269 2022-02-09 16:39 2022-02-09 ${1644417583.632269} (Epoch 时间) date str 与 datetime 的字符串转换相同，但所有时间组件都应省略或为零。 2018-09-12 timedelta str, int, float 预期字符串表示一个时间间隔，格式为 Robot Framework 支持的一种时间格式：数字时间、时间字符串或”计时器”字符串。整数和浮点数被认为是秒。 42 (42 秒) 1 分钟 2 秒 01:02 (与上面相同) Path PathLike str 字符串被转换为 pathlib.Path 对象。在 Windows 上，&#x2F; 自动转换为 \\。在 Robot Framework 6.0 中新增。 &#x2F;tmp&#x2F;absolute&#x2F;path relative&#x2F;path&#x2F;to&#x2F;file.ext name.txt Enum str 指定的类型必须是枚举（Enum 或 Flag 的子类），给定的参数必须匹配其成员名称。匹配成员名称对大小写、空格、下划线和连字符不敏感，但精确匹配优先于规范化匹配。在 Robot Framework 7.0 中新增忽略连字符。枚举文档和成员在由 Libdoc 自动生成的文档中自动显示。 NORTH (Direction.NORTH) north west (Direction.NORTH_WEST) IntEnum str, int 指定的类型必须是基于整数的枚举（IntEnum 或 IntFlag 的子类），给定的参数必须匹配其成员名称或值。匹配成员名称的方式与 Enum 相同。值可以是整数，也可以是可以转换为整数的字符串。枚举文档和成员在由 Libdoc 自动生成的文档中自动显示。在 Robot Framework 4.1 中新增。 OFF (PowerState.OFF) 1 (PowerState.ON) Literal 任何 只接受指定的值。值可以是字符串、整数、字节、布尔值、枚举和 None，使用的参数使用特定于值类型的转换逻辑进行转换。字符串对大小写、空格、下划线和连字符不敏感，但精确匹配优先于规范化匹配。Literal 提供了与 Enum 类似的功能，但不支持自定义文档。在 Robot Framework 7.0 中新增。 OFF on None str 字符串 NONE（不区分大小写）被转换为 Python None 对象。其他值会导致错误。 None Any 任何 接受任何值。不进行转换。在 Robot Framework 6.1 中新增。 list Sequence sequence str, Sequence 字符串必须是 Python 列表字面量。它们使用 ast.literal_eval 函数转换为实际的列表。它们可以包含 ast.literal_eval 支持的任何值，包括列表和其他容器。如果使用的类型提示是 list（例如，arg: list），那么不是列表的序列将被转换为列表。如果类型提示是通用的 Sequence，那么序列将不经转换地使用。在 Robot Framework 7.0 中新增序列别名。 [‘one’, ‘two’] [(‘one’, 1), (‘two’, 2)] tuple str, Sequence 与 list 相同，但字符串参数必须是元组字面量。 (‘one’, ‘two’) set Set str, Container 与 list 相同，但字符串参数必须是集合字面量或 set() 来创建一个空集合。 {1, 2, 3, 42} set() frozenset str, Container 与 set 相同，但结果是一个 frozenset。 {1, 2, 3, 42} frozenset() dict Mapping dictionary, mapping, map str, Mapping 与 list 相同，但字符串参数必须是字典字面量。在 Robot Framework 7.0 中新增映射别名。 {‘a’: 1, ‘b’: 2} {‘key’: 1, ‘nested’: {‘key’: 2}} TypedDict str, Mapping 与 dict 相同，但字典项也转换为指定的类型，不允许包含类型规范中未包含的项。在 Robot Framework 6.0 中新增。普通的 dict 转换在之前使用。 {‘width’: 1600, ‘enabled’: True} 注意 注意 从 Robot Framework 5.0 开始，已转换的类型会自动显示在 Libdoc 输出中。 在 Robot Framework 4.0 之前，大多数类型支持将字符串 NONE（不区分大小写）转换为 Python None。这种支持已被移除，只有当参数具有 None 作为显式类型或默认值时，才进行 None 转换。 指定多个可能的类型从 Robot Framework 4.0 开始，可以指定一个参数有多个可能的类型。在这种情况下，会根据每种类型尝试参数转换，如果所有这些转换都失败，那么整个转换就会失败。 当使用函数注解时，指定一个参数有多个可能的类型的自然语法是使用 Union： 12345from typing import Uniondef example(length: Union[int, float], padding: Union[int, str, None] = None): ... 当使用 Python 3.10 或更高版本时，可以使用原生的 type1 | type2 语法： 12def example(length: int | float, padding: int | str | None = None): ... Robot Framework 7.0 增强了对联合语法的支持，以便也可以像 ‘type1 | type2’ 这样的”字符串类型”联合工作。这种语法也适用于旧的 Python 版本： 12def example(length: &#x27;int | float&#x27;, padding: &#x27;int | str | None&#x27; = None): ... 另一种方法是将类型指定为元组。这在注解中不推荐使用，因为其他工具不支持这种语法，但它与 @keyword 装饰器配合使用效果很好： 123456from robot.api.deco import keyword@keyword(types=&#123;&#x27;length&#x27;: (int, float), &#x27;padding&#x27;: (int, str, None)&#125;)def example(length, padding=None): ... 在上述示例中，length 参数将首先被转换为整数，如果失败，则转换为浮点数。padding 将首先被转换为整数，然后转换为字符串，最后转换为 None。 如果给定的参数具有其中一个接受的类型，那么不进行转换，参数按原样使用。例如，如果 length 参数获取值 1.5 作为浮点数，它将不会被转换为整数。注意，使用非字符串值（如浮点数）作为参数需要使用变量，如这些示例给出的给 length 参数不同值所示： 123456*** Test Cases ***Conversion Example 10 # 参数是字符串。转换为整数。 Example 1.5 # 参数是字符串。转换为浮点数。 Example $&#123;10&#125; # 参数是整数。按原样接受。 Example $&#123;1.5&#125; # 参数是浮点数。按原样接受。 如果接受的类型之一是字符串，那么如果给定的参数是字符串，则不进行转换。如下面的示例给出的给 padding 参数不同值所示，在这些情况下，也可以使用变量传递其他类型： 1234567*** Test Cases ***Conversion Example 1 big # 参数是字符串。按原样接受。 Example 1 10 # 参数是字符串。按原样接受。 Example 1 $&#123;10&#125; # 参数是整数。按原样接受。 Example 1 $&#123;None&#125; # 参数是 `None`。按原样接受。 Example 1 $&#123;1.5&#125; # 参数是浮点数。转换为整数。 如果给定的参数没有任何接受的类型，将按照类型指定的顺序尝试转换。如果任何转换成功，结果值将被使用，而不尝试剩余的转换。如果没有单个转换成功，整个转换失败。 如果 Robot Framework 不识别指定的类型，那么原始参数值将按原样使用。例如，对于这个关键字，首先会尝试将参数转换为整数，但如果失败，关键字将获取原始参数： 12def example(argument: Union[int, Unrecognized]): ... 从 Robot Framework 6.1 开始，如果未识别的类型列在识别的类型之前，如 Union[Unrecognized, int]，上述逻辑也适用。在这种情况下，也会尝试 int 转换，如果失败，参数将按原样传递。在早期的 Robot Framework 版本中，不会尝试 int 转换。 泛型的类型转换对于泛型，也可以使用参数化语法，如 list[int] 或 dict[str, int]。当使用这种语法时，首先将给定值转换为基类型，然后将各个项目转换为嵌套类型。不同的泛型类型的转换规则如下： 对于列表，只能有一种类型，如 list[float]。所有列表项都转换为该类型。 对于元组，可以有任意数量的类型，如 tuple[int, int] 和 tuple[str, int, bool]。作为参数的元组预期具有完全相同的项目数量，并且它们被转换为匹配的类型。 要创建同质元组，可以使用一个类型和省略号，如 tuple[int, ...]。在这种情况下，元组可以有任意数量的项目，它们都被转换为指定的类型。 对于字典，必须有两种类型，如 dict[str, int]。字典键使用前一种类型转换，值使用后一种类型转换。 对于集合，只能有一种类型，如 set[float]。转换逻辑与列表相同。 使用原生的 list[int] 语法需要 Python 3.9 或更高版本。如果需要支持早期的 Python 版本，可以使用来自 typing 模块的匹配类型，如 List[int]，或使用 “字符串类型” 语法，如 &#39;list[int]&#39;。 注意 在 Robot Framework 6.0 中新增了对泛型的嵌套类型转换的支持。同样的语法也适用于早期版本，但参数只转换为基类型，嵌套类型不用于任何事情。 在 Robot Framework 7.0 中新增了对 “字符串类型” 参数化泛型的支持。 自定义参数转换器除了像前面的章节中解释的那样自动进行参数转换，Robot Framework 还支持自定义参数转换。这个功能有两个主要的用途： 覆盖框架提供的标准参数转换器。 为自定义类型和其他不支持开箱即用的类型添加参数转换。 参数转换器是函数或其他可调用的对象，它们获取用于数据的参数，并在参数传递给关键字之前将它们转换为所需的格式。通过将 ROBOT_LIBRARY_CONVERTERS 属性（区分大小写）设置为将所需类型映射到转换器的字典，为库注册转换器。当以模块的方式实现库时，这个属性必须设置在模块级别，对于基于类的库，它必须是类属性。对于以类实现的库，也可以使用 @library 装饰器的 converters 参数。下面的章节中的示例说明了这两种方法。 注意 在 Robot Framework 5.0 中新增了自定义参数转换器。 覆盖默认转换器假设想要创建一个接受日期对象的关键字，用于芬兰的用户，其中常用的日期格式是 dd.mm.yyyy。使用方式可能如下所示： 123*** Test Cases ***Example Keyword 25.1.2022 自动参数转换支持日期，但它期望它们是 yyyy-mm-dd 格式，所以它不会工作。解决方案是创建一个自定义转换器，并注册它来处理日期转换： 12345678910111213141516from datetime import date# 转换器函数。def parse_fi_date(value): day, month, year = value.split(&#x27;.&#x27;) return date(int(year), int(month), int(day))# 为指定类型注册转换器函数。ROBOT_LIBRARY_CONVERTERS = &#123;date: parse_fi_date&#125;# 使用自定义转换器的关键字。转换器基于参数类型解析。def keyword(arg: date): print(f&#x27;year: &#123;arg.year&#125;, month: &#123;arg.month&#125;, day: &#123;arg.day&#125;&#x27;) 转换错误如果尝试使用像 invalid 这样的无效参数使用上述关键字，它会失败并产生这个错误： 1ValueError: Argument &#x27;arg&#x27; got value &#x27;invalid&#x27; that cannot be converted to date: not enough values to unpack (expected 3, got 1) 这个错误不太有信息量，也没有告诉任何关于预期格式的信息。Robot Framework 不能自动提供更多的信息，但转换器本身可以增强以验证输入。如果输入无效，转换器应该引发一个带有适当消息的 ValueError。在这种特殊情况下，有几种方法可以验证输入，但使用正则表达式可以验证输入在正确的位置有点（.）和日期部分包含正确数量的数字： 123456789101112131415161718from datetime import dateimport redef parse_fi_date(value): # 使用正则表达式验证输入，如果无效则引发 ValueError。 match = re.match(r&#x27;(\\d&#123;1,2&#125;)\\.(\\d&#123;1,2&#125;)\\.(\\d&#123;4&#125;)$&#x27;, value) if not match: raise ValueError(f&quot;Expected date in format &#x27;dd.mm.yyyy&#x27;, got &#x27;&#123;value&#125;&#x27;.&quot;) day, month, year = match.groups() return date(int(year), int(month), int(day))ROBOT_LIBRARY_CONVERTERS = &#123;date: parse_fi_date&#125;def keyword(arg: date): print(f&#x27;year: &#123;arg.year&#125;, month: &#123;arg.month&#125;, day: &#123;arg.day&#125;&#x27;) 使用上述转换器代码，使用参数 invalid 的关键字失败会有更多有用的错误消息： 1ValueError: Argument &#x27;arg&#x27; got value &#x27;invalid&#x27; that cannot be converted to date: Expected date in format &#x27;dd.mm.yyyy&#x27;, got &#x27;invalid&#x27;. ​ 限制值类型默认情况下，Robot Framework 会尝试使用所有给定参数的转换器，无论它们的类型如何。这意味着，如果之前的示例关键字被用于包含字符串以外的变量，转换代码将在 re.match 调用中失败。例如，尝试使用参数 ${42} 会导致以下错误： 1ValueError: Argument &#x27;arg&#x27; got value &#x27;42&#x27; (integer) that cannot be converted to date: TypeError: expected string or bytes-like object 这种错误情况可以自然地在转换器代码中通过检查值类型来处理，但是如果转换器只接受某些类型，通常更容易直接限制值为该类型。做到这一点只需要向转换器添加适当的类型提示： 12def parse_fi_date(value: str): # ... 注意，这个类型提示不用于在调用转换器之前转换值，它用于严格限制可以使用的类型。使用上述添加后，使用 ${42} 调用关键字将导致以下错误： 1ValueError: Argument &#x27;arg&#x27; got value &#x27;42&#x27; (integer) that cannot be converted to date. 如果转换器可以接受多种类型，可以将类型指定为 Union。例如，如果想要增强的关键字，以便也接受整数，使它们被视为自 Unix 纪元以来的秒数，可以这样改变转换器： 12345678910111213141516171819202122from datetime import dateimport refrom typing import Union# 接受字符串和整数。def parse_fi_date(value: Union[str, int]): # 整数单独转换。 if isinstance(value, int): return date.fromtimestamp(value) match = re.match(r&#x27;(\\d&#123;1,2&#125;)\\.(\\d&#123;1,2&#125;)\\.(\\d&#123;4&#125;)$&#x27;, value) if not match: raise ValueError(f&quot;Expected date in format &#x27;dd.mm.yyyy&#x27;, got &#x27;&#123;value&#125;&#x27;.&quot;) day, month, year = match.groups() return date(int(year), int(month), int(day))ROBOT_LIBRARY_CONVERTERS = &#123;date: parse_fi_date&#125;def keyword(arg: date): print(f&#x27;year: &#123;arg.year&#125;, month: &#123;arg.month&#125;, day: &#123;arg.day&#125;&#x27;) ​ 转换自定义类型在之前的示例中，日期对象只能以 dd.mm.yyyy 的格式给出。如果需要支持不同格式的日期，比如下面的例子，这将无法工作： 12345*** Test Cases ***Example Finnish 25.1.2022 US 1/25/2022 ISO 8601 2022-01-22 解决这个问题的方法是创建自定义类型，而不是覆盖默认的日期转换： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from datetime import dateimport refrom typing import Unionfrom robot.api.deco import keyword, library# 自定义类型。扩展了一个现有的类型，但这不是必需的。class FiDate(date): # 转换器函数实现为类方法。它也可以是一个普通的函数，但这样所有的代码都在同一个类中。 @classmethod def from_string(cls, value: str): match = re.match(r&#x27;(\\d&#123;1,2&#125;)\\.(\\d&#123;1,2&#125;)\\.(\\d&#123;4&#125;)$&#x27;, value) if not match: raise ValueError(f&quot;Expected date in format &#x27;dd.mm.yyyy&#x27;, got &#x27;&#123;value&#125;&#x27;.&quot;) day, month, year = match.groups() return cls(int(year), int(month), int(day))# 另一个自定义类型。class UsDate(date): @classmethod def from_string(cls, value: str): match = re.match(r&#x27;(\\d&#123;1,2&#125;)/(\\d&#123;1,2&#125;)/(\\d&#123;4&#125;)$&#x27;, value) if not match: raise ValueError(f&quot;Expected date in format &#x27;mm/dd/yyyy&#x27;, got &#x27;&#123;value&#125;&#x27;.&quot;) month, day, year = match.groups() return cls(int(year), int(month), int(day))# 使用 &#x27;@library&#x27; 装饰器注册转换器。@library(converters=&#123;FiDate: FiDate.from_string, UsDate: UsDate.from_string&#125;)class Library: # 使用支持 &#x27;dd.mm.yyyy&#x27; 格式的自定义转换器。 @keyword def finnish(self, arg: FiDate): print(f&#x27;year: &#123;arg.year&#125;, month: &#123;arg.month&#125;, day: &#123;arg.day&#125;&#x27;) # 使用支持 &#x27;mm/dd/yyyy&#x27; 格式的自定义转换器。 @keyword def us(self, arg: UsDate): print(f&#x27;year: &#123;arg.year&#125;, month: &#123;arg.month&#125;, day: &#123;arg.day&#125;&#x27;) # 使用与 IS0-8601 兼容的默认转换。 @keyword def iso_8601(self, arg: date): print(f&#x27;year: &#123;arg.year&#125;, month: &#123;arg.month&#125;, day: &#123;arg.day&#125;&#x27;) # 接受不同格式的日期。 @keyword def any(self, arg: Union[FiDate, UsDate, date]): print(f&#x27;year: &#123;arg.year&#125;, month: &#123;arg.month&#125;, day: &#123;arg.day&#125;&#x27;) ​ 严格的类型验证如果参数开始时就是指定的类型，那么根本不会使用转换器。因此，使用不接受任何值的自定义转换器可以轻松启用严格的类型验证。例如，Example 关键字只接受 StrictType 实例： 12345678910111213class StrictType: passdef strict_converter(arg): raise TypeError(f&#x27;Only StrictType instances accepted, got &#123;type(arg).__name__&#125;.&#x27;)ROBOT_LIBRARY_CONVERTERS = &#123;StrictType: strict_converter&#125;def example(argument: StrictType): assert isinstance(argument, StrictType) 为了方便，Robot Framework 允许将转换器设置为 None 以获得相同的效果。例如，这段代码的行为与上述代码完全相同： 123456789class StrictType: passROBOT_LIBRARY_CONVERTERS = &#123;StrictType: None&#125;def example(argument: StrictType): assert isinstance(argument, StrictType) 注意 在 Robot Framework 6.0 中新增了使用 None 作为严格转换器。在早期版本中需要使用显式的转换器函数。 从转换器访问测试库从 Robot Framework 6.1 开始，可以从转换器函数访问库实例。这允许定义依赖于库状态的动态类型转换。例如，如果库可以配置为测试特定的区域设置，可能会使用库状态来确定如何解析日期，如下所示： 1234567891011121314151617181920212223from datetime import dateimport redef parse_date(value, library): # 使用正则表达式验证输入，如果无效则引发 ValueError。 # 使用库状态中的区域设置来确定解析格式。 if library.locale == &#x27;en_US&#x27;: match = re.match(r&#x27;(?P&lt;month&gt;\\d&#123;1,2&#125;)/(?P&lt;day&gt;\\d&#123;1,2&#125;)/(?P&lt;year&gt;\\d&#123;4&#125;)$&#x27;, value) format = &#x27;mm/dd/yyyy&#x27; else: match = re.match(r&#x27;(?P&lt;day&gt;\\d&#123;1,2&#125;)\\.(?P&lt;month&gt;\\d&#123;1,2&#125;)\\.(?P&lt;year&gt;\\d&#123;4&#125;)$&#x27;, value) format = &#x27;dd.mm.yyyy&#x27; if not match: raise ValueError(f&quot;Expected date in format &#x27;&#123;format&#125;&#x27;, got &#x27;&#123;value&#125;&#x27;.&quot;) return date(int(match.group(&#x27;year&#x27;)), int(match.group(&#x27;month&#x27;)), int(match.group(&#x27;day&#x27;)))ROBOT_LIBRARY_CONVERTERS = &#123;date: parse_date&#125;def keyword(arg: date): print(f&#x27;year: &#123;arg.year&#125;, month: &#123;arg.month&#125;, day: &#123;arg.day&#125;&#x27;) 转换器函数的库参数是可选的，即如果转换器函数只接受一个参数，库参数将被省略。通过使转换器函数只接受可变参数，例如 def parse_date(*varargs)，可以实现类似的结果。 转换器文档转换器的信息会自动添加到由 Libdoc 生成的输出中。这些信息包括类型的名称、接受的值（如果使用类型提示指定）和文档。类型信息会自动链接到使用这些类型的所有关键字。 默认情况下，文档是从转换器函数中获取的。如果它没有任何文档，文档就从类型中获取。因此，上一个示例中向转换器添加文档的这两种方法产生的结果是相同的： 1234567891011121314class FiDate(date): @classmethod def from_string(cls, value: str): &quot;&quot;&quot;日期格式为 ``dd.mm.yyyy``。&quot;&quot;&quot; # ...class UsDate(date): &quot;&quot;&quot;日期格式为 ``mm/dd/yyyy``。&quot;&quot;&quot; @classmethod def from_string(cls, value: str): # ... 通常推荐添加文档，以向用户提供更多关于转换的信息。特别重要的是要记录为现有类型注册的转换器函数，因为它们自己的文档在这种情况下可能不太有用。 @keyword 装饰器尽管 Robot Framework 自动获取了关于关键字的大量信息，如它们的名称和参数，但有时需要进一步配置这些信息。这通常最容易通过使用 robot.api.deco.keyword 装饰器来完成。它有几个有用的用法，这些用法在其他地方已经详细解释，这里只列出作为参考： 当使用 @library 装饰器或其他方式禁用了自动关键字发现时，将方法和函数公开为关键字。 为关键字设置自定义名称。当使用嵌入式参数语法时，这尤其有用。 设置关键字标签。 设置类型信息以启用自动参数类型转换。也支持完全禁用参数转换。 当使用动态库 API 或混合库 API 时，标记要公开为关键字的方法。 @not_keyword 装饰器robot.api.deco.not_keyword 装饰器可以用于禁用函数或方法成为关键字。 使用自定义装饰器在实现关键字时，有时使用 Python 装饰器修改它们是有用的。然而，装饰器通常会修改函数签名，因此可能会使 Robot Framework 的内省在确定关键字接受哪些参数时感到困惑。当使用 Libdoc 创建库文档和使用像 RIDE 这样的外部工具时，这尤其有问题。避免这个问题的最简单方法是使用 functools.wraps 装饰装饰器本身。其他解决方案包括使用像 decorator 和 wrapt 这样的外部模块，它们允许创建完全保留签名的装饰器。 注意 在 Robot Framework 3.2 中新增了对使用 functools.wraps 装饰的装饰器的 “解包” 支持。 ​ 嵌入参数到关键字名称库关键字也可以接受嵌入参数，就像用户关键字一样。这部分主要介绍创建此类关键字的 Python 语法，嵌入参数的语法本身在用户关键字文档中详细介绍。 具有嵌入参数的库关键字需要有一个自定义名称，通常使用 @keyword 装饰器设置。匹配嵌入参数的值作为位置参数传递给实现关键字的函数或方法。如果函数或方法接受更多参数，它们可以作为正常的位置或命名参数传递给关键字。参数名称不需要匹配嵌入参数名称，但这通常是一个好的约定。 接受嵌入参数的关键字： 123456789from robot.api.deco import keyword@keyword(&#x27;Select $&#123;animal&#125; from list&#x27;)def select_animal_from_list(animal): ...@keyword(&#x27;Number of $&#123;animals&#125; should be&#x27;)def number_of_animals_should_be(animals, count): ... 使用上述关键字的测试： 12345678*** Test Cases ***Embedded arguments Select cat from list Select dog from listEmbedded and normal arguments Number of cats should be 2 Number of dogs should be count=3 如果指定了类型信息，自动参数转换也适用于嵌入参数： 123@keyword(&#x27;Add $&#123;quantity&#125; copies of $&#123;item&#125; to cart&#x27;)def add_copies_to_cart(quantity: int, item: str): ... 注意 在 Robot Framework 7.0 中，混合嵌入参数和普通参数的支持是新的。 异步关键字从 Robot Framework 6.1 开始，可以像运行普通函数一样运行原生异步函数（由 async def 创建）： 123456import asynciofrom robot.api.deco import keyword@keywordasync def this_keyword_waits(): await asyncio.sleep(5) 可以使用 asyncio.get_running_loop() 或 asyncio.get_event_loop() 获取循环的引用。在修改循环运行方式时要小心，它是全局资源。例如，永远不要调用 loop.close()，因为这将使得无法运行任何进一步的协程。如果有任何函数或资源需要事件循环，即使没有显式使用 await，也必须将函数定义为 async 才能使用事件循环。 更多功能示例： 123456789101112131415161718import asynciofrom robot.api.deco import keywordasync def task_async(): await asyncio.sleep(5)@keywordasync def examples(): tasks = [task_async() for _ in range(10)] results = await asyncio.gather(*tasks) background_task = asyncio.create_task(task_async()) await background_task # If running with Python 3.10 or higher async with asyncio.TaskGroup() as tg: task1 = tg.create_task(task_async()) task2 = tg.create_task(task_async()) 注意 Robot Framework 会等待函数完成。如果想要一个运行很长时间的任务，例如，使用 asyncio.create_task()。管理任务并保存引用以避免被垃圾回收是责任。如果事件循环关闭并且任务仍在挂起，将打印一条消息到控制台。 如果关键字的执行由于某种原因不能继续，例如信号停止，Robot Framework 将取消异步任务及其所有子任务。其他异步任务将正常运行。 与 Robot Framework 通信在调用实现关键字的方法后，它可以使用任何机制与被测试系统进行通信。然后，它也可以向 Robot Framework 的日志文件发送消息，返回可以保存到变量的信息，最重要的是，报告关键字是否通过。 报告关键字状态报告关键字状态只需使用异常即可完成。如果执行的方法引发异常，关键字状态为 FAIL，如果正常返回，则状态为 PASS。 可以使用标准异常（如 AssertionError、ValueError 和 RuntimeError）报告正常执行失败和错误。然而，在后续部分解释的一些特殊情况中，需要特殊的异常。 错误消息在日志、报告和控制台中显示的错误消息是从异常类型和其消息创建的。对于通用异常（例如，AssertionError、Exception 和 RuntimeError），只使用异常消息，对于其他异常，消息以 ExceptionType: Actual message 的格式创建。 也可以避免在非通用异常的失败消息前添加异常类型。这是通过向异常添加一个特殊的 ROBOT_SUPPRESS_NAME 属性并赋值为 True 来完成的。 Python： 12class MyError(RuntimeError): ROBOT_SUPPRESS_NAME = True 在所有情况下，对用户来说，异常消息尽可能具有信息性是很重要的。 错误消息中的 HTML也可以通过在消息开始处添加文本 HTML 来获得 HTML 格式的错误消息： 1raise AssertionError(&quot;*HTML* &lt;a href=&#x27;robotframework.org&#x27;&gt;Robot Framework&lt;/a&gt; rulez!!&quot;) 这种方法既可以在库中引发异常时使用，如上例所示，也可以在用户在测试数据中提供错误消息时使用。 自动剪切长消息如果错误消息超过 40 行，它将自动从中间剪切，以防止报告变得过长且难以阅读。完整的错误消息总是显示在失败关键字的日志消息中。 跟踪回溯异常的跟踪回溯也使用 DEBUG 日志级别记录。这些消息在日志文件中默认不可见，因为它们对普通用户来说很少有趣。在开发库时，通常最好使用 –loglevel DEBUG 运行测试。 Robot Framework 提供的异常Robot Framework 提供了一些库可以用来报告失败和其他事件的异常。这些异常通过 robot.api 包暴露，并包含以下内容： Failure报告验证失败。使用此异常与使用标准的 AssertionError 没有实际区别。使用此异常的主要好处是其名称与其他提供的异常一致。 Error报告执行错误。与系统行为不符的失败通常应使用 Failure 异常或标准的 AssertionError 报告。例如，如果关键字使用不正确，可以使用此异常。除了与其他提供的异常名称一致外，使用此异常与使用标准的 RuntimeError 没有实际区别。 ContinuableFailure报告验证失败但允许继续执行。有关更多信息，请参见下面的 “可继续的失败” 部分。 SkipExecution标记已执行的测试或任务为跳过。有关更多信息，请参见下面的 “跳过测试” 部分。 FatalError报告停止整个执行的错误。有关更多信息，请参见下面的 “停止测试执行” 部分。 注意：所有这些异常都是在 Robot Framework 4.0 中新增的。除跳过测试（这也是 Robot Framework 4.0 中的新功能）外，早期版本中的其他功能可以通过其他方式获得。 可继续的失败即使存在失败，也可以继续测试执行。做到这一点的最简单方法是使用提供的 robot.api.ContinuableFailure 异常： 123456from robot.api import ContinuableFailuredef example_keyword(): if something_is_wrong(): raise ContinuableFailure(&#x27;Something is wrong but execution can continue.&#x27;) ... 另一种方法是创建一个自定义异常，该异常具有设置为 True 值的特殊 ROBOT_CONTINUE_ON_FAILURE 属性。下面的示例进行了演示。 12class MyContinuableError(RuntimeError): ROBOT_CONTINUE_ON_FAILURE = True 跳过测试可以使用库关键字跳过测试。做到这一点的最简单方法是使用提供的 robot.api.SkipExecution 异常： 123456from robot.api import SkipExecutiondef example_keyword(): if test_should_be_skipped(): raise SkipExecution(&#x27;Cannot proceed, skipping test.&#x27;) ... 另一种方法是创建一个自定义异常，该异常具有设置为 True 值的特殊 ROBOT_SKIP_EXECUTION 属性。下面的示例进行了演示。 12class MySkippingError(RuntimeError): ROBOT_SKIP_EXECUTION = True ​ 停止测试执行可以使测试用例失败，从而停止整个测试执行。实现这一点的最简单方法是使用提供的 robot.api.FatalError 异常： 123456from robot.api import FatalErrordef example_keyword(): if system_is_not_running(): raise FatalError(&#x27;System is not running!&#x27;) ... 除了使用 robot.api.FatalError 异常外，还可以创建一个具有设置为 True 值的特殊 ROBOT_EXIT_ON_FAILURE 属性的自定义异常。下面的示例进行了说明。 12class MyFatalError(RuntimeError): ROBOT_EXIT_ON_FAILURE = True 记录信息异常消息不是向用户提供信息的唯一方式。除此之外，方法还可以通过简单地写入标准输出流（stdout）或标准错误流（stderr）向日志文件发送消息，甚至可以使用不同的日志级别。另一个，通常更好的，记录可能性是使用编程日志 API。 默认情况下，方法写入标准输出的所有内容都作为单个条目写入日志文件，日志级别为 INFO。写入标准错误的消息在其他方面处理类似，但在关键字执行完成后，它们会被回显到原始 stderr。因此，如果需要在执行测试的控制台上看到一些消息，可以使用 stderr。 使用日志级别要使用 INFO 以外的其他日志级别，或创建多个消息，可以通过在消息中明确指定日志级别来实现，格式为 LEVEL 实际日志消息。在这种格式中，LEVEL 必须在行的开头，LEVEL 必须是可用的具体日志级别 TRACE、DEBUG、INFO、WARN 或 ERROR，或伪日志级别 HTML 或 CONSOLE。伪级别可以分别用于记录 HTML 和记录到控制台。 错误和警告带有 ERROR 或 WARN 级别的消息会自动写入控制台和日志文件中的单独的 “Test Execution Errors” 部分。这使得这些消息比其他消息更加可见，并允许使用它们向用户报告重要但非关键的问题。 记录 HTML库通常记录的所有内容都将转换为可以安全表示为 HTML 的格式。例如，foo 将在日志中完全按照该方式显示，而不是 foo。如果库想要使用格式化、链接、显示图像等，它们可以使用特殊的伪日志级别 HTML。Robot Framework 将这些消息直接以 INFO 级别写入日志，因此它们可以使用任何它们想要的 HTML 语法。注意，需要谨慎使用此功能，因为例如，一个放置不当的 标签可能会严重破坏日志文件。 在使用公共日志 API 时，各种日志方法有可选的 html 属性，可以设置为 True 以启用 HTML 格式的日志。 时间戳默认情况下，通过标准输出或错误流记录的消息在执行的关键字结束时获取其时间戳。这意味着时间戳不准确，特别是对于运行时间较长的关键字的问题调试可能会有问题。 关键字有可能在需要时向它们记录的消息中添加准确的时间戳。时间戳必须以 Unix 纪元以来的毫秒数给出，并且必须放在日志级别后面，用冒号与其分隔： 12*INFO:1308435758660* Message with timestamp*HTML:1308435758661* &lt;b&gt;HTML&lt;/b&gt; message with timestamp 如下面的示例所示，添加时间戳很容易。然而，使用编程日志 API 获取准确的时间戳更容易。显式添加时间戳的一个大好处是，这种方法也适用于远程库接口。 1234import timedef example_keyword(): print(&#x27;*INFO:%d* Message with timestamp&#x27; % (time.time()*1000)) ​ 记录到控制台库有多种选项可以将消息写入控制台。如前所述，警告和所有写入标准错误流的消息都会同时写入日志文件和控制台。这两种选项都有一个限制，即消息只有在当前执行的关键字完成后才会结束到控制台。 从 Robot Framework 6.1 开始，库可以使用伪日志级别 CONSOLE 将消息同时记录到日志文件和控制台： 12def my_keyword(arg): print(&#x27;*CONSOLE* Message both to log and to console.&#x27;) 这些消息将以与 HTML 伪日志级别类似的方式使用 INFO 级别记录到日志文件。使用此方法时，消息只有在关键字执行结束后才会记录到控制台。 另一种选项是将消息写入 sys.__stdout__ 或 sys.__stderr__。使用此方法时，消息会立即写入控制台，并且根本不会写入日志文件： 1234import sysdef my_keyword(arg): print(&#x27;Message only to console.&#x27;, file=sys.__stdout__) 最后一个选项是使用公共日志 API。在这种方法中，消息也会立即写入控制台： 1234567from robot.api import loggerdef log_to_console(arg): logger.console(&#x27;Message only to console.&#x27;)def log_to_console_and_log_file(arg): logger.info(&#x27;Message both to log and to console.&#x27;, also_console=True) 日志示例在大多数情况下，INFO 级别就足够了。低于它的级别，DEBUG 和 TRACE，对于写入调试信息很有用。这些消息通常不会显示，但是它们可以帮助调试库本身可能存在的问题。WARN 或 ERROR 级别可以用来使消息更加可见，HTML 对于需要任何类型的格式化都很有用。当消息需要同时显示在控制台和日志文件中时，可以使用 CONSOLE 级别。 以下示例阐明了如何使用不同级别进行日志记录的工作方式。 12345678910print(&#x27;Hello from a library.&#x27;)print(&#x27;*WARN* Warning from a library.&#x27;)print(&#x27;*ERROR* Something unexpected happen that may indicate a problem in the test.&#x27;)print(&#x27;*INFO* Hello again!&#x27;)print(&#x27;This will be part of the previous message.&#x27;)print(&#x27;*INFO* This is a new message.&#x27;)print(&#x27;*INFO* This is &lt;b&gt;normal text&lt;/b&gt;.&#x27;)print(&#x27;*CONSOLE* This logs into console and log file.&#x27;)print(&#x27;*HTML* This is &lt;b&gt;bold&lt;/b&gt;.&#x27;)print(&#x27;*HTML* &lt;a href=&quot;http://robotframework.org&quot;&gt;Robot Framework&lt;/a&gt;&#x27;) 12345678916:18:42.123 INFO Hello from a library. 16:18:42.123 WARN Warning from a library. 16:18:42.123 ERROR Something unexpected happen that may indicate a problem in the test. 16:18:42.123 INFO Hello again! This will be part of the previous message. 16:18:42.123 INFO This is a new message. 16:18:42.123 INFO This is &lt;b&gt;normal text&lt;/b&gt;. 16:18:42.123 INFO This logs into console and log file. 16:18:42.123 INFO This is bold. 16:18:42.123 INFO Robot Framework ​ 程序化日志 API程序化 API 提供了比使用标准输出和错误流更清晰的方式来记录信息。 公共日志 APIRobot Framework 有一个基于 Python 的日志 API，用于将消息写入日志文件和控制台。测试库可以像 logger.info(&#39;My message&#39;) 这样使用这个 API，而不是像 print(&#39;*INFO* My message&#39;) 那样通过标准输出进行日志记录。除了程序化接口使用起来更清晰外，这个 API 还有一个好处，即日志消息具有准确的时间戳。 公共日志 API 在 https://robot-framework.readthedocs.org 的 API 文档部分有详细的文档。下面是一个简单的使用示例： 1234567from robot.api import loggerdef my_keyword(arg): logger.debug(&#x27;Got argument %s&#x27; % arg) do_something() logger.info(&#x27;&lt;i&gt;This&lt;/i&gt; is a boring example&#x27;, html=True) logger.console(&#x27;Hello, console!&#x27;) 一个明显的限制是，使用这个日志 API 的测试库依赖于 Robot Framework。如果 Robot Framework 没有运行，消息会自动重定向到 Python 的标准日志模块。 使用 Python 的标准日志模块除了新的公共日志 API 外，Robot Framework 还提供了对 Python 的标准日志模块的内置支持。这个工作方式是，模块的根记录器接收到的所有消息都会自动传播到 Robot Framework 的日志文件。此 API 也会产生具有准确时间戳的日志消息，但不支持记录 HTML 消息或将消息写入控制台。一个很大的好处，也由下面的简单示例说明，是使用这个日志 API 不会创建对 Robot Framework 的依赖。 123456import loggingdef my_keyword(arg): logging.debug(&#x27;Got argument %s&#x27; % arg) do_something() logging.info(&#x27;This is a boring example&#x27;) 日志模块的日志级别与 Robot Framework 稍有不同。它的 DEBUG、INFO、WARNING 和 ERROR 级别直接映射到匹配的 Robot Framework 日志级别，CRITICAL 映射到 ERROR。自定义日志级别映射到比自定义级别小的最接近的标准级别。例如，INFO 和 WARNING 之间的级别映射到 Robot Framework 的 INFO 级别。 在库初始化期间进行日志记录库也可以在测试库导入和初始化期间进行日志记录。这些消息不会像正常的日志消息那样出现在日志文件中，而是写入到系统日志中。这允许记录关于库初始化的任何类型的有用的调试信息。使用 WARN 或 ERROR 级别记录的消息也会在日志文件中的测试执行错误部分中可见。 在导入和初始化期间进行日志记录可以使用标准输出和错误流以及程序化日志 API。这两种方法都在下面进行了演示。 在导入期间使用日志 API 记录库： 123456from robot.api import loggerlogger.debug(&quot;Importing library&quot;)def keyword(): # ... 注意 如果在初始化期间，即在 Python 的 __init__ 中，记录了一些东西，那么根据库的范围，消息可能会被记录多次。 返回值关键字与核心框架进行反向通信的最后一种方式是返回从被测试系统中检索或通过其他方式生成的信息。返回的值可以赋值给测试数据中的变量，然后作为其他关键字（甚至来自不同测试库）的输入使用。 值是通过方法中的 return 语句返回的。通常，一个值被赋值给一个标量变量，如下例所示。此示例还说明了可以返回任何对象并使用扩展变量语法访问对象属性的可能性。 1234567891011121314from mymodule import MyObjectdef return_string(): return &quot;Hello, world!&quot;def return_object(name): return MyObject(name)*** Test Cases ***Returning one value $&#123;string&#125; = Return String Should Be Equal $&#123;string&#125; Hello, world! $&#123;object&#125; = Return Object Robot Should Be Equal $&#123;object.name&#125; Robot 关键字也可以返回值，以便它们可以一次赋值给多个标量变量，赋值给一个列表变量，或赋值给标量变量和一个列表变量。所有这些用法都需要返回的值是列表或类似列表的对象。 12345678910111213141516def return_two_values(): return &#x27;first value&#x27;, &#x27;second value&#x27;def return_multiple_values(): return [&#x27;a&#x27;, &#x27;list&#x27;, &#x27;of&#x27;, &#x27;strings&#x27;]*** Test Cases ***Returning multiple values $&#123;var1&#125; $&#123;var2&#125; = Return Two Values Should Be Equal $&#123;var1&#125; first value Should Be Equal $&#123;var2&#125; second value @&#123;list&#125; = Return Two Values Should Be Equal @&#123;list&#125;[0] first value Should Be Equal @&#123;list&#125;[1] second value $&#123;s1&#125; $&#123;s2&#125; @&#123;li&#125; = Return Multiple Values Should Be Equal $&#123;s1&#125; $&#123;s2&#125; a list Should Be Equal @&#123;li&#125;[0] @&#123;li&#125;[1] of strings 检测 Robot Framework 是否正在运行从 Robot Framework 6.1 开始，通过使用 BuiltIn 库的 robot_running 和 dry_run_active 属性，很容易检测 Robot Framework 是否正在运行，以及 dry-run 模式是否激活。一个相对常见的用例是，库初始化器可能希望避免在执行期间不使用库但是被初始化（例如，由 Libdoc）时做一些工作： 12345678from robot.libraries.BuiltIn import BuiltInclass MyLibrary: def __init__(self): builtin = BuiltIn() if builtin.robot_running and not builtin.dry_run_active: # Do some initialization that only makes sense during real execution. 有关使用 BuiltIn 库作为程序化 API 的更多信息，包括使用 robot_running 的另一个示例，请参见 “使用 BuiltIn 库” 部分。 使用线程时的通信如果库使用线程，它通常应该只从主线程与框架进行通信。如果工作线程有例如需要报告的失败或需要记录的东西，它应该首先将信息传递给主线程，然后主线程可以使用本节解释的异常或其他机制与框架进行通信。 当线程在其他关键字运行时在后台运行时，这尤其重要。在这种情况下与框架进行通信的结果是未定义的，最坏的情况可能导致崩溃或输出文件损坏。如果关键字在后台启动了一些东西，应该有另一个关键字检查工作线程的状态并相应地报告收集到的信息。 使用程序化日志 API 的正常日志方法记录的非主线程的消息将被静默忽略。 还有一个在单独的 robotbackgroundlogger 项目中的 BackgroundLogger，具有与标准 robot.api.logger 类似的 API。正常的日志方法会忽略来自非主线程的消息，但 BackgroundLogger 会保存后台消息，以便稍后可以记录到 Robot 的日志中。 分发测试库文档化库没有关于其包含哪些关键字以及这些关键字的作用的文档的测试库是相当无用的。为了便于维护，强烈建议将库文档包含在源代码中并从中生成。基本上，这意味着使用 docstrings，如下例所示： 1234567891011121314class MyLibrary: &quot;&quot;&quot;这是一个带有一些文档的示例库。&quot;&quot;&quot; def keyword_with_short_documentation(self, argument): &quot;&quot;&quot;这个关键字只有简短的文档&quot;&quot;&quot; pass def keyword_with_longer_documentation(self): &quot;&quot;&quot;文档的第一行在这里。 更长的文档在这里继续，它可以包含 多行或段落。 &quot;&quot;&quot; pass Python 有创建库文档的工具，如上所述。然而，这些工具的输出对于一些用户来说可能稍微有些技术性。另一种选择是使用 Robot Framework 自己的文档工具 Libdoc。此工具可以从使用静态库 API 的库（如上所述）创建库文档，但它也处理使用动态库 API 和混合库 API 的库。 关键字文档的第一行逻辑行，直到第一个空行，用于特殊目的，应包含关键字的简短总体描述。它被 Libdoc 用作简短文档（例如，作为工具提示）并且也显示在测试日志中。 默认情况下，文档被认为遵循 Robot Framework 的文档格式规则。这种简单的格式允许经常使用的样式，如 粗体 和 斜体，表格，列表，链接等。也可以使用 HTML，纯文本和 reStructuredText 格式。有关如何在库源代码中设置格式的信息，请参见文档格式部分，有关格式的更多信息，请参见 Libdoc 章节。 注意：在 Robot Framework 3.1 之前，简短文档只包含关键字文档的第一行物理行。 测试库任何非琐碎的测试库都需要进行彻底的测试，以防止其中出现错误。当然，这种测试应该是自动化的，以便在库发生变化时重新运行测试。 Python 有出色的单元测试工具，它们非常适合测试库。在使用它们进行此目的的测试与使用它们进行其他测试之间没有主要的区别。熟悉这些工具的开发人员不需要学习任何新东西，而不熟悉它们的开发人员应该 anyway 学习它们。 也很容易使用 Robot Framework 本身来测试库，从而为它们进行实际的端到端验收测试。在 BuiltIn 库中有很多有用的关键字可以用于此目的。特别值得一提的是 Run Keyword And Expect Error，它对于测试关键字是否正确报告错误非常有用。 是否使用单元级别或验收级别的测试方法取决于上下文。如果需要模拟实际的被测试系统，通常在单元级别上更容易。另一方面，验收测试确保关键字通过 Robot Framework 工作。如果不能决定，当然可以使用这两种方法。 打包库在库被实现、文档化和测试后，仍然需要将其分发给用户。对于由单个文件组成的简单库，通常只需要求用户将该文件复制到某个地方并相应地设置模块搜索路径。更复杂的库应该被打包以使安装更容易。 由于库是正常的编程代码，它们可以使用正常的打包工具进行打包。有关打包和分发 Python 代码的信息，请参见 https://packaging.python.org/。当使用 pip 或其他工具安装此类包时，它会自动在模块搜索路径中。 弃用关键字有时候，可能需要用新的关键字替换现有的关键字，或者完全删除它们。仅仅通知用户这种变化可能并不总是足够的，运行时获取警告更有效。为了支持这一点，Robot Framework 具有标记关键字已弃用的能力。这使得更容易从测试数据中找到旧的关键字并删除或替换它们。 关键字可以通过在其文档开始处添加文本 DEPRECATED（区分大小写）并在文档的第一行也有一个关闭 * 来标记为已弃用。例如，DEPRECATED，DEPRECATED.* 和 DEPRECATED in version 1.5. 都是有效的标记。 当执行一个已弃用的关键字时，会记录一个弃用警告，并且警告也会显示在控制台和日志文件中的测试执行错误部分。弃用警告以文本 “Keyword ‘’ is deprecated.” 开始，并在弃用标记之后有剩余的简短文档（如果有的话）。例如，如果执行以下关键字，日志文件中将会有如下所示的警告。 123456def example_keyword(argument): &quot;&quot;&quot;*DEPRECATED!!* Use keyword `Other Keyword` instead. This keyword does something to given ``argument`` and returns results. &quot;&quot;&quot; return do_something(argument) 120080911 16:00:22.650 WARN Keyword ‘SomeLibrary.Example Keyword’ is deprecated. Use keyword `Other Keyword` instead. 这个弃用系统适用于大多数测试库，也适用于用户关键字。 动态库 API动态 API 在很多方面与静态 API 类似。例如，报告关键字状态、记录日志和返回值的工作方式完全相同。最重要的是，导入动态库和使用它们的关键字与其他库没有区别。换句话说，用户不需要知道他们的库使用的是什么 API。 静态库和动态库之间的唯一区别是 Robot Framework 如何发现库实现了哪些关键字，这些关键字有哪些参数和文档，以及如何实际执行这些关键字。在静态 API 中，所有这些都是通过反射完成的，但是动态库有一些特殊的方法用于这些目的。 动态 API 的一个好处是在组织库时有更多的灵活性。使用静态 API，必须在一个类或模块中有所有的关键字，而使用动态 API，可以例如将每个关键字实现为一个单独的类。然而，这种用例对于 Python 来说并不那么重要，因为它的动态能力和多继承已经提供了足够的灵活性，而且还有可能使用混合库 API。 动态 API 的另一个主要用例是实现一个库，使其可以作为可能在其他进程甚至其他机器上运行的实际库的代理。这种代理库可以非常薄，因为关键字名称和所有其他信息都是动态获取的，所以当在实际库中添加新的关键字时，无需更新代理。 本节解释了动态 API 如何在 Robot Framework 和动态库之间工作。对于 Robot Framework 来说，这些库是如何实际实现的（例如，如何将 run_keyword 方法的调用映射到正确的关键字实现）并不重要，有许多不同的方法是可能的。Python 用户也可能会发现 PythonLibCore 项目很有用。 获取关键字名称动态库通过 get_keyword_names 方法告诉它们实现了哪些关键字。此方法不能接受任何参数，并且必须返回一个包含库实现的关键字名称的字符串列表或数组。 如果返回的关键字名称包含多个单词，它们可以用空格或下划线分隔，或者以驼峰格式返回。例如，[‘first keyword’, ‘second keyword’]，[‘first_keyword’, ‘second_keyword’] 和 [‘firstKeyword’, ‘secondKeyword’] 都将被映射到关键字 First Keyword 和 Second Keyword。 动态库必须始终具有此方法。如果它缺失，或者由于某种原因调用它失败，库将被视为静态库。 标记要作为关键字公开的方法如果一个动态库应该包含既是关键字又是私有辅助方法的方法，那么标记关键字方法可能是明智的，这样在实现 get_keyword_names 时就更容易。robot.api.deco.keyword 装饰器允许轻松做到这一点，因为它在装饰的方法上创建了一个自定义的 ‘robot_name’ 属性。这允许在 get_keyword_names 期间只通过检查库中每个方法的 robot_name 属性来生成关键字列表。 12345678910111213141516171819from robot.api.deco import keywordclass DynamicExample: def get_keyword_names(self): # 从库中获取所有属性及其值。 attributes = [(name, getattr(self, name)) for name in dir(self)] # 过滤出没有 &#x27;robot_name&#x27; 设置的属性。 keywords = [(name, value) for name, value in attributes if hasattr(value, &#x27;robot_name&#x27;)] # 返回 &#x27;robot_name&#x27; 的值（如果给定），否则返回原始的 &#x27;name&#x27;。 return [value.robot_name or name for name, value in keywords] def helper_method(self): # ... @keyword def keyword_method(self): # ... 执行关键字动态库有一个特殊的 run_keyword（别名 runKeyword）方法用于执行它们的关键字。当在测试数据中使用来自动态库的关键字时，Robot Framework 使用 run_keyword 方法来执行它。此方法接受两个或三个参数。第一个参数是一个字符串，包含要执行的关键字的名称，格式与 get_keyword_names 返回的格式相同。第二个参数是一个列表，包含在测试数据中给关键字的位置参数，可选的第三个参数是一个包含命名参数的字典。如果缺少第三个参数，不支持自由命名参数和仅命名参数，其他命名参数映射到位置参数。 注意 在 Robot Framework 3.1 之前，无论 run_keyword 是否接受两个或三个参数，普通命名参数都映射到位置参数。第三个参数只获取可能的自由命名参数。 获取关键字名称和参数后，库可以自由地执行关键字，但必须使用与静态库相同的机制与框架进行通信。这意味着使用异常来报告关键字状态，通过写入标准输出或使用提供的日志 API 进行记录，以及在 run_keyword 中使用 return 语句返回某些内容。 每个动态库必须都有 get_keyword_names 和 run_keyword 方法，但动态 API 中的其余方法是可选的。下面的示例显示了一个工作的，尽管微不足道的，动态库。 12345678class DynamicExample: def get_keyword_names(self): return [&#x27;first keyword&#x27;, &#x27;second keyword&#x27;] def run_keyword(self, name, args, kwargs): print(&quot;Running keyword &#x27;%s&#x27; with positional arguments %s and named arguments %s.&quot; % (name, args, kwargs)) 获取关键字参数如果动态库只实现了 get_keyword_names 和 run_keyword 方法，Robot Framework 就没有关于实现的关键字接受哪些参数的任何信息。例如，在上面的示例中，First Keyword 和 Second Keyword 都可以使用任何参数。这是有问题的，因为大多数真实的关键字都期望有一定数量的关键字，在这种情况下，它们需要自己检查参数计数。 动态库可以通过使用 get_keyword_arguments（别名 getKeywordArguments）方法来通信它们的关键字期望什么参数。此方法获取关键字的名称作为参数，并且必须返回一个字符串列表，包含该关键字接受的参数。 与其他关键字一样，动态关键字可以要求任意数量的位置参数，有默认值，接受可变数量的参数，接受自由命名参数和具有仅命名参数。如何表示所有这些不同变量的语法是从 Python 中它们是如何指定的派生出来的，并在下表中进行了解释。 参数类型及其表示方式 参数类型 如何表示 示例 无参数 空列表 [] 一个或多个位置参数 包含参数名称的字符串列表 [&#39;argument&#39;][&#39;arg1&#39;, &#39;arg2&#39;, &#39;arg3&#39;] 默认值 表示参数名称和默认值的两种方式：1. 作为一个字符串，其中名称和默认值用 &#x3D; 分隔。2. 作为一个元组，其中名称和默认值作为单独的项。在 Robot Framework 3.2 中新增。 字符串与 &#x3D; 分隔符：[&#39;name=default&#39;][&#39;a&#39;, &#39;b=1&#39;, &#39;c=2&#39;]元组：[(&#39;name&#39;, &#39;default&#39;)][&#39;a&#39;, (&#39;b&#39;, 1), (&#39;c&#39;, 2)] 仅位置参数 &#x2F; 标记之前的参数。在 Robot Framework 6.1 中新增。 [&#39;posonly&#39;, &#39;/&#39;][&#39;p&#39;, &#39;q&#39;, &#39;/&#39;, &#39;normal&#39;] 可变数量的参数（varargs） 可能的位置参数之后的参数有一个 * 前缀 [&#39;*varargs&#39;][&#39;argument&#39;, &#39;*rest&#39;][&#39;a&#39;, &#39;b=42&#39;, &#39;*c&#39;] 仅命名参数 varargs 之后的参数，或者如果没有 varargs，则是一个孤立的 *。有或没有默认值。需要 run_keyword 支持仅命名参数。在 Robot Framework 3.1 中新增。 [&#39;*varargs&#39;, &#39;named&#39;][&#39;*&#39;, &#39;named&#39;][&#39;*&#39;, &#39;x&#39;, &#39;y=default&#39;][&#39;a&#39;, &#39;*b&#39;, (&#39;c&#39;, 42)] 自由命名参数（kwargs） 最后的参数有 ** 前缀。需要 run_keyword 支持自由命名参数。 [&#39;**named&#39;][&#39;a&#39;, (&#39;b&#39;, 42), &#39;**c&#39;][&#39;*varargs&#39;, &#39;**kwargs&#39;][&#39;*&#39;, &#39;kwo&#39;, &#39;**kws&#39;] ​ 执行关键字当使用 get_keyword_arguments 时，Robot Framework 会自动计算关键字需要多少个位置参数，以及是否支持自由命名参数。如果一个关键字使用了无效的参数，将会发生错误，甚至不会调用 run_keyword。 返回的实际参数名称和默认值也很重要。它们需要用于支持命名参数，Libdoc 工具需要它们来创建有意义的库文档。 如上表所述，可以通过参数名称以字符串的形式指定默认值，如 ‘name&#x3D;default’，或者以元组的形式，如 (‘name’, ‘default’)。前一种语法的主要问题是所有的默认值都被视为字符串，而后一种语法允许使用所有对象，如 (‘integer’, 1) 或 (‘boolean’, True)。当使用字符串以外的其他对象时，Robot Framework 可以根据它们进行自动参数转换。 出于一致性的原因，也可以将不接受默认值的参数指定为一个元素的元组。例如，[‘a’, ‘b&#x3D;c’, ‘d’] 和 [(‘a’,), (‘b’, ‘c’), (‘d’,)] 是等价的。 如果 get_keyword_arguments 丢失或对某个关键字返回 Python None，那么该关键字将获得一个接受所有参数的参数规范。这个自动参数规范是 [*varargs, **kwargs] 或 [*varargs]，取决于 run_keyword 是否支持自由命名参数。 注意 在 Robot Framework 3.2 中新增了将参数指定为元组，如 (‘name’, ‘default’) 的支持。在 Robot Framework 6.1 中新增了动态库 API 对仅位置参数的支持。 获取关键字参数类型Robot Framework 3.1 引入了对自动参数转换的支持，动态库 API 也支持这一点。转换逻辑与静态库完全相同，但指定类型信息的方式自然是不同的。 对于动态库，可以使用可选的 get_keyword_types 方法（别名 getKeywordTypes）返回类型。它可以使用列表或字典返回类型，就像使用 @keyword 装饰器时可以指定类型一样。类型信息可以使用实际类型（如 int）来指定，但特别是如果动态库从外部系统获取此信息，使用字符串（如 ‘int’ 或 ‘integer’）可能更容易。有关支持的类型以及如何指定它们的更多信息，请参见 “支持的转换” 部分。 Robot Framework 也会根据参数默认值进行自动参数转换。此前，这在动态 API 中无法工作，因为只能将参数指定为字符串。如前一节所述，这在 Robot Framework 3.2 中发生了变化，现在像 (‘example’, True) 这样返回的默认值会自动用于此目的。 从 Robot Framework 7.0 开始，动态库还可以通过在返回的类型字典中使用键 ‘return’ 和适当的类型来指定关键字返回类型。这个信息在执行期间不用于任何事情，但是它会被 Libdoc 显示出来，用于文档目的。 获取关键字标签动态库可以通过使用 get_keyword_tags 方法（别名 getKeywordTags）报告关键字标签。它获取一个关键字名称作为参数，并应返回相应的标签作为字符串列表。 另外，也可以在由下面讨论的 get_keyword_documentation 方法返回的文档的最后一行上指定标签。这需要在最后一行开始时使用 Tags: 并在其后列出标签，如 Tags: first tag, second, third。 信息 get_keyword_tags 方法保证在 get_keyword_documentation 方法之前被调用。这使得只有在 get_keyword_tags 方法未被调用时，才能轻松地将标签嵌入到文档中。 获取关键字文档如果动态库想要提供关键字文档，它们可以实现 get_keyword_documentation 方法（别名 getKeywordDocumentation）。它接受一个关键字名称作为参数，并且，如方法名称所示，返回其文档作为字符串。 返回的文档与静态库中的关键字文档字符串的使用方式相同。主要的用例是将关键字的文档获取到由 Libdoc 生成的库文档中。此外，文档的第一行（直到第一个 \\n）显示在测试日志中。 获取通用库文档get_keyword_documentation 方法也可以用于指定整体库文档。这个文档在测试执行时不使用，但它可以使由 Libdoc 生成的文档更好。 动态库可以提供通用库文档和与使用库相关的文档。前者是通过调用 get_keyword_documentation 与特殊值 __intro__ 获得的，后者是使用值 __init__ 获得的。如何呈现文档最好在实践中使用 Libdoc 进行测试。 动态库还可以直接在代码中指定通用库文档，作为库类和其 __init__ 方法的 docstring。如果直接从代码和 get_keyword_documentation 方法中获取了非空文档，后者优先。 获取关键字源信息动态 API 遮蔽了 Robot Framework 的关键字的实际实现，因此无法看到关键字是在哪里实现的。这意味着编辑器和其他使用 Robot Framework API 的工具无法实现如 go-to-definition 等功能。这个问题可以通过实现另一个可选的动态方法 get_keyword_source（别名 getKeywordSource）来解决，该方法返回源信息。 get_keyword_source 方法的返回值必须是一个字符串，或者如果没有源信息可用，则为 None。在简单的情况下，只需简单地返回实现关键字的文件的绝对路径即可。如果知道关键字实现开始的行号，可以将其嵌入到返回值中，如 path:lineno。只返回行号也是可能的，如 :lineno。 库本身的源信息是从导入的库类中自动获取的，与其他库 API 的方式相同。库源路径用于所有没有定义自己的源路径的关键字。 注意 为关键字返回源信息是 Robot Framework 3.2 中的新功能。 动态库中的命名参数语法动态库 API 也支持命名参数语法。使用语法是基于从库使用 get_keyword_arguments 方法获取的参数名称和默认值。 如果 run_keyword 方法接受三个参数，第二个参数获取所有位置参数作为列表，最后一个参数获取所有命名参数作为映射。如果它只接受两个参数，命名参数被映射到位置参数。在后一种情况下，如果一个关键字有多个带有默认值的参数，并且只给出了后面的一些参数，那么框架会根据 get_keyword_arguments 方法返回的默认值填充跳过的可选参数。 以下示例说明了如何使用动态库中的命名参数语法。所有示例都使用一个关键字 Dynamic，它有一个参数规范 [a, b&#x3D;d1, c&#x3D;d2]。每行的注释显示了在这些情况下如何调用 run_keyword，如果它有两个参数（即签名是 name, args）以及如果它有三个参数（即 name, args, kwargs）。 1234567891011121314151617*** 测试用例 *** # args # args, kwargs仅位置参数 Dynamic x # [x] # [x], &#123;&#125; Dynamic x y # [x, y] # [x, y], &#123;&#125; Dynamic x y z # [x, y, z] # [x, y, z], &#123;&#125;仅命名参数 Dynamic a=x # [x] # [], &#123;a: x&#125; Dynamic c=z a=x b=y # [x, y, z] # [], &#123;a: x, b: y, c: z&#125;位置和命名参数 Dynamic x b=y # [x, y] # [x], &#123;b: y&#125; Dynamic x y c=z # [x, y, z] # [x, y], &#123;c: z&#125; Dynamic x b=y c=z # [x, y, z] # [x], &#123;y: b, c: z&#125;中间缺失 Dynamic x c=z # [x, d1, z] # [x], &#123;c: z&#125; 注意 在 Robot Framework 3.1 之前，所有正常的命名参数都被映射到位置参数，可选的 kwargs 只用于自由命名参数。在上述示例中，run_keyword 始终像现在如果不支持 kwargs 那样被调用。 动态库中的自由命名参数动态库也可以支持自由命名参数（**named）。这种支持的强制前提条件是 run_keyword 方法接受三个参数：第三个参数将获取自由命名参数以及可能的其他命名参数。这些参数作为映射传递给关键字。 关键字接受哪些参数取决于 get_keyword_arguments 为它返回什么。如果最后一个参数以 ** 开头，那么该关键字被认为接受自由命名参数。 以下示例说明了如何使用动态库中的自由命名参数语法。所有示例都使用一个关键字 Dynamic，它的参数规范是 [a&#x3D;d1, b&#x3D;d2, **named]。注释显示了实际调用 run_keyword 方法的参数。 12345678910111213141516171819*** 测试用例 *** # args, kwargs无参数 Dynamic # [], &#123;&#125;仅位置参数 Dynamic x # [x], &#123;&#125; Dynamic x y # [x, y], &#123;&#125;仅自由命名参数 Dynamic x=1 # [], &#123;x: 1&#125; Dynamic x=1 y=2 z=3 # [], &#123;x: 1, y: 2, z: 3&#125;位置和自由命名参数 Dynamic x y=2 # [x], &#123;y: 2&#125; Dynamic x y=2 z=3 # [x], &#123;y: 2, z: 3&#125;位置作为命名和自由命名参数 Dynamic a=1 x=1 # [], &#123;a: 1, x: 1&#125; Dynamic b=2 x=1 a=1 # [], &#123;a: 1, b: 2, x: 1&#125; 注意 在 Robot Framework 3.1 之前，所有正常的命名参数都被映射到位置参数，但现在它们是 kwargs 的一部分，与自由命名参数一起。 动态库中的仅命名参数从 Robot Framework 3.1 开始，动态库可以有仅命名参数。这需要 run_keyword 方法接受三个参数：第三个参数获取仅命名参数以及其他命名参数。 在 get_keyword_arguments 方法返回的参数规范中，仅命名参数在可能的可变数量的参数（varargs）之后指定，或者如果关键字不接受 varargs，则在一个孤立的星号（）之后指定。仅命名参数可以有默认值，有默认值和没有默认值的参数的顺序无关紧要。 以下示例说明了如何使用动态库中的仅命名参数语法。所有示例都使用一个关键字 Dynamic，它被指定为具有参数规范 [positional&#x3D;default, *varargs, named, named2&#x3D;default, **free]。注释显示了实际调用 run_keyword 方法的参数。 123456789101112131415*** 测试用例 *** # args, kwargs仅命名参数 Dynamic named=value # [], &#123;named: value&#125; Dynamic named=value named2=2 # [], &#123;named: value, named2: 2&#125;命名参数与位置和 varargs Dynamic argument named=xxx # [argument], &#123;named: xxx&#125; Dynamic a1 a2 named=3 # [a1, a2], &#123;named: 3&#125;位置作为命名的命名参数 Dynamic named=foo positional=bar # [], &#123;positional: bar, named: foo&#125;命名参数与自由命名参数 Dynamic named=value foo=bar # [], &#123;named: value, foo: bar&#125; Dynamic named2=2 third=3 named=1 # [], &#123;named: 1, named2: 2, third: 3&#125; 总结下表列出了动态 API 中的所有特殊方法。方法名称以下划线格式列出，但它们的驼峰别名的工作方式完全相同。 动态 API 中的所有特殊方法 名称 参数 目的 get_keyword_names 无 返回实现的关键字的名称。 run_keyword name, arguments, kwargs 使用给定的参数执行指定的关键字。kwargs 是可选的。 get_keyword_arguments name 返回关键字的参数规范。可选方法。 get_keyword_types name 返回关键字的参数类型信息。可选方法。在 RF 3.1 中新增。 get_keyword_tags name 返回关键字的标签。可选方法。 get_keyword_documentation name 返回关键字和库的文档。可选方法。 get_keyword_source name 返回关键字的源。可选方法。在 RF 3.2 中新增。 使用动态 API 的一个好例子是 Robot Framework 自己的 Remote 库。 注意 从 Robot Framework 7.0 开始，动态库可以有它们的特殊方法的异步实现。 混合库 API混合库 API，顾名思义，是静态 API 和动态 API 的混合。就像动态 API 一样，只使用混合 API 也可以实现一个库。 获取关键字名称获取关键字名称的方式与动态 API 完全相同。实际上，库需要有 get_keyword_names 或 getKeywordNames 方法，返回库实现的关键字名称的列表。 运行关键字在混合 API 中，没有 run_keyword 方法用于执行关键字。相反，Robot Framework 使用反射来查找实现关键字的方法，这与静态 API 类似。使用混合 API 的库可以直接实现这些方法，更重要的是，它可以动态地处理它们。 在 Python 中，使用 __getattr__ 方法动态处理缺失的方法很容易。这个特殊方法可能对大多数 Python 程序员来说都很熟悉，他们可以立即理解以下示例。其他人可能会发现先查阅 Python 参考手册更容易。 1234567891011121314from somewhere import external_keywordclass HybridExample: def get_keyword_names(self): return [&#x27;my_keyword&#x27;, &#x27;external_keyword&#x27;] def my_keyword(self, arg): print(&quot;My Keyword called with &#x27;%s&#x27;&quot; % arg) def __getattr__(self, name): if name == &#x27;external_keyword&#x27;: return external_keyword raise AttributeError(&quot;Non-existing attribute &#x27;%s&#x27;&quot; % name) 注意，__getattr__ 不像动态 API 中的 run_keyword 那样执行实际的关键字。相反，它只返回一个可调用的对象，然后由 Robot Framework 执行。 另一个需要注意的点是，Robot Framework 使用从 get_keyword_names 返回的相同名称来查找实现它们的方法。因此，类本身实现的方法的名称必须以与它们定义的相同的格式返回。例如，如果 get_keyword_names 返回 My Keyword 而不是 my_keyword，那么上面的库将无法正确工作。 获取关键字参数和文档当使用此 API 时，Robot Framework 使用反射来查找实现关键字的方法，这与静态 API 类似。获取到方法的引用后，它会以与使用静态 API 相同的方式从中搜索参数和文档。因此，没有必要像动态 API 那样有获取参数和文档的特殊方法。 总结在实现测试库时，混合 API 具有与实际动态 API 相同的动态能力。它的一个很大的好处是，不需要有获取关键字参数和文档的特殊方法。通常，只有真正的动态关键字需要在 __getattr__ 中处理，其他的可以直接在主库类中实现。 由于明显的优势和相等的能力，混合 API 在大多数情况下都是比动态 API 更好的选择。一个值得注意的例外是将库实现为代理实际库实现的地方，因为那时实际的关键字必须在其他地方执行，代理只能向前传递关键字名称和参数。 使用混合 API 的一个好例子是 Robot Framework 自己的 Telnet 库。 使用 Robot Framework 的内部模块测试库可以使用 Robot Framework 的内部模块，例如，获取有关执行的测试和使用的设置的信息。然而，应谨慎使用这种与框架通信的强大机制，因为并非所有的 Robot Framework 的 API 都是为外部使用而设计的，它们可能会在不同的框架版本之间发生根本性的变化。 可用的 APIAPI 文档在优秀的 Read the Docs 服务上单独托管。如果不确定如何使用某个 API 或者它是否具有向前兼容性，请向邮件列表发送问题。 使用 BuiltIn 库最安全的 API 是在 BuiltIn 库中实现关键字的方法。关键字的更改很少，它们总是首先弃用旧的用法。最有用的方法之一是 replace_variables，它允许访问当前可用的变量。下面的示例演示了如何获取 ${OUTPUT_DIR}，这是许多方便的自动变量之一。也可以使用 set_test_variable，set_suite_variable 和 set_global_variable 从库中设置新的变量。 12345678910111213import os.pathfrom robot.libraries.BuiltIn import BuiltIndef do_something(argument): builtin = BuiltIn() output = do_something_that_creates_a_lot_of_output(argument) if builtin.robot_running: output_dir = builtin.replace_variables(&#x27;$&#123;OUTPUT_DIR&#125;&#x27;) else: output_dir = &#x27;.&#x27; with open(os.path.join(output_dir, &#x27;output.txt&#x27;), &#x27;w&#x27;) as file: file.write(output) print(&#x27;*HTML* Output written to &lt;a href=&quot;output.txt&quot;&gt;output.txt&lt;/a&gt;&#x27;) 如上例所示，BuiltIn 还有一个方便的 robot_running 属性，用于检测 Robot Framework 是否正在运行。 使用 BuiltIn 的方法的唯一问题是，所有 run_keyword 方法的变体都必须特别处理。使用 run_keyword 方法的方法必须使用 BuiltIn 模块中的 register_run_keyword 方法将自己注册为运行关键字。这个方法的文档解释了为什么需要这样做，显然也解释了如何做。 扩展现有的测试库本节解释了如何向现有测试库添加新功能以及如何在自己的库中使用它们的不同方法。 修改原始源代码如果可以访问想要扩展的库的源代码，可以直接修改源代码。这种方法的最大问题是，可能很难更新原始库而不影响更改。对于用户来说，使用具有与原始库不同功能的库可能也会令人困惑。重新打包库也可能是一个大的额外任务。 如果增强功能是通用的，并且计划将它们提交给原始开发人员，那么这种方法将非常有效。如果的更改被应用到原始库，它们将被包含在未来的版本中，并且上述所有问题都将得到缓解。如果更改是非通用的，或者由于某种原因无法提交它们，那么可能在接下来的部分中解释的方法会更好。 使用继承扩展现有库的另一种直接方法是使用继承。下面的示例说明了如何向 SeleniumLibrary 添加新的 Title Should Start With 关键字。 1234567891011from SeleniumLibrary import SeleniumLibraryfrom SeleniumLibrary.base import keywordclass ExtendedSeleniumLibrary(SeleniumLibrary): @keyword def title_should_start_with(self, expected): title = self.get_title() if not title.startswith(expected): raise AssertionError(&quot;Title &#x27;%s&#x27; did not start with &#x27;%s&#x27;&quot; % (title, expected)) 与修改原始库相比，这种方法的一个大的区别是新库的名称与原始库不同。一个好处是可以轻松地告诉正在使用一个自定义库，但一个大问题是不能轻易地使用原始库和新库。首先，新库将具有与原始库相同的关键字，这意味着总是存在冲突。另一个问题是库不共享它们的状态。 当开始使用一个新库并希望从一开始就向它添加自定义增强时，这种方法效果很好。否则，本节中解释的其他机制可能会更好。 直接使用其他库因为测试库在技术上只是类或模块，所以使用另一个库的简单方法是导入它并使用它的方法。当方法是静态的并且不依赖于库状态时，这种方法非常有效。这由早期使用 Robot Framework 的 BuiltIn 库的示例所说明。 然而，如果库有状态，事情可能不会按照希望的方式工作。在库中使用的库实例与框架使用的不是同一个，因此执行的关键字所做的更改对库不可见。下一节将解释如何获取对框架使用的同一库实例的访问权限。 从 Robot Framework 获取活动库实例可以使用 BuiltIn 关键字 Get Library Instance 从框架本身获取当前活动的库实例。此关键字返回的库实例与框架本身使用的相同，因此看到正确的库状态没有问题。尽管这个功能作为关键字可用，但通常在测试库中直接通过导入 BuiltIn 库类来使用。下面的示例说明了如何实现与早期关于使用继承的示例中相同的 Title Should Start With 关键字。 12345678from robot.libraries.BuiltIn import BuiltIndef title_should_start_with(expected): seleniumlib = BuiltIn().get_library_instance(&#x27;SeleniumLibrary&#x27;) title = seleniumlib.get_title() if not title.startswith(expected): raise AssertionError(&quot;Title &#x27;%s&#x27; did not start with &#x27;%s&#x27;&quot; % (title, expected)) 当库有状态时，这种方法显然比直接导入库并使用它更好。相对于继承，最大的好处是可以正常使用原始库，并在需要时使用新库。这在下面的示例中得到了证明，其中预期在新库 SeLibExtensions 中可以使用前面示例中的代码。 12345678*** Settings ***Library SeleniumLibraryLibrary SeLibExtensions*** Test Cases ***Example Open Browser http://example # SeleniumLibrary Title Should Start With Example # SeLibExtensions 使用动态或混合 API 的库使用动态或混合库 API 的测试库通常有自己的系统来扩展它们。对于这些库，需要向库开发人员询问指导，或者查阅库文档或源代码。 远程库接口远程库接口提供了在 Robot Framework 运行的机器上有测试库的方法，也为使用原生支持的 Python 以外的其他语言实现库提供了方法。对于测试库，用户远程库看起来几乎与任何其他测试库一样，使用远程库接口开发测试库也非常接近创建普通测试库。 介绍使用远程库 API 的两个主要原因： 可以在 Robot Framework 运行的机器上有实际的库。这为分布式测试提供了有趣的可能性。 测试库可以使用支持 XML-RPC 协议的任何语言来实现。存在为各种语言（如 Python、Java、Ruby、.NET 等）准备的通用远程服务器。 远程库接口由 Remote 库提供，这是标准库之一。这个库本身没有任何关键字，但它作为核心框架和其他地方实现的关键字之间的代理。Remote 库通过远程服务器与实际库实现进行交互，Remote 库和服务器使用 XML-RPC 通道上的简单远程协议进行通信。所有这些的高级架构在下面的图片中进行了说明： 注意 远程客户端使用 Python 的标准 XML-RPC 模块。它不支持一些 XML-RPC 服务器实现的自定义 XML-RPC 扩展。 使用 Remote 库导入 Remote 库Remote 库需要知道远程服务器的地址，但是导入它和使用它提供的关键字与使用其他库没有什么不同。如果需要在一个套件中多次使用 Remote 库，或者只是想给它一个更具描述性的名称，可以在导入时给它一个别名。 1234*** 设置 ***库 Remote http://127.0.0.1:8270 AS Example1库 Remote http://example.com:8080/ AS Example2库 Remote http://10.0.0.2/example 1 minute AS Example3 上面的第一个示例使用的 URL 也是 Remote 库在没有给定地址时使用的默认地址。 上面的最后一个示例显示了如何给 Remote 库提供一个自定义超时作为可选的第二个参数。当最初连接到服务器时以及如果连接意外关闭时，将使用超时。超时可以以 Robot Framework 时间格式给出，如 60s 或 2 分钟 10 秒。默认超时通常是几分钟，但它取决于操作系统及其配置。注意，如果设置的超时比关键字执行时间短，将中断关键字。 注意 端口 8270 是远程服务器预期使用的默认端口，已由 IANA 为此目的注册。选择这个端口号是因为 82 和 70 分别是字母 R 和 F 的 ASCII 码。 当连接到本地机器时，建议使用 IP 地址 127.0.0.1 而不是机器名 localhost。这样可以避免地址解析，至少在 Windows 上可能非常慢。 如果 URI 在服务器地址后没有路径，Remote 库使用的 XML-RPC 模块将默认使用 &#x2F;RPC2 路径。实际上，使用 http://127.0.0.1:8270 与使用 http://127.0.0.1:8270/RPC2 是相同的。这可能会或可能不会成为问题，具体取决于远程服务器。如果地址有路径，即使路径只是 &#x2F;，也不会添加额外的路径。例如，http://127.0.0.1:8270/ 和 http://127.0.0.1:8270/my/path 都不会被修改。 启动和停止远程服务器在可以导入 Remote 库之前，必须启动提供实际关键字的远程服务器。如果在启动测试执行之前启动了服务器，那么可以像上面的示例那样使用正常的库设置。或者，其他关键字，例如来自 Process 或 SSH 库的关键字，可以启动服务器，但是可能需要使用 Import Library 关键字，因为当测试执行开始时，库不可用。 如何停止远程服务器取决于它是如何实现的。通常，服务器支持以下方法： 无论使用哪个库，远程服务器都应提供 Stop Remote Server 关键字，以便执行的测试可以轻松使用。 远程服务器应在其 XML-RPC 接口中有 stop_remote_server 方法。 在运行服务器的控制台上按 Ctrl-C 应该可以停止服务器。 可以使用操作系统提供的工具终止服务器进程（例如 kill）。 注意 服务器可能被配置为用户不能使用 Stop Remote Server 关键字或 stop_remote_server 方法来停止它。 支持的参数和返回值类型由于 XML-RPC 协议不支持所有可能的对象类型，因此必须将 Remote 库和远程服务器之间传输的值转换为兼容的类型。这适用于 Remote 库传递给远程服务器的关键字参数以及服务器返回给 Remote 库的返回值。 Remote 库和 Python 远程服务器都按照以下规则处理 Python 值。其他远程服务器应该有类似的行为。 字符串、数字和布尔值在传递时不做修改。 Python 的 None 被转换为一个空字符串。 所有列表、元组和其他可迭代对象（除字符串和字典外）都作为列表传递，以便递归地转换它们的内容。 字典和其他映射作为字典传递，以便将它们的键转换为字符串，递归地将值转换为支持的类型。 返回的字典被转换为所谓的点可访问字典，允许使用扩展变量语法像 {result.key} 这样访问键作为属性。这也适用于嵌套字典，如result.key这样访问键作为属性。这也适用于嵌套字典，如{root.child.leaf}。 包含不能在 XML 中表示的 ASCII 范围内的字节的字符串被发送为 Binary 对象，该对象在内部使用 XML-RPC base64 数据类型。接收到的 Binary 对象自动转换为字节字符串。 其他类型被转换为字符串。 远程协议本节解释了 Remote 库和远程服务器之间使用的协议。这些信息主要针对希望创建新的远程服务器的人。 远程协议是在 XML-RPC 之上实现的，XML-RPC 是一种使用 XML 在 HTTP 上的简单远程过程调用协议。大多数主流语言（Python、Java、C、Ruby、Perl、Javascript、PHP等）都内置或作为扩展支持 XML-RPC。 Python 远程服务器可以作为参考实现。 必需的方法远程服务器提供关于它们包含的关键字的信息有两种可能性。下面简要解释了这些方法，并在后续部分中进行了更详细的文档记录。 远程服务器可以实现动态库 API 具有的相同方法。这意味着 get_keyword_names 方法和可选的 get_keyword_arguments、get_keyword_types、get_keyword_tags 和 get_keyword_documentation 方法。注意，像 getKeywordNames 这样使用 “驼峰命名” 是不可能的，就像在正常的动态 API 中一样。 从 Robot Framework 4.0 开始，远程服务器可以有一个 get_library_information 方法，该方法返回一个字典，其中包含所有库和关键字信息。如果远程服务器有这个方法，那么像 get_keyword_names 这样的其他 getter 方法将根本不会被使用。这种方法的好处是只需要一个 XML-RPC 调用就可以获取信息，而上面解释的方法需要每个关键字进行几次调用。对于更大的库，差异可能很大。 无论远程服务器如何提供关于它们的关键字的信息，它们都必须有 run_keyword 方法，当执行关键字时使用。实际关键字如何实现对 Remote 库来说并不重要。远程服务器可以像可用的通用远程服务器那样作为真实测试库的包装器，也可以自己实现关键字。 远程服务器还应在其公共接口中有 stop_remote_server 方法以方便停止它们。他们还应该自动将此方法作为 Stop Remote Server 关键字暴露出来，以允许在测试数据中使用它，无论测试库是什么。允许用户停止服务器并不总是可取的，服务器可能支持以某种方式禁用此功能。该方法，以及暴露的关键字，应该根据是否允许停止返回 True 或 False。这使得外部工具可以知道是否成功停止了服务器。 使用 get_keyword_names 和特定于关键字的 getter本节解释了当服务器实现 get_keyword_names 时，Remote 库如何获取关键字名称和其他信息。下一节将介绍使用较新的 get_library_info 方法。 get_keyword_names 方法必须返回服务器包含的关键字的名称，作为字符串列表。远程服务器也可以（并且应该）实现 get_keyword_arguments、get_keyword_types、get_keyword_tags 和 get_keyword_documentation 方法，以提供有关关键字的更多信息。所有这些方法都以关键字的名称作为参数，它们必须返回的内容在下表中进行了解释。 关键字特定的 getter 方法 方法 返回值 get_keyword_arguments 以与动态库相同的格式返回字符串列表形式的参数。 get_keyword_types 类型信息，以字符串列表或字典形式返回。详情请参见下文。 get_keyword_documentation 文档，以字符串形式返回。 get_keyword_tags 标签，以字符串列表形式返回。 用于参数转换的类型信息可以以列表形式返回，基于位置将类型名称映射到参数，也可以直接以字典形式返回，将参数名称映射到类型名称。实际上，这与使用普通库中的 @keyword 装饰器指定类型的方式相同。区别在于，因为 XML-RPC 协议不支持任意值，所以需要使用类型名称或别名（如 ‘int’ 或 ‘integer’）来指定类型信息，而不是使用实际类型（如 int）。此外，XML-RPC 服务器可能不允许 None 或 null 值，但可以使用空字符串来表示某个参数没有类型信息。 也支持基于默认值的参数转换，使用与普通库相同的逻辑。为了使这个工作，具有默认值的参数必须以元组的形式返回，而不是字符串，就像动态库一样。例如，如果参数信息返回的是 [(‘count’, 1), (‘caseless’, True)]，那么参数转换就会起作用，但如果是 [‘count&#x3D;1’, ‘caseless&#x3D;True’]，则不会起作用。 远程服务器还可以提供通用库文档，用于使用 Libdoc 工具生成文档。通过调用 get_keyword_documentation 并使用特殊值 __intro__ 和 __init__ 来获取这些信息。 注意 get_keyword_types 是在 Robot Framework 3.1 中新增的，基于默认值的参数转换支持是在 Robot Framework 4.0 中新增的。 使用 get_library_informationget_library_information 方法允许在一个 XML-RPC 调用中返回整个库的信息。信息必须以字典的形式返回，其中键是关键字名称，值是包含关键字信息的嵌套字典。字典也可以包含用于通用库信息的单独条目。 关键字信息字典可以包含关键字参数、文档、标签和类型，相应的键是 args、doc、tags 和 types。信息必须使用与前一节中讨论的 get_keyword_arguments、get_keyword_documentation、get_keyword_tags 和 get_keyword_types 相同的语义提供。如果某些信息不可用，可以从 info 字典中完全省略。 get_library_information 还支持返回用于 Libdoc 的通用库文档。这是通过在返回的库信息字典中包含特殊的 __intro__ 和 __init__ 条目来完成的。 例如，一个 Python 库如下： 1234567891011&quot;&quot;&quot;库文档。&quot;&quot;&quot;from robot.api.deco import keyword@keyword(tags=[&#x27;x&#x27;, &#x27;y&#x27;])def example(a: int, b=True): &quot;&quot;&quot;关键字文档。&quot;&quot;&quot; passdef another(): pass 可以映射到这种类型的库信息字典： 12345678&#123; &#x27;__intro__&#x27;: &#123;&#x27;doc&#x27;: &#x27;库文档&#x27;&#125; &#x27;example&#x27;: &#123;&#x27;args&#x27;: [&#x27;a&#x27;, &#x27;b=True&#x27;], &#x27;types&#x27;: [&#x27;int&#x27;], &#x27;doc&#x27;: &#x27;关键字文档。&#x27;, &#x27;tags&#x27;: [&#x27;x&#x27;, &#x27;y&#x27;]&#125; &#x27;another: &#123;&#x27;args&#x27;: []&#125;&#125; 注意 get_library_information 是在 Robot Framework 4.0 中新增的。 ​ 执行远程关键字当 Remote 库希望服务器执行某个关键字时，它会调用远程服务器的 run_keyword 方法，并传递关键字名称、参数列表，以及可能的自由命名参数字典。基本类型可以直接作为参数使用，但更复杂的类型需要转换为支持的类型。 服务器必须在结果字典（或映射，取决于术语）中返回执行的结果，该字典包含以下表格中解释的项目。注意，只有状态条目是必需的，如果其他条目不适用，可以省略。 远程结果字典中的条目 名称 解释 status 必需的执行状态。可以是 PASS 或 FAIL。 output 可能写入日志文件的输出。必须以单个字符串给出，但可以包含多个消息和不同的日志级别，格式为 INFO First message\\nHTML 2nd\\nWARN Another message。也可以将时间戳嵌入到日志消息中，如 INFO:1308435758660 Message with timestamp。 return 可能的返回值。必须是支持的类型之一。 error 可能的错误消息。仅在执行失败时使用。 traceback 可能的堆栈跟踪，当执行失败时，使用 DEBUG 级别写入日志文件。 continuable 当设置为 True，或者在 Python 中被认为是 True 的任何值，发生的失败被认为是可继续的。 fatal 像 continuable，但表示发生的失败是致命的。 不同的参数语法Remote 库是一个动态库，通常，它根据与任何其他动态库相同的规则处理不同的参数语法。这包括必需的参数、默认值、varargs，以及命名参数语法。 自由命名参数（**kwargs）也大多数情况下与其他动态库的工作方式相同。首先，get_keyword_arguments 必须返回一个包含 **kwargs 的参数规范，就像任何其他动态库一样。主要的区别在于，远程服务器的 run_keyword 方法必须有一个可选的第三个参数，用于获取用户指定的 kwargs。第三个参数必须是可选的，因为出于向后兼容性的原因，Remote 库只有在测试数据中使用了 kwargs 时，才会将 kwargs 传递给 run_keyword 方法。 实际上，run_keyword 应该看起来像下面的 Python 和 Java 示例，具体取决于语言如何处理可选参数。 123456789def run_keyword(name, args, kwargs=None): # ...public Map run_keyword(String name, List args) &#123; // ...&#125;public Map run_keyword(String name, List args, Map kwargs) &#123; // ...&#125; ​ 监听器接口Robot Framework 的监听器接口提供了一个强大的机制，用于在执行过程中获取通知以及检查和修改数据和结果。例如，当套件、测试和关键字开始和结束时，当输出文件准备好时，以及最后整个执行结束时，都会调用监听器。示例用途包括与外部测试管理系统通信，当测试失败时发送消息，以及在执行过程中修改测试。 监听器以具有某些特殊方法的类或模块的形式实现。它们可以从命令行中使用，并由库注册。前者的监听器在整个执行过程中都是活动的，而后者只在执行注册它们的库的套件时活动。 有两种支持的监听器接口版本，监听器版本 2 和监听器版本 3。它们的方法大致相同，但这些方法被调用时的参数不同。新的监听器版本 3 更强大，通常推荐使用。 监听器结构监听器以与库类似的方式实现为模块或类。它们可以实现某些命名的钩子方法，具体取决于它们对哪些事件感兴趣。例如，如果监听器希望在测试开始时收到通知，它可以实现 start_test 方法。如后续部分所述，不同的监听器版本有稍微不同的可用方法集，它们也被调用时的参数不同。 1234567# 使用监听器 API 版本 3 实现的模块监听器。def start_suite(data, result): print(f&quot;Suite &#x27;&#123;data.name&#125;&#x27; starting.&quot;)def end_test(data, result): print(f&quot;Test &#x27;&#123;result.name&#125;&#x27; ended with status &#123;result.status&#125;.&quot;) 监听器不需要实现任何显式接口，只需简单地实现所需的方法，它们将被自动识别。然而，有基类 robot.api.interfaces.ListenerV2 和 robot.api.interfaces.ListenerV3 可以用来在编辑器中获取方法名称完成、类型提示等。 123456789101112# 与上面的示例相同，但使用了可选的基类和类型提示。from robot import result, runningfrom robot.api.interfaces import ListenerV3class Example(ListenerV3): def start_suite(self, data: running.TestSuite, result: result.TestSuite): print(f&quot;Suite &#x27;&#123;data.name&#125;&#x27; starting.&quot;) def end_test(self, data: running.TestCase, result: result.TestCase): print(f&quot;Test &#x27;&#123;result.name&#125;&#x27; ended with status &#123;result.status&#125;.&quot;) 注意 可选的监听器基类是在 Robot Framework 6.1 中新增的。 除了使用 “蛇形命名法”（如 start_test）与监听器方法名称外，还可以使用 “驼峰命名法”（如 startTest）。当可以在 Jython 上运行 Robot Framework 并使用 Java 实现监听器时，添加了此支持。出于向后兼容性的原因，它被保留下来，但不推荐在新的监听器中使用。 监听器接口版本有两个支持的监听器接口版本，版本号分别为 2 和 3。监听器可以通过具有值 2 或 3 的 ROBOT_LISTENER_API_VERSION 属性来指定要使用的版本。从 Robot Framework 7.0 开始，如果未指定版本，则默认使用监听器版本 3。 监听器版本 2 和监听器版本 3 的方法大致相同，但传递给这些方法的参数不同。给监听器 2 方法的参数是字符串和包含执行信息的字典。可以检查和进一步发送此信息，但无法直接修改它。监听器 3 方法获取 Robot Framework 本身使用的相同模型对象，这些模型对象可以被检查和修改。 监听器版本 3 比较旧的监听器版本 2 更强大，通常推荐使用。 监听器版本 2使用监听器 API 版本 2 的监听器在执行过程中会收到关于各种事件的通知，但它们无法访问实际执行的测试，因此无法直接影响执行或创建的结果。 API 版本 2 中的监听器方法列在下面的表格和可选的 ListenerV2 基类的 API 文档中。所有与测试执行进度相关的方法都有相同的签名 method(name, attributes)，其中 attributes 是一个包含事件详细信息的字典。监听器方法可以自由地处理它们接收到的信息，但不能直接更改它。如果需要，可以使用监听器版本 3。 方法 参数 文档说明描述 start_suite name, attributes 当测试套件开始时调用。包含以下属性字典内容：id: 套件id，如顶级套件为s1，第一个子套件为s1-s1，以此类推。longname: 包含父套件的套件名称。doc: 套件文档。metadata: 自由套件元数据，以字典形式。source: 套件创建来源的文件&#x2F;目录的绝对路径。suites: 此套件具有的直接子套件的名称列表。totaltests: 此套件及其所有子套件中测试的总数，以整数形式。starttime: 套件执行开始时间。 end_suite name, attributes 当测试套件结束时调用。包含以下属性字典内容：id: 同start_suite。longname: 同start_suite。doc: 同start_suite。metadata: 同start_suite。source: 同start_suite。starttime: 同start_suite。endtime: 套件执行结束时间。elapsedtime: 总执行时间，以毫秒为单位的整数。status: 套件状态，为字符串PASS、FAIL或SKIP。statistics: 套件的统计信息，包括通过和未通过测试的数量，以字符串形式。message: 如果套件设置或拆卸失败的错误信息，否则为空。 start_test name, attributes 当测试用例开始时调用。包含以下属性字典内容：id: 测试id，格式如s1-s2-t2，其中开头是父套件id，最后一部分显示该套件中的测试索引。longname: 包括父套件的测试名称。originalname: 可能未解析变量的测试名称。RF 3.2新功能。doc: 测试文档。tags: 测试标签，为字符串列表。template: 用于测试的模板名称。如果测试未模板化，则为空字符串。source: 测试用例源文件的绝对路径。RF 4.0新功能。lineno: 测试在源文件中开始的行号。RF 3.2新功能。starttime: 测试执行开始时间。 end_test name, attributes 当测试用例结束时调用。包含以下属性字典内容：id: 与start_test相同。longname: 与start_test相同。originalname: 与start_test相同。doc: 与start_test相同。tags: 与start_test相同。template: 与start_test相同。source: 与start_test相同。lineno: 与start_test相同。starttime: 与start_test相同。endtime: 测试执行结束时间。elapsedtime: 总执行时间，以毫秒为单位的整数。status: 测试状态，为字符串PASS、FAIL或SKIP。message: 状态消息。通常是错误消息或空字符串。 start_keyword name, attributes 当一个关键字或一个控制结构（如 IF&#x2F;ELSE 或 TRY&#x2F;EXCEPT）开始时调用:对于关键字，name 是完整的关键字名称，包含可能的库或资源名称作为前缀，如 MyLibrary.Example Keyword。对于控制结构，name 包含参数的字符串表示。关键字和控制结构共享大部分属性，但控制结构可以根据其类型具有额外的属性。共享属性： type: 指定开始项类型的字符串。可能的值有：KEYWORD、SETUP、TEARDOWN、FOR、WHILE、ITERATION、IF、ELSE IF、ELSE、TRY、EXCEPT、FINALLY、VAR、RETURN、BREAK、CONTINUE 和 ERROR。所有类型值在 RF 4.0 中改变，在 RF 5.0 中 FOR ITERATION 被改为 ITERATION。 kwname: 关键字名称，不包含库或资源前缀。控制结构的参数的字符串表示。 libname: 关键字所属的库或资源文件的名称。在测试用例文件中的用户关键字和控制结构中为空字符串。doc: 关键字文档。args: 关键字的参数，以字符串列表形式。assign: 关键字返回值被赋值的变量名称列表。tags: 关键字标签，以字符串列表形式。source: 使用关键字的文件的绝对路径。在 RF 4.0 中新增。lineno: 使用关键字的行号。在 RF 4.0 中新增。status: 初始关键字状态。如果关键字未执行（例如，由于之前的失败），则为 NOT RUN，否则为 NOT SET。在 RF 4.0 中新增。starttime: 关键字执行开始时间。FOR 类型的额外属性：variables: 每个循环迭代的分配变量，以字符串列表形式。 flavor: 循环类型（例如 IN RANGE）。 values: 循环遍历的值列表，以字符串列表形式。 start: 开始配置。仅在 IN ENUMERATE 循环中使用。在 RF 6.1 中新增。mode: 模式配置。仅在 IN ZIP 循环中使用。在 RF 6.1 中新增。fill: 填充值配置。仅在 IN ZIP 循环中使用。在 RF 6.1 中新增。FOR 循环的 ITERATION 类型的额外属性：variables: 一个 FOR 循环迭代的变量及其内容的字符串表示，以字典形式。WHILE 类型的额外属性： condition: 循环条件。 limit: 最大迭代限制。 on_limit: 如果超过限制，该怎么做。有效值是 pass 和 fail。在 RF 7.0 中新增。 on_limit_message: 达到 WHILE 循环的限制时引发的自定义错误。在 RF 6.1 中新增。IF 和 ELSE IF 类型的额外属性：condition: 正在评估的条件表达式。在 RF 6.1 中新增的 ELSE IF。EXCEPT 类型的额外属性： patterns: 匹配的异常模式，以字符串列表形式。 pattern_type: 模式匹配类型（例如 GLOB）。 variable: 包含捕获的异常的变量。RETURN 类型的额外属性：values: 关键字的返回值，以字符串列表形式。VAR 类型的额外属性： name: 变量名称。 value: 变量值。标量变量为字符串，否则为列表。 scope: 变量范围（例如 GLOBAL），以字符串形式。控制结构的额外属性通常在 RF 6.0 中新增。VAR 在 RF 7.0 中新增。 end_keyword name, attributes 当一个关键字或一个控制结构结束时会被调用。name 是完整的关键字名称，包含可能的库或资源名称作为前缀。例如，MyLibrary.Example Keyword。控制结构具有额外的属性，这些属性根据 type 属性变化。有关所有可能属性的描述，请参见 start_keyword 部分。属性字典的内容： type: 与 start_keyword 相同。 kwname: 与 start_keyword 相同。 libname: 与 start_keyword 相同。 doc: 与 start_keyword 相同。 args: 与 start_keyword 相同。 assign: 与 start_keyword 相同。 tags: 与 start_keyword 相同。 source: 与 start_keyword 相同。 lineno: 与 start_keyword 相同。 starttime: 与 start_keyword 相同。 endtime: 关键字执行结束时间。 elapsedtime: 总执行时间，以毫秒为单位的整数。 status: 关键字状态，字符串 PASS、FAIL、SKIP 或 NOT RUN。SKIP 和 NOT RUN 在 RF 4.0 中新增。 log_message message 当执行的关键字写入日志消息时会被调用。message 是一个字典，包含以下内容： message: 消息的内容。 level: 用于记录消息的日志级别。 timestamp: 消息创建时间，格式为 YYYY-MM-DD hh:mm:ss.mil。html: 字符串 yes 或 no，表示是否应将消息解释为 HTML。如果消息级别低于当前阈值级别，则不会调用此方法。 message message 当框架本身写入系统日志消息时会被调用。message 是一个字典，其内容与 log_message 方法相同。 library_import name, attributes 当导入一个库时会被调用。name 是导入的库的名称。如果在使用 AS 导入库时给库指定了自定义名称，name 就是指定的别名。属性字典的内容： args: 传递给库的参数，以列表形式。 originalname: 如果使用 AS 给库指定了别名，则为原始库名称，否则与 name 相同。 source: 库源的绝对路径。如果由于某种原因获取库的源失败，则为 None。 importer: 导入库的文件的绝对路径。当导入 BuiltIn 以及使用 Import Library 关键字时为 None。 resource_import name, attributes 当导入资源文件时会被调用。 name 是导入的资源文件的名称，不包含文件扩展名。属性字典的内容： source: 导入的资源文件的绝对路径。 importer: 导入资源文件的文件的绝对路径。使用 Import Resource 关键字时为 None。 variables_import name, attributes 当导入变量文件时会被调用。name 是导入的变量文件的名称，包含文件扩展名。属性字典的内容： args: 传递给变量文件的参数，以列表形式。 source: 导入的变量文件的绝对路径。 importer: 导入资源文件的文件的绝对路径。使用 Import Variables 关键字时为 None。 output_file path 当准备好写入输出文件时会被调用。path 是文件的绝对路径，以字符串形式表示。 log_file path 当准备好写入日志文件时会被调用。path 是文件的绝对路径，以字符串形式表示。 report_file path 当准备好写入报告文件时会被调用。path 是文件的绝对路径，以字符串形式表示。 xunit_file path 当准备好写入 xunit 文件时会被调用。path 是文件的绝对路径，以字符串形式表示。 debug_file path 当准备好写入调试文件时会被调用。path 是文件的绝对路径，以字符串形式表示。 close 当整个测试执行结束时会被调用。对于库监听器，当库超出范围时会被调用。 监听器版本 3监听器版本 3 的方法大多与监听器版本 2 相同，但与测试执行相关的方法的参数不同。这些方法获取 Robot Framework 本身使用的实际运行和结果模型对象，监听器既可以查询它们需要的信息，也可以即时更改模型对象。 在 Robot Framework 7.0 中，当它获得了与关键字和控制结构相关的方法时，对监听器版本 3 进行了大量增强。它仍然没有与库、资源文件和变量文件导入相关的方法，但计划在 Robot Framework 7.1 中添加它们。 API 版本 3 中的监听器方法列在下面的表格和可选的 ListenerV3 基类的 API 文档中。 方法 参数 文档说明描述 start_suite data, result 当测试套件开始时调用。data 和 result 是表示执行的测试套件及其执行结果的模型对象。 end_suite data, result 当测试套件结束时调用。参数与 start_suite 相同。 start_test data, result 当测试用例开始时调用。data 和 result 是表示执行的测试用例及其执行结果的模型对象。 end_test data, result 当测试用例结束时调用。参数与 start_test 相同。 start_keyword data, result 当关键字开始时调用。data 和 result 是表示执行的关键字调用及其执行结果的模型对象。默认情况下，当用户关键字、库关键字开始时，以及当关键字调用无效时，会调用此方法。如果实现了更具体的 start_user_keyword、start_library_keyword 或 start_invalid_keyword 方法，则不会调用此方法。 end_keyword data, result 当关键字开始时调用。参数和其他语义与 start_keyword 相同。 start_user_keyword data, implementation, result 当用户关键字开始时调用。data 和 result 与 start_keyword 相同，implementation 是实际执行的用户关键字。如果实现了此方法，start_keyword 不会在用户关键字中被调用。 end_user_keyword data, implementation, result 当用户关键字结束时调用。参数和其他语义与 start_user_keyword 相同。 start_library_keyword data, implementation, result 当库关键字开始时调用。data 和 result 与 start_keyword 相同，implementation 表示执行的库关键字。如果实现了此方法，start_keyword 不会在库关键字中被调用。 end_library_keyword data, implementation, result 当库关键字结束时调用。参数和其他语义与 start_library_keyword 相同。 start_invalid_keyword data, implementation, result 当无效的关键字调用开始时调用。data 和 result 与 start_keyword 相同，implementation 表示无效的关键字调用。关键字可能没有被找到，可能有多个匹配，或者关键字调用本身可能无效。如果实现了此方法，start_keyword 不会在无效的关键字调用中被调用。 end_invalid_keyword data, implementation, result 当无效的关键字调用结束时调用。参数和其他语义与 start_invalid_keyword 相同。 start_for, start_for_iteration, start_while, start_while_iteration, start_if, start_if_branch, start_try, start_try_branch, start_var, start_continue, start_break, start_return data, result 当控制结构开始时调用。有关更多信息，请参阅可选的 ListenerV3 基类的文档和类型提示。 end_for, end_for_iteration, end_while, end_while_iteration, end_if, end_if_branch, end_try, end_try_branch, end_var, end_continue, end_break, end_return data, result 当控制结构结束时调用。有关更多信息，请参阅可选的 ListenerV3 基类的文档和类型提示。 start_error data, result 当无效语法开始时调用。 end_error data, result 当无效语法结束时调用。 log_message message 当执行的关键字写入日志消息时调用。message 是表示记录的消息的模型对象。如果消息的级别低于当前阈值级别，此方法不会被调用。 message message 当框架本身写入系统日志消息时调用。message 与 log_message 中的对象相同。 library_import N&#x2F;A 目前未实现。 resource_import N&#x2F;A 目前未实现。 variables_import N&#x2F;A 目前未实现。 output_file path 当准备好写入输出文件时调用。path 是文件的绝对路径，作为 pathlib.Path 对象。 log_file path 当准备好写入日志文件时调用。path 是文件的绝对路径，作为 pathlib.Path 对象。 report_file path 当准备好写入报告文件时调用。path 是文件的绝对路径，作为 pathlib.Path 对象。 xunit_file path 当准备好写入 xunit 文件时调用。path 是文件的绝对路径，作为 pathlib.Path 对象。 debug_file path 当准备好写入调试文件时调用。path 是文件的绝对路径，作为 pathlib.Path 对象。 close 当整个测试执行结束时调用。对于库监听器，当库超出范围时会被调用。 注意 在 Robot Framework 7.0 之前，传递给结果文件相关的监听器版本 3 方法的路径是字符串。 使用监听器从命令行注册监听器需要在整个执行过程中保持活动的监听器必须从命令行中使用。这是通过使用 --listener 选项完成的，将监听器的名称作为参数给出。监听器的名称来自实现监听器的类或模块的名称，类似于库名称来自实现库的类或模块的名称。指定的监听器必须在导入它们时搜索测试库的同一模块搜索路径中。除了使用名称注册监听器外，还可以给出监听器文件的绝对路径或相对路径，类似于测试库。可以通过多次使用此选项来使用多个监听器： 123robot --listener MyListener tests.robotrobot --listener path/to/MyListener.py tests.robotrobot --listener module.Listener --listener AnotherListener tests.robot 还可以从命令行给监听器类提供参数。参数在监听器名称（或路径）后使用冒号（:）作为分隔符指定。如果监听器被给出为绝对 Windows 路径，则驱动器字母后的冒号不被视为分隔符。此外，还可以使用分号（;）作为替代参数分隔符。这在监听器参数本身包含冒号时很有用，但在 UNIX-like 操作系统上需要用引号包围整个值： 123robot --listener listener.py:arg1:arg2 tests.robotrobot --listener &quot;listener.py;arg:with:colons&quot; tests.robotrobot --listener c:\\path\\listener.py;d:\\first\\arg;e:\\second\\arg tests.robot 除了逐个传递参数作为位置参数外，还可以使用命名参数语法传递它们，类似于使用关键字时： 12robot --listener listener.py:name=value tests.robotrobot --listener &quot;listener.py;name=value:with:colons;second=argument&quot; tests.robot 监听器参数会根据类型提示和默认值自动转换，使用与关键字相同的规则。例如，这个监听器 12345class Listener: def __init__(self, port: int, log=True): self.port = post self.log = log 可以这样使用 1robot --listener Listener:8270:false 并且第一个参数将根据类型提示转换为整数，第二个参数将根据默认值转换为布尔值。 注意 命名参数语法和参数转换在 Robot Framework 4.0 中是新的。 作为监听器的库有时，对于测试库来说，获取关于测试执行的通知也是有用的。例如，这允许它们在测试套件或整个测试执行结束时自动执行某些清理活动。 注册监听器测试库可以通过使用 ROBOT_LIBRARY_LISTENER 属性来注册监听器。此属性的值应为要使用的监听器的实例。它可能是一个完全独立的监听器，或者库本身可以充当监听器。为了避免监听器方法被暴露为关键字，在后一种情况下，可以使用下划线作为前缀。例如，可以使用 _end_suite 而不是 end_suite。 以下示例说明了使用外部监听器以及库本身充当监听器： 12345678910111213141516171819202122from listener import Listenerclass LibraryWithExternalListener: ROBOT_LIBRARY_SCOPE = &#x27;GLOBAL&#x27; ROBOT_LIBRARY_LISTENER = Listener() def example_keyword(self): ...class LibraryItselfAsListener: ROBOT_LIBRARY_SCOPE = &#x27;SUITE&#x27; ROBOT_LISTENER_API_VERSION = 2 def __init__(self): self.ROBOT_LIBRARY_LISTENER = self # 使用 &#x27;_&#x27; 前缀以避免监听器方法成为关键字。 def _end_suite(self, name, attrs): print(f&quot;Suite &#x27;&#123;name&#125;&#x27; ending with status &#123;attrs[&#x27;id&#x27;]&#125;.&quot;) def example_keyword(self): ... 如上面的第二个示例已经演示，库监听器可以使用 ROBOT_LISTENER_API_VERSION 属性指定监听器接口版本，就像任何其他监听器一样。 从 Robot Framework 7.0 开始，监听器也可以通过使用字符串 SELF（不区分大小写）作为监听器来注册自己。这在使用 @library 装饰器时特别方便： 1234567891011121314from robot.api.deco import keyword, library@library(scope=&#x27;SUITE&#x27;, listener=&#x27;SELF&#x27;)class LibraryItselfAsListener: # 监听器版本未指定，因此默认使用监听器版本 3。 # 当使用 @library 装饰器时，关键字必须使用 @keyword 装饰器， # 因此这里无需使用 &#x27;_&#x27; 前缀。 def end_suite(self, data, result): print(f&quot;Suite &#x27;&#123;data.name&#125;&#x27; ending with status &#123;result.status&#125;.&quot;) @keyword def example_keyword(self): ... 也可以通过给 ROBOT_LIBRARY_LISTENER 一个列表值来为单个库指定多个监听器： 1234567from listeners import Listener1, Listener2, Listener3class LibraryWithMultipleListeners: ROBOT_LIBRARY_LISTENER = [Listener1(), Listener2(), Listener3()] def example_keyword(self): ... 调用监听器方法库监听器会收到在导入使用它们的库的套件中的所有事件的通知。实际上，这意味着会调用套件、测试、关键字、控制结构和日志消息相关的方法。除此之外，当库超出范围时，还会调用 close 方法。 如果库每次实例化时都创建一个新的监听器实例，那么要使用的实际监听器实例将根据库的范围而变化。 监听器示例本节包含使用监听器接口的示例。前面的示例说明了在执行过程中获取通知，后面的示例修改了执行的测试和创建的结果。 获取信息第一个示例是作为 Python 模块实现的。它使用的是监听器版本 2，但同样可以使用监听器版本 3 来实现。 12345678&quot;&quot;&quot;如果测试失败，停止执行的监听器。&quot;&quot;&quot;ROBOT_LISTENER_API_VERSION = 2def end_test(name, attrs): if attrs[&#x27;status&#x27;] == &#x27;FAIL&#x27;: print(f&quot;Test &#x27;&#123;name&#125;&#x27; failed: &#123;attrs[&#x27;message&#x27;]&#125;&quot;) input(&quot;Press enter to continue.&quot;) 如果将上述示例保存为，例如，PauseExecution.py 文件，那么可以像这样从命令行中使用它： 1robot --listener path/to/PauseExecution.py tests.robot 下一个示例（仍然使用监听器版本 2）稍微复杂一些。它将获取的所有信息写入临时目录中的文本文件，没有太多格式化。文件名可以从命令行给出，但也有默认值。请注意，在实际使用中，通过命令行选项 --debugfile 可用的调试文件功能可能比这个示例更有用。 12345678910111213141516171819202122232425262728import os.pathimport tempfileclass Example: ROBOT_LISTENER_API_VERSION = 2 def __init__(self, file_name=&#x27;listen.txt&#x27;): path = os.path.join(tempfile.gettempdir(), file_name) self.file = open(path, &#x27;w&#x27;) def start_suite(self, name, attrs): self.file.write(&quot;%s &#x27;%s&#x27;\\n&quot; % (name, attrs[&#x27;doc&#x27;])) def start_test(self, name, attrs): tags = &#x27; &#x27;.join(attrs[&#x27;tags&#x27;]) self.file.write(&quot;- %s &#x27;%s&#x27; [ %s ] :: &quot; % (name, attrs[&#x27;doc&#x27;], tags)) def end_test(self, name, attrs): if attrs[&#x27;status&#x27;] == &#x27;PASS&#x27;: self.file.write(&#x27;PASS\\n&#x27;) else: self.file.write(&#x27;FAIL: %s\\n&#x27; % attrs[&#x27;message&#x27;]) def end_suite(self, name, attrs): self.file.write(&#x27;%s\\n%s\\n&#x27; % (attrs[&#x27;status&#x27;], attrs[&#x27;message&#x27;])) def close(self): self.file.close() ​ 修改数据和结果以下示例说明了如何修改执行的测试和套件以及执行结果。所有这些示例都需要使用监听器版本 3。 修改执行的套件和测试更改执行内容就像修改传递给监听器方法的表示执行数据的模型对象一样简单。下面的示例说明了如何向每个执行的套件添加一个新的测试，并向每个测试添加一个新的关键字调用。 12345def start_suite(data, result): data.tests.create(name=&#x27;New test&#x27;)def start_test(data, result): data.body.create_keyword(name=&#x27;Log&#x27;, args=[&#x27;Keyword added by listener!&#x27;]) 此 API 与可以用于在整个测试执行开始之前修改套件和测试的预运行修改器 API 非常相似。使用监听器 API 的主要好处是可以根据执行结果或其他方式动态地进行修改。例如，这为基于模型的测试提供了有趣的可能性。 尽管监听器接口并未建立在 Robot Framework 的内部访问者接口之上，就像预运行修改器 API 一样，但监听器仍然可以自己使用访问者接口。例如，可以像这样使用预运行修改器示例中使用的 SelectEveryXthTest 访问者： 12345from SelectEveryXthTest import SelectEveryXthTestdef start_suite(suite, result): selector = SelectEveryXthTest(x=2) suite.visit(selector) 访问库或资源文件可以获取更多关于实际执行的关键字及其所属的库或资源文件的信息： 1234567891011from robot.running import Keyword as KeywordData, LibraryKeywordfrom robot.result import Keyword as KeywordResultdef start_library_keyword(data: KeywordData, implementation: LibraryKeyword, result: KeywordResult): library = implementation.owner print(f&quot;Keyword &#x27;&#123;implementation.name&#125;&#x27; is implemented in library &quot; f&quot;&#x27;&#123;library.name&#125;&#x27; at &#x27;&#123;implementation.source&#125;&#x27; on line &quot; f&quot;&#123;implementation.lineno&#125;. The library has &#123;library.scope.name&#125; &quot; f&quot;scope and the current instance is &#123;library.instance&#125;.&quot;) 如上例所示，可以获取到实际库实例的访问权限。这意味着监听器可以检查库状态并修改它。对于用户关键字，甚至可以修改关键字本身，或者通过所有者资源文件，修改资源文件中的任何其他关键字。 ​ 修改结果可以通过修改传递给监听器方法的结果对象来改变测试执行结果。以下是一个作为类实现并使用类型提示的监听器的示例： 1234567891011121314151617181920212223from robot import result, runningclass ResultModifier: def __init__(self, max_seconds: float = 10.0): self.max_seconds = max_seconds def start_suite(self, data: running.TestSuite, result: result.TestSuite): result.doc = &#x27;由监听器设置的文档。&#x27; # 关于测试的信息只能通过数据获得。 smoke_tests = [test for test in data.tests if &#x27;smoke&#x27; in test.tags] result.metadata[&#x27;Smoke tests&#x27;] = len(smoke_tests) def end_test(self, data: running.TestCase, result: result.TestCase): elapsed_seconds = result.elapsed_time.total_seconds() if result.status == &#x27;PASS&#x27; and elapsed_seconds &gt; self.max_milliseconds: result.status = &#x27;FAIL&#x27; result.message = &#x27;测试执行时间过长。&#x27; def log_message(self, msg: result.Message): if msg.level == &#x27;WARN&#x27; and not msg.html: msg.message = f&#x27;&lt;b style=&quot;font-size: 1.5em&quot;&gt;&#123;msg.message&#125;&lt;/b&gt;&#x27; msg.html = True 一个限制是，修改当前测试套件或测试用例的名称是不可能的，因为在调用监听器时，它已经被写入到 output.xml 文件中。由于同样的原因，在 end_suite 方法中修改已经完成的测试也没有效果。 请注意，尽管监听器可以改变任何执行的关键字或控制结构的状态，但这并不直接影响执行的测试的状态。一般来说，监听器不能直接使关键字失败，以便停止执行，也不能处理失败，以便继续执行。如果有需要，将来可能会添加这种功能。 此 API 与 pre-Rebot 修改器 API 非常相似，可以用于在生成报告和日志之前修改结果。主要的区别是，监听器也修改了创建的 output.xml 文件。 更多示例关键字和控制结构相关的监听器版本 3 方法如此多样，以至于在用户指南中无法完全覆盖它们。有关更多示例，可以查看接受测试，这些测试以各种方式使用这些方法。 解析器接口Robot Framework 支持可以处理自定义数据格式甚至覆盖 Robot Framework 自己的解析器的外部解析器。 注意 自定义解析器在 Robot Framework 6.1 中是新的。 使用解析器解析器是从命令行使用 --parser 选项启用的，使用的语义与监听器完全相同。这包括指定解析器为名称或路径，给解析器类提供参数等： 123robot --parser MyParser tests.customrobot --parser path/to/MyParser.py tests.customrobot --parser Parser1:arg --parser Parser2:a1:a2 path/to/tests 解析器 API解析器可以作为模块和类来实现。本节解释了它们必须包含哪些属性和方法。 EXTENSION 或 extension 属性此属性指定解析器支持的文件扩展名或扩展名。接受 EXTENSION 和 extension 名称，如果两者都存在，前者优先。该属性可以是字符串或字符串序列。扩展名不区分大小写，可以带或不带前导点。如果解析器作为类实现，可以将此属性设置为类属性或实例属性。 也支持包含多个部分的扩展名，如 .example.ext 或 .robot.zip。 注意 如果解析器支持 .robot 扩展名，它将用于解析这些文件，而不是标准解析器。 parse 方法强制性的 parse 方法负责解析套件文件。它被调用时，每个解析的文件都有一个解析器支持的扩展名。该方法必须返回一个 TestSuite 对象。 在简单的情况下，parse 可以被实现为只接受一个参数，即指向要解析的文件的 pathlib.Path 对象。如果解析器对在更高级别的套件初始化文件中设置的 Test Setup、Test Teardown、Test Tags 和 Test Timeout 的默认值感兴趣，parse 方法必须接受两个参数。在这种情况下，第二个参数是一个 TestDefaults 对象。 parse_init 方法可选的 parse_init 方法负责解析套件初始化文件，即格式为 __init__.ext 的文件，其中 .ext 是解析器支持的扩展名。该方法必须返回一个表示整个目录的 TestSuite 对象。从子套件文件和目录创建的套件将被添加到其子套件中。 parse_init 也可以被实现为接受一个或两个参数，取决于它是否对测试相关的默认值感兴趣。如果它接受默认值，它可以操作传递的 TestDefaults 对象，并在解析子套件文件时看到更改。 只有当解析器需要支持套件初始化文件时，才需要此方法。 可选的基类解析器不需要实现任何显式的接口，但扩展可选的 Parser 基类可能会有所帮助。主要的好处是基类有文档和类型提示。它也作为更正式的 API 规范。 示例作为模块实现的解析器第一个示例演示了一个作为模块实现的简单解析器，支持一个硬编码的扩展名。它只创建一个虚拟套件，并不实际解析任何内容。 123456789from robot.api import TestSuiteEXTENSION = &#x27;.example&#x27;def parse(source): suite = TestSuite(name=&#x27;Example&#x27;, source=source) test = suite.tests.create(name=&#x27;Test&#x27;) test.body.create_keyword(name=&#x27;Log&#x27;, args=[&#x27;Hello!&#x27;]) return suite 作为类实现的解析器第二个解析器作为一个类实现，接受要使用的扩展名作为参数。解析器读取给定的源文件，并从其中的每一行创建虚拟测试。 123456789101112131415from pathlib import Pathfrom robot.api import TestSuiteclass ExampleParser: def __init__(self, extension: str): self.extension = extension def parse(self, source: Path) -&gt; TestSuite: name = TestSuite.name_from_source(source, self.extension) suite = TestSuite(name, source=source) for line in source.read_text().splitlines(): test = suite.tests.create(name=line) test.body.create_keyword(name=&#x27;Log&#x27;, args=[&#x27;Hello!&#x27;]) return suite 扩展可选基类的解析器这个解析器扩展了可选的 Parser 基类。它支持解析套件初始化文件，使用 TestDefaults 并注册多个扩展名。 12345678910111213141516171819202122232425from pathlib import Pathfrom robot.api import TestSuitefrom robot.api.interfaces import Parser, TestDefaultsclass ExampleParser(Parser): extension = (&#x27;example&#x27;, &#x27;another&#x27;) def parse(self, source: Path, defaults: TestDefaults) -&gt; TestSuite: &quot;&quot;&quot;创建一个套件并将可能的默认值从 init 文件设置到测试中。&quot;&quot;&quot; suite = TestSuite(TestSuite.name_from_source(source), source=source) for line in source.read_text().splitlines(): test = suite.tests.create(name=line, doc=&#x27;Example&#x27;) test.body.create_keyword(name=&#x27;Log&#x27;, args=[&#x27;Hello!&#x27;]) defaults.set_to(test) return suite def parse_init(self, source: Path, defaults: TestDefaults) -&gt; TestSuite: &quot;&quot;&quot;创建一个虚拟套件并设置一些默认值。 只有在有一个支持的扩展名的初始化文件时，才会调用此方法。 &quot;&quot;&quot; defaults.tags = (&#x27;tags&#x27;, &#x27;from init&#x27;) defaults.setup = &#123;&#x27;name&#x27;: &#x27;Log&#x27;, &#x27;args&#x27;: [&#x27;Hello from init!&#x27;]&#125; return TestSuite(TestSuite.name_from_source(source.parent), doc=&#x27;Example&#x27;, source=source, metadata=&#123;&#x27;Example&#x27;: &#x27;Value&#x27;&#125;) 作为预处理器的解析器最后一个示例解析器充当 Robot Framework 数据文件的预处理器，支持格式为 === Test Cases === 的标题，除了 *** Test Cases ***。在这种使用情况下，使用 TestSuite.from_string、TestSuite.from_model 和 TestSuite.from_file_system 工厂方法构造返回的套件是方便的。 123456789101112from pathlib import Pathfrom robot.running import TestDefaults, TestSuiteclass RobotPreprocessor: extension = &#x27;.robot&#x27; def parse(self, source: Path, defaults: TestDefaults) -&gt; TestSuite: data = source.read_text() for header in &#x27;Settings&#x27;, &#x27;Variables&#x27;, &#x27;Test Cases&#x27;, &#x27;Keywords&#x27;: data = data.replace(f&#x27;=== &#123;header&#125; ===&#x27;, f&#x27;*** &#123;header&#125; ***&#x27;) suite = TestSuite.from_string(data, defaults=defaults) return suite.config(name=TestSuite.name_from_source(source), source=source) ​ 辅助工具库文档工具（Libdoc）Libdoc 是 Robot Framework 的内置工具，可以为 Robot Framework 库和资源文件生成文档。它可以为人类生成 HTML 文档，也可以生成 XML 和 JSON 格式的机器可读规范文件。Libdoc 还有一些特殊命令可以在控制台上显示库或资源信息。 可以为以下内容创建文档： 使用普通静态库 API 实现的库， 使用动态 API 的库，包括远程库， 资源文件， 套件文件，以及 套件初始化文件。 此外，还可以使用 Libdoc 之前创建的 XML 和 JSON 规范文件作为输入。 注意 在 Robot Framework 6.0 中，新增了为套件文件和套件初始化文件生成文档的支持。 在 Robot Framework 4.0 中，新增了对 JSON 规范文件的支持。 一般使用概要12libdoc [options] library_or_resource output_filelibdoc [options] library_or_resource list|show|version [names] 选项 -f, --format &lt;html|xml|json|libspec&gt;：指定是否为人类生成 HTML 输出，或者以 XML 或 JSON 格式生成机器可读的规范文件。libspec 格式意味着将文档转换为 HTML 的 XML 规范。默认格式从输出文件扩展名中获取。 -s, --specdocformat &lt;raw|html&gt;：指定用于 XML 和 JSON 规范文件的文档格式。raw 表示保留原始文档格式，html 表示将文档转换为 HTML。默认值是 XML 规范文件的 raw 和 JSON 规范以及使用特殊 libspec 格式时的 html。这是 Robot Framework 4.0 中的新功能。 -F, --docformat &lt;robot|html|text|rest&gt;：指定源文档格式。可能的值是 Robot Framework 的文档格式、HTML、纯文本和 reStructuredText。默认值可以在测试库源代码中指定，初始默认值是 robot。 --theme &lt;dark|light|none&gt;：使用深色或浅色 HTML 主题。如果未使用此选项，或者值为 none，则根据浏览器颜色方案选择主题。仅适用于 HTML 输出。这是 Robot Framework 6.0 中的新功能。 -N, --name &lt;newname&gt;：设置文档化库或资源的名称。 -V, --version &lt;newversion&gt;：设置文档化库或资源的版本。测试库的默认值在源代码中定义。 -P, --pythonpath &lt;path&gt;：搜索库和资源的额外位置，类似于运行测试时的情况。 --quiet：不将生成的输出文件的路径打印到控制台。这是 Robot Framework 4.0 中的新功能。 -h, --help：打印此帮助。 执行 Libdoc运行 Libdoc 的最简单方法是使用作为正常安装的一部分创建的 libdoc 命令： 1libdoc ExampleLibrary ExampleLibrary.html 另一种可能性是直接执行 robot.libdoc 模块。如果使用多个 Python 版本安装了 Robot Framework，并希望使用 Libdoc 的特定版本，这种方法特别有用： 12python -m robot.libdoc ExampleLibrary ExampleLibrary.htmlpython3.9 -m robot.libdoc ExampleLibrary ExampleLibrary.html 还有另一种选择是作为脚本运行 robot.libdoc 模块： 1python path/to/robot/libdoc.py ExampleLibrary ExampleLibrary.html 注意 单独的 libdoc 命令是 Robot Framework 4.0 中的新功能。 指定库或资源文件Python 库和动态库的名称或路径在为使用 Python 或使用动态库 API 实现的库编写文档时，可以通过仅使用库名称或库源代码的路径来指定库： 12libdoc ExampleLibrary ExampleLibrary.htmllibdoc src/ExampleLibrary.py docs/ExampleLibrary.html 在前一种情况下，将使用模块搜索路径搜索库，其名称必须与在 Robot Framework 测试数据中导入库时的格式相同。 如果这些库在导入时需要参数，则必须使用两个冒号将参数与库名称或路径连接，如 MyLibrary::arg1::arg2。如果参数更改了库提供的关键字或以其他方式更改了其文档，那么使用 --name 选项也更改库名称可能是个好主意。 资源文件的路径资源文件必须始终使用路径指定： 1libdoc example.resource example.html 如果路径不存在，资源文件也会从执行测试用例时的所有目录的模块搜索路径中搜索。 Libdoc 规范文件也可以使用先前生成的 Libdoc XML 或 JSON 规范文件作为输入。如果规范文件使用 *.xml、*.libspec 或 *.json 扩展名，这将起作用： 123libdoc Example.xml Example.htmllibdoc Example.libspec Example.htmllibdoc Example.json Example.html 注意 对 *.libspec 扩展名的支持是 Robot Framework 3.2 中的新功能。 对 *.json 扩展名的支持是 Robot Framework 4.0 中的新功能。 生成文档Libdoc 可以生成 HTML（供人类阅读）以及 XML 或 JSON（供工具使用）格式的文档。写入文档的文件是在库&#x2F;资源名称或路径之后作为第二个参数指定的，输出格式默认从输出文件扩展名中获取。 Libdoc HTML 文档大多数 Robot Framework 库使用 Libdoc 生成 HTML 格式的库文档。因此，这种格式对于使用过 Robot Framework 的大多数人来说都很熟悉。下面可以看到一个简单的示例，它是基于本节稍后找到的示例生成的。 HTML 文档从库的一般介绍开始，然后是关于导入库时的配置（如果适用），最后是所有关键字的快捷方式和关键字本身。右下角的放大镜图标打开关键字搜索对话框，也可以通过简单地按 s 键打开。 如果输出文件扩展名为 *.html，Libdoc 会自动创建 HTML 文档。如果需要使用其他扩展名，可以使用 --format 选项显式指定格式。 123libdoc OperatingSystem OperatingSystem.htmllibdoc --name MyLibrary Remote::http://10.0.0.42:8270 MyLibrary.htmllibdoc --format HTML test/resource.robot doc/resource.htm Libdoc XML 规范文件Libdoc 也可以生成适合外部工具（如编辑器）使用的 XML 格式的文档。它包含与 HTML 格式相同的所有信息，但以机器可读的格式提供。 XML 规范文件还包含库和关键字源信息，因此库和每个关键字可以有源路径（source 属性）和行号（lineno 属性）。源路径相对于生成规范文件的目录，因此如果规范被移动，它不会引用正确的文件。如果关键字的源路径与库的源路径相同，则省略关键字的源路径，如果由于任何原因从库获取源路径和行号失败，则省略源路径和行号。 如果输出文件扩展名为 *.xml 或 *.libspec，Libdoc 会自动使用 XML 格式。当使用特殊的 *.libspec 扩展名时，Libdoc 会自动启用选项 -f XML -s HTML，这意味着创建一个 XML 输出文件，其中关键字文档被转换为 HTML。如果需要，可以使用 --format 选项显式设置格式。 1234libdoc OperatingSystem OperatingSystem.xmllibdoc test/resource.robot doc/resource.libspeclibdoc --format xml MyLibrary MyLibrary.speclibdoc --format xml -s html MyLibrary MyLibrary.xml 准确的 Libdoc 规范文件格式在 https://github.com/robotframework/robotframework/tree/master/doc/schema 上有一个 XML 架构（XSD）进行了文档化。规范文件格式可能会在 Robot Framework 的主要版本之间发生变化。 为了让外部工具更容易知道如何解析某个规范文件，规范文件的根元素有一个专用的 specversion 属性。它在 Robot Framework 3.2 中添加，值为 2，早期的规范文件可以认为版本为 1。如果有变化，将来会增加规范版本。Robot Framework 4.0 引入了新的规范版本 3，与早期版本不兼容。 注意 在 Robot Framework 3.2 中引入的 XML:HTML 格式已被 LIBSPEC 格式或选项组合 --format XML --specdocformat HTML 替代。 在 Robot Framework 3.2 中新增了包含源信息和规范版本。 Libdoc JSON 规范文件自 Robot Framework 4.0 起，Libdoc 也可以生成适合外部工具（如编辑器或网页）使用的 JSON 格式的文档。它包含与 HTML 格式相同的所有信息，但以机器可读的格式提供。 与 XML 规范文件类似，JSON 规范文件包含所有信息，也可以作为 Libdoc 的输入。从该格式可以创建任何其他输出格式。默认情况下，库文档字符串在 JSON 输出文件中被转换为 HTML 格式。 JSON 规范文件的确切格式在 https://github.com/robotframework/robotframework/tree/master/doc/schema 上有一个 JSON 架构进行了文档化。规范文件格式可能会在 Robot Framework 的主要版本之间发生变化。 在控制台查看信息Libdoc 有三个特殊的命令可以在控制台上显示信息。这些命令用于替代输出文件的名称，它们也可以接受额外的参数。 list列出库&#x2F;资源包含的关键字的名称。可以通过传递可选的模式作为参数来限制只显示某些关键字。如果关键字的名称包含给定的模式，则列出关键字。 show显示库&#x2F;资源的文档。可以通过传递名称作为参数来限制只显示某些关键字。如果关键字的名称与任何给定的名称匹配，则显示关键字。特殊参数 intro 将只显示库的介绍和导入部分。 version显示库版本 给 list 和 show 提供的可选模式不区分大小写和空格。两者都接受 * 和 ? 作为通配符。 示例： 123456libdoc Dialogs listlibdoc SeleniumLibrary list browserlibdoc Remote::10.0.0.42:8270 showlibdoc Dialogs show PauseExecution execute*libdoc SeleniumLibrary show introlibdoc SeleniumLibrary version 编写文档本节讨论为使用静态库 API 的基于 Python 的测试库以及动态库和资源文件编写文档。在用户指南的其他地方详细描述了创建测试库和资源文件。 Python 库使用静态库 API 的 Python 库的文档简单地写为库类或模块以及实现关键字的方法的文档字符串。方法文档的第一行被视为关键字的简短文档（例如，用作生成的 HTML 文档中链接的工具提示），因此它应尽可能描述，但不应过长。 下面的简单示例说明了如何一般地编写文档。可以看到基于此示例生成的 HTML 文档是什么样子，本章末尾还有一个稍长的示例。 123456789101112131415161718class ExampleLibrary: &quot;&quot;&quot;用于演示目的的库。 这个库只用于一个示例，它没有做任何有用的事情。 &quot;&quot;&quot; def my_keyword(self): &quot;&quot;&quot;什么都不做。&quot;&quot;&quot; pass def your_keyword(self, arg): &quot;&quot;&quot;接受一个参数并且*不对其做任何事情*。 示例： | Your Keyword | xxx | | Your Keyword | yyy | &quot;&quot;&quot; pass 信息 如果库做了一些初始化工作，那么在使用 Libdoc 时不应该做，可以轻松地检测 Robot Framework 是否正在运行 有关 Python 文档字符串的更多信息，请参阅 PEP-257。 动态库为了能够为动态库生成有意义的文档，库必须使用 get_keyword_arguments 和 get_keyword_documentation 方法（或使用它们的驼峰命名变体 getKeywordArguments 和 getKeywordDocumentation）返回关键字参数名称和文档。库还可以通过特殊的 __intro__ 和 __init__ 值支持一般的库文档。 有关如何创建这些方法的更多信息，请参阅动态库 API 部分。 导入部分根据其初始化方法，创建了关于如何导入库的单独部分。如果库有一个 __init__ 方法，除了 self 之外还需要参数，那么将显示其文档和参数。 12345678910111213class TestLibrary: def __init__(self, mode=&#x27;default&#x27;) &quot;&quot;&quot;创建新的 TestLibrary。`mode` 参数用于确定模式。&quot;&quot;&quot; self.mode = mode def some_keyword(self, arg): &quot;&quot;&quot;根据给定的 `arg` 做一些事情。 所做的事情取决于在 `importing` 库时指定的 `mode`。 &quot;&quot;&quot; if self.mode == &#x27;secret&#x27;: # ... 资源文件文档资源文件中的关键字可以使用 [Documentation] 设置进行文档化，Libdoc 也使用此文档。文档的第一行（直到第一个隐式换行符或显式 \\n）被视为与测试库类似的简短文档。 资源文件本身也可以在设置部分有文档，用于记录整个资源文件。 资源文件中的可能变量不能被文档化。 1234567891011121314151617*** Settings ***Documentation 用于演示目的的资源文件。... 这个资源只用于一个示例，它没有做任何有用的事情。*** Keywords ***My Keyword [Documentation] 什么都不做 No OperationYour Keyword [Arguments] $&#123;arg&#125; [Documentation] 接受一个参数并且*不对其做任何事情*。 ... ... 示例： ... | Your Keyword | xxx | ... | Your Keyword | yyy | No Operation ​ 文档语法Libdoc 支持 Robot Framework 自己的文档语法、HTML、纯文本和 reStructuredText。可以在库源代码中使用 ROBOT_LIBRARY_DOC_FORMAT 属性或使用 --docformat (-F) 选项从命令行给出要使用的格式。在这两种情况下，可能的不区分大小写的值是 ROBOT（默认）、HTML、TEXT 和 reST。 Robot Framework 自己的文档格式是默认的，通常推荐的格式。其他格式在使用现有代码和现有文档的测试库中特别有用。 Robot Framework 文档语法Robot Framework 的文档语法中最重要的特性是使用 *bold* 和 _italic_ 进行格式化，自定义链接和自动将 URL 转换为链接，以及使用管道字符简单地创建表格和预格式化文本块（对于示例很有用）。如果文档变得更长，支持章节标题也可能很方便。 下面的示例说明了一些最重要的格式化特性。注意，由于这是默认格式，因此无需使用 ROBOT_LIBRARY_DOC_FORMAT 属性，也无需从命令行给出格式。 12345678910&quot;&quot;&quot;Robot Framework 格式的示例库。- 使用 *bold* 和 _italic_ 进行格式化。- URLs 如 http://example.com 会被转换为链接。- 支持自定义链接，如 [http://robotframework.org|Robot Framework]。- 可以链接到 `My Keyword`。&quot;&quot;&quot;def my_keyword(): &quot;&quot;&quot;这里没有更多内容。&quot;&quot;&quot; 自动创建目录对于较大的库，通常有必要在库介绍中添加目录。当使用 Robot Framework 文档格式时，可以通过在自己的一行中添加一个特殊的 %TOC% 标记来自动完成此操作。目录是根据介绍中使用的顶级章节标题（例如 = Section =）创建的。除此之外，TOC 还获取到自动创建的快捷方式和关键字以及适用时的导入和标签部分的链接。 12345678910111213141516171819202122&quot;&quot;&quot;演示 TOC 生成的示例库。%TOC% 标记只创建实际的目录，可能的标题或其他解释需要像下面这样单独添加。== 目录 ==%TOC%= 章节标题 =顶级章节标题会自动添加到 TOC。= 第二章节 === 子章节 ==子章节标题不会添加到 TOC。&quot;&quot;&quot;def my_keyword(): &quot;&quot;&quot;这里没有更多内容。&quot;&quot;&quot; 注意 在 Robot Framework 3.2 中，自动 TOC 生成是新功能。 HTML 文档语法当使用 HTML 格式时，可以使用任何语法自由地创建文档。主要的缺点是 HTML 标记不是那么人性化，这可能使源代码中的文档难以维护和阅读。HTML 格式的文档由 Libdoc 直接使用，无需任何转换或转义。然而，支持使用像 My Keyword 这样的语法链接到关键字的特殊语法。 下面的示例包含与前一个示例相同的格式化示例。现在必须使用 ROBOT_LIBRARY_DOC_FORMAT 属性或在命令行上像 --docformat HTML 这样给出格式。 12345678910111213&quot;&quot;&quot;HTML 格式的示例库。&lt;ul&gt; &lt;li&gt;使用 &lt;b&gt;bold&lt;/b&gt; 和 &lt;i&gt;italic&lt;/i&gt; 进行格式化。 &lt;li&gt;URL 不会自动转换为链接。 &lt;li&gt;支持自定义链接，如 &lt;a href=&quot;http://www.w3.org/html&quot;&gt;HTML&lt;/a&gt;。 &lt;li&gt;可以链接到 `My Keyword`。&lt;/ul&gt;&quot;&quot;&quot;ROBOT_LIBRARY_DOC_FORMAT = &#x27;HTML&#x27;def my_keyword(): &quot;&quot;&quot;这里没有更多内容。&quot;&quot;&quot; ​ 内部链接Libdoc 支持在文档中对关键字和不同章节进行内部链接。链接是通过将目标名称用反引号字符（如 target）包围来完成的。目标名称不区分大小写，可能的目标在后续章节中有解释。 如果找不到链接目标，不会有错误或警告，而是 Libdoc 只将其中的文本格式化为斜体。早期，当引用关键字参数时，推荐使用这种格式，但这可能会意外地创建内部链接。现在，推荐使用双反引号（如 argument）代替内联代码样式。未来可能会删除旧的单反引号格式，以便在找不到链接目标时给出错误。 除了以下章节中的示例外，还在本章末尾的较长示例中显示了内部链接和参数格式化。 链接到关键字库中的所有关键字都会自动创建链接目标，可以使用 Keyword Name 语法进行链接。下面的示例说明了两个关键字都有链接到对方。 123456789101112131415def keyword(log_level=&quot;INFO&quot;): &quot;&quot;&quot;做一些事情并使用给定的级别记录输出。 `log level` 的有效值是 &quot;INFO&quot;（默认）&quot;DEBUG&quot; 和 &quot;TRACE&quot;。 另请参见 `Another Keyword`。 &quot;&quot;&quot; # ...def another_keyword(argument, log_level=&quot;INFO&quot;): &quot;&quot;&quot;对给定的参数做一些事情并记录输出。 有关有效日志级别的信息，请参见 `Keyword`。 &quot;&quot;&quot; # ... 注意 当使用 reStructuredText 文档语法时，必须像 Keyword Name 这样转义反引号。 链接到自动章节Libdoc 生成的文档总是包含库的整体介绍和关键字的章节。如果库本身需要参数，还有一个单独的导入章节。如果任何关键字有标签，概览中也会显示它们的单独选择器。 所有章节都充当可以链接的目标，可能的目标名称列在下表中。在下一节的示例中显示了如何使用这些目标。 章节 目标 介绍 introduction 和 library introduction 导入 importing 和 library importing 关键字 keywords 注意 在 Robot Framework 4.0 之前，还有标签和快捷方式的章节。在 Robot Framework 4.0 中，这些已被概览菜单取代。这意味着之前链接到快捷方式或标签章节的链接不再工作。 链接到自定义章节Robot Framework 的文档语法支持自定义章节标题，库或资源文件介绍中使用的标题会自动创建链接目标。下面的示例说明了如何链接到自动和自定义章节： 12345678910111213141516&quot;&quot;&quot;用于 Libdoc 演示目的的库。这个库没有做任何有用的事情。= 我的章节 =我们确实在文档中有一个自定义章节。&quot;&quot;&quot;def keyword(): &quot;&quot;&quot;什么都不做。 有关更多信息，请参见 `introduction`，并参见 `My section` 以测试如何 链接到自定义章节。 &quot;&quot;&quot; pass 注意 只有在使用 Robot Framework 文档语法时，才能链接到自定义章节。 表示参数Libdoc 会自动显示关键字参数的信息。 包含的信息 以下信息将显示所有关键字，无论它们是在库中实现还是在资源文件中实现： 参数名称。用户关键字参数显示时不带 $&#123;&#125; 装饰，使得无论关键字来自何处，参数看起来都是一样的。 标记告诉参数是仅位置、仅命名、自由位置、自由命名，还是可以通过位置或名称给出的普通参数。 可能的默认值。显示为 = 42。 可能的类型。显示为 &lt;int&gt;。可以是链接到下一节解释的类型文档。 在关键字文档中引用参数时，建议使用内联代码样式，如 argument。 自动列出类型文档如上所述，Libdoc 在列出参数时会自动显示可能的类型信息。如果类型是基于 Enum 或 TypedDict 的自定义类型，类型会被自动转换，或者类型有自定义转换器，那么类型本身也会单独列出以显示更多关于它的信息。当这些类型用于参数时，类型名称也会变成链接到类型信息的链接。 所有列出的数据类型都显示可能的类型文档以及支持的参数类型。此外，基于 Enum 的类型列出可用的成员，基于 TypedDict 的类型显示字典结构。 注意 在 Robot Framework 4.0 中，基于 Enum 和 TypedDict 的类型的自动列出是新功能。在 Robot Framework 5.0 中，列出其他类型是新功能。 Libdoc 示例以下示例说明了如何使用最重要的文档格式化可能性、内部链接等。点击这里查看生成的文档是什么样子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class LoggingLibrary: &quot;&quot;&quot;用于记录消息的库。 = 目录 = %TOC% = 使用 = 这个库有几个关键字，例如 `Log Message`，用于记录消息。实际上，这个库只用于 _Libdoc_ 演示目的。 = 有效的日志级别 = 有效的日志级别是 ``INFO``，``DEBUG`` 和 ``TRACE``。默认的日志级别可以在 `importing` 时设置。 = 示例 = 注意示例中的关键字是如何链接的。 | `Log Message` | My message | | | | `Log Two Messages` | My message | Second message | level=DEBUG | | `Log Messages` | First message | Second message | Third message | &quot;&quot;&quot; ROBOT_LIBRARY_VERSION = &#x27;0.1&#x27; def __init__(self, default_level=&#x27;INFO&#x27;): &quot;&quot;&quot;可以在库导入时给出默认的日志级别。 有关可用日志级别的信息，请参见 `Valid log levels` 章节。 示例： | =Setting= | =Value= | =Value= | =Comment= | | Library | LoggingLibrary | | # 使用默认级别 (INFO) | | Library | LoggingLibrary | DEBUG | # 使用给定的级别 | &quot;&quot;&quot; self.default_level = self._verify_level(default_level) def _verify_level(self, level): level = level.upper() if level not in [&#x27;INFO&#x27;, &#x27;DEBUG&#x27;, &#x27;TRACE&#x27;]: raise RuntimeError(&quot;无效的日志级别&#x27;%s&#x27;。有效的级别是 &quot; &quot;&#x27;INFO&#x27;, &#x27;DEBUG&#x27;, 和 &#x27;TRACE&#x27;&quot;) return level def log_message(self, message, level=None): &quot;&quot;&quot;使用指定的日志级别将给定的消息写入日志文件。 要记录的消息和要使用的日志级别分别由 ``message`` 和 ``level`` 参数定义。 如果没有给出日志级别，则使用在 `library importing` 时给出的默认级别。 &quot;&quot;&quot; level = self._verify_level(level) if level else self.default_level print(&quot;*%s* %s&quot; % (level, message)) def log_two_messages(self, message1, message2, level=None): &quot;&quot;&quot;使用指定的日志级别将给定的消息写入日志文件。 有关更多信息，请参见 `Log Message` 关键字。 &quot;&quot;&quot; self.log_message(message1, level) self.log_message(message2, level) def log_messages(self, *messages): &quot;&quot;&quot;使用在 `importing` 时设置的日志级别记录给定的消息。 另请参见 `Log Message` 和 `Log Two Messages`。 &quot;&quot;&quot; for msg in messages: self.log_message(msg) 所有标准库都有由 Libdoc 生成的文档，它们的文档（和源代码）作为更现实的示例。 测试数据文档工具（Testdoc）Testdoc 是 Robot Framework 的内置工具，用于基于测试用例生成高级文档。创建的文档是 HTML 格式，包括每个测试套件和测试用例的名称、文档和其他元数据，以及顶级关键字及其参数。 一般使用概要1python -m robot.testdoc [options] data_sources output_file 选项 -T, --title &lt;title&gt; 设置生成的文档的标题。标题中的下划线会被转换为空格。默认标题是顶级套件的名称。 -N, --name &lt;name&gt; 覆盖顶级测试套件的名称。 -D, --doc &lt;doc&gt; 覆盖顶级测试套件的文档。 -M, --metadata &lt;name:value&gt; 设置&#x2F;覆盖顶级测试套件的自由元数据。 -G, --settag &lt;tag&gt; 将给定的标签设置到所有测试用例。 -t, --test &lt;name&gt; 通过名称包含测试。 -s, --suite &lt;name&gt; 通过名称包含套件。 -i, --include &lt;tag&gt; 通过标签包含测试。 -e, --exclude &lt;tag&gt; 通过标签排除测试。 -A, --argumentfile &lt;path&gt; 文本文件，从中读取更多参数。与运行测试时的参数文件工作方式完全相同。 -h, --help 在控制台打印此帮助。 除了 --title 之外，所有选项的语义与执行测试用例时的相同选项完全相同。 生成文档数据可以作为单个文件、目录或多个文件和目录给出。在所有这些情况下，最后一个参数必须是要写入输出的文件。 Testdoc 可以作为已安装的模块执行，如 python -m robot.testdoc，或作为脚本执行，如 python path/robot/testdoc.py。 示例： 12python -m robot.testdoc my_test.robot testdoc.htmlpython path/to/robot/testdoc.py --name &quot;Smoke tests&quot; --include smoke path/to/tests smoke.html 测试数据清理工具（Tidy）内置的 Tidy 工具在 Robot Framework 4.1 中被弃用，取而代之的是新的和增强的外部 Robotidy 工具。它在 Robot Framework 5.0 中被完全移除。 外部工具有许多外部工具可以与 Robot Framework 一起使用。这些工具包括各种 IDE 和文本编辑器的插件，用于并行执行和数据驱动测试的工具，用于持续集成系统的插件等。 这些工具作为与 Robot Framework 本身独立的单独项目进行开发。有关可用工具的列表，请参见 http://robotframework.org/。 附录可用设置此附录列出了可以在不同部分使用的所有设置。 注意 设置可以本地化。请参阅支持的翻译附录以获取更多信息。 设置部分设置部分用于导入库、资源文件和变量文件，并为测试套件和测试用例定义元数据。它可以包含在测试用例文件和资源文件中。请注意，在资源文件中，设置部分只能包含导入库、资源和变量的设置。 名称 描述 Library 用于导入库 Resource 用于使用资源文件 Variables 用于使用变量文件 Name 用于设置自定义套件名称 Documentation 用于指定套件或资源文件文档 Metadata 用于设置自由套件元数据 Suite Setup 用于指定套件设置 Suite Teardown 用于指定套件拆卸 Test Tags 用于为套件中的所有测试指定测试用例标签 Force Tags, Default Tags 已弃用的设置，用于指定测试用例标签 Keyword Tags 用于为某个文件中的所有用户关键字指定用户关键字标签 Test Setup 用于指定默认测试设置 Test Teardown 用于指定默认测试拆卸 Test Template 用于指定测试用例的默认模板关键字 Test Timeout 用于指定默认测试用例超时 Task Setup, Task Teardown, Task Template, Task Timeout 分别是 Test Setup, Test Teardown, Test Template 和 Test Timeout 的别名，可以在创建任务时使用 测试用例部分测试用例部分的设置始终特定于为其定义的测试用例。这些设置中的一些会覆盖在设置部分定义的默认值。 在任务部分创建任务时，可以使用完全相同的设置。 名称 描述 [Documentation] 用于指定测试用例文档 [Tags] 用于标记测试用例 [Setup] 用于指定测试设置 [Teardown] 用于指定测试拆解 [Template] 用于指定模板关键字 [Timeout] 用于指定测试用例超时 关键字部分关键字部分中的设置特定于为其定义的用户关键字。 原文 描述 [Documentation] 用于指定用户关键字文档 [Tags] 用于指定用户关键字标签 [Arguments] 用于指定用户关键字参数 [Setup] 用于指定用户关键字设置，Robot Framework 7.0中的新功能 [Teardown] 用于指定用户关键字拆解 [Timeout] 用于指定用户关键字超时 [Return] 用于指定用户关键字返回值，已在Robot Framework 7.0中弃用，建议使用RETURN语句代替 ​ 命令行选项此附录列出了执行测试用例和后处理输出时可用的所有命令行选项。还列出了影响执行和后处理的环境变量。 测试执行的命令行选项 --rpa：开启通用自动化模式。 --language &lt;lang&gt;：激活本地化。lang 可以是内置语言的名称或代码，或者是自定义语言文件的路径或模块名称。 -F, --extension &lt;value&gt;：执行目录时，只解析这些文件。 -I, --parseinclude &lt;pattern&gt;：执行目录时，只解析匹配的文件。 -N, --name &lt;name&gt;：设置顶级测试套件的名称。 -D, --doc &lt;document&gt;：设置顶级测试套件的文档。 -M, --metadata &lt;name:value&gt;：为顶级测试套件设置自由元数据。 -G, --settag &lt;tag&gt;：为所有执行的测试用例设置标签。 -t, --test &lt;name&gt;：通过名称选择测试用例。 --task &lt;name&gt;：执行任务时可以使用的 --test 的别名。 -s, --suite &lt;name&gt;：通过名称选择测试套件。 -R, --rerunfailed &lt;file&gt;：选择从早期输出文件中重新执行的失败测试。 -S, --rerunfailedsuites &lt;file&gt;：选择从早期输出文件中重新执行的失败测试套件。 -i, --include &lt;tag&gt;：通过标签选择测试用例。 -e, --exclude &lt;tag&gt;：通过标签选择测试用例。 --skip &lt;tag&gt;：具有给定标签的测试将被跳过。标签可以是模式。 --skiponfailure &lt;tag&gt;：如果失败，具有给定标签的测试将被跳过。 -v, --variable &lt;name:value&gt;：设置单个变量。 -V, --variablefile &lt;path:args&gt;：使用变量文件设置变量。 -d, --outputdir &lt;dir&gt;：定义创建输出文件的位置。 -o, --output &lt;file&gt;：设置生成的输出文件的路径。 --legacyoutput：以 Robot Framework 6.x 兼容格式创建输出文件。 -l, --log &lt;file&gt;：设置生成的日志文件的路径。 -r, --report &lt;file&gt;：设置生成的报告文件的路径。 -x, --xunit &lt;file&gt;：设置生成的 xUnit 兼容结果文件的路径。 -b, --debugfile &lt;file&gt;：在执行期间编写的调试文件。 -T, --timestampoutputs：在上述输出文件中添加时间戳。 --splitlog：将日志文件分割成较小的部分，可以在浏览器中透明地打开。 --logtitle &lt;title&gt;：为生成的测试日志设置标题。 --reporttitle &lt;title&gt;：为生成的测试报告设置标题。 --reportbackground &lt;colors&gt;：设置生成的报告的背景颜色。 --maxerrorlines &lt;lines&gt;：设置测试失败时报告中显示的错误行数。 --maxassignlength &lt;characters&gt;：设置在日志中显示的变量分配的字符数。 -L, --loglevel &lt;level&gt;：设置日志的阈值级别。可以选择性地给出默认可见日志级别，用冒号（:）分隔。 --suitestatlevel &lt;level&gt;：定义在输出中的套件统计表中显示的级别数。 --tagstatinclude &lt;tag&gt;：只在标签统计表中包含这些标签。 --tagstatexclude &lt;tag&gt;：从标签统计表中排除这些标签。 --tagstatcombine &lt;tags:title&gt;：基于标签创建组合统计。 --tagdoc &lt;pattern:doc&gt;：为指定的标签添加文档。 --tagstatlink &lt;pattern:link:title&gt;：在标签统计表中添加外部链接。 --expandkeywords &lt;name:pattern|tag:pattern&gt;：在生成的日志文件中自动展开关键字。 --removekeywords &lt;all|passed|name:pattern|tag:pattern|for|while|wuks&gt;：从生成的日志文件中删除关键字数据。 --flattenkeywords &lt;for|while|iteration|name:pattern|tag:pattern&gt;：在生成的日志文件中展平关键字。 --listener &lt;name:args&gt;：设置一个监听器以监视测试执行。 --nostatusrc：无论测试用例是否失败，都将返回代码设置为零。错误代码正常返回。 --runemptysuite：即使选择的测试套件为空，也执行测试。 --dryrun：在干运行模式下，测试将在不执行来自测试库的关键字的情况下运行。对于验证测试数据语法很有用。 -X, --exitonfailure：如果有任何测试失败，停止测试执行。 --exitonerror：如果在解析测试数据、导入库等过程中发生任何错误，停止测试执行。 --skipteardownonexit：如果测试执行提前停止，跳过拆卸。 --prerunmodifier &lt;name:args&gt;：激活测试数据的程序化修改。 --prerebotmodifier &lt;name:args&gt;：激活结果的程序化修改。 --randomize &lt;all|suites|tests|none&gt;：随机化测试执行顺序。 --console &lt;verbose|dotted|quiet|none&gt;：控制台输出类型。 --dotted：--console dotted的快捷方式。 --quiet：--console quiet的快捷方式。 -W, --consolewidth &lt;width&gt;：设置控制台输出的宽度。 -C, --consolecolors &lt;auto|on|ansi|off&gt;：指定控制台上使用的颜色。 -K, --consolemarkers &lt;auto|on|off&gt;：当测试用例中的顶级关键字结束时，在控制台上显示标记。 -P, --pythonpath &lt;path&gt;：添加到模块搜索路径的额外位置。 -A, --argumentfile &lt;path&gt;：从中读取更多参数的文本文件。 -h, --help：打印使用说明。 --version：打印版本信息。 后处理输出的命令行选项 --rpa：开启通用自动化模式。 -R, --merge：更改结果组合行为为合并。 -N, --name &lt;name&gt;：设置顶级测试套件的名称。 -D, --doc &lt;document&gt;：设置顶级测试套件的文档。 -M, --metadata &lt;name:value&gt;：为顶级测试套件设置自由元数据。 -G, --settag &lt;tag&gt;：为所有处理的测试用例设置标签。 -t, --test &lt;name&gt;：通过名称选择测试用例。 --task &lt;name&gt;：执行任务时可以使用的 --test 的别名。 -s, --suite &lt;name&gt;：通过名称选择测试套件。 -i, --include &lt;tag&gt;：通过标签选择测试用例。 -e, --exclude &lt;tag&gt;：通过标签选择测试用例。 -d, --outputdir &lt;dir&gt;：定义创建输出文件的位置。 -o, --output &lt;file&gt;：设置生成的输出文件的路径。 --legacyoutput：以 Robot Framework 6.x 兼容格式创建输出文件。 -l, --log &lt;file&gt;：设置生成的日志文件的路径。 -r, --report &lt;file&gt;：设置生成的报告文件的路径。 -x, --xunit &lt;file&gt;：设置生成的 xUnit 兼容结果文件的路径。 -T, --timestampoutputs：在上述输出文件中添加时间戳。 --splitlog：将日志文件分割成较小的部分，可以在浏览器中透明地打开。 --logtitle &lt;title&gt;：为生成的测试日志设置标题。 --reporttitle &lt;title&gt;：为生成的测试报告设置标题。 --reportbackground &lt;colors&gt;：设置生成的报告的背景颜色。 -L, --loglevel &lt;level&gt;：设置选择日志消息的阈值级别。可以选择性地给出默认可见日志级别，用冒号（:）分隔。 --suitestatlevel &lt;level&gt;：定义在输出中的套件统计表中显示的级别数。 --tagstatinclude &lt;tag&gt;：只在标签统计表中包含这些标签。 --tagstatexclude &lt;tag&gt;：从标签统计表中排除这些标签。 --tagstatcombine &lt;tags:title&gt;：基于标签创建组合统计。 --tagdoc &lt;pattern:doc&gt;：为指定的标签添加文档。 --tagstatlink &lt;pattern:link:title&gt;：在标签统计表中添加外部链接。 --expandkeywords &lt;name:pattern|tag:pattern&gt;：在生成的日志文件中自动展开关键字。 --removekeywords &lt;all|passed|name:pattern|tag:pattern|for|wuks&gt;：从生成的输出中删除关键字数据。 --flattenkeywords &lt;for|foritem|name:pattern|tag:pattern&gt;：在生成的输出中展平关键字。 --starttime &lt;timestamp&gt;：创建报告时设置测试执行的开始时间。 --endtime &lt;timestamp&gt;：创建报告时设置测试执行的结束时间。 --nostatusrc：无论测试用例是否失败，都将返回代码设置为零。错误代码正常返回。 --processemptysuite：即使文件包含空测试套件，也处理输出文件。 --prerebotmodifier &lt;name:args&gt;：激活结果的程序化修改。 -C, --consolecolors &lt;auto|on|ansi|off&gt;：指定控制台上使用的颜色。 -P, --pythonpath &lt;path&gt;：添加到模块搜索路径的额外位置。 -A, --argumentfile &lt;path&gt;：从中读取更多参数的文本文件。 -h, --help：打印使用说明。 --version：打印版本信息。 执行和后处理的环境变量 ROBOT_OPTIONS 和 REBOT_OPTIONS：默认选项的空格分隔列表，这些选项将放在命令行的任何显式选项前面。 ROBOT_SYSLOG_FILE：Robot Framework 将解析测试用例文件和运行测试的内部信息写入的系统日志文件的路径。 ROBOT_SYSLOG_LEVEL：写入系统日志文件时使用的日志级别。 ROBOT_INTERNAL_TRACES：当设置为任何非空值时，Robot Framework 的内部方法将包含在错误跟踪中。 翻译Robot Framework 支持翻译部分标题、设置、在行为驱动开发（BDD）中使用的 Given&#x2F;When&#x2F;Then 前缀，以及在自动布尔参数转换中使用的 true 和 false 字符串。本附录列出了 Robot Framework 开箱即用支持的所有语言（不包括英语）的所有翻译。 如何实际激活翻译在本地化部分有解释。该部分还解释了如何创建自定义语言定义以及如何贡献新的翻译。 简体中文 (zh-CN)部分标题 标题 翻译 Settings 设置 Variables 变量 Test Cases 用例 Tasks 任务 Keywords 关键字 Comments 备注 设置 设置 翻译 Library 程序库 Resource 资源文件 Variables 变量文件 Name Documentation 说明 Metadata 元数据 Suite Setup 用例集启程 Suite Teardown 用例集终程 Test Setup 用例启程 Task Setup 任务启程 Test Teardown 用例终程 Task Teardown 任务终程 Test Template 用例模板 Task Template 任务模板 Test Timeout 用例超时 Task Timeout 任务超时 Test Tags 用例标签 Task Tags 任务标签 Keyword Tags 关键字标签 Tags 标签 Setup 启程 Teardown 终程 Template 模板 Timeout 超时 Arguments 参数 BDD 前缀 前缀 翻译 Given 假定 When 当 Then 那么 And 并且 But 但是 布尔字符串 True&#x2F;False Values True 真, 是, 开 False 假, 否, 关, 空 ​ 文档格式化在测试数据中，可以使用简单的 HTML 格式化对测试套件、测试用例和用户关键字文档以及自由套件元数据进行文档化，以及在文档化测试库时。这种格式化类似于大多数 wiki 中使用的样式，旨在使其既可以作为纯文本理解，也可以在 HTML 转换后理解。 处理测试数据中的空白换行符在文档化测试套件、测试用例和用户关键字或向测试套件添加元数据时，可以使用 \\n 转义序列手动添加换行符。 123*** Settings ***Documentation First line.\\n\\nSecond paragraph. This time\\nwith multiple lines.Metadata Example list - first item\\n- second item\\n- third 注意 如下面的段落部分所解释的，Second paragraph, this time\\nwith multiple lines. 中的单个换行符实际上并不影响该段落的渲染。然而，创建列表或其他此类结构时需要换行符。 手动向长文档添加换行符需要一些努力，额外的字符也使文档更难阅读。不过，可以避免这种情况，因为在连续的文档和元数据行之间会自动插入换行符。实际上，这意味着上面的示例也可以按以下方式编写。 1234567891011*** Settings ***Documentation... First line....... Second paragraph. This time... with multiple lines.Metadata... Example list... - first item... - second item... - third 如果一行已经以字面换行符结束，或者以转义反斜杠结束，则不会添加自动换行符： 12345678*** Test Cases ***Ends with newline [Documentation] Ends with a newline and\\n ... automatic newline is not added.Ends with backslash [Documentation] Ends with a backslash and \\ ... no newline is added. 空格与 Robot Framework 数据的其他地方不同，文档和元数据中保留了前导空格和连续的内部空格。例如，这使得可以将列表项分割到多行，并具有带空格的预格式化文本： 12345678910111213141516*** Test Cases ***Long list item [Documentation] ... List: ... - Short item. ... - Second item is pretty long and it is split to ... multiple rows. Leading spaces are preserved. ... - Another short item.Preformatted text [Documentation] ... Example with consecutive internal spaces: ... ... | *** Test Cases *** ... | Example ... | Keyword 注意 在 Robot Framework 6.1 中，文档和元数据中保留空格是新的。在早期版本中，需要使用反斜杠转义空格。 段落在格式化的 HTML 文档中，所有常规文本都表示为段落。实际上，无论换行符是手动添加的还是自动添加的，单个换行符分隔的行将被组合成一个段落。可以使用空行（即两个换行符）分隔多个段落，而且在后续部分讨论的表格、列表和其他特殊格式化块也会结束一个段落。 例如，以下测试套件或资源文件文档： 123456*** Settings ***Documentation... First paragraph has only one line....... Second paragraph, this time created... with multiple lines. 将被格式化为 HTML： 第一段只有一行。 第二段，这次创建了多行。 内联样式文档语法支持粗体、斜体和代码的内联样式。可以通过在选定的单词或单词前后添加一个星号来创建粗体文本，例如 这是粗体。斜体样式类似，但要使用的特殊字符是下划线，例如，斜体。也可以使用 粗斜体 的语法来创建粗斜体。 代码样式是使用双反引号创建的，如 code。结果是带有浅灰色背景的等宽文本。 单独的星号、下划线或双反引号，或者在单词中间，不会开始格式化，但在它们前后的标点字符是允许的。当多行形成一个段落时，所有内联样式都可以跨多行。 内联样式示例： 未格式化 格式化 bold bold italic italic bold italic bold italic code code bold, then italic and finally some code bold, then italic and finally some code This is bold\\non multiple\\nlines. This is bold on multiple lines. URLs所有看起来像 URL 的字符串都会自动转换为可点击的链接。此外，以 .jpg、.jpeg、.png、.gif、.bmp 或 .svg（不区分大小写）结尾的 URL 将自动创建图像。例如，像 http://example.com 这样的 URL 会变成链接，而 http:&#x2F;&#x2F;&#x2F;host&#x2F;image.jpg 和 file:&#x2F;&#x2F;&#x2F;path&#x2F;chart.png 会变成图像。 URL 自动转换为链接的功能适用于日志和报告中的所有数据，但只有在测试套件、测试用例和关键字文档以及测试套件元数据中才会创建图像。 注意 .svg 图像支持是 Robot Framework 3.2 中的新功能。 自定义链接和图像可以使用特殊语法 [link|content] 创建自定义链接和嵌入图像。这将创建一个链接或图像，取决于链接和内容图像。如果它们具有与 URL 特殊的相同的图像扩展名，或者以 data:image&#x2F; 开头，那么它们就被认为是图像。在所有情况下，部分之间的周围方括号和管道字符都是必需的。 注意 对 data:image&#x2F; 前缀的支持是 Robot Framework 3.2 中的新功能。 带有文本内容的链接如果链接和内容都不是图像，最后的结果是一个普通的链接，其中链接是链接目标，内容是可见的文本： 12[file.html|this file] -&gt; &lt;a href=&quot;file.html&quot;&gt;this file&lt;/a&gt;[http://host|that host] -&gt; &lt;a href=&quot;http://host&quot;&gt;that host&lt;/a&gt; 带有图像内容的链接如果内容是图像，会得到一个链接，其中链接内容是图像。链接目标由链接创建，它可以是文本或图像： 123[robot.html|robot.png] -&gt; &lt;a href=&quot;robot.html&quot;&gt;&lt;img src=&quot;robot.png&quot;&gt;&lt;/a&gt;[robot.html|data:image/png;base64,oooxxx=] -&gt; &lt;a href=&quot;robot.html&quot;&gt;&lt;img src=&quot;data:image/png;base64,oooxxx=&quot;&gt;&lt;/a&gt;[image.jpg|thumb.jpg] -&gt; &lt;a href=&quot;image.jpg&quot;&gt;&lt;img src=&quot;thumb.jpg&quot;&gt;&lt;/a&gt; 带有标题文本的图像如果链接是图像但内容不是，语法创建一个图像，其中内容是鼠标悬停在图像上时显示的标题文本： 12[robot.jpeg|Robot rocks!] -&gt; &lt;img src=&quot;robot.jpeg&quot; title=&quot;Robot rocks!&quot;&gt;[data:image/png;base64,oooxxx=|Robot rocks!] -&gt; &lt;img src=&quot;data:image/png;base64,oooxxx=&quot; title=&quot;Robot rocks!&quot;&gt; 节标题如果文档变得较长，通常最好将其分割成几个部分。可以使用 = 我的标题 = 的语法来用标题分隔各个部分，其中等号的数量表示标题的级别： 12345678910111213= First section === Subsection ==Some text.== Second subsection ==More text.= Second section =You probably got the idea. 注意，只支持三个标题级别，并且等号与标题文本之间的空格是必需的。 表格表格是使用管道字符（带有周围空格）作为列分隔符和换行符作为行分隔符创建的。可以通过用等号（和可选的空格）包围单元格内容来创建标题单元格，如 = 标题 = 或 =标题=。表格单元格还可以包含链接和格式化内容，如粗体和斜体： 123| =A= | =B= | = C = || _1_ | Hello | world! || _2_ | Hi | 创建的表格总是有一个细边框，普通文本是左对齐的。标题单元格中的文本是粗体和居中的。空单元格会自动添加，使行长度相等。例如，上面的示例在 HTML 中的格式化如下： &#x3D;A&#x3D; &#x3D;B&#x3D; &#x3D; C &#x3D; _1_ Hello world! _2_ Hi 列表列表是通过以连字符和空格（’- ‘）开始一行来创建的。可以通过用一个或多个空格缩进连续的行来将列表项分割成多行。不以 ‘- ’ 开头且未缩进的行结束了列表： 123456Example:- a list item- second list item is continuedThis is outside the list. 上述文档在 HTML 中的格式化如下： Example: a list item second list item is continued This is outside the list. ​ 预格式化文本在文档中，可以嵌入预格式化文本块。预格式化块是通过以 ‘| ’ 开始行来创建的，除非在否则为空的行上，否则在管道字符后面的一个空格是必需的。开始的 ‘| ’ 序列将从结果的 HTML 中删除，但所有其他空白都将保留。 在以下文档中，当转换为 HTML 时，两个中间行形成一个预格式化块： 1234Doc before block:| inside block| some additional whitespaceAfter block. 上述文档格式化如下： 12345Doc before block:inside block some additional whitespaceAfter block. 水平尺水平尺（&lt;hr&gt; 标签）使得可以将较大的部分彼此分开，可以通过在一行中单独放置三个或更多的连字符来创建它们： 12345Some text here.---More text... 上述文档格式化如下： 12345Some text here.---More text... ​ 时间格式Robot Framework 有自己的时间格式，既灵活易用，又易于理解。它被几个关键字（例如，BuiltIn 关键字 Sleep 和 Wait Until Keyword Succeeds）、DateTime 库和超时使用。 作为数字的时间时间总是可以作为一个纯数字给出，在这种情况下，它被解释为秒。整数和浮点数都可以工作，可以使用实数或包含数值的字符串。 注意 注意 在某些上下文中，纯数字可以被解释为其他时间。例如，对于 WHILE 循环限制，整数表示最大迭代次数。 作为时间字符串的时间将时间表示为时间字符串意味着使用诸如 2 分钟 42 秒这样的格式，这通常比仅将值作为秒更容易理解。例如，不太容易理解 4200 秒是多长时间，但 1 小时 10 分钟立即就清楚了。 这种格式的基本思想是首先有一个数字，然后有一个文本指定该数字代表的时间。数字可以是整数或浮点数，整个格式对大小写和空格不敏感，可以添加 - 前缀来指定负时间。可用的时间说明符有： days, day, d hours, hour, h minutes, minute, mins, min, m seconds, second, secs, sec, s milliseconds, millisecond, millis, ms microseconds, microsecond, us, μs nanoseconds, nanosecond, ns 示例： 1234561 min 30 secs 1.5 minutes 90 s 1 day 2 hours 3 minutes 4 seconds 5 milliseconds 6 microseconds 7 nanoseconds 1d 2h 3m 4s 5ms 6μs 7 ns- 10 seconds 注意 在 Robot Framework 6.0 中，对微秒和纳秒的支持是新的。 作为 “计时器” 字符串的时间时间也可以以计时器格式 hh:mm:ss.mil 给出。在这种格式中，小时和毫秒部分都是可选的，当它们不重要时，可以省略前导和尾随的零，负时间可以通过添加 - 前缀来表示。例如，以下计时器和时间字符串值是相同的： 计时器和时间字符串示例 计时器 时间字符串 00:00:01 1 秒 01:02:03 1 小时 2 分钟 3 秒 1:00:00 1 小时 100:00:00 100 小时 00:02 2 秒 42:00 42 分钟 00:01:02.003 1 分钟 2 秒 3 毫秒 00:01.5 1.5 秒 -01:02.345 - 1 分钟 2 秒 345 毫秒 ​ 布尔参数Robot Framework 标准库中的许多关键字接受作为布尔值 true 或 false 处理的参数。如果这样的参数作为字符串给出，那么如果它是一个空字符串或等于 FALSE、NONE、NO、OFF 或 0（不区分大小写），则被认为是 false。除非关键字文档明确说明否则，其他字符串被认为是 true，其他参数类型使用与 Python 相同的规则进行测试。 12345678910111213*** Keywords ***True examples Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=True # 字符串通常为 true。 Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=yes # 与上面相同。 Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=$&#123;TRUE&#125; # Python 的 `True` 是 true。 Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=$&#123;42&#125; # 除 0 之外的数字为 true。False examples Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=False # 字符串 `false` 是 false。 Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=no # 字符串 `no` 也是 false。 Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=$&#123;EMPTY&#125; # 空字符串是 false。 Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=$&#123;FALSE&#125; # Python 的 `False` 是 false。 Should Be Equal $&#123;x&#125; $&#123;y&#125; Custom error values=no values # 这个关键字的特殊 false 字符串。 注意 在 Robot Framework 3.1 中，将 OFF 和 0 视为 false 是新的。 表达式求值本附录解释了在不同上下文中如何使用 Python 求值表达式，以及如何处理表达式中的变量。 简介诸如 IF&#x2F;ELSE 结构、WHILE 循环和内联 Python 求值以及几个 BuiltIn 关键字都接受一个在 Python 中求值的表达式： 1234567891011121314151617*** Test Cases ***IF/ELSE IF $&#123;x&#125; &gt; 0 Log to console $&#123;x&#125; is positive ELSE Log to console $&#123;x&#125; is negative ENDInline Python evaluation Log to console $&#123;x&#125; is $&#123;&#123;&#x27;positive&#x27; if $&#123;x&#125; &gt; 0 else &#x27;negative&#x27;&#125;&#125;Evaluate keyword $&#123;type&#125; = Evaluate &#x27;positive&#x27; if $&#123;x&#125; &gt; 0 else &#x27;negative&#x27; Log to console $&#123;x&#125; is $&#123;type&#125;Should Be True keyword Should Be True $&#123;x&#125; &gt; 0 注意，与其创建复杂的表达式，通常最好将逻辑移动到测试库中。这通常可以简化维护，并提高执行速度。 求值命名空间表达式使用 Python 的 eval 函数进行求值，因此可以使用正常的 Python 构造，如 ‘{x}’ &#x3D;&#x3D; ‘expected’、x′&#x3D;&#x3D;′expected′、{x} &gt; 0 和 ‘${x}’.upper() not in (‘FAIL’, ‘BAD’)，并且所有内置函数，如 len() 和 int() 都可用。此外，所有未识别的 Python 变量都被认为是自动导入的模块。可以使用所有可用的 Python 模块，包括标准模块和已安装的第三方模块。 以下示例演示了使用 Python 内置函数以及使用内联 Python 求值语法的模块，但相同的表达式也可以与 IF&#x2F;ELSE 结构和 BuiltIn 关键字一起工作，无需在表达式周围使用 $&#123;&#123;&#125;&#125; 装饰： 12345678910111213141516*** Variables ***$&#123;VAR&#125; 123*** Test Cases ***Python syntax Should Be True $&#123;&#123;&#x27;$&#123;VAR&#125;&#x27; == &#x27;123&#x27;&#125;&#125; Should Be True $&#123;&#123;&#x27;$&#123;VAR&#125;&#x27;.startswith(&#x27;x&#x27;) or &#x27;$&#123;VAR&#125;&#x27; in &#x27;012345&#x27;&#125;&#125;Python builtins Should Be Equal $&#123;&#123;len(&#x27;$&#123;VAR&#125;&#x27;)&#125;&#125; $&#123;3&#125; Should Be Equal $&#123;&#123;int(&#x27;$&#123;VAR&#125;&#x27;)&#125;&#125; $&#123;123&#125;Access modules Should Be Equal $&#123;&#123;os.sep&#125;&#125; $&#123;/&#125; Should Be Equal $&#123;&#123;round(math.pi, 2)&#125;&#125; $&#123;3.14&#125; Should Start With $&#123;&#123;robot.__version__&#125;&#125; 4. 使用模块的一个限制是，只有当根模块自动导入子模块时，才能使用像 rootmod.submod 这样的嵌套模块。这并不总是这样，使用这样的模块是不可能的。一个相关的具体示例是 selenium 模块，至少在撰写本文时，仅导入 selenium 并不导入 selenium.webdriver 子模块。另一个限制是，当使用 Python 3 时，模块不能在列表推导的表达式部分使用。这两个问题的解决方法是使用接受模块作为参数进行导入并添加到求值命名空间的 BuiltIn 关键字 Evaluate： 1234567891011121314*** Test Cases ***Does not work due to nested module structure Log $&#123;&#123;selenium.webdriver.ChromeOptions()&#125;&#125;Evaluate keyword with nested module $&#123;options&#125; = Evaluate selenium.webdriver.ChromeOptions() modules=selenium.webdriver Log $&#123;options&#125;Does not work due to list comprehension Log $&#123;&#123;[json.loads(item) for item in (&#x27;1&#x27;, &#x27;&quot;b&quot;&#x27;)]&#125;&#125;Evaluate keyword with list comprehension $&#123;items&#125; = Evaluate [json.loads(item) for item in (&#x27;1&#x27;, &#x27;&quot;b&quot;&#x27;)] modules=json Log $&#123;items&#125; 如果需要进一步的定制，Evaluate 关键字还支持自定义求值命名空间。有关更多详细信息，请参阅 BuiltIn 库中的文档。 ​ 使用变量正常的 ${variable} 语法当在表达式中使用正常的 {variable} 语法使用变量时，其值会在表达式求值之前被替换。这意味着在表达式中使用的值将是变量值的字符串表示，而不是变量值本身。对于数字和其他可以直接求值的对象的字符串表示，这不是问题。例如，如果有一个作为整数的返回码在变量variable语法使用变量时，其值会在表达式求值之前被替换。这意味着在表达式中使用的值将是变量值的字符串表示，而不是变量值本身。对于数字和其他可以直接求值的对象的字符串表示，这不是问题。例如，如果有一个作为整数的返回码在变量{rc} 中，使用像 ${rc} &gt; 0 这样的东西是可以的。 对于其他对象，行为取决于字符串表示。最重要的是，字符串必须始终用单引号或双引号引起来，如 ‘{x}’，如果它们可以包含换行符，它们必须用三引号引起来，如 ‘’’x′，如果它们可以包含换行符，它们必须用三引号引起来，如′′′{x}’‘’。包含引号本身的字符串会导致额外的问题，但通常可以通过三引号来处理。另外，反斜杠字符 \\ 是有问题的，但可以通过使用 Python 的原始字符串表示法，如 r’${path}’ 来处理。 123456789*** Test Cases ***Using normal variable syntax Should Be True $&#123;rc&#125; &gt; 0 IF &#x27;$&#123;status&#125;&#x27;.upper() == &#x27;PASS&#x27; Log Passed END IF &#x27;FAIL&#x27; in r&#x27;&#x27;&#x27;$&#123;output&#125;&#x27;&#x27;&#x27; Log Output contains FAIL END 特殊的 $variable 语法引用字符串并不那么方便，但有些情况下，将变量替换为其字符串表示会导致更大的问题。例如，如果变量值可以是字符串或 Python None，需要像 ‘${var}’ 这样引用，否则字符串就不起作用，但那么 None 就被解释为字符串了。幸运的是，这个部分讨论的这些问题有一个简单的解决方案。 实际的变量值在求值命名空间中可用，并可以使用没有花括号的特殊变量语法，如 $variable 来访问。这样的变量永远不应该被引用，即使它们包含字符串。 将这些示例与上一节的示例进行比较： 12345678910111213*** Test Cases ***Using special variable syntax Should Be True $rc &gt; 0 IF $status.upper() == &#x27;PASS&#x27; Log Passed END IF &#x27;FAIL&#x27; in $output Log Output contains FAIL ENDOnly possible using special variable syntax Should Be True $example is not None Should Be True len($result) &gt; 1 and $result[1] == &#x27;OK&#x27; 使用 $variable 语法会稍微减慢表达式求值的速度。这通常不应该有问题，但如果经常求值复杂的表达式，并且有严格的时间限制，应该考虑到这一点。无论如何，将这样的逻辑移动到测试库通常是一个好主意。 注意 由于技术原因，这些特殊变量在求值期间作为局部变量可用。这使得它们在非局部范围内不可用，例如在列表推导的表达式部分和在 lambda 内部。 注册本附录列出了与 Robot Framework 关联的文件扩展名、媒体类型等。 套件文件扩展名以下扩展名的套件文件会被自动解析： .robot 使用纯文本格式的套件文件。 .robot.rst 使用 reStructuredText 格式的套件文件。 .rbt 使用 JSON 格式的套件文件。 使用其他扩展名是可能的，但需要单独配置。 资源文件扩展名资源文件可以使用以下扩展名： .resource 推荐在使用纯文本格式时使用。 .robot, .txt 和 .tsv 出于向后兼容性原因，支持在纯文本格式中使用。推荐使用 .resource，将来可能会强制使用。 .rst 和 .rest 使用 reStructuredText 格式的资源文件。 .rsrc 和 .json 使用 JSON 格式的资源文件。 媒体类型使用 Robot Framework 数据的媒体类型是 text&#x2F;robotframework。 远程服务器端口默认的远程服务器端口是 8270。该端口已由 IANA 注册。 ​","categories":[{"name":"RPA","slug":"RPA","permalink":"https://www.yiuhangblog.com/categories/RPA/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"}],"author":"Yiuhang Chan"},{"title":"TagUI教程","slug":"20240418TagUI教程","date":"2024-04-18T03:39:15.000Z","updated":"2024-04-19T02:52:06.265Z","comments":true,"path":"2024/04/18/20240418TagUI教程/","permalink":"https://www.yiuhangblog.com/2024/04/18/20240418TagUI%E6%95%99%E7%A8%8B/","excerpt":"TagUI教程","text":"资源网址GitHub开源地址：https://github.com/aisingapore/TagUI 中文技术文档：http://www.tagui.com.cn/setup.html 原技术文档：https://tagui.readthedocs.io/en/latest/index.html 环境安装Windows资源下载各类TagUI安装&#x2F;插件&#x2F;资源 国内下载，请访问： 链接：https://pan.baidu.com/s/1GrkOxmu9fTBpwzO1JzaNUw?pwd=tagu 各类TagUI安装&#x2F;插件&#x2F;资源 原下载，请访问： TagUI v6.110 zip 文件: https://github.com/kelaberetiv/TagUI/releases/download/v6.110.0/TagUI_Windows.zip [MS Word 插件安装程序](https://storage.googleapis.com/tagui-dependencies/TagUI WordAddIn&#x2F;TagUIWordAddInSetupV3.18.zip)（一个使 RPA 变得非常简单的全功能应用程序） RPA 学习者提供的 有关安装和运行第一个 MS Word RPA 机器人的视频。 MS Excel 插件安装程序 (Excel 中定义 RPA 数据参数并从 Excel 运行 TagUI) RPA 学习者提供的 有关使用 Excel 插件安装和创建可视化的视频。 简易自动安装方式 (不建议)TagUI v6.46 Windows 安装包 ，下载安装即可。 手动配置安装方式 下载 TugUI zip 压缩包，下载点击： TagUI v6.109 for Windows 解压到硬盘，例如： D:\\，不建议解压在文件夹内 安装 OpenJDK for Windows（已经安装可跳过） 安装 Python （已经安装可跳过） 安装 Chrome 浏览器（已经安装可跳过） 安装 Microsoft Visual C++ Redistributable 2012 X86 版本（已经安装可跳过） 环境变量Path增加TagUI路径，注意需要scr目录，不是根目录，例如： D:\\tagui\\src 按 Win + R，输入cmd，进入CMD命令行模式。 复制下面这行命令，粘贴到CMD运行展示样例：（路径改为安装的实际路径） 1tagui D:\\tagui\\flows\\samples\\8_chineseflow.tag 系统编码设置中文Windows系统的CMD默认编码是GBK，流程执行中的中文会显示乱码，改成UTF-8编码: 首先，管理员身份打开命令提示符窗口。在窗口顶部右击选择属性，选中选项后会看到默认编码为GBK。（OEM一样乱码） Win + R 打开运行窗口后输入regedit，点击确定按钮，打开注册表窗口，按照图中的路径打开command processor项 右键新建字符串值，设置完名称后右击打开窗口后输入数值数据chcp 65001，点击确定保存，即可完成设置了 基础功能执行流程TagUI通过运行 流程文件 flows 自动执行操作，流程文件扩展名是 .tag。 可以在CMD命令提示符&#x2F;终端中运行流程： 命令使用格式： 当前目录： 1tagui my_flow.tag 绝对路径： 1tagui c:\\tagui\\samples\\1_google.tag 也可以设定按固定计划运行流程，按固定计划自动运行流程通常很有用：每月、每周、每天甚至每 5 分钟一次。例如在 Windows 上，使用任务计划程序： 快捷执行可以使用以下命令创建快捷方式文件 -deploy： 1tagui my_flow.tag -deploy 或者使缩写方式 -d： 1tagui my_flow.tag -d 这将创建一个快捷方式 (my_flow.cmd)，只需双击快捷方式即可运行流程。该快捷方式与流程位于同一文件夹中，但可以将其移动到桌面或其他任何位置。 如果想增加更多参数，例如 -headless (-h)，可以这样写命令： 1tagui my_flow.tag -h -d 注意 原.tag文件路径被移动，相关的.cmd快捷文件会失效。 运行云端.tag可以把.tag文件放在服务器，并用下面命令运行： 1tagui https://raw.githubusercontent.com/kelaberetiv/TagUI/master/flows/samples/1_google.tag 隐藏浏览器运行可以不显示Web浏览器来运行Web流程，使用 -headless 参数 1tagui my_flow.tag -headless 或使用快捷方式-h： 1tagui my_flow.tag -h 这允许在流程运行时正常使用电脑，但如果流程中使用可视自动化（例如OCR、图像识别等），则无法正常运行，因为流程需要读取并单击屏幕上的内容 基础命令自动化RPA流程是由基础命令组成的，以下是一些常见命令。 click 鼠标左键单击点击命令，可以使用它来单击Web元素： 1click Getting started 此命令单击WEB元素，点击定位可以用“ID”，“name”，“class”或“title”属性，这里有个使用 XPath的例子： XPath是一种强大的定位元素方式，例如： 1click //a[@class=&quot;icon icon-home&quot;] 还可以单击屏幕上的某个坐标点： 1click (500,300) 命令里的500和300是X-Y坐标。此命令点击距离屏幕左侧为500像素，距离屏幕顶部300像素的位置。可以在TagUI Live模式下使用 mouse_xy() 辅助函数寻找XY坐标点，当然更推荐使用一些小工具更方便的知道XY坐标。 click还可以使用图像识别(Visual Automation)单击先前保存的图像所匹配的位置。下面这条命令会在屏幕范围寻找类似 button.png 的位置，然后单击它。注意：TagUI只识别桌面区域，浏览器区域不一定识别。 1click button.png 当然，好的编程习惯，是把图片都放在 image 目录下： 1click image/button.png WEB访问直接输入网址，TagUI就会在Chrome里打开： 1https://somewebsite.com type 文本输入可以在网络输入中输入内容。此命令以与单击步骤相同的方式查找元素some-input（元素定位），并在其中键入some-text（文本内容）： 1type some-input as some-text 可以用 [clear] 来清除元素文本，用 [enter] 来按回车： 1type some-input as [clear]some-text[enter] 也可以用图片进行输入定位, 类似 click 一样： 1type some-input.png as some-text read 读取元素，可读取文本 或某些属性值用 read 命令读取元素的文本，并且赋值给变量。 下面命令里的 some-element 是元素， some-variable 是变量： 1read some-element to some-variable read 还可以使用Visual Automation和OCR功能从屏幕区域读取文本。依赖于OCR的读取可能不完全准确。 此命令读取在点（300,400）和（500,550）之间形成的矩形中的所有文本： 1read (300,400)-(500,550) to some-variable 还可以使用XPath读取Web元素的某些属性值。此命令从元素中读取ID属性： 1read //some-element/@some-attribute to some-variable assign 赋值对变量进行赋值： 此示例使用count() 辅助函数，计算在 id&#x2F;name&#x2F;text 中找到的包含“row”的元素数量，并将其分配给一个变量row_count以供以后使用： 1row_count = count(&#x27;row&#x27;) 元素定位DOM 和 XPath 标识符仅适用于 Chrome&#x2F;Edge。要自动化其他浏览器，请使用点&#x2F;区域和图像标识符。 DOM 元素属性定位1click Getting started DOM (Document Object Model) 方式用元素属性进行定位匹配，可以用 id, name, class attributes 或元素本身的文本内容定位元素。注意：这种方式可能因为同名造成定位不准确。 XPath 页面路径定位1click //body/div[1]/nav/div/div[1]/a XPath （XML Path Language）用树状结构来定位元素，表达方式可以理解成“某小区66号楼601室书房里桌子左边的第一个抽屉”。 这是针对 Web 元素的最准确的定位方式，推荐使用 XPath 进行元素定位描述。 信息 可以使用 CSS selectors 代替XPath，但XPath是首选。 Point 坐标点定位1click (200,500) 坐标原点是在屏幕左上角，横向称为X坐标，竖向称为Y坐标，Y坐标100表示从上往下100个像素的位置。本条命令会到距离屏幕左侧200像素，距离屏幕顶部500像素的位置 进行点击。 Region 屏幕区域定位1read (300,400)-(500,550) to some-variable 这与两点（300,400）和（500,550）之间形成的矩形匹配坐标点。 Image 图像定位1click button.png 在全屏范围寻找类似图像文件 button.png 的位置进行点击。首先需要截图保存为 &#96;button.png。 1click image/button.png 可以使用图片的绝对路径，同时好的编程习惯，是把图片都放到 image 目录下。并且使用容易理解的文件名，例如：button.png。 Live mode 用于调试的Live模式在流程开发中，经常需要测试下一步的操作代码，建议使用Live Mode。 1tagui live 启动 Live 模式后，可以输入一行才执行一行，这样调试起来很方便。下面这张图展示了这个操作。进入 Live Mode 时，TagUI 会自动打开Chrome。 If 条件语句if 就是“如果”怎样就怎样 的条件逻辑语言，例如：如果出现“登录按钮”就进行点击。 代码举例： 如果 URL网址包含 “success”, 就点击 buttons1 和 buttons2 123if url() contains &quot;success&quot; click button1.png click button2.png url() 是一个辅助函数，用于获取当前网页的网址URL。注意，需要 if 执行的命令，需要在前面缩进空格（或Tab），这表示它们在if块 中。如果满足条件，就执行if块 中的命令。 另一个常见的情况是判断某元素是否存在。在这里，“如果在等待超时后未出现某些元素，则访问此网页”。 12if !exist(&#x27;some-element&#x27;) https://tagui.readthedocs.io/ 这 !否定条件来自 JavaScript，TagUI 代码最终会翻译成 JavaScript。 在下面的示例中，检查变量row_count，是否等于5： 12if row_count equals to 5 some steps 以下是 大于more than 和 小于 less than 的命令方式： 1234if row_count more than 5 some stepsif row_count less than 5 some steps For 循环可以在同一流程中使用循环执行多次同样的流程。为了使用不同变量多次运行一个流程，标准方式是使用 DataTables (高级命令). 在此示例中，我们重复块内的流程总共20次： 1234for n from 1 to 20 some step to take some other step some more step functions 函数函数功能是调用 JavaScript 函数，并且返回需要的值。 每个函数后跟小括号 ()，小括号内可以填写函数的参数。 csv_row()将一些变量转换为CSV文本以写入CSV文件。它将变量作为参数输入，包含在方括号内 [] (实际上是一个数组 array). 1234read name_element to nameread price_element to priceread details_element to detailswrite `csv_row([name, price, details])` to product_list.csv clipboard() 剪贴板从剪贴板读取文本： 12345dclick pdf_document.pngwait 3 secondskeyboard [ctrl]akeyboard [ctrl]ctext_contents = clipboard() 对于大量文本内容输入，建议将文本先放到剪贴板，在用 Ctrl+V 粘贴，这比用 type 快很多： 12345long_text = &quot;This is a very long text which takes a long time to type&quot;clipboard(long_text)click text_inputkeyboard [ctrl]vkeyboard [enter] mouse_x(), mouse_y() 获得坐标点当前位置获取鼠标的x或y坐标。 在偏移点击目标时，需要先获得 x 或 y 坐标，以下代码示例表示，鼠标先移动到 element.png ，再获得偏移的 x 和 y ，然后单击元素右侧的200像素： 1234hover element.pngx = mouse_x() + 200y = mouse_y()click (`x`,`y`) mouse_xy()在Live模式下，可以使用 echo `mouse_xy()&#96; 找到鼠标的坐标。 注意，这里用的不是单引号 ‘ 而是键盘数字1左边按键的 &#96; 1echo `mouse_xy()` 高级命令保存流程运行结果tagui/src/tagui_report.csv 可以使用-report选项（快捷方式）保存运行的 html 日志和流程运行结果-r。 1tagui my_flow.tag -report CSV 文件将显示每次运行的一行、开始时间、完成时间、运行期间的任何错误消息、该运行日志文件的链接以及用户的工作组\\用户 ID。 处理异常和错误当流程没按预期进行时，有3种方法可以在Tagui中处理。 第一种方式是针对单条指令错误处理，可以增加 if 判断来预防。例如，检查是否缺少某些UI元素，然后执行XYZ步骤。使用这种方式。 第二种方式是对针对某个流程的错误处理。类似下面的语法，当 Flow.tag 成功运行时才运行。当它检测到丢失（缺少截图文件）或其他一些未知错误时，Tagui将自动抛出错误。 Windows 代码例子： 12call tagui flow.tag || tagui error.tagcall tagui flow.tag &amp;&amp; tagui success.tag 第三种方式是全局错误处理。可以对 TagUI 进行配置，以便在每次运行后，进行特殊处理，将报告选项生成的数据或文件发送到某个目标文件夹或 API 端点，以进行错误&#x2F;成功处理。例如，将所有自动化运行同步到中央存储以进行审计。特殊处理适用于所有运行的 TagUI 流。 DataTables数据表格批量自动化DataTables是 csv 文件，可以把数据表格作为变化，多次循环运行流程。 Datatable数据文件 (trade_data.csv) 类似下面格式: # trade username password pair size direction 1 Trade USDSGD test_account 12345678 USDSGD 10000 BUY 2 Trade USDSGD test_account 12345678 USDJPY 1000 SELL 3 Trade EURUSD test_account 12345678 EURUSD 100000 BUY 要使用它，可以使用 运行流程。 TagUI 将为数据表中的每一行运行一次（标题除外）。tagui my_flow.tag trade_data.csv``my_flow.tag 在流程中，TagUI 可以使用变量trade、username、password等，就好像它们位于本地对象存储库中一样，并且值将来自该运行的行。 要知道的流程处于哪个迭代中，可以使用该iteration变量： 123456echo current iteration: `iteration`if iteration equals to 1 // go to login URL and do the login steps www.xero.com// do rest of the steps for every iteration 可重用性的对象存储库对象存储库是可选的csv 文件，可以存储在流中使用的变量。它们有助于将流与个人数据（例如 Web 流的登录信息）分开，并允许在多个流之间共享通用信息以便于更新。 每个流都有一个本地对象存储库，所有流共享全局对象存储库。本地对象存储库tagui_local.csv与流位于同一文件夹中。全局对象存储库位于tagui_global.csv该tagui/src/文件夹中。 对象存储库可能如下所示： object definition email user-email-textbox create account btn btn–green btn-xl signup-btn 在流程中，TagUI 可以使用对象email,作为变量，并且在运行之前它们将直接被定义替换。局部定义优先于全局定义。create account 如果user-email-textbox是某些 Web 文本输入的标识符，那么可以在流程中使用以下内容： 1type `email` as my_email@email.com 调用流程可以通过将大型工作流程文件分解为许多子流程文件来模块化 RPA 工作流程。对于更复杂的 RPA 场景，甚至可以让一个子流程运行其他子流程。 这样做的一些常见原因包括方便在其他流程中重用相同的子流程、通过在子流程中保留步骤顺序来执行更容易组织的特定操作，或者将 Python 或 JavaScript 代码和函数存储在单独的子流程中（使用例如 py begin 和 py finish 代码块）。 在一个流程内调用另一个流程，命令如下： 1tagui login_crm.tag 被调用流程也可以存储在子文件夹中： 12345// Windows exampletagui CRM\\login.tag// Mac/Linux exampletagui CRM/login.tag 变量可以在父流程和子流程之间使用：（可以理解成变量是全局的） 1234567891011// username 和 password 变量可以被使用在 login.tagusername = &#x27;jennifer&#x27;; password = &#x27;12345678&#x27;;tagui login.tag// 也可以把变量分行来写，这样更清晰username = &#x27;jennifer&#x27;password = &#x27;12345678&#x27;tagui login.tag// 在子流程 login.tag 里，也可以定义和返回变量，给父流程使用echo `login_result` 可以在父子流中赋值变量 action = &#39;login&#39;，配合 if 来控制具体执行哪个子流程： 123456789101112131415// crm_steps.tagif action equals to &#x27;login&#x27; do some steps do some more stepselse if action equals to &#x27;report&#x27; do some steps do some more stepselse if action equals to &#x27;logout&#x27; do some steps do some more stepselse echo ERROR - action undefined Turbo mode 极速模式，10倍速运行运行流产时，可使用 turbo 参数开启极速模式（谨慎使用）： 12345tagui flow.tag -turboortagui flow.tag -t 大多数网站和桌面应用程序都无法适应TagUI的极速模式。如果RPA以超出这些网站的速度运行，经常会报错。报错的点可能是字段和数据未正确填写，表单缺少数据等。 极速模式下问题可能会随机发生，包括在PC上工作，但由于CPU速度的差异而无法在另一台PC上工作。因此，不建议使用Turbo极速模式。实际应用中，如果用极速模式造成某些数据错误，可能最终需要花费更多时间来排除或修复错误造成的后果。 但是，极速模式对某些特定场景的某些用户非常有用。例如，从应用程序中获取数据，超越人类速度的Web端数据输入等。 视觉自动化 OCR对于许多步骤，可以使用或来结束步骤，告诉 TagUI 使用 OCR（光学字符识别）与屏幕上的某些 UI 元素进行交互。请参阅下面的示例。可以执行此操作的步骤：单击、rclick、dclick、悬停、键入、选择、读取、捕捉、exist()、present()。using ocr``using OCR 12345678910click Submit using ocrif exist(&#x27;Special Offer using ocr&#x27;) click Add To Cart using OCR// various usage combinations for select stepselect Dress Color using OCR as Dark Blue using OCRselect dress_color.png as Bright Pink using ocrselect Dress Color using OCR as dark_black.pngselect dress_color.png as bright_white.png 如果使用图像编辑器将文件中 UI 元素的背景设置为.png100% 透明，则 TagUI 将能够定位该元素，无论其背景如何。 相反，还可以删除某些锚元素（例如框架）附近的前景内容，以便可以使用读取步骤对空白区域中的不同内容进行 OCR。 在流程中编写Python可以在 TagUI 流程中编写 Python 代码。Python 开发环境需要单独安装。 使用 py 命令告诉 TagUI 调用 python 运行python命令。可以将字符串值传递回 TagUI 然后在Python里 print()。 Python 运行结果将存放到 TagUI 变量 py_result 里。 12345py a=1py b=2py c=a+bpy print(c)echo `py_result` 也可以使用 py begin 和 py finish 来告诉 TagUI 这部分是 Python 语言： 1234567py begina=1b=2c=a+bprint(c)py finishecho `py_result` 可以这样将变量传递给Python： 123456789phone = 1234567py_step(&#x27;phone = &#x27; + phone)py print(phone)echo `py_result`name = &#x27;Donald&#x27;py_step(&#x27;name = &quot;&#x27; + name + &#x27;&quot;&#x27;)py print(name)echo `py_result` 要传递并返回更复杂的数据，例如多个变量，可以使用 JavaScript 和 Python JSON 库来发送和接收 JSON 字符串。传递2个变量，执行一些处理，并返回2个变量： 123456789101112131415161718192021a = 1b = 2c = &#123;&quot;a&quot;:a, &quot;b&quot;:b&#125;json_c = JSON.stringify(c)echo `json_c`py_step(&quot;json_c = &#x27;&quot; + json_c + &quot;&#x27;&quot;)py beginimport jsonc = json.loads(json_c)d = c[&quot;a&quot;] * 10e = c[&quot;b&quot;] * 10f = &#123;&quot;d&quot;:d, &quot;e&quot;:e&#125;json_f = json.dumps(f)print(json_f)py finishecho `py_result`f = JSON.parse(py_result)echo `f.d`echo `f.e` 上面将 2 个变量从 TagUI 传递到 Python，进行修改，返回 2 个变量，并显示下面的 e 和 f ： 121020 创建运行Log日志便于调试要执行高级调试，可以通过在 tagui/src/中创建一个空的tagui_logging文件，在运行流程时记录运行日志。 my_flow.log 存储一步步的执行记录。 my_flow.js 是已运行的生成的JavaScript文件。 my_flow.raw is the expanded flow after parsing modules. 运行云端 TagUI可以使用 免费 Google 服务器 运行Web浏览器或手机上的 Tagui。可以在浏览器的不同选项卡上同时运行最多5个会话。 为了对在云上运行的更多控制，可以在首选的云供应商上运行此Docker 映像 （使用边缘标签获取最新版本）或Docker 文件。 或者在 OpenFlow 上的免费 Node-RED 实例 上运行。 Docker 镜像、Docker 文件和 OpenFlow 云由Allan Zimmermann 维护和赞助。 命令手册在这里查询各种命令、辅助功能和运行选项 流程命令鼠标和键盘命令click 单击鼠标左键点击目标 可以使用 DOM, XPath Point, Image进行目标定位。 1click [DOM/XPath/Point/Image] 例子： 1234click Main conceptsclick //nav/div/div[2]/ul/li[4]/ul/li[1]/aclick (500,200)click button.png rclick 右键单击鼠标右键单击目标 可以使用 DOM, XPath Point, Image进行目标定位。 1rclick [DOM/XPath/Point/Image] 参考 click 例子。 dclick 双击鼠标左键双击目标 可以使用 DOM, XPath Point, Image进行目标定位。 1dclick [DOM/XPath/Point/Image] hover 鼠标移动鼠标移动到目标位置 1hover [DOM/XPath/Point/Image] type 输入Web输入命令，可以使用 [clear] 清除字段和 [enter] 来点击ENTER键。 可以使用 DOM, XPath Point, Image进行目标定位。 1type [DOM/XPath/Point/Image] as [text to type] 例子： 123456789type search-term as John Wicktype //input[@name=&quot;search&quot;] as John Wicktype (500,200) as John Wicktype input_field.png as John Wicktype search-term as [clear]John Wick[enter]type //input[@name=&quot;search&quot;] as [clear]John Wick[enter]type (500,200) as [clear]John Wick[enter]type input_field.png as [clear]John Wick[enter] keyboard 按键&#x2F;按组合键模拟键盘按键 1keyboard [keys] 可以使用以下这些功能按键： [shift] [ctrl] [alt] [win] [cmd] [enter] [space] [tab] [esc] [backspace] [delete] [clear] [up] [down] [left] [right] [pageup] [pagedown] [home] [end] [insert] [f1] .. [f15] [printscreen] [scrolllock] [pause] [capslock] [numlock] 例子： 12345678keyboard [win]run[enter]keyboard [printscreen]keyboard [ctrl]ckeyboard [tab][tab][tab][enter]keyboard [cmd][space]keyboard safari[enter]keyboard []c mouse 鼠标在当前鼠标位置，按下鼠标左键&#x2F;弹起鼠标左键。 12mouse downmouse up Web 网页端命令visit 打开网站&#x2F;url直接输入网址url（带上 http），TagUI 就会在 Chrome 打开这个 URL。 1[URL] 例子： 1https://google.com select 下拉选择修改下拉选择框，注意 as 后面是区分大小写的。 可以用 DOM , XPath 进行目标定位。 1select [DOM/XPath of select input element] as [option value or text] 例子： 1select variant as blue table 保存表格数据将Table表格数据保存到CSV文件，基于网页的Table编号或其XPath 进行目标定位。 12table [table number] to [filename.csv]table [XPath] to [filename.csv] 例子： 123table 1 to regional_exchange_rates.csvtable (//table)[2] to global_exchange_rates.csvtable //table[@name=&#x27;report&#x27;] to report.csv popup 把下一步操作放到新标签页把下一步操作放到新标签页里进行。 12popup [新标签页URL的特征部分] [steps] 例子：popup board 这里也可以使用 popup top.baidu.com&#x2F;board 效果是一样的。 12345https://baidu.comclick 百度热搜popup board click 电影榜 // some other steps frame 针对某些框架操作指定下一步操作的目标框架范围。 12345frame [frame name] [steps]frame [frame name] | [subframe name] [steps] 例子： 12345frame navigation click Productsframe main | register click Register download to指定 Chrome 下载文件的存储位置。默认位置是当前TagUI流程的文件夹。Specifies a location to store file downloads. The default location is the folder of the TagUI flow. 1download to [folder location] 默认情况下 TagUI 启动后 Chrome 不询问下载存放路径，可以在.tag 文件里增加下面这句，让 Chrome 在下载是询问下载文件存放目录。 1js chrome_step(&#x27;Page.setDownloadBehavior&#x27;,&#123;behavior: &#x27;default&#x27;, downloadPath: location&#125;) upload上传文件到网站。 仅支持 DOM 目标定位方式。 1upload [DOM of upload element] as [filename] 例子： 1upload #element_id as report.csv api调用Web API,并将返回内容保存到变量 api_result。 如果 API 返回的是JSON数据格式，将自动创建 api_json。 1api https://some-api-url 例子： 123api https://api.github.com/repos/kelaberetiv/TagUI/releasesecho `api_result`author = api_json[0].author.login Excel读取中文配置控制面板 &gt; 语言 &gt; 管理语言设置 &gt; 更改系统区域设置 &gt; 使用utf-8 提供全球语言支持 对 Excel 执行读取，写入，复制，删除 等操作，比如 [workbook]sheet!range 范围。 本功能适用于 Windows 和 Mac 的 Excel 程序。对于部分需要密码的Excel处理，需要用到 excel_password = &#39;password&#39;： variables 变量可以在Excel语法中使用变量，例如范围或表格 range or sheet。TagUI 支持各种版本的 Excel 文件，必须把文件的.扩展名 作为语法的一部分，以便 TagUI 可以识别指令是Excel命令而不是一些JavaScript 代码。 12[`workbook`.xlsx]`sheet`!`range` = 123data = [`workbook`.xlsx]`sheet`!`range` visibility 是否让Excel操作可见默认情况下，Excel 操作将在后台打开并运行，看不到后台的 Excel 操作。如果希望在 Excel 显示状态下操作，可以在流程中使用 excel_focus = true。使用 excel_focus = false 在工作流程中再次将其设置为OFF。 对于某些使用场景，甚至可能不希望 Excel 应用程序在后台可见。在这种情况下，可以在工作流程中设置以不可见方式运行 Excel。用于使 Excel 在 RPA 工作流程中再次可见。excel_visible = false``excel_visible = true 读取Excel从Excel文件读取数据，支持的相对路径和绝对文件路径。如果指定的文件或工作表不存在，则会显示错误。接着，可以指定单元格或某个范围。 1variable = [workbook]sheet!range 读取 列column 和 行row 可以使用标准Excel语法范围描述方式，例如： A:A (column A), B:D (columns B to D), 2:2 (row 2), 3:5 (rows 3 to 5)。如果不指定范围，则默认对全部范围进行操作。 例子： 123456789top_profit = [Monthly Report.xlsx]August!E10top_salesman = [Monthly Report.xlsx]August!E11data_array = [Quarterly Metrics.xlsx]Main!B3:G100data_array = [C:\\Reports\\June.xls]Sheet1!A1:C2data_array = [C:\\Reports\\June.xls]Sheet1!A:Adata_array = [C:\\Reports\\June.xls]Sheet1!B:Ddata_array = [C:\\Reports\\June.xls]Sheet1!2:2data_array = [C:\\Reports\\June.xls]Sheet1!3:5 Tagui 的后端语言是JavaScript，因此 Data_array 可以像 JavaScript 数组一样使用。 1234// to work on data in data_array cell by cellfor row from 0 to data_array.length-1 for col from 0 to data_array[row].length-1 echo `data_array[row][col]` 注意 - 读取多行和列有一个限制，举例： B:D and 3:5 (data array returned will be a 1 x N array instead of the correct row x column array)。这个问题在 v6.87 中已经修复。使用 tagui update 命令升级，或者用 MS Word Plug-in Update TagUI 按钮升级。 写入Excel使用 Write 命令往Excel内写数据。支持相对和绝对文件路径。如果指定的文件不存在，将创建一个新文件。如果表单不存在，将创建新表。 If the data is an array, the given cell will be used as the top-left cell to write the range of cells. 1[workbook]sheet!cell = variable 例子： 1234[Monthly Report.xlsx]August!E10 = 12345[Monthly Report.xlsx]August!E11 = &quot;Alan&quot;[Monthly Report.xlsx]August!E12 = variable[Quarterly Metrics.xlsx]Main!B3 = data_array Tagui 的后端语言是JavaScript，因此 Data_array 可以像 JavaScript 数组一样使用。 12345678910111213// to assign a set of range data with 2 rows of 3 columns[C:\\Reports\\June.xls]Sheet1!A1 = [[1, 2, 3], [4, 5, 6]][C:\\Reports\\June.xls]Sheet1!A1 = [[variable_1, variable_2, variable_3], [4, 5, 6]]// example spreadsheet data with #, name and country[Participants.xlsx]Sheet1!A1 = [[&#x27;1&#x27;, &#x27;John&#x27;, &#x27;USA&#x27;], [2, &#x27;Jenny&#x27;, &#x27;Russia&#x27;], [3, &#x27;Javier&#x27;, &#x27;Serbia&#x27;]]// get the next row count for the example spreadsheetcolumn_A = [Participants.xlsx]Sheet1!A:Anext_row = column_A.length + 1// write a new row accordingly to example spreadsheet[Participants.xlsx]Sheet1!A`next_row` = [[next_row, &#x27;Janice&#x27;, &#x27;Brazil&#x27;]] copy 复制在Excel文件中复制数据。支持相对和绝对文件路径。如果指定的目标文件不存在，将创建一个新文件。如果目标工作表不存在，将创建一个新工作表。如果数据是数组，则给定单元格将用作左上角单元格来写入单元格范围。 1[workbook]sheet!cell = [workbook]sheet!range 例子： 12[Monthly Report.xlsx]August!A1 = [Jennifer Report.xlsx]August!A1[Monthly Report.xlsx]August!A1 = [Jennifer Report.xlsx]August!A1:E200 delete 删除删除 Excel 内的数据。支持相对和绝对文件路径。如果指定的文件或工作表不存在，将显示错误。Delete a range of cells by assigning an empty array to it. 1[workbook]sheet!cell = &quot;&quot; 例子： 12[Monthly Report.xlsx]August!E10 = &quot;&quot;[Quarterly Metrics.xlsx]Main!A1 = [[&quot;&quot;, &quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;, &quot;&quot;]] Word只需将 Microsoft Word 文档的文件名分配给变量即可读取其文本内容，如下所示。 TagUI 将自动 Microsoft Word 复制文本内容并分配给变量。此功能适用于 Windows 和 Mac。 Windows 设置word文件路径举例： 12345678word_text = [Research Report.docx]word_text = [C:\\Users\\Jennifer\\Desktop\\Report.docx]word_text = [FY2021 Reports\\Research Report.docx]filename = &#x27;C:\\\\Users\\\\Jennifer\\\\Desktop\\\\Report&#x27;word_text = [`filename`.docx]filename = &#x27;Research Report&#x27;word_text = [`filename`.docx] Mac 设置word文件路径举例： 12345678word_text = [Research Report.docx]word_text = [/Users/jennifer/Desktop/Report.docx]word_text = [FY2021 Reports/Research Report.docx]filename = &#x27;/Users/jennifer/Desktop/Report&#x27;word_text = [`filename`.docx]filename = &#x27;Research Report&#x27;word_text = [`filename`.docx] 将文本内容读入变量后，可以使用Tagui的函数来处理它，例如 get_text() 和 del_chars()，以获得RPA流程所需的特定信息。标准JavaScript函数也可用于进行字符串处理，可以 Google 搜索 javascript how to xxxx。 从 Word 读取文本内容后，TagUI 将关闭 Microsoft Word 并继续执行接下去的流程。 PDF只需要将文件名分配给变量，就可以将PDF文件的文本内容赋值给变量。TagUI 将自动执行 PDF Viewer 应用程序以复制文本内容并分配给变量。在 Windows 系统, 需要安装 Adobe Acrobat Reader，并且设置为打开pdf的默认程序。在Mac 系统, TagUI 使用可以查看PDF文件的默认预览应用程序。 Windows 设置pdf文件路径举例： 12345678pdf_text = [Research Report.pdf]pdf_text = [C:\\Users\\Jennifer\\Desktop\\Report.pdf]pdf_text = [FY2021 Reports\\Research Report.pdf]filename = &#x27;C:\\\\Users\\\\Jennifer\\\\Desktop\\\\Report&#x27;pdf_text = [`filename`.pdf]filename = &#x27;Research Report&#x27;pdf_text = [`filename`.pdf] Mac 设置pdf文件路径举例： 12345678pdf_text = [Research Report.pdf]pdf_text = [/Users/jennifer/Desktop/Report.pdf]pdf_text = [FY2021 Reports/Research Report.pdf]filename = &#x27;/Users/jennifer/Desktop/Report&#x27;pdf_text = [`filename`.pdf]filename = &#x27;Research Report&#x27;pdf_text = [`filename`.pdf] 将文本内容读入变量后，可以使用 Tagui 的函数 get_text() 和 del_chars() 来获得RPA流程所需的特定信息。标准JavaScript函数也可用于进行字符串处理，具体可以 Google 搜索javascript how to xxxx。从PDF文件读取文本内容后，TagUI将关闭PDF查看器并继续使用其余自动化步骤。 Using variables 使用变量read 读取目标内容放入变量获取一些文本或值并将其存储在变量中。 可以使用 DOM, XPath, Region, Image 进行目标定位。 1read [DOM/XPath/Region/Image] to [variable] 当提供区域Region 或 图像Image 元素特征时，Tagui 会使用OCR从屏幕中读取字符。 例子： 1234567read //p[@id=&quot;address&quot;] to addressread //p[@id=&quot;address&quot;]/@class to address-classread (500,200)-(600,400) to id-numberread frame.png to email 变量赋值将文本保存到变量。 1[variable] = [value] 在值中使用文本时，请围绕引号中的文本，如 “某些文本”。这使用 JavaScript 的规则，因此可以将数字分配给变量或使用其他 JavaScript 函数。变量名称需要是一个单词，不能以数字开头。 例子： 123count = 5username = &quot;johncleese&quot;fullname = firstname + lastname File saving&#x2F;loading 文件保存和读取dump 文本保存到文件将文本保存到新文件，例如把一个文本变量，保存到一个txt里。 1234dump [text] to [filename]dump [`variable`] to [filename]// creates blank CSV file with headerdump First Name,Last Name to names.csv write 追加写入将新的文本保存到现有文件中。 12write [text] to [filename]write [`variable`] to [filename] 例子： 12write firstname,lastname to names.csvwrite `fullreport` to report.txt load 读取将文件内容加载到变量。 1load [filename] to [variable] 例子： 1load report.txt to report snap 截屏屏幕截图功能，可以是全屏、某个元素或区域。 可以使用 DOM, XPath, Region, Image 进行目标定位。 1snap [DOM/XPath/Region/Image/page] to [filename] 如果使用 page 定位目标，会把整个网页进行截图。 例子： 123snap logo to logo.pngsnap page to webpage.png 显示输出echo 信息输出在命令行上显示输出内容，比如显示变量。 12echo [text]echo [`variable`] 例子： 12echo Flow has startedecho The user is `username` show 显示元素文本在命令行上直接显示元素文本。 可以用 DOM, XPath 进行目标定位。 1show [DOM/XPath] 例子： 1show review-text check 根据条件显示文本基于条件显示不同文本信息。 1check [条件] | [结果为 true 的文本] | [结果为 false 的文本] 例子： 1check header_home_text equals to &quot;Home&quot; | &quot;header text is correct&quot; | &quot;header text is wrong&quot; Custom code 自定义代码JavaScript运行 JavaScript 代码。TagUI 直接访问 JavaScript 变量。 TagUI 可以“智能”判断以下 3 种情况使用，无需使用js或js begin&#x2F; js finish： 分配或改变变量 分配变量时，TagUI 可以检测&#x3D;符号并自动将该行视为 JavaScript 代码。 以 ; 结尾：如果一行以 ; 字符结尾，并且该行无法匹配任何已知的 TagUI 命令，则将其视为 JavaScript 代码。 常见的JavaScript关键字开头：如果一行无法匹配任何已知的 TagUI 命令，并且该行以常见的JavaScript 关键字（例如 if、for、switch、else、while、case、break、continue 等）开头，它将自动被视为 JavaScript 代码。 js，js begin和js finish方式使用 - 1js 1-line JavaScript code 12345js beginJavaScript code line 1JavaScript code line 2JavaScript code line 3js finish 每当有一些 JavaScript 代码（除了 TagUI 步骤或辅助函数之外的任何代码）时，都需要上面的代码。然而，TagUI 可以“智能”地检测到以下 3 种使用 JavaScript 但js不需要的情况。 12345js [JavaScript statement]js begin[JavaScript statements]js finish 例子： 123456789101112131415js obj = JSON.parse(api_result)dump `obj` to result.jsonjs beginobj = JSON.parse(api_result)randomInteger = Math.floor(Math.random() * Math.floor(5)) + 1js finishdump `obj` to result.json// declare and initilise variable to use it inside/outside js code blocka = &quot;&quot;js begina = &quot;some string&quot;js finishecho `a` 1. 分配或更改变量 当分配变量时，TagUI 可以检测符号=并自动将该行视为 JavaScript 代码，而无需用户显式使用js或js begin&#x2F; js finish。 1name = &quot;Johnny&quot; 2. 以 ; 结尾的行特点 如果一行以;字符结尾，并且该行无法匹配任何已知的 TagUI 步骤，则将其视为 JavaScript 代码。 12// below line quit TagUIthis.exit(); 3. 常用JavaScript关键字 如果一行无法匹配任何已知的 TagUI 步骤，并且该行以常见的 JavaScript 关键字（例如 if、for、switch、else、while、case、break、continue 等）开头，它将自动被视为 JavaScript 代码，而无需使用js. 1234for n from 1 to 10 echo `n` if n equals to 5 break Python运行Python代码并将stdout 保存到变量 py_result 作为字符串。 12345py [Python statement]py begin[Python statements]py finish 例子： 12345678910py result = 2 + 3py print(result)echo `py_result`py beginimport randomrandom_integer = random.randint(1,6)print(random_integer)py finishecho `py_result` 有关运行Python代码的更多示例和使用模式查看高级命令 RUN在命令提示符或终端中运行命令，并将 stdout 保存到变量 run_result。 1run [shell command] 例子： 1run cmd /c mkdir new_directory Sikuli运行 Sikuli 代码，例如需要把OCR设置成中文 123456vision beginimport org.sikuli.script.TextRecognizer as TRSettings.OcrReadText = TrueSettings.OcrLanguage = &quot;chi_sim&quot;TR.reset()vision finish 例子： 1vision click(&quot;button1.png&quot;) DOM在浏览器 DOM 中运行代码并将返回值保存到变量 dom_result。 12345dom [JavaScript statement to run in the DOM]dom begin[JavaScript statements to run in the DOM]dom finish 例子： 12345// goes back to previous pagedom window.history.back()// returns text of an elementdom return document.querySelector(&#x27;#some_id&#x27;).textContent R运行 R 语句并将 stdout 保存到变量 r_result。 12345r [R statement]r begin[R statements]r finish 更多命令wait 等待等待一段时间，默认时间单位：秒。 123wait [seconds to wait]wait [seconds to wait] swait [seconds to wait] seconds 例子： 123wait 5.5wait 10 swait 20 seconds timeout 设置等待超时等待 Web 元素出现时，设置自动等待超时（默认为10秒）。 1timeout [seconds to wait before timeout] 例子： 1timeout 300 ask提示用户输入，并将用户输入内容保存为变量 ask_result。 1ask [prompt] 例子： 12ask What is the date of the receipt? (in DD-MM-YYYY)type search as `ask_result` live一步步执行命令并立即看到输出。输入 “done” 退出Live模式。 1live tagui 调用流程调用另一个 TagUI 流程，注意文件路径别写错。 12tagui [flow file]tagui [folder/flow file] 例子： 12tagui update-forex.tagtagui flows/update-forex.tag &#x2F;&#x2F; 添加注释添加代码注释。在使用条件或循环命令是，注释也要相应缩进，以便在转换为JavaScript代码后正确运行。 1// 这里写注释，不会被程序运行 例子： 1// 点击登录按钮 TelegramTelegram 是国外的一款聊天软件，中国使用人数极少。TagUI 通过发送 telegram 消息，及时获得机器人的工作结果或报错状态信息。国内一般都用 企业微信、钉钉等。 首先要获得 @taguibot 发消息授权，然后再用 TagUI 下面的命令： 1telegram [id] [message] 例子： 1234567891011// this line sends message to Telegram user with ID 1234567890, \\n means a new linetelegram 1234567890 Hello Alena,\\n\\nYour HR onboarding bot has completed successfully.// show telegram_result variable - &#x27;success&#x27; means sent, &#x27;fail&#x27; means sending failedecho Telegram message - `telegram_result`// if condition to check telegram_result &#x27;success&#x27; or &#x27;fail&#x27; and handle accordinglyif telegram_result equals to &#x27;success&#x27; echo Message sent successfully.else echo Message sending failed. 注意 电报步骤需要互联网连接。此功能托管在https://tebel.org 上，但如果希望在自己的云或服务器上托管此功能，则源代码 位于 GitHub 上。该实现是在纯 PHP 中实现的，没有任何依赖项。 记录的唯一信息是 chat_id、消息长度、日期时间戳（以防止滥用）。如果希望自行托管，请首先阅读此链接以了解有关 Telegram Bot API、创建的 bot API 令牌并设置 webhook 的更多信息 - https://core.telegram.org/bots Run options 运行流程选项可以使用 tagui 命令，查看选项说明。 举例：这条命令运行 my_flow.tag 而隐藏Web浏览器，同时把流程运行结果存储到 tagui_report.csv 中。 1tagui my_flow.tag -headless -report -deploy or -d 生产CMD快捷方式创建一个可以双击运行流程的快捷方式。如果移动文件，则必须创建一个新的快捷方式。流程将在创建快捷方式时使用的所有选项运行。 -headless or -h 隐藏浏览器运行时，隐藏 Chrome Web浏览器（隐藏浏览器就无法使用 Visual Automation）。 -nobrowser or -n 不使用Web浏览器不使用Web浏览器，例如仅使用可视自动化执行自动化。 -report or -r 保存HTML日志追踪流程运行结果，记录在tagui/src/tagui_report.csv 中，并保存流量执行的HTML日志。 -turbo or -t 十倍速运行在10倍的速度下运行流程。谨慎使用！ -quiet or -q 减少非主动信息输出除了 echo, show, check steps and errors etc 之外，不显示其他输出。在执行期间显示和隐藏输出的细粒度控制（例如，隐藏密码显示出来）, 可以在流处里使用 quiet_mode = true 和 quiet_mode = false 进行控制。 -edge or -e 使用Edge浏览器使用 Microsoft Edge浏览器而不是Chrome运行（可与-headless选项一起使用）。 my_datatable.csv使用指定的CSV文件作为批量自动化的DataTable。查看 datatables 。 input(s) 流程参数添加自己的流程参数，在的流程中做为变量P1至P8使用。 例如在CMD里,运行 register_attendence.tag 流程，需要用 Edge 浏览器，同时向该流程输入4个变量（4个人名）。 1tagui register_attendence.tag -edge Jenny Jason John Joanne 在流程里, 4个人名会自动分配给4个变量 p1, p2, p3, p4 。例如在需要输入不同数据时，就特别方便，下面的命令会显示出这4个变量，可以试试。 1234echo `p1`echo `p2`echo `p3`echo `p4` 辅助函数csv_row()以数组方式写入CSV文件。 例子： 1234read name_element to nameread price_element to priceread details_element to detailswrite `csv_row([name, price, details])` to product_list.csv count() 数量计算获取符合指定元素特征的元素数，例如计算有多少个新闻标题，然后用for读取它们。请注意，元素特征需要单引号 &#39;&#39;。 例子： 1rows = count(&#x27;table-rows&#x27;) clipboard() 剪贴板将文本放在剪贴板上，或获取剪贴板文本。 例子： 12345clipboard(&#x27;some text&#x27;)keyboard [ctrl]vkeyboard [ctrl]ccontents = clipboard() url() 获取当前URL获取当前网页的URL。 例子： 12if url() contains &#x27;success&#x27; click button1 title() 获取当前网页标题。获取当前网页的标题title。 例子： 12if title() contains &#x27;Confirmation&#x27; click button1 text()获取当前网页的所有文本内容。 例子： 12if text() contains &#x27;success&#x27; click button1 timer()获得一段命令执行的时间周期，时间单位：秒。 例子： 12345timer()click button1click button2click button3echo `timer()` exist() 等待元素出现等待元素出现，如果元素出现返回true ，如果元素等待时间超时，元素还没有出现，就返回 false，通常在网页搜索、查询等流程时使用本命令，以确定查询结果已经出现后，才继续下面的流程。请注意，元素特征包含在引号 ‘’ 内。 可以使用 DOM, XPath, Image 进行目标定位。 1exist(&#x27;[DOM/XPath/Image]&#x27;) 例子： 12if exist(&#x27;//table&#x27;) click button1 present() 判断元素是否存在判断元素是否存在，并且直接返回 true 或 false。 请注意，元素特征包含在单引号 &#39; 内。 可以使用DOM, XPath, Image 进行目标定位。 例子： 12if present(&#x27;//table&#x27;) click button1 mouse_xy()获取当前鼠标位置的x，y坐标。 适合用在 live mode。 例子： 1echo `mouse_xy()` mouse_x()获取当前鼠标位置的 x 坐标。 例子： 1234hover element.pngx = mouse_x() + 200y = mouse_y()click (`x`,`y`) mouse_y()获取当前鼠标位置的 y 坐标。 例子： 1234hover element.pngx = mouse_x() + 200y = mouse_y()click (`x`,`y`) get_files()获取文件或文件夹列表，支持相对和绝对路径。Returns an array of files and folders in a given folder. Both relative and absolute paths supported. 例子： 12345678910111213141516171819// list of files in the same folder as the flow filelist = get_files(&#x27;.&#x27;)// list of files in the Desktop folder of user Alan// note double backslash because of JavaScript stringlist = get_files(&#x27;C:\\\\Users\\\\Alan\\\\Desktop&#x27;)// alternatively, use single forward slash insteadlist = get_files(&#x27;C:/Users/Alan/Desktop&#x27;)// showing the list of files after retrieving it// JavaScript array start from 0 for 1st elementfor n from 0 to list.length-1 echo `list[n]`// checking to process a specific file extensionfor n from 0 to list.length-1 if list[n] contains &#x27;.XLSX&#x27; echo `list[n]` get_text() 截取文本从文本中提取2的锚点之间的文本。当有多个匹配结果时的可选第4参数（例如，3判断函数返回找到的第3匹配）。 例子： 1234567pdf_text = &#x27;Name: John State: Texas City: Plano Contact: ...&#x27;name = get_text(pdf_text, &#x27;Name:&#x27;, &#x27;State:&#x27;)state = get_text(pdf_text, &#x27;State:&#x27;, &#x27;City:&#x27;)city = get_text(pdf_text, &#x27;City:&#x27;, &#x27;Contact:&#x27;)echo `name`, `state`, `city` del_chars() 删除文本删除特征字符后的文本，并返回结果来清除数据。Cleans data by removing provided character(s) from given text and returning the result. 例子： 12pdf_text = &#x27;Name: John\\n State: Texas\\t City: Plano\\n Contact: ...&#x27;echo `del_chars(pdf_text, &#x27;\\n\\t:&#x27;)` get_env() 获得当前用户环境变量从操作系统返回给定环境变量的值。例如：C:\\Users\\Administrator 例子： 1234567// getting %USERPROFILE% variable for Windowsecho `get_env(&#x27;USERPROFILE&#x27;)`home_dir = get_env(&#x27;USERPROFILE&#x27;)// getting $HOME variable for Mac or Linuxecho `get_env(&#x27;HOME&#x27;)`home_dir = get_env(&#x27;HOME&#x27;) RPA for Python (TagUI 在 Python 里使用)RPA for Python 是一个 Python 库 (安装方式：pip install rpa) 这个库可以使用 Python API 来调用 TagUI 执行自动化RPA操作。查看 这里 ， RPA for Python 由 TagUI’s creator Ken Soh @kensoh 创建和维护。 TagUI 源代码的和依赖库可以查看这些源代码，帮助这些项目的迭代及Bug修复，因为这些项目都有大量用户在使用。 TagUI - https://github.com/kelaberetiv/TagUI SikuliX - https://github.com/casperjs/casperjs PhantomJS - https://github.com/ariya/phantomjs SlimerJS - https://github.com/laurentj/slimerjs Python - https://github.com/python/cpython R - https://github.com/wch/r-source PHP - https://github.com/php/php-src 示例代码块第一个例子TagUI 支持运行服务器上的.tag文件，试试直接输入下面命令，会打开百度进行简单点击操作。 1tagui http://www.TagUI.com.cn/baidu.tag 把cmd设置成UTF-8这样在CMD环境里，echo输出就可以正常显示简体中文。 12// 把cmd设置成UTF-8run cmd /c chcp 65001 字符串查找替换字符串替换命令，TagUI字符串处理，请参考 JS 语法 123//字符串查找替换txt=&quot;http://baidu.com&quot;txt=txt.replace(&quot;baidu&quot;,&quot;kkyyww&quot;) 查找字符串目标文字位置，参考JS语法 123//查找字符串目标文字位置字符位置=txt.lastIndexOf(&quot;du.&quot;)echo `字符位置` 下载图片下载图片需要用curl.exe这个命令，百度 curl 具体了解。 12// 下载图片run curl -k -s -L -o c:/aaa.png http://www.bbb.com/ccc.jpg download 命令的使用例子download命令下载视频 1234https://www.videvo.net/video/apollo-command-and-service-module-separation/8/download to C:\\Users\\Administrator\\Documents\\TagUI\\TCvideo\\vclick //*[@id=&quot;download-button&quot;]wait 10 API 例子调用有道API翻译，初学者可以看看这里的数组处理方式 12345// 用API翻译api http://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=i love you中文词 = JSON.parse(api_result)中文词 = 中文词[&quot;translateResult&quot;][0][0][&quot;tgt&quot;]echo `中文词` 抓取百度首页新闻标题循环抓取 XPATH 的例子 1234567// 抓取百度首页新闻标题http://baidu.com新闻总数量 = count(&#x27;/html/body/div[1]/div[1]/div[5]/div/div/div[3]/ul/li[*]/a/span[2]&#x27;)echo `新闻总数量`for i from 1 to 新闻总数量 read /html/body/div[1]/div[1]/div[5]/div/div/div[3]/ul/li[`i`]/a/span[2] to 标题 echo `标题` 判断目录内是否包含指定扩展名文件判断目录内是否包含指定扩展名文件，可用于判断下载是否完成 12345// 判断目录内是否包含指定扩展名文件，可用于判断下载是否完成list = get_files(&#x27;C:\\\\Users\\\\Administrator\\\\Documents\\\\TagUI\\\\TCvideo\\\\v\\\\视频翻译\\\\&#x27;)指定扩展名=&quot;mp4&quot;echo `list[1].indexOf(指定扩展名)`echo `字符位置` 判断chrome是否下载完成判断chrome是否下载完成 123456789101112// 判断chrome是否下载完成https://www.videvo.net/video/8//wait 3click download-buttonwait 3for n from 1 to 100 echo `present(&#x27;mb.png&#x27;)` if present(&#x27;mb.png&#x27;) wait 3 else echo 下载完成 break 读取excel，写入txt读取excel，写入txt 12345//读exceldata_array = [1.xlsx]sheet1!A1:B3echo `data_array`dump `data_array` to 0.txtwait 5 打开变量里的URL下面2种方法都可以，推荐用第二种 12345678//打开变量里的URLurl = &#x27;https://baidu.com&#x27;https://`url.split(&#x27;//&#x27;)[1]`//打开变量里的URL，推荐用这种方式，简单点url = &#x27;baidu.com&#x27;https://`url` 环境初始化杀死TagUI相关进程，包括chrome，避免上一个tag没完成或卡主，影响当前tag运行 12// 环境初始化，杀死TagUI相关进程，包括chromerun cmd /c d:/tagui/src/end_processes.cmd 获得本机名获得本地Windows计算机名 1234//获得本机名run cmd /c hostnamepcname=run_resultecho `pcname`","categories":[{"name":"RPA","slug":"RPA","permalink":"https://www.yiuhangblog.com/categories/RPA/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"}],"author":"Yiuhang Chan"},{"title":"CUDA安装","slug":"20240402CUDA安装教程","date":"2024-04-02T01:35:05.000Z","updated":"2024-04-18T03:39:49.000Z","comments":true,"path":"2024/04/02/20240402CUDA安装教程/","permalink":"https://www.yiuhangblog.com/2024/04/02/20240402CUDA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"CUDA安装","text":"CUDA安装确定版本打开NVIDA Control Panel（桌面右键）-&gt;选择左下角的系统信息-&gt;组件 查看后前往kCUDA Toolkit Archive | NVIDIA Developer 下载 安装流程 下载 CUDA Toolkit: 双击下载的 exe 文件开始安装，建议选择默认下载路径以避免后续配置复杂性。 安装前的选择: 如果这是第一次安装 CUDA，建议选择全选以安装所有组件。 如果之前已安装过 CUDA，建议只选择必要的组件以避免潜在的冲突，通常至少需要选择 Toolkit。 临时解压目录: 安装程序会首先要求设置临时解压目录，建议使用默认设置。安装结束后，该目录会自动删除。 安装目录: 接下来会要求设置安装目录，也建议保持默认。 注意： 临时解压目录不应该与 CUDA 的安装路径设置成一样，以避免安装完成后找不到安装目录的问题。 环境变量配置: 安装完成后，需要配置 CUDA 的环境变量以便于命令行工具的使用。 打开“控制面板” &gt; “系统和安全” &gt; “系统” &gt; “高级系统设置” &gt; “环境变量”。 在“系统变量”中找到 Path 变量，点击“编辑”。 添加 CUDA Toolkit 的 bin 目录和 libnvvp 目录到 Path 变量中。通常这些目录位于 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\vX.X\\bin 和 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\vX.X\\libnvvp。 注意： X.X 应替换为您安装的 CUDA 版本号。 验证安装: 打开命令提示符窗口。 输入 nvcc --version 检查 CUDA 编译器的版本，确认安装成功。 输入 set cuda 查看 CUDA 设置的环境变量，确保它们被正确设置。","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://www.yiuhangblog.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"CUDA","slug":"CUDA","permalink":"https://www.yiuhangblog.com/tags/CUDA/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.yiuhangblog.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"author":"Yiuhang Chan"},{"title":"弘玑 Cyclone RPA","slug":"20240401弘玑Cyclone RPA","date":"2024-04-01T03:44:05.000Z","updated":"2024-04-02T00:55:43.000Z","comments":true,"path":"2024/04/01/20240401弘玑Cyclone RPA/","permalink":"https://www.yiuhangblog.com/2024/04/01/20240401%E5%BC%98%E7%8E%91Cyclone%20RPA/","excerpt":"弘玑Cyclone RPA","text":"弘玑 Cyclone RPARPA的特征与业务价值什么是RPARPA，全称 “机器人流程自动化” (Robotic Process Automation), 它的核心技术是从自动化测试工具和桌面自动化技术中发展而来的。 RPA是近些年新兴的一个IT领域，其本质是基于软件的机器人，结合包括AI在内的各项技术，为企业实现业务流程自动化的产品&#x2F;解决方案。 PRA的特征汇总 软件机器人 模拟和替代人工的操作 核心能力，比如键盘，鼠标，登录，切换页面和粘贴数据等操作 非侵入式串接不同的系统 PRA实现了无缝跨系统的集成 界面捕捉对象，内容和数据等 无需改动后端程序，无接口，无需调整数据库结构，表层集成 一组技术的组合 屏幕抓取，工作流，流程控制和拖拽等易用性特征 类似工作流的执行能力 执行的是具有固定规则、工作量大的任务 快速实施 RPA客户目标节省成本结合流程标准化的机会引入机器人工具自动化流程可以至少节省30%-50% 生产性 自动化工具最高可提升到人力的5倍工作 24x7 人们可以专注更重要的任务 正确性通过机器人工具消除人工干预能让处理正确性达到100% 扩展性&#x2F;灵活性 数字员工可适用于不同地点和流程 提供可扩展及可协作性 可通过扩展适应业务的迅速变化 合规 可适应区域性数据存储需求 规则驱动的交易处理可以持续满足财务需求 全程可追溯，全生命周期日志 安全 不会有因为人工干预丢失数据的风险 全程无人干预，可以进行 保密数据的传输可按需设定安全权限 Cyclone RPA 三件套协同工作数字员工执行器 根据脚本自动完成所需的业务处理 数字员工设计器 设计开发自动化流程文件 脚本文件 数字员工中央控制台 管理流程的运行 监控任务的完成和记录相关的数据等 组件流程 无人值守自动化无需人工参与的自动化 如绝大多数重复性文本核对工作 有人值守自动化人与机器人协同工作 Cyclone RPA 应用场景财务 财务录入 报告生成 财务核对 银行对账 账户查询提醒 应收账款处理 应付账款 账户结算 纳税申报 费用报销 人力资源 招聘管理 简历收集及筛选 入职及离职 考勤管理 员工数据管理 报告生成 薪酬管理 培训管理 供应链 订单处理 供应商对账 主数据管理 第三方平台对账 内部对账 货单处理 库存管理 采购管理 凭证录入 关账与报表合并 IT 用户权限管理 密码重置&#x2F;解锁系统监控 系统运维|信息抓取 工单处理|邮件分发 网络信息抓取 数据清洗 数据导入批处理 数据备份与恢复 Helpdesk热线 银行 账单核对 征信查询 信用卡积分管理 对公账户信息录入 资质审核|信用凭证自动化 经销商发票勾兑 业务对账 验证贷款申请 保险 录入业务账单 客户服务 承保合规性 优化客户理赔体验 账单处理 收益分析及计算 每日战报 经典落地场景账单录入 客户类型：某保险公司 适用部门:账单部门 业务内容:根据账单部门收到的格式不一的账单，整理并录入业务核心系统，并发送邮件报告 工作量:1000~2000 张账单&#x2F;月 使用效果:月末账单录入时间大大减少，提升50%账单录入速度，零错误率 设计器安装 Cyclone Log Viewerd 当流程使用 Cyclone Server运行时，选择了输出日志，此时Cyclone Server 会输出日志文件，Cyclone Log Viewerd查看日志文件内容。 Cyclone Server用来执行流程，添加触发器以及查看流程运行记录。 Cyclone Starter流程设计器，RPA流程的开发，设计都可以在此程序中完成，同时，支持自定义组件可以更好的支持定制化流程。 启动安装完成后，双击Cyclone Starter启动设计器。 注意 注意以管理员身份运行 流程版本管理与发布 流程mrpax文件的命名 发布后的流程mrpax文件的命名模式并不唯一但至少应当考虑明确其环境信息。 推荐使用类似的命名方式:【客户名称简写】【环境简称】【流程业务简称】.mrpax 如:中石化云南 UAT 企业账户费用核销.mrpax格力珠海 Prod 客户应收应付日报 20210702.mrpax 基本概念流程流程是应用的组成单元，一个流程包含一系列顺序执行的指令。流程之间可以相互调用。在应用运行时，会从主流程开始执行，并顺序执行主流程中包含的指令和调用的子流程。主流程不可被删除。 作用域作用域是指一个变量存在或可被使用的范围。如全局变量的可被使用范围是整个应用，而在循环中插入的变量，可被使用的范围仅是当前循环中。在变量所在域之外，变量会被回收。 组件指令&#x2F;组件是流程的组成单元，也是RPA最基本的组成单元。每一个指令对应一个具体的计算机操作动作。如“打开Excel文件”、“获取元素文本内容”，“条件判断”等。指令分为内置指令、外置指令和市场指令三种。内置指令随客户端版本一一起更新，外置指令可以在切换应用时动态加载不同的版本，也可以在指令管理面板手动切换版本。市场指令是从指令市场获取的指令，可以在指令管理面切换版本或删除。 变量内存中的一块空间存储某个值，空间中存储的值是可以改变的，这个空间就是变量。简单的说，就是给应用和流程中用到的数据取一个名字，在流程中可以通过名字使用这个数据。变量中可以储存数字、字符串、列表等类型的数据，也可以储存数据表格、excel、页面元素等具有复杂结构的数据。变量分为全局变量和局部变量，全局变量可以在整个应用范围内被引用。而局部变量可在流程中任意位置插入，在插入位置之后，在当前变量的所在域中，可以被使用。 参数参数是一种特殊的变量，是数据传递的介质。应用输入参数是在应用运行前，需要用户输入的数据。参数也可以用来在应用与应用之间，或流程与流程之间进行数据传递。不过，在流程之间传递数据也可以通过全局变量来实现。 元素元素（或界面元素）是一种特殊的变量类型。在工作易RPA中，元素特指通过UI自动化（捕获）的方式，从浏览器或桌面软件中指定的一个目标，获取其特征和截图，以对其进行后续的查找和操作。 设计器特性设计器的产品目标与特性让用户更轻松、更快速地在不需要编写代码的情况下完成RPA流程的开发设计，并为机器人赋予更强大的自动化能力。 图形化开发 设计器提供了图形化界面，所有的节点都通过节选或者配置参数的方式完成设计，同时它的调试模式提供断点，单步调试，变量值显示，实时语法检查等辅助功能，帮助用户加速开发，设计器界面自动化支持跨平台跨系统，自动化操作各种架构的第三方产品和文档，且支持开发导入自定义组件，以供流程开发调用 设计器工程模式简介 创建项目将会创建一个json包文件和flow流程文件 打开项目可以打开json包文件和flow流程文件，将跳转到设计器设计界面 升级旧流程可以将旧版本的mrpa文件升级成flow文件，若出现cyclone-upgrader-errs.json则说明有需要修改的地方 界面介绍标题栏 标题栏主要用于展示项目名称，当项目打开后会显示当前项目的名称。 如果是初始状态，标题栏展示为开始。 导航栏 名称 作用 首页 回到首页 工程 回到当前工程 调试 调试当前流程。详细信息参见：调试 说明。 设置选项 个性化系统设置 收起 收起&#x2F;展开工程资源栏 连接中心 与控制中心，应用市场，卓越中心连接 工具栏 工具栏主要集成想项目开发中所用的工具。 名称 作用 新建 新建RPA项目 保存 保存更改后的流程。 发布 RPA项目发布，打包。详细信息参见：发布 说明。 运行 运行流程。 调试 对流程进行调试修改。 撤销 回退上一步操作。 重做 恢复上一步操作。 清空 清空画布中所有组件 组件管理 安装、卸载、更新等管理外部组件，同时支持用户自定义组件。 安装扩展 安装一些辅助类的插件，如浏览器扩展，键盘驱动等。 录屏 通过记录用户在界面的操作记录，并将这些记录生成流程 数据抓取 批量抓取结构化数据与表格数据。详细信息参见：数据抓取 说明。 Cyclone 浏览器 设计器自带的浏览器，若开发时没有浏览器可以选择此浏览器作为支持。 UI解析器 捕获到的元素的详细信息展示和修改。详细信息参见：UI解析器 说明。 下边栏下边栏主要包含三个选项卡 变量管理：方便的统一管理变量、如创建、修改、删除、筛选变量，查看异常提示、引用信息。详细信息参见：变量 说明。 运行日志：通过此窗口查看流程运行的重要节点信息。 参数管理：管理参数的传递方向，类型，默认值等。 详细信息参见：参数 说明。 属性面板用户可以在属性面板区域编辑画布对应节点的输入输出信息。属性面板展示内容如下： 节点名称（用户可以自定义）； 节点编号（节点的唯一标识）； 节点描述； 节点输入； 节点输出； 节点设置（部分节点有） 对于属性面板的输入框，点击如所示EXP按钮可以切换表达式模式和值模式： 表达式模式：支持引用变量，支持语法糖，支持表达式； 值模式：支持直接输入字符，不用转义。（举例：输入姓名的字符串，如为表达式模式，应输入”张三“，如为值模式，应输入张三） 导入流程 项目之外的流程文件 导入资源文件Excel，图片等资源文件 组件管理额外拓展自定义等 自动化流程演示 调试 可自动获取外部参数、局部变量的当前值。 支持编辑变量的当前值 修改后的变量值对还未调试的节点生效。 支持可视化编辑日期时间、数组、对象变量的当前值。 完整搭建一个流程新建流程 在设计器界面中点击“新建项目”按钮，开始创建项目。 在 创建项目 面板中，填写项目名称和存放目录，点击“确定”按钮。 项目名称* - 输入项目名称，项目名称不能为空。 项目存放目录* - 将在项目存放的目录下自动创建与项目同名的文件夹。 *代表必填项 点击“打开主流程”按钮①，在主流程中添加组件；或点击“新建流程”按钮②，新建子流程，在子流程中可以添加组件。以打开主流程为例。 在主流程的面板中点击“添加组件”按钮①，打开组件库；或在面板左侧点击“组件库”②，切换到组件库。以点击“添加组件”按钮为例。 在组件库中展开需要的模块来添加组件，组件库中的组件模块包括界面自动化、Excel、数据处理、逻辑处理、系统功能、应用自动化、数据库、人机交互、网络协议、其他组件、中控、集成模块。也可以在搜索框中搜索特定的组件。 注意：在面板左侧组件库中右键后点击“加入收藏”的组件，会被收入 我的收藏 模块。最近使用过的组件，会被收入 最近使用 模块。 找到需要的组件，点击组件加入流程。以 打开浏览器、输入文本为例。 点击组件面板，填写组件属性。例如在 打开浏览器 组件中，选择浏览器类型，填写网页路径、进程号等。 部分组件可能需要捕获元素，例如在 输入文本 组件中，点击目标元素的坐标按钮，进入常规捕获模式。 将鼠标移至需要捕获元素的位置，使用Ctrl+鼠标左键组合确认捕获，捕获目标元素后在组件属性中可以回显。 运行流程 填写完所有组件的属性后，点击“运行”按钮，运行流程。 默认为运行全流程。下拉可以选择以下三项： 运行当前流程，快捷键为Ctrl+F6 运行全流程，快捷键为Ctrl+F5 画中画运行全流程 运行成功时系统会显示 “Cyclone Starter 运行成功”。 调试流程 在设计器界面中点击“调试”按钮，开始调试流程。 默认为调试全流程。下拉可以选择以下二项： 调试当前流程，快捷键为F8 调试全流程，快捷键为F7 在调试界面中，可进行详细操作。在左侧蓝色导航栏可切换到主页或设计界面。 开始 - 开始调试流程，快捷键为F8 停止 - 调试过程中点击“停止”，停止调试，关闭调试界面，快捷键为Ctrl+F12 单步调试 - 点击后调试单个组件，调试后暂停，再点击调试下一个组件，快捷键为F11 运行日志 - 点击后跳转到运行日志所在文件夹 调速 - 可选择以下四种速度，默认为快速 速度 延时时间 慢速 1000ms 正常 500ms 快速 0ms 自定义 可填写 保存流程 如果需要保存流程，在面板中点击“保存”按钮。 默认为保存当前文件。下拉可以选择以下二项： 保存当前文件 - 保存当前界面中的流程文件 保存全部 - 保存打开的全部流程文件 发布流程 在设计器界面中点击“发布”按钮，开始发布流程。 在发布项目界面中，可以进行多项内容的填写与修改。 其中项目信息①和发布者身份②，需点击按钮进行子页面填写。 在项目信息界面中，可进行项目名称、项目简介、使用说明的填写。 项目名称* - 默认为新建项目时填写的项目名称 项目简介* - 输入项目简介 使用说明* - 输入使用说明 在 导出 模块中，可进行是否导出至本地的选择、存储路径的选取。 导出至本地 - 是否导出至本地，可选择启用或不启用，默认为启用 存储路径 - 可点击按钮后进行选取 在 发布 模块中，可进行发布者身份、是否发布至中控的修改。 发布者身份 - 点击 连接中心 或修改按钮，进入 Designer Pro 连接中心 界面 发布至中控 - 是否发布至中控，可选择启用或不启用，默认为不启用 在 版本信息 模块中，可进行发布版本的选择、发布说明的填写。 发布版本 - 可以根据当前版本号，选择以下四种版本号（以当前版本1.0.0为例）： 发布版本 版本号 备注 当前版本 1.0.0 默认选择项 修订版 1.0.1 修复问题，且兼容上一版本时，建议选择此版本 次版本 1.1.0 新增功能，且兼容上一版本时，建议选择此版本 主版本 2.0.0 产生不兼容的修改时，建议选择此版本 发布说明* - 输入发布说明 填写完发布项目的信息后，点击“更新项目信息并发布”按钮。 流程发布成功后，会反馈发布结果，点击“完成”按钮，完成发布流程。 如何录制一个流程 在流程面板中点击“录制”按钮，开启智能录制。 在智能录制面板中，点击“开始”按钮，开始录制。 开始智能录制后，进行需要录制的操作，操作动作会被记录，自动生成流程。能在智能录制的面板中看到记录的操作动作。 在智能录制面板中，点击“暂停”按钮或使用Esc键暂停录制①；点击“确定”按钮完成录制②；点击“取消”按钮取消录制③. 完成智能录制后，能在面板中看到 录屏流程 组件。 可展开 录屏流程 组件，双击查看其中的子流程。 在子流程面板中可以对录制的子流程进行修改，也可以点击“主流程”按钮返回 录制流程 组件所在的主流程。 从模板新建流程基本概念越来越复杂的业务场景，需要更完善的企业级流程架构应对，企业级流程模板是从复杂项目中总结出的最佳实践，它有： 更完善的异常处理机制，增强流程稳定性 更统一的业务逻辑流程，易于后期运维 功能入口首页-从模板新建-企业级流程模板 使用说明 从模板中新建项目中选择“企业级流程模板”，写好项目名称等信息 即可基于模板建立一个新的项目 进入新建好的项目，可以看到模板中已有的流程框架，可按需继续编辑流程 也支持导入一个本地流程作为自定义模板 可以从官方市场中获取更多流程作为模板，点击“浏览更多模板”将在默认浏览器中前往官方市场 已知限制 自定义模板功能不支持导入 使用低于该版本的设计器写的流程 作为模板（比如用4.0写的流程文件不能导入到4.3的设计器作为自定义模板），建议您先升级您的流程后再导入 流程模式序列图序列图分为流程模式和行模式，流程模式以图形的方式展示节点，能直观的看到画布上的节点信息，且部分节点支持在画布上操作，而行模式同样大小的画布能够容纳更多的节点信息，双方各有优劣。 流程模式功能描述流程模式以图形化，可视化的方式展示画布上的节点，能够直观的看到节点与节点之前间的逻辑关系和层级。 使用场景任何需要用到序列图画布的场景 使用说明1. 插入节点现插入节点有2种方式：从画布中插入和拖动组件库节点至画布，具体场景如下： 从组件库插入：拖动插入或双击插入即可。 在画布上点击加号插入： 2. 插入注释支持选中节点后右键插入注释 行模式功能描述行模式画布类似大纲，将节画布中的节点信息按行展示，这样可以在一屏中展示更多的信息。 使用场景任何需要用到序列图画布的场景 使用说明1. 功能入口开启行模式画布，点击如图所示按钮即可开启 2. 插入节点：现插入节点有2种方式：从画布中插入和拖动组件库节点至画布，具体场景如下： 从组件库插入：拖动插入即可。 在画布上同层级插入： IF中插入更多条件： 从画布末尾插入 3. 画布视图调整： 支持调整百分比； 支持收起或展开有层级的节点； 其他功能与序列图流程模式一致。 3. 插入批注：可通过选中节点右键添加批注 流程图功能描述用流程图画布，绘制流程图，并通过序列画布实现流程图中的流程节点，从而完成项目的开发。 使用场景流程图画布适用于较为复杂的多个节点按序重试、多判断、多分支的流程。 使用说明1. 开启实验室功能因流程图画布属于实验室功能，故应先开启功能，开启路径为 设置-实验室功能-启用实验功能。 2. 创建流程图画布现流程图画布有2个入口：1） 新建空白项目后如画布未添加任何组件，可在画布区域右上角切换为流程图画布；2）新建文件可新建流程图文件。 3. 绘制流程图1） 绘制节点，可在左侧功能栏-组件库中选择相应节点拖拽至画布即可完成节点绘制（现仅支持流程块，流程判断及流程决策节点）；2） 绘制连线：点击流程节点出口连接处，鼠标左键按下并拖拽至其他流程节点入口连接处即可完成连线绘制； 4. 流程节点实现双击流程块，可进入序列画布页面，使用流程序列完成流程节点实现。 5. 运行与调试流程图的调试运行功能与序列流程基本一致，支持运行当前流程&#x2F;全流程、调试当前流程&#x2F;全流程，流程图组件暂不支持【调试当前节点】或【从当前节点开始调试】 代码模式使用场景对于有代码基础的用户，为了提高开发效率，许多场景可通过写代码的方式实现，如 流程中有很多数据处理任务，使用组件开发比较麻烦，效率较低 一些需要调用三方包的功能，如Excel、pdf接口调用等 编写爬虫等脚本文件 调用已有的代码文件 环境介绍 设计器在安装时，会自动内置代码运行环境，与电脑中的python&#x2F;js环境无关 设计器中内置的python环境为：python 3.8.10，js环境为：node-v12 详细内容参照：代码模式 流程编辑工程模式基本概念工程模式，就是把一个项目当成一个project（相当于现在的一个mrpa） 项目相关资源组织成文件夹，包括流程文件、资源文件、package.json等 将大流程拆分成若干子文件，在需要时进行调用 解决的问题子流程复用，联调 建议将大的流程拆分成多个流程文件，进行单独调试、运行。规避变量过多，解决难于阅读和调试的问题，同时增强文件的复用性。 主流程结构更加清晰 主流程结构不再受线性条件的限制，可以在条件判断、循环中使用 建议大家把整体的流程逻辑放在主流程中，然后用不同的流程文件进行组合。未来会推出模版，配合流程图模式，规范大家的流程结构，增强可读性。 资源文件管理 一些在项目中使用到的文件，比如“图片”，“excel文件“等，如果希望未来该文件可以随着项目一起发布，可将其作为项目需要的资源文件，加入到项目中。 对于已捕获的组件，重新捕获后，之前捕获的图片如果不再使用，可以进行删除 最佳实践 可被复用的节点片段建议拆成单个流程，每个流程单独编写、单独调试通过。 建议每个流程文件不超过100个节点 每个流程文件的功能尽量单一，清晰 功能介绍入口流程项目文件默认从main.flow开始执行 将流程文件加入到流程中请在流程中使用“引入流程文件”节点。 注意 注：该节点只能引用项目文件夹内部的流程（如果需要引入项目外的流程文件，需要先将其导入） 导入外部流程文件如果需要使用来自外部的流程文件，需要先将其进行导入，再在流程中使用“引入流程文件”节点。 支持导入.flow格式的流程文件 导入含有依赖的流程文件的处理方式如果从外部导入了流程1，然后流程1中又使用了”引入流程文件“，引入了流程2，在导入流程1时，需要做如下操作： 1、将其依赖的”流程2“也导入到本项目中 2、将流程1中”引入流程文件“的节点进行修改，重新引入一下流程2 一些在项目中使用到的文件，比如“图片”，“excel文件“等，如果希望未来该文件可以随着项目一起发布，可将其作为项目需要的资源文件，加入到项目中。 1、导入资源文件 在“+”号处，选择“导入资源文件” 2、使用资源文件 1）在画布中，使用“引入资源文件节点”，选择该资源文件，将文件路径输出为一个变量 2）在需要用到文件路径的地方，使用该变量 3、查看和编辑资源文件(使用当前系统中默认的打开方式打开该文件) 代码模式代码文件使用场景对于有代码基础的用户，为了提高开发效率，许多场景可通过写代码的方式实现，如 流程中有很多数据处理任务，使用组件开发比较麻烦，效率较低 一些需要调用三方包的功能，如Excel、pdf接口调用等 编写爬虫等脚本文件 调用已有的代码文件 环境介绍 设计器在安装时，会自动内置代码运行环境，与电脑中的python&#x2F;js环境无关 设计器中内置的python环境为：python 3.8.10，js环境为：node-v12 功能介绍创建代码文件 支持创建py文件、js文件、Mjs文件（会比javaScript更加规范的一种语言） 两个入口可以新建代码文件，项目面板和标签栏 创建完成后，项目面版会新增一个代码文件，并且会在标签页中自动打开 定义输入输出参数使用场景：当代码文件需要和其他流程文件进行数据交互时，需要定义输入输出参数 定义完成后，当使用“调用代码块”进行调用时，需要传递相应的出入参数 功能描述： 支持多个输入参数和一个输出参数 不同语言的定义方法不同，示例如下： 一个函数需要两个数字类型入参a,b和一个数字类型的出参，不同语言的写法如下： python文件 支持的数据类型：float、bool、str、dict js文件 支持的数据类型：js语言支持的所有类型 Mjs文件 支持的数据类型：Mjs语言支持的所有类型 编写代码文件设计器提供了内置代码编辑器 代码编辑器功能： python:支持语法着色、自动补全、语法提示等功能； JS&#x2F;MJS：支持错误提示、语法着色、自动补全、语法提示等 调用代码文件在流程文件中调用：使用组件”调用代码块” 使用提醒：当选择脚本路径后，需要点击“刷新文件”，再选择方法名称 在代码块中调用：直接使用import，和写代码一致 注意 若在代码编辑中有需要用到外部包，请在包管理工具中导入。请参考代码包管理 参数管理基本概念 参数：是用于流程被调用或者执行时与外部进行数据传递，比如 在设计器的主流程中引用其他flow流程时，通过输入输出参数进行数据传递 在执行器或中控上执行流程时，通过输入输出参数进行数据传递 新建参数 新建输入&#x2F;输出参数： 右键点击输入&#x2F;输出参数，在右键菜单中选择“新建参数” 选中输入或输出参数下的其中一个参数后，点击“+”按钮 编辑参数 有两种方式可以编辑您的参数 悬停在某个参数时，会出现一个编辑图标按钮，点击按钮即可打开编辑页面 右键点击某参数，右键菜单中选择“编辑参数” 可设置参数的名称、参数类型、初始值、参数描述 注意输出参数不支持设置初始值，因为输出参数应当是在流程中对它进行赋值，而不该是固定默认值 参数类型设计器支持众多参数类型，这些参数类型均与变量类型一致。因此，您可以创建泛型值、字符串、布尔值、对象、数组或数据表参数，与创建变量 时相同。 主要有： 参数类型 详细类型 字符串 string 数字 number 布尔 boolean 数组 array 对象 object 密码 cyclone.Password 日期时间 cyclone.DateTime 数据表 cyclone.Datatable 自定义类型 例如array,object,string 表示array Cyclone内部变量类型 cyclone.xxx，是弘玑定义的一些固定的数据结构 注意 注意： 参数类型中，布尔类型默认值为true。 数组类型在使用时，要选择数组中数据的类型，同时只能选择字符串、数字、布尔类型。 对象类型在使用时，要选择数组中数据的类型，同时只能选择字符串、数字、布尔类型。 密码类型不支持作为输出参数，密码的默认加密类型AES加密，实际上是加密的字符串类型。 输入参数如何改为输出参数 可将输入参数拖拽至输出参数的节点下面，反之亦可 按下{ctrl}或{shift}可实现批量拖拽参数 删除参数 右键菜单中选择“删除参数” 选中参数后按下{Del}键，支持按下{Ctrl}或{Shift}选中多个参数后进行批量删除 批量复制粘贴变量 选中一个参数，如参数1，按下Ctrl+C进行复制；按下Ctrl+V进行粘贴，生成【参数1的副本1】 按下{ctrl}支持选中多个参数进行批量复制粘贴 按下{shift}支持连选多个参数进行批量复制粘贴 搜索&amp;筛选变量 点击参数旁的筛选图标小按钮，支持筛选参数类型 支持输入参数名称进行模糊搜索 查看引用信息 鼠标悬停在某个参数时，会显示参数的详细信息 点击“显示详情”可以查看该参数被引用情况，点击引用信息下的某作用域可以实现快速跳转 参数一键转换为变量右键点击变量，在菜单中可以选择转换为输入或输出参数 变量管理基本概念 变量：是用于存储流程设计中需要流转使用的数据 新建变量新建全局变量：点击变量面板中的“+”按钮，即可快速创建新变量。节点中输出一个新变量时，需要同时按键Shift + Enter, 快速创建一个变量。 新建局部变量：有两种方法 右键点击想要新建局部变量的目标作用域，在右键菜单中选择“新建变量” 选中目标作用域下的其中一个变量后，点击“+”按钮 编辑变量有两种方式可以编辑您的变量 悬停在某个变量时，会出现一个编辑图标按钮，点击按钮即可打开编辑页面 右键点击某变量，右键菜单中选择“编辑变量” 可设置变量的名称、变量类型、初始值、变量描述 变量类型设计器支持众多变量类型。您可以创建泛型值、字符串、布尔值、对象、数组或数据表变量主要有：主要有： 变量类型 详细类型 字符串 string 数字 number 布尔 boolean 数组 array 对象 object 密码 cyclone.Password 日期时间 cyclone.DateTime 数据表格 cyclone.Sqltable 自定义类型 例如array,object,string 表示array Cyclone内部变量类型 cyclone.xxx，是弘玑定义的一些固定的数据结构 注意 注意： 变量类型中，布尔类型默认值为true。 数组类型在使用时，要选择数组中数据的类型，同时只能选择字符串、数字、布尔类型。 对象类型在使用时，要选择数组中数据的类型，同时只能选择字符串、数字、布尔类型。 密码类型在使用时，默认加密类型AES加密。 变量范围 变量范围 是否会创建自变量 当前流程 否 流程块 否 TryCatch异常处理&gt;try 否 TryCatch异常处理&gt;finally 否 捕获异常 否 While循环 否 数组遍历 是（①_array_index、②_array_element） 对象遍历 是（①_object_key、②_object_value） For循环 是（i） If条件判断&gt;如果 否 If条件判断&gt;否则 否 修改变量作用域 可通过拖拽修改变量的作用域，比如将主流程下的全局变量拖至for循环作用域下面 按下{ctrl}或{shift}可实现批量拖拽变量，批量修改变量的作用域 删除变量（可批量） 右键菜单中选择“删除变量” 选中变量后按下{Del}键，支持按下{Ctrl}或{Shift}选中多个变量后进行批量删除 复制粘贴变量（可批量） 选中一个变量，如变量1，按下Ctrl+C进行复制；按下Ctrl+V进行粘贴，生成【变量1的副本1】 按下{ctrl}支持选中多个变量进行批量复制粘贴 按下{shift}支持连选多个变量进行批量复制粘贴 搜索&amp;筛选变量 点击变量旁的筛选图标小按钮，支持筛选变量类型 支持输入变量名称进行模糊搜索 去除未引用变量 当变量未被其他组件引用时，通过“去除未引用变量”功能，可以快速去除所有未引用的变量 ⚠注意：如果您的节点被&#x2F;&#x2F;禁用了，这些节点里面引用的变量也会被一并删除掉 查看引用信息 鼠标悬停在某个变量时，会显示变量的详细信息 点击“显示详情”可以查看该变量被引用情况，点击引用信息下的某作用域可以实现快速跳转 查看变量 跟随用户在画布上选中节点所属的作用域，展示该节点所有可用的变量 如果在主流程中不选中任何节点，展示主流程可使用的全局变量 异常提示当变量类型不匹配，或引用变量不正确，或变量名称重复时会进行异常提醒 变量一键转换为参数右键点击变量，在菜单中可以选择转换为输入或输出参数 元素捕获捕获模式捕获元素目前为5种，常规捕获模式、CV捕获模式、图片捕获模式、表格捕获模式、UIA捕获模式： 模式 快捷键 描述 常规捕获模式 F1 用于捕获大部分软件，基于GUI元素属性定位目标元素 CV捕获模式 F2 用于其他捕获模式无法捕获的情况，基于屏幕图像理解，记录元素特征定位目标元素 图片捕获模式 F3 用于其他捕获模式无法捕获的情况，基于图片定位目标元素 表格捕获模式 F4 用于捕获表格中的行列信息，定位单元格 UIA捕获模式 F5 用于捕获使用UIA框架编写的客户端软件 点击捕获元素按钮，进入普通捕获模式。 {F1}常规捕获模式 {F2}切换到CV捕获模式，若F2无法切换模式，尝试alt+F2 {F3}切换到图片捕获模式，若F3无法切换模式，尝试alt+F3 {F4}切换到表格捕获模式，若F4无法切换模式，尝试alt+F4 {F5}切换到UIA捕获模式，若F5无法切换模式，尝试alt+F5 {Esc}退出捕获模式在捕获元素时，会有捕获节点推荐提示：根据用户捕获的元素，自动判断应当适用哪个功能节点，弹窗提示用户“建议您使用XX功能”。 1. 常规捕获模式 用于捕获大部分软件，基于GUI元素属性定位目标元素 Cyclone旧版捕获和其他大部分竞品的捕获元素操作，是会冻结当前界面，此时点击目标元素即完成捕获，但如果当前桌面最上层的应用不是您想要的应用，通常还需要配合延迟捕获等额外功能才能方便使用 Cyclone新版捕获优化了用户体验，需要按下{Ctrl}+点击（左键右键均可）完成元素捕获，未按下Ctrl键之前的所有鼠标键盘操作均可正常使用 有的输入框的表面有一层浮层，因此捕获输入框，建议用户输入文本后再捕获 相比于大部分竞品，Cyclone捕获元素无需做抓取模式的切换，可以智能识别当前是什么类型的应用，无需做Java模式&#x2F;IE模式&#x2F;CS模式等切换 可识别的元素显示红框高亮 支持通过F12禁用鼠标事件（如悬停） 2. CV捕获模式用于其他捕获模式无法捕获的情况，基于屏幕图像理解，记录元素特征定位目标元素元素捕获时，按下快捷键F2进入CV捕获模式a.机器配置 推荐8g内存，i7CPU 最低4g内存，i5CPU b.升级须知 CV识别功能在3.2进行了全面升级，使用的是新的识别模型，提高了识别速度和准确率。 此功能优化后不兼容老版本的CV模型，所以如果流程中使用了之前的CV功能，升级后需要重写CV识别相关的节点 支持通过F12禁用鼠标事件（如悬停） c.具体操作 元素捕获时，快捷键F3可切换捕获模式至CV识别； 用户需要先选中一个目标窗口，未选择窗口前，用户可快捷键切换至F1属性定位或F2图片匹配 此时需等待CV返回识别结果 正在识别时，不要进行其他的鼠标键盘操作 识别后，用户鼠标移动到可识别元素的高亮框时，按下Ctrl+点击，完成CV捕获 3. 图片捕获模式 用于其他捕获模式无法捕获的情况，基于图片定位目标元素 元素捕获时，按下快捷键F3切换至图片匹配； 用户点击屏幕任意位置后，进入截图模式，自动隐藏左上角面板提示，此时不可再使用快捷键进行模式切换。 示例链接:当当网 截取购物车的图片，点击完成完成图片捕获 支持通过F12禁用鼠标事件（如悬停） 4. 表格捕获模式用于捕获复杂表格中的单个元素 5. UIA捕获模式用于捕获使用UIA框架编写的客户端软件 6. CV表格捕获模式功能说明：使用CV(Computer Vision)技术捕获表格中的行列信息，定位单元格具体操作： 点击画布节点上的【CV抓取表格数据】按钮，打开向导，点击【捕获元素】按钮，进入【元素捕获】模式 选择需要识别的表格所在的范围，等待识别运算 解析表格结构失败，或未解析出表格结构，返回设计器，在设计器中toast提示用户：“未识别表格结构，请重新捕获” 7. 禁用鼠标事件开关按下F12可以开启禁用鼠标事件的开关，开启后，目标界面不会响应用户的鼠标悬停事件，主要应对的使用场景是：鼠标移上去时目标元素会变，无法捕获变化前的元素 8. 功能组件的捕获模式 二级目录 名称 描述 **支持的捕获模式 ** 应用和浏览器 启动应用程序 打开指定的应用程序 窗口 关闭应用程序 录制一段关闭应用的界面操作，或强行关闭一个应用程序 窗口 打开浏览器 打开浏览器，并加载指定网页 不需捕获 打开新标签页 打开新标签页，并前往指定的网址 不需捕获 激活标签页 激活目标浏览器中的一个标签页，让后续相关的操作在正确的目标上执行 不需捕获 关闭标签页 关闭已打开的标签页 不需捕获 刷新&#x2F;前进&#x2F;后退 对指定网页进行刷新、前进、回退操作 不需捕获 执行JS脚本 向目标网页中的iframe注入并执行JavaScript脚本 不需捕获 获取网页URL 获取当前页面的网址URL 不需捕获 获取网页Cookie 获取网页的Cookie数据 不需捕获 设置网页Cookie 设置网页的Cookie数据 不需捕获 输入文本 在指定的输入框中输入文本(自动清空后输入、输入后校验） 常规,CV,图片,表格,UIA,CV表格 发送热键 对当前激活窗口或有焦点的元素，模拟发送键盘按键 常规 选择选项 在下拉列表、列表框中选择一个选项 常规,表格 勾选&#x2F;取消勾选 将单选框、复选框元素的勾选状态设置为勾选或取消勾选 常规,表格 鼠标悬停 移动鼠标至指定目标位置并悬停 常规,CV,图片,表格,UIA,坐标,CV表格 鼠标拖拽 模拟鼠标将元素拖拽至指定位置 录制,坐标 鼠标滚动 在当前激活窗口滚动鼠标滚轮 不需捕获 获取鼠标位置 获取当前鼠标光标所在位置 不需捕获 表格&#x2F;列表 抓取表格数据 批量抓取标准表格和列表（相似元素）数据，可自动翻页 表格 抓取结构化数据 在网页中批量抓取相似元素数据，如列表页 常规 CV抓取表格数据 CV表格 抓取下拉列表数据 抓取下拉列表、列表框中 所有&#x2F;选中 选项的内容和数量 常规,表格 查找相似元素 在网页上查找多个相似元素，将元素列表输出到数组 常规 文本 点击文本 还没有这个节点 常规 获取文本 获取元素的文本内容（Value属性) 常规,表格 读取可见文本 采用系统注入的方式获取可见文本，目前仅支持常见的证券软件（如同花顺） 常规,区域 按文本查找元素 在网页上查找指定文本的元素 常规 获取树子节点 在客户端软件的目录树中，获取指定目录下的所有子节点的名称 常规,表格 元素 判断元素是否存在 判断元素是否存在，返回布尔值true&#x2F;false 常规,CV,图片,表格,UIA,CV表格 等待元素出现 进行元素操作前最好等待元素出现 常规,CV,图片,表格,UIA,CV表格 编辑元素属性 编辑或删除网页元素的指定属性 常规 获取元素属性 获取界面中指定元素的属性信息 常规,表格 获取元素颜色 获取界面中指定元素的颜色信息 常规,坐标 获取元素位置 获取界面中指定元素的位置信息 常规,表格 元素截图 对界面元素进行截图，并将结果保存至指定文件夹 常规,表格 滚动截图 垂直或水平滚动后截图，并拼接成完整的长截图 常规 查找子元素 获取目标元素下的所有子元素，返回获取到的子元素，仅支持网页元素 常规 查找父元素 获取目标元素向上一级的父元素，返回获取到的父元素，仅支持网页元素 常规 Xpath查找元素 通过目标元素的XPath路径，获取目标元素并保存到对象 不需捕获 锚点查找元素 在网页上基于固定的锚点查找目标元素 常规 窗口 激活窗口 将目标窗口置顶，便于后续的前台操作 不需捕获 关闭窗口 使用后台的方式关闭目标窗口 不需捕获 设置窗口状态 使用后台的方式最大化、最小化目标窗口 不需捕获 高级功能 查找OCR文本位置 使用OCR技术在目标范围内查找文本，输出目标文本所在的坐标位置 常规 OCR通用文本识别 自研OCR通用文本识别模型，可识别单行文本 常规,区域 OCR验证码识别 自研OCR验证码识别模型，可识别4-6位数字英文验证码 常规,区域 第三方服务商OCR 使用第三方服务商OCR识别，需申请特殊license 不需捕获 获取个人微信聊天记录 捕获聊天对话框里的任意一条对话，执行时将获取当前激活的微信对话框里可见的聊天记录（不支持企业微信） 常规 元素属性什么是元素属性？可以简单理解为这个元素的特征，机器人需要定位一个元素，需要基于元素的特征来查找。就像一个人的特征，姓名是张三，性别是男…元素的特征有很多，比如宽是200，长是100，类型是按钮，文字是确定…为了找到正确的元素，正确的元素特征非常重要。 窗口属性 目标元素所在窗口的相关属性 一般只需关注name属性，代表窗口标题 某些业务场景下窗口标题是容易变化的，比如登录后窗口标题带有登录名信息，比如翻页后窗口标题带有页码信息 元素属性 目标元素自身的属性特征 有info图标：用户最直观的感受是，这类属性勾选或不勾选好像都会生效，这是为什么呢？这一类属性我们称之为查找属性，为了增强元素捕获的稳定性，底层会进行多轮查找，分别使用不同的特征组合进行查找，找不到时会自动降权，舍弃不重要的特征，所以，哪怕这些属性值变化了，理论上也不会影响找到正确的元素 没有info图标：这类属性的勾选状态是完全生效的，我们称之为匹配属性，在用不同特征进行查找之后，有可能查找到多个元素，将找的元素与被勾选上的匹配属性进行匹配，看是否是正确的 在界面上众多的元素中找到正确的目标元素，就像我们想在淘宝网站中找到心意的商品，比如商品的特征是：北欧、花瓶、白色、雕花，第一次我们用四个特征去搜索商品，可能会有3种结果： 123①找到了多个商品（类比找到多个元素）②找到了1个商品（类比找到1个元素）③没找到任何商品（类比没有找到元素） 结果③，会走向”降权查找“： 第二轮查找，我们用三个特征“北欧、花瓶、白色”再找一次 如果第二轮还是没找到任何商品，第三轮我们用两个特征“花瓶、白色”再找一次 以此类推 结果①和②，会走向”匹配属性“： “匹配属性”，就类似再加了一条过滤器，比如我就想要XX淘宝店的花瓶，这样再筛选一下，可能会有3种结果： 123①找到了多个商品，这时第一条商品就会被认为是心意商品（类比正确的目标元素）②找到了1个商品，它被认为是心意商品（类比正确的目标元素）③没找到任何商品（类比报错：找不到目标元素） 匹配方式【精准匹配】基于固定值或变量值，可在输入框中输入固定值，或@引用变量 【通配匹配】支持通配符“*”和“？” *：代替零个、单个或多个字符 ？：代替一个字符 【正则匹配】 支持Perl正则表达式，详见链接：https://www.runoob.com/perl/perl-regular-expressions.html 实现的是regex_search功能，实现部分匹配而不是完全匹配，举例来说，如果目标元素是“百度一下，你就知道“，如果选择了正则匹配，匹配值为”百度“，是可以匹配上的 属性列表 元素类型 属性名 描述 是否支持通配匹配 是否支持正则匹配 **是否区分大小写 ** Windows元素 category 元素类别，WINCONRTROL代表是CS结构的应用 YES NO YES Windows元素 winClass Windows元素的具体类型，比如输入框、按钮 YES NO YES Windows元素 name Windows元素的文本属性 YES YES YES Windows元素 role Windows元素类型 NO NO YES Windows元素 width Windows元素宽度 NO NO YES Windows元素 height Windows元素高度 NO NO YES Windows元素 left Windows元素距离所在窗口左侧边缘的距离 NO NO YES Windows元素 top Windows元素距离所在窗口上方边缘的距离 NO NO YES Windows元素 index Windows元素的顺序 NO NO YES Windows元素 value Windows元素输入的文本 YES YES YES Java元素 category 元素类别，JAVACONRTROL代表是Java应用 YES NO YES Java元素 name Java元素文本属性 YES YES YES Java元素 role Java元素类型 NO NO YES Java元素 width Java元素宽度 NO NO YES Java元素 height Java元素高度 NO NO YES Java元素 left Java元素距离所在窗口左侧边缘的距离 NO NO YES Java元素 top Java元素距离所在窗口上方边缘的距离 NO NO YES Java元素 index Java元素的顺序 NO NO YES Java元素 value Java元素输入的文本 YES YES YES IE元素 category 元素类别，IECONRTROL代表是IE浏览器 YES NO YES IE元素 tagName IE元素的标签属性，如HTML、DIV、LI等 NO NO YES IE元素 type IE元素类型，如text、rec等 NO NO YES IE元素 name IE元素的name属性 YES YES YES IE元素 offsetWidth IE元素宽度 NO NO YES IE元素 offsetHeight IE元素高度 NO NO YES IE元素 offsetLeft IE元素距离父元素左上角的距离 NO NO YES IE元素 offsetTop IE元素距离父元素上端的距离 NO NO YES IE元素 special IE元素special属性，非关键属性 NO NO YES IE元素 id IE元素HTML中的核心属性：唯一标识符id NO NO YES IE元素 index IE元素的顺序 NO NO YES IE元素 parentId IE元素的父元素的唯一标识符id NO NO YES IE元素 toParent IE层级树中第几个父元素有id NO NO YES IE元素 frameURL IE元素所在的网址链接 YES YES YES IE元素 className IE元素的class属性，用来对网页元素进行分类。如果不同元素的class属性值相同，就表示它们是一类的 YES YES YES IE元素 value IE元素的value属性 YES YES YES IE元素 link IE元素的link属性，为点击该元素后跳转到的链接 YES YES YES IE元素 readOnly IE元素的只读属性，代表该字段不可编辑 NO NO YES IE元素 innerText IE元素中包含的所有文本内容 YES YES YES IE元素 outerText IE元素中包含的所有文本内容，除了作用范围扩大到了包含调用它的节点之外，outerText与innerText基本上没区别 YES YES YES IE元素 styleBackgroundImage 网页背景图片的url NO NO YES IE元素 styleVisibility 是否可见，1代表可见，0代表不可见 NO NO YES Chrome元素 category 元素类别，CHROMECONRTROL代表是Chrome浏览器 YES NO YES Chrome元素 tagName Chrome元素的标签属性，如HTML、DIV、LI等 NO NO YES Chrome元素 type Chrome元素类型，如text、rec等 NO NO YES Chrome元素 name Chrome元素的name属性 YES YES YES Chrome元素 offsetWidth Chrome元素宽度 NO NO YES Chrome元素 offsetHeight Chrome元素高度 NO NO YES Chrome元素 offsetLeft Chrome元素距屏幕左侧边缘的距离 NO NO YES Chrome元素 offsetTop Chrome元素距屏幕上方边缘的距离 NO NO YES Chrome元素 special Chrome元素special属性，非关键属性 NO NO YES Chrome元素 id Chrome元素的id属性，是元素在网页内的唯一标识 NO NO YES Chrome元素 index Chrome元素的顺序 NO NO YES Chrome元素 parentId Chrome元素的父元素的唯一标识符id NO NO YES Chrome元素 toParent Chrome层级树中第几个父元素有id NO NO YES Chrome元素 frameURL Chrome元素所在的网页URL YES YES YES Chrome元素 className Chrome元素的class属性，用来对网页元素进行分类。如果不同元素的class属性值相同，就表示它们是一类的 YES YES YES Chrome元素 value Chrome元素的value属性 YES YES YES Chrome元素 link Chrome元素的link属性，为点击该元素后跳转到的链接 YES YES YES Chrome元素 readOnly Chrome元素的只读属性，代表该字段不可编辑 NO NO YES Chrome元素 innerText Chrome元素中包含的所有文本内容 YES YES YES Chrome元素 outerText Chrome元素中包含的所有文本内容，除了作用范围扩大到了包含调用它的节点之外，outerText与innerText基本上没区别 YES YES YES Chrome元素 styleBackgroundImage 网页背景图片的url NO NO YES Chrome元素 styleVisibility 是否可见，1代表可见，0代表不可见 NO NO YES SAP元素 category 元素类别，SAPCONRTROL代表是SAP YES NO YES SAP元素 id SAP的id属性,是SAP元素的唯一标识 NO NO YES SAP元素 type SAP元素类别，如输入框、按钮等 NO NO YES SAP元素 name SAP元素的名称 NO NO YES SAP元素 text SAP元素的文本属性 NO NO YES SAP元素 subType SAP元素的子类型 NO NO YES SAP元素 width SAP元素宽度 NO NO YES SAP元素 height SAP元素高度 NO NO YES SAP元素 left SAP元素距离？左上角的距离 NO NO YES SAP元素 top SAP元素距离？上端的距离 NO NO YES SAP元素 index SAP元素的顺序 NO NO YES 元素操作功能入口右键单击 节点上的元素截图 回显 功能说明用于验证是否能找到正确的目标元素，找到的元素会被红框高亮 使用方法 点击后会自动激活元素所在的目标窗口，被找到的元素会红框高亮 如果未找到元素，会返回设计器并toast提示错误 打开选择器打开目标元素对应的元素选择器面板，功能详见元素选择器 重新捕获重新捕获目标元素 移除移除已捕获的目标元素 UI解析器用于验证设计器的捕获能力，探测界面上的元素是否可以被捕获。功能详见：UI解析器 智能捕获功能说明功能背景 原有捕获方式会由于元素变化导致流程稳定性差 某些元素变化是用户无感知的，比如是元素底层的属性特征变化、网页HTML源码变化等；但从用户的角度来看，这个元素并没有变化，样式和内容都没有发生变化 功能效果 当元素的底层关键特征发生变化，导致找不到元素时，通过智能捕获可以正确找到元素 当元素所在的页面发生变化时，比如结构微调或者新增新模块，导致找不到&#x2F;找错元素时，通过智能捕获可以正确找到元素 功能限制 不适用情况： 若元素的样式发生变化；或界面上由&gt;1个样式、尺寸相似的元素； 若元素的文本内容发生变化；或界面上有&gt;1个文本相同的元素； 捕获方式及对象： 捕获方式：常规捕获、表格捕获、UIA捕获 对象：BS网页、CS客户端、JAVA客户端、SAP 支持组件 点击 输入文本 鼠标悬停 发送热键 使用说明 在元素选择器中新增：“元素截图”、”OCR查找文本“选项，当元素变化时，作为查找元素的依据 更新fallback查找策略； 查看日志可以通过%appdata%\\speed_dev\\logs\\engine下面的日志文件中，搜索runAction response关键字，查看指令运行之后的返回结果，通过结果中的extensionCode字段区分是否使用了智能捕获： 0 未使用智能捕获 1 未找到窗口时，降权到图片查找 2 未找到窗口时，降权到OCR文本查找 1000 未找到元素时，降权到图片查找 2000 未找到元素时，降权到OCR文本查找 前置条件适用场景 捕获Chrome元素、IE元素、Edge元素、Java元素、SAP元素。 首次或重新安装设计器，按需安装扩展程序。 在电脑A上设计的流程文件，需要在电脑B上执行，电脑B按需安装扩展程序。 具体步骤打开工具管理-&gt;查看帮助文档。可以查看所有扩展程序的安装与启用步骤。 注意事项系统自动检测捕获插件是否安装，若未安装则会给出友好提示、引导用户一步步安装。 如果捕获的时候，发现目标应用程序的权限高于设计器的权限，提示用户“权限不足，请使用管理员权限运行设计器后再次尝试”。 浏览器插件安装参考文档：浏览器插件 元素选择器功能入口 可进行回显目标、重新捕获、在UI解析器中查看操作 1. 属性定位模式属性列表 应用：目标元素所在的应用名称，如iexplorer.exe 标题：支持引用变量，支持通配、正则匹配 目标元素所在窗口的标题，如【百度一下，你就知道 - Internet Explorer】 标题中大于20个字符的部分会自动改为*，表示模糊匹配 类型：目标元素类型，如radio button，input box，text，tree，list等 文本：目标元素中的文本内容，支持引用变量，支持通配、正则匹配 如果目标元素中的文本为空（输入框），或者易变，不建议勾选此项 此属性不能获取图片中的文本内容 元素类型 - 复杂元素 包括列表list、树Tree、表格Table 元素类型 列表 - List 树 - Tree 表格 - Table 元素选择器 注意事项 支持选项内容匹配 支持选项序号匹配 支持选项内容匹配 不支持序号匹配 仅支持根据行号、列号定位单元格 不支持内容匹配 2. 图片匹配模式属性列表 置信度：默认置信度为0.75，即查找与图片匹配依据图片相似度75%以上的图片，可以调整（输入值或拖动bar条），仅支持输入0-1范围的精确到0.01的数字，不支持引用变量。 匹配范围：默认的匹配范围是目标窗口，可通过选择应用和标题确定匹配范围。 支持抗分辨率变化，但有以下限制： 等比例缩放，界面布局不能变化 目标元素仍在界面可见 不可在UI解析器中查看 3. CV识别模式属性列表 CV元素截图：CV识别捕获到的元素截图 CV识别范围：默认的匹配范围是目标窗口，可通过选择应用和标题确定匹配范围。 不可在UI解析器中查看 4. CV表格识别模式属性列表 表格号：捕获后自动生成，从0开始计算，可编辑，支持引用变量 行：捕获后自动生成，从0开始计算，可编辑，支持引用变量 列：捕获后自动生成，从0开始计算，可编辑，支持引用变量 依赖管理组件管理组件包入口在设计器顶部导航栏，点击依赖管理–组建管理，可进入组件管理界面。 组件源配置组件管理界面左下角，配置组件包来源，可配置来源。 本地：当用户安装设计器时，默认会创建本地组件包来源。你可以进行开启与关闭。 中控： 如果设计器已连接到中控，则会添加此组件包来源，内部会包含中控已有的组件包。该组件源默认为关闭状态，需要手动开启。 应用市场：在有外网的情况下。可以直接连接并展示应用市场源的组件。方便用户自行安装市场上的组件。 自定义：用户可选择磁盘或网络文件夹路径作为一个自定义源 当流程执行时，组件包的查找顺序为：本地—&gt;中控—&gt;应用市场，既优使用先本地源组件。 组件包信息在组件包管理主界面，可以查看当前项目依赖、所有可用来源、本地源、中控源（需配置连接） 组件包列表当选中“项目依赖项”Tab，则显示当前项目依赖的组件包列表。在列表项组件包图标、组件包名称、组件包简介、版本号、包的作者等信息。 安装提示：用户鼠标hover在未作为项目依赖的组件包上，则显示安装标志，用户点击，即可安装该组件包为项目依赖。 卸载提示：用户鼠标hover在已安装的组件包上，则显示卸载标志，用户点击，即可将此组件包从当前项目依赖中移除。 可以通过顶部的搜索功能进行按名称搜索组件 组件包详情用户在列表中选中组件包，则在右侧显示组件包详情 详情信息：显示组件包图标、组件包名称、已安装版本号（仅对于已安装的组件包显示）、简介、版本、作者、发布日期、更新说明、此组件包的依赖项。 安装组件：用户也可通过list，或直接点击切换版本按钮，切换到合适版本后再进行安装。 运行时规则完成组件的安装后，默认会选择“严格”模式。在该模式下，流程发布到执行器执行时，执行器只能使用设计阶段选择的组件版本，如果找不到该版本组件运报告运行异常信息。如果选择了“兼容”模式，则执行器在找不到设计时的组件版本，会在各个源种寻找并安装兼容的组件版本并运行。该模式保留了运行的灵活度，但组件若出现不兼容的情况，会导致运行的异常。 依赖项管理 依赖项列表安装了新组件后，在项目面板中将显示当前项目的依赖信息。 依赖项更新、修复、删除在依赖组件包上，点击右键。可以进行组件包的管理、删除、修复操作。 打开组件包管理：点击即可打开组件包管理界面 删除依赖项：点击即可删除当前依赖项，具体见下方删除依赖项。 修复依赖项：对于安装失败的依赖项，会出现修复依赖项按钮。你可以点击修复进行依赖项修复。 代码包管理功能入口在设计器的依赖管理–代码包管理功能中，点击后可打开代码包管理弹出层。 代码包管理在代码包管理界面，你可以查看 系统内置、扩展包、自定义三类代码包。可以使用搜索栏，检索已经安装好的代码包。 系统内置系统内置了36种设计器所必须依赖的代码包，你可以点击“+”号图标，查看内置的代码包。 扩展包扩展包是官方支持的，但未内置到设计器安装包中的代码包，可按以下步骤进行安装操作。a. 点击管理主界面右侧 “安装扩展包”按钮，打开扩展包安装界面。并在界面中点击获取代码扩展，进行下载。b. 下载完成后，在安装界面点击路径按钮添加扩展包，并开始安装。当完成安装后，你可以返回到代码包主界面查看已经完成安装的扩展包。 自定义（实验室功能）自定义包因为存在未知的兼容性风险，建议谨慎使用该功能。如需使用，请按如下步骤操作：a. 先进入设计器的设置中心，并开启实验室功中的”代码包管理”b. 再次进入到代码包管理界面，可以看到地磅出现了安装包的功能按钮。c. 点击安装包按钮，可以打开包安装工具界面，你可以通过代码源安装所需的代码包。 AI模型管理OCR验证码识别组件功能说明 由于【OCR验证码识别】组件依赖的模型文件在不断训练升级，且模型文件大小高达200M，所以这次功能升级就是将这个模型文件从设计器执行器的安装包中移除，模型文件上线到弘玑官方市场上统一管理 使用场景 使用【AI能力&gt;OCR&gt;OCR验证码识别】组件时，需要安装依赖的模型文件包 如果觉得OCR识别准确率不高，可以联系技术支持或产品运营定制化训练后，用新模型替换旧模型 使用方法设计器 使用【OCR验证码识别】组件时，会检查是否存在依赖的OCR模型，如果没有会报错提醒，点击“前往安装”会跳转至AI模型管理面板 “AI模型管理”入口在工具栏的“依赖管理”下，可在线安装或离线安装 在线安装：使用前提是需要确保设计器所在设备可以访问弘玑官方市场（https://marketplace.cyclone-robotics.com/） 离线安装：如果设计器所在设备无法访问，可以采用本地导入的方式离线安装 如果是离线安装，从哪里获取OCR验证码模型文件？ 前往弘玑官方市场，需要使用账号密码登录（公司的LDAP账号），登录后可下载最新版OCR验证码模型文件 如果当前最新版的模型文件识别效果不佳，也可联系技术支持或产品运营进行定制化训练，从离线安装入口导入新模型文件进行替换 执行器 如果要跑的流程中使用到了OCR验证码识别组件，则需要相应在执行器中导入OCR验证码模型 新增【AI模型管理】在执行器托盘右键下 旧版组件（erpa）旧版组件的本地导入在旧版组件管理中，选择【本地】可以将获得的新组件导入到组件库中。 选择 ① 本地，选择②导入组件，可以选择③单个erpa文件或者选择④存放erpa的文件夹批量导入。 当有新版本的外部组件需要更新时，选择⑤可以进行新组件更新升级。 当需要将组件导出到其他项目或计算机时可以选择⑥进行导出。 不需要再项目中运行或需要将组件移除流程时，可以选择⑦进行禁用，此时流程当中所用到的此功能组件将无法使用。 如果项目中不在需要此组件时可以选择⑧进行删除。 选择⑨开发工具可以对此组件进行测试，已经修改等功能。 调试：进行组件运行测试。 功能测试会对导入的节点进行功能和属性上的测试，主要用于自定义的组件。 重新编译：主要针对重新进行修改和编辑后的组件进行编译，编译完成后可以在插件功能测试中显示改动的新功能和属性。 编辑Schema：对已经编写好的功能组件进行修改和自定义更新。 注意 ⑨的部分开发工具功能属于实验室功能，如需使用请与官方技术支持人员联系。 旧版组件市场选择共享后可以看到提示，需要连接到应用市场，此时可以查看 Designer Pro 连接中心 数据抓取使用场景用于抓取目标软件中的表格数据和结构化数据，比如： 表格 结构化数据 使用说明表格 如果是抓表格，请捕获表格中的一个单元格 可选择要抓取整个表格，或是仅抓取单列数据，或者仅抓取单行数据 点击继续，将自动爬取数据后，展示在数据预览界面，左下角会统计抓取行数和列数 左上角有开关控制 首行是否作为表头，默认不开启 根据引导，如果需要翻页的情况，可继续捕获下一页按钮 注意，此翻页不适用于瀑布式加载的情况 页码组指的是没有下一页按钮，只能选择页面序号的情况 如果不需要翻页，可点击“仅抓取当前页” 结构化数据 如果是抓结构化数据，比如当当热销书榜单的书名、作者、价格，需要一列一列数据捕获，请先捕获第一列书名的其中一个元素，比如第一个书名 根据提示，再捕获第一列书名的另一个元素，建议找个离第一个元素距离比较远的，比如倒数第一个元素 捕获成功后，会红框高亮所有的相似元素 捕获成功后，可以选择将元素的URL链接输出到单独列，URL指的是点击这个元素会跳转到的网址链接，可以按需选择是否要输出 下一步可将数据抓取出来，列名默认值是column1,2,3…支持修改列名 接下来还要捕获第二列作者信息，点击“新增列”按钮，继续用同样的方法捕获作者元素 捕获了这两个元素后（一个是单个作者，一个是多个作者），却提示错误了，说明这两个元素并不在网页的同一个层级，也就是说，他们在网页源码层面上并不相似 点击“重新捕获”，我们再尝试一次，这次我们去捕获单个作者，就成功了 同样的，可以将列名改为“作者” 接下来捕获价格，也是同样的方法 组件属性 如果是抓表格，会生成组件【抓取表格数据】，属性说明详见抓取表格数据 如果是抓结构化数据，会生成组件【抓取结构化数据】，属性说明详见抓取结构化数据 弹窗监控使用场景 流程运行过程中，可能会不定时的出现弹窗干扰，导致流程异常 常见的弹窗可以分为三种： 80%为浏览器弹窗，关闭后流程可以继续运行 15%为客户端软件内弹窗，如更新通知 5%为系统级别的弹窗，可能无法关闭，或关闭后机器人不能继续运行 弹窗出现的时间不固定，在流程运行时，随时可能跳出弹窗，并且不同弹窗的处理方式也不同 功能描述解决全流程执行过程中，不定时弹出的已知弹窗 不定时：不确定何时弹出，降低了流程的开发和执行效率 已知弹窗：弹窗需要是在流程设计中，遇到过的已知弹窗 注意事项 连贯的原子性业务操作（如多次展开下拉框）如果被弹窗中断（下拉框可能会被折叠），关闭弹窗后无法返回中间步骤继续执行；建议搭建流程时将连贯操作放到一个try-catch整体中重试 弹窗出现时被阻断的业务操作是不确定的；建议在弹窗监控节点后校验关闭弹窗操作是否被正确执行 每个流程的弹窗监控最多可以设置开启10个任务，但出于性能考虑，建议弹窗监控不超过五个 使用说明 并行弹窗监控功能将对指定的.flow流程文件监控； 添加弹窗监控后，会在左侧项目栏中为添加过的流程文件名后显示监控 对流程添加弹窗监控后，可设置： 捕获弹窗元素: 捕获弹窗元素支持Windows内核弹窗和Chrome内核弹窗 捕获模式支持：常规、表格、UIA 当捕获的弹窗为Chrome内核弹窗时，将在运行时通过对浏览器进行代码注入的方式，自动拦截该弹窗； 注意 注意： 由于向浏览器注入拦截代码需要耗时，请确保流程总的运行时长不短于10秒 当捕获的弹窗为windows弹窗时，需要用户手动设置处置流程。 以截图中的消息提醒弹窗为例，可通过点击（坐标偏移）去关闭弹窗 对每一个弹窗，支持三种操作方式：：点击、输入文本、发送热键 执行时将打印监控任务的日志 日志将保存在以下目录：“%appdata%&#x2F;cyclone&#x2F;logs&#x2F;monitor” QA 问题：开启了弹窗监控，要关闭的是Chrome内核的弹窗，但却发现关不掉 解决办法：如果这个弹窗是在打开Chrome浏览器后很快就出现的，建议在打开浏览器前加等待10秒，原因是关闭chrome弹窗的方式是通过注入JS脚本实现的，注入需要一定时间 工具管理小工具UI解析器用于验证设计器的捕获能力，探测界面上的元素是否可以被捕获。功能详见：UI解析器 Inspect小工具微软提供的官方捕获小工具，用于验证目标程序的元素是否按微软接口规范开发，不符合规范的元素是无法使用常规捕获的。 诊断工具收集电脑硬件环境,以及日志信息。详见说明：诊断工具 Cyclone浏览器内置的浏览器，如果您的流程涉及网页自动化,推荐您使用此浏览器。 恢复分辨率助手(Remote Helper)帮助执行器所在的远程桌面恢复界面，如果您的流程涉及界面操作、且将在虚机中执行，建议您先使用此工具查看可恢复的分辨率列表，详见使用说明恢复分辨率助手 。 远程连接助手(Remote Manager)当您的机器人被部署在远程桌面上(无人值守场景)，您可在另一台独立的机器上安装远程连接助手并连接上中控，可在中控上配置执行流程时所需的分辨率，增强流程稳定性。详见说明远程连接助手 clog查看工具（logviewer）用于Clog日志内容的基本阅读。若你需要分析较大日志，建议你通过日志导出功能将日志还原（设置-诊断-导出日志），然后使用如notpad++等工具进行分析。 插件Chrome插件安装Chrome插件，用于Chrome浏览器自动化操作。 Edge插件安装Edge插件，用于Edge浏览器自动化操作。 Java插件安装Java插件，用于Java应用程序自动化操作。 IE插件安装E插件,用于IE浏览器自动化操作。 Firefox插件安装Firefox插件，用于Firefox浏览器自动化操作。 360安全浏览器插件安装360浏览器插件，用于360安全浏览器自动化操作。 PS2驱动安装PS2键盘驱动，常用于输入密码控件。 HID驱动安装HID键盘驱动，常用于输入密码控件。 FAR驱动安装FAR键盘驱动，常用于在远程桌面的密码控件中输入 微软远程桌面插件安装微软远程桌面插件，用于微软远程桌面自动化操作，注意需要在远程桌面中安装相应程序。详见产品手册：微软远程桌面插件 Citrix插件安装Citrix插件，用于Citrix程序自动化操作，注意需要在Citrix中安装相应程序。 Inspect小工具使用场景 使用元素捕获功能时，常规、UIA、表格捕获模式不能正常捕获时（鼠标移动到目标元素时没有红框高亮） 想知道常规&#x2F;UIA&#x2F;表格捕获模式是否能够适配，可以先用Inspect小工具进行捕获 提问题工单时可以附上Inspect小工具的抓取截图 使用方法 前往设计器安装目录…\\extra_resources\\recorder\\tool 使用管理员权限启动Inspect.exe进行捕获 用MSAA和UIA分别尝试一下，看下能否在目标元素上画出黄色框框： 如果能画出黄色框框，请提问题工单，产研将相应适配这种场景，可以支持捕获 如果不能画出黄色框框，可以捕获目标元素所在的窗或者区域后，尝试一层一层展开元素DOM树 如果无法展开更下层，说明内部元素无法被捕获，常规捕获无法适配，请用其他绕行方案（图片匹配、CV、快捷键、OCR等） 如果是CS客户端，查看Role属性 如果是Role属性值是文档，可以推断这个软件应该是一个内嵌网页，可能可以适配，请提工单 如果是Role属性值是窗格，可以推断这个情况是由于微软没有提供接口，竞品友商都是抓不到的，请用其他绕行方案（图片匹配、CV、快捷键、OCR等） 案例说明： 内网通的内部元素不可被捕获。 招行CBS7内部元素可被捕获。 诊断工具使用场景诊断工具，主要两个能力。对安装RPA软件的设备进行预检，快速了解电脑的软件硬件信息。用于发生故障时候，对设备的硬件、系统、软件、RAP及日志进行全面的搜集并打包，提交到研发同学定位问题。 使用说明1. 如何获取 V4.5以下版本：独立绿色版的EXE小工具，可以像产品运营同学 申昌港获取。 V4.5及以上版本：通过工具管理打开 2. 检测功能11. 用户点击“检测”按钮后，软件会调起资源管理器弹出层，选择路径后进行保存报告。 恢复分辨率助手(Remote Helper)功能说明恢复分辨率助手(RH)是一个独立的应用程序，可以帮助机器人恢复远程桌面的连接，可独立安装使用，无需升级设计器和执行器的版本。 适用场景无人值守&#x2F;远程机器人通常被部署在云桌面上，在机器人执行控界面元素相关操作时，如果用户断开了远程连接，电脑系统会回收鼠标键盘权限，导致机器人相关操作执行失败，因此需要Remote Helper帮助机器人恢复远程桌面的连接。 已知问题 支持Vmware, 微软云、阿里云、腾讯云、Windows远程桌面 不支持win-server多用户登录的场景（一个恢复分辨率助手(RH)只能服务于一个用户，一台电脑只能开启一个恢复分辨率助手(RH)，也就是说在多用户登录的场景下，只有一个用户断开远程桌面后能使用恢复分辨率助手(RH)帮助机器人恢复） 不支持win server 2008 不支持Citrix、华为云（目前恢复分辨率助手(RH)无法正常工作） 如遇上述场景，请使用远程连接助手(Remote Manager) 使用方法安装方法 前往设计器的安装目录下\\extra_resources\\recorder，确保存在以下三个文件： RemoteHelper.exe RemoteHelper_Detail.bat RemoteHelper_Monitor.bat 确保与action_gui.dll文件在平级目录，不能用文件夹隔开； 确保AgentHelper.exe进程不处于运行状态； 确保tscon.exe进程不处于运行状态； 确保没有运行过close-rdp.cmd脚本。 RemoteHelper_Detail.bat 运行RemoteHelper_Detail.bat文件，可以让实施人员提前知道，这台云桌面（即执行器所在的设备）可以使用恢复分辨率助手(RH)自动恢复到哪几个分辨率； 设计流程时使用的电脑分辨率（即设计器所在的设备），应尽可能的与推荐的分辨率一致，以增强稳定性； RemoteHelper_Monitor.bat 运行RemoteHelper_Monitor.bat文件，可以让远程连接断开后，帮助机器人恢复远程桌面的连接，以确保执行器正常工作； 这个不需要每次断开前都执行，注意在每次电脑重启&#x2F;注销之后，手动执行一次即可。 远程连接助手(Remote Manager)使用场景无人值守&#x2F;远程机器人通常被部署在云桌面上，而在用户断开了云桌面的远程连接时，系统会回收鼠标键盘权限，导致机器人执行前台操作时失败，需要产品化解决方案，应对这种场景 前提条件 已部署中控，远程连接助手(RM)需要使用中控账号登录 远程连接助手(RM)需要被安装于一台Windows系统的电脑上，这台电脑可以使用远程桌面连接（mstsc）连接到所有执行器所在的云桌面 如果远程连接助手(RM)安装在云桌面，注意RM不能自己连接自己，所以这台云桌面不能断开连接 电脑配置要求 系统要求：WIN7及以上 连接一个机器人要100~150M内存 举例：8G内存电脑可以连接50+个远端机 功能介绍什么是远程连接助手RemoteManager（RM）？ 用于管理执行器所在的云桌面 可以模拟远程连接到云桌面，确保云桌面都在连接状态下执行流程 为什么需要远程连接助手RemoteManager（RM）？ 使用RM用户可以配置连接云桌面时的分辨率，解决目前用户的痛点问题： 分辨率变化很大，导致流程不稳定 低分辨率下开发，用户体验不好 远程连接助手(RM)和恢复分辨率助手RemoteHelper(RH) 的关系？ 两者并不冲突，可以配合使用 恢复分辨率助手(RH)适合的场景： 客户购买的无人值守&#x2F;远程机器人数量较少，比如只有一两台 客户不愿耗费多一台机器的资源用于安装远程连接助手(RM) 流程执行不受分辨率变化影响或影响较小 使用说明1.连接至中控 确保使用的中控账号 拥有执行器设备管理权限 2.在中控上管理远程连接助手 连接成功后，进入连接列表页面，展示当前受中控调度去连接了哪些云桌面（不再支持RM本地连接云桌面的方式） 连接成功后，中控的远程桌面连接助手列表页会新增一条RM设备，状态为可用，可配置最大连接数，表示最多可连接多少个云桌面 在中控流程列表开启远程助手 在中控上传了一个包含“界面自动化”操作的流程，且设计器版本是4.4beta及以上，会在流程详情看到流程设计时的分辨率 如果希望该流程在设计时分辨率下执行，可开启远程连接助手，开启后会在流程下发到执行器时，自动调度远程连接助手RM、以该分辨率连接执行器所在的设备 注意 仅在流程执行前 中控会下发一次连接任务到RM，也就是说，如果在执行过程中有人连接到远程桌面的话，会踢掉RM的连接，且RM不会再次进行连接 启用远程连接助手时，可以选择如果RM连接失败，流程是否还继续执行，默认是继续执行 捕获远程桌面插件使用场景 随着云桌面在企业中的广泛应用，前场会遇到这样的场景：RPA需要操作的应用软件安装在远程桌面，而设计器和执行器则安装在本机&#x2F;另一台虚机 设计器在捕获元素的时候，没法捕获到在远程桌面上的元素 在加入抓取远程桌面插件后，将支持微软远程桌面&#x2F;Citrix等常见的远程桌面工具，实现对远程桌面元素的捕获 使用前提支持对象：微软远程桌面&#x2F;Citrix 远程桌面必须是Windows系统，已验证支持Win7、Win10、win sever 2016 需要同时在设计器端和远程桌面端安装插件 设计器端和远程桌面端都需要使用管理员权限安装插件 使用说明插件安装 在设计器端安装 以管理员身份运行设计器 退出已开启的远程桌面 前往“工具管理”，点击安装“微软远程桌面”、“Citrix插件” 插件安装成功后，打开远程桌面进行远程桌面端的安装 在远程桌面中安装 在设计器安装目录下，寻找“…\\cyclone\\extra_resources\\recorder\\tool\\RemotePackage”文件夹 将“RemotePackage”文件夹复制到远程桌面中 如果需要在远程桌面中捕获IE、Chrome、…，需要以管理员身份运行”…\\RemotePackage\\InstallAsAdministrator.bat”，安装常用的浏览器插件 管理员身份运行“…\\RemotePackage\\cyclone_remote.exe”，等待进程出现在任务管理器中，即可实现对远程桌面的捕获 注意如果远程桌面重启了，需要再次手动启动该进程 插件卸载在设计器卸载 卸载设计器时会自动卸载插件 在远程桌面中卸载 如需卸载远程桌面中安装的浏览器插件，需要以管理员身份运行“…\\UninstallAsAdministrator.bat”，卸载安装的浏览器插件 元素选择器更新 当用户捕获远程桌面中的元素后，元素选择器会多一层数据： 远程桌面窗口标题，支持修改 远程桌面类型 UI解析器更新 当用户捕获远程桌面元素之后，UI解析器会多一层数据： 远程桌面窗口标题 远程桌面类型 远程桌面窗口的宽高左上 Chrome浏览器插件 安装说明一、检查插件 查看插件安装和打开状态，可以通过三种方式打开。 ①拼图按钮-&gt;管理扩展程序 ②三点按钮-&gt;更多工具-&gt;扩展程序 ③在Chrome地址栏直接输入chrome:&#x2F;&#x2F;extensions&#x2F;，敲击回车 ④在打开的页面确认是否有Cyclone Automation Tool的扩展，并且已经打开。 二、安装方式 设计器软件安装时自动安装插件 Chrome插件在设计器安装时会自动安装（安装时需要关闭浏览器，否则会强制关闭），再次打开浏览器页面会提示打开插件。 注意：再次打开浏览器页面时，请务必手动点击打开插件按钮。 设计器软件中手动安装（推荐） 点击左侧边栏工具管理按钮，点击Chrome插件旁边的“安装”按钮（安装时需要关闭浏览器，否则会强制关闭）。 此时会弹出你要允许此应用对你的设备进行更改吗？点击是，等待自动安装完成即可。 再次打开浏览器页面，页面右上角会提示打开插件，请手动点击“启用扩展程序”。 其他安装方式 在设计器的安装目录下\\extra_resources\\recorder找到文件SpeedAutomationTool.crx，并将它拖入Chrome扩展管理的页面 右上角打开开发者模式后，将SpeedAutomationTool.crx文件拖入即可安装，如果不能拖入安装，需要进行 在地址栏输入chrome:&#x2F;&#x2F;flags&#x2F;#extensions-on-chrome-urls，并把黄色高亮选项改为enabled。 三、启用扩展 方式一：浏览器提示启用 扩展安装完毕后，初次打开浏览器，会弹出一个提示，这时需点击启用扩展程序按钮 方式二：手动启用 点击浏览器右上角的①三个点状按钮（自定义及控制Google Chrome）按钮，打开菜单 点击②更多工具(L) 选项，展开更多工具菜单 点击③扩展程序(E)选项，打开扩展程序页面 找到Cyclone Automation Tool，点击开关 IE浏览器插件IE插件在设计器安装时会自动安装（安装时需要关闭浏览器，否则会强制关闭）并打开。 一、检查插件查看插件安装和打开状态，检查是否已安装并开启IE加载项 点击设置&gt;管理加载项 启用名称为【BridgeIEBHO Class】的加载项, - 只需启用一次，启用后重启IE即可正常抓取IE元素 二、安装插件 设计器软件中手动安装（推荐） 如果在IE找不到对应的加载项，则需要手动安装插件。首先点击左侧边栏工具管理按钮，点击IE插件旁边的“安装”按钮（安装时需要关闭浏览器，否则会强制关闭）。 此时会弹出你要允许此应用对你的设备进行更改吗？点击是，等待自动安装完成即可。 再次打开IE浏览器，启用BridgeIEBHO Class加载项，重启浏览器后即可正常捕获元素。 其他安装方式 在设计器的安装目录下\\resources\\runTime\\cpp找到文件InstallAsAdministrator.bat关闭IE浏览器后，使用管理员权限运行bat文件 此时会弹出你要允许此应用对你的设备进行更改吗？点击是，进入命令提示符界面，等待命令提示符代码自动运行完。 再次打开IE浏览器，启用BridgeIEBHO Class加载项，重启浏览器后即可正常捕获元素。 三、启用加载项 点击设置&gt;管理加载项 启用名称为【BridgeIEBHO Class】的加载项（若找不到该加载项请看IE浏览器插件 常见问题 ） 只需启用一次，启用后重启IE即可正常抓取IE元素 Edge浏览器插件Edge插件在设计器安装时会自动安装（安装时需要关闭浏览器，否则会强制关闭）并打开。 一、检查插件查看插件安装和打开状态 点击拼图按钮-&gt;管理扩展 在地址栏输入edge:&#x2F;&#x2F;extensions&#x2F;，查看是否有 查看是否有名为Cyclone Automation Tool的扩展和打开的状态，如果未打开，点击按钮打开。如果未安装，请按照下面的指南安装插件。 二、安装插件 V3.1.4以前的设计器版本，需要手动安装扩展：（1）连接外网，需要可以访问谷歌的网上应用商店（2）打开Cyclone Automation Tool - Chrome 网上应用店 (google.com) （3）点击安装 V3.1.4及以上的设计器版本，可以在设计器软件中手动安装（推荐） 如果在Edge找不到对应的加载项，则需要手动安装插件。首先点击左侧边栏工具管理按钮，点击Edge插件旁边的“安装”按钮（安装时需要关闭浏览器，否则会强制关闭）。 此时会弹出你要允许此应用对你的设备进行更改吗？点击是，等待自动安装完成即可。 再次打开Edge浏览器，在右上角弹出界面中选择“打开扩展”按钮。 其他安装方式 在设计器的安装目录下\\resources\\runTime\\cpp找到文件CycloneAutomationTool.crx 左下角打开开发者模式后，将CycloneAutomationTool.crx文件拖入并点击添加扩展即可 三、启用扩展 安装成功后，进入①管理扩展，②启用扩展 启用后，重启重启浏览器后可正常捕获元素。 UI解析器前置条件 如需捕获Chrome，请安装和启用Chrome插件 如需捕获IE，请安装和启用IE加载项 如需捕获Java，请安装Java Hook 如需捕获SAP，请SAP客户端和服务端均启用GUI脚本权限 功能入口 右键单击画布中的组件 属性栏的目标元素中的“更多”图标 元素选择器中的“在UI解析器中查看” 属性列表属性列表分为【窗口属性】和【元素属性】两部分，【窗口属性】代表的是元素所在窗口，【元素属性】为元素本身 【info】部分属性，如果被取消勾选，当前属性值会在保存、复制、高亮时舍弃 【属性项】属性名称，不支持编辑 【匹配模式】下拉可选：&#x3D; 等于、*通配、.*正则 【属性值】支持编辑，点击即可编辑 【变量】可引用设计器中的变量 。 属性对比点击【属性对比】，进行第二次捕获 可对比前后两次捕获，目标元素的属性不同的地方 在对比值中高亮红字，代表属性值发生了变化 ： 将发生变化的属性值改为通配符或正则表达式 如果是有规律的变化，可考虑使用“引用变量”功能 将变化很大的属性取消勾选 原始数据开启【原始数据】开关，方便直接修改源代码。 复制与粘贴在UI解析器中捕获后，点击【复制到剪贴板】按钮，复制完整的selector，可粘贴至设计器节点 在设计器中捕获的元素，也可复制selector后，点击UI解析器中的【粘贴至解析器】 查看捕获截图用户抓取时对元素所在界面的截图，红框高亮目标元素 层级捕获使用场景捕获元素时，需要使用鼠标，但需要捕获的元素在鼠标移动上后会隐藏，这导致了不能捕获网页上有遮罩层，导致捕获不到想要的目标元素 使用方法 点击层级捕获按钮，捕获所需要的内容，如果出现遮罩层或被隐藏的元素，则对包含其所在的部分进行捕获。 捕获后在界面右侧会生成元素层级树，你所捕获的部分会被高亮显示。根据对层级树结构的判断，找到具体需要捕获的元素并双击，此时编辑器中元素属性的属性值会发生改变，变为你需要真正捕获的元素值，最后点击保存。 匹配方式【精准匹配】基于固定值或变量值，可在输入框中输入固定值，或@引用变量 【通配匹配】支持通配符“*”和“？” *：代替零个、单个或多个字符 ？：代替一个字符 【正则匹配】 支持Perl正则表达式，详见链接：https://www.runoob.com/perl/perl-regular-expressions.html 实现的是regex_search功能，实现部分匹配而不是完全匹配，举例来说，如果目标元素是“百度一下，你就知道“，如果选择了正则匹配，匹配值为”百度“，是可以匹配上的。 Git版本管理功能说明Git管理功能可以满足流程设计者的版本管理需求。 使用说明在使用git管理功能对项目进行版本控制前，需要完成git初始化操作 Git初始化Git安装 在设计器端使用git进行版本管理之前，需要在本地机器上安装git 当本地git未安装时，设计器会提示git未安装 此时，点击”进入官网“下载并安装Git Git已安装 当完成Git的安装后，需要编辑Git作者信息以完成初始化 Git初始配置 配置用户名称及邮箱（即在git bash中配置的用户名和邮箱） 完成后即可选择初始化项目仓库 Git配置更新 设计器端不可移除Git作者，但可对Git作者进行更新 如需移除Git作者，需要在Git Bash中输入指令 git config –global –unset user.name “yourUserName” git config –global –unset user.email “yourEmail” 当本地的账号被移除之后，设计器中的作者会自动被移除 项目仓库初始化 完成本机Git安装和用户信息配置后，点击初始化项目仓库 初始化项目仓库完成后，即可看到提交版本和历史版本 功能介绍提交版本: 提交前校验 保存校验：当用户提交任意项目文件前，会自动校验文件是否保存 本地仓库创建、更新 选中需要提交的文件，填写提交信息并提交后，将完成项目的初始化 初次提交时，会在项目的目录，生成Git本地仓库 “.git” （发布的时候将忽略 .git目录，工程项目中没有.git目录） 再次提交时，完成本地仓库的更新 提交版本中支持对文件进行搜索 支持精准匹配和关键字匹配，如使用文件名、文件后缀进行搜索 历史版本：查看历史版本 在历史提交记录中，可以查看提交说明、提交时间、提交版本号 支持流程文件（flow文件）、代码块文件（python、JS、MJS类型文件…）的比对 文件可点击查看变更内容，比较历史版本版本和前一版本的内容差异（绿色 新增，红色 删除） 文件内容搜索：可搜索到对应的节点（历史版本和本地版本都可以搜索）、python文件、JS文件可以定位到行号 提交版本: 项目下载 点击列表下载图标，可下载对应版本的项目文件 选择目标目录，可下载对应的项目 点击下载后，用户选择要保存的路径，确认后完成版本下载 下载的文件为项目压缩包 配置用户名称及邮箱（即在git bash中配置的用户名和邮箱） 完成后即可选择初始化项目仓库 Git配置更新 设计器端不可移除Git作者，但可对Git作者进行更新 如需移除Git作者，需要在Git Bash中输入指令 git config –global –unset user.name “yourUserName” git config –global –unset user.email “yourEmail” 当本地的账号被移除之后，设计器中的作者会自动被移除 项目仓库初始化 完成本机Git安装和用户信息配置后，点击初始化项目仓库 初始化项目仓库完成后，即可看到提交版本和历史版本 本地仓库 功能介绍 提交版本: 提交前校验 保存校验：当用户提交任意项目文件前，会自动校验文件是否保存 本地仓库创建、更新 选中需要提交的文件，填写提交信息并提交后，将完成项目的初始化 初次提交时，会在项目的目录，生成Git本地仓库 “.git” （发布的时候将忽略 .git目录，工程项目中没有.git目录） 再次提交时，完成本地仓库的更新 本地仓库文件搜索展示： 提交版本中支持对文件进行搜索 支持精准匹配和关键字匹配，如使用文件名、文件后缀进行搜索 历史版本： 查看历史版本 在历史提交记录中，可以查看提交说明、提交时间、提交版本号 支持流程文件（flow文件）、代码块文件（python、JS、MJS类型文件…）的比对 文件可点击查看变更内容，比较历史版本版本和前一版本的内容差异（绿色 新增，红色 删除） 文件内容搜索：可搜索到对应的节点（历史版本和本地版本都可以搜索）、python文件、JS文件可以定位到行号 文件下载 项目下载 点击列表下载图标，可下载对应版本的项目文件 选择目标目录，可下载对应的项目 点击下载后，用户选择要保存的路径，确认后完成版本下载 下载的文件为项目压缩包 远程仓库克隆远程仓库 支持http和ssh方法进行克隆，输入远程仓库地址及用户名密码信息后即可成功克隆。 推送能够实现用户连接远程仓库后，将本地仓库当前内容提交到远程仓库，并支持文件层级的冲突展示与解决冲突。 拉取能够实现用户连接远程仓库后，将远程仓库最新代码同步至本地 历史版本用户可以下载远程仓库的历史版本内容，打包下载到本地指定文件夹。 Designer Pro 连接中心中控Designer Pro连接中心主要管理设计器连接的外部服务器。 设计器的连接中心，支持基于中控的账号密码，以及账号+密钥的连接方式。 AI服务功能描述连接AI服务器，获得AI服务器的基本信息，并支持AI节点运行 使用场景某些项目需要基于CV ROBOT 或连接到技能平台，可使用该模块进行连接信息配置 使用方法入口：在设计器的 “连接中心”面板中，新增了一个“AI服务”页签，可打开直连服务的配置弹出层。 配置：点击连接新服务，可以打开添加服务弹出层。在弹出层中输入正确的连接地址、账号、密码。然后点击连接，即可完成配置。配置成功后，界面将会展示从服务器端读取到的基本参数信息。、连接失败则提醒失败信息。","categories":[{"name":"RPA","slug":"RPA","permalink":"https://www.yiuhangblog.com/categories/RPA/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"弘玑","slug":"弘玑","permalink":"https://www.yiuhangblog.com/tags/%E5%BC%98%E7%8E%91/"}],"author":"Yiuhang Chan"},{"title":"JS逆向","slug":"20220108JS逆向","date":"2022-01-08T10:12:46.000Z","updated":"2024-02-28T10:35:10.000Z","comments":true,"path":"2022/01/08/20220108JS逆向/","permalink":"https://www.yiuhangblog.com/2022/01/08/20220108JS%E9%80%86%E5%90%91/","excerpt":"JS逆向基础理论","text":"JS逆向简要介绍案例：模拟百度翻译请求检查百度翻译请求首先，对百度翻译的请求进行了检查。通过分析发现，百度翻译使用的是POST请求方法。在翻译过程中的请求载荷内容进行了详细观察。 请求参数分析在请求的脚本参数中，发现了from和to字段。通过模拟操作，可以推断出这些参数代表着翻译的源语言和目标语言，例如从中文翻译到英文。进一步观察表单数据，可以看到请求所携带的所有参数。 请求头对于请求的表头参数也进行了检查，以便在模拟请求时能够更准确地伪装。 Sign参数首先ctrl+shift+f 全局搜索sign参数所在源代码 一个个查看这些sign参数，对符合js模式的进行断点 重新执行翻译过程，可以发现断点停留在sign: b(e)，即js方法调用处 在控制台输入参数可以看到sign的值 跳转这个调用到其源代码 Python代码实现爬虫代码12345678910111213141516171819202122232425262728293031323334import timeimport jsdataimport requests# 设置请求URL和头部信息url = &#x27;https://fanyi.baidu.com/v2transapi?from=zh&amp;to=en&#x27;headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 ...&#x27;, &#x27;Cookie&#x27;: &#x27;PSTM=1694260469; BIDUPSID=...; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1703248315;&#x27;, &#x27;Acs-Token&#x27;: &#x27;1703217664841_1703248346365_aQyvrnWWYIouJv2VqASm...&#x27;&#125;# 获取用户输入的翻译内容a = input(&#x27;输入你要翻译的内容:&#x27;)# 调用jsdata模块生成签名sign = jsdata.make_js_data(a)# 构建表单数据form_data = &#123; &quot;from&quot;: &quot;zh&quot;, &quot;to&quot;: &quot;en&quot;, &quot;query&quot;: a, &quot;transtype&quot;: &quot;realtime&quot;, &quot;simple_means_flag&quot;: &quot;3&quot;, &quot;sign&quot;: sign, &quot;token&quot;: &quot;2977c992c92eb0731d89f23d17b6edd7&quot;, &quot;domain&quot;: &quot;common&quot;, &quot;ts&quot;: str(int(time.time()*1000)),&#125;# 发送POST请求并输出结果res = requests.post(url, headers=headers, data=form_data)print(res.json().get(&quot;trans_result&quot;).get(&quot;data&quot;)[0].get(&#x27;dst&#x27;)) 以上代码首先导入了必要的模块，设置了请求的URL和头部信息。通过用户输入获取翻译内容，然后使用jsdata模块来生成签名。随后构建表单数据，包括语言类型、查询词、时间戳等，并发送POST请求。最后，从返回的JSON数据中提取并打印翻译结果。 信息 &quot;ts&quot;: str(int(time.time()*1000)) 用于生成一个时间戳，这个时间戳是表单数据（form_data）的一部分，发送给百度翻译的服务器。下面详细解释这个时间戳的生成过程： time.time(): 这个函数来自Python的time模块，用于获取当前时间。它返回的是一个浮点数，代表自1970年1月1日（称为Unix纪元或Epoch时间）以来的秒数。 time.time() * 1000: 由于time.time()返回的是秒数，而通常服务器端需要的时间戳是以毫秒为单位的。因此，将其乘以1000，将秒转换成毫秒。 int(...): 这个函数将浮点数转换为整数。在这里，它将乘以1000后的结果转换成整数形式，因为时间戳通常是整数形式的毫秒值。 str(...): 最后，int类型的时间戳被转换成字符串（str），因为在构建表单数据时，需要的是字符串形式的时间戳。 综合来看，&quot;ts&quot;: str(int(time.time()*1000)) 这一行代码生成了一个表示当前时间的毫秒级时间戳，并将其转换为字符串格式，以便作为HTTP请求的一部分发送。 JS逆向代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function n(t, e) &#123; for (var n = 0; n &lt; e.length - 2; n += 3) &#123; var r = e.charAt(n + 2); r = &quot;a&quot; &lt;= r ? r.charCodeAt(0) - 87 : Number(r), r = &quot;+&quot; === e.charAt(n + 1) ? t &gt;&gt;&gt; r : t &lt;&lt; r, t = &quot;+&quot; === e.charAt(n) ? t + r &amp; 4294967295 : t ^ r &#125; return t&#125;var r = null;const gtk = &#x27;320305.131321201&#x27;;function test_JS_re_code(t,gtk) &#123; var o, i = t.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g); if (null === i) &#123; var a = t.length; a &gt; 30 &amp;&amp; (t = &quot;&quot;.concat(t.substr(0, 10)).concat(t.substr(Math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10))) &#125; else &#123; for (var s = t.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), c = 0, u = s.length, l = []; c &lt; u; c++) &quot;&quot; !== s[c] &amp;&amp; l.push.apply(l, function(t) &#123; if (Array.isArray(t)) return e(t) &#125;(o = s[c].split(&quot;&quot;)) || function(t) &#123; if (&quot;undefined&quot; != typeof Symbol &amp;&amp; null != t[Symbol.iterator] || null != t[&quot;@@iterator&quot;]) return Array.from(t) &#125;(o) || function(t, n) &#123; if (t) &#123; if (&quot;string&quot; == typeof t) return e(t, n); var r = Object.prototype.toString.call(t).slice(8, -1); return &quot;Object&quot; === r &amp;&amp; t.constructor &amp;&amp; (r = t.constructor.name), &quot;Map&quot; === r || &quot;Set&quot; === r ? Array.from(t) : &quot;Arguments&quot; === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0 &#125; &#125;(o) || function() &#123; throw new TypeError(&quot;Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;) &#125;()), c !== u - 1 &amp;&amp; l.push(i[c]); var p = l.length; p &gt; 30 &amp;&amp; (t = l.slice(0, 10).join(&quot;&quot;) + l.slice(Math.floor(p / 2) - 5, Math.floor(p / 2) + 5).join(&quot;&quot;) + l.slice(-10).join(&quot;&quot;)) &#125; for (var d = &quot;&quot;.concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (null !== r ? r : (r = gtk || &quot;&quot;) || &quot;&quot;).split(&quot;.&quot;), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v &lt; t.length; v++) &#123; var _ = t.charCodeAt(v); _ &lt; 128 ? g[y++] = _ : (_ &lt; 2048 ? g[y++] = _ &gt;&gt; 6 | 192 : (55296 == (64512 &amp; _) &amp;&amp; v + 1 &lt; t.length &amp;&amp; 56320 == (64512 &amp; t.charCodeAt(v + 1)) ? (_ = 65536 + ((1023 &amp; _) &lt;&lt; 10) + (1023 &amp; t.charCodeAt(++v)), g[y++] = _ &gt;&gt; 18 | 240, g[y++] = _ &gt;&gt; 12 &amp; 63 | 128) : g[y++] = _ &gt;&gt; 12 | 224, g[y++] = _ &gt;&gt; 6 &amp; 63 | 128), g[y++] = 63 &amp; _ | 128) &#125; for (var b = f, w = &quot;&quot;.concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(97)) + &quot;&quot;.concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(54)), k = &quot;&quot;.concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(51)) + &quot;&quot;.concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(98)) + &quot;&quot;.concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(102)), x = 0; x &lt; g.length; x++) b = n(b += g[x], w); return b = n(b, k), (b ^= m) &lt; 0 &amp;&amp; (b = 2147483648 + (2147483647 &amp; b)), &quot;&quot;.concat((b %= 1e6).toString(), &quot;.&quot;).concat(b ^ f) &#125; 对复制过来的调用JavaScript源代码进行适配修改： 去掉t.exports属性，不需要赋值，重新命名函数为test_JS_re_code n 函数 这个函数对给定的整数t和字符串e进行一系列位操作。 t: 初始整数值。 e: 用于操作的字符串，其字符用于决定如何变换t。 函数通过遍历字符串e并根据其字符执行位移和位异或操作来转换t。 最后，返回转换后的整数t。 test_JS_re_code函数 这个函数是主要的函数，用于生成百度翻译的sign值。 t: 要翻译的文本。 gtk: 百度翻译API的一个关键变量，用于生成签名的固定密钥之一。 这个函数的工作流程大致如下： 处理输入文本: 如果文本过长或包含特殊字符（比如表情符号），它会被适当地截断或转换。 字符编码处理: 文本t中的每个字符被转换为其ASCII或Unicode编码。 生成初始值: 通过某些固定字符和可能是密钥gtk的变量r组合，生成一个初始整数值b。 迭代处理: 对上一步得到的整数值b和文本的每个字符编码进行迭代处理，使用n函数和特定的字符串（在变量w和k中定义）进行变换。 生成最终sign值: 最终的b值经过一系列操作后，与gtk的某个部分进行操作，生成最终的sign值。 执行测试代码12345678910111213import execjsdef make_js_data(que): with open(&#x27;translate.js&#x27;, &#x27;r&#x27;) as f: translate = f.read() # 生成js操作对象 js_data = execjs.compile(translate) sign = js_data.call(&#x27;test_JS_re_code&#x27;,que) return sign 导入了execjs模块，这个模块允许Python运行JavaScript代码。 定义了一个名为make_js_data的函数，这个函数接受一个参数que，这个参数是用户想要翻译的文本。 这段代码从translate.js文件中读取JavaScript代码。translate.js包含了先前分析的那段JavaScript代码（包括n函数和test_JS_re_code函数）。execjs.compile方法编译这段JavaScript代码，使其可以在Python环境中执行。 通过execjs对象的call方法调用translate.js中的test_JS_re_code函数，传入要翻译的文本que作为参数，生成并返回sign值。 函数返回计算得到的sign值。 注意 gtk 和 token 的实际值通常是动态生成的，可能会随着百度翻译网站的更新而变化。在实际应用中，这些值需要从网站的某些部分（如JavaScript代码或隐藏的表单字段）中动态获取。 硬编码的值只用于示例和概念验证。如果要实现一个可靠和长期有效的解决方案，就需要实现一个方法来动态获取这些值。 使用硬编码的值可能会导致在百度翻译更新其验证机制后，代码无法正常工作。 gtk: 这通常是一个固定的字符串，用于生成翻译请求中的sign参数。sign参数是基于要翻译的文本和gtk值计算得出的，用于验证请求的合法性。 token: 这是另一个重要的验证参数，通常也是在发送翻译请求时必须包含的。它可能用于识别用户或会话，或者作为另一层的安全验证。 gtk为&#39;320305.131321201&#39;，token为2977c992c92eb0731d89f23d17b6edd7","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"JS逆向","slug":"JS逆向","permalink":"https://www.yiuhangblog.com/tags/JS%E9%80%86%E5%90%91/"}],"author":"Yiuhang Chan"},{"title":"编码与加解密","slug":"20211227编码与加解密","date":"2021-12-27T10:12:46.000Z","updated":"2024-02-28T10:35:03.000Z","comments":true,"path":"2021/12/27/20211227编码与加解密/","permalink":"https://www.yiuhangblog.com/2021/12/27/20211227%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"爬虫相关加密与解密理论","text":"概念和作用概念加密解密 是一种信息安全技术，用于保护数据免受未经授权的访问。加密是将原始数据（明文）转换为无法被轻易读懂的格式（密文）的过程。解密则是将密文还原为原始数据的过程。加密和解密确保只有拥有正确密钥的人可以访问和理解这些数据。 作用加密解密技术在网络信息传输安全中起着至关重要的作用，主要涉及以下三个方面： **保密性(Confidentiality)**：确保信息在传输过程中不被未授权的人员窥视或窃取。 **完整性(Integrity)**：确保信息在传输过程中未被修改或篡改。 **有效性(Availability)**：确保信息的接收者是合法且被授权的。 常用加密方式 数据加密方式 描述 主要解决的问题 常用算法 对称加密 使用同一个密钥进行数据的加密和解密。加密和解密速度快，适合大量数据的处理，但密钥的分发和管理是一个挑战。 数据的机密性 DES, AES 非对称加密 使用一对密钥，即公钥和私钥。公钥用于加密数据，私钥用于解密。公钥可以公开，而私钥必须保密。非对称加密通常用于密钥交换和数字签名，提供身份验证和数据机密性。 身份验证、数据机密性 DSA，RSA 单向加密 仅提供单向加密过程，不能被逆转。通常用于存储敏感信息，如密码哈希。 数据的完整性、验证数据未被篡改 MD5，SHA系列算法 对称加密 的例子包括 DES（数据加密标准）和 AES（高级加密标准）。AES是现代最常用的对称加密算法，广泛用于WiFi安全、VPN以及许多其他应用中。 非对称加密 的知名算法包括 RSA（由Rivest、Shamir和Adleman开发）和 DSA（数字签名算法）。RSA不仅用于加密，也用于数字签名，而DSA主要用于数字签名。 单向加密（哈希） 通常用于验证数据完整性。MD5（消息摘要算法第5版）虽然在许多应用中仍在使用，但由于安全性问题，现在更推荐使用SHA系列（安全哈希算法），如SHA-256。 字符编码进制在计算机中，所有信息最终都是以二进制形式存储的。字符编码就是字符（如字母、数字和符号）与二进制数之间的映射规则。不同的字符编码系统可以支持不同的字符集和语言。 常见的字符编码 ASCII（美国标准信息交换码）: 最初设计用于表示英文字符。 使用7位二进制数来表示一个字符（128个可能的字符）。 Unicode: 为了包含全球所有语言的字符，Unicode被设计出来。 最常用的形式是UTF-8，它是一种变长编码，可以用1到4个字节表示一个字符。 UTF-8: 在UTF-8编码中，ASCII字符只需一个字节，而其他字符可能需要多达四个字节。 由于其对ASCII的兼容性和对多字节字符的支持，UTF-8成为了互联网上最常用的编码方式。 二进制（Base-2）: 只使用0和1。每一位的值是2的幂。 十进制（Base-10）: 我们平常使用的数系统，使用0到9。每一位的值是10的幂。 十六进制（Base-16）: 使用0到9和A到F。十六进制广泛用于计算机系统中，因为它可以更简洁地表示二进制数。每一位的值是16的幂。 十进制 十六进制 二进制 0 0 0000 0000 1 1 0000 0001 2 2 0000 0010 3 3 0000 0011 4 4 0000 0100 &#x3D; 2^2 5 5 0000 0101 6 6 0000 0110 7 7 0000 0111 8 8 0000 1000 &#x3D; 2^3 9 9 0000 1001&#x3D;2^3+2^0 10 A 0000 1010&#x3D;2^3+2^1 11 B 0000 1011 12 C 0000 1100 13 D 0000 1101&#x3D;2^3+2^2+2^0 14 E 0000 1110&#x3D;2^3+2^2+2^1 15 F 0000 1111&#x3D;2^3+2^2+2^1+2^0 进制间转换方法Python中的进制转换十进制与二进制 在Python中，可以使用 bin() 函数将十进制数转换为二进制字符串，int() 函数用于将二进制字符串转换回十进制数。 12345# 十进制转二进制print(bin(255)) # 输出: &#x27;0b11111111&#x27;# 二进制转十进制print(int(&quot;0b11111111&quot;, 2)) # 输出: 255 十进制与十六进制 类似地，hex() 函数用于将十进制数转换为十六进制字符串，int() 函数也可以用于将十六进制字符串转换回十进制数。 12345# 十进制转十六进制print(hex(255)) # 输出: &#x27;0xff&#x27;# 十六进制转十进制print(int(&quot;0xff&quot;, 16)) # 输出: 255 Unicode 与字符编码Unicode是一个国际标准，它为世界上大多数的文字系统提供了唯一的码位。不同的编码方式（如UTF-8、UTF-16、UTF-32、GBK等）可以用来表示这些码位。 字符与Unicode码位： 使用 ord() 函数可以获取字符的Unicode码位。 chr() 函数则可以将Unicode码位转换回对应的字符。 字符编码： 字符串的 encode() 方法用于将Unicode字符串编码为特定编码格式的字节串。 相对地，字节串的 decode() 方法用于将字节串解码为Unicode字符串。 1234567# Unicode码位print(ord(&quot;中&quot;)) # 输出: 20013print(chr(20013)) # 输出: &#x27;中&#x27;# 编码为字节串print(&quot;中&quot;.encode(&quot;utf-8&quot;)) # 输出: b&#x27;\\xe4\\xb8\\xad&#x27;print(&quot;中&quot;.encode(&quot;gbk&quot;)) # 输出: b&#x27;\\xd6\\xd0&#x27; UTF-8编码： UTF-8是一种变长的编码方式，可以使用1到4个字节来表示一个Unicode字符。 对于ASCII字符（U+0000到U+007F），UTF-8与ASCII编码完全相同，使用单个字节表示。 GBK编码： GBK是用于简体中文的扩展编码集，是在GB2312基础上扩展而来。 在GBK编码中，汉字通常使用两个字节表示。 Base64编码原理概念Base64编码是一种编码方法，用于将二进制数据转换成ASCII字符串。Base64编码主要用于在不支持二进制数据的系统上存储和传输数据，例如在网页中嵌入图像数据或在电子邮件中发送二进制文件。Base64不是加密方法，它不提供任何安全性或数据保护。Base64是一种基于64个可打印字符来表示二进制数据的编码方法。这些字符包括26个大写字母、26个小写字母、10个数字，以及+和/，共计64个字符。 作用 处理非ASCII字符：最初设计用于电子邮件系统，后来被广泛用于处理包含非ASCII字符的情况，例如中文、日文等。 网络传输：在网络上传输数据时，特别是需要通过文本格式传输的二进制数据（如图片、加密数据等），Base64能将这些数据转换成由可打印字符组成的字符串。 数据表示：在一些应用中，如电子邮件附件、证书、网页内嵌资源等，Base64用于表示和传输数据。 Base64编码表Base64编码表是将二进制数据按6位一组划分，每组对应一个可打印字符。 文本到base64格式的转换转换过程通常包括以下步骤： 将文本转换为ASCII码：每个字符转换为其对应的ASCII值。 将ASCII码转换为二进制：每个ASCII值转换为8位二进制数。 划分6位一组：将二进制串划分为每组6位。 映射到Base64字符：每组二进制数映射到Base64编码表中对应的字符。 ASCII码转换首先，文本字符转换为它们对应的ASCII码： 123456&gt;&gt;&gt; ord(&quot;M&quot;)77&gt;&gt;&gt; ord(&quot;a&quot;)97&gt;&gt;&gt; ord(&quot;n&quot;)110 ASCII转二进制然后，ASCII码转换为8位的二进制表示： 123456&gt;&gt;&gt; bin(77)&#x27;0b1001101&#x27; # 实际上应该是 01001101&gt;&gt;&gt; bin(97)&#x27;0b1100001&#x27; # 实际上应该是 01100001&gt;&gt;&gt; bin(110)&#x27;0b1101110&#x27; # 实际上应该是 01101110 请注意，为了确保每个ASCII码都是8位二进制，通常需要在前面补0。 组合二进制并划分接着，将这些二进制串连起来，并每6位分为一组： 010011 010110 000101 101110 二进制转Base64编码每组二进制数转换为Base64编码表中对应的字符： 12345678&gt;&gt;&gt; int(&quot;010011&quot;, 2)19 # 对应Base64表中的 &#x27;T&#x27;&gt;&gt;&gt; int(&quot;010110&quot;, 2)22 # 对应Base64表中的 &#x27;W&#x27;&gt;&gt;&gt; int(&quot;000101&quot;, 2)5 # 对应Base64表中的 &#x27;F&#x27;&gt;&gt;&gt; int(&quot;101110&quot;, 2)46 # 对应Base64表中的 &#x27;u&#x27; 因此，”Man” 这个字符串在Base64编码中表示为 &quot;TWFu&quot;。 Base64编码：Base64编码是一种二进制到文本的编码方法，用于在文本格式中表示二进制数据。每个6位二进制数映射到Base64编码表中的一个字符。 补码：在Base64编码中，如果最后一组不足6位，则用0补足6位，并在编码结果末尾添加一个或两个等号（=）作为填充。 BASE64编码补码在Base64编码中，如果二进制数据的位数不是6的倍数，将使用补码=来填充，以保证编码后的字符串长度是4的倍数。 编码与加密的区别：Base64编码并不是加密过程。它不提供数据保护，只是一种编码方案，任何人都可以使用Base64算法将编码后的字符串解码回原始数据。 使用场景：虽然Base64主要用于在需要以文本格式传输二进制数据的场合，但它并不限于此。例如，Base64也常用于在Web应用中嵌入小的图像或其他类型的文件。 信息 凯撒密码（Caesar Cipher）是一种最简单和最广为人知的加密技术。它是一种替换密码，其中每个字母在明文中被移动了一定数目的位置。例如，当偏移量是3的时候，所有的字母都将向前移动三个位置，因此 ‘A’ 变成了 ‘D’，’B’ 变成了 ‘E’，以此类推。这种密码得名于朱利叶斯·凯撒（Julius Caesar），他用它来保护重要的军事信息。 工作原理 加密过程：在凯撒密码中，字母表中的每个字母都被向右或向左移动一定的固定数目。例如，如果我们选择向右移动3个位置，那么’A’就变成了’D’，’B’变成了’E’，依此类推。 解密过程：解密是加密过程的逆过程。如果我们知道了位移的数目，我们可以通过反方向移动同样数目的位置来还原原文。 示例 假设我们有一个明文 “HELLO”，我们使用向右位移3的凯撒密码加密： ‘H’ -&gt; ‘K’ ‘E’ -&gt; ‘H’ ‘L’ -&gt; ‘O’ ‘L’ -&gt; ‘O’ ‘O’ -&gt; ‘R’ 因此，加密后的密文是 “KHOOR”。 Python实现 以下是凯撒密码的一个简单Python实现： 12345678910111213141516171819202122232425def caesar_cipher(text, shift): result = &quot;&quot; for i in range(len(text)): char = text[i] # 加密大写字母 if char.isupper(): result += chr((ord(char) + shift - 65) % 26 + 65) # 加密小写字母 elif char.islower(): result += chr((ord(char) + shift - 97) % 26 + 97) else: result += char return result# 测试加密text = &quot;HELLO&quot;shift = 3print(&quot;Plain Text : &quot; + text)print(&quot;Shift pattern : &quot; + str(shift))print(&quot;Cipher: &quot; + caesar_cipher(text, shift)) 安全性 凯撒密码是一种非常基础的加密方法，由于其算法简单且容易破解（特别是在现代计算技术的帮助下），因此它不适合用于保护重要的信息。凯撒密码的主要用途在于教育和娱乐。在实际的安全应用中，需要使用更为复杂和安全的加密算法。 单向加密概念单向加密，也被称为哈希（Hashing），是一种加密过程，其中明文数据被转换成固定长度的唯一散列值，但这个过程是不可逆的。这意味着从散列值无法还原回原始数据。单向加密常用于存储密码、验证数据完整性和安全性。 常见方法两种常见的单向加密算法是MD5（Message-Digest Algorithm）和SHA（Secure Hash Algorithm）。 MD5： MD5生成的散列值长度为128位（即16字节）。 通常以32个十六进制字符表示（因为每4位二进制可以表示为1位十六进制，所以128位二进制等于32位十六进制）。 SHA： SHA家族包括多种算法，如SHA-1、SHA-256、SHA-512等，其中SHA-256生成的散列值长度为256位。 SHA-256的结果通常表示为64个十六进制字符。 更新哈希值： update() 方法用于向哈希对象添加数据。如果同一个哈希对象被多次调用 update()，则新增的数据会被附加到原有数据后面，最终的哈希值是所有数据的总和。 MD5加密12345from hashlib import md5md5_obj = md5() # 创建MD5算法加密对象md5_obj.update(&quot;加密数据&quot;.encode()) # 添加要加密的数据print(md5_obj.hexdigest()) # 获取十六进制表示的散列值 SHA加密12345from hashlib import sha256sha256_obj = sha256() # 创建SHA-256算法加密对象sha256_obj.update(&quot;加密数据&quot;.encode()) # 添加要加密的数据print(sha256_obj.hexdigest()) # 获取十六进制表示的散列值 安全性： MD5和SHA-1由于存在安全漏洞，不再推荐用于安全敏感的场合。 SHA-256是更安全的选择，广泛用于加密货币、SSL证书等。 用途： 单向加密主要用于密码存储、数据完整性校验和数字签名等。 不可逆性： 哈希函数的一个关键特性是它们是单向的，无法逆转。这意味着无法从散列值推算出原始输入。 对称加密概念与简介概念: 对称加密是一种加密方法，其中加密和解密使用相同的密钥。 简介: 对称加密算法通常速度较快，适合加密大量数据。常用的对称加密算法包括 DES（Data Encryption Standard）、3DES（Triple DES）和 AES（Advanced Encryption Standard）。 **DES (Data Encryption Standard)**：是最初的对称加密标准，使用56位密钥。尽管存在8位校验位，但实际上只用到了56位。DES由于密钥长度较短，容易受到暴力破解攻击。 **3DES (Triple DES)**：是DES的改进版本，通过使用三重DES加密过程提高安全性。它使用两个或三个密钥，有效长度为112或168位。 AES 是一种更现代的对称加密标准，提供多种密钥长度（128、192和256位）。被认为是DES的继任者，提供了更高的安全性和更好的性能。AES在现代加密应用中非常普遍。 特点： 相同密钥：加密和解密使用相同的密钥，因此密钥的保密性极为重要。 密钥长度：一般较短，通常小于256位。密钥越长，安全性越高，但性能可能受影响。 对称加密的应用：对称加密算法通常用于加密大量数据，如文件加密、数据库加密等。 DES概念DES是一种经典的对称加密算法，尽管由于其较短的密钥长度（56位有效长度），在现代计算能力下已不再安全。 DES加密原理DES的加密过程包括初始置换、16轮迭代运算和逆初始置换。每轮迭代运算包括扩展置换、S盒置换和P盒置换，以及与子密钥的混合。初始置换（Initial Permutation, IP）和逆初始置换（Final Permutation, FP）是DES加密过程中的第一步和最后一步，它们是固定的非加密置换。 初始置换：打乱明文数据的顺序。 16轮迭代运算：每轮使用不同的密钥进行加密。 逆初始置换：恢复数据到最终加密状态。 初始IP置换表 58 50 12 34 26 18 10 2 60 52 44 36 28 20 12 4 62 54 46 38 30 22 14 6 64 56 48 40 32 24 16 8 57 49 41 33 25 17 9 1 59 51 43 35 27 19 11 3 61 53 45 37 29 21 13 5 63 55 47 39 31 23 15 7 逆置置换表 40 8 48 16 56 24 64 32 39 7 47 15 55 23 63 31 38 6 46 14 54 22 62 30 37 5 45 13 53 21 61 29 36 4 44 12 52 20 60 28 35 3 43 11 51 19 59 27 34 2 42 10 50 18 58 26 33 1 41 9 49 17 57 25 Python实现DES加密使用Python进行DES加密需要安装pycryptodomex或pycryptodome库。 123456789101112from Cryptodome.Cipher import DESkey = b&#x27;1234abcd&#x27; # 8字节密钥des = DES.new(key, DES.MODE_ECB) # 创建DES加密对象，ECB模式content = &quot;加密内容&quot; # 确保内容长度是8的倍数padding = (8 - len(content) % 8) * &quot;-&quot;en_data = content + paddingen_data = des.encrypt(en_data.encode()) # 加密print(en_data)de_data = des.decrypt(en_data) # 解密print(de_data.decode()) 密钥管理：对称加密的一个挑战是密钥的安全传输和管理，因为密钥必须在通信双方之间共享。 加密模式：除了ECB（Electronic Codebook）模式，还有其他几种模式，如CBC（Cipher Block Chaining）和CFB（Cipher Feedback），每种模式有其特点和用途。 安全性考量：随着计算能力的提高，DES由于其较短的密钥长度而变得不够安全，AES由于其更长的密钥和更高效的算法成为更好的选择。 3DES概念3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次DES加密算法。 由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解。3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。 3DES加密原理3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），加密算法，其具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，M代表明文， 加密过程：C = Ek3(Dk2(Ek1(M))) 其中，Ek() 表示用密钥 k 进行DES加密，Dk() 表示用密钥 k 进行DES解密。 M 代表明文，C 代表密文。 k1、k2 和 k3 是三个不同的密钥。 解密过程：M = Dk1(Ek2(Dk3(C))) 解密过程是加密过程的逆过程。 Python实现3DES加密实际上，3DES有几种不同的实现方式，包括使用三个不同密钥的3-key模式（最安全，但也最慢），以及使用两个不同密钥的2-key模式。 123456789101112from Cryptodome.Cipher import DES3key = b&#x27;12345678abcdefgh&#x27; # 16字节密钥用于2-key模式，24字节密钥用于3-key模式des = DES3.new(key, DES3.MODE_ECB) # 创建3DES加密对象，ECB模式content = &quot;加密内容&quot; # 确保内容长度是8的倍数padding = (8 - len(content) % 8) * &quot;-&quot;en_data = content + paddingen_data = des.encrypt(en_data.encode()) # 加密print(en_data)de_data = des.decrypt(en_data) # 解密print(de_data.decode()) 性能：由于3DES使用了三次DES加密过程，它在相同硬件上比单次DES加密慢三倍左右。 安全性：虽然3DES比原始的DES更安全，但它的速度和效率不及更现代的算法，如AES。 用途：3DES通常用于需要与旧系统兼容的场景，但新的系统和应用更倾向于使用AES。 AES概念AES（Advanced Encryption Standard），又称Rijndael加密法，是一种区块加密标准，用于替代原来的DES。AES是美国国家标准技术研究所（NIST）于2001年采纳的加密标准，并被广泛使用。 加密过程 分组密码：AES将明文分为固定大小的数据块进行加密，每个数据块的大小为128位，即16个字节。 密钥长度：AES支持三种长度的密钥：128位、192位和256位。不同的密钥长度会影响加密的轮数。 加密轮数 ：根据密钥长度的不同，AES有不同的加密轮数： AES-128：10轮 AES-192：12轮 AES-256：14轮 每轮加密操作：每一轮包括若干步骤，如字节代换、行移位、列混淆和轮密钥加。 AES 密钥长度（32位比特字) 分组长度(32位比特字) 加密轮数 AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 Python实现AES加密在Python中使用AES加密时，可以选择不同的加密模式，如CBC（Cipher Block Chaining）模式。CBC模式需要一个初始化向量（IV）来提高安全性。 12345678910111213141516171819from Cryptodome.Cipher import AESkey = b&#x27;abcdefghijklnmop&#x27; # 16字节密钥iv = b&#x27;1234567890abcdef&#x27; # 初始化向量# 创建AES加密器实例aes = AES.new(key, AES.MODE_CBC, iv)content = &quot;我爱你&quot;b_content = content.encode()# 补足到16的倍数bytes_content = content + (16 - len(b_content) % 16) * &quot;*&quot;en_data = aes.encrypt(bytes_content.encode())print(en_data) # 加密后的数据# 解密aes_decrypt = AES.new(key, AES.MODE_CBC, iv)de_data = aes_decrypt.decrypt(en_data)print(de_data.decode().rstrip(&#x27;*&#x27;)) # 解密后的数据，去除填充的&#x27;*&#x27; 非对称加密概念与简介非对称加密是一种加密方法，其中使用一对密钥：一个公钥和一个私钥。公钥用于加密数据，而私钥用于解密。这种方法的关键优势在于，公钥可以公开共享，而私钥则保持私密，从而确保了信息的安全传输。 主要特点 安全性：非对称加密提供了高度的安全性，因为即使公钥是公开的，没有相应的私钥也无法解密信息。 密钥传输：不需要安全地传输密钥，因为公钥可以公开。 效率：相较于对称加密，非对称加密过程速度较慢，尤其是在处理大量数据时。 使用场景 常用于加密少量重要数据，如加密会话密钥。 广泛应用于数字签名和身份验证。 RSA加密算法数论基础素数 (Prime Numbers)素数，也称为质数，指的是一个大于1的自然数，它除了1和其自身外，不能被其他自然数整除。 模运算 (Modulo Operation)模运算，即求余运算，在数学中通常用”mod”表示。它与”同余”的概念密切相关。如果两个整数除以同一个正整数得到相同的余数，那么这两个整数是同余的。 例如，若两个整数$a$和$b$，除以正整数$m$得到的余数相等，则$a \\equiv b \\ (\\text{mod} \\ m)$，即$a$同余于$b$模$m$。如：$26 \\equiv 14 \\ (\\text{mod} \\ 12)$。 互质关系（Coprime）互质关系是指两个正整数$a$和$b$之间的关系，它们除了1以外没有其他共同的正因子。互质关系表示为$\\text{gcd}(a, b) &#x3D; 1$，其中$\\text{gcd}(a, b)$表示$a$和$b$的最大公因子。 性质和应用： 任意两个质数互质。 如果一个数是质数，另一个数不是它的倍数，它们互质。 如果两数中较大的那个是质数，则它们互质。 1和任意自然数互质。 对于大于1的整数$p$，$p$和$p-1$互质。 对于大于1的奇数$p$，$p$和$p-2$互质。 欧拉函数 (Euler’s Totient Function)欧拉函数，记作$\\phi(n)$，是一个数论中的重要函数。它的定义是：对于任意正整数$n$，欧拉函数$\\phi(n)$表示在$1$到$n$之间与$n$互质的正整数的数量。 定义 对于正整数$n$，欧拉函数$\\phi(n)$被定义为： $$ \\phi(n) &#x3D; \\text{数量}{k \\in \\mathbb{N} : 1 \\leq k \\leq n, \\text{gcd}(k, n) &#x3D; 1} $$ 这里，$\\text{gcd}(k, n)$表示$k$和$n$的最大公因数。 性质 对于质数$p$: 因为一个质数除了自身和 $1$ 以外，没有其他因子。因此，除了自身之外，所有小于 $p$ 的正整数都与 $p$ 互质。 $$ \\phi(p) &#x3D; p - 1 $$ 推导 ​ 对于质数 $p$，它没有除 $1$ 和自身以外的因子。 ​ 因此，$1, 2, …, p-1$ 都是与 $p$ 互质的。 ​ 这意味着与 $p$ 互质的正整数的数量是 $p-1$。 两个不同质数的乘积: 当 $n$ 是两个不同质数 $p$ 和 $q$ 的乘积时，欧拉函数的计算变得稍微复杂一点 $$ \\phi(pq) &#x3D; (p - 1)(q - 1) $$ 推导 ​ 首先，由于 $p$ 和 $q$ 是质数，所以除了 $1$ 和它们自身外，它们没有其他因子。 ​ 任何小于 $pq$ 且不是 $p$ 或 $q$ 的倍数的数都与 $pq$ 互质。 ​ 在 $1$ 到 $pq$ 的数中，有 $q$ 个数是 $p$ 的倍数，有 $p$ 个数是 $q$ 的倍数，但 $pq$ 被算了两次。 ​ 因此，与 $pq$ 互质的数的数量是 $pq - p - q + 1$。 - 这可以重写为 $(p - 1)(q - 1)$。 对于质数$p$的幂$p^n$: 当 $n$ 是质数 $p$ 的幂，即 $n &#x3D; p^k$（其中 $k &gt; 1$）时，欧拉函数的计算方式如下： $$ \\phi(p^k) &#x3D; p^k - p^{k-1} $$ 推导 ​ 在 $1$ 到 $p^k$ 的数中，与 $p^k$ 不互质的数是 $p$ 的倍数。 ​ 这些数是 $p, 2p, 3p, \\ldots, p^{k-1}p$，总共有 $p^{k-1}$ 个。 ​ 因此，与 $p^k$ 互质的数的数量是 $p^k - p^{k-1}$。 示例 计算 $\\phi(10)$: 由于 $10 &#x3D; 2 \\times 5$，且 $2$ 和 $5$ 是质数，$\\phi(10) &#x3D; (2-1)(5-1) &#x3D; 4$。 与 $10$ 互质的数有 $1, 3, 7, 9$。 应用 欧拉函数在密码学和数论中有着重要的应用，例如在RSA加密算法中，它被用来选择密钥。 模反元素&#x2F;模逆元（Modular Multiplicative Inverse）模反元素是数论和代数中的一个重要概念。当两个正整数$a$和$n$互质时（即它们的最大公因数为$1$），$a$在模$n$下的模反元素是指一个整数$b$，使得$a$乘以$b$在模$n$下的结果等于$1$。 定义 对于给定的正整数$a$和$n$，如果存在整数$b$满足以下等式，则$b$是$a$的模反元素： $$ ab \\equiv 1 \\pmod{n} $$ 这里的$\\equiv$表示同余，而$\\pmod{n}$表示对$n$取模。 计算方法 要找到$a$在模$n$下的模反元素$b$，可以使用扩展欧几里得算法或费马小定理（如果$n$是质数）。 示例 假设$a &#x3D; 3$和$n &#x3D; 11$，那么$3$和$11$互质。 要找到一个数$b$，使得$3b \\equiv 1 \\pmod{11}$。 在这个例子中，$b &#x3D; 4$是$3$的模反元素，因为$3 \\cdot 4 &#x3D; 12$，且$12 \\equiv 1 \\pmod{11}$。 应用 模反元素在密码学中非常重要，尤其是在公钥加密和数字签名算法中。 它也用于计算机科学中的某些算法，如模算术和散列函数。 概念RSA是一种广泛使用的非对称加密算法，由Rivest、Shamir和Adleman三位数学家提出。RSA的安全性基于大数分解的难题。在RSA中，加密密钥（公钥）是公开的，而解密密钥（私钥）则必须保密。由于RSA计算量大，通常用于加密小量数据或加密对称加密的密钥。常见的做法是使用RSA加密对称密钥，然后用该对称密钥进行实际数据的加密和解密，这样结合了两者的优点：RSA的安全性和对称加密的效率。 RSA加密原理RSA加密的基本步骤可以分为三个阶段：密钥生成、加密和解密。 密钥生成过程 选择两个大的质数 $p$ 和 $q$。这些质数需要足够大，以确保加密的安全性。 计算它们的乘积 $n &#x3D; p \\times q$。这个乘积 $n$ 用于公钥和私钥，且其长度决定了密钥长度。 计算欧拉函数 $\\phi(n) &#x3D; (p-1)(q-1)$。这是公钥和私钥生成的关键部分。 选择一个公钥指数 $e$。$e$ 是一个小于 $\\phi(n)$ 的正整数，并且 $e$ 和 $\\phi(n)$ 互质。常见的选择是 $e &#x3D; 65537$，但确保 $e &lt; \\phi(n)$。 计算私钥 $d$。$d$ 是 $e$ 相对于 $\\phi(n)$ 的模逆元，即找到一个整数 $d$ 使得 $ed \\equiv 1 \\mod \\phi(n)$。这可以通过扩展欧几里得算法来实现。 信息 扩展欧几里得算法及其在RSA加密中的应用 扩展欧几里得算法是一种用于求解两个整数 a 和 b 的最大公因数（GCD）的同时，找到整数 x 和 y 使得 ax + by = gcd(a, b) 的算法。 算法描述 基本思想: 扩展欧几里得算法基于欧几里得算法的原理，通过反复应用除法原理，直到余数为0。 在每一步中，算法维护着等式 ax + by = gcd(a, b) 的一个解。 算法步骤: 如果 b = 0，则 gcd(a, b) = a，且 x = 1, y = 0。 否则，递归调用扩展欧几里得算法：gcd(b, a % b)。 通过回溯的方式，计算出 x 和 y 的值。 在RSA加密中的应用 在RSA加密中，扩展欧几里得算法用于计算私钥 d，这是公钥指数 e 的模逆元相对于 φ(n)。 公钥和私钥的生成: 已知公钥指数 e 和 φ(n)（其中 n = pq 是两个质数 p 和 q 的乘积）。 需要找到一个整数 d 使得 ed ≡ 1 (mod φ(n))。 这意味着需要找到 x 和 y 使得 ex + φ(n)y = 1。 使用扩展欧几里得算法: 应用扩展欧几里得算法于 e 和 φ(n)。 算法将产生 x 和 y，其中 x 就是所求的 d。 即使 x 是负数，也可以通过加上 φ(n) 来得到正的模逆元。 示例 假设 e = 17 和 φ(n) = 3120，使用扩展欧几里得算法找到 d，使得 17d ≡ 1 (mod 3120)。算法将返回 d 的值，这是私钥的一部分。 这种方法确保了RSA加密算法中私钥的生成既安全又有效率。 加密过程加密过程是将明文消息 $M$ 转换成密文 $C$。这通过以下公式完成： $$ C &#x3D; M^e \\mod n $$ 使用公钥 $(n, e)$ 对明文 $M$ 进行加密。 解密过程解密过程是将密文 $C$ 还原回原始明文 $M$。这通过以下公式完成： $$ M &#x3D; C^d \\mod n $$ 使用私钥 $(n, d)$，可以将密文 $C$ 解密回明文 $M$。 信息 在RSA加密算法中，公钥指数 e 的选择对于加密的效率和安全性都至关重要。e &#x3D; 65537 是一个广泛使用的值，其原因如下： 安全性: e 应该是一个与 $\\phi(n)$ 互质的大质数。65537 是一个质数，且大多数情况下不会与 $\\phi(n)$ 有共同因子。 效率: 65537 在二进制表示中只有两个 1（即 10000000000000001）。这使得进行模幂运算（用于加密和解密）时更加高效。较少的 1 位意味着需要更少的乘法操作。 历史原因: 在RSA的早期，较小的值如 3 和 17 也被作为公钥指数使用。然而，随着对RSA安全性的更深入理解，这些较小的值被认为在某些情况下不够安全。65537 提供了良好的安全性，同时保持了计算效率。 平衡性: 65537 是一个在保持计算效率和确保足够安全性之间的良好平衡。它足够大，可以避免某些已知的攻击方法，同时又不会像更大的数那样使计算量过大。 总结来说，e &#x3D; 65537 是RSA加密中的一个标准选择，因为它在安全性和计算效率之间提供了一个很好的平衡点。 RSA加密算法的安全性RSA加密算法的安全性主要基于大数分解的难度。当选择的两个大素数p和q足够大时，它们的乘积n = p * q难以分解，这是RSA算法的核心安全基础。 大素数分解难题：目前，没有已知的高效算法可以在合理时间内分解非常大的数。这个数学难题是RSA安全性的基石。 RSA加密算法的缺点尽管RSA加密算法被广泛使用，但它确实有一些缺点： 密钥生成困难：生成大素数需要特定的算法和足够的计算资源。在某些环境下，这可能是一个限制。 计算效率低：由于涉及大数运算，RSA加密和解密过程相对较慢，尤其是当使用较长的密钥时。 理论安全性未证明：尽管大数分解被认为是困难的，但尚无理论证明表明破解RSA加密的难度与大数分解的难度等价。 12345678910111213141516171819202122232425from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPimport binascii# 生成密钥对key = RSA.generate(2048)private_key = key.export_key()public_key = key.publickey().export_key()# 明文message = &quot;Hello RSA!&quot;# 使用公钥加密public_key = RSA.import_key(public_key)cipher = PKCS1_OAEP.new(public_key)encrypted_message = cipher.encrypt(message.encode())# 使用私钥解密private_key = RSA.import_key(private_key)cipher = PKCS1_OAEP.new(private_key)decrypted_message = cipher.decrypt(encrypted_message)print(&quot;Original Message:&quot;, message)print(&quot;Encrypted Message:&quot;, binascii.hexlify(encrypted_message))print(&quot;Decrypted Message:&quot;, decrypted_message.decode())","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"编码","slug":"编码","permalink":"https://www.yiuhangblog.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"加解密","slug":"加解密","permalink":"https://www.yiuhangblog.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"}],"author":"Yiuhang Chan"},{"title":"分布式爬取","slug":"20211218分布式爬取","date":"2021-12-18T00:24:32.000Z","updated":"2024-02-28T10:50:38.000Z","comments":true,"path":"2021/12/18/20211218分布式爬取/","permalink":"https://www.yiuhangblog.com/2021/12/18/20211218%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E5%8F%96/","excerpt":"Scrapy结合Redis进行分布式爬取","text":"分布式概念和作用分布式系统（Distributed Systems）概念分布式系统是由一组相互独立的计算机通过网络进行通信和协调工作的系统。每台计算机（通常称为“节点” Node）都有自己的内存和处理能力，它们共同协作以完成特定的任务或管理共享数据。 作用与特点 可扩展性（Scalability）: 分布式系统可以通过增加更多的节点来提高性能和容量，而不是依赖单个更强大的机器。 容错性（Fault Tolerance）: 由于系统分布在多个节点上，即使部分节点失败，整个系统仍然可以继续运行。 资源共享（Resource Sharing）: 分布式系统允许不同地理位置的节点共享资源，如文件、数据或设备。 灵活性（Flexibility）: 可以根据需要在不同的节点上部署不同的服务和应用。 并行处理（Parallel Processing）: 多个节点可以同时处理任务，提高处理速度。 应用场景 云计算（Cloud Computing） 大数据处理（Big Data Processing） 在线事务处理（Online Transaction Processing, OLTP） 分布式文件系统（Distributed File Systems） 分布式系统与网络爬虫的结合 网络爬虫（Web Crawler）概念网络爬虫，也称为网络蜘蛛（Web Spider）或网络机器人（Web Bot），是一种自动访问互联网并从网页中提取信息的程序。 结合分布式系统的优势 提高爬取效率: 通过多个节点并行爬取，可以显著提高数据收集的速度。 抗干扰能力强: 单点爬虫易被封禁，而分布式爬虫由于请求来自不同IP，更难被识别和封禁。 数据冗余与备份: 在多个节点上存储数据，增加数据安全性。 负载均衡（Load Balancing）: 自动分配任务到不同节点，避免单个节点过载。 应用实例 搜索引擎（如Google, Bing）使用分布式爬虫来索引网页。 数据挖掘和市场分析，通过分布式爬虫收集大量数据进行分析。 社交媒体分析，如通过爬取Twitter或Facebook的公开数据进行情感分析或趋势预测。 技术实现 消息队列（Message Queue）: 如RabbitMQ、Kafka，用于在不同节点间分配任务。 分布式存储（Distributed Storage）: 如Hadoop HDFS，用于存储爬取的数据。 负载均衡器（Load Balancer）: 均衡请求分配。 分布式数据库（Distributed Database）: 如Cassandra或MongoDB，用于高效存储和检索数据。 将分布式系统的概念应用于网络爬虫，可以极大地提高爬虫的效率和效能，同时降低被封禁的风险。这种结合在数据密集型应用，如搜索引擎和大数据分析中尤为重要。 Scrapy-Redis概念Scrapy-Redis是一个基于Redis的Scrapy扩展，用于支持Scrapy项目的分布式爬取和数据处理。 特点 分布式爬取: 通过共享Redis中的请求队列，支持多个Scrapy爬虫实例的协作，适合多域名、大规模网页的爬取。 分布式数据处理: 爬取到的数据（Items）被推送至Redis中，允许部署多个数据处理节点。 兼容性强: 可以轻松集成至现有的Scrapy项目中，不需大量修改原有代码。 应用架构 Scrapy爬虫节点: 多个Scrapy实例并行工作，共享任务队列。 Redis服务器: 作为中心节点，管理请求队列和数据存储。 数据处理节点: 可以是Scrapy管道（Pipelines）或其他数据处理应用。 Redis的安装与使用在Ubuntu&#x2F;Debian上安装Redis在Linux系统上安装Redis的过程可以通过不同的方法进行，包括使用包管理器或Snapcraft。 先决条件（Prerequisites）对于运行极简发行版的系统（例如Docker容器），可能需要首先安装lsb-release、curl和gpg： sudo apt install lsb-release curl gpg 添加仓库（Repository）将Redis的官方APT仓库添加到系统的apt索引中，然后进行更新： 导入GPG密钥（Import GPG Key）: curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg 添加Redis存储库（Add Redis Repository）: echo &quot;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main&quot; | sudo tee /etc/apt/sources.list.d/redis.list 更新系统包列表（Update Package List）: sudo apt-get update 安装Redis（Install Redis）: sudo apt-get install redis 信息 如果找不到Redis路径可以先查看redis进程号, 查看命令: ps -ef | grep redis 拿到上面进程号####然后查询ll -l /proc/####/cwd即可 Redis 基本信息和操作基本信息Redis（Remote Dictionary Server）是一个开源的、支持网络、基于内存且可选持久化的键值对存储数据库。它通常被用作数据库、缓存或消息传递系统。它提供了丰富的数据结构，如字符串（strings）、哈希表（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）以及位图（bitmaps）等。 配置信息 默认端口: 6379。 数据库数量: 默认支持16个，编号从0到15。 redis命令 redis执行了make install后，redis的课执行文件都会自动复制到 &#x2F;usr&#x2F;local&#x2F;bin 目录 redis-server redis服务器 redis-cli redis命令行客户端 redis-benchmark redis性能测试工具 redis-check-aof aof文件修复工具 redis-check-dump rdb文件检查工具 redis-cli shutdown 停止 redis redis-server 启动 redis-server redis-server /etc/redis/redis.conf 带配置文件启动 数据类型 字符串（String）：这是 Redis 最基本的数据类型，它可以存储任何形式的字符串，包括文本、数字甚至二进制数据。字符串类型常用于缓存用户信息、会话数据等。 哈希（Hash）：哈希是键值对的集合，类似于编程语言中的字典或哈希表。它适用于存储对象，每个对象可以包含多对字段和值。例如，可以用哈希存储用户的各种属性，如姓名、年龄、邮箱等。 列表（List）：列表是一系列有序的字符串，类似于数组。Redis 列表是双向链表，因此在列表的头部或尾部添加或删除元素非常快速。它适用于实现队列、栈或其他有序集合。 集合（Set）：集合是一组不重复的字符串元素。由于集合中的元素是无序的，可以快速执行添加、删除和检查元素是否存在等操作。集合适用于存储无序的唯一元素，例如标签、好友关系等。 有序集合（Sorted Set）：有序集合和普通集合类似，但每个元素都会关联一个浮点数分数，这使得元素能按分数有序排列。有序集合适用于需要按某种顺序访问元素的场景，如排行榜。 位图（Bitmap）：位图本质上是字符串类型的一种特殊用法，它允许对字符串的位进行操作。位图适用于处理大量的布尔值，如用户在线状态、特征标志等。 超级日志（HyperLogLog）：超级日志是一种用于高效统计唯一元素个数（如独立访客数）的概率数据结构。它可以使用极小的内存空间来处理大量数据。 基本操作字符串（String）操作Redis 的字符串（String）是最基本的数据类型之一，它支持多种操作，涵盖了对单个或多个字符串值的处理。 设置值: SET key value: 设置指定键的值。 SETEX key seconds value: 设置键的值，并设置过期时间（以秒为单位）。 SETNX key value: 仅当键不存在时，设置键的值。 MSET key1 value1 [key2 value2 ...]: 同时设置一个或多个键值对。 获取值: GET key&#96;: 获取指定键的值。 MGET key1 [key2 ...]: 获取一个或多个键的值。 GETSET key value: 设置指定键的值，并返回键的旧值。 操作数值: INCR key: 将键的整数值增加一。 DECR key: 将键的整数值减少一。 INCRBY key increment: 将键的整数值增加指定的量。 DECRBY key decrement: 将键的整数值减少指定的量。 INCRBYFLOAT key increment: 将键的浮点数值增加指定的量。 处理子字符串: GETRANGE key start end: 获取键值的子串。 SETRANGE key offset value: 从指定的偏移量开始替换键的值。 键值长度和追加: STRLEN key: 获取指定键值的长度。 APPEND key value: 将值追加到指定键的现有值的末尾。 位操作: SETBIT key offset value: 对键值的二进制表示的指定偏移量的位进行设置。 GETBIT key offset: 获取键值的二进制表示中指定偏移量的位值。 BITCOUNT key [start end]: 计算字符串被设置为1的位数。 BITOP operation destkey key1 [key2 ...]: 对一个或多个键执行位操作，并将结果存储在目标键中。 过期和持久化: EXPIRE key seconds: 设置键的过期时间（秒）。 PERSIST key: 移除键的过期时间，使其成为持久的键。 哈希表（Hash）操作Redis 的哈希（Hash）是一种键值对集合的数据类型，非常适合用来存储对象。哈希表中的每个字段都是唯一的，并且它们映射到特定的值。 添加和设置字段: HSET key field value: 设置哈希表字段的值。 HMSET key field1 value1 [field2 value2 ...]: 同时设置哈希表的多个字段。 HSETNX key field value: 仅当字段不存在时，设置哈希表字段的值。 获取字段值: HGET key field: 获取存储在哈希表中的字段的值。 HMGET key field1 [field2 ...]: 获取所有给定字段的值。 HGETALL key: 获取在哈希表中指定键的所有字段和值。 HVALS key: 获取哈希表中所有字段的值。 删除字段: HDEL key field1 [field2 ...]: 删除一个或多个哈希表字段。 字段计数: HLEN key: 获取哈希表中字段的数量。 检查字段存在: HEXISTS key field: 查看哈希表的指定字段是否存在。 增减数值字段: HINCRBY key field increment: 为哈希表 key 中的指定字段的整数值加上增量 increment。 HINCRBYFLOAT key field increment: 为哈希表 key 中的指定字段的浮点数值加上增量 increment。 获取所有字段名: HKEYS key: 获取哈希表中的所有字段。 扫描哈希表: HSCAN key cursor [MATCH pattern] [COUNT count]: 迭代哈希表中的键值对。 获取字段值的长度: HSTRLEN key field: 获取存储在哈希表中的字段值的长度。 列表（List）操作Redis 的列表（List）是一种线性数据结构，主要用于存储有序的字符串元素集合。Redis 列表是基于双向链表实现的，这意味着即使在很长的列表上，向列表的头部或尾部添加和移除元素仍然非常快速。 添加元素: LPUSH key value1 [value2 ...]: 将一个或多个值插入到列表头部。 RPUSH key value1 [value2 ...]: 将一个或多个值插入到列表尾部。 移除元素: LPOP key: 移除并返回列表头部的元素。 RPOP key: 移除并返回列表尾部的元素。 LREM key count value: 根据参数 count 的值，移除列表中与参数 value 相等的元素。 列表长度: LLEN key: 获取列表长度。 获取列表元素: LRANGE key start stop: 获取列表指定范围内的元素。 LINDEX key index: 获取列表中指定索引的元素。 修改列表元素: LSET key index value: 将列表中指定索引的元素的值设置为另一个值。 插入元素: LINSERT key BEFORE|AFTER pivot value: 在列表的元素前或后插入元素。 截取列表: LTRIM key start stop: 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 阻塞操作: BLPOP key1 [key2 ...] timeout: 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOP key1 [key2 ...] timeout: 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH source destination timeout: 从列表中弹出一个值，将它推入另一个列表并返回它；如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 转移元素: RPOPLPUSH source destination: 移除列表的最后一个元素，将该元素添加到另一个列表并返回。 集合（Set）操作Redis 的集合（Set）是一种存储唯一元素且无序的字符串集合。集合非常适合用于存储不重复的数据，如标签、好友关系等。 添加元素: SADD key member1 [member2 ...]: 向集合添加一个或多个成员。 移除元素: SREM key member1 [member2 ...]: 移除集合中一个或多个成员。 集合大小: SCARD key: 获取集合的成员数。 检查成员存在: SISMEMBER key member: 判断成员元素是否是集合的成员。 获取所有成员: SMEMBERS key: 获取集合中的所有成员。 随机元素: SRANDMEMBER key [count]: 返回集合中一个或多个随机数。 SPOP key [count]: 移除并返回集合中的一个随机元素。 集合运算: SUNION key1 [key2 ...]: 返回所有给定集合的并集。 SINTER key1 [key2 ...]: 返回所有给定集合的交集。 SDIFF key1 [key2 ...]: 返回第一个集合与其他集合之间的差集。 集合运算并存储结果: SUNIONSTORE destination key1 [key2 ...]: 计算所有给定集合的并集，并存储在 destination 集合中。 SINTERSTORE destination key1 [key2 ...]: 计算所有给定集合的交集，并存储在 destination 集合中。 SDIFFSTORE destination key1 [key2 ...]: 计算第一个集合与其他集合的差集，并存储在 destination 集合中。 集合的遍历: SSCAN key cursor [MATCH pattern] [COUNT count]: 迭代集合中的元素。 移动成员到另一个集合: SMOVE source destination member: 将成员从一个集合移动到另一个集合。 有序集合（Sorted Set）操作Redis 的有序集合（Sorted Set）是一种集合数据类型，它不仅存储成员（Member），还为每个成员关联了一个浮点数分数（Score）。这使得成员能够按照分数的大小排序，从而支持快速的插入、删除、查找和排名操作。 添加和更新成员: ZADD key score1 member1 [score2 member2 ...]: 向有序集合添加一个或多个成员，或更新已存在成员的分数。 移除成员: ZREM key member1 [member2 ...]: 移除有序集合中的一个或多个成员。 获取成员数量: ZCARD key: 获取有序集合的成员数量。 获取成员分数: ZSCORE key member: 获取有序集合中成员的分数。 增加成员分数: ZINCRBY key increment member: 增加有序集合中成员的分数。 范围查询: ZRANGE key start stop [WITHSCORES]: 返回有序集合中指定区间内的成员。 ZREVRANGE key start stop [WITHSCORES]: 返回有序集合中指定区间内的成员，按分数从高到低排序。 ZRANGEBYSCORE key min max [WITHSCORES]: 根据分数值获取有序集合中的成员。 移除指定排名或分数范围内的成员: ZREMRANGEBYRANK key start stop: 移除有序集合中指定排名（index）区间内的所有成员。 ZREMRANGEBYSCORE key min max: 移除有序集合中分数在给定区间内的成员。 获取成员排名: ZRANK key member: 获取有序集合中成员的排名（按分数值递增）。 ZREVRANK key member: 获取有序集合中成员的排名（按分数值递减）。 有序集合间的运算: ZUNIONSTORE destination numkeys key1 [key2 ...] [WEIGHTS weight1 [weight2 ...]]: 计算多个有序集合的并集，并存储在新的有序集合中。 ZINTERSTORE destination numkeys key1 [key2 ...] [WEIGHTS weight1 [weight2 ...]]: 计算多个有序集合的交集，并存储在新的有序集合中。 遍历有序集合: ZSCAN key cursor [MATCH pattern] [COUNT count]: 迭代有序集合中的元素。 键（Key）管理Redis 提供了一系列命令用于管理和操作键（Key），这些命令允许你对存储在 Redis 中的数据进行各种操作，包括但不限于查询、移动、重命名和设置键的生命周期。 键存在性检查: EXISTS key1 [key2 ...]: 检查一个或多个键是否存在。 删除键: DEL key1 [key2 ...]: 删除一个或多个键。 设置键的过期时间: EXPIRE key seconds: 设置键的过期时间（秒）。 PEXPIRE key milliseconds: 设置键的过期时间（毫秒）。 EXPIREAT key timestamp: 设置键的过期时间为 UNIX 时间戳（秒）。 PEXPIREAT key milliseconds-timestamp: 设置键的过期时间为 UNIX 时间戳（毫秒）。 查询键的剩余生存时间: TTL key: 查询键的剩余生存时间（秒）。 PTTL key: 查询键的剩余生存时间（毫秒）。 移除键的过期时间: PERSIST key: 移除键的过期时间。 查找符合给定模式的键: KEYS pattern: 查找所有符合给定模式的键。 SCAN cursor [MATCH pattern] [COUNT count]: 迭代数据库中的数据库键。 重命名键: RENAME key newkey: 修改键名。 RENAMENX key newkey: 仅当 newkey 不存在时，将 key 改名为 newkey。 随机返回一个键: RANDOMKEY: 从数据库中随机返回一个键。 键类型查询: TYPE key: 返回键所储存的值的类型。 移动键到另一个数据库: MOVE key db: 将当前数据库的键移动到指定的数据库 db 当中。 键的字节串长度查询: STRLEN key: 获取指定键所储存的字符串值的长度。 原子操作: DUMP key: 返回存储在指定键的值的序列化版本。 RESTORE key ttl serialized-value [REPLACE]: 通过序列化值创建一个键，ttl 为存活时间，REPLACE 表示是否替换已存在的键。 事务（Transaction）在 Redis 中，事务提供了一种将多个命令打包然后一次性、按顺序执行的机制。它通过一系列命令来实现事务的开始、执行和管理。 开始事务: MULTI: 标记一个事务块的开始。后续的命令将会被队列化，而不是立即执行。 命令入队: 在 MULTI 命令之后输入的命令不会立即被执行，而是会被放入一个队列中。当执行 EXEC 命令时，队列中的所有命令会被连续执行。 执行事务: EXEC: 执行所有在 MULTI 之后入队的命令。如果在执行 EXEC 之前连接被断开，那么事务中的所有命令都不会被执行。 放弃事务: DISCARD: 取消事务，放弃执行事务块内的所有命令。 监视键: WATCH key1 [key2 ...]: 在执行事务之前监视一个或多个键。如果在调用 EXEC 命令之前这些键被其他命令改变了，那么事务将被放弃。 取消监视键: UNWATCH: 取消 WATCH 命令对所有键的监视。 Redis 事务的特点： 原子性: Redis 的事务保证了事务内的命令要么全部执行，要么全部不执行。 没有隔离级别: Redis 不支持传统数据库意义上的事务隔离级别。如果事务执行期间，有其他客户端修改了被 WATCH 命令监视的键，那么该事务将被取消。 不支持回滚: 在 Redis 中，事务没有回滚的概念。如果事务中某个操作失败，其他操作仍会继续执行。 发布&#x2F;订阅Redis 的发布&#x2F;订阅（pub&#x2F;sub）是一种消息通信模式，它使得消息的发送者（发布者）不需要知道消息的接收者（订阅者），反之亦然。这种模式非常适合构建松耦合的应用程序和服务。 发布消息: PUBLISH channel message: 将消息发送到指定的频道。 订阅频道: SUBSCRIBE channel1 [channel2 ...]: 订阅一个或多个频道。订阅后，客户端将接收这些频道上发布的所有消息。 退订频道: UNSUBSCRIBE [channel1 [channel2 ...]]: 退订一个或多个频道。如果没有提供频道名，客户端将退订所有频道。 按模式订阅频道: PSUBSCRIBE pattern1 [pattern2 ...]: 根据给定的模式订阅频道。模式可以包含通配符。 按模式退订频道: PUNSUBSCRIBE [pattern1 [pattern2 ...]]: 根据给定的模式退订频道。如果没有提供模式，客户端将退订所有模式。 列出当前活跃的频道: PUBSUB CHANNELS [pattern]: 列出当前的活跃频道。可选的模式参数可以用来过滤频道名。 列出特定频道的订阅者数量: PUBSUB NUMSUB [channel1 [channel2 ...]]: 返回一个或多个频道的订阅者数量。 列出按模式订阅的数量: PUBSUB NUMPAT: 返回按模式订阅的数量。 地理位置Redis 从 3.2 版本开始引入了地理空间支持，允许使用一组命令来存储、查询和操作地理位置信息。这些功能基于 Redis 的有序集合实现，每个元素都是一个带有经纬度的地理空间信息。 添加地理位置信息: GEOADD key longitude latitude member [longitude latitude member ...]: 将指定的地理空间位置（经度、纬度、成员）添加到指定的 key 中。 地理位置查询: GEOPOS key member [member ...]: 返回一个或多个成员位置的经纬度。 计算两地距离: GEODIST key member1 member2 [unit]: 计算两个成员之间的距离。单位可以是 m（米）、km（千米）、mi（英里）或 ft（英尺）。 按半径查询成员: GEORADIUS key longitude latitude radius m|km|mi|ft [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]: 以指定的经纬度为中心，查找在指定半径内的元素。可选参数提供了多种查询功能，例如排序、限制返回数量等。 GEORADIUSBYMEMBER key member radius m|km|mi|ft [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]: 以指定成员为中心，查找在指定半径内的元素。 地理空间索引的哈希值: GEOHASH key member [member ...]: 返回一个或多个位置对象的 Geohash 字符串。 基于概率的数据结构Redis 支持几种基于概率的数据结构，允许在内存效率和准确性之间取得平衡。这些数据结构特别适用于处理大规模数据集，其中完全准确的结果要么不可行，要么成本过高。 HyperLogLog 用于高效的基数估计（即估计唯一元素的数量）。 PFADD key element [element ...]: 向 HyperLogLog 中添加元素。 PFCOUNT key [key ...]: 返回 HyperLogLog 的近似基数估计值。 PFMERGE destkey sourcekey [sourcekey ...]: 合并多个 HyperLogLog 到一个新的 HyperLogLog 中。 布隆过滤器（通过 RedisBloom 模块） 布隆过滤器是一种空间效率很高的数据结构，用于测试一个元素是否是集合的一部分。它可能返回假阳性，但不会返回假阴性。 BF.ADD key element: 将元素添加到布隆过滤器。 BF.MADD key element [element ...]: 向布隆过滤器中添加多个元素。 BF.EXISTS key element: 检查元素是否可能存在于布隆过滤器中。 BF.MEXISTS key element [element ...]: 检查多个元素是否可能存在于布隆过滤器中。 计数最小Sketch（通过 RedisBloom 模块） 计数最小 Sketch 是一种用于频率估计的数据结构，它可以估计一个元素在数据流中出现的次数。 CMS.INITBYDIM key width depth: 通过指定宽度和深度初始化计数最小 Sketch。 CMS.INITBYPROB key error probability: 通过指定错误率和置信度初始化计数最小 Sketch。 CMS.INCRBY key item count [item count ...]: 增加一个或多个元素的计数值。 CMS.QUERY key item [item ...]: 查询一个或多个元素的计数值。 Top-K 结构（通过 RedisBloom 模块） Top-K 结构用于跟踪数据流中最常见的元素。 TOPK.RESERVE key topk width depth decay: 创建一个 Top-K 结构。 TOPK.ADD key item [item ...]: 向 Top-K 结构中添加一个或多个元素。 TOPK.QUERY key item [item ...]: 查询一个或多个元素是否在 Top-K 结构中。 TOPK.LIST key: 列出 Top-K 结构中的元素。 其他 PING：检查服务是否运行。 INFO：获取服务器的信息和统计。 数据持久化RDB（Redis Database）RDB是Redis的一种持久化机制，它会在指定的时间间隔内生成数据集的时间点快照。 触发机制: 可以通过SAVE命令手动触发，或者配置在redis.conf文件中的规则自动触发。 优点: 提供了一个非常紧凑的数据文件，适合灾难恢复，快照频率可配置，可以最大化性能和数据持久性之间的权衡。 缺点: 在生成快照时可能会消耗大量的IO和CPU资源，如果Redis在快照之间崩溃，那么自上次快照以来的所有数据将丢失。 AOF（Append Only File）AOF是另一种Redis持久化机制，记录了执行过的所有写操作命令，并在服务器启动时重新执行这些命令来重建数据集。 触发机制: 每个写操作命令都会追加到AOF文件中。 优点: 提供了更好的持久性和安全性，可以配置不同的同步方式，如每秒同步或每写操作同步。 缺点: AOF文件通常比RDB文件大，且恢复速度可能慢于RDB方式。 应用场景 会话缓存: 存储用户会话信息，如登录状态或用户的临时偏好设置，以便快速读取。 队列: 利用Redis的列表数据结构实现消息队列，支持多种队列模式，如FIFO（先进先出），LIFO（后进先出）。 排行榜: 使用Redis的有序集合数据类型，它可以保持元素插入的顺序，适合实时排行榜系统。 计数器: 利用Redis的原子操作如INCR实现计数器，常用于统计点击数、用户在线数等。 发布&#x2F;订阅: Redis提供了PUB&#x2F;SUB模式，允许客户端订阅频道并接收发布到这些频道的消息，适用于实时消息系统如聊天室。 Redis如何开启远程服务Redis开启远程服务的操作方法： 打开redis的配置文件redis.conf 将bind 127.0.0.1注释掉 将protected-mode yes改成protected-mode no 添加daemonize no 重启redis服务 Scrapy-Redis 中存储的数据类型及其用途 List类型 (spidername:items) 用途：存储爬虫获取到的数据项，数据项是JSON格式的字符串。 例如：db250:items 存储豆瓣电影 Top 250 的爬取数据。 Set类型 (spidername:dupefilter) 用途：用于存储已访问URL的哈希值，以实现去重。 特点：存储的是URL的40字符哈希字符串。 List类型 (spidername:start_urls) 用途：存储启动爬虫时的初始URL。 例如：db250:start_urls 可以存储 https://www.movie.douban.com/top250 作为起始页面。 ZSet类型 (spidername:requests) 用途：存储待调度的请求，内容是序列化的请求对象。 特点：使用ZSet可以对请求进行优先级排序。 常用设置及其说明 调度器设置 SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot; 功能：启用Scrapy-Redis的调度器，将请求存储到Redis中。 去重过滤器设置 DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot; 功能：确保所有的Spider通过Redis共享相同的重复过滤器。 管道设置 ITEM_PIPELINES = &#123;&#39;scrapy_redis.pipelines.RedisPipeline&#39;: 300,&#125; 功能：启用Redis管道，将爬取的项存储到Redis中。 Redis连接设置 REDIS_HOST = &#39;localhost&#39; REDIS_PORT = 6379 功能：指定连接到Redis服务器的主机和端口。 调度器持久化设置 # SCHEDULER_PERSIST = True 功能：设置为True时，不清理Redis队列，允许爬虫暂停和恢复，数据不会丢失。 特点：这是一个可选设置，根据需求选择是否启用。 补充说明 扩展性：Scrapy-Redis的设计使得Scrapy爬虫具有更好的扩展性，特别适用于大规模分布式爬取。 负载均衡：通过Redis队列，多个爬虫实例可以共享URL请求，实现负载均衡。 数据共享：所有的Spider可以通过Redis数据库共享去重信息和待抓取的URL，从而协同工作。 分布式项目演示演示逻辑 将代码设置成可以进行分布式爬取代码 将分布式代码copy一份,一共两份 两份代码,两处内容存放的位置,两处爬取的内容之和是整体内容 项目配置及项目代码 spider作了简单改动,更重要的是在settings里作一些设置 Spider文件代码作了简单改动 导出RedisSpider 类继承 RedisSpider 注销start_urls 设置 redis_key &#x3D; “db:start_urls” 开启爬虫 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import scrapyfrom ..items import DbItemfrom scrapy_redis.spiders import RedisSpiderclass Dbtest1Spider(RedisSpider): print(&quot;#1 Spider on...&quot;) name = &quot;dbtest1&quot; allowed_domains = [&quot;movie.douban.com&quot;] # start_urls = [&quot;https://movie.douban.com/top250&quot;] # 修改为开始爬取的页面 redis_key = &quot;dbtest1:start_urls&quot; # 3.开启爬虫的key page_num = 0 # parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址 def parse(self, response): node_list = response.xpath(&#x27;//div[@class=&quot;info&quot;]&#x27;) if node_list: for node in node_list: # 标题 movie_name = node.xpath(&#x27;./div/a/span/text()&#x27;).get() # 导演 director = node.xpath(&#x27;./div/p/text()&#x27;).get().strip() # 分数 score = node.xpath(&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;).get() item = DbItem() item[&quot;movie_name&quot;] = movie_name item[&quot;director&quot;] = director item[&quot;score&quot;] = score # 电影详情页 detail_url = node.xpath(&#x27;./div/a/@href&#x27;).get() yield scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;&quot;info&quot;:item&#125;) # 发送新一页的请求 # 构造url if response.meta.get(&quot;num&quot;): self.page_num = response.meta.get(&#x27;num&#x27;) page_url = &quot;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&quot;.format(self.page_num*25) yield scrapy.Request(page_url, callback=self.parse, meta=&#123;&quot;num&quot;: self.page_num&#125;) self.page_num +=1 if self.page_num ==6: return # 详情页解析 def get_detail(self,response): item = DbItem() info = response.meta.get(&quot;info&quot;) item.update(info) description_list = response.xpath(&#x27;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#x27;).getall() description = &#x27;&#x27;.join([des.strip() for des in description_list]) item[&quot;description&quot;] = description yield item Items文件12345678910import scrapyclass DbItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() movie_name = scrapy.Field() director = scrapy.Field() score = scrapy.Field() description = scrapy.Field() Pipelines文件123456789101112131415from itemadapter import ItemAdapterimport jsonclass DbPipeline: def open_spider(self, spider): self.f = open(&#x27;film.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) def process_item(self, item, spider): json_str = json.dumps(dict(item), ensure_ascii=False) + &#x27;\\n&#x27; self.f.write(json_str) return item def close_spider(self, spider): self.f.close() Settings文件settings文件需要配置 公共的调度器 SCHEDULER 公共的过滤器 DUPEFILTER_CLASS 公共存储区域 redis 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: utf-8 -*-BOT_NAME = &#x27;db&#x27;SPIDER_MODULES = [&#x27;db.spiders&#x27;]NEWSPIDER_MODULE = &#x27;db.spiders&#x27;# Obey robots.txt rulesROBOTSTXT_OBEY = FalseDOWNLOAD_DELAY = 1# Override the default request headers:DEFAULT_REQUEST_HEADERS = &#123; &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;, &#x27;Accept-Language&#x27;: &#x27;en&#x27;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36&quot;&#125;# 启用调度将请求存储进redis# 必须SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;# 确保所有spider通过redis共享相同的重复过滤。# 必须DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;#公共管道ITEM_PIPELINES = &#123; &#x27;scrapy_redis.pipelines.RedisPipeline&#x27;:300, &#x27;db.pipelines.DbPipeline&#x27;: 200,&#125;# 指定连接到Redis时要使用的主机和端口。# 必须REDIS_HOST = &#x27;localhost&#x27;REDIS_PORT = 6379# 不清理redis队列，允许暂停/恢复抓取。# 可选 允许暂停,redis数据不丢失SCHEDULER_PERSIST = True#日志文件配置# LOG_FILE=&quot;db_redis.log&quot;LOG_ENABLED=TrueLOG_FORMAT=&#x27;%(asctime)s [%(name)s] %(levelname)s: %(message)s&#x27;LOG_DATEFORMAT=&#x27;%Y&#x27;LOG_ENCODING=&quot;utf-8&quot;LOG_LEVEL=&quot;INFO&quot; 执行演示爬虫执行可以发现爬虫1和爬虫2未有提交URL时进行了等待 注意 TypeError: ExecutionEngine.crawl() got an unexpected keyword argument &#39;spider&#39; Scrapy版本和scrapy-redis版本有概率不兼容，我的案例是修正Scrapy版本为2.8.0解决问题 添加URL给Redis开启爬取执行命令在Redis添加列表添加URL LPUSH dbtest1:start_urls &quot;https://movie.douban.com/top250&quot; 随后两个爬虫就会开始进行爬取即可 Scrapy-Redis 源码解读connection.py这个模块的作用是建立与Redis数据库的连接。它通常提供一个工厂方法，用于创建Redis连接对象，这使得Scrapy项目能够连接到Redis服务器并执行各种操作，如存储或检索数据。 defaults.py这里定义了Scrapy-Redis用到的一些默认设置。这可能包括默认的Redis URL、连接参数、队列名称等。这些常量和默认值对于确保Scrapy-Redis的标准行为至关重要。 dupefilter.py这个 dupefilter.py 源码是Scrapy-Redis扩展的一部分，专门用于处理请求去重。请求去重是网页爬虫中的一个关键步骤，用于确保不重复爬取相同的网页，从而提高效率和减少资源浪费。这个模块使用Redis作为存储后端来记录已经处理过的请求。 类 RFPDupeFilter RFPDupeFilter 类继承自 Scrapy 的 BaseDupeFilter，是一个基于Redis的请求去重过滤器。 初始化方法 __init__ server: 接收一个 Redis 实例，用于与Redis数据库通信。 key: 指定在Redis中用于存储去重指纹（fingerprints）的键。 debug: 一个布尔值，用于确定是否打印日志信息，用于调试。 类方法 from_settings 这个方法用于从Scrapy的设置中创建一个 RFPDupeFilter 实例。它读取相关配置并实例化一个连接到Redis的去重过滤器。 类方法 from_crawler 这个方法从Scrapy的爬虫中创建 RFPDupeFilter 实例。它是 from_settings 的包装方法，提供了一个从 Crawler 对象获取设置的快捷方式。 方法 request_seen 这个方法用于检查一个请求是否已经被看到（即之前已经处理过）。它使用请求的指纹（fingerprint），如果这个指纹已经存在于Redis中，就认为这个请求是重复的。 request_fingerprint 方法用于生成请求的指纹，通常基于请求的URL和其他特征。 方法 close 和 clear close 方法在过滤器关闭时被调用，用于执行清理工作。 clear 方法用于从Redis中删除所有的去重指纹数据。 方法 log 这个方法用于在启用调试模式时打印日志信息，记录被过滤掉的重复请求。 整体工作流程 当Scrapy爬虫启动时，RFPDupeFilter 会被实例化，并与Redis建立连接。 对于每个发出的请求，RFPDupeFilter 会计算其指纹并检查这个指纹是否已经存储在Redis中。 如果指纹已存在，表明请求是重复的，将不会再次处理该请求。 所有的指纹都存储在Redis中，这允许在分布式爬虫环境下跨多个爬虫实例共享去重信息。 picklecompat.py这个模块是用于数据序列化和反序列化的。虽然您提到它类似于JSON转换，但它实际上更多使用的是pickle库，这是Python中一个常用的序列化方法。它允许复杂的数据结构如Python对象被转换为可以存储在Redis中的形式。 pipelines.py在Scrapy框架中，pipelines用于处理爬取的数据。Scrapy-Redis的这一模块扩展了这个概念，允许将爬取的数据存储在Redis数据库中。这对于分布式爬虫来说特别重要，因为它允许多个爬虫实例共享和存储数据。 queue.py这个模块维护了请求队列。在Scrapy-Redis中，通常有几种类型的队列，例如FIFO（先进先出）、LIFO（后进先出）等，用于控制请求的处理顺序。通过Redis来管理这些队列，可以实现跨多个爬虫实例的请求共享。 scheduler.py这是Scrapy-Redis中的一个核心组件。调度器负责决定何时以及如何发送请求。在Scrapy-Redis中，这通常涉及从Redis队列中获取请求，并在分布式环境下有效地管理这些请求。 类 Scheduler Scheduler 类是一个基于 Redis 的调度器。 初始化方法 __init__ server: Redis 服务器实例，用于和 Redis 数据库进行交互。 persist: 表示在关闭时是否保留请求数据。如果为 False，则在关闭时清空队列。 flush_on_start: 表示在启动时是否清空 Redis 队列。 queue_key: 请求队列在 Redis 中的键名。 queue_cls: 请求队列的类的路径，用于动态加载队列类。 dupefilter_key: 去重过滤器在 Redis 中的键名。 dupefilter_cls: 去重过滤器类的路径，用于动态加载去重类。 idle_before_close: 在关闭前等待的空闲时间，如果在这段时间内没有接收到消息，则关闭调度器。 serializer: 用于序列化请求的类或模块。 类方法 from_settings 这个方法从 Scrapy 的设置中创建一个 Scheduler 实例。它读取相关配置并基于这些配置创建一个实例。 类方法 from_crawler 这个方法从 Scrapy 的爬虫对象中创建一个 Scheduler 实例。它是 from_settings 的包装器，提供从爬虫对象获取设置的方式。 方法 open 在爬虫开启时调用，用于初始化请求队列和去重过滤器。 方法 close 在爬虫关闭时调用，根据 persist 参数决定是否清空队列。 方法 flush 清空队列和去重过滤器中的数据。 方法 enqueue_request 将新的请求加入队列。如果请求不需要过滤且之前没有见过，那么它将被加入队列。 方法 next_request 从队列中弹出下一个请求。 方法 has_pending_requests 检查是否还有等待处理的请求。 工作流程 当爬虫启动时，Scheduler 会被初始化。它会创建请求队列和去重过滤器。 如果设置了 flush_on_start，则在启动时清空 Redis 队列。 在爬虫运行期间，所有新的请求都会通过 enqueue_request 方法加入队列。如果请求被去重过滤器认为是重复的，它将不会被加入队列。 next_request 方法用于获取下一个要处理的请求，这个过程可能会根据 idle_before_close 设置等待一段时间。 当爬虫关闭时，根据 persist 设置决定是否清空 Redis 队列。 通过扩展关闭分布式爬虫在Scrapy和Scrapy-Redis中，利用扩展（Extensions）来智能地关闭分布式爬虫是一种有效的策略。这种方法主要依赖于Scrapy的信号系统和对 spider_idle 信号的处理。 Scrapy-Redis 的 spider_idle 方法在Scrapy-Redis中，当一个爬虫耗尽其内部队列中的所有请求时，Scrapy的信号系统会触发 spider_idle 信号。Scrapy-Redis通过重写 spider_idle 方法，并在方法中主动从Redis队列中调度新的请求。由于这个方法抛出了 DontCloseSpider 异常，所以即使没有剩余的本地请求，爬虫也不会停止，而是会继续等待新的请求从Redis中被调度。 1234567891011# The idle signal is called when the spider has no requests left,that&#x27;s when we will schedule new requests from redis queue爬虫程序没有剩余请求时,空闲信号就会被调用，也就是我们将从redis队列调度新请求的时候crawler.signals.connect(self.spider_idle, signal=signals.spider_idle)意思就非常明显了,空闲的信号被调用---&gt; spide_idledef spider_idle(self): &quot;&quot;&quot;Schedules a request if available, otherwise waits.&quot;&quot;&quot; # XXX: Handle a sentinel to close the spider. self.schedule_next_requests() raise DontCloseSpider 因为抛出了DontCloseSpider异常，所以当触发spider_idle信号的时候整个爬虫也不会停止。 自定义扩展这个自定义扩展RedisSpiderSmartClosedExtensions的目的是在某些条件下智能地关闭爬虫，而不是无限期地等待新的请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import timeimport loggingfrom scrapy import signals # 引入信号from scrapy.exceptions import NotConfigured # 在settings 设置是否开启这个拓展logger = logging.getLogger(__name__)class ResdisSpiderSmartClosedExtensions: # 高内聚 低耦合 def __init__(self, idle_number, crawler): # 数量值 self.idle_number = idle_number # 这个就是settings里面的一些配置项 self.crawler = crawler # 专门记录触发信号的时间 self.idle_list = [] # 记录次数,进行对比 self.idle_count = 0 @classmethod def from_crawler(cls, crawler): if not crawler.settings.getbool(&#x27;MYEXT_ENABLED&#x27;): raise NotConfigured # 判断一下 你是不是一个redis爬虫 if not &#x27;redis_key&#x27; in crawler.spidercls.__dict__.keys(): raise NotConfigured(&#x27;Only Support Redis Version&#x27;) idle_number = crawler.settings.getint(&#x27;IDLE_NUMBER&#x27;, 10) ext = cls(idle_number, crawler) crawler.signals.connect(ext.spider_idle, signal=signals.spider_idle) return ext def spider_idle(self, spider): self.idle_count += 1 self.idle_list.append(time.time()) idle_list_len = len(self.idle_list) # 长度大于二就证明已经空转很多次了, key有存在就证明你还没有抓完 if idle_list_len &gt; 2 and spider.server.exists(spider.redis_key): self.idle_list = [self.idle_list[-1]] elif idle_list_len &gt; self.idle_number: logger.info(&#x27;\\n continued idle number exceed &#123;&#125; Times&#x27; &#x27;\\n meet the idle shutdown conditions, will close the reptile operation&#x27; &#x27;\\n idle start time: &#123;&#125;,close spider time: &#123;&#125;&#x27;.format(self.idle_number, self.idle_list[0], self.idle_list[-1])) self.crawler.engine.close_spider(spider, &#x27;closespider_pagecount&#x27;) 初始化方法 __init__ idle_number: 表示允许爬虫空闲的次数（没有新请求的情况）。 crawler: Scrapy的爬虫对象。 idle_list: 用于记录每次空闲时的时间戳。 idle_count: 记录空闲发生的次数。 方法 from_crawler 这个类方法用于从爬虫的配置中创建扩展实例，并连接到Scrapy的信号。 方法 spider_opened 和 spider_closed spider_opened: 在爬虫开启时调用，用于记录初始信息。 spider_closed: 在爬虫关闭时调用，用于记录关闭信息。 方法 spider_idle 这是关键方法。每次爬虫空闲时，都会增加 idle_count 的值，并记录当前时间。如果连续空闲次数超过设定的 idle_number，并且Redis队列中没有新的请求，那么爬虫将被关闭。 settings.py 中的相关设置 EXTENSIONS: 在这里配置自定义的扩展类。 MYEXT_ENABLED: 用于启用或禁用这个扩展。 IDLE_NUMBER: 设置允许的最大空闲次数。 123456EXTENSIONS = &#123; # &#x27;scrapy.extensions.telnet.TelnetConsole&#x27;: None, &#x27;db.extensions.RedisSpiderSmartIdleClosedExensions&#x27;: 500&#125;MYEXT_ENABLED = TrueIDLE_NUMBER = 5 工作流程 当爬虫开始运行时，RedisSpiderSmartClosedExtensions 被初始化，并连接到相应的Scrapy信号。 在爬虫运行期间，每当它空闲时（没有新的请求），spider_idle 方法会被触发。 如果连续空闲次数超过 IDLE_NUMBER 设置的阈值，并且Redis中没有新的请求，那么这个扩展会指示Scrapy关闭爬虫。 这种方法使得爬虫在完成其任务后不会无限期地等待，从而有效管理资源。 ScrapydScrapyd是一个用于部署和运行Scrapy爬虫的应用，它提供了一个JSON API，通过该API可以实现爬虫的部署、启动、停止等操作。 安装 Scrapyd 和 Scrapyd-client 安装 Scrapyd 使用命令 pip install scrapyd 来安装 Scrapyd。 验证： 输入 scrapyd 命令。如果能够访问 http://localhost:6800/ 页面，表示安装成功。 安装 Scrapyd-client 使用命令 pip install scrapyd-client 来安装 Scrapyd-client，这是一个用于与Scrapyd交互的命令行工具。 验证： 在Scrapy项目目录下输入 scrapyd-deploy，如果出现提示 Unknown target: default，表示安装成功。 配置 Scrapy.cfg在 scrapy.cfg 文件中，配置部署信息。例如： 12345[deploy:douban] # 部署名称，可自定义url = http://localhost:6800/ # Scrapyd服务器地址project = db250 # 项目名称username = xxx # 服务器访问用户名（可选）password = xxx # 服务器访问密码（可选） 验证： 使用命令 scrapyd-deploy -l 可以查看设置的部署名称和URL。 执行打包命令在包含 scrapy.cfg 的目录下执行部署命令： scrapyd-deploy [部署名称] -p [项目名称] 例如： scrapyd-deploy douban -p db250 成功部署后，终端会显示类似如下信息： 123Deploying to project &quot;db250&quot; in http://localhost:6800/addversion.jsonServer response (200):&#123;&quot;node_name&quot;: &quot;YNRBYA8RP4AT92A&quot;, &quot;status&quot;: &quot;ok&quot;, &quot;project&quot;: &quot;db250&quot;, &quot;version&quot;: &quot;1595508145&quot;, &quot;spiders&quot;: 1&#125; 启动爬虫使用 curl 命令启动爬虫： 1curl http://localhost:6800/schedule.json -d project=[项目名称] -d spider=[爬虫名称] 成功启动后，会返回包含 jobid 的响应，如： 1&#123;&quot;node_name&quot;: &quot;YNRBYA8RP4AT92A&quot;, &quot;status&quot;: &quot;ok&quot;, &quot;jobid&quot;: &quot;98785578cce211eab46598fa9b72ce54&quot;&#125; 关闭爬虫使用 curl 命令关闭爬虫： 1curl http://localhost:6800/cancel.json -d project=[项目名称] -d job=[jobid] 列出项目列出Scrapyd服务器上的所有项目： 1curl http://localhost:6800/listprojects.json 删除项目从Scrapyd服务器上删除指定项目： 1curl http://localhost:6800/delproject.json -d project=[项目名称]","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://www.yiuhangblog.com/tags/Scrapy/"},{"name":"Redis","slug":"Redis","permalink":"https://www.yiuhangblog.com/tags/Redis/"},{"name":"分布式","slug":"分布式","permalink":"https://www.yiuhangblog.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"网页抓取","slug":"网页抓取","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96/"},{"name":"Scrapyd","slug":"Scrapyd","permalink":"https://www.yiuhangblog.com/tags/Scrapyd/"}],"author":"Yiuhang Chan"},{"title":"Scrapy","slug":"20211128scrapy","date":"2021-10-28T05:12:54.000Z","updated":"2024-02-28T10:50:35.000Z","comments":true,"path":"2021/10/28/20211128scrapy/","permalink":"https://www.yiuhangblog.com/2021/10/28/20211128scrapy/","excerpt":"Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。","text":"简介Scrapy是一个用Python编写的高效且结构化的网页抓取框架，广泛应用于数据挖掘、网站监测和自动化测试。它的设计初衷是为了方便用户爬取网站数据和提取结构化数据，但它的用途不仅限于网页抓取，还包括处理API返回的数据（如Amazon Associates Web Services）或进行更广泛的网络爬取任务。 Scrapy的一个关键特性是它使用了Twisted异步网络库来处理网络通信。 信息 异步编程: 在传统的同步编程模型中，任务按顺序一个接一个地执行。如果一个任务需要等待（例如，等待网络响应），程序将在此期间停止执行后续任务。 异步编程允许程序在等待一个任务完成的同时继续执行其他任务。这种方式非常适合处理I&#x2F;O密集型任务，比如网络请求，因为程序不需要在每个请求完成时都暂停执行。 Twisted异步网络库: Twisted是一个事件驱动的网络编程框架，专为Python设计。它支持多种协议，可以用于创建高性能的网络服务器和客户端。 在Scrapy中，Twisted用于处理网络请求。当Scrapy发出一个请求并等待服务器响应时，它不会阻塞整个爬虫的进程。相反，Scrapy可以利用这段时间执行其他任务，如处理已经收到的数据或发出更多的网络请求。 Scrapy中的应用: Scrapy利用Twisted的异步特性来提高爬虫的效率。它能够同时处理多个网络请求，而不会因为单个请求的延迟而阻塞整个爬虫。 这使得Scrapy非常适合执行大规模的网络抓取任务，因为它可以有效地利用网络资源和处理能力，同时维持高效率的数据收集。 使用原因： 1.为了更利于我们将精力集中在请求与解析上2.企业级的要求 12345flowchart TD A(找到目标数据) --&gt; B(分析请求流程) B --&gt; C(构造http请求) C --&gt; D(提取数据) D --&gt; E(数据持久化) 运行流程 Scrapy框架的体系结构Scrapy框架的体系结构由几个重要组件组成，这些组件协同工作，实现了从发送请求到提取数据再到存储数据的整个流程： 引擎（Engine）: Scrapy引擎是框架的核心，负责控制数据流在各组件之间的流动，触发事件。 调度器（Scheduler）: 负责接收引擎发送的请求，并将它们加入队列中。在引擎请求新请求时，调度器发送下一个要抓取的请求给引擎。 下载器（Downloader）: 负责从Internet上下载网页内容，并将其封装为响应对象，然后返回给引擎。 蜘蛛（Spiders）: 是用户编写用来解析响应并从中提取数据（提取的项目）或额外的跟进URL的类。 项目管道（Item Pipeline）: 负责处理由蜘蛛提取出来的项目，通常包括清洗、验证和存储等。 下载器中间件（Downloader Middlewares）: 位于引擎和下载器之间，处理引擎和下载器之间的请求和响应。 蜘蛛中间件（Spider Middlewares）: 位于引擎和蜘蛛之间，处理蜘蛛的输入（响应）和输出（项目和新的请求）。 信息 Downloader Middleware（下载中间件） 这些钩子允许处理、修改和自定义发往下载器的请求以及从下载器返回的响应。下载中间件在Scrapy的请求&#x2F;响应处理流程中提供了几个关键的扩展点。例如，可以使用它来添加HTTP头部到请求中，或者处理从网站返回的HTTP响应。这些中间件的用途包括： 在请求发送到下载器之前修改或过滤请求。 在响应发送到爬虫之前处理或修改响应。 直接生成新的请求，而不是处理当前的响应。 选择性地放弃某些请求 Spider Middleware（爬虫中间件） 爬虫中间件则是处理传入响应、传出项目（item）和请求的钩子。这些中间件在Scrapy的数据处理流程中处于核心位置，允许用户对爬虫的输入和输出进行细致的控制。使用爬虫中间件，可以： 在爬虫处理回调之后处理请求或项目。 修改或过滤开始请求（由 start_requests 方法生成的请求）。 处理由于响应内容引发的异常，根据响应内容调用错误回调（errback）。 数据流过程 启动过程: Scrapy开始运行，初始化了调度器、下载器以及蜘蛛。 爬取过程: 引擎向蜘蛛请求第一个要爬取的URL。 蜘蛛返回第一个要爬取的请求给引擎。 引擎将请求发送到调度器，并请求下一个URL。 调度器返回下一个要爬取的请求给引擎。 下载过程: 引擎从调度器中取出请求，通过下载器中间件发送到下载器。 下载器处理请求，返回响应给引擎。 引擎收到响应后，通过蜘蛛中间件发送给相应的蜘蛛处理。 解析和提取数据: 蜘蛛处理响应，提取数据并生成新的请求，返回给引擎。 引擎将提取的数据发送到项目管道，并将新的请求发送到调度器。 项目管道处理提取出的数据。 循环处理: 以上过程在整个爬取过程中不断重复，直到调度器中没有更多的请求。 关闭过程: 当所有预定的URL都被爬取，且调度器中没有更多的请求时，Scrapy关闭，爬取过程结束。 简单使用项目命令 创建项目: 使用命令 scrapy startproject &lt;project_name&gt; [project_dir] 创建新项目。其中 &lt;project_name&gt; 是必填项，表示项目名称；[project_dir] 是可选项，表示项目目录。 例如：scrapy startproject db 会创建一个名为 ‘db’ 的Scrapy项目。 创建第一个爬虫: 首先，需要进入到项目目录中，使用 cd &lt;project_name&gt; 命令。 然后，使用 scrapy genspider &lt;name&gt; &lt;domain&gt; 创建一个新的爬虫。这里 &lt;name&gt; 是爬虫的名称，而 &lt;domain&gt; 是爬虫将要爬取的域名。 例如：scrapy genspider example example.com 会在项目的 spiders 目录下创建一个名为 ‘example’ 的爬虫，它针对的是 ‘example.com’ 网站。 运行项目: 使用命令 scrapy crawl &lt;spider_name&gt; 来运行爬虫。这里 &lt;spider_name&gt; 是在创建爬虫时指定的名称。 例如：scrapy crawl example 会运行名为 ‘example’ 的爬虫。 设置配置文件: 在 settings.py 文件中，可以配置各种参数，比如 ROBOTSTXT_OBEY（是否遵守网站的robots.txt规则）和 DEFAULT_REQUEST_HEADERS（默认的HTTP头部）。 警告 由于可以设置多个爬虫，且通过name进行管理，因此scrapy genspider &lt;name&gt; &lt;domain&gt;创建新爬虫的时候的时候name是不能重复的，会报错 无数据可以查看是否限制了域名 dbtest1.py： 12345678910import scrapyclass Test1Spider(scrapy.Spider): name = &quot;test1&quot; #爬虫名 allowed_domains = [&quot;movie.douban.com&quot;] #限制域名，可以添加多个域名（列表） start_urls = [&quot;https://movie.douban.com/top250&quot;] #初始页面，第一个抓取的页面，放在产生请求的地方也就是在爬虫部件 def parse(self, response): #response就是上面start_urls的响应 pass 项目文件介绍 爬取豆瓣电影项目目的和要求目标是创建一个 Scrapy 爬虫来爬取豆瓣电影的前 250 个电影信息。这些信息包括： 电影名称 导演和演员信息 电影评分 需要将这些信息保存到本地，同时通过 Scrapy 的管道（Pipelines）机制进行持久化。 项目搭建创建 Spider 类首先需要创建一个名为 Test1Spider 的类，该类继承自 scrapy.Spider。在这个类中，定义以下属性和方法： name: 爬虫的唯一标识名 start_urls: 包含开始爬取的 URL 列表 parse(self, response): 是爬虫的核心方法，用于处理响应并返回提取的数据或新的请求。 创建命令示例： scrapy genspider dbtest1 movie.douban.com 这将在 spiders 目录下生成 dbtest1.py 文件。 解析响应（Parsing Response） 在 parse 方法中，使用 response 对象进行页面内容的解析。可以利用 xpath 或 css 选择器提取所需的数据。 首先分析该页面结构： 假设要获取标题，导演和分数等信息，通过分析可以发现class=&quot;info&quot;即可包含所有得信息 因此修改response直接使用xpath语法 dbtest1.py： 123456789class Dbtest1Spider(scrapy.Spider): name = &quot;dbtest1&quot; allowed_domains = [&quot;movie.douban.com&quot;] start_urls = [&quot;https://movie.douban.com/top250&quot;] #修改为开始爬取的页面 # parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址 def parse(self, response): # 这个地方可以直接使用response 就可以了，response对象里面就已经绑定了lxml的一些方法 node_list = response.xpath(&#x27;//div[@class=&quot;info&quot;]&#x27;) 调试前置可以在同目录下添加调试文件db_debug.py，方便对爬虫文件进行断点调试 db_debug.py: 1234from scrapy.cmdline import executeexecute([&#x27;scrapy&#x27;, &#x27;crawl&#x27;, &#x27;dbtest1&#x27;]) #执行命令 通过调试可以发现传输了25行数据 清洗数据对拿到的info标签进行解析，利用循环进行即可 首先查看标题标签 然后通过其结构利用xpath锁定其位置 dbtest1.py： 1234567891011121314151617181920import scrapyclass Dbtest1Spider(scrapy.Spider): name = &quot;dbtest1&quot; allowed_domains = [&quot;movie.douban.com&quot;] start_urls = [&quot;https://movie.douban.com/top250&quot;] #修改为开始爬取的页面 # parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址 def parse(self, response): # 这个地方可以直接使用response 就可以了，response对象里面就已经绑定了lxml的一些方法 node_list = response.xpath(&#x27;//div[@class=&quot;info&quot;]&#x27;) if node_list: #万一没有数据那么就不执行避免报错 for node in node_list: # 标题 move_title = node.xpath(&#x27;./div/a/span/text()&#x27;).get() # 工作人员 employee = node.xpath(&#x27;./div/p/text()&#x27;).get() # 评分 score = node.xpath(&#x27;./span[@class=&quot;rating_num&quot;]/text()&#x27;).get() 信息 在XPath中，./和//是两种不同的路径选择符，它们用于指定当前节点的相对路径。理解它们之间的差异对于正确地从HTML文档中提取数据是很重要的。 ./ - 当前节点下的直接子节点: ./用于选择当前节点的直接子节点。 当使用./时，它会限制搜索范围到直接下级的元素。 在例子中，./div意味着选择当前节点（在这里是每个div[@class=&quot;info&quot;]）的直接子div元素。 // - 文档中任何位置的节点: //用于选择文档中任何位置的节点，而不考虑它们在文档中的位置。 使用//时，它会从整个文档中搜索符合条件的节点，而不仅限于当前节点的子节点。 在例子中，如果使用//div，它将会查找整个文档中所有的div元素，而不仅仅是div[@class=&quot;info&quot;]下的div元素。 使用了./div，这意味着想要选择每个div[@class=&quot;info&quot;]元素的直接子div元素。这是一种更精确的选择方式，确保只选取特定父元素下的子元素，避免从整个文档中获取不相关的div。 调试1断点调试后发现其获取的是对象，这是因为在Scrapy框架中，使用.xpath()方法返回的是一个SelectorList对象，而不是直接返回数据。SelectorList是Scrapy中的一个特殊类型，用于表示一组通过XPath选择器找到的元素。 SelectorList 对象: 当调用 .xpath() 方法时，返回的是一个 SelectorList 对象，而不是实际的数据。 SelectorList 是一个包含多个 Selector 对象的列表。每个 Selector 对象代表一个通过XPath表达式匹配到的节点。 使用 .get() 方法提取数据: 为了从 Selector 或 SelectorList 对象中提取数据，需要使用 .get() 方法（在早期版本的Scrapy中，这个方法叫做 .extract_first()）。 .get() 方法从 SelectorList 中提取第一个匹配的元素的数据。如果没有找到匹配的元素，它将返回 None。 如果想要提取所有匹配的元素，可以使用 .getall() 方法（旧版本中对应 .extract()）。 为什么不直接返回数据: 这种设计允许在决定如何处理匹配到的元素之前先检查它们。例如，可以检查 SelectorList 是否为空，或者提取它包含的所有元素。 它还提供了更大的灵活性，例如先对匹配到的元素进行进一步的选择或应用额外的XPath表达式。 因此，要从中提取文本数据，需要调用 .get() 方法。 调试2随后继续调试可以发现工作人员部分，带有额外空白字符 而使用 .strip() 方法在处理从网页提取的文本数据时是非常常见且有用的，特别是当文本包含了不必要的空白字符（如空格、制表符、换行符等）时。.strip() 方法的作用是移除字符串两端的空白字符，使得提取的数据更加整洁和一致。 原因和原理： 移除多余空白: 网页中的文本经常包含了在HTML代码中用于格式化的额外空白字符。这些字符在网页上看不出来，但在提取文本数据时会被包含进来。 .strip() 方法用于移除这些不需要的空白字符，如前后的空格和换行符，这对于清洁数据和后续处理非常有帮助。 格式化和一致性: 使用 .strip() 可以确保数据的格式一致，无论原始HTML中的格式如何。 它有助于减少后续处理数据时的麻烦，特别是在比较、存储或展示数据时。 使用方法: 在Python中，.strip() 方法无需任何参数即可移除字符串两端的空白字符。 如果想要移除其他特定字符，也可以传递一个字符串作为参数给 .strip()，它将移除字符串两端的任何包含在该参数中的字符。 这样，employee 将不再包含字符串开头和结尾的空格或换行符，使得数据更加整洁和便于处理。 调试3最后对分数进行调试，发现没有返回数据，而这是因为搜索节点的范围和深度的缘故造成的 当使用 ./span[@class=&quot;rating_num&quot;]/text() ： 这里的 ./ 将会导致XPath表达式只在当前处理节点的直接子节点中进行搜索。如果当前处理节点是 div 元素的父节点，那么 ./div[@class=&quot;star&quot;] 将会选中直接子节点中的 class=&quot;star&quot; 的 div 元素。然后，/span[@class=&quot;rating_num&quot;]/text() 将会从这个选中的 div 元素中选择 class=&quot;rating_num&quot; 的 span 元素，并提取其文本内容。 然而，由于当前处理的节点是 div[@class=&quot;star&quot;] 内部的一个节点，或者更深层次的一个节点，因此 ./ 就不能正确地选中所需的元素了，因为它不会搜索更深层次的节点。 所以会返回None 当使用 .//span[@class=&quot;rating_num&quot;]/text()： .// 表示从当前节点开始查找，不限于直接子节点，而是包括所有后代节点。 div[@class=&quot;star&quot;] 表示选择 class 属性为 “star” 的 div 元素。 span[@class=&quot;rating_num&quot;] 表示选择 class 属性为 “rating_num” 的 span 元素。 /text() 表示获取选定 span 元素的文本内容。 由于 span 元素嵌套在 class=&quot;star&quot; 的 div 元素内部，所以需要使用 .// 来确保能够选中正确的元素，无论它位于何种深度 在XPath中，./ 和 .// 的差异主要在于它们搜索节点的范围和深度。这个差别对于定位和提取网页中的数据是至关重要的。 ./ - 直接子节点: ./ 表示选择当前节点的直接子节点。 当使用 ./ 时，它将只在当前节点的下一级（即直接子节点）中查找匹配的元素。 例如，如果当前节点是一个div元素，./span将只会选择该div元素的直接子span元素。 .// - 当前节点及其所有后代节点: .// 表示在当前节点及其所有后代（子节点、孙节点等）中选择节点。 当使用 .// 时，它会搜索整个子树，找到所有匹配的元素，无论它们位于当前节点的哪个层级。 所以，如果当前节点是一个div元素，.//span将会选择该div及其所有子节点中的所有span元素，无论这些span元素嵌套得有多深。 在实际应用中，如果不确定当前处理的节点在HTML结构中的确切位置，使用 .// 会更加安全，因为它不受节点深度的限制。而 ./ 更适合在已知确切的层次结构和上下文中使用。 dbtest1.py： 12345678910111213141516171819import scrapyclass Dbtest1Spider(scrapy.Spider): name = &quot;dbtest1&quot; allowed_domains = [&quot;movie.douban.com&quot;] start_urls = [&quot;https://movie.douban.com/top250&quot;] #修改为开始爬取的页面 # parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址 def parse(self, response): # 这个地方可以直接使用response 就可以了，response对象里面就已经绑定了lxml的一些方法 node_list = response.xpath(&#x27;//div[@class=&quot;info&quot;]&#x27;) if node_list: #万一没有数据那么就不执行避免报错 for node in node_list: # 标题 move_title = node.xpath(&#x27;./div/a/span/text()&#x27;).get() # 工作人员 employee = node.xpath(&#x27;./div/p/text()&#x27;).get().strip() # 评分 score = node.xpath(&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;).get() 定义 Item Scrapy使用Item类来定义数据结构。当从非结构化数据源（如网页）提取数据时，使用Item对象可以确保数据结构化和一致性。 Item对象类似于Python字典，但提供了额外的结构化和错误检测功能。这在大型项目中尤其重要，因为它减少了字段名错误和数据不一致的风险。 在Scrapy项目中，通常需要在items.py文件中定义Item类，然后在爬虫代码中导入和使用这些类。 Scrapy 使用 Item 类来定义结构化数据字段，它类似于 Python 的字典但提供额外的保护和便利。在 items.py 文件中定义数据结构。 dbtest1.py： 1234567891011121314151617181920212223242526272829import scrapyfrom ..items import DbItemclass Dbtest1Spider(scrapy.Spider): name = &quot;dbtest1&quot; allowed_domains = [&quot;movie.douban.com&quot;] start_urls = [&quot;https://movie.douban.com/top250&quot;] # 修改为开始爬取的页面 # parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址 def parse(self, response): # 这个地方可以直接使用response 就可以了，response对象里面就已经绑定了lxml的一些方法 node_list = response.xpath(&#x27;//div[@class=&quot;info&quot;]&#x27;) if node_list: # 万一没有数据那么就不执行避免报错 for node in node_list: # 标题 move_title = node.xpath(&#x27;./div/a/span/text()&#x27;).get() # 工作人员 employee = node.xpath(&#x27;./div/p/text()&#x27;).get().strip() # 评分 score = node.xpath(&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;).get() # 实例化 item = DbItem() item[&#x27;move_title&#x27;] = move_title item[&#x27;employee&#x27;] = employee item[&#x27;score&#x27;] = score yield item 只会存储item.py里定义的字段 items.py： 1234567891011121314# Define here the models for your scraped items## See documentation in:# https://docs.scrapy.org/en/latest/topics/items.htmlimport scrapyclass DbItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() move_title = scrapy.Field() employee = scrapy.Field() score = scrapy.Field() 信息 在Python中，点（.）和双点（..）是相对导入的一部分，它们表示当前和父包的目录位置。 单个点（.）表示当前模块的目录位置。 双点（..）表示父目录的位置。 当在一个Python模块中看到 from ..items import DbItem 这样的语句时，这意味着： from ..items 表示从当前模块的父包中的 items 模块导入。 import DbItem 是指导入 items 模块中定义的 DbItem 类。 这种导入方式通常用在一个包结构中，使得模块可以导入同一包内或父包中的其他模块。例如，在Scrapy项目中，可能有以下的目录结构： 123456789101112myproject/├── myproject/│ ├── __init__.py│ ├── items.py│ ├── middlewares.py│ ├── pipelines.py│ ├── settings.py│ └── spiders/│ ├── __init__.py│ ├── spider1.py│ └── spider2.py└── scrapy.cfg 如果在 spider1.py 或 spider2.py 中需要导入 items.py 中定义的 DbItem 类，需要使用相对导入。由于 spiders 是一个子包，需要使用 .. 来表示 items.py 所在的父包 myproject。 使用相对导入的好处是，它不依赖于包的具体位置，这使得整个包更易于重构和移动。然而，相对导入也要小心使用，因为它们只能用在一个包的内部，不能用于顶级模块，否则会引发 ImportError。 信息 在Scrapy框架中，yield关键字用于从一个函数返回数据项，但与return不同，yield实现的是一种称为生成器的概念，允许函数在保持其状态的情况下产生一个序列的值，这使得函数能够在每次产生一个值后暂停执行，并在下一次从它停止的地方继续执行。 在Scrapy中，yield通常在爬虫的parse方法中使用，用来产生以下几种可能的对象： Item对象: 当爬虫解析网页并提取数据时，它会创建一个Item对象，并填充数据。然后通过yield语句返回这个Item对象，Scrapy引擎会将这个Item传递给Item Pipeline进行进一步的处理，如清洗、验证和存储。 Request对象: 如果页面需要跟进链接或翻页，爬虫会创建一个Request对象，并通过yield返回。这个Request对象包含了请求的URL和一个回调函数，Scrapy会排队发送这个请求，并在收到响应后将其传递给指定的回调函数。 使用yield的优势在于它的内存效率和执行效率。生成器不需要在处理大量数据时将它们全部存储在内存中，它们只在需要时产生一个数据项。对于大规模的爬虫任务，这意味着更低的内存消耗和更好的性能。 下面是使用yield在Scrapy爬虫中返回Item对象的示例代码： 12345678def parse(self, response): # 解析页面，提取数据 for some_data in response.css(&#x27;some_selector&#x27;): item = MyItem() item[&#x27;field1&#x27;] = some_data.css(&#x27;field1_selector::text&#x27;).get() item[&#x27;field2&#x27;] = some_data.css(&#x27;field2_selector::text&#x27;).get() # ... yield item # 循环返回Item对象 在这个例子中，每次循环都会提取数据，创建一个Item对象，并通过yield返回它。Scrapy引擎接收到这些Item后，会将它们发送到Item Pipeline。 追踪链接（Following Links） 为了实现多页爬取，需要在爬虫中实现链接追踪。这通常涉及从当前页面提取下一页的链接或根据一定的规则构建新的URL。 可以在爬虫中使用类变量来追踪当前页码，并在解析函数中构造下一页的URL。如果没有更多的页面可以爬取，爬虫将停止。 要爬取所有250部电影的信息，需要从初始页面提取到其他页面的链接，并对其进行跟踪。这可以通过构造新的 scrapy.Request 对象并从 parse 方法返回实现 定义和使用管道（Pipelines） Item管道是Scrapy中用于处理爬虫返回的Item对象的组件。它们可以执行多种操作，如清理HTML数据、验证数据完整性、检查重复项和进行数据持久化。 创建管道组件通常涉及编写一个Python类，并在该类中实现特定的方法来处理Item对象。 为了激活特定的管道组件，需要在Scrapy的settings.py文件中的ITEM_PIPELINES设置中添加并配置它们。 管道用于处理 Spider 从网页中提取的 Item。常见的用途包括清洗数据、去重、存储数据到文件或数据库中。 在 pipelines.py 中定义一个管道类，用于处理 Item 对象。 在 settings.py 中启用管道（ITEM_PIPELINES 设置）。 1234567891011121314151617181920212223242526272829# Define your item pipelines here## Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html# useful for handling different item types with a single interfacefrom itemadapter import ItemAdapter #Pipeline可以更加通用地处理不同的Item类或字典。import json #导入Python标准库中的json模块，用于将Python字典转换为JSON字符串。class DbPipeline: #定义了一个名为DbPipeline的新类，这是一个Scrapy Pipeline的实现。 def open_spider(self, spider): #open_spider是一个特殊的方法，它在Scrapy爬虫开始运行时被调用。 #在open_spider方法中，打开一个名为dbtest1result.txt的文件用于写入（&#x27;w&#x27;模式） #并设置编码为utf-8。这个文件句柄被保存在self.f属性中，以便在整个Pipeline中使用。 self.f = open(&#x27;dbtest1result.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) def process_item(self, item, spider): #是Pipeline中的核心方法，每个Item在Pipeline中被处理时都会调用这个方法。 #将Item对象转换为字典（如果它还不是字典），然后转换为一个JSON字符串。 #ensure_ascii=False是为了确保非ASCII字符（如中文）能被正确处理。 #每个JSON字符串后面都加上一个换行符，为了确保写入文件时每个Item占据一行。 json_str = json.dumps(dict(item), ensure_ascii=False) + &#x27;\\n&#x27; self.f.write(json_str) #将JSON字符串写入之前打开的文件。 print(item) #在控制台上打印Item，这对于调试和监控Pipeline的处理是有用的。 return item #返回Item对象，这样它就能被后续的Pipeline组件进一步处理。 def close_spider(self, spider): #是另一个特殊的方法，它在爬虫关闭时调用。 self.f.close() #关闭文件句柄。这是一个好习惯，因为它可以确保所有内容都被正确地写入磁盘，并释放了系统资源。 存储数据 可以编写管道类来实现特定的数据处理需求，例如将爬取的数据保存到文件中。 管道的执行顺序是根据在settings.py中分配给它们的整数值确定的。 修改 pipelines.py 文件以添加数据存储逻辑。例如，将数据写入到本地的 film.txt 文件中。 运行爬虫进入项目根目录，运行以下命令以启动爬虫： scrapy crawl db 注意 Robots.txt 协议： 默认情况下，Scrapy 会遵守 Robots.txt 协议。如果需要爬取被此协议禁止的内容，需在 settings.py 中将 ROBOTSTXT_OBEY 设置为 False。 表头设置（伪装）： 有些网站会根据请求的 User-Agent 进行内容过滤。如果需要，可在 settings.py 中设置自定义的表头。 管道激活： 需要在 settings.py 中激活管道，以便将提取的数据传递到 pipelines.py。300是一个整数值，定义了Pipeline的执行顺序，数字越小越早执行。 Item 字段定义： 在 items.py 中定义字段，这些字段决定了可以从爬取的页面中提取哪些数据。 Scrapy shellscrapy shell 是一个强大的交互式环境，它允许开发者在不运行整个爬虫的情况下测试和调试Scrapy的数据抓取代码。它可以加载网页，执行选择器，甚至可以运行爬虫的解析函数，是Scrapy开发中不可或缺的调试工具。 在项目目录下输入 scrapy shell https://movie.douban.com/top250 会启动Scrapy shell并预加载豆瓣电影Top 250的页面进行调试。下面是对Scrapy shell中提供的一些快捷方法和对象的详细说明： 快捷方法 shelp(): 显示Scrapy shell可用的快捷方法和支持的对象的帮助文档。 fetch(url[,redirect=True]): 用于在Scrapy shell中获取指定网址的响应。如果redirect为True，则会跟随重定向。 fetch(request): 与上面的方法相似，但这里可以传递一个Scrapy的Request对象，而不是URL字符串。 view(response): 在本地浏览器中打开当前响应的页面，便于直观地查看Scrapy获取的数据与实际浏览器中呈现的网页之间的差异。 Scrapy 对象 crawler: 表示当前运行的爬虫的Crawler对象，包含了很多与爬虫运行相关的信息和接口。 spider: 当前被加载的Spider对象。如果在shell中加载了一个特定的页面，Scrapy会尝试为这个域创建一个爬虫对象。 request: 当前被执行的Request对象。在执行fetch()方法后，可以通过这个对象查看请求的具体信息。 response: 最近一次执行fetch()方法后返回的Response对象。可以通过它来访问页面的内容，并使用选择器提取数据。 settings: 当前Scrapy项目的设置。可以通过它来查看或修改Scrapy的配置信息。 在Scrapy shell中，也可以使用所有的Python标准库和Scrapy提供的选择器，例如response.xpath()或response.css()来测试和调试数据提取的代码。 总结起来，scrapy shell提供了一个沙箱环境，让开发者可以实时测试XPath或CSS选择器，查看响应内容，甚至是测试item pipelines的代码，这样可以在不必运行整个Scrapy项目的情况下快速调试和修正代码中的问题。 示例使用IPython 作为控制台的后端在终端（Terminal）中运行 Scrapy shell，Scrapy 会自动检测到 IPython 并使用它，相较于标准 Python 解释器这样操作更加简便。 在项目文件目录下成功启动Scrapy shell后输入settings[&#39;DEFAULT_REQUEST_HEADERS&#39;]即可查看settings文件中的DEFAULT_REQUEST_HEADERS的默认配置信息 同样的可以查看当前的爬虫和爬虫类的属性值 例如spider.name 或者利用fetch()进行URL的切换 但是个人觉得还是用IDE的调试方便，但是一般对于已经部署在服务器的项目还是使用Shell才行，毕竟不用修改代码 Scrapy Selector 类选择器 Selector 是 Scrapy 的核心部分，用于提取 HTML&#x2F;XML 文档中的数据。 Scrapy 和 lxml 的关系: Scrapy 默认使用 lxml 作为其解析器，这意味着即使没有直接导入 lxml，Scrapy 仍然依赖于它来解析 HTML&#x2F;XML。 lxml 提供了底层的解析功能，而 Scrapy 的选择器在此基础上提供了更易用的接口。 选择器的主要方法: xpath(): 接受 XPath 表达式，用于选择 HTML&#x2F;XML 文档中的元素。 css(): 使用 CSS 选择器来选择元素。 这些方法返回的是选择器列表（SelectorList 对象），可以进一步用于提取或操作数据。 提取数据的方法: extract(): 返回所有匹配的元素的数据。 extract_first(): 返回第一个匹配元素的数据，如果没有匹配元素则返回 None。 get() 和 getall(): 它们是 extract_first() 和 extract() 的别名。 嵌套选择器的使用: 在某些情况下，可能需要多次调用 .xpath() 或 .css() 来精确定位数据。 示例：response.css(&#39;img&#39;).xpath(&#39;@src&#39;) 会首先选择所有 &lt;img&gt; 标签，然后提取它们的 src 属性。 使用正则表达式提取数据: .re(): 使用正则表达式提取数据，返回匹配的字符串列表。 .re_first(): 返回第一个匹配的字符串。 示例 HTML 字符串: 提供的 HTML 字符串html_str是一个豆瓣电影页面的一部分，包含电影信息如标题、导演、评分等。 使用 Scrapy 选择器，可以提取这些信息，如电影名称、评分等。 1234567891011121314151617181920212223242526272829html_str=&quot;&quot;&quot;&lt;div class=&quot;info&quot;&gt; &lt;div class=&quot;hd&quot;&gt; &lt;a href=&quot;https://movie.douban.com/subject/1292052/&quot; class=&quot;&quot;&gt; &lt;span class=&quot;title&quot;&gt;肖申克的救赎&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;&amp;nbsp;/&amp;nbsp;The Shawshank Redemption&lt;/span&gt; &lt;span class=&quot;other&quot;&gt;&amp;nbsp;/&amp;nbsp;月黑高飞(港) / 刺激1995(台)&lt;/span&gt; &lt;/a&gt; &lt;span class=&quot;playable&quot;&gt;[可播放]&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p class=&quot;&quot;&gt; 导演: 弗兰克·德拉邦特 Frank Darabont&amp;nbsp;&amp;nbsp;&amp;nbsp;主演: 蒂姆·罗宾斯 Tim Robbins /...&lt;br&gt; 1994&amp;nbsp;/&amp;nbsp;美国&amp;nbsp;/&amp;nbsp;犯罪 剧情 &lt;/p&gt; &lt;div class=&quot;star&quot;&gt; &lt;span class=&quot;rating5-t&quot;&gt;&lt;/span&gt; &lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;9.7&lt;/span&gt; &lt;span property=&quot;v:best&quot; content=&quot;10.0&quot;&gt;&lt;/span&gt; &lt;span&gt;1980500人评价&lt;/span&gt; &lt;/div&gt; &lt;p class=&quot;quote&quot;&gt; &lt;span class=&quot;inq&quot;&gt;希望让人自由。&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&quot;&quot;&quot; 选择器使用的完整示例： 1234567891011121314151617181920212223242526272829303132333435363738from scrapy.selector import Selector# 1.通过文本构造实例对象select_txt = Selector(text=html_str) # 这段代码通过 Selector 类创建一个选择器实例，接受一个 HTML 字符串作为输入。允许对该 HTML 文档执行 XPath 或 CSS 查询。# 提取电影的名字(提取单个内容使用get())print(select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).get())# 这里使用 XPath 查询提取了电影名称。get() 方法返回第一个匹配元素的文本，适用于提取单个内容。# 提取多个标签的内容(提取多个内容使用getall())print(select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).getall())# 与上面类似，但使用 getall() 方法，它返回所有匹配元素的文本列表，适用于提取多个内容。# 提取电影的名字(提取单个内容使用extract_first())print(select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).extract_first())# 这行代码等效于使用 get() 方法。extract_first() 也返回第一个匹配元素的文本# 提取多个标签的内容(提取多个内容使用extract())print(select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).extract())# 这行代码等效于使用 getall() 方法。extract() 返回所有匹配元素的文本列表。# 细分一下标签print(select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span[1]/text()&#x27;).getall()[0])# 这里通过细分 XPath 查询，只选择第一个 &lt;span&gt; 元素的文本，并通过索引 [0] 获取列表中的第一个元素。# 2. 通过response 构造实例对象from scrapy.http import HtmlResponseresponse = HtmlResponse(url=&#x27;http://www.example.com/&#x27;, body=html_str.encode())select_tet = Selector(response=response)# 这里通过 HtmlResponse 对象创建了一个选择器实例。HtmlResponse 接受一个 URL 和 HTML 内容作为输入。print(select_tet.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).get())print(response.selector.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).get())# 这两行代码都用于提取电影名称。第一行直接使用通过 HtmlResponse 创建的选择器，第二行使用 response 对象的 selector 属性。print(select_tet.css(&#x27;a&#x27;).xpath(&#x27;./span/text()&#x27;).re_first(&#x27;.*的&#x27;))# 这里首先使用 CSS 选择器选择所有的 &lt;a&gt; 标签，然后使用 XPath 选择器进一步选择这些 &lt;a&gt; 标签中的 &lt;span&gt; 标签内的文本。最后，使用正则表达式方法 re_first() 提取包含“的”的第一个文本。 Selector 类的基础用法12from scrapy.selector import Selectorfrom scrapy.http import HtmlResponse 导入 Selector 类和 HtmlResponse 类的语句。 Selector 类： Selector 类用于从 HTML 或 XML 文档中提取数据。 它提供了使用 XPath 和 CSS 选择器查询文档的功能。 通过 Selector 类，可以轻松地提取网页中的特定部分，如文本、链接、标签属性等。 HtmlResponse 类： HtmlResponse 类是 Scrapy 用于表示 HTTP 响应的一个类。 它是 Response 类的一个子类，专门用于处理 HTML 类型的内容。 通过 HtmlResponse，可以访问响应的 URL、状态码、头部（headers）、正文（body）等信息。 它通常与 Request 对象一起使用，表示发送请求后收到的 HTTP 响应。 这两个类在编写 Scrapy 爬虫时非常有用。例如，当发送一个 HTTP 请求并收到响应时，可以使用 HtmlResponse 对象来处理这个响应，并使用 Selector 对象来解析和提取所需的数据。 1. 通过文本构造 Selector 实例1select_txt = Selector(text=html_str) Selector 是 Scrapy 框架中的一个核心类，用于执行对 HTML 或 XML 文档的选择和提取操作。 这行代码创建了一个 Selector 的实例，命名为 select_txt。 text=html_str：这里 text 参数用于传递 HTML 内容。 html_str 应该是一个包含 HTML 文档内容的字符串。在实际应用中，这个字符串通常是从网页请求中获取的 HTML 响应体。 通过传递这个 HTML 字符串，Selector 类的实例 select_txt 将能够解析这个 HTML 文档。 创建了 select_txt 实例后，可以使用它来进行数据提取。 Selector 提供了多种方法来查询和提取 HTML 文档中的数据，最常见的包括 XPath 和 CSS 查询。 例如，select_txt.xpath(&#39;//div&#39;) 会选择 HTML 文档中所有的 &lt;div&gt; 元素。 另一个例子，select_txt.css(&#39;div.classname&#39;) 会选择所有 class 属性为 classname 的 &lt;div&gt; 元素。 这行代码的主要功能是创建一个 Selector 对象，用于解析和操作给定的 HTML 字符串。这是 Scrapy 爬虫开发中常见的模式，用于从网页中提取信息，如提取链接、文本内容、图像地址等。通过这种方式，Scrapy 能够高效地处理和解析网页内容。 提取电影名称1select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).get() select_txt 是一个 Selector 对象，它包含了 HTML 文档的内容。 .xpath(&#39;//div[@class=&quot;info&quot;]/div/a/span/text()&#39;) 是一个 XPath 查询。这个查询的含义如下： //div[@class=&quot;info&quot;]：这部分选择所有具有 class=&quot;info&quot; 属性的 &lt;div&gt; 元素。// 表示在整个文档中查找，而 [@class=&quot;info&quot;] 是一个条件，用于筛选具有指定类名的 &lt;div&gt; 元素。 /div/a/span：对于每个符合上述条件的 &lt;div&gt; 元素，进一步选择其内部的子 &lt;div&gt;，然后选择这些 &lt;div&gt; 内部的 &lt;a&gt; 元素，再选择这些 &lt;a&gt; 元素内部的 &lt;span&gt; 元素。这是一个层层深入的选择过程。 /text()：最后，这部分选择了前面找到的 &lt;span&gt; 元素中的文本内容。text() 函数用于获取一个元素的文本部分。 .get()：这个方法用于从上面的 XPath 查询中提取第一个匹配元素的文本内容。如果查询没有找到匹配的元素，则返回 None。 提取所有匹配元素的文本列表1select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).getall() 类似于前面的查询，但使用 getall() 方法来获取所有匹配元素的文本内容列表。 .getall()：这个方法从 XPath 查询中提取所有匹配元素的文本内容，并返回一个列表。如果没有找到匹配的元素，则返回一个空列表。 使用 extract_first() 提取第一个匹配元素的文本1select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).extract_first() extract_first() 方法的功能与 get() 相似，用于提取第一个匹配元素的文本。 使用 extract() 提取所有匹配元素的文本列表1select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).extract() extract() 方法的功能与 getall() 相似，用于提取所有匹配元素的文本内容列表。 提取特定子元素的文本1select_txt.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span[1]/text()&#x27;).getall()[0] select_txt 应该是一个 Selector 对象，包含了 HTML 文档的内容。 .xpath(&#39;//div[@class=&quot;info&quot;]/div/a/span[1]/text()&#39;) 是一个 XPath 查询。 //div[@class=&quot;info&quot;]：选择所有具有 class=&quot;info&quot; 属性的 &lt;div&gt; 元素。// 表示在整个文档中查找。 /div/a/span[1]：对于每个符合上述条件的 &lt;div&gt; 元素，进一步选择其内部的子 &lt;div&gt;，然后选择这些 &lt;div&gt; 内部的 &lt;a&gt; 元素，再选择这些 &lt;a&gt; 元素内部的第一个 &lt;span&gt; 元素（由 [1] 指定）。 /text()：选择前面找到的 &lt;span&gt; 元素中的文本内容。 .getall()：这个方法用于从 XPath 查询中提取所有匹配元素的文本内容，并返回一个列表。 [0]：这个索引用于从列表中获取第一个元素。在 Python 中，列表的索引从 0 开始。 2. 通过 response 构造 Selector 实例1234# 创建 HtmlResponse 对象response = HtmlResponse(url=&#x27;http://www.example.com/&#x27;, body=html_str.encode())# 创建 Selector 对象select_tet = Selector(response=response) HtmlResponse 是 Scrapy 框架中用来表示 HTTP 响应的一个类。 url=&#39;http://www.example.com/&#39;：这里指定了响应所对应的 URL。在实际的 Scrapy 应用中，这通常是发起请求的目标 URL。 body=html_str.encode()：body 参数用于提供 HTTP 响应的正文内容。 html_str 应该是一个包含 HTML 内容的字符串。 .encode() 方法将这个字符串转换为字节序列。在 HTTP 通信中，正文内容通常以字节形式存在，所以需要进行这样的转换。 Selector 类在 Scrapy 中用于选择和提取 HTML 或 XML 文档中的数据。 response=response：这里将前面创建的 HtmlResponse 对象传递给 Selector。这样，Selector 就可以使用 HtmlResponse 中的 HTML 内容进行解析和数据提取。 select_tet 是创建的 Selector 对象的实例，它现在包含了 response 中的 HTML 数据，并可以使用该对象进行各种选择器查询（如 XPath 或 CSS 查询）。 这两行代码组合使用 HtmlResponse 和 Selector 类来处理和解析 HTML 数据。首先，使用 HtmlResponse 来模拟一个 HTTP 响应，包括它的 URL 和正文内容。然后，创建一个 Selector 对象来解析这个响应的 HTML 内容，并提供数据提取的功能。这是在 Scrapy 爬虫中常见的模式，用于从网页中提取所需的信息。 使用 Selector 实例和 response 的 selector 属性提取数据12select_tet.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).get()response.selector.xpath(&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;).get() select_tet 应该是一个由 Selector 类实例化的对象。这个对象包含了某个 HTML 文档的内容。 .xpath(&#39;//div[@class=&quot;info&quot;]/div/a/span/text()&#39;) 是一个 XPath 选择器表达式。这个表达式的作用是： //div[@class=&quot;info&quot;]：选择所有具有 class=&quot;info&quot; 属性的 &lt;div&gt; 标签。 /div/a/span：在每个这样的 &lt;div&gt; 标签内，进一步选择嵌套的 &lt;div&gt;，然后选择其内部的 &lt;a&gt; 标签，再选择 &lt;a&gt; 标签内的 &lt;span&gt; 标签。 /text()：提取这些 &lt;span&gt; 标签内的文本内容。 .get()：这个方法用于获取匹配的第一个元素的文本内容。如果没有找到匹配的元素，将返回 None。 response 应该是一个 HtmlResponse 对象，通常在 Scrapy 中表示对某个 URL 请求的响应。 response.selector 是 HtmlResponse 对象的属性，它提供了一个 Selector 对象，用于在响应的 HTML 内容上进行选择器查询。 .xpath(&#39;//div[@class=&quot;info&quot;]/div/a/span/text()&#39;) 和第一行代码中的 XPath 表达式相同，作用也相同，用于选择特定结构的元素并提取其文本内容。 .get() 的作用同上，用于获取匹配的第一个元素的文本内容。 这两行代码实现的功能是相同的：从 HTML 文档中提取具有特定结构的元素（在这种情况下是某些 &lt;span&gt; 标签内的文本内容）。区别在于它们的选择器来源不同 — 第一行代码使用的是直接从 HTML 文本创建的选择器，而第二行代码使用的是从 HtmlResponse 对象创建的选择器。这种灵活性使得 Scrapy 可以适应不同的数据提取场景。 结合 CSS 和 XPath 选择器及正则表达式提取数据1select_tet.css(&#x27;a&#x27;).xpath(&#x27;./span/text()&#x27;).re_first(&#x27;.*的&#x27;) select_tet.css(&#39;a&#39;): select_tet 应该是一个 Selector 对象，它包含了从网页中提取的 HTML 数据。 .css(&#39;a&#39;) 是一个 CSS 选择器，用来选取所有的 &lt;a&gt; 标签。在 Scrapy 中，css 方法用于执行 CSS 选择器查询。 这一步的结果是一个新的 SelectorList 对象，包含了 HTML 文档中所有的 &lt;a&gt; 标签。 .xpath(&#39;./span/text()&#39;): .xpath() 是一个 XPath 选择器方法，用来进一步从前一步的结果中筛选数据。 &#39;./span/text()&#39; 是一个 XPath 查询，它的含义是：在当前节点（这里指的是每个 &lt;a&gt; 标签）的基础上，选择其子节点中的 &lt;span&gt; 标签，并获取这些 &lt;span&gt; 标签的文本内容。 这一步的结果是一个 SelectorList 对象，包含了所有选中 &lt;span&gt; 标签的文本内容。 .re_first(&#39;.\\*的&#39;): .re_first() 是一个正则表达式方法，用于在之前选择的文本中进行模式匹配。 &#39;.*的&#39; 是一个正则表达式，. 表示任意字符，* 表示零次或多次重复，的 是要匹配的具体字符。因此，这个表达式的意思是匹配任何以 “的” 结尾的字符串。 re_first 表示只提取第一个匹配的结果。如果没有找到匹配项，则返回 None。 在 HTML 文档中查找所有 &lt;a&gt; 标签，然后在每个 &lt;a&gt; 标签中查找 &lt;span&gt; 标签的文本内容，并从这些文本中提取第一个以 “的” 结尾的字符串。这种方法在处理 HTML 数据时非常灵活，可以有效地结合不同的选择器和正则表达式来提取复杂的数据结构。 Scrapy Spider 类 Spider的名称 (name): 这是一个字符串，用于定义此蜘蛛的名称。 名称必须唯一，因为它是Scrapy定位和实例化蜘蛛的方式。 这是最重要的蜘蛛属性，必须提供。 起始URLs (start_urls): 这是蜘蛛开始爬取的URL列表。 爬虫的第一页下载将是此列表中的页面。 后续的请求将从这些起始URL中提取的数据中连续生成。 自定义设置 (custom_settings): 这些设置在运行特定蜘蛛时会覆盖项目范围的全局设置。 必须定义为类属性，因为在实例化蜘蛛之前，设置就已经更新。 Spider 类的基础结构123456789101112131415class Spider(object_ref): &quot;&quot;&quot;Base class for scrapy spiders. All spiders must inherit from this class.&quot;&quot;&quot; name = None custom_settings = None def __init__(self, name=None, **kwargs): if name is not None: self.name = name elif not getattr(self, &#x27;name&#x27;, None): raise ValueError(&quot;%s must have a name&quot; % type(self).__name__) self.__dict__.update(kwargs) if not hasattr(self, &#x27;start_urls&#x27;): self.start_urls = [] class Spider(object_ref): 这行定义了一个名为 Spider 的类。它从 object_ref 继承，但这里的 object_ref 看起来像是一个错误或者不完整的代码，因为通常 Python 中的类是从 object 类继承的。这可能是一个笔误或者特定项目中的自定义实现。 类的文档字符串说明了这个类是所有 Scrapy Spider 的基类，意味着所有的 Scrapy 爬虫都应该从这个类继承。 name = None: 这是一个类级别的属性，用于存储爬虫的名称。在 Scrapy 中，每个爬虫的名称应该是唯一的。 custom_settings = None: 这也是一个类级别的属性，用于定义特定于此爬虫的自定义设置，这些设置将覆盖全局设置。 def __init__(self, name=None, **kwargs): 这是 Spider 类的构造函数。它接受一个可选的 name 参数和任意数量的关键字参数（**kwargs）。 这部分代码用于设置爬虫的名称。如果构造函数中提供了 name，它将被用作爬虫的名称。 如果没有提供 name 并且类的 name 属性也没有被设置，会抛出一个 ValueError 异常，因为每个爬虫必须有一个唯一的名称。 self.__dict__.update(kwargs): 这行代码将所有通过 **kwargs 传入的关键字参数添加到类的实例字典中。这允许在创建爬虫实例时传入额外的属性或设置。 if not hasattr(self, &#39;start_urls&#39;): 这里检查实例是否有 start_urls 属性，如果没有，则初始化为空列表。start_urls 是爬虫开始爬取的 URL 列表。 这个类是 Scrapy 爬虫的一个基本框架，提供了命名、自定义设置和初始化的基本机制。任何具体的 Scrapy 爬虫都应该继承这个类，并根据需要提供具体的实现细节。 日志系统 Logger在 Scrapy 的 Spider 类中，日志系统被用于记录信息、警告、错误等。这对于监控爬虫的行为、调试和记录重要事件非常有用。 Logger 属性1234@propertydef logger(self): logger = logging.getLogger(self.name) return logging.LoggerAdapter(logger, &#123;&#x27;spider&#x27;: self&#125;) @property：这是一个 Python 装饰器，用于将一个方法转换为属性。这意味着可以通过 self.logger 访问这个方法返回的值，而不是 self.logger()。 logger = logging.getLogger(self.name)：这里创建了一个日志记录器（logger）。getLogger(self.name) 使用爬虫的名称（self.name）获取一个日志记录器实例。如果不存在具有该名称的记录器，将自动创建一个。 return logging.LoggerAdapter(logger, &#123;&#39;spider&#39;: self&#125;)：返回一个 LoggerAdapter 实例。这是一个对标准日志记录器的包装，它提供了额外的上下文信息，使得每个日志消息都能够知道是由哪个爬虫实例产生的。这里的上下文信息是 &#123;&#39;spider&#39;: self&#125;，即当前的爬虫实例。 Log 方法12345678def log(self, message, level=logging.DEBUG, **kw): &quot;&quot;&quot;Log the given message at the given log level This helper wraps a log call to the logger within the spider, but you can use it directly (e.g. Spider.logger.info(&#x27;msg&#x27;)) or use any other Python logger too. &quot;&quot;&quot; self.logger.log(level, message, **kw) def log(self, message, level=logging.DEBUG, **kw): 这是一个辅助方法，用于在爬虫内部发送日志消息。 level=logging.DEBUG：默认的日志级别设置为 DEBUG。日志级别决定了记录的消息类型。常见的级别包括 DEBUG, INFO, WARNING, ERROR, 和 CRITICAL。 self.logger.log(level, message, **kw)：这个调用使用了之前定义的 logger 属性。它将消息 message 记录到日志中，级别为 level。**kw 可以传递额外的关键字参数。 使用示例1234567class MySpider(scrapy.Spider): name = &#x27;my_spider&#x27; def parse(self, response): # 使用日志记录信息 self.logger.info(&#x27;Parsing response from %s&#x27;, response.url) # 其他解析逻辑... 在这个例子中，每当 parse 方法被调用时，都会记录一个包含响应 URL 的信息级别日志。 from_crawler 和 _set_crawler 方法Spider 类的 from_crawler 类方法和 _set_crawler 实例方法。这些方法在 Scrapy 的内部机制中扮演重要角色，尤其是在爬虫的初始化过程中。 from_crawler 方法 12345@classmethoddef from_crawler(cls, crawler, *args, **kwargs): spider = cls(*args, **kwargs) spider._set_crawler(crawler) return spider @classmethod：这是一个 Python 装饰器，用于定义一个类方法。不同于普通的实例方法，类方法接收类本身作为第一个参数（通常命名为 cls）而非类的实例。 from_crawler 是 Scrapy 用来创建 Spider 实例的标准方法。它接收一个 crawler 对象作为参数，以及任意数量的额外的位置和关键字参数。 spider = cls(*args, **kwargs)：这行代码使用传入的参数创建了一个 Spider 实例。 spider._set_crawler(crawler)：这行代码调用 _set_crawler 方法，将 crawler 对象设置到创建的 Spider 实例上。 return spider：返回创建好的 Spider 实例。 _set_crawler 方法 1234def _set_crawler(self, crawler): self.crawler = crawler self.settings = crawler.settings crawler.signals.connect(self.close, signals.spider_closed) 这是一个内部方法，用于在 Spider 实例上设置 crawler 对象。 self.crawler = crawler：将传入的 crawler 对象赋值给 Spider 实例的 crawler 属性。 self.settings = crawler.settings：将 crawler 对象的设置赋值给 Spider 实例的 settings 属性。这样，Spider 可以访问和使用 Scrapy 项目的设置。 crawler.signals.connect(self.close, signals.spider_closed)：这行代码连接了 Spider 的 close 方法到 Scrapy 的 spider_closed 信号。当爬虫关闭时，这个信号会被触发，并调用 Spider 的 close 方法。 在 Scrapy 框架中，from_crawler 方法通常由框架自身调用，用于创建并初始化 Spider 对象。这个过程包括设置爬虫的配置和信号处理等。一般情况下，开发者无需覆盖这个方法，除非需要进行一些特殊的初始化操作。from_crawler 和 _set_crawler 方法是 Scrapy 框架中 Spider 类的重要组成部分，它们负责爬虫的初始化和设置。这些方法确保了每个 Spider 实例可以访问到它所需的资源和配置，同时也使得爬虫能够正确响应 Scrapy 框架的信号。 start_requests 方法start_requests 是一个关键方法，用于生成爬虫启动时的初始请求。这个方法只会在爬虫开始时调用一次。下面是对这个方法的代码和概念的详细解释和整理： 1234567891011121314151617181920def start_requests(self): cls = self.__class__ if not self.start_urls and hasattr(self, &#x27;start_url&#x27;): raise AttributeError( &quot;Crawling could not start: &#x27;start_urls&#x27; not found &quot; &quot;or empty (but found &#x27;start_url&#x27; attribute instead, &quot; &quot;did you miss an &#x27;s&#x27;?)&quot;) if method_is_overridden(cls, Spider, &#x27;make_requests_from_url&#x27;): warnings.warn( &quot;Spider.make_requests_from_url method is deprecated; it &quot; &quot;won&#x27;t be called in future Scrapy releases. Please &quot; &quot;override Spider.start_requests method instead (see %s.%s).&quot; % ( cls.__module__, cls.__name__ ), ) for url in self.start_urls: yield self.make_requests_from_url(url) else: for url in self.start_urls: yield Request(url, dont_filter=True) def start_requests(self): 这是 Scrapy Spider 类中的一个实例方法，用于生成初始的网页请求。 cls = self.__class__: 获取当前实例的类。 if not self.start_urls and hasattr(self, &#39;start_url&#39;): 这个条件检查是否定义了 start_urls 属性。如果 start_urls 没有定义或为空，并且错误地定义了 start_url（缺少末尾的 ‘s’），则抛出异常。 if method_is_overridden(cls, Spider, &#39;make_requests_from_url&#39;): 检查是否重写了 make_requests_from_url 方法。这个方法已被弃用，Scrapy 鼓励使用 start_requests 方法。 warnings.warn(...): 如果使用了弃用的方法，显示警告信息。 for url in self.start_urls: 遍历 start_urls 列表中的每个 URL。 yield self.make_requests_from_url(url): 对于每个 URL，使用 make_requests_from_url 方法生成请求。这是兼容旧代码的方式。 yield Request(url, dont_filter=True): 对于每个 URL，创建一个 Scrapy 的 Request 对象并返回。dont_filter=True 表示对这些请求不应用去重过滤器。 通常，Scrapy 爬虫定义了 start_urls 列表，并依赖 start_requests 方法来为这些 URL 创建初始请求。可以覆盖 start_requests 方法以提供更复杂的启动逻辑，例如从外部数据源读取 URL，或添加特殊的请求头和元数据。 start_requests 方法是 Scrapy 爬虫的起点，负责生成爬虫的初始请求。这个方法应返回一个可迭代对象，其中包含了爬虫开始时需要处理的 Request 对象。通过重写这个方法，开发者可以自定义爬虫的启动行为，例如，从外部文件读取起始 URL，或者添加特定的请求参数和头部 parse 方法这是Scrapy在其请求未指定回调时处理下载的响应时使用的默认回调 12def parse(self, response): raise NotImplementedError(&#x27;&#123;&#125;.parse callback is not defined&#x27;.format(self.__class__.__name__)) parse 是 Scrapy 爬虫中最重要的方法之一。它是默认的回调函数，用于处理由 Scrapy 发出的请求所返回的响应。 当一个请求没有指定特定的回调函数时，Scrapy 会自动调用 parse 方法。 在这个示例中，parse 方法被定义为抛出 NotImplementedError 异常。这是一个通常的做法，用来提示开发者应该在自己的爬虫类中覆盖这个方法，提供具体的实现逻辑。 实际使用中，parse 方法通常包含解析响应（response 对象）并提取数据或进一步生成请求（Request 对象）的逻辑。 parse 是处理响应的默认方法 close 方法 close 方法在爬虫关闭时被调用。它是一个钩子（hook），提供了一种机会在爬虫结束时执行某些操作，比如清理资源、保存状态、发出通知等。 close 方法的具体实现会根据爬虫的需求而有所不同。在 Scrapy 框架的默认实现中，这个方法可能并未显式地定义，但可以根据需要在自定义爬虫中覆盖它。 在开发 Scrapy 爬虫时，通常需要实现 parse 方法来定义如何处理响应。这可能包括解析 HTML、处理数据和生成新的请求。 close 方法则用于定义在爬虫关闭时需要执行的任何清理或结束任务。 close 提供了在爬虫结束时执行操作的机会。 次级页面抓取及数据传递拼接次级页面抓取在 Scrapy 爬虫中，处理多级页面通常涉及以下步骤： 一级页面（列表页） 在列表页，会解析出指向详情页的链接，并对每个链接发起请求以进入二级页面。 二级页面（详情页） 在详情页，会提取所需的具体数据。 这个过程通常在 parse 方法（处理列表页）和一个自定义的回调方法（处理详情页）中实现。 详情页抓取12def get_detail(self, response): pass get_detail 是一个自定义的回调方法，用于处理从列表页提取的详情页链接的响应。 这个方法中，编写解析详情页的逻辑，例如提取特定的数据。 数据提取示例 第一种方式：&#39;//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]&#39;。这个 XPath 查询用于提取比较简单的结构的数据。 第二种方式：&#39;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#39;。这个查询适用于当数据结构更复杂或有多种可能的格式时。它使用了 XPath 的联合操作符 | 来匹配多个可能的路径。 参数的传递拼接 在 Scrapy 中，meta 参数用于在不同的请求之间传递数据。 当从列表页发起对详情页的请求时，可以使用 meta 参数携带需要在详情页中使用的数据。例如，可能想传递从列表页提取的某些上下文信息到详情页。 使用 meta 的示例 12345def parse(self, response): # 提取详情页链接 detail_url = response.xpath(&#x27;some_xpath_to_detail_url&#x27;).get() # 向详情页发起请求，并传递额外的数据 yield scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;&#x27;item&#x27;: &#x27;some_data&#x27;&#125;) 在这个示例中，parse 方法提取了详情页的链接，并发起了一个新的请求。通过设置 meta=&#123;&#39;item&#39;: &#39;some_data&#39;&#125;，任何想从列表页到详情页传递的数据都可以包含在这个 meta 字典中。 在 Scrapy 爬虫中处理多级页面时，通常会在列表页解析出详情页的链接，并为这些链接发起请求。在处理这些请求的回调方法中，会提取详情页的具体数据。使用 meta 参数可以在不同请求之间传递数据，这对于保持爬虫逻辑的连贯性和传递上下文信息非常重要。 豆瓣为例子Spider 文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546import scrapyimport jsonfrom ..items import DbItemclass Db250Spider(scrapy.Spider): name = &#x27;db250&#x27; allowed_domains = [&#x27;movie.douban.com&#x27;] start_urls = [&#x27;https://movie.douban.com/top250&#x27;] page_num = 0 def parse(self, response): node_list = response.xpath(&#x27;//div[@class=&quot;info&quot;]&#x27;) if node_list: for node in node_list: # 标题 movie_name = node.xpath(&#x27;./div/a/span/text()&#x27;).get() # 导演 director = node.xpath(&#x27;./div/p/text()&#x27;).get().strip() # 分数 score = node.xpath(&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;).get() item = DbItem() item[&quot;movie_name&quot;] = movie_name item[&quot;director&quot;] = director item[&quot;score&quot;] = score # 电影详情页 detail_url = node.xpath(&#x27;./div/a/@href&#x27;).get() yield scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;&quot;info&quot;:item&#125;) self.page_num +=1 page_url = &#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;.format(self.page_num*25) yield scrapy.Request(page_url, callback=self.parse) else: return # 详情页解析 def get_detail(self,response): item = DbItem() info = response.meta.get(&quot;info&quot;) item.update(info) description_list = response.xpath(&#x27;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#x27;).getall() description = &#x27;&#x27;.join([des.strip() for des in description_list]) item[&quot;description&quot;] = description yield item 这段代码是一个 Scrapy 爬虫的示例，用于爬取豆瓣电影 Top 250 的相关信息。下面是对这个代码的详细分析： 爬虫定义12345class Db250Spider(scrapy.Spider): name = &#x27;db250&#x27; allowed_domains = [&#x27;movie.douban.com&#x27;] start_urls = [&#x27;https://movie.douban.com/top250&#x27;] page_num = 0 这个类继承自scrapy.Spider，是Scrapy框架中用于创建爬虫的基础类。 class Db250Spider(scrapy.Spider): 这行定义了一个名为Db250Spider的新类，它继承自scrapy.Spider。这意味着Db250Spider是一个Scrapy爬虫，可以继承并使用Scrapy框架提供的所有功能和属性。 name = &#39;db250&#39; 这里设置了爬虫的名字为db250。这个名称是Scrapy项目中唯一的标识符，用于在命令行中指定和运行特定的爬虫。 allowed_domains = [&#39;movie.douban.com&#39;] allowed_domains是一个列表，包含了爬虫允许爬取的域名。这有助于确保爬虫不会跨域爬取。在这个例子中，爬虫只会爬取movie.douban.com域下的页面。 start_urls = [&#39;https://movie.douban.com/top250&#39;] start_urls是一个包含起始URL的列表。当爬虫启动时，Scrapy会自动开始从这些URL发起请求。在这个例子中，爬虫将从豆瓣电影Top 250的主页开始爬取。 page_num = 0 page_num是一个类属性，用于跟踪当前爬取的页码。这在处理分页或需要在多个页面之间导航时非常有用。在这个例子中，它被初始化为0。 接下来在这个爬虫类中定义如parse等方法，以指定如何解析和处理每个请求的响应，以及如何从中提取数据或者进一步生成新的请求。例如，解析豆瓣电影Top 250页面的响应，提取电影信息，然后爬取每个电影的详细页面等。 主页解析方法 parse123456789101112131415161718192021def parse(self, response): node_list = response.xpath(&#x27;//div[@class=&quot;info&quot;]&#x27;) if node_list: for node in node_list: movie_name = node.xpath(&#x27;./div/a/span/text()&#x27;).get() director = node.xpath(&#x27;./div/p/text()&#x27;).get().strip() score = node.xpath(&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;).get() item = DbItem() item[&quot;movie_name&quot;] = movie_name item[&quot;director&quot;] = director item[&quot;score&quot;] = score detail_url = node.xpath(&#x27;./div/a/@href&#x27;).get() yield scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;&quot;info&quot;:item&#125;) self.page_num += 1 page_url = &#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;.format(self.page_num*25) yield scrapy.Request(page_url, callback=self.parse) else: return 0. 方法定义1def parse(self, response): self 是对当前对象实例（即Spider对象）的引用。 response 是一个包含了HTTP响应数据的对象。它包括响应内容（通常是HTML）、URL、HTTP头等信息。 parse方法的主要功能是处理response，提取有用信息，或者进一步生成需要跟进的URL请求。 在这个方法中，通常会使用XPath或CSS选择器来解析响应内容（如提取数据）。 数据提取：可以使用response.xpath()或response.css()方法来选择HTML元素，然后提取所需数据。 生成跟进请求：如果页面中有链接到其他页面，且想爬取那些页面的数据，可以通过scrapy.Request生成新的请求。 parse方法可以返回以下类型的对象： 字典（在Python中通常是通过yield语句生成）。 scrapy.Item对象，这是一个更结构化的方式来管理数据。 Request对象，用于生成新的爬取请求。 或者它们的组合。 parse方法是Scrapy爬虫的核心，用于处理响应并从中提取信息，或者根据页面中的链接生成新的请求。 1. 解析节点列表1node_list = response.xpath(&#x27;//div[@class=&quot;info&quot;]&#x27;) 这行代码使用 XPath 查询从响应中提取所有类属性为 &quot;info&quot; 的 &lt;div&gt; 元素。 这些 &lt;div&gt; 元素包含了电影的主要信息，并存储在 node_list 中。 response: 这通常是一个由Scrapy框架（或类似的库）提供的响应对象。 它代表了一个从网页请求中获得的HTTP响应。 这个对象包含了完整的网页数据，通常是HTML格式。 .xpath(): 这是一个方法，用于对response对象中的HTML内容执行XPath查询。 XPath是一种在XML和HTML文档中查找信息的语言。 通过XPath，可以导航文档的结构，并选择需要的元素、属性等。 &#39;//div[@class=&quot;info&quot;]&#39;: 这是传递给.xpath()方法的XPath查询表达式。 让我们分解这个表达式： //: 这个符号表示选择文档中的所有匹配元素，而不仅仅是直接子元素。它在整个文档中进行搜索。 div: 这指定了想要选择的元素类型。在这种情况下，它是&lt;div&gt;元素。 [@class=&quot;info&quot;]: 这是一个条件（谓语），用来进一步细化选择。它指定只选择那些具有class=&quot;info&quot;属性的&lt;div&gt;元素。 @class: 表示选择元素的class属性。 &quot;info&quot;: 表示属性值必须精确匹配info字符串。 在网页的响应内容中选择所有class属性值为info的&lt;div&gt;元素，并将这些元素存储在node_list变量中。这个列表可以被进一步用于抽取数据、分析或其他处理。在网页抓取和数据提取的过程中，这是一种非常常见的做法。 2. 判断并遍历节点12if node_list: for node in node_list: 首先检查 node_list 是否非空，确保有要处理的节点。 然后遍历这些节点，每个节点 (node) 代表一个电影条目。 if node_list: 这是一个条件语句，检查node_list是否非空。在Python中，空列表（[]）被认为是False，而非空列表被认为是True。 这个条件确保仅当node_list中有元素时，即列表不为空时，才会执行下面的代码块。这是一个良好的编程实践，可以避免在空列表上执行操作时出现错误。 for node in node_list: 这是一个for循环，用于遍历node_list中的每个元素。 在每次迭代中，node变量会被赋予node_list中的当前元素。 如果node_list是由之前提到的response.xpath(&#39;//div[@class=&quot;info&quot;]&#39;)表达式返回的，那么每个node很可能是一个表示HTML &lt;div&gt;元素的对象。这种对象通常提供了进一步提取数据（如文本内容、属性等）的方法。 如果node_list不为空，即至少包含一个元素，那么对于列表中的每个元素（每个&lt;div class=&quot;info&quot;&gt;），执行循环体中的代码。循环体的具体内容没有提供，但通常它会包含进一步处理每个node的代码，例如提取信息、打印数据、存储结果等。 3. 提取电影信息123movie_name = node.xpath(&#x27;./div/a/span/text()&#x27;).get()director = node.xpath(&#x27;./div/p/text()&#x27;).get().strip()score = node.xpath(&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;).get() 提取电影名称：使用 XPath 查询从当前节点 (node) 中提取电影名称。 提取导演信息：获取导演信息，这里使用 .strip() 来移除字符串开头和结尾的空白字符。 提取电影评分：获取电影评分，这里使用 .// 从当前节点的所有子孙节点中查找符合条件的节点。 movie_name = node.xpath(&#39;./div/a/span/text()&#39;).get() 这行代码从当前的node中提取电影名称。 ./div/a/span/text(): XPath查询语句。 ./ 表示从当前节点开始。 div/a/span 定位到一个&lt;span&gt;元素，这个元素是一个&lt;a&gt;元素的子元素，而&lt;a&gt;元素又是一个&lt;div&gt;元素的子元素。 /text() 选择这个&lt;span&gt;元素的文本内容。 .get() 是一个方法，用来获取XPath查询结果的第一个匹配项。 director = node.xpath(&#39;./div/p/text()&#39;).get().strip() 这行代码用来提取导演的名称。 ./div/p/text(): XPath查询语句。 类似于前面的查询，但这次是选择一个&lt;p&gt;元素的文本内容。 .get() 同样获取第一个匹配项的文本。 .strip() 是一个字符串方法，用来移除字符串首尾的空白字符（如空格、换行符等）。 score = node.xpath(&#39;.//span[@class=&quot;rating_num&quot;]/text()&#39;).get() 这行代码用于提取电影评分。 .//span[@class=&quot;rating_num&quot;]/text(): XPath查询语句。 .// 表示在当前节点及其子节点中查找。 span[@class=&quot;rating_num&quot;] 选择所有class属性为rating_num的&lt;span&gt;元素。 /text() 同样选择这些&lt;span&gt;元素的文本内容。 .get() 获取第一个匹配结果。 这三行代码是在遍历一个包含多个节点（每个节点代表一个电影信息）的列表时，用来从每个节点中提取特定信息的标准操作。这种方式在爬虫和数据提取的过程中非常常见，特别是当处理诸如电影列表页面这样的结构化数据时。 4. 创建并填充 Scrapy Item1234item = DbItem()item[&quot;movie_name&quot;] = movie_nameitem[&quot;director&quot;] = directoritem[&quot;score&quot;] = score item = DbItem() 这行代码创建了一个DbItem的实例。通常在Scrapy项目中定义，用于表示提取的数据结构。 在Scrapy中，Item对象用于定义存储爬取数据的结构。它们类似于Python中的字典，但提供额外的保护和便利，如字段定义和类型检查。 item[&quot;movie_name&quot;] = movie_name 这行代码将之前提取的movie_name（电影名称）赋值给item的&quot;movie_name&quot;键。 这意味着DbItem类中定义了一个字段movie_name，用于存储电影名称。 item[&quot;director&quot;] = director 类似地，这行代码将提取的director（导演名称）赋值给item的&quot;director&quot;键。 item[&quot;score&quot;] = score 同样地，这行代码将提取的score（电影评分）赋值给item的&quot;score&quot;键。 创建了一个DbItem实例，并填充了从网页中提取的数据：电影名称、导演和评分。在Scrapy中，这样的item对象通常会被进一步传递到管道（pipelines），在那里可以进行如存储到数据库、进行数据清洗或其他处理的操作。使用Item对象的好处在于它提供了结构化的数据存储方式，有助于维护代码的清晰度和可维护性。 5. 请求电影详情页12detail_url = node.xpath(&#x27;./div/a/@href&#x27;).get()yield scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;&quot;info&quot;:item&#125;) detail_url = node.xpath(&#39;./div/a/@href&#39;).get() 这行代码使用XPath选择器从当前处理的节点（node）中提取详情页面的链接。 ./div/a/@href: XPath查询语句。 ./ 表示从当前节点开始。 div/a 定位到当前节点下的&lt;div&gt;元素中的&lt;a&gt;元素。 @href 获取这个&lt;a&gt;元素的href属性，即链接地址。 .get() 方法从XPath选择器返回的结果中获取第一个匹配项，也就是详情页面的URL。 yield scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;&quot;info&quot;:item&#125;) 这行代码创建一个新的Scrapy请求（Request），用于爬取在detail_url中找到的URL。 scrapy.Request(detail_url, ...) 创建一个新的请求对象，其目标是detail_url。 callback=self.get_detail 设置当请求得到响应时应调用的回调方法为get_detail。这意味着，当Scrapy成功访问detail_url并获得响应时，它将自动调用get_detail方法来处理响应。 meta=&#123;&quot;info&quot;:item&#125; 将一个额外的信息字典&#123;&quot;info&quot;: item&#125;传递给回调方法。这通常用于在不同请求之间传递数据。在这里，item对象（可能包含已经提取的某些数据，如电影名、导演、评分等）被传递到详情页面的处理方法中。 在Scrapy中，yield关键字被用于生成请求而不是直接返回它们。这允许Scrapy处理请求队列，并根据可用的资源和设置来调度这些请求。这种方法使得爬虫能够有效地管理大量的并行请求，同时避免过载目标服务器或被封禁。 信息 在编程中，特别是在异步编程和事件驱动编程中，”callback”（回调函数）是一个非常重要的概念。回调函数是传递给另一个函数或方法的函数，它在那个函数或方法执行完某些操作之后被调用。在不同的编程语言和框架中，回调函数的具体实现和使用方式可能有所不同，但其基本概念是相似的。 回调函数的基本原理 定义回调函数: 回调函数是定义的一个函数，它将在未来的某个时间点被调用。这个函数通常定义了在某些操作完成后应该执行的操作。 将回调函数作为参数传递: 将这个回调函数作为参数传递给另一个函数或方法。这通常发生在希望在那个函数完成其主要操作后执行一些额外操作的情况下。 异步操作或事件处理: 在进行异步操作（如网络请求、文件读写等）或处理事件（如用户输入、定时器触发等）时，回调函数特别有用。在这些情况下，不能立即得到结果，回调函数提供了一种在操作完成时得到通知并执行相关代码的方式。 回调函数的例子 在Python中，回调函数的一个常见例子是在多线程或网络请求中使用： 12345678910import requestsdef on_success(response): print(&quot;Success:&quot;, response.text)def on_error(error): print(&quot;Error:&quot;, error)# 发送异步HTTP请求requests.get(&quot;https://www.example.com&quot;, success=on_success, error=on_error) 在这个例子中，on_success和on_error是回调函数。它们分别在HTTP请求成功时和出错时被调用。 在Scrapy中的回调函数 在Scrapy这类网络爬虫框架中，回调函数用于处理从网页请求中返回的响应。例如： 1234567891011import scrapyclass MySpider(scrapy.Spider): name = &#x27;example_spider&#x27; def start_requests(self): yield scrapy.Request(url=&quot;https://www.example.com&quot;, callback=self.parse) def parse(self, response): # 处理响应的代码 pass 在这里，parse方法是一个回调函数，当Scrapy框架从指定的URL接收到响应时调用。 总的来说，回调函数是一种在某个操作完成后（通常是异步操作）再执行的函数。它们在事件驱动的程序设计中尤为重要，允许程序在等待一个操作完成时继续执行其他任务，并在适当的时候处理操作结果。 6. 分页处理123self.page_num += 1page_url = &#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;.format(self.page_num*25)yield scrapy.Request(page_url, callback=self.parse) self.page_num += 1 这行代码将类属性page_num的值增加1。这个属性用于追踪当前爬取的页数。在每次处理完一个页面后，递增page_num以移至下一个页面。 page_url = &#39;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#39;.format(self.page_num*25) 这里构造了下一个页面的URL。 &#39;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#39;是基本的URL格式。豆瓣电影Top 250页面的分页通过URL参数start实现，其中start表示列表的起始位置。 .format(self.page_num*25)用于插入计算后的起始位置。由于每页显示25部电影，那么每递增一页，start的值应增加25。例如，第一页是从0开始（0*25），第二页是从25开始（1*25），依此类推。 yield scrapy.Request(page_url, callback=self.parse) 这行代码生成了一个新的Scrapy请求，用于爬取下一个页面。 scrapy.Request(page_url, callback=self.parse)创建一个新的请求对象，其目标是page_url。 callback=self.parse指定当请求得到响应时，应该调用parse方法来处理该响应。parse是Scrapy爬虫中的标准方法，用于处理和解析响应内容。 使用yield关键字来生成请求对象，允许Scrapy根据需要来调度和处理这些请求。 在Scrapy中，适当地管理分页是提取多页数据的关键。代码正确地实现了递增页码并构建新页面URL的逻辑。通过在parse方法中重复这个过程，爬虫可以遍历并爬取整个列表的所有页面。 7. 处理结束12else: return 如果 node_list 为空，说明没有更多的电影信息可以处理，函数返回并结束。 如果条件不满足（else部分），return语句会被执行。在Python中，return语句用于从函数返回。如果return后没有任何值或表达式，它默认返回None。在这个上下文中，它表示不再继续生成新的请求，爬虫的这个部分将停止执行。 这个 parse 方法展示了如何在 Scrapy 中处理分页和详情页的链接提取、数据抓取和传递。它有效地结合了 XPath 选择器、Scrapy Item 的使用，以及 Scrapy 的请求和响应机制。 详情页解析方法 get_detail123456789def get_detail(self, response): item = DbItem() info = response.meta.get(&quot;info&quot;) item.update(info) description_list = response.xpath(&#x27;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#x27;).getall() description = &#x27;&#x27;.join([des.strip() for des in description_list]) item[&quot;description&quot;] = description yield item 0. 方法定义1def get_detail(self, response): 这是一个在 Scrapy 爬虫中定义的 get_detail 方法，它是一个回调函数，用于处理电影详情页的响应。 response 参数是 Scrapy 传递给这个方法的响应对象，包含了详情页的数据。 这个方法定义表明get_detail是一个实例方法，用于处理从一个特定的请求返回的响应。这个方法接收一个参数response，它包含了对应请求的HTTP响应。 1. 初始化和更新 Item123item = DbItem()info = response.meta.get(&quot;info&quot;)item.update(info) item = DbItem()：创建一个 DbItem 对象。DbItem 通常是一个在 Scrapy 项目中定义的 Item 类，用于结构化存储提取的数据。继承自scrapy.Item，用于指定希望收集的数据字段。 info = response.meta.get(&quot;info&quot;)：从响应的 meta 属性中获取传递过来的电影基本信息。这些信息之前在处理列表页时已经被提取并通过 meta 参数传递到这个方法。这里从response.meta中提取了之前传递的元数据。response.meta是一个字典，用于在Scrapy的不同请求之间传递数据。在这个例子中，它被用来传递之前页面上已经抓取的数据。 item.update(info)：将获取到的电影基本信息更新到 item 对象中。这行代码将从上一个页面提取的数据（存储在info字典中）合并到新创建的item对象中。 2. 提取电影描述信息12description_list = response.xpath(&#x27;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#x27;).getall()description = &#x27;&#x27;.join([des.strip() for des in description_list]) response.xpath() 方法用于执行XPath查询。它从响应的HTML中选择指定的元素。 XPath查询字符串有两部分，通过（并集运算符）连接： //div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text(): 选取所有id为&quot;link-report&quot;的&lt;div&gt;元素中，类名为&quot;all hidden&quot;的&lt;span&gt;子元素的文本内容。 //div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text(): 选取所有id为&quot;link-report&quot;的&lt;div&gt;元素中，property属性为&quot;v:summary&quot;的&lt;span&gt;子元素的文本内容。 .getall() 方法获取所有匹配的元素的文本内容，返回一个字符串列表 将description_list中的所有文本片段合并成一个单一的字符串。 [des.strip() for des in description_list] 是一个列表推导式，用于遍历description_list中的每个元素（des），并对每个元素应用.strip()方法。.strip()方法移除字符串两端的空白字符（包括空格、换行符等）。 &#39;&#39;.join([...]) 方法将经过清洁的字符串列表连接成一个单一的字符串。空字符串&#39;&#39;作为连接符，意味着直接将文本片段连在一起，没有额外的字符插入。 这段代码的作用是从HTML响应中提取电影描述，可能包括多个文本片段，并将它们清洁和合并为一个完整的描述字符串。这种方法在处理包含多个文本块或可选文本块（例如有些电影可能只有一种描述格式）的HTML页面时非常有用。 3. 设置描述并返回 Item12item[&quot;description&quot;] = descriptionyield item item[&quot;description&quot;] = description 这行代码将之前提取并合并的描述文本（description）赋值给item对象的&quot;description&quot;字段。 item是一个类似于字典的对象，用于存储提取的数据。在Scrapy中，这通常是一个继承自scrapy.Item的类的实例，用来定义和存储爬取的数据结构。 这里，&quot;description&quot;字段是之前定义在DbItem（或类似的Item类）中的一个字段，用于保存电影的描述文本。 yield item 使用yield关键字来产生item对象，将其传递给Scrapy的管道系统（Pipelines）。 在Scrapy中，yield的使用允许框架接管并异步处理这些item对象。这些item随后会通过定义好的管道进行处理，例如进行数据清洗、验证、存储到数据库等操作。 这种基于生成器的方法使得Scrapy能够有效地处理大量数据，并允许多个item同时在管道中进行处理，从而提高整个爬取和数据处理的效率。 这两行代码的作用是将提取的描述文本保存到一个item对象中，并将这个对象传递给Scrapy的后续处理流程，如管道处理。这是Scrapy爬虫中处理和传递数据的常见模式。 Items 文件定义了一个 Scrapy Item 类，名为 DbItem，用于在 Scrapy 爬虫中存储和组织爬取的数据。 123456789import scrapyclass DbItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() movie_name = scrapy.Field() director = scrapy.Field() score = scrapy.Field() description = scrapy.Field() import scrapy: 导入 Scrapy 模块，这是使用 Scrapy 框架的基础。 class DbItem(scrapy.Item): 定义了一个名为 DbItem 的类，该类继承自 scrapy.Item。在 Scrapy 中，Item 类用于定义一种数据结构，使得爬取的数据可以被结构化和标准化。 movie_name = scrapy.Field(): 定义了一个字段 movie_name 来存储电影的名称。使用 scrapy.Field() 表示这是一个用于存储数据的字段。 director = scrapy.Field(): 定义了一个字段 director 用于存储电影的导演信息。 score = scrapy.Field(): 定义了一个字段 score 用于存储电影的评分。 description = scrapy.Field(): 定义了一个字段 description 用于存储电影的详细描述。 在 Scrapy 爬虫中，Item 类被用来收集和整理爬取的数据。例如，在爬取一个电影网站时，可以使用 DbItem 实例来存储每部电影的相关信息。这样的数据结构化处理使得数据的存储、输出和后续处理变得更加方便和标准化。 DbItem 类是 Scrapy 项目中用于定义和存储特定数据结构的方式。它允许爬虫以一种清晰和一致的方式处理爬取的数据。在这个例子中，DbItem 用于存储电影名称、导演、评分和描述等信息，从而使得数据在 Scrapy 爬虫的整个流程中易于处理和维护。 Pipelines 文件定义了一个 Scrapy 的 Pipeline 类，名为 DbPipeline，用于处理由爬虫提取的数据。在 Scrapy 中，Pipeline 用于数据的清洗、验证和存储。 123456789101112import jsonclass DbPipeline: def open_spider(self, spider): self.f = open(&#x27;film.txt&#x27;,&#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) def process_item(self, item, spider): json_str = json.dumps(dict(item), ensure_ascii=False) + &#x27;\\n&#x27; self.f.write(json_str) return item def close_spider(self, spider): self.f.close() 1. 初始化及打开文件12def open_spider(self, spider): self.f = open(&#x27;film.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) class DbPipeline: 定义了一个名为DbPipeline的新类。 def open_spider(self, spider): 这个open_spider方法在爬虫开始时被调用。用于进行一些初始化工作。 self.f = open(&#39;film.txt&#39;,&#39;w&#39;, encoding=&#39;utf-8&#39;): 这个方法打开一个名为film.txt的文件用于写入（’w’模式），并且指定编码为UTF-8。这是为了确保可以正确写入包含非ASCII字符（如中文）的文本。 文件对象被赋值给self.f，这样在这个类的其他方法中也能使用这个文件对象。 2. 处理并存储数据1234def process_item(self, item, spider): json_str = json.dumps(dict(item), ensure_ascii=False) + &#x27;\\n&#x27; self.f.write(json_str) return item def process_item(self, item, spider): 这个方法会被 Scrapy 框架自动调用，每次爬虫提取出一个 item 时都会执行。process_item方法是管道处理每个item的核心方法。 json_str = json.dumps(dict(item), ensure_ascii=False) + &#39;\\n&#39;: 将 item 对象转换成 JSON 字符串。ensure_ascii=False 参数确保非 ASCII 字符（如中文）被正确处理。 self.f.write(json_str): 将 JSON 字符串写入之前打开的文件。然后，这个JSON字符串（json_str）被写入到前面打开的文件中。每个item占一行，因为在字符串末尾添加了换行符\\n。 return item: 返回 item，以便它能够传递到其他可能存在的 pipeline 或最终输出。 3. 关闭文件12def close_spider(self, spider): self.f.close() def close_spider(self, spider): 在爬虫结束时被调用。当爬虫关闭时，Scrapy框架会调用close_spider方法。 self.f.close(): 关闭打开的文件。这是一个重要的步骤，确保数据被完整写入并且文件正常关闭。这个方法关闭了文件对象self.f。这是一个良好的实践，可以确保所有数据都被写入到文件中，并且文件正确地关闭。 在 Scrapy 项目中，Pipeline 类用于处理从爬虫传递过来的数据。在这个例子中，DbPipeline 负责将每个电影的信息以 JSON 格式保存到一个文本文件中。这样的处理方式适合于数据的持久化存储，例如保存到文件、数据库等。 DbPipeline 类演示了 Scrapy 爬虫中如何使用 pipeline 对提取的数据进行进一步的处理和存储。通过在爬虫启动和关闭时执行相关操作，并在提取数据时进行处理，pipeline 为数据的后续使用提供了一个有效的方式。 Settings 文件settings.py 是 Scrapy 项目的配置文件，用于定义爬虫的各种设置。这些设置影响着爬虫的行为方式。 此处删除了大部分注释 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-# Scrapy settings for db projectBOT_NAME = &#x27;db&#x27;SPIDER_MODULES = [&#x27;db.spiders&#x27;]NEWSPIDER_MODULE = &#x27;db.spiders&#x27;# Crawl responsibly by identifying yourself (and your website) on the user-agent#USER_AGENT = &#x27;db (+http://www.yourdomain.com)&#x27;# Obey robots.txt rulesROBOTSTXT_OBEY = False# Override the default request headers:DEFAULT_REQUEST_HEADERS = &#123; &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;, &#x27;Accept-Language&#x27;: &#x27;en&#x27;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36&quot;&#125;# Configure item pipelines# See https://docs.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123; &#x27;db.pipelines.DbPipeline&#x27;: 300,&#125; 基本设置 BOT_NAME = &#39;db&#39;: 定义了爬虫项目的名称，这里是 &#39;db&#39;。 SPIDER_MODULES = [&#39;db.spiders&#39;]: 指定了包含 Scrapy 爬虫的模块。 NEWSPIDER_MODULE = &#39;db.spiders&#39;: 指定了新爬虫的模板搜索路径。 用户代理设置 DEFAULT_REQUEST_HEADERS: 这是默认的请求头部设置。在这里，可以设置 Accept 和 Accept-Language 头部，以及用户代理 (User-Agent)。这有助于模仿常规浏览器请求，避免被目标网站识别为爬虫。 ROBOTSTXT_OBEY = False: 这个设置告诉 Scrapy 是否遵守 robots.txt 规则。在这里，它被设置为 False，意味着爬虫将忽略目标网站的 robots.txt 规则。 Item Pipeline 设置 ITEM_PIPELINES: 这个设置定义了项目中启用的 Item Pipeline。在这里，DbPipeline 被设置为处理 item 的 pipeline，300 表示其优先级。 爬虫项目的目标和请求流程总结目标数据 目标是爬取电影信息以及从次级页面（详情页）获取电影简介。 请求流程 访问一级页面：爬取电影列表页，提取电影的基本信息和指向详情页的 URL。 访问次级页面：访问每部电影的详情页，进一步提取电影的详细简介。 数据存储和一致性 由于 Scrapy 是异步的，页面响应的顺序可能与请求发送的顺序不同。因此，使用 meta 参数在请求间传递数据，保证了数据（如电影的基本信息和详细简介）之间的一致性和关联。 项目案例分析需求 获取腾讯社会招聘的岗位信息 要获取信息的URL并不会显示存在页面中因此要通过开发者模式查看，能发现其有众多异步请求且要获取的信息就在其中 分析排前的请求，在Fetch/XHR下的Preview可以发现图示请求的数据结构与页面内容近似，因此该页面的URL就应该在这个请求的标头中 通过标头构造页面即可开始实施抓取数据，这个URL可以发现拼接了很多参数 分析规律 通过分析每页的URL，发现切换页面的规律 12URL_1 = &#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=1&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27;URL_2 = &#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702289736331&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=2&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27; 可以发现pageIndex是不一样的，一个为1一个为2，那么后续只要利用花括号pageSize=&#123;&#125;传值即可实现页面跳转 同时可以发现URL都存在api因此其都是为接口数据 爬取思路 找到列表页的数据的url 使用scrapy.Request 方法进行请求 解析第二步的响应，提取里面的内容 步骤1. 创建项目首先在终端输入 scrapy startproject tx 其中tx代表项目名称为腾讯缩写 2. 创建爬虫然后输入scrapy genspider tencent_data careers.tencent.com 创建爬虫tencent_data 其爬取域名为careers.tencent.com 3. 编辑爬虫在生成tencent_data.py的爬虫文件下继承自scrapy.Spider命名为TencentDataSpider的类中编辑需要构造的URL，在原本的URL内修改参数pageIndex=1为pageIndex=&#123;&#125;以便分页（页面跳转），将url_data格式化字符串中的pageIndex参数设为1，生成第一页的URL，作为爬虫开始爬取的起始点。 12345678910111213import scrapyclass TencentDataSpider(scrapy.Spider): name = &quot;tencent_data&quot; allowed_domains = [&quot;careers.tencent.com&quot;] url_data = &#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27; start_urls = [url_data.format(1)] def parse(self, response): pass 4. 处理列表列在parse方法中添加一个循环以确定要爬取的页面数量，可以通过循环for来进行。parse 是Scrapy爬虫中默认的回调方法，用于处理响应。该方法通过循环生成接下来四页的URL（从第1页到第4页）。对于每一页，它创建并产生一个新的Scrapy请求 (scrapy.Request)，并指定回调函数为self.parse_data。 123456789101112131415import scrapyclass TencentDataSpider(scrapy.Spider): name = &quot;tencent_data&quot; allowed_domains = [&quot;careers.tencent.com&quot;] url_data = &#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27; start_urls = [url_data.format(1)] def parse(self, response): for i in range(1, 5): next_page_url = self.url_data.format(i) yield scrapy.Request(next_page_url, callback=self.parse_data) 注意 在提供的parse方法中，response参数实际上没有被使用。这是因为该方法的主要目的是生成后续页面的URL，并对每个URL发起新的请求，而不是处理response中的数据。 在常规的Scrapy爬虫中，parse方法通常用于处理响应，从中提取数据或发现新的URL来跟进。但在这个特定的例子中，parse方法仅用于根据初始响应生成一系列后续页面的请求。实际处理这些页面的响应内容的任务被委托给了另一个方法parse_data（在后续定义）。这意味着在这个特定的parse实现中，初始的response对象不包含需要立即处理的相关数据，其主要作用是触发爬虫开始执行后续页面的请求。 显然请求的文件是JSON文件，因此需要编辑方法处理从网页请求中返回的JSON格式的响应。这个方法特别适用于处理返回JSON数据的API响应。 123456789101112131415161718import scrapyclass TencentDataSpider(scrapy.Spider): name = &quot;tencent_data&quot; allowed_domains = [&quot;careers.tencent.com&quot;] url_data = &#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27; start_urls = [url_data.format(1)] def parse(self, response): for i in range(1, 5): next_page_url = self.url_data.format(i) yield scrapy.Request(next_page_url, callback=self.parse_data) def parse_data(self, response): dict_data = response.json() # json.loads(response.text) print(dict_data) parse_data是一个实例方法，与parse方法类似，它是Scrapy框架用于处理响应的回调函数。不同的是，这个方法专门用于处理JSON响应。 response参数是一个包含HTTP响应数据的对象。在Scrapy中，这个对象通常包括响应的内容和其他元数据。 dict_data = response.json()这一行是核心功能。response.json()方法将响应的内容（假定是JSON格式）解析成Python字典。这允许以Python原生的方式访问JSON响应中的数据。 在将JSON响应解析为字典后，可以进一步处理这些数据。例如从字典中提取特定的字段，并将它们存储在Scrapy的Item对象中，或者直接进行数据清洗、转换等操作。 在修改settings.py配置文件的参数为正确后进行调试，发现其response依旧能返回200，然而实际输入的URL和抓取时间戳timestamp并不一样，这说明其对时间戳并不敏感。 如果敏感且失败则需要构造时间戳int(time.time() * 1000) 进行分析调试结果response.json() 返回的数据结构是一个字典且具有数据 但是由于这样数据有太多且杂乱无章，因此在获取数据的时候就进行部分的过滤，只获取Data下的Posts里的部分数据即可，例如名称，地址，时间，详情URL等 1234567891011121314151617181920212223242526272829import scrapyclass TencentDataSpider(scrapy.Spider): name = &quot;tencent_data&quot; allowed_domains = [&quot;careers.tencent.com&quot;] url_data = &#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27; PostURL = &#x27;https://careers.tencent.com/tencentcareer/api/post/ByPostId?timestamp=1701864924030&amp;postId=&#123;&#125;&amp;language=zh-cn&#x27; start_urls = [url_data.format(1)] def parse(self, response): for i in range(1, 5): next_page_url = self.url_data.format(i) yield scrapy.Request(next_page_url, callback=self.parse_data) def parse_data(self, response): dict_data = response.json().get(&quot;Data&quot;).get(&quot;Posts&quot;) # json.loads(response.text) for data in dict_data: item = &#123;&#125; item[&#x27;RecruitPostName&#x27;] = data.get(&#x27;RecruitPostName&#x27;) item[&#x27;LocationName&#x27;] = data.get(&#x27;LocationName&#x27;) item[&#x27;LastUpdateTime&#x27;] = data.get(&#x27;LastUpdateTime&#x27;) item[&#x27;CategoryName&#x27;] = data.get(&#x27;CategoryName&#x27;) PostId = data.get(&#x27;PostId&#x27;) detail_url = self.PostURL.format(PostId) yield scrapy.Request(detail_url, callback=self.parse_post_detail, meta=&#123;&#x27;info&#x27;: item&#125;) response.json()将返回的JSON数据转换为Python字典。 .get(&quot;Data&quot;).get(&quot;Posts&quot;)从这个字典中获取Data键对应的值，然后从Data中获取Posts键对应的值。JSON结构是&#123;&quot;Data&quot;: &#123;&quot;Posts&quot;: [...]&#125;&#125;，这将得到包含职位信息的列表。 遍历dict_data列表中的每个元素（每个元素代表一个职位）。 对于每个职位，创建一个新的字典item，并从data中提取相关字段。 使用PostId来格式化self.PostURL字符串，以创建指向每个职位详情页的URL。 item = &#123;&#125;: 这行代码创建了一个空字典item，用于存储从每个职位信息中提取的数据。这是一种常见的在爬虫中收集数据的方法。 self.PostURL是在访问当前类实例（在这种情况下是TencentDataSpider的实例）的PostURL属性。这意味着PostURL是这个类的实例属性，而非一个局部变量或一个类变量（类变量将会使用类名来访问，比如TencentDataSpider.PostURL）。 从data字典中获取PostId值，然后使用这个PostId来格式化self.PostURL字符串。 PostURL 为 self.PostURL.format(PostId)使用了format方法来插入PostId进行构造 格式化后的URL被存储在detail_url变量中。然后，这个URL被用来生成一个新的请求，该请求被发送到parse_post_detail方法（这是一个假定的方法，用于处理每个职位详情页面的响应） scrapy.Request: 这是Scrapy用来创建新HTTP请求的类。 detail_url是这个新请求的目标URL。这个URL通常是从当前页面提取的，指向一个需要进一步爬取的页面。 callback=self.parse_post_detail: callback参数指定了Scrapy在收到此请求的响应后应该调用的方法。 self.parse_post_detail是定义的爬虫类中的一个方法。当Scrapy处理detail_url的响应时，它会将响应数据传递给parse_post_detail方法。 meta=&#123;&#39;info&#39;: item&#125;: meta是一个字典，用于在Scrapy的不同请求之间传递额外的数据。 在这个例子中，meta字典包含一个键&#39;info&#39;，其值为item。这意味着可以在parse_post_detail方法中通过response.meta[&#39;info&#39;]来访问这个item对象。 这种方式在请求链中保持状态或传递数据时非常有用。 yield: 使用yield关键字来生成请求对象。在Scrapy中，yield的使用使得框架可以接管并异步处理这些请求。 这允许Scrapy根据需要进行请求的调度，而不是立即发出请求，从而更有效地管理网络资源和避免对目标网站造成过大压力。 5. 处理详情页和Items 文件随后定义parse_post_detail方法和构造items.py文件下的类属性 tencent_data.py: 123456789def parse_post_detail(self, response): item = TxItem() info = response.meta.get(&#x27;info&#x27;) item.update(info) dict_data = response.json() item[&#x27;Requirement&#x27;] = dict_data.get(&quot;Data&quot;).get(&#x27;Requirement&#x27;).replace(&#x27;\\r\\n&#x27;, &#x27;&#x27;) item[&#x27;Responsibility&#x27;] = dict_data.get(&quot;Data&quot;).get(&#x27;Responsibility&#x27;).replace(&#x27;\\r\\n&#x27;, &#x27;&#x27;) yield item items.py: 1234567891011121314151617# Define here the models for your scraped items## See documentation in:# https://docs.scrapy.org/en/latest/topics/items.htmlimport scrapyclass TxItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() RecruitPostName = scrapy.Field() LocationName = scrapy.Field() LastUpdateTime = scrapy.Field() CategoryName = scrapy.Field() Requirement = scrapy.Field() Responsibility = scrapy.Field() 然后调试检查查看传值是否成功 调试处理详情页相关方法前需要同时配置Items 文件，不然无法传值 6. 编辑Pipelines在Settings.py文件激活Pipelines后，配置Pipelines文件 123456789101112131415# Define your item pipelines here## Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html# useful for handling different item types with a single interfacefrom itemadapter import ItemAdapterclass TxPipeline: def process_item(self, item, spider): with open(&#x27;tencent.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(str(item)) return item 在Scrapy的管道（Pipeline）中，可以选择用不同的方式来处理文件的打开和关闭。 类定义: class TxPipeline: 定义了一个名为TxPipeline的新类。 这个类是Scrapy的一个管道，它必须实现process_item方法。 process_item方法: def process_item(self, item, spider): 是管道处理每个爬取的项目（item）的方法。 每当爬虫提取出数据并生成item对象时，Scrapy框架会自动调用这个方法，并将item对象和spider对象作为参数传递给它。 文件写入操作: with open(&#39;tencent.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as f: 使用with语句打开文件tencent.txt。如果文件不存在，将会创建它。文件以追加模式（&#39;a&#39;）打开，意味着新写入的内容会被添加到文件的末尾，而不是覆盖原有内容。文件以utf-8编码打开，这对于写入非ASCII字符（例如中文）很重要。 f.write(str(item)) 将item对象转换为字符串，并写入文件。这里需要注意的是，str(item)可能不会以最优雅的格式输出，特别是如果item包含多个字段或嵌套结构时。在实际应用中，可能需要更精细的格式化方法，比如使用json.dumps来生成更可读的JSON格式。 返回项目: return item：在处理完项目后，管道返回item对象。这允许同一个item被多个管道依次处理。在Scrapy中，项目（items）可以通过多个管道传递，每个管道都可以执行一些操作（如清洗数据、去重、写入数据库等）。 使用with语句: 在TxPipeline类中，process_item方法使用了with语句来打开文件： 12with open(&#x27;tencent.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(str(item)) with语句：Python中的with语句用于包裹执行需要资源管理的代码块，比如文件操作。with语句可以确保文件在使用完毕后被正确关闭，即使在处理文件过程中发生错误也是如此。 优点：使用with语句的主要优点是它会自动处理文件的关闭。这种方式在每次process_item被调用时打开文件，写入数据，然后立即关闭文件，非常适合写入少量数据。 缺点：如果process_item被频繁调用，这种方式可能会导致性能问题，因为每次调用都会打开和关闭文件。 使用open_spider和close_spider方法： 在之前的案例DbPipeline类中，文件的打开和关闭是在open_spider和close_spider方法中处理的： 12345def open_spider(self, spider): self.f = open(&#x27;dbtest1result.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)def close_spider(self, spider): self.f.close() open_spider和close_spider方法：这两个方法分别在爬虫开始时和结束时被调用。在这里，文件在爬虫启动时被打开，并在爬虫关闭时被关闭。 优点：这种方式对于处理大量数据更有效，因为它在整个爬虫过程中只打开和关闭文件一次。这减少了文件操作的开销，提高了性能。 缺点：如果爬虫在执行过程中出现异常并意外终止，可能导致文件没有正确关闭。这可能会导致数据丢失或文件损坏。 如果爬虫产生的数据量不大，或者更关心代码的简洁性，使用with语句是一个很好的选择。 如果爬虫产生大量数据，或者希望减少文件操作的开销，使用open_spider和close_spider方法可能更合适。 检查最后运行，产出文件tencent.txt且具有相应的值则成功 数据库存储首先在Ubuntu的MySQL创建一个数据库叫tx mysql&gt; create database tx; 随后检查是否创建成功mysql&gt; show databases;: 然后切换数据库并检查内容： use tx; show tables; 检查无误后按照items.py文件下的TxItem类创建表格即可： 1234567891011# 爬虫存数据 必须要先有表格才能进行数据的增加create table txzp( # 主键 id int primary key auto_increment, RecruitPostName varchar(50), LocationName varchar(50), LastUpdateTime varchar(50), CategoryName varchar(50), Requirement text, Responsibility text) 创建表格后通过show tables;查看当前数据库的表格内容 使用desc txzp; 查看 txzp 表格内的内容属性 建立测试文件tx_debug.py: 123456789101112131415161718192021222324252627282930import pymysql# 建立数据库连接# host: 数据库服务器地址，这里设置为&#x27;localhost&#x27;表示数据库服务在本地# port: 数据库服务端口，默认MySQL端口为3306# user: 用户名，这里使用&#x27;yiuhang_test&#x27;# password: 用户密码，这里为&#x27;Test123..&#x27;# db: 要连接的数据库名，这里为&#x27;tx&#x27;# charset: 设置字符集，这里使用&#x27;utf8&#x27;conn = pymysql.connect(host=&#x27;localhost&#x27;, port=3306, user=&#x27;yiuhang&#x27;, password=&#x27;Test123..&#x27;, db=&#x27;tx&#x27;, charset=&#x27;utf8&#x27;)print(conn) # 打印连接对象，用于验证是否连接成功# 创建一个cursor对象，用于执行查询和获取结果curs = conn.cursor()# 在此处添加数据库操作的CRUD（创建、读取、更新、删除）逻辑# 例如：curs.execute(&quot;SELECT * FROM your_table&quot;)# 提交事务，对于更改数据库的操作（INSERT, UPDATE, DELETE），需要调用commit()来提交更改conn.commit()# 关闭cursor和连接curs.close()conn.close() 这段脚本主要用于建立与MySQL数据库的连接，执行一些数据库操作（CRUD逻辑），然后关闭连接。 pymysql.connect() 函数用于创建与MySQL数据库的连接。 conn.cursor() 方法创建一个游标对象，该对象可以用来执行SQL语句并获取结果。 数据库的实际操作（如查询、插入数据等）需要在获取游标后进行。 执行修改数据库内容的操作（如INSERT, UPDATE, DELETE）后，需要调用 conn.commit() 来提交这些更改。 最后，使用 curs.close() 和 conn.close() 关闭游标和连接，以释放资源。 注意 在运行测试文件前，如果使用虚拟机需要检查3306端口是否已经让虚拟机和主机映射，否则会产生 Mysql Python Connector No connection could be made because the target machine actively refused it 的报错。 当在虚拟机（例如使用VMware）中运行应用程序（如数据库服务器）并希望从主机（物理机器）访问时，需要进行端口映射。这是因为虚拟机通常运行在与主机隔离的网络环境中。端口映射确保从主机到虚拟机的网络通信能够正确进行。 解释端口映射 为什么需要端口映射: 虚拟机通常在私有网络中运行，这意味着它们对主机网络而言是不可见的。 端口映射使得主机可以通过指定的端口访问虚拟机中的服务。 示例解释: MySQL（端口3306）: 假设在虚拟机中运行MySQL服务器，它默认监听3306端口。要从主机上的应用程序连接到这个MySQL服务器，需要将虚拟机的3306端口映射到主机的某个端口（也可以是3306）。 SSH（端口22）: 同理，如果想要通过SSH连接到虚拟机，需要将虚拟机的22端口映射到主机的某个端口（也可以是22）。 端口映射的步骤 打开VMware的虚拟网络编辑器。 选择用于虚拟机的网络适配器（通常是NAT模式）。 进入NAT设置，然后设置端口转发规则。 添加规则：指定主机端口，目标IP（虚拟机IP）和虚拟机端口。 如果是服务器而非虚拟机 物理服务器: 如果数据库运行在物理服务器上，通常不需要端口映射，因为服务器与本地机器或其他服务器都在同一网络或可通过互联网直接访问。 需要注意的是安全设置，如防火墙规则，确保只有授权的客户端能够访问特定端口。 云服务器: 在云平台（如AWS、Azure）上，可能需要配置安全组或网络安全规则来允许特定端口（如3306）的流量。 这类似于在物理服务器上设置防火墙规则。 在所有情况下，重要的是确保只有信任的客户端能够访问敏感服务（如数据库服务器），并且采用强密码和加密连接（如SSL）来保护数据安全。 配置步骤1. 在 settings.py 中配置MySQL信息在Scrapy项目的settings.py文件中，配置数据库连接信息。这是一个字典，包含连接数据库所需的所有信息。 123456789101112# 配置mysql链接信息DATABASE_CONFIG = &#123; &#x27;type&#x27;: &#x27;mysql&#x27;, # 使用的是哪一个数据库类型 &#x27;config&#x27;: &#123; &#x27;host&#x27;: &#x27;localhost&#x27;, # 数据库服务器地址 &#x27;port&#x27;: 3306, # 数据库服务器端口，MySQL默认为3306 &#x27;user&#x27;: &#x27;yiuhang&#x27;, # 数据库用户名 &#x27;password&#x27;: &#x27;Test123..&#x27;, # 数据库密码 &#x27;db&#x27;: &#x27;tx&#x27;, # 数据库名 &#x27;charset&#x27;: &#x27;utf8&#x27;, # 数据库编码 &#125;&#125; 2. 在 pipelines.py 中创建MySQL存储的类在pipelines.py文件中，创建一个Pipeline类，该类负责在爬虫开始时连接数据库，在处理每个item时存储数据，以及在爬虫结束时关闭数据库连接。注释掉之前的配置。 1234567891011121314import pymysqlclass TxzpPipeline: def open_spider(self, spider): # 此方法在爬虫开启时调用 pass def process_item(self, item, spider): # 对每个爬取的item调用此方法 pass def close_spider(self, spider): # 此方法在爬虫关闭时调用 pass 3. 注册Pipeline在settings.py文件中，将Pipeline添加到ITEM_PIPELINES设置中。这里的数字表示优先级，范围是0到1000。注释掉之前的配置。 123ITEM_PIPELINES = &#123; &quot;tx.pipelines.TxzpPipeline&quot;: 300,&#125; 4. 编写连接MySQL的逻辑在TxzpPipeline类中，实现数据库连接和关闭逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243import pymysqlclass TxzpPipeline: def open_spider(self, spider): &quot;&quot;&quot; 在爬虫开启时调用此方法，用于建立数据库连接。 此方法从spider的设置中获取数据库配置信息，并建立连接。 &quot;&quot;&quot; # 从爬虫的设置中获取数据库配置 data_config = spider.settings.get(&quot;DATABASE_CONFIG&quot;) # 检查配置类型是否为MySQL，确保我们使用正确的配置 if data_config.get(&#x27;type&#x27;) == &#x27;mysql&#x27;: # 使用提供的配置参数建立MySQL连接 self.conn = pymysql.connect(**data_config.get(&#x27;config&#x27;)) # 创建一个数据库操作游标 self.cursor = self.conn.cursor() def process_item(self, item, spider): &quot;&quot;&quot; 对每个从爬虫爬取的item调用此方法。 这里可以添加将item保存到数据库的逻辑。 &quot;&quot;&quot; # 示例：保存逻辑（需实现） # sql = &quot;INSERT INTO table_name (column1, column2) VALUES (%s, %s)&quot; # self.cursor.execute(sql, (item[&#x27;field1&#x27;], item[&#x27;field2&#x27;])) # self.conn.commit() return item def close_spider(self, spider): &quot;&quot;&quot; 在爬虫结束时调用此方法，用于关闭数据库连接。 &quot;&quot;&quot; # 关闭数据库操作游标 self.cursor.close() # 关闭数据库连接 self.conn.close() open_spider 方法： 在爬虫启动时被Scrapy框架自动调用。 从spider的设置 (settings.py) 中获取名为DATABASE_CONFIG的数据库配置信息。 如果配置类型是MySQL（&#39;type&#39;: &#39;mysql&#39;），则使用这些配置信息（如主机、端口、用户名、密码等）建立数据库连接。 创建一个用于执行数据库操作的游标。 方法定义：open_spider(self, spider) 作用：open_spider是一个特殊的Scrapy方法，它在爬虫启动时自动调用。这是设置爬虫运行前所需资源的理想位置，例如建立数据库连接。 参数：self指向类的实例，而spider是当前运行的爬虫实例。通过spider，可以访问Scrapy项目的设置和其他与爬虫相关的属性。 获取数据库配置：data_config = spider.settings.get(&quot;DATABASE_CONFIG&quot;) 作用：这一行从Scrapy的settings.py文件中获取数据库配置信息。将配置放在settings.py中可以集中管理配置，并在需要时轻松更改，而无需修改代码本身。 为什么重要：这种做法增加了代码的灵活性和可维护性，因为可以在不同环境（如开发、测试、生产）中使用不同的数据库配置，而无需更改代码。 检查配置类型：if data_config.get(&#39;type&#39;) == &#39;mysql&#39;: 作用：这个条件检查确保从settings.py中获取的配置是为MySQL数据库设计的。这是一个安全措施，以防配置被错误地设置。 为什么重要：在可能有多种数据库配置的情况下（例如MySQL、PostgreSQL等），这个检查确保Pipeline使用正确的配置。这有助于避免运行时错误和配置混淆。 建立MySQL连接：self.conn = pymysql.connect(**data_config.get(&#39;config&#39;)) 作用：这行代码使用pymysql模块建立到MySQL数据库的连接。**data_config.get(&#39;config&#39;)是一个字典解包操作，它将配置字典中的键值对作为参数传递给pymysql.connect函数。 为什么重要：建立数据库连接是进行数据库操作的首要步骤。使用pymysql模块可以方便地与MySQL数据库交互。这种方法的优点是可以直接从配置文件中读取连接信息，提高了代码的可读性和可维护性。 创建数据库游标：self.cursor = self.conn.cursor() 作用：创建一个数据库游标对象，该对象允许在数据库中执行SQL命令并处理结果。 为什么重要：游标是执行和管理数据库操作的关键。它不仅允许执行SQL语句，还能帮助有效地检索查询结果。在Scrapy中，通常会在process_item方法中使用此游标执行数据库操作。 process_item 方法： 对爬虫爬取的每个item调用此方法。 这是数据处理和保存的主要地方。在这个方法中，可以编写将爬取的数据（item）保存到MySQL数据库的逻辑。 在这个示例中，该方法仅返回item，需要根据具体需求来实现数据插入的逻辑。 close_spider 方法： 在爬虫结束时被Scrapy框架自动调用。 关闭数据库游标和连接，确保释放资源。 5.编写存储逻辑实现process_item方法以将每个item存储到MySQL数据库。 12345678910111213def process_item(self, item, spider): # 定义插入数据的SQL语句 sql = &quot;INSERT INTO txzp(RecruitPostName, LocationName, LastUpdateTime, CategoryName, Requirement, Responsibility) VALUES(%s,%s,%s,%s,%s,%s)&quot; params = [ item.get(&#x27;RecruitPostName&#x27;), item.get(&#x27;LocationName&#x27;), item.get(&#x27;LastUpdateTime&#x27;), item.get(&#x27;CategoryName&#x27;), item.get(&#x27;Requirement&#x27;), item.get(&#x27;Responsibility&#x27;), ] self.cursor.execute(sql, params) self.conn.commit() 方法定义1def process_item(self, item, spider): process_item：这是Scrapy框架中Pipeline对象的一个核心方法，用于处理从爬虫传递过来的每个item。 self：指向当前类（TxzpPipeline）的实例。 item：这是一个从爬虫传递到Pipeline的数据项。它通常是一个类似字典的对象，包含了爬虫提取的数据。 spider：引用当前的爬虫实例，允许访问爬虫特定的功能或数据。 SQL 语句的定义1sql = &quot;INSERT INTO txzp(RecruitPostName, LocationName, LastUpdateTime, CategoryName, Requirement, Responsibility) VALUES(%s,%s,%s,%s,%s,%s)&quot; 这行代码定义了一个SQL插入语句，用于将数据插入到名为txzp的MySQL表中。 INSERT INTO txzp：指定要插入数据的表名。 (RecruitPostName, LocationName, LastUpdateTime, CategoryName, Requirement, Responsibility)：这些是表中的列名，将为这些列插入数据。 VALUES(%s,%s,%s,%s,%s,%s)：这是参数化的查询部分，%s是占位符，用于在执行时插入实际的数据值。 准备数据12345678params = [ item.get(&#x27;RecruitPostName&#x27;), item.get(&#x27;LocationName&#x27;), item.get(&#x27;LastUpdateTime&#x27;), item.get(&#x27;CategoryName&#x27;), item.get(&#x27;Requirement&#x27;), item.get(&#x27;Responsibility&#x27;),] 这部分代码创建了一个列表params，包含了要插入到数据库中的数据。 item.get(&#39;RecruitPostName&#39;)等语句从item对象中提取相应的数据。get方法用于安全地访问字典键值，即使键不存在也不会引发错误。 执行SQL语句1self.cursor.execute(sql, params) 使用之前创建的数据库游标self.cursor来执行SQL语句。 execute方法执行前面定义的SQL语句，并用params列表中的值替换占位符%s。 这种参数化查询方法可以有效防止SQL注入攻击，比直接将字符串拼接到SQL语句更安全。 提交事务1self.conn.commit() 调用self.conn.commit()来提交事务，确保更改被保存到数据库。 在数据库操作中，commit是一个重要步骤，它使得执行的操作（如插入、更新、删除）成为永久性的。 如果不调用commit，那么即使执行了SQL语句，数据也不会被实际保存到数据库中。 执行确认执行测试文件tx_debug.py 连接成功后执行测试文件db_debug.py 随后连接Linux检查数据库是否存储数据即可 Scray Request 类Scrapy的Request类是用于表示一个HTTP请求的基本类。以下是其构造函数的参数和一些特殊的meta键值的详细说明： 构造函数参数 url (str): 请求的URL。 callback (callable): 当请求成功时，Scrapy将调用此回调函数处理响应。 method (str): HTTP方法（如&#39;GET&#39;, &#39;POST&#39;等）。默认为&#39;GET&#39;。 headers (dict): 自定义的请求头。 body (str 或 unicode): 请求体内容。如果未提供，默认为空字符串。 cookies (dict 或 [dict]): 请求时附带的cookies。 meta (dict): 包含此请求的额外信息，可以在不同的回调函数间共享。 encoding (str): 编码类型，默认为&#39;utf-8&#39;。用于URL编码和将body转换为bytes。 priority (int): 请求的优先级。数字越大优先级越高，默认为0。 dont_filter (bool): 如果设置为True，则不会对请求进行去重过滤。 errback (callable): 如果请求过程中发生错误，将调用此函数。 flags (list): 一组字符串标志，通常用于日志记录或调试。 cb_kwargs (dict): 传递给回调函数的关键字参数。 123456789from scrapy.http import Request,FormRequest&quot;&quot;&quot;class Request(object_ref): def __init__(self, url, callback=None, method=&#x27;GET&#x27;, headers=None, body=None, cookies=None, meta=None, encoding=&#x27;utf-8&#x27;, priority=0, dont_filter=False, errback=None, flags=None, cb_kwargs=None):&quot;&quot;&quot; Request.meta 的特殊键值 dont_redirect (bool): 不处理HTTP重定向。 dont_retry (bool): 不对失败的HTTP请求进行重试。 handle_httpstatus_list (list): 包含HTTP状态码的列表，这些状态码的响应将不被视为错误。 handle_httpstatus_all (bool): 处理所有HTTP状态码。 dont_merge_cookies (bool): 不合并此请求的cookies。 cookiejar (int&#x2F;object): 指定用于此请求的cookie jar。 dont_cache (bool): 禁止对此请求使用HTTP缓存。 redirect_reasons (list): 跟踪重定向的原因。 redirect_urls (list): 存储请求过程中的所有重定向URL。 bindaddress (tuple): 指定用于出站连接的本地IP地址和端口。 dont_obey_robotstxt (bool): 不遵守robots.txt规则。 download_timeout (float): 设置下载超时时间。 download_maxsize (int): 设置允许下载的最大字节数。 download_latency (float): 设置下载延迟。 download_fail_on_dataloss (bool): 如果出现数据丢失，下载失败。 proxy (str): 设置此请求的代理服务器。 ftp_user (str): FTP请求的用户名。 ftp_password (str): FTP请求的密码。 referrer_policy (str): 设置引用策略。 max_retry_times (int): 设置请求最大重试次数。 FormRequest 类Scrapy框架中的FormRequest类，它是Request类的一个子类，专门用于处理表单请求。 FormRequest是Scrapy用来发送数据到表单的特殊请求类型。它继承自基本的Request类，并添加了处理表单数据的特定功能。 构造函数参数 \\*args 和 \\**kwargs: 这些是Python中的标准参数，允许接收任意数量的位置参数（*args）和关键字参数（**kwargs）。这在继承时使得FormRequest可以接收Request类接受的所有参数。 formdata (dict 或 类似于列表的元组对): 这是用于传递表单数据的关键字参数。如果提供了formdata，FormRequest将以application/x-www-form-urlencoded格式编码这些数据并包含在请求体中。 如果method未指定且formdata存在，则默认将请求方法设置为POST。 方法逻辑 检查formdata和method: 如果提供了formdata且未指定method，则默认将method设置为POST。 调用基类构造函数: 使用super(FormRequest, self).__init__(*args, **kwargs)调用基类（Request）的构造函数，确保所有基本的初始化逻辑被执行。 处理formdata: 如果提供了formdata，它将被转换为查询字符串。 对于POST请求，这个查询字符串将被设置为请求体，同时设置Content-Type头为application/x-www-form-urlencoded。 对于非POST请求（例如GET），查询字符串将被附加到URL上。 特别说明 valid_form_methods 是一个类属性，定义了FormRequest支持的HTTP方法。默认为[&#39;GET&#39;, &#39;POST&#39;]。 _urlencode 函数用于将表单数据转换为URL编码的字符串。 _set_body 和 _set_url 是内部方法，用于设置请求体和更新请求URL。 FormRequest通常用于向网站提交表单，例如登录页面、搜索查询等。由于它自动处理表单数据的编码，因此相比于普通的Request，在处理表单请求时更加方便。 在使用scrapy发动POST请求的时候,常使用此方法,能较方便的发送请求.具体的使用,见登录github案例; 123456789101112131415161718class FormRequest(Request): valid_form_methods = [&#x27;GET&#x27;, &#x27;POST&#x27;] def __init__(self, *args, **kwargs): formdata = kwargs.pop(&#x27;formdata&#x27;, None) if formdata and kwargs.get(&#x27;method&#x27;) is None: kwargs[&#x27;method&#x27;] = &#x27;POST&#x27; super(FormRequest, self).__init__(*args, **kwargs) if formdata: items = formdata.items() if isinstance(formdata, dict) else formdata querystr = _urlencode(items, self.encoding) if self.method == &#x27;POST&#x27;: self.headers.setdefault(b&#x27;Content-Type&#x27;, b&#x27;application/x-www-form-urlencoded&#x27;) self._set_body(querystr) else: self._set_url(self.url + (&#x27;&amp;&#x27; if &#x27;?&#x27; in self.url else &#x27;?&#x27;) + querystr) HTTP响应处理当使用Scrapy或类似的网络爬虫框架时，处理HTTP响应是一个常见的任务。以下是响应对象的主要属性和方法： url（字符串）: 此响应的URL。 status（整数）: 响应的HTTP状态码。默认为200。 headers（字典）: 此响应的响应头。可以是单值或多值。 body（字节）: 响应主体。为字节类型，可使用response.text以字符串形式访问。 flags（列表）: 包含初始响应标志的列表。 request（Request对象）: 表示生成此响应的请求。 属性和方法 url: 包含请求URL的字符串。只读。 method: 表示HTTP方法的字符串。 headers: 请求头的类似字典对象。 body: 包含请求正文的字符串。只读。 meta: 包含请求的任意元数据的字典。 copy(): 返回此请求的副本。 replace(): 返回一个具有更新字段的新请求。 Scrapy日志配置和使用在Scrapy项目中，正确配置和使用日志是监控爬虫行为、调试和记录关键信息的重要方面。 日志文件配置在Scrapy的settings.py文件中，可以配置以下日志相关的设置： LOG_FILE: 设置日志输出文件的路径。如果设置为None，日志将输出到控制台。 LOG_ENABLED: 控制是否启用日志记录，布尔值，默认为True。 LOG_ENCODING: 设置日志文件的编码，默认为&#39;utf-8&#39;。 LOG_LEVEL: 设置日志级别，默认为&#39;DEBUG&#39;。其他级别包括&#39;INFO&#39;、&#39;WARNING&#39;、&#39;ERROR&#39;、&#39;CRITICAL&#39;。 LOG_FORMAT: 自定义日志的格式。格式选项包括： %(levelno)s: 日志级别的数值。 %(levelname)s: 日志级别名称。 %(pathname)s: 执行程序的路径。 %(filename)s: 执行程序名。 %(funcName)s: 日志的当前函数。 %(lineno)d: 日志的当前行号。 %(asctime)s: 日志记录的时间。 %(thread)d: 线程ID。 %(threadName)s: 线程名称。 %(process)d: 进程ID。 %(message)s: 日志信息。 %(name)s: 日志记录器的名称。 LOG_DATEFORMAT: 设置日志的日期格式。 LOG_STDOUT: 布尔值，控制是否将标准输出（stdout）重定向到日志，通常设为False。 LOG_SHORT_NAMES: 布尔值，设置为True时，日志记录器将使用短名称。 Python日志模块12345678910111213141516171819202122import logging# 创建logger对象logger = logging.getLogger(&#x27;hello&#x27;)# 创建日志处理器：控制台和文件streamH = logging.StreamHandler()fileH = logging.FileHandler(&#x27;test_log.txt&#x27;)# 设置日志格式formatter = logging.Formatter(&#x27;时间:%(asctime)s -- 日志级别:%(levelname)s -- 报错信息:%(message)s&#x27;)# 将格式应用到日志处理器streamH.setFormatter(formatter)fileH.setFormatter(formatter)# 将处理器添加到loggerlogger.addHandler(streamH)logger.addHandler(fileH)if __name__ == &#x27;__main__&#x27;: logger.error(&quot;我真的知道错误&quot;) 在这个示例中，创建了一个名为hello的日志记录器。 两个处理器（StreamHandler和FileHandler）分别用于输出日志到控制台和文件。 使用Formatter设置了日志的格式。 日志记录器通过添加这些处理器来启用日志记录。 项目中的常见设置12LOG_FILE = &#x27;logfile_name.log&#x27;LOG_LEVEL = &#x27;INFO&#x27; logger: Scrapy在每个Spider实例中提供了一个可用的logger实例，用于记录日志。 注意事项 在生产环境中，通常将日志级别设置为INFO或WARNING，以减少日志文件的大小。 保证日志记录的详细程度与应用程序的需求相符，同时避免记录过于敏感的信息，如用户凭据等。 日志文件的管理（如归档和清理）也是重要的，以避免日志文件占用过多磁盘空间。 GitHub登录过程分析与实现登录分析首先前往GitHub https://github.com/login 进行登录操作，检查登录的过程提交的数据 可以发现其在登录的过程中进行了POST请求，并提交表单到 https://github.com/session。关键在于准确地捕获并发送所有必要的表单参数。 检查其Payload可以查看到其参数和对应的值 由于密码和账户组合有三种情况，因此通过分别保持密码和账户相同分别再进行两次请求，并查看它们的值 比较三者的不同可以发现其是authenticity_token ，login，password，required_field_####，timestamp和timestamp_secret，因此需要在后面进行构造 登录参数因此登录GitHub时，提交的表单数据不仅包含用户名和密码，还包括一些隐藏字段，如authenticity_token、timestamp和timestamp_secret。这些字段可能是为了安全性（如防止CSRF攻击）而设置的。 一个典型的登录请求包含以下参数： 12345678910111213form_data = &#123; &quot;commit&quot;: &quot;Sign in&quot;, &quot;authenticity_token&quot;: authenticity_token, &quot;login&quot;: ACCOUNT, # 用户名 &quot;password&quot;: PASSWORD, # 密码 &quot;webauthn-support&quot;: &quot;supported&quot;, &quot;webauthn-iuvpaa-support&quot;: &quot;unsupported&quot;, &quot;return_to&quot;: &quot;&quot;, &quot;required_field_####&quot;: &quot;&quot;, &quot;timestamp&quot;: timestamp, &quot;timestamp_secret&quot;: timestamp_secret,&#125; form_data 数据来源这些数据大部分可以在访问 https://github.com/login 页面时从页面HTML中捕获。特别是authenticity_token、required_field_、timestamp和timestamp_secret是动态生成的，因此每次登录前都需要先访问登录页面来获取这些数据。 请求流程请求流程 访问 https://github.com/login 以获取登录所需的参数。 向 https://github.com/session 提交POST请求，携带用户名、密码及其他必需数据。 Scrapy实现编辑爬虫文件12345678910111213141516171819202122232425262728293031323334353637383940414243import scrapyfrom git.spiders import USER# from git.spiders import USERclass GithubLoginSpider(scrapy.Spider): name = &quot;github_login&quot; allowed_domains = [&quot;github.com&quot;] start_urls = [&quot;https://github.com/login&quot;] def parse(self, response): authenticity_token = response.xpath(&#x27;//input[@name=&quot;authenticity_token&quot;]/@value&#x27;).get() required_field = response.xpath(&#x27;//input[@type=&quot;text&quot; and @hidden=&quot;hidden&quot; ]/@name&#x27;).get() timestamp = response.xpath(&#x27;//input[@name=&quot;timestamp&quot;]/@value&#x27;).get() timestamp_secret = response.xpath(&#x27;//input[@name=&quot;timestamp_secret&quot;]/@value&#x27;).get() form_data = &#123; &quot;commit&quot;: &quot;Sign in&quot;, &#x27;authenticity_token&#x27;: authenticity_token, &quot;login&quot;: USER.LOGIN, &quot;password&quot;: USER.PASSWORD, &quot;webauthn-conditional&quot;: &quot;undefined&quot;, &quot;javascript-support&quot;: &quot;true&quot;, &quot;webauthn-support&quot;: &quot;supported&quot;, &quot;webauthn-iuvpaa-support&quot;: &quot;unsupported&quot;, &quot;return_to&quot;: &quot;https://github.com/login&quot;, &#x27;allow_signup&#x27;: &#x27;&#x27;, &#x27;client_id&#x27;: &#x27;&#x27;, &#x27;integration&#x27;: &#x27;&#x27;, required_field: &#x27;&#x27;, &quot;timestamp&quot;: timestamp, &quot;timestamp_secret&quot;: timestamp_secret, &#125; yield scrapy.FormRequest(url=&quot;https://github.com/session&quot;, formdata=form_data, callback=self.login) def login(self, response): print(response) if &#x27;CosmicTrace&#x27; in response.text: print(&quot;已成功拿到值&quot;) else: print(&#x27;失敗了&#x27;) print(response) 代码解析1234class GithubLoginSpider(scrapy.Spider): name = &quot;github_login&quot; allowed_domains = [&quot;github.com&quot;] start_urls = [&quot;https://github.com/login&quot;] 定义了一个名为GithubLoginSpider的Scrapy爬虫类。 name属性设置为&quot;github_login&quot;，是爬虫的唯一标识。 allowed_domains列表限制了爬虫只能爬取&quot;github.com&quot;域名下的页面。 start_urls包含了爬虫开始爬取的URL，这里是GitHub的登录页面。 12345def parse(self, response): authenticity_token = response.xpath(&#x27;//input[@name=&quot;authenticity_token&quot;]/@value&#x27;).get() required_field = response.xpath(&#x27;//input[@type=&quot;text&quot; and @hidden=&quot;hidden&quot; ]/@name&#x27;).get() timestamp = response.xpath(&#x27;//input[@name=&quot;timestamp&quot;]/@value&#x27;).get() timestamp_secret = response.xpath(&#x27;//input[@name=&quot;timestamp_secret&quot;]/@value&#x27;).get() parse是Scrapy爬虫的默认回调方法，爬虫向一个URL发出请求时，获得的响应会自动传递给这个方法。在这个例子中，response 对象包含了对 start_urls 中URL的HTTP响应。 这几行代码使用XPath从登录页面的HTML中提取了authenticity_token、required_field、timestamp和timestamp_secret。这些字段通常用于防止跨站请求伪造（CSRF）攻击。 response.xpath(&#39;//input[@name=&quot;authenticity_token&quot;]/@value&#39;).get() //input[@name=&quot;authenticity_token&quot;]：这部分的XPath查找文档中所有&lt;input&gt;元素，其中name属性等于&quot;authenticity_token&quot;。//表示在整个文档中查找，而不仅限于某个特定部分。 /@value：这部分表示从找到的&lt;input&gt;元素中提取value属性。在HTML中，&lt;input&gt;标签的value属性通常用来存储输入字段的值。 .get()：这是Scrapy的Selector对象的方法，用于提取XPath选择器的第一个匹配结果。如果没有匹配的元素，它将返回None。 response.xpath(&#39;//input[@type=&quot;text&quot; and @hidden=&quot;hidden&quot;]/@name&#39;).get() //input[@type=&quot;text&quot; and @hidden=&quot;hidden&quot;]：这个XPath查找所有&lt;input&gt;元素，它们的type属性为&quot;text&quot;且同时拥有hidden=&quot;hidden&quot;属性。这通常是隐藏的表单字段，对用户不可见，但对于表单提交可能是必需的。 /@name：这表示提取这些&lt;input&gt;元素的name属性。 .get()：同样，这是用来获取第一个匹配结果的Scrapy方法。 response.xpath(&#39;//input[@name=&quot;timestamp&quot;]/@value&#39;).get() //input[@name=&quot;timestamp&quot;]：这个XPath寻找所有&lt;input&gt;元素，其name属性为&quot;timestamp&quot;。这通常用于跟踪表单的创建或提交时间。 /@value：提取这些&lt;input&gt;元素的value属性。 .get()：获取第一个匹配结果。 response.xpath(&#39;//input[@name=&quot;timestamp_secret&quot;]/@value&#39;).get() //input[@name=&quot;timestamp_secret&quot;]：查找所有&lt;input&gt;元素，其name属性为&quot;timestamp_secret&quot;。这个值可能是与timestamp相关的加密或哈希值。 /@value：提取value属性。 .get()：获取第一个匹配结果。 1234567891011121314151617form_data = &#123; &quot;commit&quot;: &quot;Sign in&quot;, &#x27;authenticity_token&#x27;: authenticity_token, &quot;login&quot;: USER.LOGIN, &quot;password&quot;: USER.PASSWORD, &quot;webauthn-conditional&quot;: &quot;undefined&quot;, &quot;javascript-support&quot;: &quot;true&quot;, &quot;webauthn-support&quot;: &quot;supported&quot;, &quot;webauthn-iuvpaa-support&quot;: &quot;unsupported&quot;, &quot;return_to&quot;: &quot;https://github.com/login&quot;, &#x27;allow_signup&#x27;: &#x27;&#x27;, &#x27;client_id&#x27;: &#x27;&#x27;, &#x27;integration&#x27;: &#x27;&#x27;, required_field: &#x27;&#x27;, &quot;timestamp&quot;: timestamp, &quot;timestamp_secret&quot;: timestamp_secret,&#125; commit: 表单提交按钮的值，通常在登录表单中可以找到。 authenticity_token: 一个安全令牌，用于防止CSRF攻击，从登录页面的HTML中提取。 login: GitHub的用户名，USER.LOGIN应该替换为实际的用户名。 password: GitHub的密码，USER.PASSWORD应该替换为实际的密码。 webauthn-conditional, javascript-support, webauthn-support, webauthn-iuvpaa-support: 这些字段可能与GitHub的特定前端逻辑相关，例如Web认证和JavaScript支持。 return_to: 登录后应重定向到的URL。 allow_signup, client_id, integration: 这些可能是额外的表单字段，用于GitHub的内部跟踪或逻辑。 required_field: 之前从页面提取的隐藏字段，其确切意图可能是内部验证。 timestamp 和 timestamp_secret: 与表单提交时效性和安全性相关的字段。 1yield scrapy.FormRequest(url=&quot;https://github.com/session&quot;, formdata=form_data, callback=self.login) 这行代码创建了一个Scrapy的FormRequest对象，用于向GitHub的https://github.com/session URL发送一个POST请求。 formdata=form_data 指定了要发送的表单数据。 callback=self.login 指定了Scrapy在收到响应后应调用的方法。self.login方法将处理登录请求的响应。 1234567def login(self, response): if &#x27;CosmicTrace&#x27; in response.text: print(response) print(&quot;已成功拿到值&quot;) else: print(&#x27;失敗了&#x27;) print(response) def login(self, response): - 这行定义了一个名为 login 的方法。由于存在 self 参数，可以判断这个方法属于某个类，并且这个方法接受一个参数 response。 if &#39;CosmicTrace&#39; in response.text: - 这行代码检查 response.text 中是否包含字符串 ‘CosmicTrace’。如果包含，意味着满足了某种成功的条件。 print(&quot;已成功拿到值&quot;) - 如果在 response.text 中找到了字符串，就打印出 “已成功拿到值”，表示操作成功。 else: - 如果在 response.text 中没有找到字符串 ‘CosmicTrace’，则执行这部分代码。 print(&#39;失敗了&#39;) - 如果没有找到字符串，就打印出 ‘失敗了’，即“失败了”。 print(response) - 这行代码会在执行完if-else条件后打印整个 response 对象。这对于调试或记录日志很有用，可以查看请求的完整响应。 测试文件编辑调试文件 1234from scrapy.cmdline import executeexecute([&#x27;scrapy&#x27;, &#x27;crawl&#x27;, &#x27;github_login&#x27;]) Settings 文件编辑配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# Scrapy settings for git project## For simplicity, this file contains only settings considered important or# commonly used. You can find more settings consulting the documentation:## https://docs.scrapy.org/en/latest/topics/settings.html# https://docs.scrapy.org/en/latest/topics/downloader-middleware.html# https://docs.scrapy.org/en/latest/topics/spider-middleware.htmlBOT_NAME = &quot;git&quot;SPIDER_MODULES = [&quot;git.spiders&quot;]NEWSPIDER_MODULE = &quot;git.spiders&quot;# Crawl responsibly by identifying yourself (and your website) on the user-agent#USER_AGENT = &quot;git (+http://www.yourdomain.com)&quot;# Obey robots.txt rulesROBOTSTXT_OBEY = False# Configure maximum concurrent requests performed by Scrapy (default: 16)#CONCURRENT_REQUESTS = 32# Configure a delay for requests for the same website (default: 0)# See https://docs.scrapy.org/en/latest/topics/settings.html#download-delay# See also autothrottle settings and docs#DOWNLOAD_DELAY = 3# The download delay setting will honor only one of:#CONCURRENT_REQUESTS_PER_DOMAIN = 16#CONCURRENT_REQUESTS_PER_IP = 16# Disable cookies (enabled by default)#COOKIES_ENABLED = False# Disable Telnet Console (enabled by default)#TELNETCONSOLE_ENABLED = False# Override the default request headers:DEFAULT_REQUEST_HEADERS = &#123; &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;en&quot;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;,&#125;# Enable or disable spider middlewares# See https://docs.scrapy.org/en/latest/topics/spider-middleware.html#SPIDER_MIDDLEWARES = &#123;# &quot;git.middlewares.GitSpiderMiddleware&quot;: 543,#&#125;# Enable or disable downloader middlewares# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#DOWNLOADER_MIDDLEWARES = &#123;# &quot;git.middlewares.GitDownloaderMiddleware&quot;: 543,#&#125;# Enable or disable extensions# See https://docs.scrapy.org/en/latest/topics/extensions.html#EXTENSIONS = &#123;# &quot;scrapy.extensions.telnet.TelnetConsole&quot;: None,#&#125;# Configure item pipelines# See https://docs.scrapy.org/en/latest/topics/item-pipeline.html#ITEM_PIPELINES = &#123;# &quot;git.pipelines.GitPipeline&quot;: 300,#&#125;# Enable and configure the AutoThrottle extension (disabled by default)# See https://docs.scrapy.org/en/latest/topics/autothrottle.html#AUTOTHROTTLE_ENABLED = True# The initial download delay#AUTOTHROTTLE_START_DELAY = 5# The maximum download delay to be set in case of high latencies#AUTOTHROTTLE_MAX_DELAY = 60# The average number of requests Scrapy should be sending in parallel to# each remote server#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0# Enable showing throttling stats for every response received:#AUTOTHROTTLE_DEBUG = False# Enable and configure HTTP caching (disabled by default)# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings#HTTPCACHE_ENABLED = True#HTTPCACHE_EXPIRATION_SECS = 0#HTTPCACHE_DIR = &quot;httpcache&quot;#HTTPCACHE_IGNORE_HTTP_CODES = []#HTTPCACHE_STORAGE = &quot;scrapy.extensions.httpcache.FilesystemCacheStorage&quot;# Set settings whose default value is deprecated to a future-proof valueREQUEST_FINGERPRINTER_IMPLEMENTATION = &quot;2.7&quot;TWISTED_REACTOR = &quot;twisted.internet.asyncioreactor.AsyncioSelectorReactor&quot;FEED_EXPORT_ENCODING = &quot;utf-8&quot; 测试执行调试测试文件，断点在login方法，发现其返回200，输出响应的TXT格式，复制其内容保存为HTML文件并打开 可以发现其成功显示出登录后的界面 也可以通过判断可以发现HTML是否含有账号名来判断调试是否成功 Scrapy下载中间件（Downloader Middleware）下载中间件是Scrapy的核心组件之一，它提供了一个灵活的方式来自定义请求和响应的处理过程。 基本概念 作用：下载中间件用于拦截并处理Scrapy发出的所有HTTP请求和响应。它们在Scrapy的请求&#x2F;响应处理过程中提供了多个钩子（hooks）点。 功能：可以用于修改请求和响应、处理重定向、重试失败的请求、设置代理、处理cookies等。 实现：它是通过实现特定的方法的Python类来定义的。 内置中间件 Scrapy自带了多种下载中间件，这些中间件提供了对不同方面的处理支持。 可以通过运行命令 scrapy settings --get=DOWNLOADER_MIDDLEWARES_BASE 查看Scrapy自带的所有下载中间件及其优先级。 1&#123;&quot;scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware&quot;: 100, &quot;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&quot;: 300, &quot;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&quot;: 350, &quot;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&quot;: 400, &quot;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&quot;: 500, &quot;scrapy.downloadermiddlewares.retry.RetryMiddleware&quot;: 550, &quot;scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware&quot;: 560, &quot;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&quot;: 580, &quot;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&quot;: 590, &quot;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&quot;: 600, &quot;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&quot;: 700, &quot;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&quot;: 750, &quot;scrapy.downloadermiddlewares.stats.DownloaderStats&quot;: 850, &quot;scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware&quot;: 900&#125; 这些内置中间件包括对robots.txt的处理、HTTP代理支持、Cookies处理等。 用户可以通过在DOWNLOADER_MIDDLEWARES设置中添加自定义的中间件来扩展Scrapy的功能。 设置是一个字典，键是中间件类的路径，值是中间件的顺序（0-1000之间的整数）。数字越小，优先级越高，即越接近Scrapy引擎 123DOWNLOADER_MIDDLEWARES = &#123; &#x27;myproject.middlewares.CustomMiddleware&#x27;: 543,&#125; 详见官方文档 https://docs.scrapy.org/en/latest/topics/downloader-middleware.html 下载中间件实例 RobotsTxtMiddleware 功能描述: 此中间件用于处理网站的robots.txt规则。它会自动解析并遵守目标网站的robots.txt文件，从而限制爬虫的行为以符合网站的爬取政策。 配置方法: 默认情况下，Scrapy会遵守robots.txt规则。可以通过在项目的settings.py中设置ROBOTSTXT_OBEY = False来禁用此功能。 HttpAuthMiddleware 功能描述: 管理HTTP认证的中间件，用于处理那些需要HTTP认证（如基本认证、摘要认证）的网站。 配置方法: 可以通过在Scrapy的Request对象中指定http_user和http_pass属性来启用HTTP认证。 DownloadTimeoutMiddleware 功能描述: 设置下载请求的超时时间。如果请求在指定时间内未得到响应，它将被视为失败，并且可以被重试中间件重新处理。 配置方法: 可以通过设置DOWNLOAD_TIMEOUT来调整全局超时时间。 DefaultHeadersMiddleware 功能描述: 为所有的Scrapy请求设置默认HTTP头部。这对于为每个请求添加或覆盖特定的HTTP头（如Accept-Language）非常有用。 配置方法: 在settings.py文件中，使用DEFAULT_REQUEST_HEADERS设置来定义默认的HTTP头部。 UserAgentMiddleware 功能描述: 此中间件允许为每个请求随机或固定地设置User-Agent。User-Agent通常被网站用来识别访问者使用的浏览器和操作系统。 配置方法: 可以通过在settings.py中设置USER_AGENT或者使用自定义的User-Agent提供器来改变User-Agent。 RetryMiddleware 功能描述: 处理失败的HTTP请求并尝试重新发送。这对于处理暂时的网络问题或服务器错误非常有用。 配置方法: 默认情况下，Scrapy会重试失败的请求。可以在settings.py中修改RETRY_TIMES来调整重试次数。 AjaxCrawlMiddleware 功能描述: 用于处理JavaScript生成的页面。这使得Scrapy能够爬取那些需要执行JavaScript代码才能显示完整内容的页面。 配置方法: 默认不启用，需要在settings.py中显式启用。 MetaRefreshMiddleware 功能描述: 自动处理页面的meta刷新标签。有些网页可能会使用meta标签来自动刷新或重定向到另一个页面。 配置方法: 默认启用。可以通过在settings.py中设置METAREFRESH_ENABLED = False来禁用它。 HttpCompressionMiddleware 功能描述: 此中间件自动处理压缩的HTTP响应，例如gzip或deflate格式的内容。 配置方法: 默认启用，无需特别配置。 RedirectMiddleware 功能描述: 自动处理HTTP重定向。对于301和302类型的重定向，此中间件会自动跟随重定向链接。 配置方法: 默认启用，可以通过REDIRECT_ENABLED设置来禁用。 CookiesMiddleware 功能描述: 管理Cookies。对于需要管理多个会话或跟踪用户会话的爬虫来说，这个中间件非常有用。 配置方法: 默认启用，可以通过COOKIES_ENABLED = False来禁用。 HttpProxyMiddleware 功能描述: 处理HTTP代理。通过使用代理，爬虫可以从不同的IP地址发送请求，这有助于绕过IP封锁或进行匿名抓取。 配置方法: 可以通过在请求的meta中设置proxy键来启用代理。 DownloaderStats 功能描述: 收集下载统计信息。这个中间件为每个响应或异常收集统计数据，帮助分析和优化爬虫性能。 配置方法: 默认启用，一般无需更改配置。 HttpCacheMiddleware 功能描述: 提供对HTTP缓存的支持。此中间件能够缓存请求的响应，以便下次请求相同资源时快速获取。 配置方法: 默认不启用，可以通过在settings.py中设置HTTPCACHE_ENABLED = True来启用。 下载中间件API 每个下载中间件可以实现以下一个或多个方法： process_request(request, spider): 在发送请求之前调用。可以返回None、一个Response对象、一个Request对象或抛出一个异常。 process_response(request, response, spider): 在接收到响应后调用。可以返回Response对象或抛出异常。 process_exception(request, exception, spider): 当下载处理过程中发生异常时调用。 from_crawler(cls, crawler): 类方法，用于访问Scrapy的核心组件和API，以及创建中间件实例。 返回值的重要性 每个方法的返回值都非常重要，它决定了请求或响应接下来的处理流程。 如果process_request返回非None值，Scrapy将不会继续处理该请求，而是立即调用相应的process_response方法。 如果process_response返回一个新的请求（Request对象），Scrapy将停止调用其他中间件的process_response方法，转而处理这个新的请求。 在process_exception中返回一个新的请求对象将同样导致Scrapy停止调用其他中间件的process_exception方法，并处理这个新的请求。 自定义中间件UA代理池中间件在Scrapy项目中，使用自定义中间件来实现用户代理池（User-Agent Pool）是一种常见的做法，用于避免被目标网站识别并可能被阻止。 自定义的用户代理池中间件允许每个请求随机使用不同的用户代理（User-Agent），从而减少被目标网站识别为爬虫的风险。 1. 在 settings.py 中定义用户代理列表首先，在Scrapy项目的settings.py文件中定义一个用户代理列表： settings文件 user_agent_list 123456789101112131415161718192021222324252627282930313233343536373839#user_agentUSER_AGENT_LIST = [ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &quot; &quot;(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;, &quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 &quot; &quot;(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 &quot; &quot;(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 &quot; &quot;(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;, &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 &quot; &quot;(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;, &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;, &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;, &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 &quot; &quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot; ] 这个列表包含了多个不同的用户代理字符串，用于在发起请求时模拟不同的浏览器。 2. 在 middlewares.py 中实现用户代理中间件在middlewares.py文件中实现自定义的中间件，用于在每个请求中随机选择一个用户代理： 12345678910import randomfrom scrapy.conf import settingsclass RandomUserAgentMiddleware(object): def process_request(self, request, spider): # 随机选择一个用户代理 user_agent = random.choice(settings.get(&#x27;USER_AGENT_LIST&#x27;)) if user_agent: # 设置请求的User-Agent request.headers.setdefault(&#x27;User-Agent&#x27;, user_agent) RandomUserAgentMiddleware 类定义了一个process_request方法，该方法在每个请求发送之前被调用。 方法中，随机从USER_AGENT_LIST中选取一个用户代理，并将其设置为该请求的User-Agent。 信息 也有另一种方法是直接从 settings 模块导入 12345678910from .settings import USER_AGENT_LISTimport randomclass UAMiddleware: def process_request(self, request, spider): request.headers[&#x27;User-Agent&#x27;] = random.choice(USER_AGENT_LIST) return None def process_response(self, request, response, spider): return response 这种方法直接从settings.py文件中导入user_agent_list。 优点是直接和简洁，尤其是在用户代理列表只在这个中间件中使用时。 缺点是它降低了配置的灵活性。如果想在不同的环境（例如开发环境和生产环境）中使用不同的用户代理列表，或者希望能够通过命令行参数动态覆盖这些设置，这种方法可能不太适用。 之前的方法使用Scrapy的内置settings模块来访问项目设置（在settings.py文件中定义的设置）。 优点是它利用了Scrapy框架的设置管理机制，可以更容易地在整个项目中管理和维护这些设置。 缺点是需要导入scrapy.conf.settings，这在某些情况下可能稍显冗余。 如果倾向于使用Scrapy框架的标准特性，并希望在项目的不同组件间共享配置，那么第一种方法（使用scrapy.conf.settings）可能更适合。 如果项目结构比较简单，或者只在一个地方使用这个用户代理列表，那么第二种方法（直接从settings.py导入）可能更直接有效。 3. 在 settings.py 中启用中间件在settings.py文件中，将自定义的中间件添加到DOWNLOADER_MIDDLEWARES设置中，以启用该中间件： 123DOWNLOADER_MIDDLEWARES = &#123; &#x27;myproject.middlewares.RandomUserAgentMiddleware&#x27;: 400,&#125; 替换&#39;myproject.middlewares.RandomUserAgentMiddleware&#39;为实际的中间件路径。 数值400是中间件的优先级。可以根据需要调整这个值以控制中间件的执行顺序。 注意事项 使用用户代理池可以帮助模拟常规用户的浏览行为，但应注意合理使用以避免对目标网站造成不必要的负担。 请确保遵守目标网站的爬虫政策和使用条款。 用户代理字符串应尽量选择常见且更新的版本，以提高爬虫的隐蔽性。 IP代理池在Scrapy项目中使用IP代理池是为了隐藏爬虫的真实IP地址，这有助于绕过目标网站的IP封锁或请求频率限制。 实现IP代理池可以让Scrapy爬虫在每次请求时使用不同的IP地址，从而提高爬虫的匿名性和效率。 1. 在 settings.py 中定义IP代理池在Scrapy项目的settings.py文件中，定义一个包含多个代理IP的列表： (此处是示例,以下的代理基本无法使用的,同时不建议去找免费的代理,不安全) 12345678910# IP代理池IPPOOL = [ &#123;&quot;ipaddr&quot;: &quot;61.129.70.131:8080&quot;&#125;, &#123;&quot;ipaddr&quot;: &quot;61.152.81.193:9100&quot;&#125;, &#123;&quot;ipaddr&quot;: &quot;120.204.85.29:3128&quot;&#125;, &#123;&quot;ipaddr&quot;: &quot;219.228.126.86:8123&quot;&#125;, &#123;&quot;ipaddr&quot;: &quot;61.152.81.193:9100&quot;&#125;, &#123;&quot;ipaddr&quot;: &quot;218.82.33.225:53853&quot;&#125;, &#123;&quot;ipaddr&quot;: &quot;223.167.190.17:42789&quot;&#125;] 这个列表包含了多个字典，每个字典代表一个代理服务器，其中ipaddr键的值是代理服务器的IP地址和端口。 2. 在 middlewares.py 中实现IP代理中间件在middlewares.py文件中，实现一个中间件来随机使用IP代理池中的一个代理： 123456789import randomfrom scrapy.conf import settingsclass ProxyMiddleware(object): def process_request(self, request, spider): # 从IP池中随机选择一个IP thisip = random.choice(settings.get(&#x27;IPPOOL&#x27;)) # 将选中的IP设置为请求的代理 request.meta[&quot;proxy&quot;] = &quot;http://&quot; + thisip[&#x27;ipaddr&#x27;] ProxyMiddleware 类定义了一个process_request方法，该方法在每个请求发送之前被调用。 方法中，随机从IPPOOL中选取一个IP代理，并将其设置为该请求的代理。 信息 第一种方法是从预定义的IP代理池中随机选择一个代理，而另一种种方法是实时从一个API获取代理IP 12345678import requestsclass IPPMiddleware: def process_request(self, request, spider): url = &#x27;https://api.hailiangip.com:8522/api/getIpEt?dataType=1&amp;encryptParam=...（省略）&#x27; res = requests.get(url) data = &quot;https://&quot; + res.text request.meta[&#x27;proxy&#x27;] = data 选择哪种方法取决于具体需求和环境。如果需要更高的灵活性和更大的代理IP池，且不介意依赖外部服务和可能的额外成本，那么使用实时API获取代理可能是更好的选择。如果更注重稳定性和控制，且不希望增加额外的依赖和成本，那么使用预定义的代理池可能更适合。 3. 在 settings.py 中启用自定义中间件在settings.py文件中，将自定义的中间件添加到DOWNLOADER_MIDDLEWARES设置中，以启用该中间件： 123DOWNLOADER_MIDDLEWARES = &#123; &#x27;myproject.middlewares.ProxyMiddleware&#x27;: 543,&#125; 替换&#39;myproject.middlewares.ProxyMiddleware&#39;为实际的中间件路径。 数值543是中间件的优先级。可以根据需要调整这个值以控制中间件的执行顺序。 注意事项 请注意，示例中的代理IP可能无法使用。在实际应用中，建议使用可靠且安全的付费代理服务。 免费代理可能不稳定，且有安全隐患，例如可能会被用于拦截或篡改数据。 使用代理时，请确保遵守目标网站的爬虫政策和使用条款，合理使用以避免对目标网站造成不必要的负担。 Scrapy settings.py 配置详解优先级 settings.py 文件是 Scrapy 项目的核心配置文件，用于定义爬虫的行为和项目的全局设置。 基础配置项目名称: BOT_NAME: 定义项目名称，通常用作日志记录的标识。 1BOT_NAME = &#x27;baidu&#x27; 爬虫模块路径: SPIDER_MODULES: 指定包含 Scrapy 爬虫的模块。 NEWSPIDER_MODULE: 定义使用 genspider 命令创建新爬虫时的默认模块。 12SPIDER_MODULES = [&#x27;baidu.spiders&#x27;]NEWSPIDER_MODULE = &#x27;baidu.spiders&#x27; 用户代理 (User-Agent): USER_AGENT: 定义爬虫默认使用的用户代理。 1USER_AGENT = &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27; Robots.txt 协议: ROBOTSTXT_OBEY: 设置是否遵守网站的 robots.txt 协议。 1ROBOTSTXT_OBEY = False Cookies 支持: COOKIES_ENABLED: 设置是否启用 cookies。 1COOKIES_ENABLED = True Telnet 控制台: TELNETCONSOLE_ENABLED: 设置是否启用 Telnet 控制台用于查看爬虫运行情况。 1TELNETCONSOLE_ENABLED = True 默认请求头: DEFAULT_REQUEST_HEADERS: 设置 Scrapy 发送 HTTP 请求时默认使用的请求头。 1234DEFAULT_REQUEST_HEADERS = &#123; &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;, &#x27;Accept-Language&#x27;: &#x27;en&#x27;,&#125; 请求重试: RETRY_ENABLED: 设置是否启用请求重试。 RETRY_TIMES: 设置请求重试的次数。 RETRY_HTTP_CODECS: 设置触发重试的 HTTP 状态码。 123RETRY_ENABLED = TrueRETRY_TIMES = 3RETRY_HTTP_CODECS = [500, 502, 503, 504, 408] 并发与延迟最大并发请求数: CONCURRENT_REQUESTS: 设置下载器最大处理的并发请求数量。 1CONCURRENT_REQUESTS = 32 每个域的最大并发请求数: CONCURRENT_REQUESTS_PER_DOMAIN: 设置每个域名的最大并发请求数。 1CONCURRENT_REQUESTS_PER_DOMAIN = 16 每个IP的最大并发请求数: CONCURRENT_REQUESTS_PER_IP: 设置每个 IP 的最大并发请求数。如果设置，CONCURRENT_REQUESTS_PER_DOMAIN 将被忽略。 1CONCURRENT_REQUESTS_PER_IP = 16 下载延迟: DOWNLOAD_DELAY: 设置对同一网站的请求间隔秒数。 1DOWNLOAD_DELAY = 3 智能限速 (AutoThrottle)AutoThrottle 扩展: 自动调整 Scrapy 到最佳爬取速度，减轻对目标站点的压力。 AUTOTHROTTLE_ENABLED: 开启 AutoThrottle。 AUTOTHROTTLE_START_DELAY: 初始下载延迟。 AUTOTHROTTLE_MAX_DELAY: 最大下载延迟。 AUTOTHROTTLE_TARGET_CONCURRENCY: 每秒并发请求数的目标值。 AUTOTHROTTLE_DEBUG: 开启调试模式，以观察 AutoThrottle 的行为。 12345AUTOTHROTTLE_ENABLED = TrueAUTOTHROTTLE_START_DELAY = 5AUTOTHROTTLE_MAX_DELAY = 60AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0AUTOTHROTTLE_DEBUG = False 中间件、Pipelines、扩展 启用或禁用 Spider 中间件: 123SPIDER_MIDDLEWARES = &#123; &#x27;baidu.middlewares.BaiduSpiderMiddleware&#x27;: 543,&#125; 启用或禁用下载器中间件: 123DOWNLOADER_MIDDLEWARES = &#123; &#x27;baidu.middlewares.MyCustomDownloaderMiddleware&#x27;: 543,&#125; 启用或禁用扩展: 123EXTENSIONS = &#123; &#x27;scrapy.extensions.telnet.TelnetConsole&#x27;: None,&#125; 配置 Item Pipelines: ITEM_PIPELINES: 设置启用的 Item Pipeline。 123ITEM_PIPELINES = &#123; &#x27;baidu.pipelines.CustomPipeline&#x27;: 300,&#125; Spider类下载图片在Scrapy框架中，下载图片与下载文本数据确实有一些相似之处，但也有其特有的处理方式。Scrapy通过内置的支持使得下载图片变得相对简单。与处理文本数据不同，处理图片通常涉及处理二进制数据，并可能需要额外的中间件支持。 测试文件1234from scrapy.cmdline import executeexecute([&#x27;scrapy&#x27;, &#x27;crawl&#x27;, &#x27;baidu_img&#x27;]) 手动保存图片Spider文件12345678910111213141516171819202122232425import scrapyimport re,osclass BaiduImgSpider(scrapy.Spider): name = &quot;baidu_img&quot; allowed_domains = [] start_urls = [&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=111210&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;oq=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;rsp=-1&quot;] num = 0 def parse(self, response): re_data = re.findall(&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;, response.text) for im in re_data: yield scrapy.Request(im, callback=self.get_img) def get_img(self, response): img_data = response.body # 直接保存图片 # 如果没有 imgspider 这个文件夹，mkdir创建 if not os.path.exists(&#x27;imgspider&#x27;): os.mkdir(&#x27;imgspider&#x27;) filename = &#x27;imgspider/&#123;&#125;.png&#x27;.format(self.num) self.num += 1 with open(filename, &#x27;wb&#x27;) as f: f.write(img_data) 代码解释 定义一个继承自scrapy.Spider的爬虫类BaiduImgSpider。 name：为爬虫指定一个唯一的名称。 allowed_domains：定义爬虫允许爬取的域名列表。这里为空，表示不对域名进行限制。 start_urls：包含一个起始URL的列表，该URL是百度图片搜索的结果页面。 parse：是爬虫的一个方法，处理响应并提取数据。 使用正则表达式从页面源代码中提取所有图片的URL。正则表达式&#39;thumbURL&quot;:&quot;(.*?)&quot;&#39;用于匹配图片的URL。 遍历所有提取到的图片URL。 对每个图片URL，生成一个Scrapy请求，并将响应发送到get_img方法。 get_img：处理图片下载的方法。 response.body：获取响应的二进制数据，即图片内容。 检查是否存在名为imgspider的目录，如果不存在，则创建该目录。用于保存下载的图片。 构造图片文件的保存路径和文件名。这里使用self.num来为图片生成唯一的文件名，但需要注意self.num在爬虫类中初始化。 以二进制写入模式打开文件，将图片数据写入文件。 注意事项 该爬虫直接从百度图片的搜索结果页面提取图片URL，具体的URL模式可能会随着百度网站的更新而变化。 使用正则表达式提取数据可能不如使用XPath或CSS选择器那样稳定，因为如果百度网页的结构发生变化，正则表达式可能需要更新。 确保遵守百度图片的版权和使用条款，不要用于任何侵犯版权或违法的用途。 调试处理前配置Settings文件进行伪装，否则连接失败 Pipeline 保存图片Items 文件12345678910# Define here the models for your scraped items## See documentation in:# https://docs.scrapy.org/en/latest/topics/items.htmlimport scrapyclass BaiduItem(scrapy.Item): img_data = scrapy.Field() 定义一个名为BaiduItem的Item类，该类用于在爬虫和Pipeline之间传递数据。 它继承自scrapy.Item。在Scrapy中，Item是用来收集从网页提取的数据的简单容器。 BaiduItem类将被用来存储从百度图片搜索结果中提取的数据。 BaiduItem类中定义了一个字段img_data。 scrapy.Field()是Scrapy用来定义Item字段的特殊容器，用于存储从网页中提取的数据。 在这个例子中，img_data字段用于存储图片的二进制数据或图片的URL。 创建了一个BaiduItem的实例，并将提取到的图片数据或URL填充到img_data字段。 然后，可以将这个填充了数据的BaiduItem实例传递给Pipeline进行进一步的处理，例如保存图片到文件系统或数据库 Spider 文件123456789101112131415161718192021import scrapyimport re,osfrom ..items import BaiduItemclass BaiduImgSpider(scrapy.Spider): name = &quot;baidu_img&quot; allowed_domains = [] start_urls = [&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=111210&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;oq=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;rsp=-1&quot;] def parse(self, response): re_data = re.findall(&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;, response.text) for im in re_data: yield scrapy.Request(im, callback=self.get_img) def get_img(self, response): item = BaiduItem() img_data = response.body item[&#x27;img_data&#x27;] = img_data yield item 定义一个名为BaiduImgSpider的爬虫类，指定爬虫名称、允许的域名（在这里为空）和起始URL。 parse是Scrapy爬虫处理响应的默认方法。使用正则表达式从响应中提取图片的URL。 对每个找到的图片URL，发起一个新的Scrapy请求，并指定回调方法get_img来处理这些请求。 get_img方法处理图片下载的响应。创建一个BaiduItem实例，并将下载的图片数据（二进制格式）存储在img_data字段中。 将包含图片数据的item提交给Pipeline进行进一步处理。 Pipelines 文件1234567891011121314from itemadapter import ItemAdapterimport osclass BaiduPipeline(): num = 0 def process_item(self, item, spider): if not os.path.exists(&#x27;imgpipeline&#x27;): os.mkdir(&#x27;imgpipeline&#x27;) filename = &#x27;imgpipeline/&#123;&#125;.png&#x27;.format(self.num) self.num += 1 with open(filename, &#x27;wb&#x27;) as f: f.write(item.get(&#x27;img_data&#x27;)) return item 导入了所需的模块和类。ItemAdapter用于适配不同类型的Item对象，os模块用于处理文件和路径操作。 num是一个类变量，用于生成图片文件的名称。 process_item是Pipeline处理item的方法。 检查名为imgpipeline的文件夹是否存在，如果不存在，则创建它。这个文件夹用于存储下载的图片。 为下载的图片生成文件名，并将num递增以确保文件名的唯一性。 以二进制写模式打开文件，并将图片数据写入文件。 返回处理后的item。 settings.py中激活BaiduPipeline避免没有传值 注意事项 这个爬虫和Pipeline的实现假定图片的URL可以直接从百度图片搜索结果的页面HTML中提取。如果百度更改其HTML结构或JavaScript动态加载机制，这个方法可能需要更新。 当处理大量图片或大型网站时，请确保遵循robots.txt规则并尊重网站的版权和使用条款。 ImagesPipeline类下载图片Scrapy提供了一个专门的ImagesPipeline类，用于方便地下载和处理图片。要正确使用这个类，需要按照以下步骤操作： 在Spider文件中提取图片URLs 爬虫应该解析目标页面，提取图片的URLs，并将它们存储在item的一个字段中。 在Items文件中定义image_urls字段 定义一个Scrapy Item，并包含一个名为image_urls的字段，用于存储待下载的图片URLs。 12class BdImagePipeItem(scrapy.Item): image_urls = scrapy.Field() 创建继承自ImagesPipeline的管道类 创建一个新的Pipeline类，继承自ImagesPipeline。这个类可以被用来进一步自定义图片的下载和处理行为（如过滤、转换格式等）。 1234from scrapy.pipelines.images import ImagesPipelineclass BdImagePipeline(ImagesPipeline): pass 在Settings文件中配置图片存储路径和Pipeline 在项目的settings.py文件中，设置图片存储路径（IMAGES_STORE）和启用图片管道。 1234IMAGES_STORE = &#x27;/path/to/your/images/dir&#x27;ITEM_PIPELINES = &#123; &#x27;yourproject.pipelines.BdImagePipeline&#x27;: 300,&#125; 安装Pillow库 ImagesPipeline需要Pillow库来处理图片。确保安装了Pillow库（版本4.0或以上）。 1pip install Pillow 媒体管道的特性和设置 Scrapy的媒体管道（包括ImagesPipeline）提供了一些有用的特性，例如避免重新下载最近下载的媒体、生成缩略图、检查图像尺寸等。 除了IMAGES_STORE之外，还有许多其他设置可以用来定制媒体管道的行为，如IMAGES_EXPIRES、IMAGES_THUMBS、IMAGES_MIN_HEIGHT、IMAGES_MIN_WIDTH等。 媒体管道的特性Scrapy的媒体管道提供了强大的功能来处理下载的媒体文件，如图片和文件。特别是对于图像，Scrapy提供了额外的处理功能。 基本特性 避免重复下载：媒体管道会跟踪最近下载的文件，避免重复下载相同的媒体内容。 灵活的存储位置：支持多种存储方式，包括本地文件系统、Amazon S3、谷歌云存储等。 图像特有功能 格式转换：下载的图片会被转换为通用的JPG格式，并确保图片模式为RGB。 缩略图生成：可以自动生成指定尺寸的缩略图。 尺寸过滤：通过设置，可以过滤掉低于指定宽度或高度的图片。 媒体管道的设置为了使用媒体管道，需要在项目的settings.py文件中进行相应的配置。 启用媒体管道1ITEM_PIPELINES = &#123;&#x27;scrapy.pipelines.images.ImagesPipeline&#x27;: 1&#125; 这行代码启用了Scrapy的图像管道，并设置其优先级为1。 设置存储位置和字段123456789101112FILES_STORE=&#x27;/path/to/valid/dir&#x27; 文件管道存放位置IMAGES_STORE=&#x27;/path/to/valid/dir&#x27; 图片管道存放位置FILES_URLS_FIELD=&#x27;field_name_for_your_files_urls&#x27; 自定义文件url字段FILES_RESULT_FIELD=&#x27;field_name_for_your_processed_files&#x27; 自定义结果字段IMAGES_URLS_FIELD = &#x27;field_name_for_your_images_urls&#x27; 自定义图片url字段IMAGES_RESULT_FIELD = &#x27;field_name_for_your_processed_images&#x27; 结果字段FILES_EXPIRES = 90 文件过期时间 默认90天IMAGES_EXPIRES = 90 图片过期时间 默认90天IMAGES_THUMBS= &#123;&#x27;small&#x27;: (50, 50), &#x27;big&#x27;:(270, 270)&#125; 缩略图尺寸IMAGES_MIN_HEIGHT= 110 过滤最小高度IMAGES_MIN_WIDTH= 110 过滤最小宽度MEDIA_ALLOW_REDIRECTS= True 是否重定向，默认为False Spider文件12345678910111213141516import scrapyimport re,osfrom ..items import BaiduItemclass BaiduImgSpider(scrapy.Spider): name = &quot;baidu_img&quot; allowed_domains = [] start_urls = [&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=111210&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;oq=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;rsp=-1&quot;] def parse(self, response): re_data = re.findall(&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;, response.text) item = BaiduItem() item[&#x27;image_urls&#x27;] = re_data yield item 导入了Scrapy框架、正则表达式库和项目中定义的BaiduItem。 定义了一个名为BaiduImgSpider的爬虫类。 start_urls包含了开始爬取的URL（百度图片搜索结果）。 parse方法处理响应并提取图片URL。 使用正则表达式从页面中提取图片的URL。 创建一个BaiduItem实例，并将提取到的URL列表赋值给image_urls字段。 使用yield语句返回这个item。 Items文件12345678910# Define here the models for your scraped items## See documentation in:# https://docs.scrapy.org/en/latest/topics/items.htmlimport scrapyclass BaiduItem(scrapy.Item): image_urls = scrapy.Field() 定义了一个名为BaiduItem的Item类，包含一个image_urls字段。 image_urls用于存储待下载的图片URL列表。 Pipelines文件123456789101112# Define your item pipelines here## Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html# useful for handling different item types with a single interfacefrom scrapy.pipelines.images import ImagesPipelineclass BaiduPipeline(ImagesPipeline): pass 导入了Scrapy的ImagesPipeline。 定义了一个名为BaiduPipeline的类，它继承自ImagesPipeline。 目前这个类没有进行任何自定义操作，直接继承了ImagesPipeline的全部功能。 Settings文件添加图片管道存放位置IMAGES_STORE=&#39;imgStore&#39; 添加缩略图尺寸设置： 1234IMAGES_THUMBS= &#123; &#x27;small&#x27;: (60, 60), &#x27;large&#x27;:(300, 300) &#125; ImagesPipeline类方法重写 (改名与翻页)Spider文件1234567891011121314151617181920212223242526import scrapyimport re,osfrom ..items import BaiduItemclass BaiduImgSpider(scrapy.Spider): name = &quot;baidu_img&quot; allowed_domains = [] start_urls = [&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=111210&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;oq=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;rsp=-1&quot;] page_url =&#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=7201144097221860430&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;queryWord=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=0&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=&#123;&#125;&amp;rn=30&amp;gsm=1e&amp;1702544763785=&#x27; page_num = 1 def parse(self, response): re_data = re.findall(&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;, response.text) item = BaiduItem() item[&#x27;image_urls&#x27;] = re_data yield item if self.page_num == 4: return url = self.page_url.format(self.page_num * 30) self.page_num += 1 yield scrapy.Request(url) page_url定义了用于翻页的URL模板。 page_num用于追踪当前的翻页数。 parse方法用正则表达式从响应中提取图片URL，并将它们存入BaiduItem的image_urls字段。 控制翻页，如果当前页面数达到4，则停止爬取。 格式化page_url以获取下一页的URL，并更新page_num。 使用scrapy.Request生成新的请求来爬取下一页。 Pipelines文件123456789101112131415from itemadapter import ItemAdapterimport osfrom .settings import IMAGES_STOREfrom scrapy.pipelines.images import ImagesPipelineclass BaiduPipeline(ImagesPipeline): pass num = 0 def item_completed(self, results, item, info): images_paths = [x.get(&#x27;path&#x27;) for ok, x in results if ok] for path in images_paths: os.rename(os.path.join(IMAGES_STORE,path), os.path.join(IMAGES_STORE, str(self.num) + &#x27;.png&#x27;) ) self.num += 1 导入所需的模块和类，包括Scrapy的内置ImagesPipeline。 定义了继承自ImagesPipeline的BaiduPipeline类。 num用于生成重命名后的图片文件名。 重写item_completed方法，该方法在item的图片被下载完成后调用。 遍历下载的图片路径，并重命名每张图片，使用num作为新的文件名。","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://www.yiuhangblog.com/tags/Scrapy/"},{"name":"网页抓取","slug":"网页抓取","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96/"}],"author":"Yiuhang Chan"},{"title":"验证识别","slug":"20211026验证识别","date":"2021-10-25T23:12:45.000Z","updated":"2024-02-28T10:50:30.000Z","comments":true,"path":"2021/10/26/20211026验证识别/","permalink":"https://www.yiuhangblog.com/2021/10/26/20211026%E9%AA%8C%E8%AF%81%E8%AF%86%E5%88%AB/","excerpt":"利用selenium和像素比较进行基本的验证自动化执行","text":"认识验证码概念验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写。是一种用来区分用户是计算机还是人的公共全自动程序 作用认证码是一种人机识别手段，最终目的是区分正常用户和机器的操作。可以防止：恶意破解密码、注册、刷票、论坛灌水，防止黑客对用户的密码进行暴力破解。一般是提出一个问题，这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答这个的问题，所以回答出问题的用户就可以被认为是人类。 类别图形验证码：这类验证码大多是计算机随机产生一个字符串，在把字符串增加噪点、干扰线、变形、重叠、不同颜色、扭曲组成一张图片来增加识别难度。 滑块验证码：也叫行为验证码，比较流行的一种验证码，通过用户的操作行为来完成验证，其中最出名的就是极验。滑动验证码的原理就是使用机器学习中的深度学习技术，根据一些特征来区分是否为正常用户。通过记录用户的滑动速度，还有每一小段时间的瞬时速度，用户鼠标点击情况，以及滑动后的匹配程度来识别。而且，不是说滑动到正确位置就是验证通过，而是根据特征识别来区分是否为真用户，滑到正确位置只是一个必要条件。 点触验证码：点击类验证码都是给出一张包含文字的图片，通过文字提醒用户点击图中相同字的位置进行验证。 Pillow库PIL库PIL (Python Image Library) 已经算是 Python 处理图片的标准库了，兼具强大的功能和简洁的 API.但是PIL库的更新非常缓慢， 并且它只支持到python2.7，不支python3 Pillow库由于PIL库更新太慢了，于是一群志愿者在PIL库的基础上创建的分支版本，命名为Pillow.Pillow目前最新支持到python3.6以上，它的维护和开发十分活跃，兼容PIL库的绝大多数语法，并且增加了许多新的特性，推荐直接使用Pillow Pillow库安装安装:pip install pillow PIL与Pillow使用注意Pillow和PIL不能共存在一个环境中，如果之前安装了PIL的话，需要删除掉才能在安装Pillow由于是继承自PIL的分支， 所以Pillow库的导入是这样的 Import PIL 图形基本概念因为要处理的是图形,所以需要了解一下基本概念 尺寸图片尺寸（size）指的是图片的宽度和高度通过size属性可以获取图片的尺寸，它的返回值是一个元组，元组里面有两个值，分别是水平和垂直方向上的像素个数 坐标系统笛卡尔像素坐标系x轴从左到右,y轴从上到下增长图像矩形区域的表示(左,顶,右,底);800*600像素表示(0,0,800,600) 通道图片均是由一个或者多个数据通道构成RGB图像,每张图片都是由三个数据通道叠加构成，分别为R 、G 、BPNG图像有RGBA四个通道，A代表透明度对于灰度图像（没有色彩的图片， RGB色彩分量全部相等），只有一个通道。灰度指的是黑白图像中点的颜色深度，范围一般是0到255， 白色为255，黑色为0 图像获取 从文件中加载图像 1picture=Image.open(&quot;test.png&quot;) 创建一个新的图像 1picture=Image.new(&quot;RGB&quot;,(200,100),&quot;red&quot;) 处理其他的图像获得 1im=picture.crop((116,168,658,798)) 获取图像通道 12im.getbands()(&quot;R&quot;,&quot;G&quot;,&quot;B&quot;) 简单验证码处理灰度化目的:为二值化做准备 彩色变黑白，三通道变成一个通道 图片的灰度化，就是让像素点矩阵中的每一个像素点满足 R&#x3D;G&#x3D;B，此时这个值叫做灰度值，白色为255，黑色为0 灰度转化一般公式为： R&#x3D;G&#x3D;B &#x3D; 处理前的 R * 0.3 + G * 0.59 + B * 0.11 1234黑 0---255 白色第一个像素点的灰度值税 187 123 改成 255第一个像素点的灰度值税 34 123 改成 0 二值化图像的二值化，就是将图像的像素点矩阵中的每个像素点的灰度值设置为0（黑色）或255（白色），从而实现二值化，将整个图像呈现出明显的只有黑和白的视觉效果。二值化原理是利用设定的一个阈值来判断图像像素是0还是255， 一般小于阈值的像素点变为0， 大于的变成255这个临界灰度值就被称为阈值，阈值的设置很重要，阈值过大或过小都会对图片造成损坏选择阈值的原则是：既要尽可能保存图片信息，又要尽可能减少背景和噪声的干扰 常用阈值选择的方法是： 灰度平均值值法： 取127 （0~255的中数， （0+255）&#x2F;2 &#x3D; 127） 平均值法：计算像素点矩阵中的所有像素点的灰度值的平均值avg 迭代法：选择一个近似阈值作为估计值的初始值（比如全图像的平均灰度），然后进行分割图像，产生两组像素，一组大于初始灰度值，另一组小于初始灰度值，根据产生的子图像的特征来选取新的阈值，在利用新的阈值分割图像，经过多次循环，使得错误分割的图像像素点降到最小。 1234567891011121314151617181920212223242526from PIL import Imageimg = Image.open(&quot;1.png&quot;)img_gray = img.convert(&quot;L&quot;)# img_gray.save(&quot;img_gray.png&quot;)def binarization(ig): w,h=img_gray.size tmp=0 for i in range(w): for j in range(h): tmp += ig.getpixel((i,j)) avg_pixel = tmp/w/h # 二值化处理 for i in range(w): for j in range(h): p = ig.getpixel((i, j)) if p&gt;avg_pixel: ig.putpixel((i, j), 255) else: ig.putpixel((i, j), 0) return igimg_bz = binarization(img_gray)img_bz.save(&#x27;img_bz.png&#x27;) 降噪 目的:清除干扰点,让图片更清晰,让计算机更利于识别孤立的噪点，他的周围应该都是白色，或者大多数点都是白色的，所以在判断的时候条件应该放宽，一个点是黑色并且相邻的点为白色的点的个数大于一个固定的值，那么这个点就是噪点。 降噪原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&quot;&quot;&quot;安装的库名 不一定是使用的库名pip install pillowimport PIL&quot;&quot;&quot;from PIL import Imageimg = Image.open(&quot;1.png&quot;) # 创建一个对象imgprint(img.getbands()) #(&#x27;R&#x27;, &#x27;G&#x27;, &#x27;B&#x27;) 三原色通道img_gray = img.convert(&quot;L&quot;)def binarization(ig): w, h = img_gray.size # 获取长宽 tmp = 0 for i in range(w): #循环宽 for j in range(h): #循环高 # 通过嵌套循环获取所有像素点的坐标 # getpixel 方法是用来获取图像中某一点像素的rgb颜色 # 需要传元组形式的坐标 tmp += ig.getpixel((i, j)) avg_pixel = tmp / w / h # 找到灰度图像的阙值 print(avg_pixel) # 236.21198586154773 # 二值化处理 for y in range(w): for z in range(h): p = ig.getpixel((y, z)) # 保持rgb的颜色到p if p &gt; avg_pixel: # 由于阀值是浮点所以正常情况是不存在相等的问题，当然进行处理等于的情况也行 ig.putpixel((y, z), 255) # 如果大于阙值则变白色 else: ig.putpixel((y, z), 0) # 反之亦然 return ig# 噪点范围def point_list(i, j, prange): #i和j是坐标，prange是范围 for x in range(i - prange, i + prange): # i以外的范围 for y in range(j - prange, j + prange): # j以外的范围 if x == i and y == j: #中心点确定为黑色 continue yield (x, y)# 传入需要降噪的二值化图片def reduce_noise(ig): w, h = ig.size prange = 4 for i in range(w): for j in range(h): if j &lt; h * 0.06 or j &gt; h * (1 - 0.2): ig.putpixel((i, j), 255) continue p = ig.getpixel((i, j)) if p &lt; 100: count = 0 for x, y in point_list(i, j, prange): # 判断周围是否是白色,如果白色多 就是噪点 if ig.getpixel((x, y)) &gt; 100: count += 1 if count &gt; 0.5 * ((prange * 2 + 1) ** 2 - 1): ig.putpixel((i, j), 255) return igbz_image = Image.open(&#x27;img_bz.png&#x27;)ig_tong = reduce_noise(bz_image)ig_tong.save(&#x27;img_test.png&#x27;) Tesseract识别OCR识别概念OCR （Optical Character Recognition）光学字符识别， 指的是对文本资料的图像文件进行分析识别处理，获取文集及版面信息的过程 Tesseract-OCR一个开源的字符识别引擎，我们可以用他来识别一些简单的验证码。 Windows下安装https://digi.bib.uni-mannheim.de/tesseract/可自行下载,点击下一步即可 ; Linux安装12sudo apt-get install tesseract-ocrsudo apt-get install libtesseract-dev Mac安装1brew install tesseract Pytesser3是一个在Python内使用Tesseract-Ocr的库，Pytesseract文档：https://pypi.org/project/pytesseract/ 安装：1pip install Pytesseract 需要配置:方法一:将pytesseract包下面__init__文件内tesseract_exe_name的值设置为tesseract.exe的路径,方法二者在代码中指定 Pytesseract认识：Pytesseract识别效果不佳，如果想提高识别率，可以使用 jTessBoxEditor对Tesseract进行简单的训练。OCR是一个专门的图像处理的领域高精度的识别需要依靠深度学习、神经网络等技术本章重点是对图片文件的理解 滑块验证码演示网址 https://captcha1.scrape.center/ ​ 获取图片验证码,包含缺口图,滑块图,完整图 三个canvas标签分别对应了缺口图，滑块图和完整图。 通过修改页面样式: 让滑块隐藏，截取缺口图; 隐藏缺口图,显示滑块图,截取滑块图; 显示完整图，截取完整图。 1.隐藏滑块,截取缺口图 设置后效果 2.隐藏缺口图,显示滑块图,截取滑块图隐藏缺口图 下滑右侧栏可以看到对滑块的设置 3.显示完整图，截取完整图选择第三个canvas 4. 计算距离​ 计算缺口位置,滑块位置,滑块要移动的距离 5. 确定距离距离&#x3D;滑块左边缘与缺口左边缘之间的距离distance&#x3D;滑块左边缘X坐标-缺口左边缘X坐标 一 更改元素样式, 获取图片 功能:获取验证图片 参数:无 返回值:缺口图地址滑块图地址完整图地址 123456789101112131415161718192021222324252627282930313233343536373839import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Byfrom PIL import Imagedef get_captcha(): time.sleep(2) #(1)隐藏滑块 得到缺口图 js_hide_slice = &#x27;document.getElementsByClassName(&quot;geetest_canvas_slice&quot;)[0].style.display=&quot;none&quot;&#x27; driver.execute_script(js_hide_slice) #截取缺口图 part_imgpath=&quot;./part.png&quot; driver.find_element(by=By.CLASS_NAME, value=&quot;geetest_canvas_bg&quot;).screenshot(part_imgpath) # (2)显示滑块 隐藏缺口图 得到滑块图 js_show_slice = &#x27;document.getElementsByClassName(&quot;geetest_canvas_slice&quot;)[0].style.display=&quot;block&quot;&#x27; js_hide_part= &#x27;document.getElementsByClassName(&quot;geetest_canvas_bg&quot;)[0].style.display=&quot;none&quot;&#x27; driver.execute_script(js_show_slice+&quot;;&quot;+js_hide_part) # 截取滑块图 slice_imgpath = &quot;./slice.png&quot; driver.find_element_by_class_name(&quot;geetest_canvas_slice&quot;).screenshot(slice_imgpath) # (3)显示完整图 js_show_full1 = &#x27;document.getElementsByClassName(&quot;geetest_canvas_fullbg&quot;)[0].style.display=&quot;block&quot;&#x27; js_show_full2 = &#x27;document.getElementsByClassName(&quot;geetest_canvas_fullbg&quot;)[0].style.opacity=&quot;1&quot;&#x27; driver.execute_script(js_show_full1+&quot;;&quot;+js_show_full2) # 截取完整图 full_imgpath = &quot;./full.png&quot; driver.find_element_by_class_name(&quot;geetest_canvas_fullbg&quot;).screenshot(full_imgpath) #还原目的 还原成原来的模样 包含缺口图与滑块 js_hide_full1 = &#x27;document.getElementsByClassName(&quot;geetest_canvas_fullbg&quot;)[0].style.display=&quot;none&quot;&#x27; js_hide_full2 = &#x27;document.getElementsByClassName(&quot;geetest_canvas_fullbg&quot;)[0].style.opacity=&quot;0&quot;&#x27; js_show_part = &#x27;document.getElementsByClassName(&quot;geetest_canvas_bg&quot;)[0].style.display=&quot;&quot;&#x27; driver.execute_script(js_hide_full1 + &quot;;&quot; + js_hide_full2+ &quot;;&quot;+js_show_part) return part_imgpath, slice_imgpath, full_imgpath 二 计算演示找到滑块的x坐标12345678910def get_slice_x(img_slice): img = Image.open(img_slice) w, h = img.size for x in range(w): for y in range(h): rgb = img.getpixel((x,y)) # (255,255,255) # 判断比白色小就证明不是白色， 不是白色这个点就是我们所需要的值 if rgb[0] + rgb[1] + rgb[2] &lt; 600: # 765 print(&quot;滑块的坐标是&quot;, x) return x 找到缺口图的x坐标123456789101112131415def get_bg_x(img_bg, img_full): bg = Image.open(img_bg) full = Image.open(img_full) w, h = bg.size for x in range(w): for y in range(h): bg_rgb = bg.getpixel((x, y)) full_rgb = full.getpixel((x, y)) r = bg_rgb[0] - full_rgb[0] g = bg_rgb[1] - full_rgb[1] b = bg_rgb[2] - full_rgb[2] abs_value = abs(r) + abs(g) + abs(b) if abs_value &gt; 120: print(&#x27;缺口的坐标是&#x27;, x) return x 计算距离123456def get_distance(img_bg, img_slice, img_full): slice_x = get_slice_x(img_slice) bg_x = get_bg_x(img_bg, img_full) data = abs(bg_x-slice_x) print(&quot;需要移动的距离是&quot;, data) return data 进行移动12345678910111213def move_silder(tracks): time.sleep(3) element = driver.find_element(by=By.CLASS_NAME, value=&#x27;geetest_slider_button&#x27;) action_chains = ActionChains(driver) action_chains.click_and_hold(element) action_chains.pause(1) # 在执行下一个动作之前 暂停1秒 action_chains.move_by_offset(tracks+20, 0) action_chains.pause(1) action_chains.move_by_offset(-20, 0) action_chains.pause(1) action_chains.release().perform() 总体执行12345678910if __name__ == &#x27;__main__&#x27;: driver = webdriver.Chrome() url = &#x27;https://captcha1.scrape.center/&#x27; driver.get(url) time.sleep(4) driver.find_element(by=By.CLASS_NAME, value=&#x27;el-button&#x27;).click() time.sleep(3) img_bg, img_slice, img_full = get_captcha() distance = get_distance(img_bg, img_slice, img_full) move_silder(distance) 点触验证码点触验证码是一种常见的反爬手段解决方案有两种：一种是直接解决，这需要深度学习机器学习等图像处理技术，以大量的数据训练识别模型，最终达到模型足矣识别图片中的文字提示和应该点击的区域之间的对应关系。这需要非常专业的设备，比如GPU运算，和专业的开发和维护人员。 因此市面上有专业解决此类问题的OCR解决提供商。也就是第二种间接解决的方案，调用第三方接口。 B站登录案例https://www.bilibili.com/ 第一步：通过登录入口，发现其元素的类为header-login-entry, 利用selenium进行点击模拟 123456789101112131415import timefrom selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.common.by import Byfrom selenium import webdriverimport main_02url = &#x27;https://www.bilibili.com/&#x27;wb = webdriver.Chrome()wb.get(url)wb.find_element(by=By.CLASS_NAME, value=&#x27;header-login-entry&#x27;).click()time.sleep(3) # 反应时间，隐性反应太麻烦了先强制等待 第二步：点击成功后，发现账号输入的元素为placeholder=&quot;请输入账号&quot;，利用XPATH锁定这个元素所在，密码也是一样的 12wb.find_element(by=By.XPATH, value=&#x27;//div/input[@placeholder=&quot;请输入账号&quot;]&#x27;).send_keys(&#x27;123&#x27;)wb.find_element(by=By.XPATH, value=&#x27;//div/input[@placeholder=&quot;请输入密码&quot;]&#x27;).send_keys(&#x27;123&#x27;) 第三步：然后同样的查看登录按钮的元素并锁定btn_primary 12wb.find_element(by=By.CLASS_NAME, value=&#x27;btn_primary &#x27;).click()time.sleep(2) 第四步：挑选能覆盖所有验证码内容的类geetest_widget 1wb.find_element(by=By.XPATH, value=&#x27;//div[@class=&quot;geetest_widget&quot;]&#x27;).screenshot(&#x27;input.png&#x27;) 第五步：进行第三方OCR操作 123456789101112131415from chaojiying_Python import chaojiyingdef superying(): supertest = chaojiying.Chaojiying_Client(&#x27;123&#x27;, &#x27;123&#x27;, &#x27;931146&#x27;) im = open(&#x27;input.png&#x27;, &#x27;rb&#x27;).read() res = supertest.PostPic(im, 9004) return res# data = &#123;&#x27;err_no&#x27;: 0,# &#x27;err_str&#x27;: &#x27;OK&#x27;,# &#x27;pic_id&#x27;: &#x27;2233720420832210145&#x27;,# &#x27;pic_str&#x27;: &#x27;49,280|59,172&#x27;, # | ， int()# &#x27;md5&#x27;: &#x27;8dc82695a1f5f8a60a298b7822a15893&#x27;&#125;# （114,296）（59,180） 123# 识别结果data = main_02.superying()pic_list = data.get(&#x27;pic_str&#x27;).split(&quot;|&quot;) 第六步：进行模拟操作, 同样的确认提交的元素geetest_commit_tip 123456789101112131415161718def img_click(click_list): # 截图用是的哪个对象， 点击就必须用哪个对象 # 4.0.0 img_element = wb.find_element(by=By.XPATH, value=&#x27;//div[@class=&quot;geetest_widget&quot;]&#x27;) for i in click_list: # [&#x27;153,194&#x27;, &#x27;258,203&#x27;, &#x27;212,135&#x27;, &#x27;245,305&#x27;] data = i.split(&quot;,&quot;) # [&quot;153&quot;, &quot;194&quot;] x = int(data[0]) y = int(data[1]) # 这段代码是使用Selenium的ActionChains类来模拟鼠标操作。 # 其中，`wb`是WebDriver对象，`img_element`表示要移动到的元素， # `x`和`y`表示鼠标相对于元素左上角的偏移量。 # 这段代码的作用是移动鼠标到指定元素的指定位置，并进行点击操作。 ActionChains(wb).move_to_element_with_offset(img_element, xoffset=x, yoffset=y).click().perform() time.sleep(2) wb.find_element(by=By.XPATH, value=&#x27;//div/a/div[@class=&quot;geetest_commit_tip&quot;]&#x27;).click()img_click(pic_list)","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"算法","slug":"算法","permalink":"https://www.yiuhangblog.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"图像识别","slug":"图像识别","permalink":"https://www.yiuhangblog.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"自动化工具","slug":"自动化工具","permalink":"https://www.yiuhangblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"},{"name":"滑块验证","slug":"滑块验证","permalink":"https://www.yiuhangblog.com/tags/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81/"},{"name":"点触验证","slug":"点触验证","permalink":"https://www.yiuhangblog.com/tags/%E7%82%B9%E8%A7%A6%E9%AA%8C%E8%AF%81/"},{"name":"字符验证","slug":"字符验证","permalink":"https://www.yiuhangblog.com/tags/%E5%AD%97%E7%AC%A6%E9%AA%8C%E8%AF%81/"}],"author":"Yiuhang Chan"},{"title":"Selenium 自动化工具","slug":"20210224selenium","date":"2021-02-23T22:12:56.000Z","updated":"2024-02-28T10:50:27.000Z","comments":true,"path":"2021/02/24/20210224selenium/","permalink":"https://www.yiuhangblog.com/2021/02/24/20210224selenium/","excerpt":"Selenium库对各浏览器执行自动化处理","text":"简介概念Selenium 是一个web自动化工具 作用 自动化测试通过它，我们可以写出自动化程序，模拟浏览器里操作web界面。 比如点击界面按钮，在文本框中输入文字 等操作。 获取信息而且还能从web界面获取信息。 比如招聘网站职位信息，财经网站股票价格信息 等等，然后用程序进行分析处理。 运行环境 Selenium测试直接运行在浏览器中，就好像一个真正的用户在操作一样， 支持大部分主流的浏览器，包括IE(7,8,9,10,11)，Firefox，Safari，Chrome，Opera等。 我们可以利用它来模拟用户点击访问网站，绕过一些复杂的认证场景，通过selenium+驱动浏览器这种组合可以直接渲染解析js，绕过大部分的参数构造和反爬。 注意事项新版本的Selenium已经不在支持phantomjs，原作者也已经放弃维护该项目了。 还有在做爬虫的时候尽量不要用这种方法，Selenium+浏览器的组合速度慢，应付不了数据量比较大的爬取以及并发爬取。并且很吃电脑资源。 基本使用原理123flowchart TD A(selenium) --&gt; B(Chrome) B --&gt; C(Chrome Drive) 123# selenium ------http------&gt; 浏览器驱动， 去操作浏览器实现效果 -------&gt; 浏览器驱动 ----------&gt; selenium# 浏览器驱动相当于 http server# 浏览器驱动和浏览器版本要一致 注意:每个驱动该对应每个浏览器;有时候浏览器会自动升级,导致浏览器不可用; 安装selenium安装终端输入 pip install selenium==4.0.0 12为什么一定要装这个版本 我们在给图片定位的时候（0,0）坐标点是选在图片的左上角位置的 浏览器驱动安装 chrome驱动下载地址:https://chromedriver.chromium.org/downloads xxxxxxxxxx op1&#x3D;&gt;operation: 1.找到目标数据op2&#x3D;&gt;operation: 2.分析请求流程op3&#x3D;&gt;operation: 3.构造http请求op4&#x3D;&gt;operation: 4.提取数据op5&#x3D;&gt;operation: 5.数据持久化​op1(right)-&gt;op2(right)-&gt;op3(right)-&gt;op4(right)-&gt;op5(right)flowCreated with Raphaël 2.2.01.找到目标数据2.分析请求流程3.构造http请求4.提取数据5.数据持久化 Microsoft Edge WebDriver - Microsoft Edge Developer 所有edge驱动版本 Microsoft Edge - Webdriver (windows.net) 如何禁止更新–参考博客 https://blog.csdn.net/jylsrnzb/article/details/131492090 然后把下载成功的驱动放到python环境的根目录 验证运行是否成功（Chrome）为例12345from selenium import webdriverwb = webdriver.Chrome()wb.get(&#x27;https://www.baidu.com&#x27;) 运行后成功自动弹出Chrome即可： 元素选取find_element(s)by_…方法在一个页面中有很多不同的策略可以定位一个元素。我们可以选择最合适的方法去查找元素。Selenium提供了下列的方法: 注： 其中的element加上一个s，则是对应的多个元素的查找方法 老版本selenium的方法 单个元素查找方法 作用 find_element_by_xpath() 通过Xpath查找 find_element_by_class_name() 通过class属性查找 find_element_by_id() 通过id属性查找 find_element_by_name() 通过name属性进行查找 find_element_by_css_selector() 通过css选择器查找 语法规则 find_element_by_link_text() 通过链接文本查找 find_element_by_partial_link_text() 通过链接文本的部分匹配查找 find_element_by_tag_name() 通过标签名查找 新版本的用法：By对象查找除了以上的多种查找方式，还有两种私有方法集成了上面的所有的查找方法，让我们更方便的使用 方法 作用 find_element(By.XPATH, ‘&#x2F;&#x2F;button&#x2F;span’) 通过Xpath查找一个 find_elements(By.XPATH, ‘&#x2F;&#x2F;button&#x2F;span’) 通过Xpath查找多个 其中的第一个参数可以选择使用查找的方法，By.xxx 使用xxx方式解析，解析方法如下： 注：By对象导入： from selenium.webdriver.common.by import By 12345678ID = &quot;id&quot; XPATH = &quot;xpath&quot; LINK_TEXT = &quot;link text&quot; PARTIAL_LINK_TEXT = &quot;partial link text&quot; NAME = &quot;name&quot; TAG_NAME = &quot;tag name&quot; CLASS_NAME = &quot;class name&quot; CSS_SELECTOR = &quot;css selector&quot; 文本输入,提交chrome.find_element_by_id(&quot;all&quot;).send_keys(&quot;username&quot;) chrome.find_element_by_id(&quot;password&quot;).send_keys(&quot;password&quot;) chrome.find_element_by_css_selector(&quot;submit button&quot;).click() 使用案例（以豆瓣为例）通过分析搜索框元素发现输入的元素内容search_text： 通过分析搜索框元素发现提交的元素内容submit： 12345678910111213from selenium import webdriverfrom selenium.webdriver.common.by import Bywb = webdriver.Edge()wb.get(&#x27;https://movie.douban.com/top250&#x27;)# 老版本# wb.find_element_by_xpath(&#x27;//input[@name=&quot;search_text&quot;]&#x27;).send_keys(&#x27;周杰伦&#x27;)# wb.find_element_by_xpath(&#x27;//input[@type=&quot;submit&quot;]&#x27;).click()# 新版本wb.find_element(by=By.XPATH, value=&#x27;//input[@name=&quot;search_text&quot;]&#x27;).send_keys(&#x27;张译&#x27;) # 等同于输入框输入值wb.find_element(By.XPATH, value=&#x27;//div[@class=&quot;inp-btn&quot;]/input&#x27;).click() # 等同于点击搜索 动作切换窗口切换用selenium操作浏览器如果需要在打开新的页面，这个时候会有问题，因为我们用selenium操作的是第一个打开的窗口，所以新打开的页面我们是无法去操作的，所以我们要用到切换窗口：即handle切换的方法 方法 作用 js &#x3D; ‘window.open(“","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"自动化工具","slug":"自动化工具","permalink":"https://www.yiuhangblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"},{"name":"Selenium","slug":"Selenium","permalink":"https://www.yiuhangblog.com/tags/Selenium/"}],"author":"Yiuhang Chan"},{"title":"页面解析工具","slug":"20210223页面解析工具","date":"2021-02-23T06:12:56.000Z","updated":"2024-02-28T10:50:23.000Z","comments":true,"path":"2021/02/23/20210223页面解析工具/","permalink":"https://www.yiuhangblog.com/2021/02/23/20210223%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7/","excerpt":"利用beautifulsoup4 Xpath JSONPath等工具对各网站进行基本的解析","text":"BS4BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库，它的使用方式相对于正则来说更加的简单方便，常常能够节省我们大量的时间。 官方中文文档https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html 安装pip install beautifulsoup4 解析器 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库执行速度适中文档容错能力强 Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差 lxml HTML 解析器 BeautifulSoup(markup, “lxml”) 速度快文档容错能力强 需要安装C语言库 lxml XML 解析器 BeautifulSoup(markup, [“lxml”, “xml”])&#96;&#96;BeautifulSoup(markup, “xml”) 速度快唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性以浏览器的方式解析文档生成HTML5格式的文档 速度慢不依赖外部扩展 由于这个解析的过程在大规模的爬取中是会影响到整个爬虫系统的速度的，所以推荐使用的是lxml，速度会快很多，而lxml需要单独安装： 12pip install lxmlsoup = BeautifulSoup(html_doc, &#x27;lxml&#x27;) 如果一段HTML或XML文档格式不正确的话,那么在不同的解析器中返回的结果可能是不一样的，所以要指定某一个解析器。 节点对象 Tagtag就是标签的意思，tag还有许多的方法和属性。 NavigableString BeautifulSoup Comment Tag和遍历文档树tag对象可以说是BeautifulSoup中最为重要的对象，通过BeautifulSoup来提取数据基本都围绕着这个对象来进行操作。首先，一个节点中是可以包含多个子节点和多个字符串的。例如html节点中包含着head和body节点。所以BeautifulSoup就可以将一个HTML的网页用这样一层层嵌套的节点来进行表示。 基本语法12345from bs4 import BeautifulSoup#导包soup=BeautifulSoup(html_str,&#x27;lxml&#x27;)type(soup)bs4.BeautifulSoup Tag 标签取出简单示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from bs4 import BeautifulSouphtml_data = &quot;&quot;&quot;&lt;html&gt; &lt;body&gt; &lt;div&gt; 我们都是害虫 &lt;/div&gt; &lt;div id=&quot;info&quot;&gt; &lt;span&gt;&lt;span class=&quot;pl&quot;&gt;导演&lt;/span&gt;: &lt;span class=&quot;attrs&quot;&gt;&lt;a href=&quot;/celebrity/1362276/&quot; rel=&quot;v:directedBy&quot;&gt;邢文雄&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt; &lt;span&gt;&lt;span class=&quot;pl&quot;&gt;编剧&lt;/span&gt;: &lt;span class=&quot;attrs&quot;&gt;&lt;a href=&quot;/celebrity/1362276/&quot;&gt;邢文雄&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;actor&quot;&gt;&lt;span class=&quot;pl&quot;&gt;主演&lt;/span&gt;: &lt;span class=&quot;attrs&quot;&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1319032/&quot; rel=&quot;v:starring&quot;&gt;马丽&lt;/a&gt; / &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1355058/&quot; rel=&quot;v:starring&quot;&gt;魏翔&lt;/a&gt; / &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1362567/&quot; rel=&quot;v:starring&quot;&gt;陈明昊&lt;/a&gt; / &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1319540/&quot; rel=&quot;v:starring&quot;&gt;周大勇&lt;/a&gt; / &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1363857/&quot; rel=&quot;v:starring&quot;&gt;黄才伦&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1350408/&quot; rel=&quot;v:starring&quot;&gt;艾伦&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1394939/&quot; rel=&quot;v:starring&quot;&gt;高海宝&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1386801/&quot; rel=&quot;v:starring&quot;&gt;韩笑&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1444360/&quot; rel=&quot;v:starring&quot;&gt;孙贵权&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1426220/&quot; rel=&quot;v:starring&quot;&gt;许猛&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1467304/&quot; rel=&quot;v:starring&quot;&gt;全容杓&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1467305/&quot; rel=&quot;v:starring&quot;&gt;卜俊男&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1316008/&quot; rel=&quot;v:starring&quot;&gt;张志忠&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1367242/&quot; rel=&quot;v:starring&quot;&gt;张建新&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1398260/&quot; rel=&quot;v:starring&quot;&gt;马驰&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1353283/&quot; rel=&quot;v:starring&quot;&gt;陶亮&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1403276/&quot; rel=&quot;v:starring&quot;&gt;詹卢卡·佐帕&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;more-actor&quot; title=&quot;更多主演&quot;&gt;更多...&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;pl&quot;&gt;类型:&lt;/span&gt; &lt;span property=&quot;v:genre&quot;&gt;喜剧&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;pl&quot;&gt;制片国家/地区:&lt;/span&gt; 中国大陆&lt;br&gt; &lt;span class=&quot;pl&quot;&gt;语言:&lt;/span&gt; 汉语普通话&lt;br&gt; &lt;span class=&quot;pl&quot;&gt;上映日期:&lt;/span&gt; &lt;span property=&quot;v:initialReleaseDate&quot; content=&quot;2022-02-01(中国大陆)&quot;&gt;2022-02-01(中国大陆)&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;pl&quot;&gt;片长:&lt;/span&gt; &lt;span property=&quot;v:runtime&quot; content=&quot;109&quot;&gt;109分钟&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;pl&quot;&gt;又名:&lt;/span&gt; Too Cool To Kill&lt;br&gt; &lt;span class=&quot;pl&quot;&gt;IMDb:&lt;/span&gt; tt16254308&lt;br&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;soup = BeautifulSoup(html_data, &#x27;lxml&#x27;)# 取第一个a标签(tag)里面的文本信息print(soup.a.text, type(soup.a.text)) # 邢文雄 &lt;class &#x27;str&#x27;&gt;print(soup.a.string, type(soup.a.string)) # 邢文雄 &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;print(&quot;===========================================================&quot;)# 标签的属性print(soup.a.get(&quot;href&quot;)) # /celebrity/1362276/print(&quot;===========================================================&quot;)# 子代标签body = soup.bodyprint(list(body.children)) # &lt;list_iterator object at 0x000001B973C23BE0&gt;print(&quot;===========================================================&quot;)# 后代标签print(list(body.descendants)) # &lt;generator object Tag.descendants at 0x00000159C796A510&gt;test = body.descendantsprint(&quot;===========================================================&quot;)# 兄弟标签 （同级的标签，有相同的父标签）span = body.spanprint(span.next_sibling.next_sibling.next_sibling) # 下一个兄弟标签# 第一个兄弟是 &lt;br&gt;# 第二个兄弟是 \\n# 第三个兄弟是第一个内容标签print(span.previous_sibling.previous_sibling)# 第一个兄弟是 \\n# 第二个兄弟是 我们所需的标签print(&quot;===========================================================&quot;)# 父类标签, 加了s就是所有父类标签，不加就是它本身p_parents = span.parentsprint(list(p_parents)) # &lt;generator object PageElement.parents at 0x000001A4DBD37E40&gt; 1.find_all直接通过名字和属性来进行访问，很多时候只能适用于比较简单的一些场景，所以BeautifulSoup还提供了搜索整个文档树的方法find_all()。 通过name搜索，find_all(&#39;b&#39;)可以直接查找出整个文档树中所有的b标签，并返回列表 通过属性搜索，我们在搜索的时候一般只有标签名是不够的，因为可能同名的标签很多，那么这时候我们就要通过标签的属性来进行搜索。这时候我们可以通过传递给attrs一个字典参数来搜索属性。soup.find_all(attrs=&#123;&#39;class&#39;: &#39;sister&#39;&#125;) 通过文本搜索，在find_all()方法中，还可以根据文本内容来进行搜索。soup.find_all(string=&quot;Elsie&quot;) 限制查找范围为子节点find_all()方法会默认的去所有的子孙节点中搜索，而如果将recursive参数设置为False，则可以将搜索范围限制在直接子节点中。 soup.html.find_all(&quot;title&quot;, recursive=False) 通过正则表达式来筛选查找结果在BeautifulSoup中，也是可以与re模块进行相互配合的，将re.compile编译的对象传入find_all()方法，即可通过正则来进行搜索。tags = soup.find_all(re.compile(&quot;^b&quot;)) 以之前的数据为例子： 12345print(soup.find_all(&#x27;a&#x27;, string=&#x27;邢文雄&#x27;)) # [&lt;a href=&quot;/celebrity/1362276/&quot; rel=&quot;v:directedBy&quot;&gt;邢文雄&lt;/a&gt;, &lt;a href=&quot;/celebrity/1362276/&quot;&gt;邢文雄&lt;/a&gt;]print(soup.find_all(&#x27;span&#x27;, attrs=&#123;&#x27;class&#x27;: &#x27;pl&#x27;&#125;))# [&lt;span class=&quot;pl&quot;&gt;导演&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;编剧&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;主演&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;类型:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;制片国家/地区:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;语言:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;上映日期:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;片长:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;又名:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;IMDb:&lt;/span&gt;] 2.CSS选择器在BeautifulSoup中，同样也支持使用CSS选择器来进行搜索。使用select()，在其中传入字符串参数，就可以使用CSS选择器的语法来找到tag。 12print(soup.select(&#x27;a&#x27;))print(soup.select(&#x27;span &gt; a&#x27;)) JSON PathJSON Path 是一种查询语言，用于从 JSON (JavaScript Object Notation) 数据中提取和处理信息。它类似于 SQL，但专门用于与 JSON 数据交互。使用 JSON Path，可以从复杂的 JSON 结构中轻松检索特定元素或值。这在处理大型或嵌套的 JSON 数据时特别有用。 以下是 JSON Path 的一些主要用途： 数据提取：从 JSON 数据中选择和提取数据，例如提取特定属性的值或筛选符合特定条件的元素。 查询构建：创建灵活的查询来搜索和筛选 JSON 数据中的信息。 数据处理：简化对复杂 JSON 结构的遍历和分析，无需编写复杂的代码。 API 交互：常用于与 RESTful API 交互时解析和处理返回的 JSON 数据。 JSON Path 通过提供一种简洁的语法来实现这些功能，使得从复杂的 JSON 结构中检索信息变得更加简单和直接。 123456789101112131415161718192021222324252627282930import jsonpath # pip install jsonpathdic = &#123; &quot;resultCode&quot;: &quot;1&quot;, &quot;resultMsg&quot;: &quot;success&quot;, &quot;reqId&quot;: &quot;52f9f3e1-1d76-47b4-b2ae-226633b61476&quot;, &quot;systemTime&quot;: &quot;1681991278593&quot;, &quot;videoInfo&quot;: &#123; # 父亲 &quot;playSta&quot;: &quot;1&quot;, &quot;video_image&quot;: &quot;https://image.pearvideo.com/cont/20170714/cont-1110173-10436784.png&quot;, &quot;srcUrl&quot;: &quot;https://video.pearvideo.com/mp4/short/20170714/1681991278593-10632788-hd.mp4&quot;, &quot;videos&quot;: &#123; # 儿子 &quot;hdUrl&quot;: &quot;&quot;, &quot;hdflvUrl&quot;: &quot;&quot;, &quot;sdUrl&quot;: &quot;&quot;, &quot;sdflvUrl&quot;: &quot;&quot;, # 孙子 &quot;srcUrl&quot;: &quot;https://video.pearvideo.com/mp4/short/20170714/1681991278593-10632788-hd.mp4&quot; &#125; &#125;&#125;# jsonpath(数据,&#x27;语法&#x27;)# dic.get(&quot;videoInfo&quot;).get(&quot;videos&quot;).get(&quot;srcUrl&quot;)# print(jsonpath.jsonpath(dic, &#x27;$..srcUrl&#x27;))## print(jsonpath.jsonpath(dic, &#x27;$..video_image&#x27;))print(jsonpath.jsonpath(dic, &#x27;$..videos.srcUrl&#x27;)) #[&#x27;https://video.pearvideo.com/mp4/short/20170714/1681991278593-10632788-hd.mp4&#x27;] Xpath简介XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。相比于BeautifulSoup，Xpath在提取数据时会更有效率。 安装pip install lxml 语法XPath 使用路径表达式在 XML&#x2F;HTML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。 下面列出了最有用的路径表达式： 谓语谓语用来查找某个或某些特定的节点或者包含某个指定值的节点谓语被嵌在方括号中。在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果。实例: 选取未知节点XPath通配符可用来选取未知节点 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 选取多个路径通过在路径表达式中使用”|”运算符，可以选取若干个路径。在下面的表格中，列出了一些路径表达式，以及这些表达式的结果： 获取节点下文本用text()获取某个节点下的文本，用string()获取某个节点下所有的文本。 解析工具应用案例1. 明确目标：以豆瓣电影排行榜为案例，抓取豆瓣电影的排行榜: https://movie.douban.com/chart 需要提取的数据： 1. movie_name 2. movie_actor 3. movie_score 2. 进行伪装与请求：进行伪装与请求： requests 3. 交互响应中去提取我们需要的信息： 正则 2. bs4 3. json() 4. xpath（可平替bs4） 4. 保存结果 文件 5. 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requestsfrom lxml import etreeurl = &#x27;https://movie.douban.com/chart&#x27;headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;, &#125;res = requests.get(url, headers=headers)with open(&#x27;douban.html&#x27;, &#x27;w&#x27;, encoding=&#x27;utf8&#x27;) as f: # encoding=&#x27;utf8&#x27; 避免乱码 f.write(res.text) # 读取已保存的文件 douban.htmlwith open(&#x27;douban.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf8&#x27;) as f: data = f.read()# 通过etree读取改文件，建立对象pagepage = etree.HTML(data)# 示例操作，一层一层往下探究对象test = page.xpath(&#x27;//div[@class=&quot;pl2&quot;]/a/text()&#x27;) # xpath(xpath语法字符串)print(test) li = [] for i in test: movie_name = i.replace(&#x27; &#x27;, &#x27;&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;).replace(&#x27;/&#x27;, &#x27;&#x27;) if not movie_name: continue li.append(movie_name) print(li) # 获取处理后的列表，分析拿到片名，但是因为还有其它值，不可能多个循环，所以实际应用不能这么操作# 实际操作test2 = page.xpath(&#x27;//tr[@class=&quot;item&quot;]&#x27;)movie = &#123;&#125;for i in yao: # 电影的名字 movie_name = i.xpath(&#x27;./td/a[@class=&quot;nbg&quot;]/@title&#x27;)[0] my_key = md5(movie_name.encode()).hexdigest() # print(movie_name) # 电影的演员表 movie_actor = i.xpath(&#x27;./td/div/p[@class=&quot;pl&quot;]/text()&#x27;)[0] # print(movie_actor) # 电影的评分 # movie_score = i.xpath(&#x27;//span[@class=&quot;rating_nums&quot;]/text()&#x27;) # movie_score = i.xpath(&#x27;./td/div/div/span[@class=&quot;rating_nums&quot;]/text()&#x27;)[0] movie_score = i.xpath(&#x27;./td//span[@class=&quot;rating_nums&quot;]/text()&#x27;)[0] # print(movie_score) movie.update(&#123;my_key: [&#123;&#x27;片名&#x27;:movie_name,&#x27;演员&#x27;: movie_actor, &#x27;评分&#x27;: movie_score&#125;]&#125;)print(movie) 6. 租客网代码示例1234567891011121314151617181920212223242526272829303132import requestsfrom lxml import etreeimport jsonurl = &#x27;https://cs.zu.anjuke.com/?from=HomePage_TopBar&#x27;res = requests.get(url)tree = etree.HTML(res.text)div = tree.xpath(&#x27;//div[@class=&quot;zu-itemmod clearfix&quot;]&#x27;)for i in div: # 标题 title = i.xpath(&#x27;./div/h3/a/b[@class=&quot;strongbox&quot;]/text()&#x27;)[0] # 价格 price = i.xpath(&#x27;./div//strong[@class=&quot;price&quot;]/text()&#x27;)[0] # 地址 address = i.xpath(&#x27;./div//address[@class=&quot;details-item tag&quot;]/text()&#x27;) # [&#x27;\\n &#x27;, &#x27;\\xa0\\xa0\\n 芙蓉&#x27;, &#x27;五一广场 &#x27;, &#x27;韭菜园路101号 &#x27;] &quot;&quot;&quot; 1.使用join 把列表转换成字符串了 2.字符串使用replace进行替换 总结： 先拼接再替换 &quot;&quot;&quot; address = &#x27;&#x27;.join(address).replace(&#x27;\\n&#x27;, &#x27;&#x27;).replace(&#x27; &#x27;, &#x27;&#x27;).replace(&#x27; &#x27;,&#x27; &#x27;) print(address) # 保存进文件中 with open(&#x27;租房信息.txt&#x27;,&#x27;a&#x27;, encoding=&#x27;utf8&#x27;) as f: f.write(&quot;标题：&quot;+ title + &quot;\\t&quot; + &quot;价格：&quot; + price + &quot;\\t&quot;+ &quot;地址：&quot; + address + &#x27;\\n&#x27;)","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Requests","slug":"Requests","permalink":"https://www.yiuhangblog.com/tags/Requests/"},{"name":"页面解析","slug":"页面解析","permalink":"https://www.yiuhangblog.com/tags/%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90/"},{"name":"BS4","slug":"BS4","permalink":"https://www.yiuhangblog.com/tags/BS4/"},{"name":"beautifulsoup4","slug":"beautifulsoup4","permalink":"https://www.yiuhangblog.com/tags/beautifulsoup4/"},{"name":"Xpath","slug":"Xpath","permalink":"https://www.yiuhangblog.com/tags/Xpath/"}],"author":"Yiuhang Chan"},{"title":"Requests","slug":"20210222requests","date":"2021-02-22T10:12:32.000Z","updated":"2024-02-28T10:50:20.000Z","comments":true,"path":"2021/02/22/20210222requests/","permalink":"https://www.yiuhangblog.com/2021/02/22/20210222requests/","excerpt":"Python Requests库介绍和基本使用","text":"简介 Requests是一个优雅而简单的Python HTTP库，专为人类而构建。 中文官方文档：http://cn.python-requests.org/zh_CN/latest/。 英文文档：http://docs.python-requests.org/en/master/api/ 作者Requests的作者Kenneth Reitz同样是一个富有传奇色彩的人物。 Requests目前基本上完全满足web请求的所有需求，以下是requests的特性: Keep-Alive &amp; 连接池 国际化域名和URL 带持久Cookie的会话 浏览器式的SSL认证 自动内容解码 基本&#x2F;摘要时的身份认证 优雅的 key&#x2F;value Cookie 自动解压 Unicode 响应体 HTTP(S) 代理支持 文件分块上传 流下载 连接超时 分块请求 支持 .netrc 发送请求使用 Requests 发送网络请求非常简单。导包, 之后添加方法进行。 Requests的请求不再像urllib一样需要去构造各种Request、opener和handler，使用Requests构造的方法，并在其中传入需要的参数即可。 发起请求的方法变得简单，只需要着重关注一下发起请求的参数 ，10个重要的参数。 method, 请求方法 url, 资源地址 params=None, 查询参数也叫做查询字符串 data=None, post请求的表单数据 headers=None, 请求头 cookies=None, cookies files=None, # 文件 auth=None, # 校验身份 timeout=None, 超时时间 allow_redirects=True, # 重定向 proxies=None, 代理 hooks=None,# 钩子函数 stream=None,# verify=None, 证书忽略 cert=None, # 字符串 --证书的地址 元组（） json=None, post 请求的JSON数据 URL传递URL参数也不用再像urllib中那样需要去拼接URL，而是简单的，构造一个字典，并在请求时将其传递给params参数，此时，查看请求的URL，则可以看到URL已经构造正确了，并且，有时候我们会遇到相同的url参数名，但有不同的值，而python的字典又不支持键的重名，那么我们可以把键的值用列表表示： 添加请求头如果想自定义请求的Headers，同样的将字典数据传递给headers参数。 添加cookiesRequests中自定义Cookies也不用再去构造CookieJar对象，直接将字典递给cookies参数。 设置超时时间设置访问超时，设置timeout参数即可。 设置代理当我们需要使用代理时，同样构造代理字典，传递给proxies参数。 重定向很多网站是http开头，为了不影响老客户，原网站不动，当访问http的原网址时，重定向到新的https网址，在requests中 allow_redirects默认是True，如果是False则不允许重定向，也就无法重定向新网址获取数据。 证书忽略验证有时候我们使用了抓包工具，这个时候由于抓包工具提供的证书并不是由受信任的数字证书颁发机构颁发的，所以证书的验证会失败，所以我们就需要关闭证书验证。在请求的时候把verify参数设置为False就可以关闭证书验证了。 POST请求发送Json数据 POST请求发送Form表单数据 POST示例以https://www.17k.com/登录为案例，首先分析登录逻辑 尝试登录操作，发现操作后会其Headers下会显示请求的网址https://passport.17k.com/ck/user/login，且请求类型为POST 随后分析所需的构造参数 在Payload下可以发现其为表单数据，应构造的参数为{loginName: 123， password: 123} 另外还需添加headers伪装 接着根据分析的要素，构造请求，向服务器提交数据即可 1234567891011121314import requestsurl=&#x27;https://passport.17k.com/ck/user/login&#x27;form_data = &#123; &#x27;loginName&#x27;: &#x27;123&#x27;, &#x27;password&#x27;: &#x27;123&#x27;&#125;headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;&#125;resp = requests.post(url, data=form_data, headers=headers)print(resp.text) response对象属性12345678910print(res.text)#直接转换成字符串 非字节码print(res.content)#图片数据 使用此参数print(res.status_code)#状态码print(res.json()[&quot;headers&quot;][&quot;User-Agent&quot;])#自动转换成 字典格式# 一定要确保使用的格式是json格式的数据print(res.headers)#响应头print(res.cookies)#响应cookieprint(res.url)#请求的urlprint(res.request.url)#请求的urlprint(res.request.headers)#请求头 响应内容通过Requests发起请求获取到的，是一个requests.models.Response对象。通过这个对象我们可以很方便的获取响应的内容。之前通过urllib获取的响应，读取的内容都是bytes的二进制格式，需要我们自己去将结果decode()一次转换成字符串数据。而Requests通过text属性，就可以获得字符串格式的响应内容。 字符编码和二进制数据Requests会自动的根据响应的报头来猜测网页的编码是什么，然后根据猜测的编码来解码网页内容，基本上大部分的网页都能够正确的被解码。而如果发现text解码不正确的时候，就需要我们自己手动的去指定解码的编码格式。而如果需要获得原始的二进制数据，那么使用content属性即可。 session方法session方法是requests库发起请求的一种方法，这种方法会自动保存访问页面得到的cookie值，从而再次访问的时候会自动携带cookie，使得操作cookie方便，不需要我们自己添加cookie了。常用于登录； 经典的登录逻辑功能:自动更新请求头信息，常用在账号登录的时候，先访问登录页url，再访问数据提交的url例:12306 session的使用基本的使用方法与requests.get 相似，使用的session的时候需要先创建session对象 123session=requests.session()#创建session对象session.headers=headers#添加请求头res_ss=session.get(index_url) session示例首先利用测试网址编入cookies 12345678910111213import requestssession = requests.session()resp_ss = session.get(&#x27;http://httpbin.org/cookies/set/CosTrace/12345678&#x27;)print(resp_ss.text)&quot;&quot;&quot;&#123; &quot;cookies&quot;: &#123; &quot;CosTrace&quot;: &quot;12345678&quot; &#125;&#125;&quot;&quot;&quot; 采用requests.get方法尝试获取cookies，发现不存在值，这是因为requests方法本身不存在存储的功能 123456789resp_req = requests.get(&#x27;http://httpbin.org/cookies&#x27;)print(resp_req.text)&quot;&quot;&quot;&#123; &quot;cookies&quot;: &#123;&#125;&#125;&#125;&quot;&quot;&quot; 随后我们用session方法尝试获取cookies，发现成功 12345678910resp_req = session.get(&#x27;http://httpbin.org/cookies&#x27;)print(resp_req.text)&quot;&quot;&quot;&#123; &quot;cookies&quot;: &#123; &quot;CosTrace&quot;: &quot;12345678&quot; &#125;&#125;&quot;&quot;&quot; Requests案例1 - 简易百度图片抓取1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;目标：百度图片抓取1. 打开网页 --&gt;请求 --&gt;伪装 a. 安装模块 pip install requests b. 请求失败的话就在伪装继续添加标头2. 下载图片 --保存本地 --&gt;交互 a. 把响应内容中的图片url提取出来 b. 对每个图片的url，进行请求二进制的方法进行保存&quot;&quot;&quot;from hashlib import md5import requests, re# 赋值urlurl = &#x27;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=000000&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;oq=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;rsp=-1&#x27;# 表头字典，制作伪装headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;,&#125;# 赋值请求服务, 获取http数据resp = requests.get(url, headers=headers)http_data = resp.text# 正则表达式提取图片re_data = re.findall(&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;, http_data)# 循环提取, md5去重命名for i in re_data: name_encode = md5(i.encode()).hexdigest() img_resp = requests.get(i) b_img_data = img_resp.content with open(f&#x27;&#123;name_encode&#125;.jpg&#x27;, &#x27;wb&#x27;) as f: f.write(b_img_data) Requests案例2 - 多页百度图片抓取 首先分析，在标头的响应查看滚动页面时返回的URL，分析翻页时的变化： 1234# 在标头的响应查看滚动页面时返回的urlurl_1 = &#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=8578568584458070132&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;queryWord=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=60&amp;rn=30&amp;gsm=3c&amp;1701269373791=&#x27;url_2 = &#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=8578568584458070132&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;queryWord=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=90&amp;rn=30&amp;gsm=5a&amp;1701269630311=&#x27;url_3 = &#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=8578568584458070132&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;queryWord=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=120&amp;rn=30&amp;gsm=78&amp;1701269630813=&#x27; 随后比较三个URL直接的关系，可以发现大部分都是相同，因此删除所有相同的部分进行比较： 123456789# 分析链接不同的规律，下面是不同的部分：# pn: 当前显示的图片数量，一次翻页显示30张，pn（Page Number）: 这个参数通常用于分页功能，表示当前显示的页面编号或者某些情况下显示的项目数量。# 例如，在图像搜索结果中，pn=90可能表示当前显示的是第90张图片或第90页的内容。# gsm未知，可能表示一个特定的标识符或编码，用于追踪请求或控制返回的内容# 后面的长数值是时间戳，时间戳通常用于记录事件发生的具体时间，有时用于缓存控制或确保请求的唯一性url_1_compar = &#x27;pn=60&amp;gsm=3c&amp;1701269373791=&#x27;url_2_compar = &#x27;pn=90&amp;gsm=5a&amp;1701269630311=&#x27;url_3_compar = &#x27;pn=120&amp;gsm=78&amp;1701269630813=&#x27; 最后把完整URL输入到浏览器，查看删减这三个不同的部分哪些会影响数据的获取： 1234# 通过删减url发现时间戳和gsm均不影响翻页，因此剩余影响数据获取的不同点是pn，且每30一获取：url_1_compar_2 = &#x27;pn=60&#x27;url_2_compar_2 = &#x27;pn=90&#x27;url_3_compar_2 = &#x27;pn=120&#x27; 通过分析可以发现百度翻页规律，随后编写循环（此例为三页）配合案例1的伪装即可获取 12345678910111213141516171819202122232425262728# 表头字典，制作伪装headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;,&#125;if not os.path.exists(&#x27;images&#x27;): os.mkdir(&#x27;images&#x27;)# 编写循环，每30返回一次：for i in range(1, 4): url = f&#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=8578568584458070132&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;queryWord=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=&#123;i * 30&#125;&amp;rn=30&#x27; resp = requests.get(url, headers=headers) # 赋值请求服务, 获取http数据 data = resp.json() # json -&gt; 字符串转成dict格式，前提条件就是resp一定时json格式 data_list = data.get(&quot;data&quot;) # 这是一个列表 for j in data_list: img_url = j.get(&quot;thumbURL&quot;) # 获取该变量下的值 if img_url: # 当请求到数据时 try: img_url_encode = md5(img_url.encode()).hexdigest() # md5去重，唯一标识符 img_resp = requests.get(img_url) except Exception as e: print(e) # 是否有脏数据 continue else: b_img_data = img_resp.content with open(&#x27;images/&#x27; + img_url_encode + &#x27;.jpg&#x27;, &#x27;wb&#x27;) as f: f.write(b_img_data) else: continue","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Requests","slug":"Requests","permalink":"https://www.yiuhangblog.com/tags/Requests/"}],"author":"Yiuhang Chan"},{"title":"爬虫与网络基础理论","slug":"20210221爬虫与网络基础理论","date":"2021-02-20T19:12:54.000Z","updated":"2024-02-28T10:50:14.000Z","comments":true,"path":"2021/02/21/20210221爬虫与网络基础理论/","permalink":"https://www.yiuhangblog.com/2021/02/21/20210221%E7%88%AC%E8%99%AB%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/","excerpt":"爬虫基本网络架构，协议和代理的基础理论","text":"一.爬虫概念概念 网络爬虫也叫网络蜘蛛，特指一类自动批量下载网络资源的程序，这是一个比较口语化的定义。 更加专业和全面对的定义是：网络爬虫是伪装成客户端与服务端进行数据交互的程序。 作用 数据采集（重要） 大数据监控，产品推荐 大数据杀熟，某平台订酒店时间长了会贵一点 灰产，内部买卖 搜索引擎 百度，谷歌（比较少），主要还是页面存储 模拟操作 测试机器人 灌水机器人（快速刷屏） 种类 通用爬虫 百度，谷歌 聚焦爬虫 专门为某站点制作的 增量爬虫 监控站点，一旦有更新就爬取（在线小说，漫画） 深网爬虫 输入表单才能获取数据（登录账号密码之后才能获取） 爬虫开发的重难点 数据的获取 伪装 采集的速度 多爬虫 分布式 二.网络与HTTP&#x2F;HTTPS协议网络类型（Network Types）网络类型主要指的是不同的网络构建方式和范围： 更多关注于网络的物理或逻辑结构和地理范围。它们描述的是网络的“形状”和“大小”，以及设备间连接的物理或无线方式。 1. 本地区域网 (LAN - Local Area Network) 定义：LAN是一个小范围内的网络，通常用于单个建筑或一组紧密相连的建筑。 用途：用于连接个人电脑或工作站，以便于共享资源（如打印机）和交换信息。 2. 广域网 (WAN - Wide Area Network) 定义：WAN覆盖广泛的地理区域，可以是城市、国家甚至跨国。 用途：用于连接不同地理位置的LANs，允许不同地区的用户和组织之间交换数据。 芝加哥（Accounts Receivable） 网络：使用IPv4。 设备：包括iSeries A服务器，有一个IPv6地址（4321::54bc）和一个IPv4地址（10.1.1.1）。 IPv4路由器：连接iSeries A服务器和Internet。 达拉斯（Accounts Payable） 网络：使用IPv6。 设备：包括iSeries B服务器，有一个IPv6地址（9876::55cc）。 客户端：连接到iSeries B服务器。 2838 Ethernet adapter：表示连接设备使用的网络适配器。 中间部分 IPv4&#x2F;6路由器：具有IPv4地址（10.1.2.1）和IPv6地址（9876::55bb），这表明它能够处理IPv4和IPv6的数据包。 连接 绿色线：表示配置了一个隧道，它允许在IPv4和IPv6网络之间安全地传输数据。隧道的本地端点是芝加哥的IPv4地址（10.1.1.1），远程端点是达拉斯的IPv4地址（10.1.2.1），并且隧道的本地IPv6地址是芝加哥的IPv6地址（4321::54bc）。 图示展示了两个使用不同IP协议版本的网络之间的互联方式，并通过一个配置了隧道的路由器进行数据传输。这显示了在IPv4和IPv6共存环境中如何实现网络互操作性。 IPv4和IPv6是两种互联网协议版本，它们是互联网通信的基础。 IPv4（Internet Protocol version 4） IPv4 是第四版的互联网协议，目前广泛使用于互联网中。 它基于32位地址长度，这意味着它可以支持大约43亿个独特的IP地址。 IPv4地址通常以点分十进制形式表示，例如192.168.1.1。 IPv6（Internet Protocol version 6） IPv6 是为了解决IPv4地址耗尽问题而设计的下一代互联网协议。 它基于128位地址长度，这意味着它可以支持几乎无限数量的设备。 IPv6地址通常以冒号分隔的十六进制形式表示，例如2001:0db8:85a3:0000:0000:8a2e:0370:7334。 主要区别 地址空间：IPv4的地址空间相对较小，而IPv6提供了更大的地址空间来满足互联网的增长需求。 安全性：IPv6设计之初就考虑了安全性，包括IPsec（一种用于IP网络通信加密和认证的框架）作为标准部分，而IPv4中IPsec是可选的。 配置：IPv6支持自动配置能力，设备可以自动分配IP地址，而IPv4通常需要手动分配或通过DHCP（动态主机配置协议）实现自动分配。 数据包处理：IPv6简化了数据包头部结构，以提高处理速度和效率。 移动性和多播：IPv6原生支持移动性和多播传输，而IPv4则需要额外的协议支持。 IPv4到IPv6的过渡是一个复杂的过程，因为它们不直接兼容。为了解决这个问题，实施了多种过渡技术，例如隧道和双栈策略，以便两种协议可以在同一网络内协同工作。 3. 城域网 (MAN - Metropolitan Area Network) 定义：MAN是介于LAN和WAN之间的网络，通常覆盖一个城市。 用途：常用于连接多个局域网，提供高速网络服务给整个城市 MAN连接了多个局域网（LAN - Local Area Network），每个LAN都通过一个网络处理引擎（NPE - Network Processing Engine）与MAN相连。 城域网（MAN）：位于图中心，代表了城市或都市区域的网络。 局域网（LAN）：分布在MAN周围，每个LAN可能代表一个不同的组织、办公室建筑或校园网络。 网络处理引擎（NPE）：在每个LAN和MAN之间的连接点处，有一个标记为NPE的设备。这些设备负责处理进入和离开局域网的数据，可能执行数据路由、交换、安全和其他网络服务。 NPE（Network Processing Engine）通常指的是一种高性能的网络处理器，它被设计用来处理和转发数据包。在城域网（MAN - Metropolitan Area Network）的环境中，NPE的作用是尤为关键的，因为它可以处理高速网络流量，确保数据包的快速和有效传输。 在城域网中，NPE可以用于以下几个主要方面： 数据包转发：NPE负责在网络设备中高效地处理和转发数据包。由于城域网通常连接着多个局域网（LANs），NPE在处理大量跨网络流量时的性能至关重要。 路由决策：NPE可以进行复杂的路由计算，以确定数据包的最佳路径。这对于确保在城域网环境中数据传输的高效性和可靠性非常重要。 流量管理：在城域网中，NPE可能涉及流量整形、负载平衡和拥塞管理等任务，以优化网络性能和资源利用。 安全处理：NPE还可以执行一些安全相关的功能，比如入侵检测、防火墙功能和VPN支持。 质量服务（QoS）：NPE可以帮助实施QoS策略，确保关键应用和服务得到优先的网络资源，保证服务质量。 在城域网这样的高速网络环境中，NPE的作用不仅仅局限于数据包的基本转发，它还涉及到整个网络性能和服务质量的维护和提升。随着网络技术的发展，NPE的功能和重要性只会继续增长。 4. 个人区域网 (PAN - Personal Area Network) 定义：PAN是一个非常小的网络，用于连接个人设备，如手机、笔记本电脑和平板电脑。 用途：用于个人设备间的数据传输，如通过蓝牙或Wi-Fi。 5. 无线局域网 (WLAN - Wireless Local Area Network) 定义：WLAN是一种无线的局域网，使用无线数据连接来链接多个设备。 用途：提供与LAN相似的功能，但无需物理连线，增加了移动性。 6. 虚拟私人网 (VPN - Virtual Private Network) 定义：VPN是一种通过公共网络（如互联网）提供加密连接的网络技术。 用途：允许远程用户安全地访问内部网络资源，常用于企业远程工作和数据保护。 互联网服务提供商（ISP）：连接用户到互联网的公司或组织。 互联网：全球性的公共网络。 内部网（Intranet）：一个私人网络，通常是公司或组织内部的网络，它包含了受保护的资源和服务。 VPN连接：一个安全的连接，通过公共互联网从用户到内部网。 隧道：VPN连接创建了一条加密的“隧道”，它通过不安全的互联网传输数据。隧道保护了数据不被外部读取或干扰，即使数据在公共互联网上传输。 在这个场景中，用户通过ISP连接到互联网，并通过VPN创建一个安全的隧道连接到其公司的内部网。这种方式允许远程用户安全地访问公司网络内部的资源，如同他们直接连接到公司的局域网（LAN）一样。这是远程工作和保护数据在不安全网络上传输的常见方式。 7. 企业私人网络 (EPN - Enterprise Private Network) 定义：EPN是专为特定企业设计的私人网络，用于连接企业内部各部门和资源。 用途：用于大型企业，确保数据安全性和网络管理的高效性。 远程工作者（Telecommuters）如何通过本地互联网服务提供商（Local ISP）连接到企业局域网（Enterprise LAN），并访问位于企业内部的资源: 远程工作人员（Telecommuters）：流程开始于远程工作者。这些用户需要从家庭或远程办公地点通过其个人电脑接入企业网络。 本地ISP（Local ISP）：远程工作者通过本地互联网服务提供商连接到互联网。本地ISP负责将用户的数据传输到互联网上，并且是用户通往互联网的桥梁。 互联网：一旦远程工作者的数据流通过本地ISP，它就进入了互联网，这是一个全球性的公共网络。 远程接入服务器（Remote Access Server）：远程工作者通过互联网连接到企业的远程接入服务器。这通常涉及到建立一个虚拟私人网络（VPN）连接，它在用户和企业网络之间创建了一条加密的通道，确保数据传输的安全性。 企业局域网（Enterprise LAN）：一旦远程工作者通过VPN连接成功，他们就可以访问企业局域网，就如同他们物理地处于企业的办公室内一样。 文件服务器（File Servers）：在连接到企业LAN之后，远程工作者可以访问文件服务器，这些服务器存储了企业的共享文档和资源。 服务器农场（Server Farm）：除了文件服务器，远程工作者还可能需要访问服务器农场中的应用服务器，这些服务器提供了企业运行所需的关键业务应用程序和数据处理服务。 第二层交换机（L2 Switch）：LAN中的数据流通过第二层交换机，它负责在数据链路层转发数据帧到正确的目的地。 网关路由器（Gateway Router）：如果远程工作者需要访问互联网上的资源，流量会经过企业的网关路由器。这台路由器也可能执行网络地址转换（NAT）和安全功能，如防火墙。 企业ISP（Enterprise ISP）：最后，如果数据需要发送到企业外部的目的地，它将通过企业的互联网服务提供商转发出去。 8. 内容分发网络 (CDN - Content Delivery Network) 定义：CDN是一组分布在多个地理位置的服务器，用于有效地传递互联网内容。 用途：用于快速传送大量数据，常用于网页内容、视频流媒体等。 9. 云计算网络 定义：这类网络是基于云计算技术，提供资源和服务的虚拟化网络。 用途：支持各种云服务，如软件即服务（SaaS）、平台即服务（PaaS）和基础设施即服务（IaaS）。 云计算（Cloud Computing） 云计算是一种利用远程服务器网络（通常在互联网上）来存储、管理和处理数据的模式，而不是在本地计算机或服务器上。这种模型允许用户和企业使用互联网来访问更强大的计算资源和大规模存储设施。 特点： 集中式数据处理：数据处理和存储在中心化的数据中心进行。 可扩展性：云服务提供动态扩展能力，根据需求增减资源。 成本效益：用户通常按使用量付费，减少了前期投资和维护成本。 全球访问：用户可以从世界任何地方通过互联网访问服务。 边缘计算（Edge Computing） 边缘计算则是数据在产生源头附近的网络边缘或设备上进行处理。这种模式旨在将计算任务从中心化的数据中心转移到网络的边缘，减少延迟，提高响应速度。 特点： 分布式数据处理：数据处理在离数据源更近的地方进行，如用户的设备或本地服务器上。 降低延迟：通过在数据产生的地方进行处理，减少了数据传输到中心数据中心的需要，从而降低了延迟。 带宽效率：减少了大量数据传输，节省了带宽，对于带宽受限的场景特别有用。 实时处理：适用于需要即时反馈的应用，如自动驾驶车辆、工业自动化等。 云计算 vs 边缘计算 ​ 数据中心远近：云计算依赖远程数据中心，而边缘计算依赖近端处理。 ​ 延迟问题：云计算可能面临网络延迟问题，边缘计算则能提供更低延迟。 ​ 带宽需求：云计算可能需要更多的带宽来传输数据，边缘计算减少了跨网络的数据流量。 ​ 适用场景： 云计算适用于需要大量计算和存储资源，但对延迟要求不是特别高的场景。 边缘计算适用于对实时分析和响应有严格要求的场景。 结合使用 云计算和边缘计算可以结合使用，形成云边协同的架构。在这种架构中，边缘计算负责实时的数据处理和决策，而云计算则负责深度分析和长期存储。这种模式可以最大化地利用两者的优势，满足不同的业务需求。 10.其它 传感器网络（Sensor Networks）：由许多分布式传感器组成，用于监测和记录物理环境的条件，并将收集的数据传输到一个中心位置。 虚拟网络（Virtual Networks）：通常建立在其他网络之上，通过软件定义网络（SDN）等技术实现。 存储区域网络（SAN - Storage Area Network）：连接存储设备和服务器的专用高速网络，允许服务器访问共享存储资源。SAN是一个高速的专用网络，连接存储设备与服务器，通常使用光纤通道（Fibre Channel）或iSCSI协议。 ​ 特点： ​ 性能高：SAN为服务器提供块级别的存储，可以实现高速数据传输。 ​ 可扩展性强：可以支持大量存储设备，适合大型企业。 ​ 灵活性：存储资源可以在SAN中被多个服务器共享。 ​ 适用场景： ​ 数据中心 ​ 大型数据库应用 ​ 高性能计算环境 ​ NAS（Network Attached Storage 网络附加存储）: ​ NAS是一种专用的文件存储设备，它通过网络提供数据访问给网络上的其他设备。 ​ 特点： ​ 易于访问和共享：NAS通过标准的网络协议（如NFS、SMB&#x2F;CIFS）提供文件级别的存储和访问，使得不同操作系统的用户可以共享数据。 ​ 配置简单：通常易于安装和配置，适合于需要文件共享的小型办公环境。 ​ 可扩展性：可以根据需要添加更多的存储设备。 ​ 适用场景： ​ 文件共享, 小型企业的数据备份, 媒体服务器 ​ DAS（直接附加存储 Direct Attached Storage） ​ DAS是直接连接到计算机的存储设备，例如内部或外部硬盘驱动器。 ​ 特点： ​ 成本低：相比NAS和SAN，DAS通常更便宜，因为它不需要额外的网络设备。 ​ 简单性：直接连接到服务器，不需要复杂的配置。 ​ 性能：由于是直接连接的，可以提供良好的数据传输速度。 ​ 适用场景： ​ 个人计算机, 小型办公环境, 需要快速数据访问的应用 集成服务数字网络（ISDN - Integrated Services Digital Network）：早期的高速网络服务，提供语音和数据服务。 网络架构（Network Architectures）架构模式则是指在这些网络中实现数据交换和处理的方法和设计： 关注于如何在网络中设计和组织资源、服务和数据流。它们描述的是网络内部数据和服务的组织和流动方式。 1. 客户端&#x2F;服务器（C&#x2F;S - Client&#x2F;Server） 定义：C&#x2F;S架构中，客户端和服务器是两个独立的实体。客户端发送请求到服务器，服务器处理请求并返回数据。 特点：客户端软件通常需要安装在用户的设备上，可以提供丰富的功能和良好的用户体验。服务器负责数据处理和存储。 应用：常见于企业应用、多用户系统、网络游戏等领域。 2. 浏览器&#x2F;服务器（B&#x2F;S - Browser&#x2F;Server） 定义：B&#x2F;S架构中，用户通过浏览器（作为客户端）来访问服务器上的资源和服务。 特点：不需要在客户端安装特定的软件，只需一个浏览器即可访问服务。服务器处理后端逻辑和数据存储。 应用：互联网网站、Web应用程序等。 3. 移动端&#x2F;服务器（M&#x2F;S - Mobile&#x2F;Server） 定义：M&#x2F;S架构专注于移动设备作为客户端，与服务器进行交互。 特点：适应了移动设备的特性，如触摸界面、定位服务和推送通知。服务器处理复杂的逻辑和数据存储。 应用：移动应用程序，如社交媒体应用、移动电子商务应用等。 4. 对等网络（P2P - Peer-to-Peer） 定义：在P2P架构中，每个节点既作为客户端又作为服务器，节点之间直接交换数据。 特点：不依赖中心化的服务器，提高了系统的可扩展性和容错能力。 应用：文件共享系统、加密货币网络、某些通信应用等。 5.微服务架构（Microservices Architecture） 定义：微服务架构是一种将应用程序作为一组小服务开发的方法，每个服务在其自己的进程中运行，通常围绕业务能力构建。 特点：服务之间通过轻量级的通信机制进行交互，每个服务独立部署，可在不同的环境中独立扩展。 应用：现代云应用、大型企业级应用等。 6. 服务导向架构（SOA - Service-Oriented Architecture） 定义：SOA是一种设计模式，其中应用程序的组件提供服务给其他组件，通过网络中的通信协议进行交互。 特点：强调可重用的服务，服务之间通常是松耦合的。 应用：企业级应用、系统集成等。 7. 网格计算（Grid Computing） 定义：网格计算是一种分布式计算形式，它将来自不同域的计算资源连接起来，以达到共同的目标。 特点：高度分布式，适合于大规模的数据处理和复杂计算任务。 应用：科学研究、大规模模拟、数据分析等。 8. 雾计算（Fog Computing） 定义：雾计算是一种分布式计算架构，它将计算、存储和网络服务扩展到网络的边缘。 特点：减少了对中心数据中心的依赖，减少延迟，提高了数据处理的速度。 应用：物联网（IoT）、实时数据分析、智能城市等。 总的来说，网络类型和架构模式是网络设计的两个不同层面。类型更侧重于网络的物理和逻辑布局，而架构则侧重于系统的内部设计和数据流动。两者相辅相成，共同构成完整的网络系统。 HTTP协议背景知识：OSI模型 OSI模型，全称是“开放式系统互连参考模型”（Open Systems Interconnection Reference Model），是一个用于解释和标准化网络内不同计算机系统之间通信过程的概念模型。这个模型由国际标准化组织（ISO）在1980年代初期开发，目的是促进不同类型计算机系统之间的兼容性和标准化通信。 层面 功能 物理层（Physical Layer） 负责实际的物理连接，包括电缆、光纤、无线电频率等的传输媒介。 数据链路层（Data Link Layer） 负责在相邻节点之间的可靠连接，处理帧定界、物理地址寻址、流量控制等。 网络层（Network Layer） 负责在多个网络之间建立、维护和终止连接，包括路由选择、分组转发等。 传输层（Transport Layer） 负责在端到端的通信中保持数据的完整性，处理错误检测和恢复、数据传输顺序等。 会话层（Session Layer） 负责建立、管理和终止会话，控制数据交换的对话和同步。 表示层（Presentation Layer） 负责数据的表示、加密和压缩，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。 应用层（Application Layer） 为各种应用软件提供服务，包括电子邮件、文件传输和其他网络软件服务。 每一层都有其特定的功能，它们一起协作，确保从一个设备到另一个设备的数据传输是顺畅和高效的。虽然在实际的网络实现中，如因特网的TCP&#x2F;IP模型更为普遍，但OSI模型仍然是理解网络通信非常重要的一个概念工具。 原因计算机之间也是需要一种规则，保障之间信息的有效交流，这就是HTTP协议; 概念及特点 HTTP是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW: World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 目前互连网上90%的网络传输都是基于HTTP协议。 HTTP是一个基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）; 使用TCP通信协议的重要的原因是基于其面向连接的特点： TCP&#x2F;IP（传输控制协议&#x2F;网际协议）是一组用于控制网络通信的协议，并且是因特网的基础。它由两个主要的协议组成：TCP和IP。 IP（网际协议）：负责将数据包从发送方路由到接收方。IP提供了一种机制，可以识别发送和接收设备的唯一地址（即IP地址）。IP协议主要负责数据包的寻址和路由，确保数据能够在网络中正确地从一个点传送到另一个点。 TCP（传输控制协议）：在IP提供的基础上，TCP负责在两个终端之间建立可靠的连接，确保数据准确无误地传输。它通过分割数据为多个部分、确保每个部分都被正确接收，并且在必要时进行重传，来完成这一任务。TCP还负责控制数据传输的速率，防止网络拥塞。 TCP&#x2F;IP模型通常被划分为四层，每层都有其特定的功能： 层面 功能 应用层 直接为用户的应用程序（如浏览器、电子邮件客户端等）提供服务。 传输层 包括TCP和UDP（用户数据报协议），负责提供端对端的通信。 互联网层 主要包括IP协议，负责在多个网络之间传输数据包。 网络接口层 包括用于实际网络连接的各种协议，负责数据在物理网络上的传输。 TCP&#x2F;IP模型由于其简洁性和高效性，在互联网的发展中起到了核心作用，是现代网络通信不可或缺的一部分。 HTTPS（安全超文本传输协议） 定义与用途： HTTPS是HTTP的安全版本，用于在不安全的网络上安全传输数据。 它通过加密和认证确保数据传输的安全性和完整性。 加密机制： 传输层安全性（TLS）或安全套接层（SSL）：HTTPS使用这些协议对数据进行加密。 加密保护数据不被中间人攻击（MITM）窃听或篡改。 数字证书： HTTPS使用数字证书验证服务器的身份，确保用户正在与预期的服务器通信。 数字证书由权威的证书颁发机构（CA）签发。 特点： 增加了安全层：相比HTTP，HTTPS提供了数据的机密性和完整性。 性能开销：加密和解密过程需要额外的处理，可能会略微影响性能。 HTTP与HTTPS的比较 安全性：HTTPS明显优于HTTP，因为它通过加密保护数据。 端口：HTTP通常使用端口80，而HTTPS使用端口443。 应用场景：对于需要保护数据安全的网站（如在线银行、电子商务等），强烈推荐使用HTTPS。 总之，HTTP和HTTPS都是实现网络通信的重要协议，但HTTPS在安全性方面提供了显著的优势。随着网络安全意识的提高，越来越多的网站和服务正在转向HTTPS。 三.HTTP协议的使用HTTP请求流程一次http请求的基本流程是，有客户端向服务端发起一次请求(request), 而服务器在接收到以后返回给客户端一个响应（response）。所以一次完整的http请求包含请求和响应两部分。 客户端打开连接：当在浏览器中输入一个URL或点击一个链接时，浏览器会向服务器发起一个HTTP请求。这通常开始于TCP的三次握手过程，建立客户端和服务器之间的连接。 发送HTTP请求：一旦TCP连接建立，客户端（如浏览器）就会通过这个连接发送一个HTTP请求。这个请求包含了请求行（如“GET &#x2F;index.html HTTP&#x2F;1.1”）、请求头（包含用户代理信息、接受的内容类型等）和（在POST请求中）一个请求体。 服务器处理请求：服务器接收到HTTP请求后，会根据请求的资源（如HTML文件、图像等）进行处理。 服务器响应：服务器处理完请求后，会回送一个HTTP响应。这个响应包含一个状态行（如“HTTP&#x2F;1.1 200 OK”）、响应头（包含内容类型、长度等）和响应体（请求的数据）。 关闭连接：在交换完数据后，通常由客户端发起TCP的四次挥手过程来关闭TCP连接。 TCP三次握手（建立连接） SYN：客户端发送一个SYN（同步序列编号）标志的TCP包到服务器，以开始一个新的连接。 SYN-ACK：服务器接收到SYN包后，回送一个包含SYN和ACK（确认字符）标志的TCP包以确认收到。 ACK：客户端收到服务器的SYN-ACK包后，再发送一个ACK包作为响应，完成连接建立。 这个过程主要确保双方都准备好开始新的连接。 数据传输（正在连接）一旦TCP连接建立，HTTP请求就可以通过这个连接发送了。 HTTP请求：客户端通过建立好的TCP连接，发送一个HTTP请求到服务器。这个请求包含了请求方法（如GET或POST）、请求的资源（如网页）、以及其他必要的头信息。 服务器处理：服务器接收并处理这个请求，然后准备相应的HTTP响应。 HTTP响应：服务器通过同一个TCP连接返回一个HTTP响应。响应通常包含状态码（如200 OK），响应头信息，以及请求的数据（如HTML文档）。 TCP四次挥手（关闭连接） FIN：当通信结束时，发起关闭的一方（通常是客户端）会发送一个FIN（结束）标志的TCP包，表明它已经没有数据发送了。 ACK：接收方接到FIN包后，会回送一个ACK包作为确认。 FIN：接着，接收方发送一个带有FIN标志的TCP包，以表明它也没有数据发送了。 ACK：最后，发起关闭的一方收到FIN后，再发送一个ACK包作为响应。一段时间后，连接被完全关闭。 这个过程确保了双方都能够完成所有数据的发送和接收，从而安全地关闭连接。 URL发送http请求时，通过URL对网络资源进行定位。 URL（Uniform Resource Locator），中文叫统一资源定位符。是用来标识某一处资源的地址。也即是我们常说的网址。以下面这个URL为例，普通URL的各部分组成： 协议 定义：指定了如何通过网络访问资源的方法或规则。 常见例子：http, https。这决定了与服务器交互时使用的规则和标准。 域名 定义：是互联网上一个服务器或一组服务器的易于记忆的地址。 作用：它被解析成一个IP地址，这是定位服务器的实际数字标识。 例子：example.com。 端口（默认80） 定义：一个网络地址的一部分，用于标识特定的进程或服务。 默认值： 对于HTTP，端口默认是80。 对于HTTPS，端口默认是443。 说明：在URL中通常省略默认端口。 端口在网络通信中是一个重要的概念，它们用于区分一台计算机上的不同服务或进程。在TCP&#x2F;IP协议中，一个端口被定义为一个数字，这个数字用来区分主机上的不同服务或应用程序。每个TCP或UDP包都有特定的端口号，以确保数据传输的正确性。 端口分类 ​ 端口号的范围从0到65535，根据用途不同，端口被划分为以下几类： 系统或保留端口（0-1023）： 这些是众所周知的端口号，通常由系统或者特定的应用程序使用。 例如，HTTP服务通常使用端口80，HTTPS服务使用端口443，FTP使用端口21。 用户或注册端口（1024-49151）： 这些端口可由用户或应用程序使用，不需要系统级权限。 很多著名的应用程序会使用这一范围内的端口号。 动态或私有端口（49152-65535）： 这些端口一般不用于特定服务，而是动态分配给客户端临时通信。 常见服务的标准端口 MySQL：默认端口为3306。 MongoDB：默认端口为27017。 REST API：没有固定端口。REST API是一种设计风格，而不是应用程序或服务。它可以运行在任何端口上，通常选择的是80或443（如果使用HTTPS）。 端口的重要性 安全性：一些端口因为常用于特定服务而更受攻击者关注，例如80和443。因此，网络安全措施经常涉及这些端口的监控和保护。 配置和管理：正确配置端口对于确保网络服务正确运行至关重要。例如，在部署数据库或API时，必须确保端口设置正确，且不与其他服务冲突。 结论 端口是网络通信的基本组成部分，正确理解和使用端口对于维护网络服务的健康和安全非常重要。每种服务都可能有一个或多个默认端口，但这些可以根据具体需求或安全考虑进行更改。 路径 定义：表示服务器上资源的具体位置。 结构：通常由一系列的斜杠(/)分隔的部分组成。 例子：在URL http://example.com/photos/image.jpg 中，/photos/image.jpg 是路径，指向服务器上的特定图片。 参数 定义：用于提供额外信息以完成对资源的请求。 结构：通常以问号（?）开始，后跟一系列的“键-值”对，每对之间用和号（&amp;）分隔。 例子：在URL http://example.com/index.html?page=2&amp;sort=asc 中，page=2&amp;sort=asc 是参数，用于指示页面编号和排序方式。 HTTP请求格式 (请求行,请求头,空行,请求体)客户端发送一个HTTP请求到服务器的请求消息包括以下部分：请求行，请求头，空行和请求数据。 一旦TCP连接建立，HTTP请求就发生在这个连接上。HTTP请求是在应用层发生的，HTTP请求依赖于TCP连接。在HTTP请求发送之前，TCP三次握手必须先完成，以确保数据传输的可靠性，具体分为以下几个部分： 请求行： ​ 包括HTTP方法（如GET, POST等）、请求的资源路径和HTTP版本，例如，GET /index.html HTTP/1.1。 ​ HTTP请求方法定义了客户端与服务器交互的不同方式。每种方法都有其特定用途。以下是HTTP 1.0和HTTP 1.1中定义的请求方法及其描述的整理： HTTP 1.0 定义的请求方法 GET 描述：请求指定的页面信息，并返回实体主体。 特点：URL中添加请求参数，显示在地址栏；请求字符串限制1024个字节；主要用于获取数据。 POST 描述：向指定资源提交数据进行处理请求（如提交表单或上传文件）。数据包含在请求体中。可能导致新资源的建立和&#x2F;或已有资源的修改。 特点：没有大小限制；相对于GET更安全，因为数据不会显示在URL中。 HEAD 描述：类似于GET，但服务器返回的响应中不包含实体的主体部分。用于获取报头。 特点：常用于验证资源是否存在，以及获取资源的元数据。 HTTP 1.1 新增的请求方法 OPTIONS 描述：允许客户端查看服务器的性能。 特点：用于客户端确定服务器对特定资源支持的方法。 PUT 描述：向指定资源位置上传其最新内容，通常用于更新内容。 特点：替换所有当前表示的内容。 DELETE 描述：请求服务器删除指定的资源。 特点：用于删除资源。 TRACE 描述：回显服务器收到的请求，主要用于测试或诊断。 特点：用于诊断信息。 CONNECT 描述：预留给能够将连接改为管道方式的代理服务器。 特点：用于代理服务器。 注意事项 方法名称是区分大小写的。 当资源不支持某个方法时，服务器应返回状态码405（Method Not Allowed）；当服务器不认识或不支持某个方法时，应返回状态码501（Not Implemented）。 HTTP服务器至少应实现GET和HEAD&#x2F;POST方法，其他方法是可选的。服务器还可以支持扩展的自定义方法。 总的来说，不同的HTTP请求方法支持不同的操作，选择适当的方法取决于执行的操作和所需的结果。GET和POST是最常用的两种方法，分别用于获取和提交数据。 请求头：包含关于请求的附加信息，如用户代理、接受类型等。由多个头部字段组成，每个字段包含一个名称和一个值，用冒号(:)分隔。请求头提供了关于请求的附加信息，例如客户端信息、所需内容类型等。例如： 1234567891011121314Host: www.baidu.com 请求的目标主机和端口号（如果非默认端口）User-Agent: Mozilla/5.0 (Windows NT 10.0; ...) 发出请求的浏览器或其他客户端的标识Referer: http://www.example.com/index.html 页面跳转处，指出产生请求的页面URLAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 客户端能够接收的内容类型Accept-Language: en-US,en;q=0.5 用户希望优先接收的语言和地区Accept-Encoding: gzip, deflate, br 客户端支持的内容编码（如压缩算法）Accept-Charset: utf-8, iso-8859-1;q=0.5 可接受的应答的字符集Connection: keep-alive 控制选项，如是否保持连接持续Cache-Control: max-age=0 关于缓存的指令Cookie: BAIDUID=... 包含服务器之前发送到用户浏览器的CookieContent-Length: 348 发送给HTTP服务器数据的长度Content-Type: application/json 具体请求的媒体类型Content-Range: bytes 21010-47021/47022 响应资源的范围Cache-Control: no-cache 指定请求和响应遵循的缓存机制 每次HTTP请求的头部可能会有所不同，这取决于发出请求的客户端、用户的配置、网站的要求等多种因素。 如果想查看一个具体网站（比如百度官网）的HTTP请求头，可以使用浏览器的开发者工具来查看。可以通过右键点击网页并选择“检查”或者使用F12键来打开开发者工具，然后切换到“网络”选项卡，查看具体的请求详情。 空行：请求头和请求体之间的一个空行，标识请求头的结束。 请求体：不是所有的HTTP请求都有请求体，它主要用于像POST这样的方法，包含了发送给服务器的数据。例如，在表单提交时，请求体可能包含填写的表单数据。POST 方法适用于需要客户填写表单的场合。与请求体相关的最常使用的是包体类型 Content-Type 和包体长度 Content-Length; HTTP响应格式 (状态行,响应头,空行,响应正文) 状态行 ​ 状态行由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开; 状态码 由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示： 1xx：表示服务器已接收了客户端请求，客户端可继续发送请求; 2xx：表示服务器已成功接收到请求并进行处理; 3xx：表示服务器要求客户端重定向; 4xx：表示客户端的请求有非法内容; 5xx：表示服务器未能正常处理客户端的请求而出现意外错误; 状态码描述文本有如下取值： 200 OK：表示客户端请求成功; 400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解; 401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用; 403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因; 404 Not Found：请求的资源不存在，例如，输入了错误的URL; 500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求; 503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常; 响应头 ​ 响应头的具体内容可以根据服务器的配置和特定请求而变化。 Allow服务器支持哪些请求方法（如GET、POST等）。 Date表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon，31Dec200104：25：57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。 Set-Cookie非常重要的header，用于把cookie发送到客户端浏览器，每一个写入cookie都会需要一个Set-Cookie。 Expires指定Response的过期时间，从而不再缓存它，重新从服务器获取，会更新缓存。过期之前使用本地缓存。降低服务器负载，缩短加载时间。 Content-Type WEB服务器告诉客户端自己响应的对急的类型和字符集。 Content-Encoding：内容编码格式 空行 响应头和响应体由空行连接。 最后一个响应头之后是一个空行，发送回车符和换行符，通知客户端以下不再有请响应头; 响应体 该响应消息的响应体是一个HTML文档。浏览器可以直接识别这个HTML文件。而我们访问的是一个JSP文件，响应回去的是一个HTML文件。说明服务器将该JSP翻译成了一个HTML，然后再响应给浏览器。 HTTP三点注意事项 HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP&#x2F;1.1开始支持持久连接（keep-alive），允许在一个连接上处理多个请求，但是是串行处理不是并行。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 这种无状态的情况，并不适合我们进行业务需求，我们需要保持我们的登录状态，方便我们访问。通常使用cookies、session等技术在HTTP层之上维护状态。 四.会话技术原因 HTTP是无状态的，那服务端怎么区分同一个用户的连续请求呢，这就用到了会话技术：Cookies和session。 概念 Cookie 有时也用其复数形式 Cookies。指某些网站为了辨别用户身份、进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密）。最新的规范是 RFC6265 。 Cookie 可以理解为一个凭证1.实际是由服务器发给客户端的特殊信息，2.这些信息以文本文件的方式存放在客户端，3.客户端每次向服务器发送请求的时候都会带上这些特殊的信息。服务器在接收到Cookie以后，会验证Cookie的信息，以此来辨别用户的身份。 Session中文经常翻译为会话，其本来的含义是指有始有终的一系列动作&#x2F;消息，比如打电话时从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个Session。这个词在各个领域都有在使用，而我们Web领域，一般使用的是其本义，一个浏览器窗口从打开到关闭这个期间。 Session的目的则是，在一个客户从打开浏览器到关闭浏览器这个期间内，发起的所有请求都可以被识别为同一个用户。 而实现的方式则是，在一个客户打开浏览器开始访问网站的时候，会生成一个Cookie，SessionID，这个ID每次的访问都会带上，而服务器会识别这个SessionID并且将与这个SessionID有关的数据保存在服务器上。由此来实现客户端的状态识别。因此Session是基于cookie的. Session与Cookie相反，Session是存储在服务器上的数据，只由客户端传上来的SessionID来进行判定，所以相对于Cookie，Session的安全性更高。 一般SessionID会在浏览器被关闭时丢弃，或者服务器会验证Session的活跃程度，例如30分钟某一个SessionID都没有活跃，那么也会被识别为失效。 五.Proxy 代理代理的概念代理实际指代理服务器，它的功能是代替用户取获取网络信息，就像是一个网络信息的中转站。正常情况下请求一个网站时，我们发送请求给web服务器，然后web服务器把响应传回给我们；而如果设置了代理服务器，此时我们就不是直接给web服务器发送请求，而是先向代理服务器发送请求，然后代理服务器再把我们的请求转发给目标web服务器，接着web服务器把响应返回给代理服务器，之后代理服务器再把响应返回给我们。使用这样的访问方式，我们同样可以正常访问网页，但是中间经过了代理服务器后，web服务器就不能识别到我们本机的IP了，只能识别代理服务器的IP，这样我们本机的真实IP就被伪装起来了，这就是代理服务器的基本原理和作用。 代理的作用代理具体有什么作用呢 突破自身IP访问限制，访问一些自身IP不能访问的站点。 访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。 提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。 隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。 代理对于爬虫的作用 由于爬虫爬取速度过快，在爬取过程中可能遇到同一个IP访问过于频繁的问题，此时网站就会让我们输入验证码登录或者直接封锁IP，这样会给爬取带来极大的不便。使用代理隐藏真实的IP，让服务器误以为是代理服务器在请求自己。这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果。","categories":[{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"网络协议","slug":"网络协议","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"网络类型","slug":"网络类型","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B/"},{"name":"网络架构","slug":"网络架构","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"}],"author":"Yiuhang Chan"},{"title":"Tableau数据可视化图表","slug":"20201005Tableau数据可视化图表","date":"2020-10-05T05:32:48.000Z","updated":"2024-02-28T10:50:12.000Z","comments":true,"path":"2020/10/05/20201005Tableau数据可视化图表/","permalink":"https://www.yiuhangblog.com/2020/10/05/20201005Tableau%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8/","excerpt":"Tableau的认识操作，可视化图表创建","text":"什么是Tableau？Tableau 是一款强大的数据可视化工具，广泛用于数据分析和商业智能领域。它使用户能够通过拖放的方式轻松创建和分享各种各样的交互式和可视化的数据报告。Tableau 支持从多种数据源获取数据，包括 Excel、SQL 数据库、云服务中的数据等。 Tableau 的主要特点包括： 易用性：用户无需编程知识即可快速创建复杂的数据可视化。 强大的数据处理能力：Tableau 能够处理大量数据，并从中提取有价值的信息。 交互性：创建的可视化报告是交互式的，用户可以通过筛选、排序等操作深入探索数据。 灵活的数据连接选项：支持连接到各种数据源，包括实时数据和大数据平台。 分享和协作：Tableau 的报告可以通过 Tableau Server 或 Tableau Online 轻松与他人共享，支持团队协作。 Tableau 提供不同的产品来满足不同的需求，包括 Tableau Desktop（用于个人数据分析和报告创建）、Tableau Server（企业级数据分享和管理）、Tableau Online（基于云的共享和协作平台）以及 Tableau Public（允许用户免费创建和发布数据可视化到网上）。 通过使用 Tableau，组织和个人可以更加直观地理解数据，帮助做出基于数据的决策。 Tableau 家族产品初探索Tableau Desktop Tableau Desktop 是 Tableau 产品套件中的一个核心组件，专为个人数据分析和可视化设计而设计。它使用户能够在本地计算机上直接创建丰富、交互式的数据可视化、报告和仪表板。以下是 Tableau Desktop 的一些关键特点和功能： 数据连接 多数据源连接：Tableau Desktop 支持连接到几乎任何类型的数据源，包括文件（如 Excel、CSV）、数据库（如 SQL Server、MySQL）、云服务（如 Google Analytics、Salesforce）等。 数据混合：能够将来自不同数据源的数据组合在一起，进行更深入的分析。 可视化创建 拖放界面：通过直观的拖放操作，用户可以轻松地创建各种数据可视化，无需编程知识。 高度可定制：提供多种可视化类型和自定义选项，让用户能够设计出满足特定需求的报告和仪表板。 交互式探索：用户可以通过筛选、钻取和排序等交互操作，深入探索数据。 分析功能 即席查询：允许用户快速对数据进行即席分析，探索数据之间的关系。 高级分析：支持趋势线、预测、聚类等高级分析功能，帮助用户识别模式和趋势。 共享与协作 发布和共享：创建的视图和仪表板可以发布到 Tableau Server 或 Tableau Online，与同事或客户共享，实现团队协作和数据驱动决策。 交互式仪表板：发布的仪表板保持其交互性，使最终用户能够根据自己的需要探索数据。 版本和许可Tableau Desktop 提供不同的版本，包括专业版和个人版，以满足不同用户的需求。专业版提供了更广泛的数据连接选项和功能，而个人版则在功能上有所限制。Tableau Desktop 是基于订阅的许可模式，用户需要购买许可才能使用。 通过 Tableau Desktop，数据分析师和业务用户可以将复杂的数据转化为易于理解和交互的视图，从而发现洞见并做出更加明智的决策。 Tableau Server Tableau Server 是 Tableau 产品家族中的一个关键组成部分，设计用于在企业环境中共享、协作和发布 Tableau 数据可视化和仪表板。它是一个在线平台，允许用户通过 web 浏览器访问在 Tableau Desktop 上创建的报告和分析。以下是 Tableau Server 的一些主要特征和功能： 数据共享与协作 安全发布：用户可以将在 Tableau Desktop 上创建的可视化、报告和仪表板安全地发布到 Tableau Server，确保数据和信息的集中管理和控制。 实时协作：支持团队成员之间的实时协作，允许用户评论、共享视图和交互式分析，促进决策过程。 访问控制和管理 灵活的权限管理：管理员可以对数据、报告和仪表板设置详细的访问权限，确保只有授权用户才能访问敏感信息。 用户和群组管理：支持对用户和群组进行管理，简化了权限和访问控制的配置。 移动访问 移动优化：Tableau Server 提供的视图和仪表板针对移动设备进行了优化，支持在各种设备上（如智能手机和平板电脑）进行访问和交互。 集成和扩展性 企业级集成：可以与企业中现有的认证系统（如 Active Directory）集成，实现单点登录（SSO）。 API和扩展：提供丰富的 API 支持，允许开发者创建自定义应用程序和集成，扩展 Tableau 的功能。 可伸缩性和可靠性 高可伸缩性：Tableau Server 设计用于满足从小型团队到大型企业的需求，可以根据组织的成长进行扩展。 数据刷新和自动化：支持定期数据刷新和报告自动化，确保用户总是访问到最新的数据。 部署选项 本地部署：可以在企业的本地服务器上部署 Tableau Server，完全控制数据和基础设施。 云部署：也可以选择在云环境（如 Amazon Web Services、Google Cloud Platform 或 Microsoft Azure）中部署，利用云计算的灵活性和扩展性。 Tableau Server 为企业提供了一个强大的平台，用于数据驱动的决策支持，通过使数据可视化和报告更加易于访问、共享和理解，从而增强了组织的数据文化和分析能力 Tableau Online Tableau Online 是 Tableau 提供的一个托管的软件即服务(SaaS)解决方案，它允许用户通过云分享、发布和协作 Tableau 数据可视化和仪表板。它基本上是 Tableau Server 的云版本，提供相似的功能和体验，但无需企业自己维护服务器或其他硬件设备。以下是 Tableau Online 的一些主要特点和功能： 云基础架构 无需硬件维护：作为一个完全托管的服务，Tableau Online 为用户省去了安装、配置和维护服务器的需求，简化了部署和管理过程。 快速部署：用户可以迅速启动和扩展他们的数据分析项目，无需担心基础设施的限制。 数据连接和集成 连接到多种数据源：Tableau Online 支持直接连接到云基础的数据源，如 Google BigQuery、Amazon Redshift、Snowflake 等，以及通过 Tableau Bridge 实现对本地数据源的实时或定期刷新。 数据集成：允许通过各种数据集成和预处理工具准备和优化数据，以提高分析效率。 协作和分享 易于分享和访问：用户可以创建、发布和分享仪表板，使团队成员或客户能够通过 web 浏览器或移动设备访问最新的分析。 实时协作：支持在线评论、共享和交互功能，促进团队成员之间的沟通和协作。 安全性和合规性 安全的数据环境：Tableau Online 提供高级安全功能，包括数据加密、双因素认证和详细的访问控制，以保护敏感信息。 合规性：遵守包括 GDPR 在内的主要国际安全和隐私标准。 可伸缩性 自动扩展：随着需求的增加，Tableau Online 可以自动扩展，提供所需的计算资源，确保性能和响应速度。 移动访问 移动优化：通过 Tableau Mobile 应用程序，用户可以在任何地方访问和交云式的仪表板和视图，使数据分析更加灵活和便捷。 Tableau Online 适合那些希望利用云计算优势、减少 IT 开销并快速启动数据分析项目的企业和团队。它为用户提供了一个强大、灵活且易于管理的平台，用于探索、可视化和分享数据洞见。 Tableau Desktop 工作区数据源想要使用 Tableau 对数据进行分析，并且通过可视化进行展示，首先需要使用 Tableau 连接数据源，连接成功后，即可进入数据源工作区，数据源页面通常包含左侧数据窗格区、画布区、元数据网格分区数据预览区四个部分 工作表在Tableau中连接数据之后，即可进入工作表工作区。工作表工作区通常包含菜单、工具栏、数据窗口、页面和筛选器和标记卡等区域，通过将字段拖放到行列功能区上来生成可视化图表，同时也可以对数据进行简单的数据处理。 仪表板仪表板工作区是把工作表和一些图片、文本、网页类型的对象按一定的布局方式组织在一起。仪表板工作区通常包含仪表板窗口、布局窗口、仪表板视图、仪表板对象窗口等。在仪表板工作区，我们可以把之前加工的工作表整合成一张数据看板。 故事故事是将多个工作表、仪表板按照一定的逻辑顺序串联起来的PPT，一般将故事用作演示工具。故事工作区通常包含仪表板和工作表窗口、故事视图区、故事说明和导航器设置等。 数据源处理案例数据导入连接到文件：支持导入本地文件，文本，execl，cvs，json，pdf等。 连接到服务器：SQL Server，MySQL，Oracle，等关系或非关系行数据库。 Tableau字段类型 条形图与直方图案例Tableau绘制条形图概念：条形图，又称条状图，柱状图，是最常用的图标类型之一，他是通过垂直或水平的条形展示维度字段的分布情况 应用：最适宜比较不同类别的大小。 维度多为字符串类型代表的是类别 度量多为数值类型可以进行计算 求和 求平均值等 条形图1：各地区酒店数量 条形图2：各地区酒店均价 堆积图3：价格等级堆积柱状图 （应用场景用于构成） Tableau绘制直方图概念：直方图与条形图类似，主要区别在于条形图的横轴为单个类别，不用考虑纵轴上的度量值， 用条形的长度表示各类别数量的多少;而直方图的横轴为对分析类别的分组( Tableau 中称为分桶)， 横轴宽度表示各组的组距，纵轴代表每级样本数量的多少。 应用：适用于对类别进行分组统计分析。分组的原因可能是因为类别是连续的，或者类别虽然离散但是数量过多，可以视为近似于连续，当然也可以基于某种业务需要 直方图概念与用途（主要是用于呈现数值的分布情况） 创建评分直方图 ：数据桶（用于数值的区间） 数据桶建议值&#x3D;最大值与最小值的差异 场景思考什么时候用条形图？比较类别数据当需要比较不同类别或分组之间的数值时，条形图是一个非常有效的工具。例如，比较不同产品的销售额、不同地区的人口数量或不同时间段的访问量。 显示数据的排名或顺序条形图可以清晰地显示各个类别按数值大小的排名，使得观察哪些类别表现最好或最差变得直观。这对于展示排行榜或优先级排序非常有用。 展示变化或趋势虽然条形图主要用于类别比较，但它们也可以用来显示时间序列数据中的变化或趋势，特别是当时间点较少，关注点在于具体时间点的值比较时。 部分对整比较堆叠条形图或分段条形图可以用来展示不同类别在整体中所占的比例或部分对整的比较，如不同部门的支出占总预算的比例。 简单的数据量展示当数据集不是很复杂，只需要展示少量的类别和数值时，条形图是一种简单直观的展示方式。 使用条形图时的注意事项 选择适当的条形图类型：根据你的数据和分析目标，选择最合适的条形图类型，如水平条形图、垂直条形图、堆叠条形图等。 考虑条形的排序：条形的排序可以影响图表的可读性和信息的传达。根据需要考虑使用升序、降序或特定的逻辑顺序。 清晰的标签和标题：确保每个条形都有清晰的标签，使观众能够轻松理解图表中的数据。同时，图表应有一个描述性的标题，说明图表展示的是什么信息。 避免过度拥挤：当类别数量过多时，条形图可能会变得拥挤且难以阅读。在这种情况下，考虑使用其他类型的图表，或者将数据分成几个不同的图表来展示。 折线图，饼图与环形图案例数据前处理tableau 的数据可视化能力强一点，数据处理能力相对弱一点。 拆分 隐藏 自定义拆分 ： 修改数值格式 上映日期字段改为日期 绘制折线图概念：一种以折线的上升或下降来表示统计数量的增减变化趋势的统计图。 应用：最适用于时间序列的数据。 创建电影数量变化折线图 创建电影票房变化折线图 2015年的电影数量与票房比较分析 饼图与环形图概念：用圆形及圆内扇形的角度来表示数值大小的图形。 应用：最适合用来展示一个数据系列中各项值的大小与总和的比例 酒店价格等级饼图 酒店价格等级环形图 导出：导出图片 说明：撰写分析意见 场景思考什么时候使用折线图？折线图 折线图适合用于展示数据随时间的变化情况，它可以清晰地展示趋势、波动或者比较不同数据系列之间的关系。你应该在以下情况使用折线图： 时间序列数据：当你有一系列按时间顺序排列的数据点时，折线图是展示这种数据变化趋势的理想选择。 比较多个数据系列：如果你想比较多组数据在相同时间框架内的变化，折线图可以帮助观众理解这些数据系列之间的关系。 强调趋势或模式：当需要强调数据随时间的增长、下降或周期性波动时，折线图能够清楚地展示这些趋势。 什么时候使用饼图？饼图 饼图适合用于展示各部分占整体的比例关系，它通过切分圆形的方式让我们一目了然地看到各部分之间的比例大小。你应该在以下情况使用饼图： 展示比例：当你需要展示一个整体被分成几部分，以及各部分占整体的百分比时，饼图是一个好选择。 有限的分类数据：饼图最适合展示少量分类的数据比例分布。如果分类太多，饼图会显得拥挤，难以阅读。 强调部分与整体之间的关系：饼图能够清晰地展示出各部分与整体之间的比例关系，适用于当你想强调单个或多个部分在整体中所占的重要性时。 基础表，树形图，气泡图，词云案例基本表概念：基本表，又称作文本表、交叉表，即一般意义上的表格，它是一种最为直观的数据表现方式，在数据分析中具有不可忽视的作用 应用：可以代替冗长的文字叙述，便于计算、分析和对比 基本表的使用 凹凸表的使用 树状图概念：也称树形图，使用一组嵌套矩形来显示数据，也是一种突出显示异常数据点或重要数据的方法。 应用：适用于展示数据之间的层级和占比关系。 不同类型酒店数量与价格 香港不同地区酒店数量与价格 气泡图与词云概念：通过每个气泡表示维度字段的一个取值，各个气泡的大小或颜色代表了度量值的大小。 应用：具有视觉吸引力，能够以非常直观的方式展示数据的大小 不同类型电影数量与票房 动作电影动态气泡图 词云图制作 标靶图案例制作标靶图概念：通常是基于条形图的基础上，增加一些参考区间，可以帮助分析人员更加直观的了解两个度量之间的关系，通常是用来比较计划值和实际值，比如说我的这个东西有没有达到我的一个计划值或标准。 二月份电量销售额完成情况 参考线与参考区间 数据集合并概念：数据合并就是将值（行）从一个表附加到另一个表,合并两个或更多表。它用于数据结构完全一致的数据的合并，合并不会增加新的列，只是将不同文件的数据追加在一起，增加了行数。 数据分层，数据组，数据集数据分层（层级）结构 （下钻&#x2F;上卷）分层结构的概念与意义概念：它是一种维度之间自上而下的组织形式，tableau默认包含对某些结构的分层形式，如日期时间，地理角色，以日期维度为例，本身就包含年 季度 月 周 日 时。 应用：在 Tableau 中，有两种方法可以进行下钻和上卷，一种是单击行列功能区字段前方的“+”号，另-种是在视图标题上右键选择下钻。例如，我们想要查看中国不同地区、省份、城市的销售额情况，就可以利用分层结构的下钻和上卷功能 分层结构的创建与应用, 层级无法嵌套 数据分组 （分组赋值）数据组创建及使用概念：组是我们维度或度量成员值的离散组合，分组可以实现维度成员的重新组合，以及度量值的范围分类（回形针图标） 人工坐席接听分组 数据集数据集的相关概念概念：集是根据某些条件定义数据子集的自定义字段，可以理解为维度的部分成员。集能够用于计算，参与计算字段的编辑。 类型：根据是否能够随着数据动态变化，集可以分为两大类：常量集和计算集 作用：集主要用于筛选，通过选取维度的部分成员作为数据子集，以实现对不同对象的选取。 创建数据集 计算字段计算字段基础概念，类型，创建，使用，编辑 根据数据源字段维度，度量，参数等，使用函数和运算符来定义的字段，和其他字段一样也能拖放到功能区构建视图 还能由于创建新的字段，且返回值分成数值型，字符型。 会新增一个数据列 创建计算字段后会在数据源中新增一列，但不会影响原始数据 复杂一点的计算字段 if 函数 盈利标准： 123IF SUM([利润])&gt;0 THEN &quot;盈利&quot;ELSE &quot;亏损&quot;END 聚合度量聚合和维度集合，大多数情况使用的是度量聚合 粒度粒度结合散点图使用，代表的是散点图的颗粒浓度。 人口金字塔概念：又叫炫风图，本质上就是成对的条形图，在同一个行上对称的显示和比较两个类别的统计指标，用另一个分类来显示不同的行 创建人口金字塔女性人数 IF [性别]=&quot;Female&quot; THEN [总人数] ELSE 0 END 男性人数 IF [性别]=&quot;Male&quot; THEN [总人数] ELSE 0 END 漏斗图漏斗图概念与用途概念：直观的展示业务流程，可以快速发现流程中存在的问题，在电商，营销，客户关系管理等领域广泛应用 公众号流量转化漏斗图 甘特图甘特图的概念和用途概念：甘特图，又称横道图，是以图示的方式通过活动列表和时间刻度形象地表示出任何特定项目的活动顺序和持续时间。甘特图的横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上该活动或项目的持续时间，因此可以用来比较与日期相关的不同活动（项目）的持续时间长短。甘特图也常用于显示不同任务之间的依赖关系，并被普遍用于项目管理中。 用途：已图视的方式来表达，通过活动列表和时间刻度，能够形象的表达出特定的项目的顺序和持续时间，普遍用在项目管理页面 交货延期情况的甘特图 蓝色的天：代表的是维度，或可以理解为一个分类符。 绿色的天：代表的是真正的时间，可以进行计算 举例说明 年龄是一个真的的数字，可以进行计算，而身份证号无法进行计算。 填充地图概念：实现国家、省&#x2F;自治区、地市级等不同详细级别数据的地理位置展示 范围-线图概念与用途范围-线图是将整体数据的部分统计特征（均值，最大值，最小值等）展示在图形中，既可以说明群体特征，还可以展示个体信息 更可以比较个体与整体的相对关系。 创建范围-线图FIXED 指定维度进行聚合计算 AVG 求平均 MAX 最大值 MIN 最小值 SUM 最大值 每天人工接听量的平均值 &#123; FIXED [日期] :AVG([人工服务接听量])&#125; 每天人工接听量的最大值 &#123; FIXED [日期] :MAX([人工服务接听量])&#125; 每天人工接听量的最小值 &#123; FIXED [日期] :MIN([人工服务接听量])&#125; 网络图简单的网络图 线路方式创建网络图 仪表板高级应用概念仪表板是若干视图的集合，让我们能同时比较各种数据。例如，我们有一组每天都要审阅的数据像收入的数据、业绩目标达成的数据、 用户数据等，就可以创建一个一次性显示所有视图的仪表板(下图)，将这些数据整合到一张仪表板上，而不是导航到单独的工作表。 仪表板功能简介 仪表板布局 布局1 布局2 故事概念：故事是一系列共同作用以传达信息的虚拟化项。可以创建故事以讲述数据，提供上下文，演示决策与结果的关系，或者只是创建一个极具吸引力的案例。同时，故事还是按顺序排列的工作表集合。故事中各个单独的工作表称为“故事点”。 超市经营情况大屏制作 数据处理创建分类文件夹–日期–地区–产品–客户–其他 创建KPI参数 创建计算字段指标SalesSUM([销售额]) 利润率Profit %SUM([利润])/SUM([销售额]) 订单数OrderCOUNT([订单 ID]) 折扣率Discount%SUM([销售额])/SUM([销售额]/(1-[折扣])) 利润ProfitSUM([利润]) KPI 注意 WHEN ‘指标Sales’ 里面的值一定不能拖入 1234567CASE [Option KPI]WHEN &#x27;指标Sales&#x27; THEN [指标Sales]WHEN &#x27;利润Profit&#x27;THEN [利润Profit]WHEN &#x27;利润率Profit %&#x27;THEN [利润率Profit %]WHEN &#x27;订单数Order&#x27;THEN [订单数Order]WHEN &#x27;折扣率Discount%&#x27;THEN [折扣率Discount%]END KPI MAX KPI MIN 图表制作创建KPI指标卡 创建地图 创建细分饼图 创建月份趋势图 创建子类别条形图 仪表板制作 仪表板交互","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"可视化","slug":"可视化","permalink":"https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"Tableau","slug":"Tableau","permalink":"https://www.yiuhangblog.com/tags/Tableau/"}],"author":"Yiuhang Chan"},{"title":"Power Query和可视化图表(Power BI)","slug":"20200921可视化图表(Power BI)","date":"2020-09-21T10:36:45.000Z","updated":"2024-02-28T10:50:08.000Z","comments":true,"path":"2020/09/21/20200921可视化图表(Power BI)/","permalink":"https://www.yiuhangblog.com/2020/09/21/20200921%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8(Power%20BI)/","excerpt":"Power Query的认识操作，可视化图表创建","text":"Power Query的认识操作如何进入Power Query在 Excel 中，进入 Power Query 的方式是选择 “数据” 选项卡下的 “从数据源获取” 或 “查询编辑器”。在 Power BI 中，进入 Power Query 的方式是通过点击 “首页” 选项卡下的 “转换数据”。 添加自定义列在 Power Query 中，可以通过 “添加列” 选项卡下的 “自定义列” 功能来创建新列。在这里，可以使用 M 语言编写公式，基于现有数据创建新的数据列。 添加条件列条件列允许基于现有列中的值来创建新列。例如，根据销售量对数据进行分类。这可以通过 “添加列” 选项卡下的 “条件列” 完成。 索引列，重复列，拆分，提取 索引列：可以添加一个序号列，对每行数据进行编号。 重复列：允许创建现有列的副本。 拆分：可以根据某些条件（如分隔符）将文本列拆分成多个列。 提取：允许从文本列中提取特定的字符。 标题，删除，替换，筛选 标题：调整列标题，使其更具描述性。 删除：删除不需要的列或行。 替换：在列中替换文本或数值。 筛选：根据条件筛选数据。 合并查询原理 合并查询：两个或多个查询的数据组合在一起。合并可以通过不同的方式完成，如下所示： 左外合并：包括左表的所有行和右表中匹配的行。 右外合并：包括右表的所有行和左表中匹配的行。 外部合并：包括两个表中的所有行。 内部合并：只包括两个表中匹配的行。 左反合并：只包括左表中独有的行。 右反合并：只包括右表中独有的行。 举例：导入多表Excel 左外合并 透视与透视列 透视：将多行数据转换为列，通常用于整理和分析数据。 透视列：将列数据转换为行格式，与透视相反。 分组依据 在 Power Query 中，可以根据一个或多个列的值对数据进行分组。这对于汇总信息非常有用。 可视化图表常用图表堆积图条形图与柱状图应用场景：最适宜比较不同类别的大小。 工作中为了反映数据细分和总体情况，我们常常会使用到堆积条形图，这种图形让我们既能看到整体推移情况，又能看到某个分组单元的总体情况，还能看到组内组成部分的细分情况，一举多得 组成要素： 组数：把数据分成几组，指导性的经验是将数据分成5到10组。 组宽度：通常来说，每组的宽度是一致的。组数和组宽度的选择就不是独立决定的，一个经验标准是：近似组宽度&#x3D;（最大值-最小值）&#x2F;组数，然后根据四舍五入确定初步的近似组宽度，之后根据数据的状况进行调整。 组限：分为组下限（进入该组的最小可能数据）和组上限（进入该组的最大可能数据），并且一个数据只能在一个组限内。绘画条形图时，不同组之间是有空隙的；而绘画直方图时，不同组之间是没有空隙的。 注意：1. 确定谁是图例，2. 数据颜色和数据标，3. 标题，背景，4. 边框和阴影，5. x轴与y轴的起始刻度 折线图应用场景：最适用于时间序列的数据。 概念：什么是折线图呢？折线图是排列在工作表的列或行中的数据可以绘制到折线图中。折线图可以显示随时间(根据常用比例设置)而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。当有多个系列时，尤其适合使用折线图。如果有几个均匀分布的数值标签(尤其是年)，也应该使用折线图。在折线图中，类别数据沿水平轴均匀分布，所有值数据沿垂直轴均匀分布。 注意：1. 确定谁是图例，2. 数据颜色和数据标签，3. 形状，4. 标题，背景，5. 边框和阴影，6. x轴与y轴的起始刻度 分区图与堆积面积图概念：什么是分区图呢？分区图又称面积图，它着重强调数量随时间而变化的程度，也可用于引起人们对总值趋势的注意并清晰展现数据的增减趋势、增减的速度、增减的规律、峰值等特征等。此外，堆积面积图还可以显示部分与整体的关系。面积图包含图表区、标题、绘图区、图例、坐标轴、坐标轴标题、网格线、数据标签、数据系列（区域）等元素，广泛运用于各行各业，比如销售金额增幅，客流量统计等。 堆积面积图：层叠面积图上最大的面积代表了所有数据量的总和，是一个整体 瀑布图应用场景：一般用于计算公司销售毛利情况，出现有正数和负数的情况。 概念：瀑布图是数据可视化分析中常见的一种图形，采用绝对值与相对值结合的方式，适用于表达数个特定数值之间的数量变化关系。对于一系列具有累计性质的正值&#x2F;负值具有很好的展示功能，既可以辅助理解数据的大小，又能直观地展示出数据的增减变化，反映数据在不同时期或受不同因素的影响结果 注意：情绪颜色和细目 建议配合切片器使用，便于查看细分的日期 散点图概念：散点图始终有两个数值轴可以显示：一组沿水平轴的数值数据，另一组沿垂直轴的数值数据。 图表在 x 和 y 数值的交叉处显示点，将这些值单独合并到各个数据点。 Power BI 可以跨水平轴均匀或不均匀地分布这些数据 点。 具体视散点图表示的数据而定。 饼图与环形图应用场景：最适合用来展示一个数据系列中各项值的大小与总和的比例 概念：用圆形及圆内扇形的角度来表示数值大小的图形。 建议配合切片器使用，便于查看各个店铺的详细情况 树状图应用创景：适用于展示数据之间的层级和占比关系。(钻取和上卷) 概念：树状图将分层数据显示为一组嵌套矩形。 层次结构中的每个级别都由一个有色矩形（分支）表示，其中包含更小的矩形（叶）。 Power BI 根据度量值来确定每个矩形内的空间大小。 矩形按大小从左上方（最大）到右下方（最小）排列。 漏斗图应用场景：一般作用与进度推进场景 概念：直观的展示业务流程，可以快速发现流程中存在的问题，在电商，营销，客户关系管理等领域广泛应用 信息 漏斗分析法 漏斗分析法是一种常用于数字营销和用户体验分析的方法。它通过将用户的整个转化过程视为一个漏斗，帮助定位在用户从潜在客户转化为最终客户的过程中的问题节点。这种方法特别适用于网站、应用程序和电子商务平台。 漏斗法的关键概念 向前找流量：这意味着要关注吸引用户的渠道和方法，理解何种营销策略、内容或广告在吸引潜在客户方面最为有效。 向后看转化：这涉及到分析用户在漏斗的每个阶段的转化情况，比如从意识到兴趣，再到决策和行动，以便理解在哪个阶段用户最有可能流失。 自身看画像：这是指理解你的目标用户群体的特征，包括他们的行为、偏好和需求。 漏斗分析法的应用 定位问题节点：通过分析用户在漏斗的各个阶段的留存和流失，可以识别出用户体验中的问题点。例如，如果在结账过程中有大量用户流失，这可能表明结账过程存在问题。 用户转化分析：漏斗分析帮助你理解用户从了解产品到最终购买的整个过程，哪些环节最有效，哪些环节需要改进。 用户流失分析：通过分析在转化过程中流失的用户，可以了解导致用户流失的原因，并采取措施减少流失。 关键交易路径分析：在电子商务等场景中，了解用户从浏览商品到完成购买的路径，并分析在这个过程中的每个环节的表现。 数据对比分析：通过比较不同时间段或不同用户群体的漏斗数据，可以发现问题和机会点。 针对性改进策略：基于漏斗分析的结果，可以采取具体的优化措施，比如改进网站设计、优化结账流程、调整营销策略等。 按照已知的转化路径，借助漏斗模型分析总体和每一步的转化情况。例如将漏斗图用于网站关键路径的转化率分析，不仅能显示用户的最终转化率，同时还可以展示每一节点的转化率。 仪表盘应用场景：适用于销售指标完成情况。 建议配合切片器使用，便于查看各个店铺的详细情况 卡片图应用场景：适用于总销售额汇总展示 建议配合切片器使用 高级图表KPI高级的卡片图 分解数概念：可以理解为一个小型的数据分析模型，逐级进行分析展示 信息 逻辑拆解法 逻辑拆解法是一种解决问题的强大工具，它通过将复杂问题分解成若干个更小、更易管理的子问题来工作。这种方法源于费米问题，这类问题以物理学家恩里科·费米命名，他以通过估算来解决复杂问题而闻名。通过将大问题分解成一系列小问题，我们可以更容易地估计或解决这些小问题，从而逐步构建出大问题的答案。 费米问题是指通过估算来近似解决复杂问题的一种方法。这种问题通常是开放式的，并且不可能直接得到精确答案。费米问题的解决通常需要借助于逻辑推理、已知数据、经验法则和合理假设。费米问题的解决过程涉及到对问题的分解，评估各部分的概率或数量，然后将这些部分合成以得出整体问题的大致答案。 费米问题的解决原则： 提出问题： 定义一个清晰且具体的问题。 分解问题： 将问题分解为更小、更具体的子问题。 估算参数： 对每个子问题进行数量估算，如果可能的话，使用已知的数据或常识。 合理假设： 在缺少确切信息的情况下，做出合理的假设来填补空白。 计算答案： 组合所有子问题的估算值来得出整个问题的近似答案。 复核与调整： 检查结果的合理性，并在必要时调整假设和估算。 逻辑树的构建 逻辑树（也称为问题树、分解树等）是逻辑拆解法的核心工具。它以树状结构展示问题的分解过程，每个节点代表问题的一个子部分。逻辑树从一个单一的、定义明确的问题开始，这个问题位于树的根部。然后，这个问题被分解成若干个子问题，这些子问题构成树的第一层分支。每个子问题又可以进一步分解成更小的问题，形成下一层分支，依此类推，直至所有的问题都被分解成足够简单，可以直接解决的问题。 逻辑树的原则 逻辑树是一种帮助系统化分解问题的工具。以下是构建逻辑树的原则： 层次结构： 逻辑树应该有明确的层次结构，从根问题开始，逐步向下分解。 互斥性： 每一层的子问题应该是互斥的，即它们不应该重叠，每个子问题应该覆盖根问题的不同部分。 完整性： 所有子问题的集合应该能够完整地覆盖上一层问题的内容。 逻辑性： 每次分解都应基于逻辑关系，如因果关系、分类、过程步骤等。 可操作性： 分解的最终子问题应足够具体，以便可以采取行动或进行量化分析。 逻辑拆解法的步骤 定义问题： 首先明确你要解决的问题。这个问题应该尽可能具体和清晰。 构建逻辑树： 从问题出发，思考哪些主要因素或子问题构成了这个问题。这一步是创建逻辑树的开始，每个因素或子问题都是树的一个分支。 进一步分解子问题： 对每个子问题继续进行分解，直到这些问题足够简单，可以直接解答或通过已知信息解决。 分析和解决子问题： 对每个最终的子问题进行分析和解决。这可能涉及到数学计算、逻辑推理、数据分析或其他专业知识。 整合结果： 最后，将所有子问题的解决方案整合起来，形成对原始问题的完整答案。 地图地图默认是不勾选的—点击文件–选项和设置–选项–勾选上地图和着色地图视觉对象 关键影响着概念：类似于一个小型的AI,可以进行简单的自动分析。 功能区图表应用场景：根据不同时间段显示排名 概念： 可创建功能区图表来直观显示数据，并快速发现哪个数据类别具有最高排名（最大值）。 功能区图表能够高效地显示排名变化，并且会在每个时间段内始终将最高排名（值）显示在最顶部。 案例制作出中国主要交通城市健康排行榜 数据获取单页数据获取数据获取拓展 获取贝壳网数据 https://sz.zu.ke.com/zufang 这样就完成了单页数据的获取 批量获取多页数据定义数字变量P &#96;(p as number) as table &#x3D;&gt;&#96;&#96; &#96;&#96;Number.ToText(p)&#96;: 将定义的变量P转为文本与前面的url地址进行拼接，最终生成我们要采集数据的URL 输入框里输入1点击调用，就是采集第一页的数据，输入2就是采集第二页的数据以此类推 新建源，生成一个空查询 输入框里输入=&#123;1..10&#125; 这样我们在调用这个查询的时候就会采集1-10页的数据 点击上面的转换，转换到表 这样我们就建立好了一个查询，待会p的参数就会从我们创建好的Column1这个函数里去调用 添加列–调用自定义函数–功能查询&#x2F;选择贝壳P&#x2F;选择我们刚刚生成的Column1 如此一来 我们就实现了1-10页的批量爬取，当然如果要爬取更多页的数据调整1-10的参数即可。 注意 Powerbi 不是专业的爬取工具，但遇到反扒机制比较强的网站，或网页结构比较复杂的，那Power bi就不适用。我们就需要使用更专业的爬取工具去采集数据，如Python，八爪鱼，火车头等采集工具。在采集数据之前最好想采集一页测试一下，如果可以在进行批量采集。如果采集不到，就只能换其他采集工具去采集数据。 导入高德地图数据导入数据源：中国主要城市交通数据 数据清洗修正表格标题和进行值的拆分 数据建模度量值与计算列给交通健康排名表里每个城市打上健康或亚健康标签 度量值健康城市数量 =CALCULATE(MAX(&#39;城市类型统计&#39;[城市数量]),&#39;城市类型统计&#39;[健康状态]=&quot;健康&quot;)，在城市类型统计表里面健康类型这个字段等于健康的，统计满足条件的城市数量最大值。 CALCULATE 函数：这是一个强大的函数，通常用于更改数据上下文并执行基于条件的计算。它可以应用过滤器来修改或创建新的数据上下文，并在这个上下文中计算表达式。 MAX(&#39;城市类型统计&#39;[城市数量])：这个表达式是CALCULATE函数中的第一个参数，用于找出“城市类型统计”表中“城市数量”列的最大值。 &#39;城市类型统计&#39;[健康状态]=&quot;健康&quot;：这是CALCULATE函数中的第二个参数，表示一个过滤器。它的作用是从“城市类型统计”表中筛选出那些“健康状态”列值为“健康”的记录。 结合这些组件，整个公式的逻辑是： 首先筛选出“健康状态”为“健康”的城市。 然后在这个已经过滤的数据集中找出“城市数量”列的最大值。 所以，这个公式计算的是在所有被标记为“健康”的城市中，数量最多的城市有多少个。换句话说，这是在寻找在健康状态下具有最多城市数的记录。 新建列健康类型 = IF(&#39;交通健康排名&#39;[排名]&lt;=&#39;城市类型统计&#39;[健康城市数量],&quot;健康&quot;,&quot;亚健康&quot;) 判断健康排名小于等于健康城市数量，健康城市引用我们刚刚建设的度量值，满足就是健康，否则就是亚健康。 IF 函数：这是一个条件函数，通常用于根据给定的条件判断返回不同的结果。它有三个参数：一个逻辑测试（条件），如果条件为真时的结果，以及如果条件为假时的结果。 &#39;交通健康排名&#39;[排名]：这是在某个表中引用的“排名”列，这里假设它是一个数值列，表示城市在交通健康方面的排名。 &#39;城市类型统计&#39;[健康城市数量]：这是在另一个表中引用的“健康城市数量”列，假设这个列保存了某种计算或确定的健康城市的数量。 &lt;=：这是一个比较运算符，表示“小于或等于”。 整个公式的逻辑是： 检查一个城市在“交通健康排名”中的排名是否小于或等于“城市类型统计”中定义的“健康城市数量”。 如果条件为真（即，如果城市的排名在健康城市数量范围内），则该城市被分类为“健康”。 如果条件为假（即，如果城市的排名超出了健康城市数量范围），则该城市被分类为“亚健康”。 结果是一个新的列或标签，表示每个城市基于其交通健康排名的健康状态。 构建数据关联关系健康类型2 = IF(&#39;交通健康排名&#39;[排名]&lt;=56,&quot;健康&quot;,&quot;亚健康&quot;)（硬编码56） IF函数： 这是一个基本的逻辑函数，它根据一个条件测试返回两个可能的结果之一。IF函数的结构是 IF(条件, 真时返回值, 假时返回值)。 条件测试： &#39;交通健康排名&#39;[排名]&lt;=56。这里检查的是某个城市的排名是否小于或等于56。 真时返回值： 如果上述条件成立（即排名是56或更好），则函数返回字符串”健康”。 假时返回值： 如果条件不成立（即排名超过56），则函数返回字符串”亚健康”。 这意味着，根据这个公式，所有排名在56或56之内的城市被认为是“健康”的，而所有排名超过56的城市则被认为是“亚健康”的。 可视化大屏制作城市健康状态占比：环形图 交通健康&#x2F;亚健康城市top3：卡片图 六宫格指标项表 地图 交通健康排名表 健康&#x2F;亚健康卡片图 时间 中国交通主要城市健康榜标题","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"可视化","slug":"可视化","permalink":"https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"Power BI","slug":"Power-BI","permalink":"https://www.yiuhangblog.com/tags/Power-BI/"},{"name":"Power Query","slug":"Power-Query","permalink":"https://www.yiuhangblog.com/tags/Power-Query/"}],"author":"Yiuhang Chan"},{"title":"商务智能基础(Power BI)","slug":"20200915PowerBI基础","date":"2020-09-15T12:21:39.000Z","updated":"2024-02-28T10:50:05.000Z","comments":true,"path":"2020/09/15/20200915PowerBI基础/","permalink":"https://www.yiuhangblog.com/2020/09/15/20200915PowerBI%E5%9F%BA%E7%A1%80/","excerpt":"商务智能基础介绍，PowerBI基础界面与操作介绍","text":"商务智能BI也叫商务智能，是一种主要由数据仓库、数据分析、查询报表、数据可视化等组成的数据类技术解决方案 商务智能BI可以实现业务流程和业务数据的规范化、流程化、标准化，打通ERP、OA、CRM等不同业务信息系统，整合纳企业数据，利用数据可视化满足企业不同人群对数据查询、分析和探索的需求，从而为管理和业务提供数据依据和决策支持。 将商业智能BI核心内容进行总结，大致有三大特征: 一套完整的由数据仓库、查询报表、数据分析等组成的数据类技术解决方案 将企业中不同系统(ERP、OA)中的数据打通并进行有效的整合: 利用合适的查询和分析工具快速准确地提供报表，为企业提供决策支持。 BI的由来BI是信息化，数字化的增长，以及社会和商业对数据的依赖 BI的定义一类由数据仓库（或数据集市）、查询报表、数据分析、数据挖掘、数据备份和恢复等部分组成的、以帮助企业决策为目的的技术及其应用。 Power BI 概念Power BI是微软官方推出的可视化数据探索和交互式报告工具。 PowerBI是一款强大的可视化软件，它可以轻松的连接到数百个数据源，简化数据并可视化重要数据信息，生成美观的报表并进行发布，供组织在 Web和移动设备上使用。每个人都可创建个性化仪表板，获取针对其业务的全方位独特见解。简单来说就是可以从各种数据源中提取数据并对数据进行整理分析，然后生成精美的图表并且可以在电脑端和移动端与他人共享的一个神器。 Power BI 组成 Power BI 包括多个协同工作的元素，从以下三个基本元素开始： Power BI Desktop （报表端） Wdinows 桌面应用程序 进行数据处理大屏可视化制作。 Power BI 服务（服务端）是一个包含软件服务、应用和连接器的集合。 Power BI 服务有时被称为 Power BI Online ，它是 Power BI 的服务型软件 (SaaS) 的部分，类似于一个网页，有了账号我们在Power BI Desktop 上做的就可以发布到我们的网页上去，相当于分了一块内存，你就可以在我的上面做一些发布，存储。然后就可以发布到浏览器上进行协同和交互。 Power BI 移动端 适用于Windows，ios和Android设备的 可视化效果（或视觉对象）是数据的可视化表示形式，如图表、颜色编码图，或其他可以创建并用来直观呈现数据的有趣形式。 Power BI 提供各种类型的可视化效果，而且随时会新增一些可视化效果。下图显示了在 Power BI 中创建的不同可视化效果的集合 Power BI 流程连接到数据要开始使用 Power BI Desktop，第一步为连接到数据。 可从 Power BI Desktop 连接到多个不同数据源。连接到数据：在“开始”功能区，选择“获取数据”&gt;“更多” 。此时将显示“获取数据”窗口，其中显示了 Power BI Desktop 可连接到的多个类别。 转换和清理数据、创建模型在 Power BI Desktop 中，可以使用内置 power query编辑器 清理并转换数据。 使用 Power Query 编辑器可以对数据进行更改，如更改数据类型、删除列或合并来自多个源的数据 创建视觉对象拥有数据模型后，即可将字段拖动到报表画布上以创建视觉对象 。 视觉对象是模型中的数据的图形表示形式。 可以在 Power BI Desktop 中选择多个不同类型的视觉对象 创建报表即创建视觉对象集合，这些视觉对象可显示已用于在 Power BI Desktop 中创建模型的数据的各个方面。 一个 Power BI Desktop 文件中的视觉对象集合称为“报表”。 报表可以有一个或多个页面组成。 Power BI 界面认识界面认识模块主页：主要是获取数据 报表：创建报表和视觉对象，大部分创建时间都花费在这里。 数据：查看与报表关联的数据模型中使用的表、度量值和其他数据，并转换数据以便在报表的模型中充分利用。 模型：查看和管理数据模型中各表之间的关系。 插入：主要是用于布局 建模：新建度量值，新建列，新建表是最常用的视 视图：图面美化 优化：字面理解 帮助：字面理解 数据查看报表视图：可进行图表制作 表格视图：可以进行数据处理，表和表字段查看，新建列，新建度量值等操作。 模型视图：可以进行表之间的关联关系查看与连接。 数据来源 从Execl导入 本地Execl数据导入 获取数据 支持多源化数据导入，本地，web，sql等上百个数据源接入 矩阵表操作 数据导入 点击加载：进入到数据可视化页面 点击转换数据：进入到数据清洗页面（Power Query） 点击矩阵表添加 设置视觉对象格式数据源：00 值：调节字体大小 列标题：默认会把列加大 行标题：默认会把行加大 搜索框：输入 + 显示开启或关闭+ 搜索框：输入大小，调节正规边框的大小， 高最大为 720，宽最大为1260， 调节的是矩阵图的大小，内容不会随这图的大小而变化。 列小计： 每一列小计，默认是打开的 行小计：每一行小计，默认是打开的 列总计：与列小计一体的，列小计关闭默认也会关闭 行总计：与行小计一体的，行小计关闭默认也会关闭 隐藏行：筛选器里面进行筛选 隐藏列：筛选器里面进行筛选 数据条：美化 设置筛选点击筛选器，点开需要筛选的视觉对象，即可筛选 运算符与新建列认识运算符 新建列数据源：01.02.04 新增列：英文的 ‘ 号 或 [ 都可以新增列进行计算 效果是相同的 新列 = &#39;销售表&#39;[销售数量]*10 新列2 = [销售数量]*10 实际操作 场景思考什么时候用 ‘ 带表名 什么时候用[ 不带表名 一张表操作时可以不用带表名，多张表操作时要带上表名 举例说明新建列的时候，当另一个需要计算的列来自其他表的时候，一定要指明表明是什么 计算销售成本两个表之间的操作，先进行表与表之间的关联，在模型视图进行，拖动品名到销售表即可 关系函数 Related：从其他的表（关联表）中返回值 销售成本 = &#39;销售表&#39;[销售数量]*RELATED(&#39;商品表&#39;[进价]) 建模与关系函数 一对多关系 传递方向 向下筛选 向上索取 多端可以向一端索取，一端可以控制传递方向相同的多端数据 Lookupvalue函数：语法：Lookupvalue（把那张表的那个列拿过来，找那张表上的谁？，找自己表里的谁？）把别人表里的字段V到自己表里 单价 = LOOKUPVALUE(&#39;商品表&#39;[进价],&#39;商品表&#39;[品名],&#39;销售表&#39;[商品名称]) 度量值表工具里新建度量值 度量值在创建好之后可以在任意的环境中去使用。去执行不同的计算，也可以拖入图表。 新建度量值（计算一列的值）销售总量 = SUM(&#39;销售表&#39;[销售数量]) 在报表视图使用任意图表如（卡片图）进行展示 聚合函数数据源：超市销售明细表 求和：SUM(‘表’[字段])销售额求和 = SUM(&#39;超市销售明细表&#39;[销售额]) 求平均：AVERAGE(‘表’[字段])成本额平均值 = AVERAGE(&#39;超市销售明细表&#39;[成本额]) 最大值：MAX(‘表’[字段])销售额最大值 = MAX(&#39;超市销售明细表&#39;[销售额]) 最小值：MIN(‘表’[字段])销售额最小值 = MIN(&#39;超市销售明细表&#39;[销售额]) 记录数：Count（’表’）记录数 = COUNTROWS(&#39;超市销售明细表&#39;) 去重计数：DISTINCTCOUNT(‘表’[字段])去重计数 = DISTINCTCOUNT(&#39;超市销售明细表&#39;[省份]) 条件判断函数数据源：12 销售成本 = &#39;例1&#39;[销售数量]*&#39;例1&#39;[单价] text类型不能进行数值计算 会全部报错。 IFERROR 遇到错误时使用指定数值替换销售金额 = IFERROR(&#39;例1&#39;[销售数量] *&#39;例1&#39;[单价],BLANK()) BLANK()返回空 也可以返回数字，但无法返回字符串 销售金额 = IFERROR(&#39;例1&#39;[销售数量] *&#39;例1&#39;[单价],123) 这样返回的就是123， 只能返回数值 if条件判断简单的条件判断 称呼 = IF(&#39;Sheet1&#39;[性别] =&quot;男&quot;,&quot;先生&quot;,&quot;女生&quot;) 称呼 = IF(&#39;例2&#39;[性别]=&quot;男&quot;,&quot;先生&quot;)女士不写，返回也可以是空值，也可以输入数字。 复杂一点的if条件判断 间隔 = IF([取款日期]=BLANK(),BLANK(),[取款日期]-[存款日期]) 如果 值 等于 什么 那么我们就返回 什么 返回。。。 switch多项条件判断适用于多条件判断 12345678SWITCH( [Expression], [Value1], [Result1], [Value2], [Result2], ... [ValueN], [ResultN], [DefaultResult]) Expression: 这是你将评估的表达式。通常情况下，这是一个列名称或者一个能够计算得到单一值的表达式。 Value1, Value2, …, ValueN: 这些是你将会检查的值。这些值将会与 [Expression] 比较。 Result1, Result2, …, ResultN: 对应于每个 Value，当 [Expression] 与 Value 匹配时返回的结果。 DefaultResult（可选）: 如果没有任何 Value 与 [Expression] 匹配，将返回此结果。如果省略此参数，且没有匹配项，SWITCH 将返回空值。 月份 = SWITCH(&#39;例3&#39;[月],1,&quot;一月&quot;,2,&quot;二月&quot;,3,&quot;三月&quot;,4,&quot;四月&quot;,5,&quot;五月&quot;,6,&quot;六月&quot;,7,&quot;七月&quot;,8,&quot;八月&quot;,9,&quot;九月&quot;,10,&quot;十月&quot;,11,&quot;十一月&quot;,12,&quot;十二月&quot;,&quot;无法识别&quot;) switch特殊用法在 Power BI 的 SWITCH 函数中，使用 TRUE() 作为表达式可以让你基于一系列的条件判断来返回不同的结果。这种方法在需要基于多个不同列或更复杂的逻辑条件进行判断时非常有用。 12345678SWITCH( TRUE(), [Condition1], [Result1], [Condition2], [Result2], ... [ConditionN], [ResultN], [DefaultResult]) 这里的每个 [ConditionN] 是一个返回布尔值（真或假）的表达式。如果该表达式的结果为真（TRUE），则 SWITCH 函数将返回对应的 [ResultN]。 年龄段 = SWITCH(TRUE(),&#39;例4&#39;[年龄]&lt;30,&quot;30岁以下&quot;,&#39;例4&#39;[年龄]&lt;40,&quot;30-40岁&quot;,&#39;例4&#39;[年龄]&lt;50,&quot;40-50岁&quot;,&quot;50岁以上&quot;)","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"可视化","slug":"可视化","permalink":"https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"函数","slug":"函数","permalink":"https://www.yiuhangblog.com/tags/%E5%87%BD%E6%95%B0/"},{"name":"Power BI","slug":"Power-BI","permalink":"https://www.yiuhangblog.com/tags/Power-BI/"}],"author":"Yiuhang Chan"},{"title":"用户画像","slug":"20200829用户画像","date":"2020-08-29T08:15:36.000Z","updated":"2024-02-29T13:10:56.000Z","comments":true,"path":"2020/08/29/20200829用户画像/","permalink":"https://www.yiuhangblog.com/2020/08/29/20200829%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/","excerpt":"用户画像的概念，分析和流程","text":"什么是用户画像用户画像是一种在数据分析和市场营销中常用的工具，它通过收集和分析用户数据来创建一个或一组虚拟的典型用户代表。这些数据通常包括但不限于用户的基本信息（如年龄、性别、地域），以及更具体的行为特征（如购买习惯、兴趣爱好、互联网使用习惯等）。用户画像的建立，旨在帮助企业更好地理解其目标客户群，以便为他们提供更加个性化、精准的服务或产品。 用户画像的核心在于给用户打上易于理解和分析的标签，这些标签既包括基础的人口统计信息，也包括用户的行为特征和偏好。这种通过标签化来描述用户的方法，可以帮助企业从大量的用户数据中，快速抽象和识别出关键的用户特征和需求。 例如，如果一个用户经常在某直播平台购买彩妆产品，该平台可能会根据用户的购买记录给其打上“女性”、“价格敏感”和“忠实用户”等标签。通过分析这些标签，平台能够推断出用户的一系列特征，如消费能力和可能的年龄范围。这些信息进一步帮助平台为用户提供更为精准的商品推荐，提高营销效率和用户满意度。 用户画像的应用非常广泛，从提高广告和营销活动的效果，到优化产品设计和服务，再到增强用户体验和满意度，都有其重要作用。通过精确的用户画像，企业能够更有效地定位目标市场，实现精准营销，从而在竞争激烈的市场环境中脱颖而出。 用户画像的作用用户画像的作用在于将分散的、非结构化的用户行为数据转化为有结构的、标签化的信息集合，从而使得这些数据能够被直接用于多种数据分析和用户模型构建的场景。用户画像通过对用户行为的细致标签化，提供了一种直观且有效的方法来理解和预测用户的需求和行为。以下是用户画像的主要作用和应用场景的详细解析： 精准营销：用户画像使得企业能够将广泛的用户群体细分成具有特定需求和特征的小群体或个体，从而实现更加个性化的营销策略。通过了解用户的具体偏好和需求，企业可以通过短信、电子邮件、社交媒体等渠道进行更为精准的营销活动，大大提高营销效率和效果。 数据分析：用户画像为数据分析提供了丰富的基础数据。通过分析不同用户画像群体的属性和行为特征，企业可以洞察到各个用户群体的分布特征、偏好差异和潜在需求，为产品开发、市场策略调整提供数据支持。 产品应用：用户标签构成了许多数据产品的基础，尤其是个性化推荐系统和客户关系管理（CRM）的搭建。通过对用户的精确标签化，产品可以提供更为个性化的内容、服务或产品推荐，增强用户体验和满意度。 数据挖掘：用户画像是构建推荐系统、搜索引擎、广告投放系统等复杂数据挖掘应用的基础。它们依赖于精细的用户画像来提高服务的精准度和个性化水平，包括但不限于提升广告的投放效果、优化内容推荐的相关性、调整产品的市场定位等。 综上所述，用户画像的建立和应用对于现代企业尤其是互联网公司来说，是实现用户理解、产品优化、市场营销精准化的关键工具。通过有效的用户画像管理，企业不仅能够提高其产品和服务的市场竞争力，还能够更好地满足用户的个性化需求，从而在激烈的市场竞争中占据有利地位。 用户画像搭建需要具备的条件构建用户画像是一个涉及多维度信息收集和分析的复杂过程，旨在通过标签化用户信息来抽象出用户的全貌。这个过程不仅有助于企业更深入地了解其用户群体，还能够为提供更加个性化的服务和产品决策提供支持。下面详细解释用户画像构建过程中涉及的各个维度： 基本属性： 基本属性包括用户的社会属性和一些变动频率较低的平台特征，如年龄、性别、教育背景、地理位置等。 这些信息通常通过用户注册、填写资料等直接方式获取，无需复杂的统计或算法挖掘。 平台属性： 平台属性反映用户在特定平台上的行为特征，例如用户的活跃度、偏好的内容类型、使用频率等。 这类属性通过分析用户的在线行为和交互模式，利用算法进行挖掘和标识。 行为属性： 行为属性记录了用户在平台上的具体操作，包括浏览、点击、购买等单点行为。 通过这些行为数据，可以进一步分析用户的兴趣点、购买习惯和活跃时间段等。 产品偏好： 产品偏好描述了用户对某些产品或服务的喜好程度，这不仅包括自家的产品，也可能涵盖竞争对手的产品。 这类偏好可以通过用户的购买历史、浏览记录和反馈来进行挖掘和分析。 兴趣偏好： 兴趣偏好是通过深入分析用户与产品或内容之间的交互来描绘的，它涵盖了品牌偏好、类目偏好和具体的标签偏好等。 了解用户的兴趣偏好对于个性化推荐和精准营销至关重要。 敏感度： 敏感度指的是用户对于平台活动或优惠的反应程度，如对热点事件、折扣和促销活动的敏感度。 识别用户的敏感度有助于调整营销策略和提升用户参与度。 通过将这些维度的信息进行有效统计和分析，企业能够构建出全面而深入的用户画像。这不仅有助于精准定位目标用户群，还能够基于用户的具体需求和偏好来优化产品设计、调整营销策略、提高用户满意度和忠诚度。用户画像的建立和应用，是现代企业深化用户理解、提升业务效能的重要手段。 如何构建用户画像从实际操作角度出发，构建用户画像主要包括数据源分析、目标分析、数据建模等步骤。 数据源分析数据是构建用户画像的核心，它不仅支撑着用户画像的建立和优化，还确保了画像的客观性和说服力。用户画像的数据来源可以从宏观和微观两个层面来理解，每个层面提供了不同视角的数据支持，共同构成了用户画像的全貌。 宏观维度宏观维度的数据主要来源于更广泛的行业和市场层面，涉及的范围比较广，可以为用户画像提供一个宽阔的背景和基础。具体包括： 行业数据：涉及整个行业的趋势、发展方向、用户需求变化等信息，有助于了解用户画像在更大范围内的位置和变化。 用户总体数据：包含用户群体的整体特征、偏好和行为模式，如人口统计学特征、整体购买力、品牌偏好等。 总体浏览数据：反映用户群体在整个平台或行业内的浏览行为和内容偏好，提供用户兴趣点和关注领域的宏观视图。 总体内容数据：包括用户群体消费内容的种类、频率和偏好等，有助于理解哪些内容类型最能吸引目标用户群体。 微观维度微观维度的数据更加聚焦于个体用户，提供细致的用户行为和特征分析，是构建精准用户画像不可或缺的部分。具体包括： 用户属性数据：个体用户的基础信息，如年龄、性别、职业、地理位置等。 用户行为数据：记录了用户的具体操作和行为，如点击、浏览、购买、反馈等。 用户成长数据：跟踪用户在平台上的成长轨迹，包括用户等级、活跃度的变化、成长速度等。 访问深度：衡量用户对平台内容的深度探索，如页面访问深度、停留时间等。 模块化数据：分析用户对不同平台模块的使用偏好和频率。 用户参与度数据：用户对平台活动、内容互动的参与程度，如评论、分享、点赞等。 用户点击数据：用户在平台上点击行为的记录，可用于分析用户的即时兴趣和偏好。 结合宏观和微观两个层面的数据，可以全面地构建出用户画像，不仅能够反映用户的基本属性和行为特征，还能够洞察用户的潜在需求和偏好变化。这种基于数据的用户画像建立方法，为企业提供了精准营销、产品优化和服务改进的重要依据，是现代企业深入理解用户、提升竞争力的关键工具。 目标分析用户画像构建的目的在于深入理解用户的需求、偏好和行为模式，以便实现更有效的用户服务、产品设计和市场营销。用户画像的应用目的不同，会影响到构建过程中参考元素的侧重点和设计的标签体系，从而确保用户画像能够有效地支持特定的业务目标。以下是关于用户画像构建目的和应用的详细解析： 用户画像构建的目的 实现精准营销：通过精确了解用户的特征和需求，企业可以设计更为针对性的营销策略，提高营销活动的转化率和效率，从而增加产品销量。 改进产品和提升用户体验：通过分析用户画像，企业能够发现产品设计中的不足，以及用户体验的潜在提升点，进而对产品进行优化，满足用户的实际需求。 用户画像的应用目的影响 参考元素的侧重差异：针对精准营销的用户画像可能更加关注用户的消费习惯和购买能力，而针对产品改进的用户画像则可能更加关注用户的使用行为和体验反馈。 标签体系的设计差异：根据用户画像的应用目的，设计的标签体系会有所不同，以确保标签能够有效地支持特定的业务需求。例如，针对营销的用户画像可能包含更多与消费偏好相关的标签，而针对产品改进的用户画像则可能包含更多与用户互动和反馈相关的标签。 用户画像的细化和应用 基础数据的梳理：完成用户画像构建的第一步是梳理和整合可用的基础数据，这些数据包括用户的基本属性、行为数据、偏好信息等。 精细化处理：根据业务目标和标准，对不同维度的用户数据进行精细化处理，将用户拆分成不同的群组和标签，以实现用户的细分。 标签与权重：为每个用户打上反映其兴趣、偏好、需求的标签，并分配相应的权重。权重反映了用户对某一内容的兴趣或需求程度，有助于进一步精确营销和个性化推荐。 用户画像的构建和应用是一个动态调整和持续优化的过程，随着市场环境的变化和用户需求的发展，企业需要不断地更新和细化用户画像，以确保其能够有效支持企业的业务目标和用户服务。通过精细化的用户画像，企业不仅能够更好地理解和服务现有用户，还能够发现潜在用户群体，为企业的长期发展提供坚实的数据支持。 数据建模方法数据建模对于构建用户画像来说是至关重要的步骤，因为它提供了一种系统化的方法来组织和解释用户数据。以下是基于事件模型概述的用户画像数据建模方法： 1. 用户标识 目的：确保每个用户都能被唯一识别，从而实现单点定位和用户行为的精确追踪。 应用：使用用户ID、邮箱、手机号码或任何其他唯一标识符来区分每个用户。 2. 时间 时间戳：记录用户行为发生的具体时间点，有助于分析用户行为的时间分布和模式。 时间长度：衡量用户在特定页面或应用中的停留时间，这可以反映用户对内容的兴趣程度。 3. 地点（用户接触点） 网址：用户访问的页面URL，不仅限于PC端，也包括移动端的应用页面，如社交媒体、电商网站等。 内容：用户在特定网址访问的内容，如文章、产品信息等。内容的性质决定了用户的兴趣和偏好。 4. 事件（用户行为类型） 行为类型：用户的具体操作，如浏览、搜索、添加购物车、购买、评论、点赞、收藏等。 应用：通过分析不同类型的用户行为，可以洞察用户的需求、兴趣和偏好。 数据模型公式[用户标识 + 时间(时间戳 + 时间长度) + 地点(网址 + 内容) + 事件(行为类型)] 标签打上的逻辑基于上述模型，可以根据用户的行为在特定时间、特定地点进行的特定事件来为用户打上相应的标签。这些标签反映了用户的兴趣、偏好和需求，为后续的个性化推荐、精准营销和产品优化提供了基础。 实施建模在实施数据建模时，需要采集和处理大量的用户数据，包括但不限于用户的浏览历史、交互行为和反馈。数据清洗和处理是此阶段的关键任务，以确保数据质量和模型的准确性。随后，通过应用数据分析和挖掘技术，如机器学习算法，可以从这些数据中提取有价值的洞察，形成精细化的用户画像。 通过这种方法构建的用户画像，不仅能够为企业提供深入的用户洞察，还能够支持更加个性化和精准的用户服务和营销策略，最终提升用户满意度和企业竞争力。 标签体系构建graph TD A[阶段效果] –&gt; B[静态数据标签] A –&gt; C[动态数据标签] 12345678910111213141516171819202122232425262728graph TD 原始数据 --&gt; 静态数据 静态数据 --&gt; 人口属性 人口属性 --&gt; 性别 人口属性 --&gt; 年龄 人口属性 --&gt; 身材 静态数据 --&gt; 社会属性 社会属性 --&gt; 职业 社会属性 --&gt; 地域 社会属性 --&gt; 婚姻情况 静态数据 --&gt; 商业属性 商业属性 --&gt; 消费等级 商业属性 --&gt; 消费周期 商业属性 --&gt; 消费占比 原始数据 --&gt; 动态数据 动态数据 --&gt; 行为数据 行为数据 --&gt; 访问或启动次数 行为数据 --&gt; 访问时长 行为数据 --&gt; 浏览路径 动态数据 --&gt; 偏好数据 偏好数据 --&gt; 使用App或Web 偏好数据 --&gt; 访问时间 偏好数据 --&gt; 浏览或收藏内容 动态数据 --&gt; 交易数据 交易数据 --&gt; 贡献率 交易数据 --&gt; 客单价 交易数据 --&gt; 回购率 标签体系构建是用户画像创建过程中的核心环节，涉及对用户信息的全面收集和深入分析，以形成有助于企业深入理解用户的结构化信息框架。这个过程通常涵盖了从基础数据梳理到动态数据分析的全方位工作，旨在通过不同维度的数据标签化，实现对用户行为和特征的精细描述。以下是标签体系构建的详细解析： 建模数据建模数据是构建用户画像的基础，包括用户的行为、交易记录、社交互动等数据。这些数据通过分析和挖掘，能够提供用户行为模式、偏好和需求的洞察。 静态数据静态数据提供了用户的基础框架和背景信息，主要包括： 人口属性：性别、年龄等基本信息，这些是用户画像的基础标签，通常不需要复杂的数据建模。 社会属性：地址、职业、婚姻状况等信息，反映用户的社会地位和生活背景。 商业属性：消费等级、消费周期、消费占比等，揭示用户的消费能力和习惯。 动态数据动态数据关注用户的行为和活动，包括： 行为数据：浏览时间、浏览路径等，反映用户的兴趣和行为习惯。 偏好数据：使用终端、浏览内容、日常爱好、购物偏好等，揭示用户的个性化需求。 交易数据：贡献率、客单价、复购率等，体现用户的消费价值和忠诚度。 用户画像分类用户画像的分类基于静态和动态数据的结合，可以分为： 静态用户信息标签和2D用户画像：基于人口属性、社会属性和商业属性的用户画像，为企业提供用户的基本框架和背景。 动态用户信息标签和3D用户画像：在2D画像的基础上增加了用户行为这一维度，通过分析用户的实际行为数据（如浏览、评论、购买等）来进行更深入的用户分析，实现活跃与不活跃用户的区分，以及对用户偏好和需求的更准确预测。 通过这样的标签体系构建，企业可以形成一个立体、动态的用户画像，不仅包括用户的基本信息和社会属性，还包括用户的行为模式和偏好。这使得企业能够更精准地进行市场定位、产品推荐、个性化营销和服务优化，最终提升用户满意度和企业的市场竞争力。 绘制用户画像您上传的图片包含了用户画像构建方法的信息，根据您的描述，可以概括为以下几个步骤： 定性与定量结合的研究方法 定性的方法： 首先通过定性分析，对产品、行为和用户个体的性质及特征进行概括，形成对应的产品标签、行为标签和用户标签。 定量的方法： 基于定性分析的结果，对每个标签打上一定的权重。然后利用数学公式，将权重化的标签综合起来，计算得出总的标签权重，从而形成一个最终的用户画像模型。 数据建模—给标签加上权重： 在确定标签之后，需要给每个标签分配一个权重，这个过程要根据用户行为数据和用户属性等相关信息来进行。 例如，在用户购买行为中，近期购买某品牌手机的用户与仅浏览该品牌手机的用户相比，对于品牌忠诚度的体现不同，因此它们的权重应该有所区别。 用户画像的建立方法： 根据用户信息的获取和分析方法的不同，可以分为：a. 定性用户画像：主要基于定性分析，如用户访谈、焦点小组讨论等。b. 定性画像+定量验证：先进行定性分析形成初步画像，再通过定量方法验证和调整。c. 定量用户画像：主要依赖于数据和算法模型，通过分析用户行为数据构建画像。 这三种方法在实际应用中可以相互补充，定性分析能够提供深入的用户洞察和直观的标签构想，而定量分析则为这些标签提供了可量化的度量和验证手段。在构建用户画像时，通常需要结合这两种方法来提高画像的准确性和可操作性。 方法 步骤 优点 缺点 定性用户画像 1. 定性研究：访谈2. 细分用户群3. 建立细分群体的用户画像 省时省离，简单，需要专业人员少 缺少数据支持和验证 定性画像+定量验证 1. 定性研究：访谈2. 细分用户群体3. 定量验证细分群体4. 建立细分群体的用户画像 有一定的定量验证工作 工作量较大成本较高 定量用户画像 1. 定性研究2. 多个细分假说3. 通过定量收集细分数据4. 基于统计的聚类分析细分用户5. 建立细分群体的用户画像 有充分的佐证，更加科学 工作量较大成本较高 用户画像的具体应用案例用户画像的构建和应用是现代营销策略中不可或缺的一部分，它帮助品牌深入理解用户需求和偏好，实现精准定位和个性化营销。以下是具体的应用案例，展示了用户画像如何在实际操作中发挥作用。 快消品牌案例：广告投放和私域运营背景：某日化快消品牌在年终活动期间希望通过公域广告投放快速推广新产品。品牌通过分析用户画像，将历史购买用户基于购买意向度进行分层，并进一步根据用户活跃度将其分为“活跃期”、“沉睡期”和“沉默期”，实施差异化的销售策略。 应用： 用户画像分析：通过用户画像洞察客户的购买品类、购买习惯、补货周期和近期浏览加购等信息。 精准营销：基于用户画像信息为消费者推送相应的内容和产品，以满足他们的需求并促进购买。 个性化体验：用户在线上购物时获得满足，易于找到适合自己的产品，增强对品牌的好感。 效果： 活动期间销售额提升近20%。 会员的季度唤醒率显著提高。 应用策略和效果分析这个案例展示了用户画像在快消品牌营销中的具体应用，通过精细化的用户分层和个性化的内容推送，品牌能够更有效地触达目标用户，提升用户参与度和购买转化率。用户画像的应用不仅限于广告投放，还包括产品推荐、内容定制等多个方面，能够全方位地提升用户体验和品牌忠诚度。 此外，用户画像还支持品牌进行有效的新品推广。通过分析目标用户群体的行为、属性和购买情况，品牌可以精准匹配并锁定潜在的意向人群，为新品上市创造有利条件。通过小范围的市场测试和用户反馈收集，品牌可以快速调整营销策略，进一步优化产品和服务，实现持续的业务增长。 这些案例凸显了用户画像在现代营销中的重要性，它使品牌能够在竞争激烈的市场环境中更加精准地定位目标用户，提供更加个性化的服务和产品，从而实现销售增长和品牌价值提升。","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"思路","slug":"思路","permalink":"https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"},{"name":"用户画像","slug":"用户画像","permalink":"https://www.yiuhangblog.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"}],"author":"Yiuhang Chan"},{"title":"业务目标","slug":"20200825业务目标","date":"2020-08-25T12:21:39.000Z","updated":"2024-02-28T10:50:02.000Z","comments":true,"path":"2020/08/25/20200825业务目标/","permalink":"https://www.yiuhangblog.com/2020/08/25/20200825%E4%B8%9A%E5%8A%A1%E7%9B%AE%E6%A0%87/","excerpt":"业务目标的概念，拆解和调整","text":"对业务目标的理解业务目标由谁制定在互联网公司里，事业部中的商分团队，负责经营分析方向的同学协助业务线的负责人及核心 管理层，需要根据行业的增长空间，对比外部竞争对手的目前状态，历史过往的经营数据，以及年趋 势的增长性，及季节因素等，结合全年可支配的销售预算、营销费用预算，及市场投放的广告费用预 算等等，综合给出预估的未来一年的增长性。在这个目标的测算过程中可能和核心管理层多次沟通， 然后多次调整。目的是为了在此过程里对分项目，分渠道，分团队的各方向目标都能够做到可实现， 可落地，但并非躺赢。 业务目标有什么作用目标，可以是定性的，也可以是粗定量的，也可以是细定量的。在企业的发展过程中，处于探索期或 者快速成长期的目标，往往一开始是由核心管理者的行业背景经验快速”拍”出来的，目标可能是一个 模糊的授意。那么就需要在执行过程里，将所有的目标变成可实现的，可衡量的具象化指标。另外， 企业发展到成熟期的，已经对市场环境、竞争对手和自身的发展规划相对清晰，制定目标已经成为了 工作流中很重要的一环。 业务目标如何制定业务目标的制定方法目标，就是对什么该做什么不该做的直观定义，并非一个数字，制定过程需符合SMAR T原则。目的就是为了判断阶段里所做的事情是否围绕目标服务，团队是否共同协作为了此目标努力。对于很多企业 来说，市场规模&amp;保证营收，都是企业非常关注且非常重要的目标。不管是规模指标还是营收指标， 前提都是完成一定的交易量级，交易额。 制定目标需考虑的因素 市场规模数据：通常来自于权威的行研分析报告，主要来自宏观的一些国家政策、人均可支配收入，在历史的发展上人均在这个行业上产生的GDP等等数据，拟合增长曲线后给出的市场规模数据。 线上化率预估：互联网公司中，很多运营操作其实就是讲消费者消费行为从线下引导到线上的动作，比如观影，从walkin到影院大厅购票到在网上自助购买，到大厅自助打票的过程。相对流 程简单，容易抽象的行业线上化率相对较高，一些行业内部的分散性高，或从业人员的学历低， 流程相对复杂个性化高的部分等等都会制约线上化率的发展，通常这类数据也来自于行研分析报 告。根据国家政策，例如5G,智能手机等等的普及，行业的历史发展的线上化率曲线，拟合线 上化率。 市占水平：来自经营数据，或者财报数据。另外也可以从企业自身用户规模量级和转化效率佐证 这一数据是否合理. 历史同期交易额增长：比如制定今年3月目标，会参考去年3月相对前年3月的增长情况，但对于 很多新生企业来说，没有这么久的历史数据，那么可以转而参考去年3月相对去年2月的增长情况。 ​ 举例：​ 2020年3月GMV预估&#x3D;2019年3月GMV *（1 +2019年3月&#x2F;2018年3月的YOY）​ 2020年 3 月 GMV 预估&#x3D;2020年 2 月 GMV *（1 +2019年 3 月 &#x2F;2019 年2 月的YOY） 交易商家数：商家单门店产出每月变化较小，会从供给角度校验下大数是否合理。但如果企业自身现在目前在市场的供给覆盖情况还不足，此项数据可参考性就需要再衡量。 ​ 公式：2020年GMV预估&#x3D;20年市场规模预估 * 20年线上化率预估 * 20年自身占比规模 * 调整系数 ​ &#x3D; 19年交易量* （ 1+19年YOY ）​ &#x3D; 20年用户量级预估*转化效率​ &#x3D; 在线营业商家量*单商家贡献 直接影响交易额增长的客观因素 天气：例如雷雨、台风等 温度：不同温度区间对消费需求的刺激情况，一般情况下，高温（超过35°C）或低温（低于0°C）会随 着恶劣程度对需求量正向&#x2F;负向刺激 节假日：区分放假的节假日和不放假的节假日，且不同节假日的影响效果不同 周末：周末普遍需求上涨 补贴力度：不同补贴力度和活动类型对用户的刺激影响程度不同 业务目标的调整通常来说，目标制定出来后，可以在原先的基础上进行调整，但是不会推翻目标重来。为什么呢？对于很多企业，目标就是价值和成果的象征，是凝聚团队成员朝一个方向去共同努力的风向标。频繁的 变更目标，会导致团队整体的方向感出现严重的问题，无法协作，无法形成凝聚力。 以下条件下可以进行目标的调整: 不可抗力。 举例：今年从春节左右开始的疫情，对于很多企业都是受到了发展的限制。 主要的客观条件、或者支持因素发生变化。 举例：国民出行意愿降低，地方政策管控聚集类场所阶段的不营业。 企业的战略方向调整。 举例：作为高优孵化的业务方向，调整为低优或限制发展。 业务目标如何拆解基于刚才提到的目标拆解的意义，需要开始着手进行分拆的事项。以下有几种常见的拆解方式，是基 于团队的之间的分工方式不同，而进行的流水线拆分，或者横向拆分的方法。也或者在项目中或者特 定的时间点需要将两者进行结合。 对达成的过程指标进行分拆主要是面向的大家负责的是不同的职能范围。比如面向C端产运团队的同学，根据公式交易额&#x3D;UV * 转化率 * 单uv价格。里面基本三个过程指标都是变量的情况下，逐一确认变量。知晓各团队所扛的指标分别是多少。 举例： 预估2019年8月交易额需要达到1000W，已知单UV贡献的价格基本在150元左右。里面存在UV和转化率两个变量。 (1) 给出2018年8月环比7月的转化率水平，再根据2019年7月的转化率水平得知是否可保持对应的 增长性。得知2019年8月的转化率目标需达到31.49%。 年 月 转化率 2018 7 27.60% 2018 8 30.50% 2019 7 28.50% (2) 根据推算出来的转化率指标推算流量&#x3D;交易额&#x2F;单UV价格&#x2F;转化率&#x3D;211676 结论： 负责引流团队要保障引流动作带来用户在21.16W左右，同时负责补贴团队需要通过补贴手段保障转化率水平在31.49%左右。 按照品类&#x2F;区域进行分拆这种情况通常来说，是大家面向的同样的工作范畴，但是可能负责的具体的产品范围或者地域范围不同。比如面向商拓团队的时候，这种情况非常常见，要从大区、区域、城市、个人，这样逐层拆解。 拆分逻辑：按照品类A+品类日&#x3D;总交易额的思路，先对目标进行分拆。 方案一：品类A的19年8月目标&#x3D;品类A的18年完成值 *【1+ (19年7月-18年7月)&#x2F;18年7月】 * 方案二：大区A的19年8月目标&#x3D;品类A的19年8月目标 *大区A占比。大区A占比，参考19年7月的各大区的占比情况 按照项目进行分拆在企业的实际工作开展过程中，会针对在拓展获客渠道，捕捉时下热点，保障供给能力等方面分别发 起一些独立的项目，这些独立的项目可能是面向部分渠道，面向部分的产品。所以针对这类项目需要 单独进行目标的制定，目标不一定是以结果指标作为最终考核指标，也可能会以项目需要达成的导向 以过程指标作为目标。 举例：在时下疫情阶段，为了深化供给侧的合作深度，决定发起一个项目，去谈合作紧密型的优质商家，并且在C端页面给予一定的流量扶持。要给出该项目的项目目标。 首先在制定目标前要考虑，这个项目的目标是为了得到什么结果，面向供给侧，是为了在阶段里拿下更多优质商家，面向用户侧是为了流量做倾斜处理。 所以，需要先进行一拨数据摸底。明确优质商家的定性和定量的指标到底是什么。经过和业务侧的反复沟通，确认如下指标为衡量优质商家的标准。 独家供给：对比其他竞对网站独家覆盖 库存率高：在线库存量&#x2F;物理库存量＞&#x3D;70% 绝对低价：对比其他竞对网站价格低 拒单退款水平低：对比其他同类商家拒单水平低，退款水平低 通过调取2019年7月的这些指标，得到了优质商家的覆盖量级在1.5w家左右。而现在站上根据用户主动搜索主动点评的这类明星商家大概有10w家左右， 根据测算商家所处的省份，城市信息，确定各地可跟进的量级。大区A需要跟进4w家，大区B需要跟进3w家，大区C需要跟进1.5w家。 按照各区的人员比例，确认一个商拓人员一周可以跟进的量级约在4家。大区A有200人，在8月约可以跟进3200家，大区B有100人约可以跟进1600家，大区C有100人约可以跟进1600家。 再根据商家一个月可以自主报名的比例约在20%,约可以完成2w家。 因此2019年8月优质商家覆盖的目标约为2.64W家。需要完成独家供给、库存率高、绝对价低，拒单 退款水平低的要求。 流量扶持的目标则在引流和转化两个方向展开。 按照特定时间点进行分拆依据各行业的淡旺季情况的不同，对于旺季的特定时点往往会依据过去的历次时点的峰值水平，由核心管理层直接发起一个定性的峰值目标。例如在双十一天猫要冲破x百亿。 分析师这时候需要做的是，首先确认特定时点的起止时间点。例如旅游行业的十一出行，确认是2019年9月30日-2019年10月7日，还是其他的时间点。 按照时间点分拆分日目标，首先先要对用户出行的峰值时间进行预估，确认哪天是最容易达到峰值的。像今年的十一，十一当日肯定是出行的高峰时间，用户前后借假休的概率偏低，没有前后的周六 日。另外根据机票、火车票等用户的出行时间，都可以锁定，用户的出行时间。 确认峰值时间点后，根据历次特定时点带来的用户量级和转化效率看，距离峰值目标的实际差距。通常情况下，企业内有大量的AB实验，确认各手段对于转化率的提升的作用。补贴到达一定水平后，其实转化率会趋于到一个顶峰值不再波动。 根据峰值时间的交易量目标反推。交易量目标&#x3D;引流用户量级转化效率人均可产生的交易额 举例背景销售的业绩指标，分析师在每月中下旬开始做下月的预估，地面团队需要在每月20号给到下月明确的交易量目标；电销团队时间节奏基本保持一致。两团队逻辑保持基本一致。 具体计算逻辑整体目标确定按照大盘下个月的目标，一般是交易额&#x2F;GMV ，计算出下个单的交易量目标 业务线大盘2020的5月的交易额目标 11亿元 ，计算出交易量： 11亿&#x2F;120(客单价) * 80%(消费 人群) &#x3D;733万 分别确定地面和电销的整体目标计算逻辑一般是按照地面团队的180个城市和电销团队负责的2000县城在过去一个月或者一个季度全部消费间夜量在酒店夜住大盘的占比来确定。 地面团队历史交易占比70% ，电销团队是30% ，根据交易量占比拆分，5月份的交易量 &#x3D; 733万 + 0.7 &#x3D; 513万 ， 电销交易量 &#x3D; 733万 * 0.3 &#x3D; 220万 分拆地面和电销的分城市&amp;分区县目标地面团队：根据YOY ，拆分城市的各自数据 电销团队：根据MOM，拆分区县的数据 调整目标可控： 地面团队：对于分城市的YOY异常高的数据，可以参考上个月的实际完成值(大盘的本月目标 &#x2F; 上个月完成值) 电销团队 ：对于分区县的MOM异常，可以参考上个月的实际完成 值（大盘 的本月目标&#x2F;上个月完成值） 不可控： 疫情、节假日出现、企业的战略方向(调整为低或者限制发展)、国民出行意愿低、天气温度等","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"思路","slug":"思路","permalink":"https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"},{"name":"业务目标","slug":"业务目标","permalink":"https://www.yiuhangblog.com/tags/%E4%B8%9A%E5%8A%A1%E7%9B%AE%E6%A0%87/"}],"author":"Yiuhang Chan"},{"title":"数据分析方法与流程","slug":"20200815数据分析方法","date":"2020-08-15T07:56:21.000Z","updated":"2024-02-28T10:49:57.000Z","comments":true,"path":"2020/08/15/20200815数据分析方法/","permalink":"https://www.yiuhangblog.com/2020/08/15/20200815%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/","excerpt":"数据分析中用到的部分方法，落地流程及业务指标","text":"分析方法在数据分析中，分析方法是指用于从数据中提取有用信息和洞察的技术和流程。这些方法可以根据数据类型、分析目标和所需的洞察类型而有所不同。以下是一些常见的数据分析方法： 描述性分析（Descriptive Analysis）: 目的：描述和总结数据集的特征。 方法：使用统计指标（如平均值、中位数、众数）、数据可视化（如条形图、饼图、直方图）等。 诊断性分析（Diagnostic Analysis）: 目的：探究数据背后的原因和关系。 方法：寻找变量间的相关性和因果关系，使用例如回归分析、相关性分析等。 预测性分析（Predictive Analysis）: 目的：基于历史数据预测未来事件。 方法：使用统计模型和机器学习算法，如线性回归、时间序列分析、随机森林等。 规范性分析（Prescriptive Analysis）: 目的：提出基于数据分析的行动建议。 方法：运用优化和仿真技术，结合预测性分析结果提供决策支持。 探索性数据分析（Exploratory Data Analysis, EDA）: 目的：探索数据集以发现模式、异常、趋势等。 方法：使用各种统计图表和数据可视化技术，进行初步的数据探索。 机器学习和人工智能（Machine Learning and AI）: 目的：利用算法自动学习和改进从数据中的洞察。 方法：包括监督学习、非监督学习、强化学习等。 每种方法都有其独特的应用场景和优势，选择哪种方法取决于具体的业务问题和数据特性。 信息 分析模型: 定义: 分析模型是一个框架或者结构，用来代表数据、变量之间的关系，以及这些关系如何与要研究的现象相联系。它们通常基于特定的理论或假设。 举例: 如RFM模型（衡量客户价值和参与度）、AARRR模型（用户生命周期跟踪）、线性回归模型（预测数值型响应变量和解释变量之间的关系）等。 特点: 分析模型通常是针对特定问题或领域设计的，如市场分析、财务预测、用户行为分析等。 分析方法: 定义: 分析方法指的是一套程序或技术，用于处理和分析数据，以提取有用信息或洞察。这些方法更多关注于“如何分析”而不是“分析什么”。 举例: 如描述性统计、机器学习算法、时间序列分析、探索性数据分析（EDA）等。 特点: 分析方法通常是通用的，可以应用于多种不同的数据集和问题。 简单来说，分析模型是一种针对特定问题或领域的结构或框架，而分析方法则是处理和分析数据的一套技术或程序。在实际应用中，通常会将合适的分析方法应用于特定的分析模型，以解决具体的业务问题或实现数据洞察的目标。 RFM 模型RFM模型更多地与描述性和诊断性分析相关，重点在于理解和分析现有客户的行为模式 这三项数据成为了衡量客户价值和客户创利能力的重要工具和手段。也是 RFM 模型的三个重要指标： Recency (最近性): 衡量客户最后一次购买或交互的时间。越近的行为通常意味着更高的再次购买或互动的可能性。 Frequency (频率): 衡量客户在特定时间内的购买或互动次数。频率越高，表明客户越忠诚。 Monetary Value (金钱价值): 衡量客户在一段时间内为公司带来的总收入。较高的消费总额通常指示出更有价值的客户。 个指标针对的业务不同，定义也会有所不同。但是无论是什么业务，各指标都有如下的特征： 1）最近一次消费时间间隔（R）：上一次消费时间离现在越近，再次消费的几率越大。即 R 值越小，用户的活跃度越大，用户的价值就越高； 2）消费频率（F）：购买频率越高，说明用户对品牌产生一定的信任和情感维系。即 F 值越大，用户的忠诚度就越大，用户的价值就越高； 3）消费金额（M）：消费金额越高，说明用户对产品的购买力越大。即 M 值越大，用户的购买力就越大，用户的价值就越高。 RFM 模型的作用 RFM模型的作用主要包括： 客户细分：帮助企业区分不同价值的客户，以便更有效地定位和沟通。 个性化营销：根据客户的RFM评分，实施更有针对性的营销策略。 提高客户忠诚度：识别忠诚客户，从而采取措施提高他们的满意度和留存率。 预测客户行为：通过分析历史购买数据，预测客户未来的购买行为和潜在价值。 资源优化分配：确保营销资源更集中地投入到最有价值的客户群体。 总的来说，RFM模型是帮助企业更好地理解和服务其客户群体的强大工具。通过精准的客户细分，企业可以更有效地分配营销资源，提高客户满意度和忠诚度，从而增加收入和盈利能力。 RFM 模型的构建流程计算 R、F、M 的值 根据 RFM 的阈值，对用户进行分类1）给 R、F、M 各值按价值划分打分区间 这里需要注意的是，我们不是按指标的数值大小打分，而是对指标的价值打分。像最近一次消费时间间隔（R），消费时间间隔最近，即 R 值越小，用户的价值越高，反之，用户的价值越低。 2）计算价值的平均值 打完分数后，分别计算 R、F、M 各打分值的平均值，结果如下： 3）用户分类 最后，我们将两个用户的 RFM 值与各值的平均值进行对比。 如果一行里的 R 值打分大于平均值，就标记该行的 R 值打分为“高”，反之标记为“低”。F、M 值亦是同理。 再将标记好的 RFM 高低值与用户分类规则表进行对比，可以得出用户属于哪种类别。 小结 注意 划分 RFM 的“高低”值，关键是找到划分的阈值。分析目标的不同，所选择的分析方法也可能不同。上面的例子中，我们为 RFM 各值进行分区域评分，再计算各评分值的平均值来得到阈值。 RFM总结 关联分析关联分析（Association Analysis）是数据挖掘的一个重要方面，主要用于发现在大型数据集中不同项之间的有意义的关联或规律。这种分析尤其在市场篮子分析（Market Basket Analysis）中广泛应用，但其应用范围远不止于此。以下是关联分析的一些关键点： 核心概念: 项集（Itemset）: 数据集中的一个或多个项目的组合。 支持度（Support）: 在所有事务中某个项集出现的频率。 置信度（Confidence）: 一个项集的出现在另一个项集已经出现的条件下的条件概率。 提升度（Lift）: 衡量两个项集的关联强度，即项集A的出现对项集B出现概率的影响。 常用算法: Apriori算法: 一种经典的关联规则挖掘算法，通过迭代方式寻找频繁项集。 FP-Growth算法: 一种有效的频繁项集挖掘方法，使用FP树结构来压缩数据集，效率高于Apriori算法。 应用实例: 市场篮子分析: 在零售业中分析哪些商品经常一起被购买。 推荐系统: 根据用户过去的购买行为或喜好推荐商品或内容。 交叉销售和促销策略: 确定哪些产品应该一起展示或促销。 医疗数据分析: 在医疗数据中寻找疾病和症状之间的关联。 挑战: 大数据量处理: 在大数据集上进行关联分析可能非常耗时。 生成规则的质量: 生成的规则数量可能非常庞大，且不是所有规则都有实际意义或价值。 误解和错误的因果关系: 强关联不一定意味着因果关系。 关联分析在为商业决策提供数据支持方面发挥着重要作用，能够帮助企业更好地理解客户行为，并据此优化产品布局和营销策略。 流程数据集现在手里有一份快餐店的用户交易数据： 如图所示：用户1001用户购买了【薯条、可乐】等2类商品，用户1002用户购买了【薯条、可乐、奶茶】等3类商品，以此类推，1004用户购买了汉堡、可乐】2类商品等 基于这份数据，我会向快餐店老板提出建议，推出薯条和奶茶的组合套餐。因为我发现购买奶茶的用户，有很大概率会加购薯条，发现的过程如下： 从那份只有4条数据的交易数据入手，它有点像购物小票。交易数据记录了用户的单次消费行为，即交易记录，如1001号订单，意思是某用户一次性购买了两种（非数量）食品：薯条、可乐。 事物而每条交易记录又可称为一个事务。所以，这份交易数据一共含有4条“事务” 即1001用户购买了【薯条、可乐】，这是一次事务；1002用户购买了【薯条、可乐、奶茶】这是两次事务，以此类推， 1004用户购买了【汉堡、可乐】这是第四次事务。 项交易中的不同物品可称为一个项。 比如说，这4条交易记录，商品类目去重后，一共含有4个项（商品类目）：{“薯条”，“可乐”，“奶茶”，“汉堡”} 项集 0个或多个项的集合，可称为一个项集，一般用{X}的形式表示项集，k 个项组成的项集, 叫 k 项集 如{薯条，可乐},有两项，看见花括号就是集合，所以是2 项集，在比如{薯条}，有1 项，看见花括号就是集合，所以是1项集 前面的4项商品，可以相互组成15个项集，项集内不存在相同的项，如{奶茶，薯条，薯条}。 支持度 {X}的支持度 &#x3D; {X}在事务中出现的次数 &#x2F; 事务总数。 事务总数在上面已经讲到，就说每条交易记录又可称为一个事务。所以，这份交易数据一共含有4条“事务” 即1001用户购买了【薯条、可乐】，这是一次事务；1002用户购买了【薯条、可乐、奶茶】这是两次事务，以此类推， 1004用户购买了【汉堡、可乐】这是第四次事务。随意X的支持度的分母&#x2F;事务总数就是4，薯条和奶茶同时出现在一块儿的购买商品 在1002的订单号里，其他的订单号没有同时出现【薯条、奶茶】的身影，所以分子&#x2F;{薯条、奶茶}出现的次数就是1，1除以4 &#x3D;1&#x2F;4等于0.25 频繁项集 此时，我们需要人为地设定一个支持度，名为最小支持度，用于筛掉那些不符合需求的项集。 比如4 项集：{可乐，汉堡，奶茶，薯条}就不符合需求，比如说，给个超参数0.2，小于0.2的支持度过滤掉，大于等0.2的保留 被留下来的项集（≥ 最小支持度），被称为频繁项集。 关联规则 有了频繁项集，就可以生产关联规则了。 关联分析是探索数据之间联系的技术，而数据之间的联系，我们用关联规则来表示，表达式为：{X}→{Y}（X 和 Y 之间不存在相同项）。 X项集和Y项集之间存在哪种关联规则有顺序之分，为了方便描述，我们把规则前面的项集叫前件，把规则后面的项集叫后件。 假设有频繁项集 {奶茶，薯条}，它可以生成2条关联规则：{薯条}→{奶茶}和{奶茶}→{薯条}。前者的意思是，购买“薯条”的顾客，和购买“奶茶”之间，可能存在有某种联系；同理可得，后者的意思是，购买“奶茶”的顾客，和购买“薯条”之间，可能存在有某种联系 置信度 置信度(Confidence)可用于衡量关联规则的可靠程度，表示在前件出现的情况下，后件出现的概率。一般来说，概率越高，规则的可靠性越强。 关联规则{X}→{Y}的置信度 &#x3D; {X，Y}的支持度 &#x2F; {X}的支持度。在上边已提到，{薯条、奶茶}支持度 &#x3D; {薯条、可乐}同时出现了1次，一共有1001、1002、1003、1004等4次事务，所以{薯条、奶茶}支持度就是1&#x2F;4&#x3D;0.25, {薯条}的支持度 &#x3D; {薯条}出现在了1001，1002，1003等3次，一共有4次事务，所以{薯条}的支持度 &#x3D;3&#x2F;4 &#x3D; 0.75 最后2者一相除约等于0.33 同为关联规则，可靠程度有“强”有“弱”。 在实际业务中，也需要人为地设定置信度，名为最小置信度，用于筛掉一些不符合需求的关联规则。被留下来的关联规则（ ≥ 最小置信度），叫做强关联规则。 提升度 关联规则既有促进关系，也有抑制关系。因而，还需引入提升度(Lift)对它们进行判断。 {X}→{Y}的提升度 &#x3D; {X}→{Y}的置信度 &#x2F; {Y}的支持度，意思是评估 X 的出现，对 Y 出现的影响有多大。 小结 大多数的关联分析工作，主要任务就是生成频繁项集和关联规则。有了计算公式和流程，理论上，可以手算，不过难度可想而知： 一个3项（k 项）的数据集，能产生7（2^k - 1）个非空频繁项集。 一个3项（k 项）的频繁项集，可产生6（2^k - 2）个关联规则。 随着“项”的增加，频繁项集和关联规则的计算量必将呈指数增长。 而现实生活中的“项”（商品）成百上千，真实的“事务”（交易）数以万计。。提高计算效率，可以使用Apriori 算法。","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"思路","slug":"思路","permalink":"https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"},{"name":"RFM","slug":"RFM","permalink":"https://www.yiuhangblog.com/tags/RFM/"},{"name":"关联分析","slug":"关联分析","permalink":"https://www.yiuhangblog.com/tags/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"},{"name":"模板","slug":"模板","permalink":"https://www.yiuhangblog.com/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"指标拆解","slug":"指标拆解","permalink":"https://www.yiuhangblog.com/tags/%E6%8C%87%E6%A0%87%E6%8B%86%E8%A7%A3/"},{"name":"落地流程","slug":"落地流程","permalink":"https://www.yiuhangblog.com/tags/%E8%90%BD%E5%9C%B0%E6%B5%81%E7%A8%8B/"}],"author":"Yiuhang Chan"},{"title":"数据分析思路模板","slug":"20200728 数据分析报告思路","date":"2020-07-28T01:32:16.000Z","updated":"2024-02-28T10:49:55.000Z","comments":true,"path":"2020/07/28/20200728 数据分析报告思路/","permalink":"https://www.yiuhangblog.com/2020/07/28/20200728%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E6%80%9D%E8%B7%AF/","excerpt":"进行数据分析和撰写报告的思路模板","text":"定量 明确目标：这是开始任何数据分析项目的第一步。明确目标意味着确定想通过数据分析解决的具体问题或达成的具体目标。这可能包括理解特定现象、预测未来趋势、识别模式或关系等。 数据处理：在这一步中，将收集相关数据并进行预处理。数据处理包括清洗（去除或纠正错误、不完整、不一致的数据）、格式化、结构化，以及可能的数据转换，以便于进一步分析。 数据分析：这一阶段是定量分析的核心，涉及使用统计方法、算法、模型等对数据进行深入探究。这可能包括描述性统计分析、推理统计分析、预测建模、聚类分析等。 数据展现：数据分析的结果需要以清晰、易懂的方式展现。这通常涉及数据可视化（如图表、图形、仪表板等），以及用于解释数据的文本描述。 报告撰写：最后一步是撰写报告，将分析过程、结果、以及洞察呈现给相关利益相关者。报告应该包括关键发现、数据分析的方法论、结论，以及可能的建议或行动方案。 明确目标 在对数据进行分析之前，首先第一步便是要明确目标。 明确目标这个环节往往需要做到以下三点，分别是： 明确分析需求 搭建分析框架 收集分析数据 接下来结合防护服装厂案例，来了解一下在这三个环节都分别需要做些什么。 首先来学习一下如何明确分析需求。 注意 现状和痛点这两个事都要藏在心里面不要不要直接说（写这两个的都被优化了🤣） 明确分析需求防护服装厂从 2020 年初开始售卖防护服，到 7 月初的时候，营销总监发现账目上已经开始出现亏损。总监十分焦虑，想要在短时间内快速找到亏损的原因，以及对应的解决策略。 从总监遇到的难题中不难发现，这次的任务需要解决两个问题，分别是： 找到亏损原因 找出对应的解决策略 在明白了这次的任务需要做什么以后，接下来就要思考如何去解决这些问题了。而要想解决问题，往往就需要搭建一个分析框架，系统地指导我们该如何去解决问题。 报告制式 12345## 一、背景某某科技公司，运营了一家小型的****工厂，该厂经营状态过往处于不稳定的状态，在今年6月底，经营开始处于亏损状态。通过本次对该厂历史经营数据的分析，帮助公司推断该厂的发展，并对该厂的亏损问题处理提供建议。## 二、目的 探寻该厂的亏损问题的原因、及下一阶段的经营发展趋势，并对防护服装厂的亏损问题处理提供建议。 搭建分析框架通过刚才的分析，已经知道了这次任务首先要做的就是找到防护服付账厂亏损背后的原因。 而亏损意味着利润为负，所以本质上我们要研究的是防护服装厂的利润情况。 订单量、单价、成本以及销售额都是会影响防护服付账厂利润的。 现在的问题是，即便知道了这四个因素会影响防护服付账厂的利润，接下来该如何动手去分析呢？到这里思路依旧不明朗。 尤其是这些因素，彼此之间又存在一些关联，互相影响。比如想研究订单量的变化情况，结果发现订单量对利润可能不构成直接影响。 公式拆解法一种比较适合这个问题场景的方法：公式拆解法。首先来了解一下公式拆解法是什么。 公式拆解法就是利用数学公式，将会影响因变量的因素按照层级关系罗列出来。然后通过分析这些因素的变化情况，来推演因变量是如何受到这些因素影响的，如下图所示： 首先从最根本的研究对象，或者说因变量开始拆解。由于防护服装厂的亏损本质上就是利润为负，那么利润就是最终想要研究的对象，放在最顶层 在对销售额拆解完毕以后，正常情况下应该思考成本会和哪些因素有关。 不过这里有个好消息，就是之前的一位员工在计算防护服付账厂各月成本的时候，已经求得防护服付账厂在 2020 年 1 月到 6 月期间，各月成本&#x2F;工资&#x2F;投放&#x2F;房租&#x2F;水电暖几乎没有变化，成本这块儿可以忽略不计。 所以利润这个因素可以看作只受到销售额的影响，之后没有必要对成本继续拆解了。 当然，这个拆解的过程是可以不断细分下去的，但是有一点要考虑，数据的采集成本。 比如说想要继续研究订单量这个因素，我们可能会觉得这和市场的供货量有关，于是就想要去采集 2020年年初到 6 月份期间市场上防护服装厂的总产能，想通过产能的变化来分析订单量的变化原因。 防护服付账厂的订单量很有可能是被这部分”大客户“所主导的。 如果因为某些原因，“大客户”出现了比较严重的流失，那么就会对订单量产生比较大的影响。 基于这条拆解思路，可以根据公式：订单量 &#x3D; 订单量（省份1） + 订单量（省份2） + 订单量（省份3）+ …，对订单量进行进一步的拆解 到这里就已经利用公式拆解法对防护服付账厂的利润情况进行了拆解。 从搭建的模型来看，后续的分析需要用到以下四层信息：销售额、订单量、防护服付账单价、订单来源省份。 报告制式 12345678910111213141516## 三 、分析思路### 3.1方法：利润 = 销售额-成本，现已知1-6月份防护服装成本是变动微小，故本次分析主要从“销售额”进行分析。### 3.2总方法：通过销售额及其影响因子的分析，对过往销售额变化的规律、变化原因进行剖析### 3.3公式：销售额 = 订单量 × 单价订单量 = 省份1+省份2...+省份n### 3.4分析框架：分析各月的“销售额”变化趋势，分析变化规律与原因。分析各月“订单量”的变化趋势，分析变化规律与原因。分析各月“单价”的变化趋势，分析变化规律与原因。分析各月各省份“订单量”的变化趋势，分析变化规律及原因。 数据收集 123456# 导入 CSV 数据import numpy as npprotective_clothing = np.loadtxt(&#x27;mask_data.csv&#x27;, dtype = str, encoding = &#x27;utf-8&#x27;)print(protective_clothing) numpy库为读取各种文件类型的数据提供了非常简便高效的方法。 np.loadtxt(&#39;path&#39;, dtype , encoding ) 就是其中一种高效读取 csv 文件的方法. 这个方法有很多参数，这里先介绍三种最常用的：path，dtype，encoding。 对于参数 path，需要传一个文件路径给它，可以是相对路径，也可以是绝对路径。这里出于方便，就可以传一个相对路径给参数 path。 对于参数dtype，根据业务需要转换成我们想要的数据类型，在该案例中，因为数据是字符串类型，我们就要转换成dtype = str 对于参数 encoding，需要传一个文件编码格式给它。文件编码格式的选取需要根据所读文件的编码格式来定。 从拆解好的思路中不难发现，需要用到的信息有：销售额、订单量、单价以及省份信息。 同时，刚才也分析过我们需要用到时间这个维度的信息，与之对应的日期这一列数据，也存在与我们的数据之中。 不过在观察各列的数据时，数据的异常情况，如下图所示： 报告制式 12## 四、数据来源从公司数据库中导入营销数据mask_data.csv，原始数据一共包含101942行，数据的结构如下： 小结 数据处理 注意 数据清洗和数据处理不是一回事，数据清洗属于数据处理的一个环节 数据清洗 12345# 导入Pandas库并将其简化为pdimport pandas as pd # 导入数据分析库# 读取本地口罩厂的数据mask_data = pd.read_csv(&quot;mask_data.csv&quot;)print(mask_data) 缺失值处理缺失值使用df.info()方法查看数据集信息 其中，日期，省，订单量，单价，销售额这些列的非空数据都比数据总量要小，说明都有缺失值 在 pandas 库中，我们可以使用isna()方法来查找DataFrame 对象 以及 Series 对象中的缺失值。它可以将查找结果以 DataFrame 对象或者 Series 对象的形式进行返回。df.isna()返回的是 DataFrame 对象，Series.isna() 返回的就是 Series 对象。 protective_clothing.isna() 12# 查看数据后5行protective_clothing.tail() 删除缺失值123# 删除所有缺失值mask_data_na_clean = mask_data.dropna() 小结 重复值处理重复值重复值很好理解，就跟字面意思一样，指的是表格中重复出现的数据。在多数情况中，重复值都是完全相同的数据。 重复值处理的第一步和缺失值一样，还是要先查找重复值。 我们可以直接使用df.duplicated() （中文意思：重复的）方法来查找DataFrame 对象中的重复数据。 使用 df.duplicated() 方法会返回一个 Series 对象，找出所有重复值。重复为 True，不重复为False。 12# 查找 protective_clothing 中的重复行mask_data_na_clean.duplicated() 12# 查看 protective_clothing 中的重复数据mask_data_na_clean[mask_data_na_clean.duplicated()] 1234# 直接删除所有重复值mask_data_na_dup_clean = mask_data_na_clean.drop_duplicates()# 查看 protective_clothing 中的重复数据mask_data_na_dup_clean[mask_data_na_dup_clean.duplicated()] 在运行结果中我们能看见mask_data_na_dup_clean的表头下面是空的，说明到这里已经没有重复数据了。值得一提的是，df.drop_duplicates() 方法并不会将所有重复的行都删除。 小结 异常值处理异常值有时数据中有一个或多个异常大或异常小的数值，超出了这份数据实际的限定范围，这样的数值被称为异常值。 我们在数据清洗中要先对异常值进行识别，因为它有可能是一个错误的数值。 对于异常值，我们首先要做的是检查数据是否存在异常。若数据存在异常我们则需要抽取限定范围的数据，过滤异常值。 检查异常值 检查数据是否存在异常的方法 —— describe()。 describe 单词在英语里是描述的意思，而在 pandas 库中 describe() 方法则可以查看 Series 对象或者 DataFrame 对象的描述性统计信息。 12# 查看 protective_clothing 的描述性统计信息mask_data_na_dup_clean.describe() 抽取数据范围，在pandas库中，有一种筛选数据的方法叫做布尔索引，使用df[&#39;列索引&#39;] 来提取某一列的信息。在 pandas 库中，我们还可以在 df[] 中通过表达式的形式来提取一定范围的数据。 123456789101112131415161718# 查看单价小于等于200的数据mask_data_na_dup_clean[mask_data_na_dup_clean[&#x27;单价&#x27;] &lt;= 200]# 查看单价小于等于200的数据mask_data_na_dup_clean[&#x27;单价&#x27;] &lt;= 200# 筛选单价小于等于200的数据mask_data_na_dup_s200_clean = mask_data_na_dup_clean[mask_data_na_dup_clean[&#x27;单价&#x27;] &lt;= 200]# 查看防护服装厂数据的描述性统计信息mask_data_na_dup_s200_clean.describe()# 筛选订单量大于0的数据mask_data_na_dup_l0_s200_clean = mask_data_na_dup_s200_clean[mask_data_na_dup_s200_clean[&#x27;订单量&#x27;] &gt; 0]# 查看mask_data的描述性统计信息mask_data_na_dup_l0_s200_clean.describe()mask_data_na_dup_l0_s200_clean.info() 小结 数据整理转换日期数据123mask_data_na_dup_l0_s200_clean_date_fot = pd.to_datetime(mask_data_na_dup_l0_s200_clean[&#x27;日期&#x27;], format = &#x27;%Y-%m-%d&#x27;)# 查看date_dataprint(mask_data_na_dup_l0_s200_clean_date_fot) 提取月份信息1234# 提取日期数据中的月份信息month_mask_data = mask_data_na_dup_l0_s200_clean_date_fot.dt.month# 查看month_dataprint(month_mask_data) 增加新列1234# 将月份数据添加到原数据中mask_data_na_dup_l0_s200_clean[&#x27;月份&#x27;] = month_mask_data# 查看原数据print(mask_data_na_dup_l0_s200_clean) 保存文件12# 保存清洗干净的数据，并取消写入行索引mask_data_na_dup_l0_s200_clean.to_csv(&#x27;mask_data.csv&#x27;, index = False) 报告制式 1234567891011## 五、数据处理### 5.1清洗数据： 缺失值 重复值 异常值### 5.2 整理数据： 多增加【月份】这一列，时间维度### 5.3 清洗结果： 我们对以上三种数据均进行了删除处理，其中清洗前数据一共有101942，清洗后数据一共有99485行。 清洗数据占比：占比2% 清洗前后数据量变化极小，因此可以忽略对结果的影响。 小结 数据分析 根据前面的分析拆解，我们知道本次分析的重点是—销售额，订单量，单价，各省订单量随着时间变化的趋势及其变化原因。 那么，我们可以通过分组聚合对每一组数据进行描述性统计分析，然后利用折线图进行变化趋势的分析。 防护服装厂的任务，需要解决总监的两个问题—找到亏损原因、找出对应的解决策略。 分组聚合，统计数据本次分析的影响因素是销售额、订单量、单价、各省订单量，而且是以一个月为颗粒度，进行时间维度上的变化趋势和原因分析。 清洗后的数据mask_data_clean，它的列索引中包含着我们需要的销售额、订单量等数据。 以销售额为例，如果要分别查看 1 月到 6 月以来的销售额，可以根据月份对数据mask_data_clean进行分组。 我们可以计算出销售额的总数，因为它代表着这个月销售额的总体情况，可以通过对比它的上升或下降，查看其每月变化。 首先要根据月份对数据集进行分组groupby，同时还需要对销售额列进行一次聚合计算，计算出销售额的总和sum。 12345678910# 导入Pandas库并将其简化为pdimport pandas as pd # 导入数据分析库# 读取本地口罩厂的数据mask_data = pd.read_csv(&quot;mask_data_clean.csv&quot;)# 获取每月销售额总数sales_income = mask_data_clean.groupby(&#x27;月份&#x27;)[&#x27;销售额&#x27;].sum()#查看数据sales_income 可以看到，打印的结果是一个 Series 对象，它的值是销售额的总数，行索引是月份。 根据数值已经可以大致看出，1-3 月总销售额增加， 3-6 月则在下降。基于这样的每月销售额统计数据，才能方便地进入后续趋势分析步骤中。 那么应该如何去分析其他3个影响因素呢？上一节课我们提到过公式拆解法搭建我们的分析框架和方法，销售额 &#x3D; 订单量*单价 根据对各月销售额的分析，我们可以总结出：不同影响因素进行分组聚合操作时，有两个要点。 根据什么进行分组； 选择什么代表性的统计方法，进行聚合计算。 那么对于各月订单量、各月单价、各月各省订单量，应该根据什么进行分组，应该选择什么统计性数值呢？ 例如对不同班级、不同班级不同性别、不同班级不同性别是否带眼镜等等情况都是如何一一进行分组聚合的。 ​ 比如，不同班级不同性别的分组聚合方式是这样的： 不过单价的平均值可以反映出某一商品在一定时期内的平均价格，一定程度上可以体现普遍的价格数量。因此选择平均数作为单价的统计性指标。 1mask_data_clean.head(3) 123# 获取各月总订单量order_number = mask_data_clean.groupby(&#x27;月份&#x27;)[&#x27;订单量&#x27;].sum()order_number 不错，它同样能够体现出这个月所有订单量的变化情况，1-3 月数量上升，3-6 月数量下降。 接下来来看每月单价，找一下如何计算单价的平均值： 12345# 获取每月平均单价month_price = mask_data_clean.groupby(&#x27;月份&#x27;)[&#x27;单价&#x27;].mean()# 查看数据month_price 要用列表来包含两个用于分组的索引 12345# 获取各省各月总订单量month_order = mask_data_clean.groupby([&#x27;省&#x27;, &#x27;月份&#x27;])[&#x27;订单量&#x27;].sum()# 查看数据month_order 12345# 获取各省各月总订单量month_order_2 = mask_data_clean.groupby([&#x27;月份&#x27;, &#x27;省&#x27;])[&#x27;订单量&#x27;].sum()# 查看数据month_order_2 终端打印出的 Series 数据，它的外层索引是月份，内层是省份，因此从上往下，看到的是每个月不同省的总订单量数据。 通过 month_order，我们能大致看出某个省的总订单量随月份的变化情况； 而通过 month_order_2 ，则可以看出某个月时不同省份总订单量的变化情况。 折线分析，确定趋势首先还是来看每月总销售额，前面我们将它存储在变量 sales_income 中，怎么画出对应的折线图 123# 获取每月销售额总数sales_income = mask_data_clean.groupby(&#x27;月份&#x27;)[&#x27;销售额&#x27;].sum()sales_income 这是一个Series对象，行索引是月份，值是每月总销售额。因此可以直接用 pandas 的plot()方法画图。 12345# 导入matplotlib库的pyplot模块from matplotlib import pyplot as pltplt.rcParams[&quot;font.sans-serif&quot;]=[&quot;SimHei&quot;] #设置字体plt.rcParams[&quot;axes.unicode_minus&quot;]=False #该语句解决图像中的“-”负号的乱码问题sales_income.plot(kind = &#x27;line&#x27;, figsize = (7,7) ,title = (&#x27;画出各月总销售额的折线图&#x27;)) 直接使用前面的Series对象，就可以画出来一个以月份为横坐标，以单位数值为纵坐标，总销售额为数据点的折线图。 按理来说，画出各月总销售额的折线图之后，就可以继续去分析其统计值的变化趋势了。 但是下面我们会先把“各月订单量、单价、各省订单量”剩下 3 个折线图都画出来之后，再进入下一步的趋势分析。 因为这 4 个影响因素关系密切：订单量不变时，单价越高销售额也会越高；同理单价不变时，订单量越多销售额也会越高。 如果这些因素的变化趋势也呈现这样的某些共性，就可以综合起来进行分析，就更容易抓住关键性的影响因素，可以聚焦问题。 12# 画出各月总订单量的折线图order_number.plot(kind = &#x27;line&#x27;, figsize = (7, 7), title = &#x27;各月总订单量趋势图&#x27;) 可以得到以月份为横坐标，单位数值为纵坐标，平均单价为数据点的折线图，单位为元。 最后来看各省各月总订单量的变化趋势，它的特殊之处在于，需要通过多条折线图来直观体现出不同省份不同月份的区别。 前面我们将各省各月的统计数据存储在变量 month_order和 month_order_2中，它们是两个 Series 对象。 但是多条折线图需要基于 DataFrame 数据来画，因此我们需要使用 unstack() 方法将 Series 对象变为 DataFrame 对象。 12345# 将month_order1转换为DataFrame，存储在month_order_df中month_order_df = month_order.unstack()# 查看month_order1_df中的数据month_order_df 12# 根据month_order_df绘制多条折线图，标题为&#x27;各月各省总订单量趋势图&#x27;month_order_df.plot(kind = &#x27;line&#x27;, figsize = (7, 7), title = &#x27;各月各省总订单量趋势图&#x27;) 我们画出来的是各月各省总订单量趋势图，它以不同颜色线条表示不同月份，以省份为横坐标，以数值单位为纵坐标，以订单量数值为数据点形成的折线图。 12345# 将month_order_2转换为DataFrame，存储在month_order_2_df中month_order_2_df = month_order_2.unstack()# 根据month_order2_df绘制多条折线图，标题为&#x27;各省各月总订单量趋势图&#x27;month_order_2_df.plot(kind = &#x27;line&#x27;,figsize = (7, 7), title = &#x27;各省各月总订单量趋势图&#x27;) 现在我们已经画完了 4 个需要的折线图，接着就可以具体观察折线图，详细分析不同影响因素的变化趋势 观察折线图，有3个要点， ​ 一是整体的走势 ​ 二是走势的规律性 ​ 三是走势的波动 我们可以直接通过折线图的线条倾斜程度，看出走势波动的强烈程度，比如下图就是不同变化程度的体现. 基于这三个要点，可以让我们更加全面地描述折线图的趋势特征。接下来我们整体来看一看四个影响因素随月份变化时对应的折线图。 可以发现无论各月的总销售额、总订单量、平均单价，以及各省在各月的总订单量，变化趋势有很大的相似性： 1）在 1 月到 3 月的折线是随着时间增长而增加，整体呈增加趋势，其中 2 月到 3 月增长快速；3 月之后整体呈下降趋势，3 月到 4 月出现了“急跌”。 2）目前的折线中未出现多个类似形状的起伏波动，未体现出任何规律性。 3）而且图中只有一处波动起伏，在这个起伏的最高点，对应着 3 月的数据，此处为最大值。 本质上，趋势是由背后的原因推动的。看趋势，更得看背后的原因，而不是单纯的看着结果走势想当然。 因此接下来的时间，我们来分析防护服装厂各项影响因素的统计值都在“走下坡路”的原因，给总监一个“交代”。 原因剖析，聚焦问题 这里趋势变化非常明显，最大值（转折点）为 3 月，因此我们重点关注这个值，以其特殊性作为突破口。 根据订单量、单价的变化，我们可以知道，3 月之前，工厂的防护服装需求量和价格都增长猛烈，3 月之后却又出现大幅下降。 按理来说，防护服装属于医用防护品和日用生活品，不受季节、时间的影响。一般其需求源头比较稳定，物价也很稳定。 但是对比 1-3 月份总订单量的变化，其纵坐标的值是 0 到 2，但是单位是百万。因此是从 1 月份的万余盒，增长到 2 月份的 30 余万盒，突然涨到 3 月份 196 万余盒，变化迅猛。 另外通过折线图也能够发现趋势变化的强烈程度，比如 3 月到 4 月的订单量，就是一个“急跌”，订单量一下子缩水了 100 多万！ 因此认为，要想在两三个月内迅速改变防护服装的供需关系，应该是属于社会性问题的外部冲击。 与防护服装使用的历史一致，几乎每次大的普及推广都是受传染性疾病或空气污染等外部影响。 因此这里排除业务内部原因，比如偶发性降价促销活动带来的客流量上涨与衰退，以及工厂竞争能力降低带来的市场占有率从高到低等等内部问题。 因为这些情况都属于常规运营问题，造成的影响远不会如此剧烈。 实际上，从 2020 年 1 月底开始，国内就蔓延出了新冠的传染性疾病，到了 3 月份，疫情感染人数才逐渐得到控制。 当然我们还是要结合疫情的情况，进行材料的佐证，这样才能尽量合情合理的去解释所发生的现象。 疫情最严重的时期为 2 月份，2 月初电视中还经常出现药店防护服装断供的新闻，3 月中下旬开始，全国陆续开始复工，人群流动性增加的情况下，防护服装的需求也是达到了最高点。 而且我们也可以看到，各省的订单量变化中，以湖北省的变化最为强烈，在 2020年的新冠疫情中，湖北省是重灾区，全省 5927 万人口，是非常大的需求缺口。 据说我们的工厂整个 2-3 月都在加班加点进行生产，但是防护服装的价格与销量都还是只增不降，说明需求根本无法及时得到满足。 而到 3 月之后，疫情好转，全国各地陆续放松，尤其是不再要求必须在公众场合佩戴防护服装，人们对于防护服装的需求迅速回落，一直到 6 月销量和价格都仍在下落的过程中。 可以说，2020 年 1 月到 6 月，由于新冠疫情的影响，防护服装的供需关系发生了很大的波动变化，导致工厂防护服装的订单量、价格以及整体销售额也自然随之发生变化。 但如果直接给出结论，就只是空口无凭了，做数据分析就是要能够发掘和解释其背后的逻辑。 深入洞察，提出对策说到问题根源，其实还是一个供需关系，如果防护服装厂商在供需矛盾中不占优势，想要继续维持原来高价格高销量的情况几乎是不可能。 因为人们的购买标准，将从“能用”升级为性价比高、质量好、服务好等更复杂的行业竞争力问题上。 因此当疫情减少，刚性需求减少后，防护服装行业的市场竞争将会越发激烈。 1 月这段时间基本不属于疫情影响范围内，比较能够体现出日常情况下人们对于防护服装的需求。我们可以以此对比一下疫情前后，订单量和单价的情况： 如果这种状态下，6 月份防护服装厂是处于亏损，那么未来这段时间，防护服装厂将继续处于亏损状态。 众所周知，“比亚迪”作为一个汽车企业，由于这次生产转型，其在防护服装行业也占有了一席之地。因此，现在的情况是危机也是转机，是打开稳定市场的好机会。 基于这样的分析，跟总监提出两种不同的建议： 1)公司可以对防护服装厂进行改革，不过对于工厂的优势，改革的重点及规划，还有待进一步对产品、营销体系等情况的分析。 2)如果公司不对防护服装厂进行新的投入和改革，防护服装厂将会持续亏损，建议尽早对防护服装厂做转让处理。 当然，还有第三种方案，那就是基于国际局势考虑，目前南半球及欧美国家，由于气候及政策等原因，新冠疫情的危机是越演愈烈。预计对于疫情为加重趋势的国家，防护服装的需求量仍会比较高涨。 3)如果可以及时打开国际销售渠道，并维持相对较低的成本，工厂将仍能保持供需矛盾中的优势地位，维持高单价高销量的营收情况。 小结 我们说整个数据分析过程就是根据分析目的，用适当的分析方法及工具，对数据进行处理和分析，提取有价值的信息，其目的是总结出所研究对象的内在规律。 在实际工作中，数据分析能够帮助管理者进行判断和决策，以便制定适当的策略与采取相应的行动。因此掌握数据分析能力对于我们的工作会有很多的帮助。 数据展现 选对图表不同图表的适用场景 不同的图表一般会有不同的适用场景，我们将折线图、柱状图和饼图进行简单对比。 可以清晰地看到，折线图主要是呈现数据变化的趋势；柱状图让数值大小的比较更加明显；至于饼图，能够直观地显示各部分相对于整体的占比。 多条折线图兼具了折线图和柱状图的优势，能够比较多组数据在同一个维度上的趋势，比如上一节课绘制的“各省各月订单量趋势图”就是各个省份的订单量在同一个维度“月”进行的比较。 明确数据展现的目标思路1各月的总销售额、总订单量、平均单价以及各省在各月总订单量，都出现了1-3月迅猛增长呈增长趋势，3-6月呈下降趋势的情况。 使用折线图呈现总销售额、总订单量以及平均单价在1-6月之间的变化趋势是合理的，但是我们仔细观察这三张图就会发现： 观察 y 轴，不能很快知道数据的数量级和单位； 图中折线颜色均是默认的蓝色，放在一起对比不容易区分； 图中折线对应的数据标记点不够明显，无法很好地与坐标轴上的值进行对应； 此外，图中的图表标题、坐标轴刻度、坐标轴标题等字体都太小了，看不清楚。 所以，我们重点调整这几张图的坐标轴标题、折线以及数据标记点样式，并调整图表标题、坐标轴刻度、坐标轴标题等字体大小。 用多条折线图呈现各省在各月总订单量的变化趋势是合理的，但同样也存在一些问题： 观察 y 轴，不能很快知道数据的数量级和单位； 图中折线对应的数据标记点不够明显，无法很好地与坐标轴上的值进行对应； 此外，图中的图表标题、坐标轴刻度、坐标轴标题等字体都太小了，看不清楚。 因此，我们重点调整多条折线图的坐标轴标题、折线以及数据标记点样式，并调整图表标题、坐标轴刻度、坐标轴标题重点调整的字体大小。 思路2通过对比 1 月和 6 月的订单量、平均单价，发现 6 月的订单量虽然比日常（1月）要高，但是平均单价已经降至比 1 月还低。 使用折线图呈现订单量、平均单价在 1 月和 6 月的数值比较是不合理的，建议用柱状图。除此之外： 图中 y 轴均缺少标题，不能很快得知它们的数量级； 对 1 月和 6 月的数值比较，但是图中没有数值，而是添加了额外的标注； 强调 1 月和 6 月进行对比，但是颜色没有做专门的区分。 此外，图中的图表标题、坐标轴刻度、坐标轴标题等字体都太小了，看不清楚。 因此，我们绘制柱状图，并重点关注该柱状图的坐标轴标题、数据标签以及柱子样式，并调整图表标题、坐标轴刻度、坐标轴标题重点调整的字体大小。 绘制各月总订单量趋势图12345678# 导入pandas库import pandas as pd# 读取清洗好的数据mask_data_clean = pd.read_csv(&#x27;mask_data_clean.csv&#x27;, encoding=&#x27;utf-8&#x27;)# 获取各月总订单量order_number = mask_data_clean.groupby(&#x27;月份&#x27;)[&#x27;订单量&#x27;].sum()order_number x 坐标值是月份的信息，y 坐标值是每个月对应的口罩订单量合计值。 我们发现折线图中每一个点的 x 坐标值就对应着 order_number 对象左边的索引，而折线图中每一个点的 y 坐标值就对应着 order_number 对象右边的数据。下面就以两个点为例： 可以用 Series 对象的 index 和 values 属性分别获取左边的索引和右边的数据。 首先看一下 index 属性 123order_number.index# Int64Index([1, 2, 3, 4, 5, 6], dtype=&#x27;int64&#x27;, name=&#x27;月份&#x27;) 这里返回的是一个 index 对象，里面存储了月份信息。 我们再来看一下 values 属性 123order_number.values# array([ 13852., 389319., 1961480., 546276., 158188., 22222.]) 确定了 x&#x2F;y 坐标值，我们就调用折线图绘图函数 plt.plot() 开始绘图。 12345678x = order_number.indexy = order_number.values# 生成画布，并设置画布的大小plt.figure(figsize=(6, 6))# 绘制折线图plt.plot(x, y) 绘图函数 plt.plot()本身是很强大的，通过调整其中的参数还可以进一步调整折线的样式 基于刚才确定的目标，我们重点调整坐标轴标题、折线以及数据标记点样式，并调整图表标题、坐标轴刻度、坐标轴标题的字体大小。 先看线条的宽度和颜色，需要用到的参数分别是 linewidth 和 color。 参数 linewidth 可以设置线条的宽度，常见为数值类型。 参数 color 可以设置线条的的颜色。下图为 matplotlib 库支持的颜色，只需要向 color 传入颜色块旁边对应的英文单词即可，常见为字符串类型。 设置线条的宽度为3：linewidth=3，颜色为红色：color=&#39;r&#39;（’red’可以简写为’r’） 1234# 生成画布，并设置画布的大小plt.figure(figsize=(6, 6))# 绘制折线图，只调整线条的样式plt.plot(x, y, linewidth=3, color=&#x27;r&#x27;) 可以看到调整参数 linewidth 和 color 后，线条宽度变宽，并且变成红色。 接着调整数据标记点的样式，需要用到的参数是 marker、markerfacecolor 和 markersize。 参数 marker 可以设置数据标记点的形状，有点、圆、加号等，常见为字符串类型，更多的形状 参数 markersize 和 markerfacecolor 用来设置数据标记点的大小和填充颜色。markersize 的设置方法与 linewidth 参数相同，而 markerfacecolor 参数的设置方法与 color参数一致。 1234# 生成画布，并设置画布的大小plt.figure(figsize=(6, 6))# 绘制折线图，只调整数据标记点的样式plt.plot(x, y, linewidth=3, color=&#x27;r&#x27;, marker=&#x27;o&#x27;,markersize=10,markerfacecolor=&#x27;w&#x27;) 可以看到调整 marker、markersize 以及 markerfacecolor 之后，数据标记点形状变成圆形，尺寸更大，填充颜色为白色。 调整折线图中图表标题、坐标轴刻度、坐标轴标题的字体样式 1234567891011121314151617# 生成画布，并设置画布的大小plt.figure(figsize=(6, 6))# 设置 x/y 坐标值x = order_number.indexy = order_number.values# 绘制折线图，并调整线条、标记点的样式plt.plot(x, y, linewidth=3, color=&#x27;r&#x27;, marker=&#x27;o&#x27;, markerfacecolor=&#x27;w&#x27;, markersize=10)# 设置图表标题名及字体大小plt.title(&#x27;各月总订单量趋势图&#x27;, fontsize=20)# 设置坐标轴的刻度字体大小plt.xticks(fontsize=12)plt.yticks(fontsize=12)# 设置坐标轴的标题名及字体大小plt.xlabel(&#x27;月份&#x27;, fontsize=15)plt.ylabel(&#x27;各月总订单量（百万）&#x27;, fontsize=15)# 保存画布plt.savefig(&#x27;各月总订单量趋势图.png&#x27;) 小结 绘制各省各月订单量趋势图重点调整多条折线图的坐标轴标题、折线以及数据标记点样式，并调整图表标题、坐标轴刻度、坐标轴标题的字体大小。 12345678910111213141516171819# 调整画布大小plt.figure(figsize=(6, 6))# 设置 x/y 坐标值x = month_order_df.indexy = month_order_df.values# 绘制折线图，并调整线条、标记点的样式plt.plot(x, y, linewidth=2, marker=&#x27;o&#x27;, markerfacecolor=&#x27;w&#x27;, markersize=10)# 设置图表标题名及字体大小plt.title(&#x27;各省各月口罩订单量变化折线图&#x27;, fontsize=20)# 设置坐标轴的刻度字体大小plt.xticks(fontsize=12)plt.yticks(fontsize=12)# 设置坐标轴的标题名及字体大小plt.xlabel(&#x27;月份&#x27;, fontsize=15)plt.ylabel(&#x27;各省各月口罩订单量（百万）&#x27;, fontsize=15)# 添加图例plt.legend([&#x27;其它&#x27;,&#x27;广东&#x27;,&#x27;江苏&#x27;,&#x27;河南&#x27;,&#x27;湖北&#x27;,&#x27;湖南&#x27;])# 保存画布plt.savefig(&#x27;各省各月口罩订单量变化折线图.png&#x27;) 小结 绘制各月平均单价分布图“各月平均单价趋势图”和“各月平均单价分布图”拥有相同的数据“单价”以及相同的时间维度“月”，因此 “各月平均单价趋势图”的 x&#x2F;y 坐标值同样可以用在“各月平均单价柱状图”中。 12345678# 求得各月平均单价数据，并将其赋值给变量 mask_pricemask_price = mask_data_clean.groupby(&#x27;月份&#x27;)[&#x27;单价&#x27;].mean()# 查看mask_pricemask_price# 设置 x 坐标值x = mask_price.index# 设置 y 坐标值y = mask_price.values 确定好 x&#x2F;y 坐标值，接下来调用柱状图绘图函数 plt.bar()开始绘图，与绘图函数 plt.plot()相似，plt.bar()也可以通过调整其中的参数去改变柱子的样式 基于刚才确定的目标，我们重点关注该柱状图的坐标轴标题、数据标签以及柱子样式，并调整图表标题、坐标轴刻度、坐标轴标题的字体大小。 先调整柱子的颜色和宽度，用到的参数分别是 color 和 width。这里的color 和折线图中的color 略有不同，当设置一种颜色时，传入值的类型为字符串；设置多种颜色时，传入值的类型为列表。width 则需要传入(0, 1]区间 (大于 0，小于等于 1) 内的浮点数，数值越大表示柱子的宽度越宽；当 width 的值为 1 时，柱子之间的间隙就为 0。 1234# 生成画布，并设置画布的大小plt.figure(figsize=(6, 6))# 绘制柱状图，设置柱子的颜色为绿色，宽度为 0.6plt.bar(x, height=y, color=&#x27;g&#x27;, width=0.6) 可以看到添加了参数 color 和 width 之后，柱子宽度变窄，并且变成绿色。 需要注意，柱的颜色是按照列表中颜色字符串的顺序设置的。 但是这个绿色太深了，只能用“丑”来形容，得想办法优化一下。 参数 alpha 可以设置柱子颜色的透明度，需要传入(0, 1]区间内的浮点数，数值越小，表示柱子颜色越浅；相反，则越深。适当地调整颜色深浅，可以提升视觉舒适度。 综上，我们设置柱子颜色透明度为 60%：alpha=6；调整 1 月份和 6 月份的柱子颜色分别为红色、蓝色，其他柱子依然是绿色：color=[&#39;r&#39;, &#39;g&#39;, &#39;g&#39;, &#39;g&#39;, &#39;g&#39;, &#39;b&#39;]。 12345# 生成画布，并设置画布的大小plt.figure(figsize=(6, 6))# 绘制柱状图，并调整柱子的颜色和透明度plt.bar(x, height=y, color=[&#x27;r&#x27;, &#x27;g&#x27;, &#x27;g&#x27;,&#x27;g&#x27;, &#x27;g&#x27;, &#x27;b&#x27;], width=0.6, alpha=0.6) 可以看到，柱子颜色变浅了，而且1 月份和 6 月份的柱子颜色分别变成红色、蓝色。 小结 报告制式 12345## 六、数据分析### 6.1变化趋势 销售额、订单量、单价变化趋势#### 1. 各月“销售额”： “销售额”2～3月份急剧上升、3～4月急剧下降，在3月份达到顶峰。 12#### 2.各月“订单量”： “订单量”表现与“销售额”月表现趋势相同。2～3月份急剧上升、3～4月急下降。在3月份达到顶峰。 1与疫情前对比，6月份比1月份的订单总量略高（1月份的防护服装订单总量为13852盒，6月份22222盒） 12#### 3. 各月“单价”： 从变化趋势来看，“单价”表现与“销售额”、“订单量”表现趋势相同。2～3月份急剧上升、3～4月急剧下降。在3月份达到顶峰。 1与疫情前对比，6月份比1月份的防护服装单价更低（1月份的防护服装单价为39元/盒，6月份30元/盒）。 12345## 6.2原因分析/内因外因1. 销售额、订单量、单价波动情况“销售额”波动：2～3月份急剧上升、3～4月急剧下降。在3月份达到顶峰。“单价”波动：2～3月份急剧上升、3～4月急剧下降。在3月份达到顶峰。“订单量”波动：2～3月份急剧上升、3～4月急剧下降。3月份达到顶峰。 1“各省份订单量”波动：各客户之间的变化趋势相同，并且我们发现湖北省的防护服装订单量显著大于其他省份，湖北省为我们的“大客户”，并且“大客户”的订单量也在大幅降低 12. 疫情是在1-3月份呈上升、3-6月份呈下降，疫情与销售额、订单量、单价变化趋势表现一致。与此同时“大客户“群体也同样是疫情期间的影响重灾地区。因此，过往在3月份的明显波动的盈利状况主要与疫情有关系。 图片来自网络，数据与国家卫健委官网一致 https://voice.baidu.com/act/newpneumonia/newpneumonia/?from=osari_aladin_banner 13. 与1月（日常情况）对比可知，6月的单价已经降到比较低的水平，订单量相对日常情况略高。由于疫情已经趋于稳定，之后订单量与单价不会再继续同时升高，那么6月已经亏损的情况下，之后的一段时间仍会继续亏损。 撰写数据分析报告撰写数据分析报告的是为了将分析结果、建议以及其他有价值的信息传递给读者。对于“口罩厂”项目来说，读者是总监，我们要让总监正确地理解结果和建议，并做出有针对性的决策。 数据分析报告的形式先来看看数据分析报告的形式，其实不限于文档、演示文稿以及表格。但是在不同的场景下，选对形式还是很关键的。 下图是不同形式报告的优劣对比，你可以根据自己的需求选择合适的形式。 数据分析报告的结构再来看数据分析报告的结构，一般会采用总分总结构，包括：背景、目的、分析思路、分析正文、结论及建议、附录等。 1）背景：阐述进行数据分析的原因、意义，以及其他相关信息，比如公司现阶段的经营情况。 2）目的：这次分析要解决什么问题，达到何种目的。有时会将背景和目的放在一起写。 3）分析思路：用到了什么分析方法，得到的分析框架是什么。 4）分析正文是报告的主体部分，包含所有的数据事实和观点，通过数据图表和文字呈现，一般包括三个 部分：第一步.数据来源：解释数据的来源，并展示数据的基本情况。第二步.数据处理：进行了哪些数据处理操作以及处理的结果是什么。第三步.数据分析：以图文结合的方式展示分析过程和结果，并能证明分析过程合理，分析结果能够应用于实际的工作场景。 5）结论及建议：以综述性文字展现数据分析结果，并结合公司的具体业务或问题给出建议。 6）附录：提供正文中涉及到的，但是未详细阐述的资料，一般包括名词解释、源数据以及分析代码等，为整个分析报告提供补充说明。 项目回顾1）背景跟着项目一路走来，你应该再熟悉不过了：公司有一家小型口罩工厂，在今年 6 月底开始处于亏损状态。 2）目标对历史经营数据进行分析，找到亏损原因，并结合公司实际情况提供对应的解决策略。 3）分析思路借助公式拆解法，推演出影响口罩厂利润的几个因素以及分析的维度。 4）分析正文 基于分析框架向公司数据部门提交需求，拿到的数据基本符合需求，但也存在一些问题，比如一些数据是脏数据，一些数据则用不到，还有一些数据不是目标格式。 针对上述存在的问题，进行了数据清洗、数据整理、分组聚合以及描述性统计分析等操作。 整理完数据后，根据销售额、订单量、口罩单价、订单来源省份的影响因素以及月的时间维度进行分析，并通过作图查看各个数据的对比和趋势，最终发现数据变化的规律和原因。 除了分析某厂内部的数据，还结合外部环境数据去佐证我们的结论。 5）结论及建议最后，总结数据变化的规律和原因，并结合口罩厂数据和外部环境数据，从避免亏损和追求盈利两个方向给出建议。 6）附录在分析报告中没有难以理解的名词，整个过程主要用 Python 对数据进行了分析，所以附上原始数据和分析代码。 报告制式 12345678910### 七、结论及建议## 【结论】 结论1：防护服装厂的“销售额”在1-3月份呈上升态势，3-6月份呈下降态势，并且在2-3月份急剧上升，3-4月份急剧下降。“订单量”、“单价”都表现出同样的变化情况。 结论2：疫情是影响防护服装厂销售额、订单量、单价在2-3月份、3-4月份出现急剧上升、急剧下降的现象的原因。 结论3：根据疫情逐渐稳定，防护服装需求下降的情况，可以推断防护服装厂6月份之后还将持续亏损。## 【建议】 建议1：如果公司不对防护服装厂新投入和改革，防护服装厂会持续亏损，建议尽早对防护服装厂进行转让处理。 建议2：如果公司对防护服装厂新投入和改革，那需要进一步分析产品情况、营销体系等因素对于日常营销的影响，把握住改革重点。 建议3：结合国外的疫情发展，可考虑打开疫情重灾国家的销售渠道，以便保持高单价高销量的营收模式。 总结","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"思路","slug":"思路","permalink":"https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"},{"name":"模板","slug":"模板","permalink":"https://www.yiuhangblog.com/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"报告","slug":"报告","permalink":"https://www.yiuhangblog.com/tags/%E6%8A%A5%E5%91%8A/"}],"author":"Yiuhang Chan"},{"title":"FineBI案例","slug":"20200712FineBI案例","date":"2020-07-12T05:45:23.000Z","updated":"2024-02-28T10:49:52.000Z","comments":true,"path":"2020/07/12/20200712FineBI案例/","permalink":"https://www.yiuhangblog.com/2020/07/12/20200712FineBI%E6%A1%88%E4%BE%8B/","excerpt":"FineBI 简要案例","text":"案例 1 营业额问题分析案例背景作为数据分析师，面对某公司8月营业额的问题，主要任务是识别问题并提出解决方案。重点关注两个方面： 商品进货预测: 分析销售额最高的商品以预测热门商品，以便进行有效的库存管理。 通过不同商品类别的销售额占比分析，优化货架空间分配，提高销售效率。 分析8月毛利额下滑原因: 使用毛利率衡量公司盈利能力，分析8月毛利额下滑原因。 发现湖南省虽销售额高，但毛利率低，进一步分析揭示成本额较高。 分析思路 商品进货预测: 确定销售额最大的前10件产品，预测未来进货需求。 毛利额下滑分析: 分析8月毛利额较低的省份、城市、门店和产品，寻找原因。 关注指标 销售额和毛利额（销售额 - 成本额） 毛利率：衡量公司盈利能力的关键指标，受时间、地区、商品等因素影响。 毛利率计算公式：毛利率 &#x3D; (毛利额 &#x2F; 销售额) × 100% FineBI中毛利率计算：SUM_agg(毛利额) &#x2F; SUM_agg(销售额) 注意 尽管8月的营业额出现问题，但原因可能不仅仅局限于8月。 需要考虑部分商品可能存在季节性变化，这也可能是影响因素之一。 单价并不是决定营收的关键因素 分析报告实现步骤上传数据表获取相关数据，进行初步整理，寻找异常值。 由于表中存在四万条数据，因此存在空值影响不大。 挑选票据号数量最大的，过滤筛选查看其值，可以发现同一时间点同一票据下存在多个数量相同商品相同类似批次销售的数据，对此可以进行分析，根据自身业务与同事沟通是否存在数据本身的重复，还是正常销售客户进货行为，还是存在涉嫌黑产的行为。若是重复则进行去重，正常则不作处理，若是其它行为则不是数据分析的范畴了。 数据处理对数据进行清洗、整理，确保数据准确性。 根据上述的初步数据整理，假设是正常销售行为，因此本案例不作数据处理。 添加毛利额 组件交互通过交互式组件展示分析结果，增强报告的可读性和互动性。 新增销售额排名分组表 拖动需要的表头维度商品名称，指标数量，销售额和毛利额到分组表，过滤维度数量最大为10 降序排列销售额，即可得到完整处理后的销售额最大的前10件产品 随后在客制化如颜色，数字显示格式后，重命名该组件为销售额最大的10件商品以作区分后新建一个新组件 拖动维度日期(年月日)，两个指标毛利额，然后设定日期为年月格式进行汇总 新增毛利额环比增长率 新增环比增长率 随后重命名以示区分，即可完成毛利额环比增长率的分组表 为了不影响源数据，复制一份新的毛利额环比增长率的分组表然后修改为自定义图表 通过修改毛利额为折线图，环比增长率的直轴为右侧对两组数据的可视化进行分割展示 按业务需求客制化如颜色，命名，是否加标签即可 新增销售品类占比饼图 拖动维度商品类别，指标销售额，然后更改指标为占比 切换到饼图，然后添加标签即可 对8月毛利额较低的维度钻取分析下滑原因 添加毛利率计算公式 添加城市与省份的地理角色，然后拖动城市到省份进行钻取 继续添加门店名称和商品名称到钻取目录，根据从属关系由上自下排列 将拖动维度钻取目录省份,城市，拖动指标毛利率，毛利额，销售额，成本额，升序毛利率查看省份最低的是哪一个 点击最低毛利率的湖南省右侧的箭头进行多次钻取，查看受影响的门店 最后钻取该门店的商品可以发现德芙巧克力处于亏本状态 添加到仪表板将分析结果整合到仪表板中，方便管理层进行决策参考。 拖动先前制作的所有组件到仪表盘中 添加过滤组件年月日并拖动到仪表盘中，然后对该仪表盘进行设置为当前数据的日期范围日期(年月日) 随后在生成的过滤组件中对日期进行设置即可，修改受影响的组件可以通过重新编辑过滤组件即可 进行分析通过之前分析可以发现八月份环比存在异常，因此需要专门分析八月份的门店营收情况 根据之前钻取的结果，分别把毛利率异常的维度筛选下来，做成折线图可以发现在八月十七号出现异常 再对仪表盘组件进行重新编辑和分析时，我们观察到一个显著的现象：8月17日，即中国的七夕节当天，德芙巧克力的销售额出现异常波动，销售额显著增加但毛利额异常低下。鉴于七夕节在现代被广泛认为是情侣之间表达爱意的节日，巧克力作为爱情的象征，在这一天的销售激增与节日背景高度相关。因此，在这种情况下，运营团队需要深入了解公司是否实施了特定的营销活动，例如会员优惠、积分折扣等。 若确认存在此类营销策略，接下来的重点应是评估这些活动是否受到了不正当的利用，比如黑灰产用户的滥用或是门店员工的内部舞弊行为。这些风险因素的识别和管理是风控部门职责范围内的关键事项。因此，建议风控部门对这一异常数据进行详细分析，以确保企业运营的安全和效率。 案例 2 旅程项目分析案例背景某初创项目咨询公司，发现差旅费过高的问题，需要给出差旅费用改善方案 已知数据表报销明细，机票全价，项目列表和住宿标准，对他们汇总对旅程价格进行分析，基于结果发现问题和给出决策建议 分析报告实现步骤数据处理首先根据行程作为主键对表报销明细和机票全价就行左合并 随后对合并后的表与项目列表根据项目编号继续左合并 最后类似的，根据住宿地继续左合并住宿标准 由于机票价格存在季节性，因此需要计算机票折扣，则新增公式列机票折扣 住宿存在预算标准限制，因此需要计算住宿超标率，新增公式列住宿超标率 组件交互月度差旅趋势分析添加组件，作为月度差旅趋势分析，同时添加是否计费帮助进行占比分析 费用种类占比添加组件，对费用种类占比进行可视化 计费项目排名添加分区柱形图，转化项目编号为维度，转化其区间分组为相同值为一组，使非计费项目的颜色为深色，创建非计费项目排名 非计费项目差旅费占比变化趋势过滤金额为非计费项目命名为非计费项目金额，创建新的计算规则为SUM_AGG($&#123;非计费项目金额&#125;)/SUM_AGG($&#123;金额&#125;)非计费项目差旅费占比，添加进组件分区折线图，得出占比变化趋势 机票折扣分布转化机票折扣为维度，过滤费用种类为机票。设置区间分组为三组，1-7折，8-9折和全价，创建组件分区柱形图，根据日期与次数进行分类 高额订票人员表复制之前创建的机票折扣分布，继承其机票折扣的过滤条件，对机票折扣进行二次过滤，只选择8-9折和全价区间。添加发起人姓名作为第二个维度，删除日期。添加组件分组表，对次数进行降序得出高额订票人员排名。 住宿超标率构成复制住宿超标率重命名为住宿超标分组并转化为维度，设置区间分组三组为不超标，超20%和超50%，设置过滤费用种类为住宿，添加组件饼图 超标率地区分布对住宿天数和住宿超标率在散点图进行四象限创建 添加到仪表板","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"FineBI","slug":"FineBI","permalink":"https://www.yiuhangblog.com/tags/FineBI/"},{"name":"数据处理","slug":"数据处理","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"案例","slug":"案例","permalink":"https://www.yiuhangblog.com/tags/%E6%A1%88%E4%BE%8B/"}],"author":"Yiuhang Chan"},{"title":"FineBI组件","slug":"20200626FineBI组件","date":"2020-06-26T05:45:23.000Z","updated":"2024-02-28T10:49:49.000Z","comments":true,"path":"2020/06/26/20200626FineBI组件/","permalink":"https://www.yiuhangblog.com/2020/06/26/20200626FineBI%E7%BB%84%E4%BB%B6/","excerpt":"FineBI 组件用法","text":"组件概述FineBI 可以为客户实现数据可视化，进行可视化分析，可视化的展现结果就是一张张的仪表板，而仪表板是由不同类型的组件构成的，本节即为你介绍如何制作可视化组件。 FineBI 用于数据分析的可视化组件包括表格、图表、时间过滤组件、文本组件等等，能够提供给你更丰富的选择。 组件编辑FineBI 中可以制作图表和表格进行可视化展示，通过将数据字段拖入分析区域实现图表或者表格的创建。 组件编辑界面的各区域功能如下图所示： 图表组件制作大致使用流程:1：在【组件管理栏】创建组件2：将【待分析区】中的字段拖入【分析区域字段框】或【图表生成区】3：在【图表配置区】设置需要的图表类型和相关属性和样式4：再根据需求在【组件全局过滤】进行设置 门店销售数据统计 销售日期 店风格 店名 店性质 品类描述 品牌描述 所属大区 所属小区 毛利 销售额 30&#x2F;09&#x2F;2017 时尚馆 成都店 自有店 女士轻便服装 WHO.A.U 中西区 西南 209 1,046 30&#x2F;09&#x2F;2017 时尚馆 成都店 自有店 女士轻便服装 WHO.A.U 中西区 西南 673 3,366 30&#x2F;09&#x2F;2017 生活馆 北京一期（百货） 自有店 女士上班服装 X.ZHINING 北方区 华北 124 3,979 30&#x2F;09&#x2F;2017 时尚馆 重庆店 自有店 女士上班服装 WHO.A.U 中西区 西南 894 5,960 30&#x2F;09&#x2F;2017 时尚馆 重庆店 自有店 女士上班服装 WHO.A.U 中西区 西南 151 1,008 30&#x2F;09&#x2F;2017 生活馆 上宝山店 自有店 女士成熟服装 O.C.T.MAMI(十月妈咪) 东南区 上海 136 4,863 30&#x2F;09&#x2F;2017 生活馆 上宝山店 自有店 女士成熟服装 O.C.T.MAMI(十月妈咪) 东南区 上海 337 1,203 30&#x2F;09&#x2F;2017 生活馆 天新百店 自有店 女士內衣 O.C.T.MAMI(十月妈咪) 北方区 华北 924 3,556 30&#x2F;09&#x2F;2017 生活馆 上浦建店 自有店 女士內衣 O.C.T.MAMI(十月妈咪) 东南区 上海 753 2,789 30&#x2F;09&#x2F;2017 生活馆 武汉百货 自有店 女士內衣 O.C.T.MAMI(十月妈咪) 中西区 华中 164 5,679 30&#x2F;09&#x2F;2017 时尚馆 武徐东店 管理店 女士內衣 O.C.T.MAMI(十月妈咪) 中西区 华中 481 1,767 30&#x2F;09&#x2F;2017 生活馆 北京一期（百货） 自有店 女士饰物 ZIPPO(之宝) 北方区 华北 558 1,758 30&#x2F;09&#x2F;2017 生活馆 北京二期（百货） 自有店 女士手袋及皮件 LESPORTSAC 北方区 华北 132 5,399 30&#x2F;09&#x2F;2017 生活馆 天新百店 自有店 女士皮鞋 HANG TEN 北方区 华北 461 1,847 30&#x2F;09&#x2F;2017 生活馆 北京一期（百货） 自有店 女士皮鞋 HANG TEN 北方区 华北 381 1,376 30&#x2F;09&#x2F;2017 生活馆 北京二期（百货） 自有店 女士皮鞋 HANG TEN 北方区 华北 337 1,485 30&#x2F;09&#x2F;2017 时尚馆 北彩旋店. 自有店 女士皮鞋 HANG TEN 北方区 华北 126 4,648 30&#x2F;09&#x2F;2017 生活馆 北利莹百貨 自有店 女士皮鞋 HANG TEN 北方区 华北 173 6,883 步骤: 创建分析主题 上传数据表 数据处理 点击【组件】进入编辑界面,一个分析主题可以添加多个组件，如下图所示： 选择「堆积柱形图」，将待分析区域字段「店性质」拖入横轴栏，将「毛利」和「销售额」拖入纵轴栏，就生成了一张图表。如下图所示： 设置图形属性和组件样式，对组件进行美化。例如自定义设置图表配色，或者更改柱状图圆角度数。 需要进行计算或者添加交互功能的根据具体数据表不同需求再进行， 如下图所示： 自定义图表自定义图表示例品类经营分析 销售日期 毛利额 商品单价 销售金额 销售数量 2015-01-01 2.4 0.5 3 6 2015-01-01 6.46 5.6 8.07 0.96 2015-01-01 2 3 2.5 1 2015-01-01 1.08 4 4 1 2015-01-01 1.83 6.7 6.5 1 2015-01-01 1 1.6 1.25 0.78 2015-01-01 3.08 9.6 3.85 0.4 2015-01-01 4.4 5.5 5.5 1 2015-01-01 10.03 19.6 12.54 0.64 2015-01-01 2.4 3 3 1 2015-01-01 0.69 19.8 2.7 0.2 2015-01-01 6.32 7.9 7.9 1 2015-01-01 6.32 7.9 7.9 1 2015-01-01 1.46 2.58 1.83 0.71 2015-01-01 0.91 1.8 1.14 0.64 2015-01-01 6.62 89.8 8.28 0.13 2015-01-01 1.34 2.56 1.68 0.66 2015-01-01 3.08 16 6.14 0.38 用户希望一个图表组件上，有多种图表类型。如下图所示： 自定义图表制作 图表类型下选择【自定义图表】，将【销售日期】字段拖入横轴，【毛利额】、【商品单价】、【销售金额】字段拖入纵轴。如下图所示： 鼠标悬浮在【毛利额】字段上，点击右下角倒三角，点击【设置值轴】，设置最小值为【0】，最大值为【4000】。如下图所示： 【图形属性】下点击【全部】，将【指标名称】字段拖入到【颜色】栏中。如下图所示： 在图形属性下，点开【销售金额】字段，图形选择【线】，设置成为 双柱形图-折线图 。如下图所示 分区柱形图分区柱形图示例分区柱形图为并列展示维度下各个分类指标的柱形图，能清晰的比较出多种维度下不同指标的数量差距，但是当维度数据较多时，图表的可读性就比较差。效果如下图所示： 销售明细表 销售日期 产品归属业务部 产品名称 产品品规 产品品类 客户编码 客户名称 区域 生产厂家 销售单位 销售类型 销售人员 不含税销售单价 不含税销售额 城建税、教育费附加、地方教育附加 出库单编码 单位生产成本 发票号 发票金额 发票增值税额 发票增值税率 含税销售单价 含税销售额 人力成本 物流编号 现金折扣 销售数量 总成本 2019-01-05 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 8.62 86,206,896.55 775,812.41 1,234,567 4.58 123,456 86,206,896.55 13,793,103.45 0.16 10 100,000,000 12,500,000 12,345,678 2,586,206.9 10,000,000 45,800,000 2019-01-30 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 发货 b 8.62 129,310,344.83 1,163,718.62 1,234,568 4.58 123,457 129,310,344.83 20,689,655.17 0.16 10 150,000,000 18,750,000 12,345,679 3,879,310.34 15,000,000 68,700,000 2019-02-10 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 8.62 103,448,275.86 930,974.9 1,234,569 4.58 123,458 103,448,275.86 16,551,724.14 0.16 10 120,000,000 15,000,000 12,345,680 3,103,448.28 12,000,000 54,960,000 2019-02-20 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 8.62 112,068,965.52 1,008,556.14 1,234,570 4.58 123,459 112,068,965.52 17,931,034.48 0.16 10 130,000,000 16,250,000 12,345,681 3,362,068.97 13,000,000 59,540,000 2019-03-08 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 退货 b 8.62 -172,413.79 -1,551.62 1,234,571 4.58 123,460 -172,413.79 -27,586.21 0.16 10 -200,000 -25,000 12,345,682 -5,172.41 -20,000 -91,600 2019-04-06 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 发货 b 8.85 115,044,247.79 865,866.27 1,234,572 4.58 123,461 115,044,247.79 14,955,752.21 0.13 10 130,000,000 16,681,415.93 12,345,683 3,451,327.43 13,000,000 59,540,000 2019-05-05 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司2 盒 发货 a 8.85 79,646,017.7 571,365.88 1,234,573 4.78 123,462 79,646,017.7 10,353,982.3 0.13 10 90,000,000 11,548,672.57 12,345,684 2,389,380.53 9,000,000 43,020,000 2019-06-15 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司2 盒 发货 b 8.85 61,946,902.65 444,395.68 1,234,574 4.78 123,463 61,946,902.65 8,053,097.35 0.13 10 70,000,000 8,982,300.88 12,345,685 1,858,407.08 7,000,000 33,460,000 2019-01-03 非处方药 感冒药2 20袋 呼吸类 AA001 A 京津 子公司3 盒 发货 a 15.52 3,103,448.28 24,411.81 1,234,575 9.16 123,464 3,103,448.28 496,551.72 0.16 18 3,600,000 450,000 12,345,686 93,103.45 200,000 1,832,000 2019-01-08 非处方药 感冒药2 20袋 呼吸类 AA001 A 京津 子公司3 盒 发货 b 15.52 7,758,620.69 61,029.52 1,234,576 9.16 123,465 7,758,620.69 1,241,379.31 0.16 18 9,000,000 1,125,000 12,345,687 232,758.62 500,000 4,580,000 2019-01-10 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 139,655,172.41 1,098,531.31 1,234,577 9.16 123,466 139,655,172.41 22,344,827.59 0.16 18 162,000,000 20,250,000 12,345,688 4,189,655.17 9,000,000 82,440,000 2019-01-19 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 155,172,413.79 1,220,590.34 1,234,578 9.16 123,467 155,172,413.79 24,827,586.21 0.16 18 180,000,000 22,500,000 12,345,689 4,655,172.41 10,000,000 91,600,000 2019-01-31 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 232,758,620.69 1,830,885.52 1,234,579 9.16 123,468 232,758,620.69 37,241,379.31 0.16 18 270,000,000 33,750,000 12,345,690 6,982,758.62 15,000,000 137,400,000 2019-02-10 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 201,724,137.93 1,586,767.45 1,234,580 9.16 123,469 201,724,137.93 32,275,862.07 0.16 18 234,000,000 29,250,000 12,345,691 6,051,724.14 13,000,000 119,080,000 2019-03-10 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 139,655,172.41 1,098,531.31 1,234,581 9.16 123,470 139,655,172.41 22,344,827.59 0.16 18 162,000,000 20,250,000 12,345,692 4,189,655.17 9,000,000 82,440,000 2019-04-15 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.93 127,433,628.32 844,796.6 1,234,582 9.16 123,471 127,433,628.32 16,566,371.68 0.13 18 144,000,000 18,477,876.11 12,345,693 3,823,008.85 8,000,000 73,280,000 2019-05-12 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.93 79,646,017.7 527,997.88 1,234,583 9.16 123,472 79,646,017.7 10,353,982.3 0.13 18 90,000,000 11,548,672.57 12,345,694 2,389,380.53 5,000,000 45,800,000 2019-06-15 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.93 71,681,415.93 475,198.09 1,234,584 9.16 123,473 71,681,415.93 9,318,584.07 0.13 18 81,000,000 10,393,805.31 12,345,695 2,150,442.48 4,500,000 41,220,000 分区柱形图制作 在图表类型下选择【分区柱形图】，将【品牌编号】、【销售日期】字段拖入到横轴中，【销售额】、【毛利】字段拖入到纵轴中。如下图所示： 点击销售日期(年月日)字段下拉框，选择年月，完成后的图表如下所示： 设置分区柱形图样式 将【指标名称】字段拖入颜色栏，点击颜色栏，设置柱形显示颜色，如下图所示： 点击【大小栏】，调整柱形的柱宽和大小，如下图所示： 堆积柱形图堆积柱形图示例堆积柱形图将每根柱子进行分割，可以显示大类目下的细分类目占比情况。它既可以直观地看出每个指标的值，还能够反映出维度总和。可应用在： 展示某互联网产品在一周内由不同渠道获得的流量对比。 销售部有 3 个部门：销售部门 A 、销售部门 B 、销售部门 C ，需要统计销售部各个部门的贡献成分及变化。 周流量数据 序号 星期 直接访问 邮件营销 联盟广告 视频广告 搜索引擎 1 周一 320 120 220 150 820 2 周二 302 132 182 212 832 3 周三 301 101 191 201 901 4 周四 334 134 234 154 934 5 周五 390 90 290 190 1290 6 周六 330 230 330 330 1330 7 周日 320 210 310 410 1320 堆积柱形图能清晰的看出每个维度下不同指标的大小，也可以比较出不同维度类别的数据量差距。但是只适用于维度不多的数据，不适用于维度太多的场景。堆积柱形图例如下图所示： 堆积柱形图制作 将【星期】字段拖入维度栏中，将指标下的字段【直接访问、邮件营销、联盟广告、视频广告、搜索引擎】按顺序置入指标栏中，在图表类型下选择【堆积柱形图】。如下图所示： 设置【按照星期排序】 自定义排序，鼠标悬浮在横轴上的【星期】字段上，点击右侧倒三角符号，设置自定义排序。如下图所示： 通过序号字段实现排序，将【序号】字段拖入【细粒度】栏。再将鼠标悬浮在横轴上的【星期】字段上，点击右侧倒三角符号，选择【升序&gt;序号(求和)】，如下图所示： 堆积柱形图设置组件样式 将指标字段【直接访问、邮件营销、联盟广告、视频广告、搜索引擎】指标 分别 拖入 各自 的图形属性中与它们名称相同的下拉栏的【标签】中。如下图所示： 多系列柱形图多系列柱形图表示例多系列柱形图用于显示不同系列指标间的对比效果，能清晰的看出每个维度下不同指标的大小，通过不同的柱形比较出不同维度类别的数据量差距。但是只适用于维度不多的数据，不适用于维度太多的场景。 访问统计事实表 统计日期 地区ID 访问ID 访问平台 渠道ID 用户ID 访问次数 浏览量 跳出次数 总停留时间 2015-09-01 3299 379 Android QD1004 USER0115 6 10 4 1,656 2015-09-01 4417 380 IOS QD1015 USER0116 5 6 4 648 2015-09-01 1101 381 Android QD1013 USER0117 5 14 4 1,512 2015-09-01 2201 382 IOS QD1015 USER0118 2 12 4 1,728 2015-09-01 2113 383 IOS QD1003 USER0119 5 9 4 1,548 2015-09-01 3712 384 移动浏览器 QD1006 USER0120 3 12 4 1,440 2015-09-02 3299 385 Android QD1014 USER0121 3 12 4 1,008 2015-09-02 4420 386 Android QD1020 USER0122 2 15 4 1,260 2015-09-03 6211 387 Android QD1011 USER0123 2 10 4 396 2015-09-03 4418 388 IOS QD1011 USER0124 2 8 4 432 2015-09-03 4420 389 IOS QD1009 USER0125 3 14 4 1,116 2015-09-03 6203 390 IOS QD1003 USER0126 5 12 4 288 2015-09-03 6110 391 移动浏览器 QD1009 USER0127 6 8 4 756 2015-09-04 3412 392 IOS QD1019 USER0128 1 10 4 648 2015-09-04 7110 393 Android QD1020 USER0129 1 14 4 792 2015-09-04 2112 394 Android QD1016 USER0130 5 6 4 396 2015-09-04 4418 395 IOS QD1011 USER0131 5 10 4 1,584 2015-09-04 2312 396 Android QD1020 USER0132 5 6 4 720 2015-09-04 3713 397 IOS QD1005 USER0133 2 11 4 720 2015-09-04 4417 398 IOS QD1018 USER0134 5 7 4 1,800 2015-09-04 4117 399 IOS QD1016 USER0135 5 14 4 792 2015-09-04 4117 400 IOS QD1020 USER0136 1 11 4 324 2015-09-04 3405 401 移动浏览器 QD1016 USER0137 4 9 5 360 2015-09-05 6212 402 IOS QD1005 USER0138 5 9 4 792 2015-09-05 4115 403 Android QD1008 USER0139 4 9 4 216 2015-09-05 3301 404 Android QD1003 USER0140 6 10 4 396 2015-09-05 4451 405 Android QD1006 USER0141 3 11 4 828 2015-09-05 4452 406 Android QD1001 USER0142 4 10 4 864 2015-09-05 3715 407 IOS QD1015 USER0143 4 6 4 756 多系列柱形图表制作 选择【多系列柱形图】，将待分析区域【统计日期】、【浏览量】、【访问次数】、【跳出次数】拖入右侧分析区域，如下图所示： 筛选出2015.7.13之前的数据。美化组件：颜色设置，大小设置等 如下图所示： 多系列柱形图表制作(开启堆积)此案例增加 【添加计算字段】和【开启堆积】 销售明细表 销售日期 产品归属业务部 产品名称 产品品规 产品品类 客户编码 客户名称 区域 生产厂家 销售单位 销售类型 销售人员 不含税销售单价 不含税销售额 城建税、教育费附加、地方教育附加 出库单编码 单位生产成本 发票号 发票金额 发票增值税额 发票增值税率 含税销售单价 含税销售额 人力成本 物流编号 现金折扣 销售数量 总成本 2019-01-05 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 8.62 86,206,896.55 775,812.41 1,234,567 4.58 123,456 86,206,896.55 13,793,103.45 0.16 10 100,000,000 12,500,000 12,345,678 2,586,206.9 10,000,000 45,800,000 2019-01-30 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 发货 b 8.62 129,310,344.83 1,163,718.62 1,234,568 4.58 123,457 129,310,344.83 20,689,655.17 0.16 10 150,000,000 18,750,000 12,345,679 3,879,310.34 15,000,000 68,700,000 2019-02-10 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 8.62 103,448,275.86 930,974.9 1,234,569 4.58 123,458 103,448,275.86 16,551,724.14 0.16 10 120,000,000 15,000,000 12,345,680 3,103,448.28 12,000,000 54,960,000 2019-02-20 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 8.62 112,068,965.52 1,008,556.14 1,234,570 4.58 123,459 112,068,965.52 17,931,034.48 0.16 10 130,000,000 16,250,000 12,345,681 3,362,068.97 13,000,000 59,540,000 2019-03-08 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 退货 b 8.62 -172,413.79 -1,551.62 1,234,571 4.58 123,460 -172,413.79 -27,586.21 0.16 10 -200,000 -25,000 12,345,682 -5,172.41 -20,000 -91,600 2019-04-06 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 发货 b 8.85 115,044,247.79 865,866.27 1,234,572 4.58 123,461 115,044,247.79 14,955,752.21 0.13 10 130,000,000 16,681,415.93 12,345,683 3,451,327.43 13,000,000 59,540,000 2019-05-05 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司2 盒 发货 a 8.85 79,646,017.7 571,365.88 1,234,573 4.78 123,462 79,646,017.7 10,353,982.3 0.13 10 90,000,000 11,548,672.57 12,345,684 2,389,380.53 9,000,000 43,020,000 2019-06-15 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司2 盒 发货 b 8.85 61,946,902.65 444,395.68 1,234,574 4.78 123,463 61,946,902.65 8,053,097.35 0.13 10 70,000,000 8,982,300.88 12,345,685 1,858,407.08 7,000,000 33,460,000 2019-01-03 非处方药 感冒药2 20袋 呼吸类 AA001 A 京津 子公司3 盒 发货 a 15.52 3,103,448.28 24,411.81 1,234,575 9.16 123,464 3,103,448.28 496,551.72 0.16 18 3,600,000 450,000 12,345,686 93,103.45 200,000 1,832,000 2019-01-08 非处方药 感冒药2 20袋 呼吸类 AA001 A 京津 子公司3 盒 发货 b 15.52 7,758,620.69 61,029.52 1,234,576 9.16 123,465 7,758,620.69 1,241,379.31 0.16 18 9,000,000 1,125,000 12,345,687 232,758.62 500,000 4,580,000 2019-01-10 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 139,655,172.41 1,098,531.31 1,234,577 9.16 123,466 139,655,172.41 22,344,827.59 0.16 18 162,000,000 20,250,000 12,345,688 4,189,655.17 9,000,000 82,440,000 2019-01-19 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 155,172,413.79 1,220,590.34 1,234,578 9.16 123,467 155,172,413.79 24,827,586.21 0.16 18 180,000,000 22,500,000 12,345,689 4,655,172.41 10,000,000 91,600,000 2019-01-31 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 232,758,620.69 1,830,885.52 1,234,579 9.16 123,468 232,758,620.69 37,241,379.31 0.16 18 270,000,000 33,750,000 12,345,690 6,982,758.62 15,000,000 137,400,000 2019-02-10 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 201,724,137.93 1,586,767.45 1,234,580 9.16 123,469 201,724,137.93 32,275,862.07 0.16 18 234,000,000 29,250,000 12,345,691 6,051,724.14 13,000,000 119,080,000 2019-03-10 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.52 139,655,172.41 1,098,531.31 1,234,581 9.16 123,470 139,655,172.41 22,344,827.59 0.16 18 162,000,000 20,250,000 12,345,692 4,189,655.17 9,000,000 82,440,000 2019-04-15 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.93 127,433,628.32 844,796.6 1,234,582 9.16 123,471 127,433,628.32 16,566,371.68 0.13 18 144,000,000 18,477,876.11 12,345,693 3,823,008.85 8,000,000 73,280,000 2019-05-12 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.93 79,646,017.7 527,997.88 1,234,583 9.16 123,472 79,646,017.7 10,353,982.3 0.13 18 90,000,000 11,548,672.57 12,345,694 2,389,380.53 5,000,000 45,800,000 2019-06-15 非处方药 感冒药2 20袋 呼吸类 AC003 C 京津 子公司3 盒 发货 c 15.93 71,681,415.93 475,198.09 1,234,584 9.16 123,473 71,681,415.93 9,318,584.07 0.13 18 81,000,000 10,393,805.31 12,345,695 2,150,442.48 4,500,000 41,220,000 2020-01-05 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 9.29 102,212,389.38 787,993.27 1,234,585 4.7 123,474 102,212,389.38 13,287,610.62 0.13 10.5 115,500,000 14,105,309.73 12,345,696 2,044,247.79 11,000,000 51,700,000 2020-01-30 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 发货 b 9.29 120,796,460.18 931,264.78 1,234,586 4.7 123,475 120,796,460.18 15,703,539.82 0.13 10.5 136,500,000 16,669,911.5 12,345,697 2,415,929.2 13,000,000 61,100,000 2020-02-10 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 9.29 92,920,353.98 716,357.52 1,234,587 4.7 123,476 92,920,353.98 12,079,646.02 0.13 10.5 105,000,000 12,823,008.85 12,345,698 1,858,407.08 10,000,000 47,000,000 2020-02-20 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司1 盒 发货 a 9.29 27,876,106.19 214,907.26 1,234,588 4.7 123,477 27,876,106.19 3,623,893.81 0.13 10.5 31,500,000 3,846,902.65 12,345,699 557,522.12 3,000,000 14,100,000 2020-03-08 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 退货 b 9.29 -278,761.06 -2,149.07 1,234,589 4.7 123,478 -278,761.06 -36,238.94 0.13 10.5 -315,000 -38,469.03 12,345,700 -5,575.22 -30,000 -141,000 2020-04-06 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司1 盒 发货 b 9.29 74,336,283.19 573,086.02 1,234,590 4.7 123,479 74,336,283.19 9,663,716.81 0.13 10.5 84,000,000 10,258,407.08 12,345,701 1,486,725.66 8,000,000 37,600,000 2020-05-05 非处方药 感冒药1 10袋 呼吸类 AA001 A 京津 子公司2 盒 发货 a 9.29 83,628,318.58 605,409.77 1,234,591 4.98 123,480 83,628,318.58 10,871,681.42 0.13 10.5 94,500,000 11,540,707.96 12,345,702 1,672,566.37 9,000,000 44,820,000 2020-06-15 非处方药 感冒药1 10袋 呼吸类 AB002 B 京津 子公司2 盒 发货 b 9.29 92,920,353.98 672,677.52 1,234,592 4.98 123,481 92,920,353.98 12,079,646.02 0.13 10.5 105,000,000 12,823,008.85 12,345,703 1,858,407.08 10,000,000 49,800,000 2020-01-03 非处方药 感冒药2 20袋 呼吸类 AA001 A 京津 子公司3 盒 发货 a 15.93 12,743,362.83 81,484.46 1,234,593 9.4 123,482 12,743,362.83 1,656,637.17 0.13 18 14,400,000 1,758,584.07 12,345,704 254,867.26 800,000 7,520,000 2020-04-08 非处方药 感冒药2 20袋 呼吸类 AA001 A 京津 子公司3 盒 发货 b 15.93 14,336,283.19 91,670.02 1,234,594 9.4 123,483 14,336,283.19 1,863,716.81 0.13 18 16,200,000 1,978,407.08 12,345,705 286,725.66 900,000 8,460,000 2020-05-03 非处方药 感冒药2 20袋 呼吸类 AA001 A 京津 子公司3 盒 发货 a 15.93 12,743,362.83 81,484.46 1,234,595 9.4 123,484 12,743,362.83 1,656,637.17 0.13 18 14,400,000 1,758,584.07 12,345,706 254,867.26 800,000 7,520,000 2020-06-08 非处方药 感冒药2 20袋 呼吸类 AA001 A 京津 子公司3 盒 发货 b 15.93 14,336,283.19 91,670.02 1,234,596 9.4 123,485 14,336,283.19 1,863,716.81 0.13 18 16,200,000 1,978,407.08 12,345,707 286,725.66 900,000 8,460,000 添加计算字段 ，字段名称为【其他成本】，公式为：SUM_AGG(总成本)-SUM_AGG(人力成本)。如下图所示： 选择【多系列柱形图】，将【产品名称】字段拖入到横轴，将【总成本】、【其他成本】、【人力成本】拖入到纵轴。如下图所示： 为纵轴中的【其他成本】、【人力成本】 【开启堆积】。如下图所示： 对比柱形图对比柱形图示例对比柱状图是一种以背靠背形式的条形图，主要用于展示同一维度下，两个指标的对比分析，便于更直观地看出对比差距。下图显示了美国大选各大洲得票情况对比，红色代表共和党，蓝色代表民主党，对比效果如图所示： 能清晰地比较出当前维度下不同指标的数据量差距，最常用于（有相反含义）的两个指标做对比。 但是只适用于维度不多的数据，不适用于维度太多的场景。 美国大选投票数据 votes democrat votes republican rep vs dem custom bins variance from national margin labels variance - skew dem or rep Row type Row densified Column Percent of year’s vote 记录数 Row densified (bin) Row State (Sheet1) State Swing left vs right Table Name Total votes - democrat Total votes - republican Year dem vs rep % variance from national margin 0.34 0.62 rep +25-30% 0.3 more right real 1 8 8e-3 1 1 7 Alabama Alabama more right swingdata3.csv 729,547 1,318,255 2,016 0.28 0.3 0.38 0.61 rep +20-25% 0.26 more right real 1 8 8e-3 1 1 7 Alabama Alabama more right swingdata3.csv 795,696 1,255,925 2,012 0.22 0.26 0.39 0.6 rep +20-25% 0.29 more right real 1 8 8e-3 1 1 7 Alabama Alabama more right swingdata3.csv 813,479 1,266,546 2,008 0.22 0.29 0.37 0.62 rep +25-30% 0.23 more right real 1 8 8e-3 1 1 7 Alabama Alabama more right swingdata3.csv 693,933 1,176,394 2,004 0.26 0.23 0.42 0.56 rep +10-15% 0.15 more right real 1 8 8e-3 1 1 7 Alabama Alabama more right swingdata3.csv 692,611 941,173 2,000 0.15 0.15 0.43 0.5 rep +5-10% 0.15 more right real 1 8 8e-3 1 1 7 Alabama Alabama more right swingdata3.csv 662,165 769,044 1,996 0.07 0.15 0.41 0.48 rep +5-10% 0.12 more right real 1 8 8e-3 1 1 7 Alabama Alabama more right swingdata3.csv 690,080 804,283 1,992 0.07 0.12 0.4 0.59 rep +15-20% 0.12 more right real 1 8 8e-3 1 1 7 Alabama Alabama more right swingdata3.csv 549,506 815,576 1,988 0.19 0.12 0.37 0.51 rep +10-15% 0.17 more right real 1 1 1e-3 1 1 1 Alaska Alaska more right swingdata3.csv 116,454 163,387 2,016 0.15 0.17 0.41 0.55 rep +10-15% 0.18 more right real 1 1 1e-3 1 1 1 Alaska Alaska more right swingdata3.csv 122,640 164,676 2,012 0.14 0.18 0.38 0.59 rep +20-25% 0.29 more right real 1 1 1e-3 1 1 1 Alaska Alaska more right swingdata3.csv 123,594 193,841 2,008 0.22 0.29 0.36 0.61 rep +25-30% 0.23 more right real 1 1 1e-3 1 1 1 Alaska Alaska more right swingdata3.csv 111,025 190,889 2,004 0.26 0.23 0.28 0.59 rep +30-40% 0.32 more right real 1 1 1e-3 1 1 1 Alaska Alaska more right swingdata3.csv 79,004 167,398 2,000 0.31 0.32 0.33 0.51 rep +15-20% 0.26 more right real 1 1 1e-3 1 1 1 Alaska Alaska more right swingdata3.csv 80,380 122,746 1,996 0.18 0.26 0.3 0.39 rep +5-10% 0.15 more right real 1 1 1e-3 1 1 1 Alaska Alaska more right swingdata3.csv 78,294 102,000 1,992 0.09 0.15 0.36 0.6 rep +20-25% 0.16 more right real 1 1 1e-3 1 1 1 Alaska Alaska more right swingdata3.csv 72,584 119,251 1,988 0.23 0.16 0.45 0.49 rep +2-5% 0.06 more right real 1 3 9e-3 1 1 6 Arizona Arizona more right swingdata3.csv 1,161,167 1,252,401 2,016 0.04 0.06 0.45 0.54 rep +5-10% 0.13 more right real 1 3 9e-3 1 1 6 Arizona Arizona more right swingdata3.csv 1,025,232 1,233,654 2,012 0.09 0.13 0.45 0.54 rep +5-10% 0.16 more right real 1 3 9e-3 1 1 6 Arizona Arizona more right swingdata3.csv 1,034,707 1,230,111 2,008 0.09 0.16 0.44 0.55 rep +10-15% 0.08 more right real 1 3 8e-3 1 1 6 Arizona Arizona more right swingdata3.csv 893,524 1,104,294 2,004 0.1 0.08 0.45 0.51 rep +5-10% 0.07 more right real 1 3 7e-3 1 1 6 Arizona Arizona more right swingdata3.csv 685,341 781,652 2,000 0.06 0.07 0.47 0.44 dem +2-5% 0.06 more right real 1 3 7e-3 1 1 6 Arizona Arizona more right swingdata3.csv 653,288 622,073 1,996 -0.02 0.06 0.37 0.38 rep +0-2% 0.08 more right real 1 3 7e-3 1 1 6 Arizona Arizona more right swingdata3.csv 543,050 572,086 1,992 0.02 0.08 0.39 0.6 rep +20-25% 0.13 more right real 1 3 6e-3 1 1 6 Arizona Arizona more right swingdata3.csv 454,029 702,541 1,988 0.21 0.13 0.34 0.61 rep +25-30% 0.29 more right real 1 6 4e-3 1 1 6 Arkansas Arkansas more right swingdata3.csv 380,494 684,872 2,016 0.27 0.29 0.37 0.61 rep +20-25% 0.27 more right real 1 6 4e-3 1 1 6 Arkansas Arkansas more right swingdata3.csv 394,409 647,744 2,012 0.24 0.27 0.39 0.59 rep +15-20% 0.27 more right real 1 6 4e-3 1 1 6 Arkansas Arkansas more right swingdata3.csv 422,310 638,017 2,008 0.2 0.27 0.45 0.54 rep +5-10% 0.07 more right real 1 6 4e-3 1 1 6 Arkansas Arkansas more right swingdata3.csv 469,953 572,898 2,004 0.1 0.07 0.46 0.51 rep +5-10% 0.06 more right real 1 6 4e-3 1 1 6 Arkansas Arkansas more right swingdata3.csv 422,768 472,940 2,000 0.05 0.06 0.54 0.37 dem +15-20% 0.08 more left real 1 6 5e-3 1 1 6 Arkansas Arkansas more left swingdata3.csv 475,171 325,416 1,996 -0.17 -0.08 对比柱形图制作 将【State】(州)字段拖入到【维度】中，【Total votes - democrat】(民主党总票数)、【Total votes - republican】(共和党总票数)字段拖入到【指标】中，在图表类型下选择【对比柱形图】。如下图所示： 更改组件颜色，更改组件标题为【对比柱形图】。如下图所示： 瀑布图瀑布图示例瀑布图采用绝对值与相对值结合的方式，来表达数个特定数值之间的数量变化关系。这种效果的图形能够在反映数据多少的同时，直观反映出数据的增减变化过程。 在实际的应用场景中，瀑布图常用于经营情况分析，解释从一个数字到另一个数字的变化过程。比如评估公司利润、比较产品收益、突出显示项目的预算变更、分析一段时间内的库存或销售情况 、显示一段时间内产品价值变化等。 瀑布图展示两个数据点之间的演变过程，还可以展示数据是如何累计的。但是使用场景有限。 工资组成 项目 数据 基本工资 460 绩效工资 120 加班工资 80 应发工资 660 保险 -45 公积金 -80 个税 -23 实发工资 512 数据间关系为： 基本工资+绩效工资+加班工资&#x3D;应发工资 应发工资-保险-公积金-个税&#x3D;实发工资 瀑布图制作-数据处理 【新增公式列】 添加字段为 【累计值准备】选择【新增公式列】。【应发工资】和【实发工资】数据变为 0 ，其他数据保持不变。 选择【新增汇总列】。对】【累计值准备】字段进行累加。如下图所示： 选择【新增公式列】。求出每根柱子在 y 轴上对应的【起点】。最后保存并预览数据图表 瀑布图制作-组件制作 将【项目】字段拖入到维度中，【y轴】」、【数据】字段拖入到指标中。 【项目】字段自定义排序。如下图所示： 瀑布图组件美化，将【数据】字段拖入到【标签】【颜色】栏等。如下图所示： 去除图例，点击【组件样式】&gt;【图例】，取消勾选【显示全部图例】。如下图所示： 分区折线图分区折线图示例分区折线图用于分区域分指标查看数据的变化趋势。如下图显示了两个城市在同一时段风速走势的对比情况：、 分区折线图能清晰地展现出当前维度下不同指标的增减趋势、增减的速率、增减的规律、峰值等特征，适合展现较大数据集，不会多条线条叠加在一起。但是不适合展示多类别数据。 风速对比 时间 A城市 B城市 1&#x2F;01&#x2F;2020 0:00 4.3 0 2&#x2F;01&#x2F;2020 0:00 5.1 0 3&#x2F;01&#x2F;2020 0:00 4.3 0 4&#x2F;01&#x2F;2020 0:00 5.2 0 5&#x2F;01&#x2F;2020 0:00 5.4 0 6&#x2F;01&#x2F;2020 0:00 4.7 0 7&#x2F;01&#x2F;2020 0:00 3.5 0 8&#x2F;01&#x2F;2020 0:00 4.1 0 9&#x2F;01&#x2F;2020 0:00 5.6 0.1 10&#x2F;01&#x2F;2020 0:00 7.4 0 11&#x2F;01&#x2F;2020 0:00 6.9 0.3 12&#x2F;01&#x2F;2020 0:00 7.1 0 13&#x2F;01&#x2F;2020 0:00 7.9 0 14&#x2F;01&#x2F;2020 0:00 7.9 0.4 15&#x2F;01&#x2F;2020 0:00 7.5 0 16&#x2F;01&#x2F;2020 0:00 6.7 0.1 17&#x2F;01&#x2F;2020 0:00 7.7 0 18&#x2F;01&#x2F;2020 0:00 7.7 0 19&#x2F;01&#x2F;2020 0:00 7.4 0 20&#x2F;01&#x2F;2020 0:00 7 0 21&#x2F;01&#x2F;2020 0:00 7.1 0 22&#x2F;01&#x2F;2020 0:00 5.8 0 23&#x2F;01&#x2F;2020 0:00 5.9 0 24&#x2F;01&#x2F;2020 0:00 7.4 0 25&#x2F;01&#x2F;2020 0:00 8.2 0 26&#x2F;01&#x2F;2020 0:00 8.5 0.6 27&#x2F;01&#x2F;2020 0:00 9.4 1.2 28&#x2F;01&#x2F;2020 0:00 8.1 1.7 分区折线图制作 在图表类型下选择【分区折线图】，将【时间】字段拖入到横轴中，【A城市】、【B城市】字段拖入到纵轴中。如下图所示： 将待分析区域维度下的【指标名称】拖入颜色栏中。如下图所示： 组件样式设置，点击【连线】，选择线形为曲线，并取消显示标记点： 点击【组件样式】，选择自适应显示下拉，选整体适应。如下图所示： 多系列折线图多系列折线图示例多系列折线图用于在同一区域查看指标的变化趋势，能直观看出趋势对比。 效果如下图所示，该图展现了自 1800 年至 2017 年全世界能源消耗情况，图中不同颜色的折线代表不同的能源类型（固态、液态、燃气等）：多系列清晰地展现出当前维度下不同指标的增减趋势、增减的速率、增减的规律、峰值等特征，适合展现较大数据集。但是线条数目一般不适合超过 4 条。 CO2-by-source Entity Code Year Cement Flaring Oil Coal Gas Afghanistan AFG 1949 0 0 0 14656 0 Afghanistan AFG 1950 0 0 65952 21984 0 Afghanistan AFG 1951 0 0 65952 25648 0 Afghanistan AFG 1952 0 0 62288 32976 0 Afghanistan AFG 1953 0 0 65952 36640 0 Afghanistan AFG 1954 0 0 65952 43968 0 Afghanistan AFG 1955 0 0 91600 62288 0 Afghanistan AFG 1956 0 0 120912 62288 0 Afghanistan AFG 1957 0 0 216176 76944 0 Afghanistan AFG 1958 0 0 238160 91600 0 Afghanistan AFG 1959 18320 0 256480 109920 0 Afghanistan AFG 1960 18012 268760 127120 Afghanistan AFG 1961 21806 293120 175870 Afghanistan AFG 1962 29074 362740 296780 Afghanistan AFG 1963 50880 392050 263810 Afghanistan AFG 1964 61783 476320 300450 Afghanistan AFG 1965 83589 542270 381060 Afghanistan AFG 1966 87223 575250 428690 Afghanistan AFG 1967 65417 556930 399380 260140 Afghanistan AFG 1968 47105 496820 332430 347040 Afghanistan AFG 1969 50880 527620 362740 Afghanistan AFG 1970 47350 297440 671990 436970 216650 Afghanistan AFG 1971 43611 304110 747460 359070 439680 Afghanistan AFG 1972 47246 366400 626540 190530 300450 Afghanistan AFG 1973 68897 223010 701920 310740 332680 Afghanistan AFG 1974 72825 367100 770910 304690 400140 Afghanistan AFG 1975 72561 303590 874190 398690 475500 Afghanistan AFG 1976 82609 293120 883020 425020 300450 Afghanistan AFG 1977 67434 381060 974620 450670 512960 Afghanistan AFG 1978 59713 282610 935910 576230 300960 多系列折线图制作 修改字段类型，数据表上传后，选择字段类型设置中的【Year】为【文本】，点击【确定】按钮。如下图所示： 将待分析区域维度下的字段【Year】拖入维度中，将指标下的字段【Cement】(水泥)、【Coal】(煤)、【Flaring】、【Gas】(气体)、【Oil】(油)拖入指标中，在图表类型中选择【多系列折线图】。如下图所示： 组件样式设置，选择【组件样式】，点击【自适应显示】，选择【整体适应】，如下图所示： 点击 Cement 字段的下拉框，选择【数值格式】，设置数量单位为亿。如下图所示： 点击 Cement 字段的下拉框，选择【设置值轴(左值轴)】，点击【自定义】，设置最小值为 0 ，取消勾选【显示轴标题】，点击【确定】。如下图所示： 折线雷达图折线雷达图示例雷达图（Radar Chart），又可称为戴布拉图、蜘蛛网图（Spider Chart），每个分类都拥有自己的数值坐标轴，这些坐标轴由中心向外辐射，并用折线将同一系列的值连接。 用以显示独立的数据系列之间，以及某个特定的系列与其他系列的整体之间的关系。 雷达图适合展现某个数据集的多个关键特征并进行比对，适合比较多条数据在多个维度上的取值。但是不适合展示多类别数据。 手机参数对比 特征 手机A 手机B 外观 85 90 屏幕 90 95 性能 90 85 系统 95 95 拍照 90 85 可以用雷达图展现两款手机 A、B 之间的性能对照，如下图所示案例表： 折线雷达图制作在图表类型下选择【折线雷达图】，将左侧【特征】、【手机A】、【手机B】字段拖入到右侧分析区域中。 如下图所示： 范围面积图范围面积图示例范围面积图用来展示持续性数据，可很好地表示趋势、累积、减少以及变化。 范围面积图适合展现同一个分类维度在同一间隔内两个连续变量的变化趋势。但是不适合展现多个分类数据。 访问统计事实表 统计日期 地区ID 访问ID 访问平台 渠道ID 用户ID 访问次数 浏览量 跳出次数 总停留时间 2015-09-01 3299 379 Android QD1004 USER0115 6 10 4 1,656 2015-09-01 4417 380 IOS QD1015 USER0116 5 6 4 648 2015-09-01 1101 381 Android QD1013 USER0117 5 14 4 1,512 2015-09-01 2201 382 IOS QD1015 USER0118 2 12 4 1,728 2015-09-01 2113 383 IOS QD1003 USER0119 5 9 4 1,548 2015-09-01 3712 384 移动浏览器 QD1006 USER0120 3 12 4 1,440 2015-09-02 3299 385 Android QD1014 USER0121 3 12 4 1,008 2015-09-02 4420 386 Android QD1020 USER0122 2 15 4 1,260 2015-09-03 6211 387 Android QD1011 USER0123 2 10 4 396 2015-09-03 4418 388 IOS QD1011 USER0124 2 8 4 432 2015-09-03 4420 389 IOS QD1009 USER0125 3 14 4 1,116 2015-09-03 6203 390 IOS QD1003 USER0126 5 12 4 288 2015-09-03 6110 391 移动浏览器 QD1009 USER0127 6 8 4 756 2015-09-04 3412 392 IOS QD1019 USER0128 1 10 4 648 2015-09-04 7110 393 Android QD1020 USER0129 1 14 4 792 2015-09-04 2112 394 Android QD1016 USER0130 5 6 4 396 2015-09-04 4418 395 IOS QD1011 USER0131 5 10 4 1,584 2015-09-04 2312 396 Android QD1020 USER0132 5 6 4 720 2015-09-04 3713 397 IOS QD1005 USER0133 2 11 4 720 2015-09-04 4417 398 IOS QD1018 USER0134 5 7 4 1,800 2015-09-04 4117 399 IOS QD1016 USER0135 5 14 4 792 2015-09-04 4117 400 IOS QD1020 USER0136 1 11 4 324 2015-09-04 3405 401 移动浏览器 QD1016 USER0137 4 9 5 360 2015-09-05 6212 402 IOS QD1005 USER0138 5 9 4 792 2015-09-05 4115 403 Android QD1008 USER0139 4 9 4 216 2015-09-05 3301 404 Android QD1003 USER0140 6 10 4 396 2015-09-05 4451 405 Android QD1006 USER0141 3 11 4 828 2015-09-05 4452 406 Android QD1001 USER0142 4 10 4 864 2015-09-05 3715 407 IOS QD1015 USER0143 4 6 4 756 2015-09-05 2305 408 IOS QD1020 USER0144 6 9 4 72 已知网页的访问次数和跳出次数，两条线勾勒出的范围非跳出次数的变化量趋势，如下图所示： 范围面积图制作 图表类型下选择【范围面积图】，将待分析区域维度下的字段【统计日期】拖入横轴中，将指标下的字段【访问次数】、【跳出次数】拖入纵轴中。如下图所示： 点击【统计日期(年月日)】字段下拉框，选择【年月】，如下图所示： 在【访问次数(求和)】或【跳出次数(求和)】字段下点击下拉，选择【设置值轴(左值轴)】，在轴标签设置中取消显示轴标签，如下图所示： 仪表盘仪表盘示例【多指针仪表盘】像一个钟表或者可读盘，它有刻度和指针，其中刻度表示度量，指针表示维度，指针角度表示数值，指针指向当前数值。利用多指针的仪表盘，可以直观地表现出某个指标的进度或实际情况。 供应商产品表 产品名称 单位数量 中止 产品ID 单价 订购量 供应商ID 库存量 类别ID 再订购量 苹果汁 每箱24瓶 是 1 18 0 1 39 1 10 牛奶 每箱24瓶 否 2 19 40 1 17 1 25 蕃茄酱 每箱12瓶 否 3 10 70 1 13 2 25 盐 每箱12瓶 否 4 22 0 2 53 2 0 麻油 每箱12瓶 是 5 21.35 0 2 0 2 0 酱油 每箱12瓶 否 6 25 0 3 120 2 25 海鲜粉 每箱30盒 否 7 30 0 3 15 7 10 胡椒粉 每箱30盒 否 8 40 1 3 6 2 0 鸡 每袋500克 是 9 97 3 4 29 6 0 蟹 每袋500克 否 10 31 0 4 31 8 0 大众奶酪 每袋6包 否 11 21 30 5 22 4 30 德国奶酪 每箱12瓶 否 12 38 3 5 86 4 0 龙虾 每袋500克 否 13 6 0 6 24 8 5 沙茶 每箱12瓶 否 14 23.25 0 6 35 7 0 味精 每箱30盒 否 15 15.5 0 6 39 2 5 饼干 每箱30盒 否 16 17.45 0 7 29 3 10 猪肉 每袋500克 是 17 39 0 7 0 6 0 墨鱼 每袋500克 否 18 62.5 4 9 42 8 0 糖果 每箱30盒 否 19 9.2 0 8 25 3 5 桂花糕 每箱30盒 否 20 81 0 8 40 3 6 花生 每箱30包 否 21 10 40 8 3 3 5 糯米 每袋3公斤 否 22 21 0 9 104 5 25 燕麦 每袋3公斤 否 23 9 0 9 61 5 25 汽水 每箱12瓶 是 24 4.5 0 10 20 1 0 巧克力 每箱30盒 否 25 14 0 11 76 3 30 棉花糖 每箱30盒 否 26 31.23 0 11 15 3 0 多指针仪表盘 在图表类型下选择【仪表盘】，图形属性下选择第一个子类型。将【库存量】、【订购量】字段拖入到指针值处。如下图所示： 百分比仪表盘【百分比仪表盘】，有两种样式：百分比圆环仪表盘、百分比刻度槽型仪表盘。可以直观地表现出某一项数据占总量的占比，可以展示销售完成率、产品合格率等，也可以作为一个进度百分比展示。但是，只能展示一个指标数据，展示信息有限。 百分比仪表盘制作 假设总库存容量是4000，新增一个计算字段库存百分比，自定义百分比数据。如下图所示： 在图表类型下选择【仪表盘】，图形属性下选择第三个子类型，将【百分比】字段拖入到指针值处。如下图所示： 点击【目标值】，设置目标值为 1 。如下图所示： 将【百分比】字段拖入到【标签栏】，设置数值格式为【百分比】。如下图所示： 点击【标签】栏，点击内容格式右下角【编辑】按钮。如下图所示： 饼图饼图示例饼图用于分析数据的占比，用户可通过饼图很直观的看到每一个部分在整体中所占的比例。 地区数据分析 合同签约时间 国家 省份 城市 客户名称 合同金额 回款金额 2016-01-18 中国 浙江省 杭州市 浙江臻善科技有限公司 1,200,000 1,200,000 2016-08-01 中国 河南省 郑州市 杭州明佑电子有限公司 100,800 100,800 2016-04-01 中国 陕西省 西安市 西北工业大学 430,000 430,000 2016-01-18 中国 浙江省 杭州市 浙江网新恩普软件有限公司 200,000 200,000 2016-04-08 中国 北京市 北京市 北京瑞翔科技有限公司 200,000 200,000 2016-04-14 中国 上海市 上海市 上海捷穗软件有限公司 200,000 200,000 2016-05-05 中国 重庆市 重庆市 重庆格力销售中心 285,000 285,000 2016-04-21 中国 江苏省 南京市 江苏邮政同达科技 120,000 120,000 2016-06-01 中国 上海市 上海市 95856部队 520,000 520,000 2016-04-29 中国 上海市 上海市 上海创业投资有限公司 240,000 240,000 2016-04-29 中国 上海市 上海市 智动营销策划咨询（上海）有限公司 450,000 450,000 2016-04-25 中国 江苏省 盐城市 盐城邮政局 120,000 120,000 2016-05-04 中国 浙江省 杭州市 杭州银行 1,200,000 1,080,000 2016-04-27 中国 北京市 北京市 建信金融租赁股份有限公司 600,000 600,000 通常能明确显示数据的比例情况。用来描述量、频率或百分比之间的相对关系。但是不适合较大的数据集（分类）展现，当比例接近时，人眼很难准确判别。如下图所示： 饼图制作 将【合同签约时间】字段拖入维度，【合同金额】字段拖入指标，【合同签约时间】字段显示格式改为【年】。如下图所示： 在图表类型下选择【饼图】。如下图所示： 将【合同签约时间】、【合同金额】拖入【标签】内，使其在图形中显示，【合同签约时间】字段显示格式改为【年】。如下图所示： 【合同金额】字段下拉点击【快速计算&gt;占比】，显示饼图各部分占比。如下图所示： 点击【组件样式】&gt;【图例】，取消勾选显示全部图例按钮。如下图所示： 玫瑰图玫瑰图示例玫瑰图通过扇形的面积和半径显示数据的占比情况，可以展示每一数值相对于总数值的大小、数据在某一时间段的变化，也可以用来比较各项数据间的情况等。玫瑰图适合突出显示不同分类的大小差异。但是玫瑰图将数据量之间的差别夸大显示了，相差 1% 表现在面积上，视觉差别是超过 1% 的，不好用于展示具体的差值数量。 地区数据分析 合同签约时间 国家 省份 城市 客户名称 合同金额 回款金额 2016-01-18 中国 浙江省 杭州市 浙江臻善科技有限公司 1,200,000 1,200,000 2016-08-01 中国 河南省 郑州市 杭州明佑电子有限公司 100,800 100,800 2016-04-01 中国 陕西省 西安市 西北工业大学 430,000 430,000 2016-01-18 中国 浙江省 杭州市 浙江网新恩普软件有限公司 200,000 200,000 2016-04-08 中国 北京市 北京市 北京瑞翔科技有限公司 200,000 200,000 2016-04-14 中国 上海市 上海市 上海捷穗软件有限公司 200,000 200,000 2016-05-05 中国 重庆市 重庆市 重庆格力销售中心 285,000 285,000 2016-04-21 中国 江苏省 南京市 江苏邮政同达科技 120,000 120,000 2016-06-01 中国 上海市 上海市 95856部队 520,000 520,000 2016-04-29 中国 上海市 上海市 上海创业投资有限公司 240,000 240,000 2016-04-29 中国 上海市 上海市 智动营销策划咨询（上海）有限公司 450,000 450,000 2016-04-25 中国 江苏省 盐城市 盐城邮政局 120,000 120,000 2016-05-04 中国 浙江省 杭州市 杭州银行 1,200,000 1,080,000 2016-04-27 中国 北京市 北京市 建信金融租赁股份有限公司 600,000 600,000 2015-03-22 中国 江苏省 南京市 南京星友田科技发展有限公司 400,000 400,000 2016-06-19 中国 上海市 上海市 上海万序计算机科技有限公司 480,000 480,000 2016-05-25 中国 上海市 上海市 上海万序计算机科技有限公司 480,000 480,000 2016-05-26 中国 上海市 上海市 上海巨一科技发展有限公司 200,000 200,000 2016-05-20 中国 北京市 北京市 北京英诺威尔科技股份有限公司 875,000 787,500 2016-05-20 中国 北京市 北京市 北京普天太力通信科技有限公司 1,400,000 700,000 2016-05-31 中国 北京市 北京市 健康在线教育培训有限公司 280,000 280,000 2016-10-11 中国 江苏省 南京市 南京益康信达 350,000 350,000 2012-06-02 中国 上海市 上海市 上海欣能信息科技发展有限公司 1,576,000 1,400,000 2016-06-22 中国 北京市 北京市 埃而塔（北京）管理技术有限公司 300,000 300,000 2016-06-24 中国 广西壮族自治区 来宾市 柳州欧莱普信息技术有限公司 250,000 250,000 2016-06-09 中国 上海市 上海市 上海普元信息技术股份有限公司 0 200,000 2016-06-15 中国 四川省 成都市 成都启冠代理记账有限公司 60,000 60,000 2016-06-08 中国 福建省 厦门市 厦门农商银行 280,000 280,000 如下图所示： 玫瑰图制作 将【合同签约时间】拖入维度中，【合同金额】、【回款金额】拖入指标中。如下图所示： 在图表类型下选择【玫瑰图】，可以看到回款金额的大小映射到玫瑰图的半径上，合同金额的大小映射到玫瑰图的角度上。 如下图所示: 该玫瑰图必须在横纵轴中有1个维度、2个指标字段才能选择，否则图表类型下的玫瑰图将灰化无法点击。 点击颜色栏中的【合同签约时间】字段，选择【年月】显示。如下图所示： 点击【半径】栏，设置内径占比到 0% 。如下图所示： 点击颜色栏中的【合同签约时间】下拉，选择升序排序，按【回款金额(求和)】进行排序。如下图所示： 散点图散点图示例散点图（Scatter Chart）是科研绘图中最常见的图形类型之一，通常用于显示和比较数值，使用一系列的散点在直角坐标系中展示变量的数值分布，可以通过观察发现两者的关系与相关性。散点图可以展示数据的分布和聚合情况，适合展示较大的数据集。但是主要用于观测相关、分布和聚合，其他信息均不能很好展现。 身高体重分布 序号 性别 身高 体重 1 女 161.2 51.6 2 女 170 59 3 女 172.5 55.2 4 女 147.2 49.8 5 女 159.5 50.6 6 女 174 54.5 7 女 154.4 46.2 8 女 162.1 53.6 9 女 168.9 62.3 10 女 167.6 58.3 11 女 167.6 61 12 女 168.3 54.8 13 女 156 52.7 14 女 162 54.7 15 女 151.1 48.7 16 女 164 55.7 17 女 170 69.4 18 女 163.2 59.8 19 女 161.4 63.4 如下图展示了一组人群身高体重的分布数据，红色代表女性，蓝色代表男性： 散点图制作 先进行【数据处理】，将【序号】的数据类型改为【文本类型】在图表类型下选择【散点图】，将【身高】字段拖入到横轴，【体重】字段拖入到纵轴，【性别】字段拖入【图形属性】&gt;【颜色】，【序号】字段拖入到【图形属性】&gt;【细粒度】。如下图所示： 点击颜色栏，分别设置男女性别显示颜色，效果如下图所示： 点击身高(求和)下拉框，选择数值格式，设置单位后缀为cm，点击确定： 点击身高(求和)下拉框，选择设置值轴(下值轴)，显示范围选择自定义，设置最小值为MIN(身高(求和))-5，最大值为MAX(身高(求和))+5，点击确定： 点击体重(求和)下拉框，选择数值格式，设置单位后缀为kg，点击确定： 点击体重(求和)下拉框，选择设置值轴(下值轴)，显示范围选择自定义，设置最小值为MIN(体重(求和))-5，最大值为MAX(体重(求和))+5，点击确定： 热力区域图热力区域图示例热力区域图以特殊高亮的方式展示坐标范围内各个点的权重情况，通过颜色高亮程度展示指标数据的差异。可应用在： 某地区每月的 24 小时平均气温分布情况。 近几年雨水在 12 个月的分布情况。 能清晰地呈现数据在两个维度之间的分布、频率或密度情况。但是效果过于柔化，不适合用作数据的精确表达。 全年气温 日期 时间 温度 1&#x2F;01&#x2F;2013 0 1.3 1&#x2F;01&#x2F;2013 1 1.4 1&#x2F;01&#x2F;2013 2 1.6 1&#x2F;01&#x2F;2013 3 2 1&#x2F;01&#x2F;2013 4 2.4 1&#x2F;01&#x2F;2013 5 2.9 1&#x2F;01&#x2F;2013 6 3.1 1&#x2F;01&#x2F;2013 7 2.8 1&#x2F;01&#x2F;2013 8 2.8 1&#x2F;01&#x2F;2013 9 2.7 1&#x2F;01&#x2F;2013 10 3.4 1&#x2F;01&#x2F;2013 11 2.6 1&#x2F;01&#x2F;2013 12 2.4 1&#x2F;01&#x2F;2013 13 2.9 1&#x2F;01&#x2F;2013 15 2.8 1&#x2F;01&#x2F;2013 14 2.8 1&#x2F;01&#x2F;2013 16 2.2 如下图所示： 热力区域图制作 上传后，将【时间】字段的数据类型改为【文本】，在图表类型下点击【自定义图表】，将【日期」】段拖入横轴，【时间】字段拖入纵轴。如下图所示： 将【日期】的分组改为【年月】。如下图所示： 在图表类型下选择【热力区域图】，将【温度】拖入热力色栏。如下图所示： 展示温度平均值。如下图所示： 点击【自适应显示】，选择【整体适应】。如下图所示： 地图类区域地图地图示例【区域地图】是一种使用不同深浅的颜色来展示数据的大小和分布范围的可视化图形。适合展示数据在地理区块空间的分布状况，使用颜色深浅来区分数值大小。 客户维度表 国家 省份 城市 客户规模 中国 陕西省 西安市 50-150人 中国 浙江省 杭州市 &gt;500人 中国 湖北省 武汉市 &gt;500人 中国 北京市 北京市 50-150人 中国 北京市 北京市 50-150人 中国 北京市 北京市 50-150人 中国 广东省 深圳市 &gt;500人 中国 上海市 上海市 &gt;500人 中国 北京市 北京市 150-500人 中国 上海市 上海市 &gt;500人 中国 辽宁省 大连市 &gt;500人 中国 吉林省 长春市 50-150人 中国 浙江省 温州市 50-150人 中国 福建省 福州市 150-500人 中国 北京市 北京市 &gt;500人 中国 湖南省 湘西市 &gt;500人 中国 广东省 广州市 &gt;500人 中国 北京市 北京市 &gt;500人 地图制作 将待分析区域维度下的字段【省份】转化为地理角色。如下图所示： 在图表类型下选择【区域地图】，将【省份（经度）】字段拖入横轴，【省份（纬度）字段】拖入纵轴。如下图所示： 将【记录数】拖入颜色栏中，点击【颜色】框体，修改渐变颜色。如下图所示： 设置背景为【幻影黑】 。如下图所示： 【钻取目录】用户可根据实际需求可以实现由省到市的逐级钻取，并对不同省份和区域的数据进行展示，创建从省份钻取到城市的客户分布数据，选择维度下的【省份】字段，将其转换为地理角色 选择【城市】字段转换为地理角色，生成城市的经纬度字段，如下图所示： 经纬度字段转化好以后，将城市字段拖至省份字段处，创建【省份-城市】的钻取目录，自动生成钻取目录的名称，点击确定保存省份和城市将会自动生成经纬度的钻取目录 图表中显示了客户覆盖的省份，但还没能实现钻取的效果，需要我们将创建的钻取目录字段拖至图形属性下:【颜色、标签、提示、细粒度】中的其中任意一个即可。如将该字段拖至细粒度下，如下图所示： 点地图点地图示例【点地图】用于在地理坐标系范围内，将数据生成为几何图形点，主要用于展示地理区域内的空间分布，适合展示一组或多组数据在地理空间的分布状况。 地区数据分析1 合同签约时间 国家 省份 城市 客户名称 合同金额 回款金额 2016-01-18 中国 浙江省 杭州市 浙江臻善科技有限公司 1,200,000 1,200,000 2016-08-01 中国 河南省 郑州市 杭州明佑电子有限公司 100,800 100,800 2016-04-01 中国 陕西省 西安市 西北工业大学 430,000 430,000 2016-01-18 中国 浙江省 杭州市 浙江网新恩普软件有限公司 200,000 200,000 2016-04-08 中国 北京市 北京市 北京瑞翔科技有限公司 200,000 200,000 2016-04-14 中国 上海市 上海市 上海捷穗软件有限公司 200,000 200,000 2016-05-05 中国 重庆市 重庆市 重庆格力销售中心 285,000 285,000 2016-04-21 中国 江苏省 南京市 江苏邮政同达科技 120,000 120,000 2016-06-01 中国 上海市 上海市 95856部队 520,000 520,000 2016-04-29 中国 上海市 上海市 上海创业投资有限公司 240,000 240,000 2016-04-29 中国 上海市 上海市 智动营销策划咨询（上海）有限公司 450,000 450,000 2016-04-25 中国 江苏省 盐城市 盐城邮政局 120,000 120,000 2016-05-04 中国 浙江省 杭州市 杭州银行 1,200,000 1,080,000 2016-04-27 中国 北京市 北京市 建信金融租赁股份有限公司 600,000 600,000 2015-03-22 中国 江苏省 南京市 南京星友田科技发展有限公司 400,000 400,000 2016-06-19 中国 上海市 上海市 上海万序计算机科技有限公司 480,000 480,000 2016-05-25 中国 上海市 上海市 上海万序计算机科技有限公司 480,000 480,000 2016-05-26 中国 上海市 上海市 上海巨一科技发展有限公司 200,000 200,000 2016-05-20 中国 北京市 北京市 北京英诺威尔科技股份有限公司 875,000 787,500 2016-05-20 中国 北京市 北京市 北京普天太力通信科技有限公司 1,400,000 700,000 2016-05-31 中国 北京市 北京市 健康在线教育培训有限公司 280,000 280,000 2016-10-11 中国 江苏省 南京市 南京益康信达 350,000 350,000 2012-06-02 中国 上海市 上海市 上海欣能信息科技发展有限公司 1,576,000 1,400,000 2016-06-22 中国 北京市 北京市 埃而塔（北京）管理技术有限公司 300,000 300,000 2016-06-24 中国 广西壮族自治区 来宾市 柳州欧莱普信息技术有限公司 250,000 250,000 点地图制作 将待分析区域维度下的字段城市转化为【地理角色】，详细操作请参见 维度转化为地理角色，如下图所示： 选择【点地图】，将城市(经度)和城市(纬度)拖入横轴纵轴栏。如下图所示： 将【合同金额】指标拖入到【颜色】，合同金额越大，颜色越深。如下图所示： 点击【颜色】框中的【合同金额】右边的倒三角，设置闪烁动画。如下图所示： 将【合同金额】指标拖入到【大小】，合同金额越大，点的面积越大。如下图所示： 选择【组件样式】，取消勾选【显示全部图例】按钮。如下图所示： 在【组件样式】&gt;【背景】中，设置组件背景GIS为【自定义】&gt;【深蓝】。如下图所示： 流向地图流向地图示例流向地图在地图上显示信息或物体从一个位置到另一个位置的移动及其数量。通常用来显示人物、动物和产品的迁移数据。单一流向线所代表的移动规模或数量由其粗细度表示，有助显示迁移活动的地理分布。 流向地图多应用于区际贸易、交通流向、人口迁移、购物消费行为、通讯信息流动、航空线路等场景，也可应用企业货物运输，供应链管理。 流向地图适合展现地理空间内事物发生位置移动时所对应数据的变化情况。但是不适合展示精确数值。 春运迁徙数据 迁徙线路 编号 城市 迁徙人数 南京市-三亚市 0 南京市 57665 南京市-三亚市 1 三亚市 57665 南京市-中卫市 0 南京市 38596 南京市-中卫市 1 中卫市 38596 南京市-丽水市 0 南京市 374853 南京市-丽水市 1 丽水市 374853 南京市-乌鲁木齐市 0 南京市 13755 南京市-乌鲁木齐市 1 乌鲁木齐市 13755 南京市-九江市 0 南京市 4596 南京市-九江市 1 九江市 4596 南京市-伊春市 0 南京市 5769 南京市-伊春市 1 伊春市 5769 南京市-保定市 0 南京市 42457 南京市-保定市 1 保定市 42457 南京市-克拉玛依市 0 南京市 3755 南京市-克拉玛依市 1 克拉玛依市 3755 南京市-包头市 0 南京市 58533 南京市-包头市 1 包头市 58533 南京市-十堰市 0 南京市 36475 南京市-十堰市 1 十堰市 36475 南京市-南平市 0 南京市 47584 南京市-南平市 1 南平市 47584 南京市-台州市 0 南京市 36586 南京市-台州市 1 台州市 36586 例如，春运迁徙人员的运动路径如下图所示： 流向地图制作 制作地图组件都需要有地理字段，选择【城市下拉】&gt;【地理角色】&gt;【城市】，将【城市】字段与系统的地理信息相匹配。点击【确定】 选择图表类型为【流向地图】，将城市经度字段拖入到横轴，城市纬度字段拖入到纵轴，编号字段拖入到连线属性，迁徙线路和城市字段拖入到细粒度属性。 如下图所示： 细粒度栏中，【迁徙路线】必须在【城市】上方。 将【迁徙人数】拖入颜色栏中，并将渐变方案更改为【极光】，如此迁徙人数的多少就可以映射到连线的颜色上。如下图所示： 点击【连线】栏，设置连线为【曲线】，标记点为【无】。如下图所示： 对连线属性下的【编号】字段选择【下拉】&gt;【特殊显示】&gt;【闪烁动】。如下图所示： 点击【添加】，选择闪烁的时间间隔为 8 秒，点击【确定】。如下图所示： 点开【背景】，将 GIS 背景改为深蓝。如下图所示 热力地图热力地图示例热力地图用于在地理坐标系范围内，将数据转换成颜色色调，并通过颜色变化程度直观反应出热点分布、区域聚集等数据信息。如下图显示了全国各地区环境监测 PM2.5 的数值高低： 全国环境监测数据 监测城市 监测点名称 PM值 北京市 万寿西宫 397 北京市 定陵 207 北京市 东四 365 北京市 天坛 352 北京市 农展馆 341 北京市 官园 343 天津市 勤俭路 322 天津市 前进路 273 天津市 北辰科技园 325 天津市 跃进路 278 天津市 第四大街 215 石家庄市 职工医院 448 石家庄市 高新区 473 石家庄市 西北水源 545 石家庄市 西南高教 492 石家庄市 世纪公园 513 唐山市 供销社 297 唐山市 雷达站 333 唐山市 物资局 319 唐山市 十二中 321 秦皇岛市 第一关 255 秦皇岛市 市政府 224 秦皇岛市 建设大厦 275 邯郸市 环保局 395 邯郸市 东污水处理厂 352 邯郸市 矿院 287 热力地图制作 将待分析区域维度下的字段监测城市转化为地理角色，详细操作请参见 维度转化为地理角色。如下图所示： 在图表类型下选择【热力地图】，将【监测城市（经度）】字段拖入横轴，【监测城市（纬度）】字段拖入纵轴。如下图所示： 将需要展示的【PM值】指标拖入热力色，【监测点名称】拖入细粒度。如下图所示： 点击【热力色】框体，在弹出的渐变方案中，选择【秋落】。如下图所示： 聚合气泡图聚合气泡图示例【聚合气泡图】采用力学图的形式展示气泡，可以用来观察数据的分布，将数据映射到气泡的面积大小上。聚合气泡图展示效果如下图所示，用户根据下图可以直观观察出「江苏、上海、山西」的录取人数最多。适用于处理值的分布和数据点的分簇。但是不适合用来查看具体数值，只适合看数据分布。 各省招生人数表 地区 年份 计划招生 实际录取 北京市 2009年 63 47 北京市 2010年 50 48 北京市 2011年 69 42 北京市 2012年 54 43 北京市 2013年 58 40 北京市 2014年 66 47 北京市 2015年 64 41 北京市 2016年 61 47 北京市 2017年 62 47 北京市 2018年 58 44 天津市 2009年 74 44 天津市 2010年 54 39 天津市 2011年 66 49 天津市 2012年 57 46 天津市 2013年 56 48 天津市 2014年 59 38 聚合气泡图制作 将待分析区域维度下的字段地区拖入维度中，将指标下的字段实际录取拖入指标中，再到图表类型中【选择聚合气泡图】。如下图所示： 将维度字段地区拖入到颜色栏，使不同分类的数据点显示为不同的颜色 选择组件样式，取消显示图例，如下图所示： 点击组件样式的大小栏中的【实际录取(求和)】字段，在下拉中选择特殊显示，选择注释，如下图所示： 点击添加条件(且)，选择实际录取(求和)最大的N个，在N&#x3D;中填入3，并到右侧+按钮中选择显示【地区】字段： 变色表格变色表格示例颜色表格用于展示对应不同维度分类的不同文字颜色，可以用清晰的颜色显示不同维度的数值。但是不适用于维度太多的场景。如下方的合同类型表，使用不同的颜色展示合同是否已经交货，效果如下图所示： 合同事实表 合同签约时间 注册时间 合同ID 合同付款类型 合同类型 客户ID 是否已经交货 购买的产品 购买数量 合同金额 2017-03-07 2016-07-28 00115727-e145-44c0-9102-110523699369 一次性付款 购买合同 ff61dfee-1c56-48b6-9f7b-21abef64c96f 否 6 1 90,000 2017-07-09 2016-08-24 03374c0e-59d1-4158-8ab5-67b48d80d84e 一次性付款 购买合同 d9c85691-1c10-4ef9-8b42-98e1637cab77 是 5 1 180,000 2017-09-19 2017-09-19 04289ab3-08e3-49d3-9582-4dbb945233e7 一次性付款 购买合同 901aa1ba-ff07-4ff7-a836-4821219c9aae 是 2 1 180,000 2017-03-30 2016-08-11 04897502-5828-4273-8184-553aa0562930 一次性付款 购买合同 88d567a8-feab-4ce5-8b8a-0cb7f5840179 是 2 1 260,000 2017-07-27 2016-10-24 056c2ca7-a186-40a4-a8a6-01b38151df57 一次性付款 购买合同 9d7ce8a7-5f9a-4087-be3e-2ed0edf53709 否 2 1 500,000 2016-09-21 2017-09-26 05bf042a-27f8-4e66-bc0c-9638145fd756 分期付款 购买合同 74643073-3ca1-4cf4-b921-af3e9c83702b 否 2 1 600,000 2016-04-07 2017-08-03 0692a164-8159-4dda-901b-4003f432d41c 一次性付款 购买合同 de4b48c5-93b6-4af1-abd9-bc4e4499fb11 是 1 1 130,000 2017-03-27 2017-05-06 080a241d-7372-4921-b171-b9ed2d4a9dd6 一次性付款 服务协议 0e4cf623-44dd-470a-8a39-5bc705c5faf5 是 6 1 210,000 2017-08-05 2017-08-17 080cd368-af54-447a-a3ae-051425c84bc1 一次性付款 购买合同 6370dee7-6d96-4881-9014-2ba42b674051 否 3 1 720,000 2016-03-12 2017-08-09 087bab2a-7b5e-4304-808a-830b68556cee 一次性付款 购买合同 ec8cec0b-012f-4b58-84ff-0c889e98f1a0 是 5 1 150,000 2017-05-13 2016-08-25 08ce15be-bbfd-4c9b-b18f-39eb03e471ca 分期付款 购买合同 456419b5-d3c7-499b-b07b-b868cc68634e 是 5 1 320,000 2016-08-05 2016-08-17 0a392e38-b72f-46ad-b713-a19e06f6f46e 一次性付款 购买合同 ef35dd55-5306-4380-88ff-5db8847f07be 否 3 1 200,000 2017-01-05 2016-08-12 0a481a95-5f8f-4a2f-acac-711dcd77ed80 一次性付款 长期协议订单 e210c77c-f1c3-44d2-ad08-fb1b36a8499f 是 1 3 270,000 2017-10-15 2016-11-15 0c6e4368-0572-40e6-978e-de72b8997d15 分期付款 购买合同 1fb823f6-209e-4484-9919-8844e2e09135 否 3 1 350,000 2016-05-25 2016-08-23 0cdfd271-6a40-432a-ac04-fcf0e3e029dd 一次性付款 购买合同 5917ef9b-f554-4364-b0ba-524bc7eee0db 是 3 1 100,000 颜色表格制作 将待分析区域维度下的字段【合同类型】、【合同付款类型】拖入维度中，将指标下的字段【合同金额】拖入指标中，并在图表类型下选择【颜色表格】。如下图所示： 迷你图迷你图示例示例迷你图可以直观清晰的展现各分类的对应指标数值大小，且简单易行，用于突出显示变量数据的特征。但是变化较为单一，只适合显示单变量。比如下图展示的各访问渠道的浏览量大小。如下图所示 互联网渠道统计数据 统计日期 地区 二级渠道名 三级渠道名 一级渠道名 用户名称 访问次数 浏览量 跳出次数 总停留时间 2015-09-01 不详市 基础上线工作 AppStore 线上渠道 雪莉尔 6 10 4 1,656 2015-09-01 阳江市 微信推广 微信互推 新媒体营销 Benedicte 5 6 4 648 2015-09-01 市辖区 微博推广 内容推广 新媒体营销 Abigale 5 14 4 1,512 2015-09-01 长春市 微信推广 微信互推 新媒体营销 Katherine 2 12 4 1,728 2015-09-01 朝阳市 基础上线工作 Wap 线上渠道 Adalin 5 9 4 1,548 2015-09-01 莱芜市 品牌基础推广 百科类 新媒体营销 Poppy 3 12 4 1,440 2015-09-02 不详市 微博推广 活动推广 新媒体营销 Dark Comet 3 12 4 1,008 2015-09-02 中山市 水货刷机 水货刷机 线下渠道 Ada 2 15 4 1,260 2015-09-03 定西市 轮台、贴吧推广 魔趣网 新媒体营销 Adah 2 10 4 396 2015-09-03 清远市 轮台、贴吧推广 魔趣网 新媒体营销 Brewster 2 8 4 432 2015-09-03 中山市 轮台、贴吧推广 机锋论坛 新媒体营销 Bunny 3 14 4 1,116 2015-09-03 金昌市 基础上线工作 Wap 线上渠道 Bryana 5 12 4 288 2015-09-03 商洛市 轮台、贴吧推广 机锋论坛 新媒体营销 Beatrice 6 8 4 756 2015-09-04 阜阳市 手机厂商预装 手机厂商预装 线下渠道 Bethel 1 10 4 648 2015-09-04 新竹市 水货刷机 水货刷机 线下渠道 Abrianna 1 14 4 792 2015-09-04 铁岭市 微信推广 小号积累 新媒体营销 Caitlin 5 6 4 396 2015-09-04 清远市 轮台、贴吧推广 魔趣网 新媒体营销 希尔顿 5 10 4 1,584 迷你图制作 将待分析区域维度下的字段【一级渠道名】、【二级渠道名】拖入维度中，将指标下的字段浏览量拖入指标中，在图表类型下选择【迷你图】。如下图所示： 选择该图表类型后，【浏览量】字段被添加到大小属性中。如下图所示： 点击形状，可以为数据点选择不同的形状。如下图所示： 矩形树图矩形树图示例矩形树图是用来描述层次结构数据的占比关系，能够进行逐级钻取显示下层数据情况。用于展示具有层级关系的数据，能够直观体现同级之间的比较，但是不适合层级关系不明确或者分类较多的数据 例如展示合同金额的情况：同一种颜色表示一个年份，同一种颜色种的每一个方块代表一类产品。哪一年哪一种产品的合同金额的大小可以通过矩形块的大小直观展示。效果如下图所示： KPI指标项 合同签约时间 产品名称 购买数量 合同金额 回款金额 2016-01-18 宝钢罗泾预矫直机 1 1,200,000 1,200,000 2016-08-01 梅钢1650连铸 1 100,800 100,800 2016-04-01 宝钢罗泾预矫直机 1 430,000 430,000 2016-01-18 梅钢1650连铸 1 200,000 200,000 2016-04-08 俄罗斯N钢牌坊 1 200,000 200,000 2016-04-14 梅钢1650连铸 1 200,000 200,000 2016-05-05 俄罗斯N钢牌坊 1 285,000 285,000 2016-04-21 宝钢罗泾预矫直机 1 120,000 120,000 2016-06-01 涟钢RH氧枪备件 1 520,000 520,000 2016-04-29 梅钢1650连铸 1 240,000 240,000 2016-04-29 俄罗斯N钢牌坊 1 450,000 450,000 2016-04-25 宝钢罗泾预矫直机 1 120,000 120,000 2016-05-04 福建福欣热轧 1 1,200,000 1,080,000 2016-04-27 宝钢罗泾预矫直机 1 600,000 600,000 2015-03-22 俄罗斯N钢牌坊 1 400,000 400,000 2016-06-19 俄罗斯N钢牌坊 1 480,000 480,000 矩形树图制作 将待分析区域维度下的合同签约时间、产品名称拖入维度中，将指标下的字段合同金额拖入指标中： 在图表类型下选择【矩形树图】，选择该图表类型后，维度字段按照顺序被添加到细粒度中，指标字段添加到大小属性中。如下图所示： 将【合同签约时间】移动至颜色栏，点击下拉箭头，切换至年显示，如下图所示： 此处矩形树图的排列逻辑为：从左上到右下，依次表示数值从大到小。在没有大小比较时，排列顺序为总是选择矩形块长宽比接近于1的方式排布，排序方式默认不支持更改。 词云词云示例词云是一种直观展示数据频率的图表类型，可以对出现频率较高的「关键词」予以视觉上的突出，形成「关键词云层」，从而过滤掉大量的文本信息，使浏览者只要一眼扫过文本就可以领略重点。适合展现数据量区分度较大的多分类文字数据，直观地表现出现高词频内容。但是不适合展示数据区分度不大的数据。 可应用于制作用户画像，对用户进行聚类，分析话题热度，实现精细化营销等。如下图所示： 搜索词汇统计表 搜索词 搜索次数 FineBI 3,266 Spider 3,044 帆软 1,710 仪表板 455 数据挖掘 512 快速挖掘 220 R语言分析 313 时序预测 248 聚类 280 分类 175 行业化 654 生态圈 1,110 数据决策系统 477 矩形树图 436 数据库 387 论坛 1,510 词云制作 将【搜索词】字段拖入维度栏中，【搜索次数】字段拖入指标栏中，在图表类型下选择【词云】。如下图所示： 选择词云图表类型后，【搜索次数】字段被添加到大小属性中，【搜索词】字段被添加到文本字段中。如下图所示： 将【搜索次数】字段拖入到颜色属性栏中，渐变类型选择【区域渐变】，渐变方案选择【极光】。如下图所示： 点击【大小】栏，可以调整词云文字的字号大小。如下图所示： 漏斗图漏斗图示例漏斗图是一种直观表现业务流程中转化情况的分析工具。 漏斗图适用于业务流程比较规范、周期长、环节多的流程分析，使用梯形面积表示某个环节业务量与上一个环节之间的差异。适用于展示随流程变化的分类数据。但是不适合表示无逻辑顺序的分类对比。 漏斗图从上到下，有逻辑上的顺序关系，表现了随着业务流程的推进业务目标完成的情况。如下图所示： 漏斗图示例数据 步骤 人数 查看商品 12452 试用商品 7832 咨询价格 5678 发送合同 4563 购买商品 2354 漏斗图制作 将【步骤】字段拖入到维度中，将【人数】字段拖入到指标中。再到图表类型下选择【漏斗图】。 在细粒度栏对【步骤】按人数进行降序。如下图所示： 设置标签，在标签栏拖入【步骤】、【人数】字段。如下图所示： 箱形图&#x2F;箱线图箱形图&#x2F;箱线图示例箱形图（Box-plot）又称为盒须图、盒式图或箱线图，是一种用作显示一组数据分散情况资料的统计图，因形状如箱子而得名。在各种领域也经常被使用，常见于品质管理。它主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比较。通过箱形图我们可以观察数据是否有偏向性、是否对称、数据是否有异常值、数据分布是否太过密集等。 当需要了解数据分布特征或需要查看数据中的异常值时，可以使用箱形图进行数据分析。箱形图最常见用于质量管理、人事测评、探索性数据分析等统计分析活动。 箱型图通常用于显示一组连续型数据分布情况的统计图。但是不适用批量较大的数据；不适用于表示趋势或者百分比的数据。 箱型图最大的优点就是不受异常值的影响，能准确稳定地描绘出数据的离散分布情况。 箱形图构成：箱子的中间有一条线，代表了数据的中位数( Q2 )。箱子的上下底，分别是数据的上四分位数（Q3）和下四分位数（Q1），这意味着箱体包含了 50% 的数据。 有关箱形图 Q1、Q2、Q3 这三个指标的介绍和计算方法，详情参见统计学概念 四分位数 因此，箱子的高度在一定程度上反映了数据的波动程度。上下边缘则代表了该组数据的最大值和最小值。超出最大值和低于最小值的点，可以理解为数据中的“异常值”。 销量表 省份 城市 销量 河南省 郑州 130987 河南省 驻马店 119234 江苏省 南京 143567 江苏省 无锡 167890 浙江省 杭州市 245671 浙江省 宁波市 198764 湖南省 长沙市 167893 湖南省 岳阳市 123456 箱形图&#x2F;箱线图制作案例一 不显示异常值 在图表类型下选择【箱形图】，将【省份】字段拖入到横轴中，【销量】字段拖入到纵轴中，【城市】字段拖入到细粒度中。如下图所示： 将【省份】字段拖入到颜色栏中。如下图所示： 案例二 显示异常值合同事实表1 合同签约时间 注册时间 合同ID 合同付款类型 合同类型 客户ID 是否已经交货 购买的产品 购买数量 总金额 2017-03-07 2016-07-28 00115727-e145-44c0-9102-110523699369 一次性付款 购买合同 ff61dfee-1c56-48b6-9f7b-21abef64c96f 否 6 1 90,000 2017-07-09 2016-08-24 03374c0e-59d1-4158-8ab5-67b48d80d84e 一次性付款 购买合同 d9c85691-1c10-4ef9-8b42-98e1637cab77 是 5 1 180,000 2017-09-19 2017-09-19 04289ab3-08e3-49d3-9582-4dbb945233e7 一次性付款 购买合同 901aa1ba-ff07-4ff7-a836-4821219c9aae 是 2 1 180,000 2017-03-30 2016-08-11 04897502-5828-4273-8184-553aa0562930 一次性付款 购买合同 88d567a8-feab-4ce5-8b8a-0cb7f5840179 是 2 1 260,000 2017-07-27 2016-10-24 056c2ca7-a186-40a4-a8a6-01b38151df57 一次性付款 购买合同 9d7ce8a7-5f9a-4087-be3e-2ed0edf53709 否 2 1 500,000 2016-09-21 2017-09-26 05bf042a-27f8-4e66-bc0c-9638145fd756 分期付款 购买合同 74643073-3ca1-4cf4-b921-af3e9c83702b 否 2 1 600,000 2016-04-07 2017-08-03 0692a164-8159-4dda-901b-4003f432d41c 一次性付款 购买合同 de4b48c5-93b6-4af1-abd9-bc4e4499fb11 是 1 1 130,000 2017-03-27 2017-05-06 080a241d-7372-4921-b171-b9ed2d4a9dd6 一次性付款 服务协议 0e4cf623-44dd-470a-8a39-5bc705c5faf5 是 6 1 210,000 2017-08-05 2017-08-17 080cd368-af54-447a-a3ae-051425c84bc1 一次性付款 购买合同 6370dee7-6d96-4881-9014-2ba42b674051 否 3 1 720,000 2016-03-12 2017-08-09 087bab2a-7b5e-4304-808a-830b68556cee 一次性付款 购买合同 ec8cec0b-012f-4b58-84ff-0c889e98f1a0 是 5 1 150,000 2017-05-13 2016-08-25 08ce15be-bbfd-4c9b-b18f-39eb03e471ca 分期付款 购买合同 456419b5-d3c7-499b-b07b-b868cc68634e 是 5 1 320,000 2016-08-05 2016-08-17 0a392e38-b72f-46ad-b713-a19e06f6f46e 一次性付款 购买合同 ef35dd55-5306-4380-88ff-5db8847f07be 否 3 1 200,000 2017-01-05 2016-08-12 0a481a95-5f8f-4a2f-acac-711dcd77ed80 一次性付款 长期协议订单 e210c77c-f1c3-44d2-ad08-fb1b36a8499f 是 1 3 270,000 2017-10-15 2016-11-15 0c6e4368-0572-40e6-978e-de72b8997d15 分期付款 购买合同 1fb823f6-209e-4484-9919-8844e2e09135 否 3 1 350,000 2016-05-25 2016-08-23 0cdfd271-6a40-432a-ac04-fcf0e3e029dd 一次性付款 购买合同 5917ef9b-f554-4364-b0ba-524bc7eee0db 是 3 1 100,000 图表类型下选择【自定义图表】，将【合同类型】字段拖入横轴，【购买的产品】字段拖进纵轴两次。图形属性下，两个指标字段，图表类型分别选择【箱形图】和【点】。如下图所示： 图形属性下，点开【全部】，将【客户ID】字段拖入细粒度中。如下图所示： 在图形属性下，点开对应点类型的指标字段，调整点大小。如下图所示： 设置纵轴最大值为 60 ，如下图所示： 结论：购买合同和长期协议订单，存在异常点，需要对异常值进行关注 桑基图桑基图示例桑基图多用于表示数据的流向。用两组数据构成多个坐标点，考察坐标点的分布，判断多变量之间是否存在某种关联或总结坐标点的分布模式。通常应用于能源、材料成分、金融和网站用户流量等数据的可视化分析。桑基图使人们易于发现系统流程中的细节；帮助识别主要的组成部分和低效的地方。但是不适用于起始流量和结束流量不同的数据 例如，有一家做海鲜批发生意的供应商，给全国各地的门店根据订单要求发货。商家想要预测未来哪些海鲜需要多补充库存，但不知道订单的情况，到底哪些海鲜的订单较多，都卖到了哪里。 现在想分析一下销售最好的5款海鲜是哪几个，都是在哪些门店卖出去的。我们通过桑基图，能看到每个产品，流向的门店，线的粗细，代表流向的多少。如下图所示：【区域地图】是一种使用不同深浅的颜色来展示数据的大小和分布范围的可视化图形。适合展示数据在地理区块空间的分布状况，使用颜色深浅来区分数值大小。 订单销售明细表 订单日期 发货日期 产品编码 产品名称 门店编号 门店名称 订单编号 订单金额 实付金额 2022-01-01 2022-01-01 B012 龙虾 A0005 杭州店 10,130,478,523 3,739 3,176 2022-01-01 2022-01-01 B015 黄鱼 A0001 深圳店 10,130,478,536 497 371 2022-01-01 2022-01-01 B002 鱿鱼 A0003 北京店 10,130,478,559 986 677 2022-01-01 2022-01-04 B011 墨鱼 A0001 深圳店 10,130,478,576 2,020 1,727 2022-01-01 2022-01-01 B017 干贝 A0005 杭州店 10,130,478,578 322 267 2022-01-01 2022-01-02 B009 虾米 A0001 深圳店 10,130,478,582 180 152 2022-01-01 2022-01-01 B011 墨鱼 A0004 广州店 10,130,478,635 813 547 2022-01-01 2022-01-05 B017 干贝 A0003 北京店 10,130,478,640 705 511 2022-01-02 2022-01-04 B009 虾米 A0001 深圳店 10,130,478,666 220 154 2022-01-02 2022-01-03 B004 盐水鸭 A0003 北京店 10,130,478,673 169 127 2022-01-02 2022-01-02 B001 猪肉 A0002 上海店 10,130,478,681 779 499 2022-01-02 2022-01-02 B007 蟹 A0004 广州店 10,130,478,691 6,833 5,257 2022-01-02 2022-01-03 B016 海参 A0004 广州店 10,130,478,693 6,149 3,877 2022-01-02 2022-01-03 B001 猪肉 A0001 深圳店 10,130,478,714 403 379 2022-01-02 2022-01-03 B012 龙虾 A0001 深圳店 10,130,478,732 4,913 4,712 2022-01-02 2022-01-02 B008 虾子 A0005 杭州店 10,130,478,734 633 396 桑基图制作 在图表类型下选择「桑基图」，将「产品名称」字段拖入到起点栏，「门店名称」字段拖入到终点栏，「订单金额」字段拖入到大小栏。如下图所示： 数据表中的 0 值或负值会过滤不绘制。 下拉【产品名称】，添加过滤条件，过滤出【订单金额】最大的 5 个产品。如下图所示： 用不同颜色区分不同产品流向。将【产品名称】字段拖入到颜色栏中。如下图所示： 添加起点终点的图形标签。点击【标签设置】&gt;【显示节点名称】。如下图所示： 多节点示例桑基图 source target 人数 男 华为 1,100 男 苹果 730 男 小米 680 男 OPPO 630 男 vivo 530 男 其他 1,630 女 华为 680 女 苹果 1,080 女 小米 370 女 OPPO 850 女 vivo 630 女 其他 1,090 华为 45岁以上 135 华为 35-44岁 319 华为 25-34岁 986 source：表示数据流出的起点 target：表示数据流向的终点 人数：衡量流量的大小 例如，从【性别&gt;使用的手机品牌&gt;年龄】的手机使用人群的流量分析。手机品牌既是起点也是终点，在【source】(来源）会存在多次数据。 依次拖入【source、target、人】」字段。因为人数是从 source 流向 target ，所以 source 在前面。如下图所示： 点击【桑基图】，自动生成图表，字段调整到对应位置。这样就生成了多节点桑基图如下图所示： ​ 若希望显示节点名称，在【图表属性】点击【标签】设置【显示节点名称】即可。 表格分组表分组表示例分组表是有一个【行表头维度】和【数值指标数据】组成的分组报表，没有列表头。 集团销售总表 日期 城市 单据编码 门店编码 门店名称 商品编码 商品类别 商品名称 省份 成本额 数量 销售额 2020-01-01 白山市 SMDBJ18000010 D010112 白山店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 鹤岗市 SMDBJ18000014 D010114 鹤岗店 62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6 零食 三全960g奶香馒头 黑龙江省 998.56 120 2,461.54 2020-01-01 鹤岗市 SMDBJ18000014 D010114 鹤岗店 BE2DA7F0-1E24-4729-BED3-3CDC0A2E4918 零食 嘉士利115g威化饼 黑龙江省 1,033.47 100 3,119.66 2020-01-01 辽源市 SMDBJ18000015 D010115 辽源店 62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6 零食 三全960g奶香馒头 吉林省 1,664.27 200 4,102.56 2020-01-01 辽源市 SMDBJ18000015 D010115 辽源店 AE451BC0-8615-4F8C-8126-05E0C01DDF24 零食 丽芝士散装系列 吉林省 950.36 100 2,948.72 2020-01-01 辽源市 SMDBJ18000015 D010115 辽源店 77DA67A0-ED8C-4FB3-8E04-E9EA7DD96BE8 零食 养乐多100ml*5乳酸菌 吉林省 573.88 50 2,094.02 2020-01-01 辽源市 SMDBJ18000015 D010115 辽源店 BE2DA7F0-1E24-4729-BED3-3CDC0A2E4918 零食 嘉士利115g威化饼 吉林省 516.73 50 1,559.83 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 12EF7049-C847-4A7F-A5B4-C0BEDDADAA81 生鲜 西红柿 吉林省 240.17 12 605.13 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 59F35931-24BA-46DC-9551-6744A16FC87B 生鲜 本地小白菜 吉林省 542.68 40 2,017.09 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 E5EA2E2A-DC19-4D47-BF0F-F29CC467A5C0 日用品 家之寓圆形24夹晒架 吉林省 252 100 1,025.64 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 E5EA2E2A-DC19-4D47-BF0F-F29CC467A5C0 日用品 家之寓圆形24夹晒架 吉林省 26.23 10 135.9 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6 零食 三全960g奶香馒头 吉林省 1,248.2 150 3,076.92 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 AE451BC0-8615-4F8C-8126-05E0C01DDF24 零食 丽芝士散装系列 吉林省 1,425.54 150 4,423.08 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 77DA67A0-ED8C-4FB3-8E04-E9EA7DD96BE8 零食 养乐多100ml*5乳酸菌 吉林省 1,342.88 117 4,900 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 CBB40A41-178E-44F7-BD5E-9ECD8B73978A 零食 格力高55g草莓味百奇 吉林省 309.43 21 807.69 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 分组表按照行表头拖拽的维度分组，对指标内的数据进行汇总统计。如下图所示： 分组表制作 在图表类型中选择【分组表】，将【品类描述】、【店风格】字段拖入维度区域，将【销售额】、【记录数】字段拖入指标区域，并在【组件样式&gt;格式】中，【展开行表头节点】，如下图所示： 创建毛利额字段 点击【…】,【添加计算字段】，创建毛利额字段，公式如下图所示： 设置组件样式 若需要设置表格的展示方式，可选择【组件样式】，根据自己的需求设置，如下图所示： 修改组件名称 在组件编辑下方重命名组件标题，如下图所示： 交叉表交叉表示例交叉表是指由「行维度」、「列维度」以及「数值区域」组成的较为复杂的报表。 用户多用来显示表中某个字段的汇总值，并将它们分组。其中一组为行维度-在数据表的左侧，另一组列维度-在数据表的上部。行和列的交叉处即「数值区域」可以对数据进行多种汇总计算，比如求和、平均值、记数、最大值、最小值等。 合同事实表： 合同ID 客户ID 合同类型 合同金额 合同付款类型 注册时间 购买数量 合同签约时间 购买的产品 是否已经交货 00115727-e145-44c0-9102-110523699369 ff61dfee-1c56-48b6-9f7b-21abef64c96f 购买合同 90,000 一次性付款 2016-07-28 1 2017-03-07 6 否 03374c0e-59d1-4158-8ab5-67b48d80d84e d9c85691-1c10-4ef9-8b42-98e1637cab77 购买合同 180,000 一次性付款 2016-08-24 1 2017-07-09 5 是 04289ab3-08e3-49d3-9582-4dbb945233e7 901aa1ba-ff07-4ff7-a836-4821219c9aae 购买合同 180,000 一次性付款 2017-09-19 1 2017-09-19 2 是 04897502-5828-4273-8184-553aa0562930 88d567a8-feab-4ce5-8b8a-0cb7f5840179 购买合同 260,000 一次性付款 2016-08-11 1 2017-03-30 2 是 056c2ca7-a186-40a4-a8a6-01b38151df57 9d7ce8a7-5f9a-4087-be3e-2ed0edf53709 购买合同 500,000 一次性付款 2016-10-24 1 2017-07-27 2 否 05bf042a-27f8-4e66-bc0c-9638145fd756 74643073-3ca1-4cf4-b921-af3e9c83702b 购买合同 600,000 分期付款 2017-09-26 1 2016-09-21 2 否 0692a164-8159-4dda-901b-4003f432d41c de4b48c5-93b6-4af1-abd9-bc4e4499fb11 购买合同 130,000 一次性付款 2017-08-03 1 2016-04-07 1 是 080a241d-7372-4921-b171-b9ed2d4a9dd6 0e4cf623-44dd-470a-8a39-5bc705c5faf5 服务协议 210,000 一次性付款 2017-05-06 1 2017-03-27 6 是 080cd368-af54-447a-a3ae-051425c84bc1 6370dee7-6d96-4881-9014-2ba42b674051 购买合同 720,000 一次性付款 2017-08-17 1 2017-08-05 3 否 087bab2a-7b5e-4304-808a-830b68556cee ec8cec0b-012f-4b58-84ff-0c889e98f1a0 购买合同 150,000 一次性付款 2017-08-09 1 2016-03-12 5 是 08ce15be-bbfd-4c9b-b18f-39eb03e471ca 456419b5-d3c7-499b-b07b-b868cc68634e 购买合同 320,000 分期付款 2016-08-25 1 2017-05-13 5 是 0a392e38-b72f-46ad-b713-a19e06f6f46e ef35dd55-5306-4380-88ff-5db8847f07be 购买合同 200,000 一次性付款 2016-08-17 1 2016-08-05 3 否 0a481a95-5f8f-4a2f-acac-711dcd77ed80 e210c77c-f1c3-44d2-ad08-fb1b36a8499f 长期协议订单 270,000 一次性付款 2016-08-12 3 2017-01-05 1 是 0c6e4368-0572-40e6-978e-de72b8997d15 1fb823f6-209e-4484-9919-8844e2e09135 购买合同 350,000 分期付款 2016-11-15 1 2017-10-15 3 否 0cdfd271-6a40-432a-ac04-fcf0e3e029dd 5917ef9b-f554-4364-b0ba-524bc7eee0db 购买合同 100,000 一次性付款 2016-08-23 1 2016-05-25 3 是 0dc1c555-2eb2-4d8e-9ee4-50e96688e6a6 0ef33a04-1464-417a-a976-01f41ba0b97e 长期协议 0 分期付款 2016-08-24 0 2016-09-01 5 是 0e2329e4-af5e-4bbc-8ea2-2b13d7f4b4eb 7ec522c2-ad8f-4018-8744-290b34bc175e 购买合同 50,000 一次性付款 2016-08-23 1 2017-06-19 3 是 0fb2bba0-ea35-42b0-8e03-1750962d64c1 16dcafcf-97b2-4380-967a-0058fccdd9fd 购买合同 380,000 分期付款 2017-01-26 1 2016-12-22 2 是 交叉表制作 在图表类型选择「交叉表」，将待分析区域的「合同类型」、「合同签约时间」拖入行维度；「合同付款类型」拖入列维度；「合同金额」拖入指标栏，如下图所示： 创建字段 点击合同签约时间字段下拉框，选择按「年」分组显示，如下图所示： 设置组件样式 表格属性为设置表格中指定文字颜色和文字旁的图标标记，包括颜色和形状 颜色修改： 【表格属性】&gt;【颜色】可设置指定范围内的指标颜色。例如，将【合同金额】拖入表格属性下的颜色栏，并点击【颜色】栏，添加条件。设置值在【2000000-无限制】之间的【合同金额】显示为红色，如下图所示： 形状修改：【表格属性】&gt;【形状】可设置字段旁的图标标记，可设置根据不同条件来显示不同标记及颜色。例如，将拖入表格属性下的形状栏中，并点击「形状」栏，设置形状和数值如下图所示： 明细表明细表，用于展示报表明细数据 特点： 可以展示数据的详细信息 不适合展示多维度数据 不支持数据汇总 明细表示例集团销售总表 日期 城市 单据编码 门店编码 门店名称 商品编码 商品类别 商品名称 省份 成本额 数量 销售额 2020-01-01 白山市 SMDBJ18000010 D010112 白山店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 鹤岗市 SMDBJ18000014 D010114 鹤岗店 62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6 零食 三全960g奶香馒头 黑龙江省 998.56 120 2,461.54 2020-01-01 鹤岗市 SMDBJ18000014 D010114 鹤岗店 BE2DA7F0-1E24-4729-BED3-3CDC0A2E4918 零食 嘉士利115g威化饼 黑龙江省 1,033.47 100 3,119.66 2020-01-01 辽源市 SMDBJ18000015 D010115 辽源店 62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6 零食 三全960g奶香馒头 吉林省 1,664.27 200 4,102.56 2020-01-01 辽源市 SMDBJ18000015 D010115 辽源店 AE451BC0-8615-4F8C-8126-05E0C01DDF24 零食 丽芝士散装系列 吉林省 950.36 100 2,948.72 2020-01-01 辽源市 SMDBJ18000015 D010115 辽源店 77DA67A0-ED8C-4FB3-8E04-E9EA7DD96BE8 零食 养乐多100ml*5乳酸菌 吉林省 573.88 50 2,094.02 2020-01-01 辽源市 SMDBJ18000015 D010115 辽源店 BE2DA7F0-1E24-4729-BED3-3CDC0A2E4918 零食 嘉士利115g威化饼 吉林省 516.73 50 1,559.83 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 12EF7049-C847-4A7F-A5B4-C0BEDDADAA81 生鲜 西红柿 吉林省 240.17 12 605.13 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 59F35931-24BA-46DC-9551-6744A16FC87B 生鲜 本地小白菜 吉林省 542.68 40 2,017.09 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 E5EA2E2A-DC19-4D47-BF0F-F29CC467A5C0 日用品 家之寓圆形24夹晒架 吉林省 252 100 1,025.64 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 E5EA2E2A-DC19-4D47-BF0F-F29CC467A5C0 日用品 家之寓圆形24夹晒架 吉林省 26.23 10 135.9 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6 零食 三全960g奶香馒头 吉林省 1,248.2 150 3,076.92 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 AE451BC0-8615-4F8C-8126-05E0C01DDF24 零食 丽芝士散装系列 吉林省 1,425.54 150 4,423.08 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 77DA67A0-ED8C-4FB3-8E04-E9EA7DD96BE8 零食 养乐多100ml*5乳酸菌 吉林省 1,342.88 117 4,900 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 CBB40A41-178E-44F7-BD5E-9ECD8B73978A 零食 格力高55g草莓味百奇 吉林省 309.43 21 807.69 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 松原市 SMDBJ18000016 D010116 松原店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 吉林省 641.03 30 1,076.92 2020-01-01 鞍山市 SMDBJ18000024 D010120 鞍山店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 辽宁省 598.29 28 1,005.13 2020-01-01 鞍山市 SMDBJ18000024 D010120 鞍山店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 辽宁省 170.94 8 287.18 2020-01-01 鞍山市 SMDBJ18000024 D010120 鞍山店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 辽宁省 512.82 24 861.54 2020-01-01 苏州市 SMDSH18000071 D010229 苏州店 5DDCE422-6782-43D2-9AC6-0E28ABA93636 生鲜 西域香妃蜜瓜 江苏省 318.55 5 1,102.56 2020-01-01 苏州市 SMDSH18000071 D010229 苏州店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 江苏省 641.03 30 1,076.92 2020-01-01 上海市 SMDSH18000075 D010231 上海店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 上海市 213.68 10 358.97 2020-01-01 上海市 SMDSH18000090 D010231 上海店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 上海市 641.03 30 1,076.92 2020-01-01 上海市 SMDSH18000090 D010231 上海店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 上海市 427.35 20 717.95 2020-01-01 上海市 SMDSH18000093 D010231 上海店 BC639DE8-B503-437C-9B6B-F0B598052A65 日用品 微爽日用245mm 上海市 641.03 30 1,076.92 2020-01-01 温州市 SMDSH18000336 D010243 温州店 62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6 零食 三全960g奶香馒头 浙江省 1,579.64 170 3,487.18 如下图所示： 明细表制作 选择图表类型为【明细表】，再将左侧的字段拖入数据栏，如下图所示： 设置分页行数 有时用户希望能自定义明细表分页行数、或者希望能实现点击翻页查看数据，可在「组件样式&gt;格式」中直接输入希望设置的分页行数即可进行调整，输入 1000，如下图所示： 指标卡指标卡图例KPI 指标卡为直观展示 KPI 数值的组件，可直接显示所选字段的数值，比如展示销售额、毛利、毛利率等指标数值。 特点：适合突出显示重要指标，但是仅能展示文本 效果如下图所示： 地区数据分析 合同签约时间 国家 省份 城市 客户名称 合同金额 回款金额 2016-01-18 中国 浙江省 杭州市 浙江臻善科技有限公司 1,200,000 1,200,000 2016-08-01 中国 河南省 郑州市 杭州明佑电子有限公司 100,800 100,800 2016-04-01 中国 陕西省 西安市 西北工业大学 430,000 430,000 2016-01-18 中国 浙江省 杭州市 浙江网新恩普软件有限公司 200,000 200,000 2016-04-08 中国 北京市 北京市 北京瑞翔科技有限公司 200,000 200,000 2016-04-14 中国 上海市 上海市 上海捷穗软件有限公司 200,000 200,000 2016-05-05 中国 重庆市 重庆市 重庆格力销售中心 285,000 285,000 2016-04-21 中国 江苏省 南京市 江苏邮政同达科技 120,000 120,000 2016-06-01 中国 上海市 上海市 95856部队 520,000 520,000 2016-04-29 中国 上海市 上海市 上海创业投资有限公司 240,000 240,000 2016-04-29 中国 上海市 上海市 智动营销策划咨询（上海）有限公司 450,000 450,000 2016-04-25 中国 江苏省 盐城市 盐城邮政局 120,000 120,000 2016-05-04 中国 浙江省 杭州市 杭州银行 1,200,000 1,080,000 2016-04-27 中国 北京市 北京市 建信金融租赁股份有限公司 600,000 600,000 2015-03-22 中国 江苏省 南京市 南京星友田科技发展有限公司 400,000 400,000 2016-06-19 中国 上海市 上海市 上海万序计算机科技有限公司 480,000 480,000 2016-05-25 中国 上海市 上海市 上海万序计算机科技有限公司 480,000 480,000 指标卡制作 设置指标卡样式 在【文本】处新增了【固定字体大小】，且默认勾选，显示效果为 KPI 指标卡默认显示效果。用户也可不勾选该按钮，自定义内容显示效果，根据自己的需求进行设置，如下图所示： 点击【文本】栏，可设置形状，并用条件属性控制形状及形状颜色的显示。如下图所示：","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"FineBI","slug":"FineBI","permalink":"https://www.yiuhangblog.com/tags/FineBI/"},{"name":"数据处理","slug":"数据处理","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件","slug":"组件","permalink":"https://www.yiuhangblog.com/tags/%E7%BB%84%E4%BB%B6/"}],"author":"Yiuhang Chan"},{"title":"常用函数(FineBI)","slug":"20200605FineBI函数","date":"2020-06-04T23:55:42.000Z","updated":"2024-02-28T10:49:46.000Z","comments":true,"path":"2020/06/05/20200605FineBI函数/","permalink":"https://www.yiuhangblog.com/2020/06/05/20200605FineBI%E5%87%BD%E6%95%B0/","excerpt":"常用函数，帆软BI软件基本操作","text":"FineBI函数介绍在FineBI中，函数用于处理数据和实现简单或者复杂的计算和分析。比如以下场景中我们可能会用到函数: 【数值计算】例如求和、平均、最大值、最小值以及计算出业务指标等; 【时间计算】比如获取当前日期、计算时间差、改变时间单位(取年或月)、格式转换 【文本处理】比如拆分合并文本、格式规范 函数的价值在于它们能够简化一些数据处理和分析的过程，并且可以实现复杂的计算和数据转换。通过使用函数，我们可以将多个步骤合并成一个， 减少了繁琐的手工操作，同时也降低了出错的可能性。 FineBI函数的使用位置1：【数据编辑】中的 【新增公式列】 2：【组件】中的添加 【计算字段】 3：【过滤】中的【添加公式】条件 FineBI常用函数 IF 函数 判断条件语法规则： if (boolean,number1/string1,number2/string2) 示例数据： 合同事实表.xlsx ​ 例：用户需要将【合同类型】改为代号显示，【购买合同】改为 1 ，【服务协议】改为 2 ，其他两个协议改为 0。 语法设置： if(合同类型=&quot;购买合同&quot;,1,if(合同类型=&quot;服务协议&quot;,2,0)) ABS 函数 求绝对值语法规则: abs(number) 示例数据： 股票买卖数据.xlsx ​ 例：使用示例数据计算买入-卖出差额后，需要将差额进行绝对值处理。 语法设置： ABS(差值) ROUND函数 保留几位小数语法规则： ROUND(number,num_digits) 示例数据： 商品销售明细表.xlsx ​ 例：使用示例数据「商品销售明细表」，需要将「销售额」数值统一为保留小数点后一位。 语法设置：ROUND(销售额,1) num_digits按此位数进行舍入，小于0，则在小数点左侧进行舍入。等于0，则舍入到最接近的整数。大于0，则舍入到指定的小数位。 INT 函数 抽取数据语法规则: int(number) 向下取整,往更小的值取整 示例数据： 集团商品销售总表.xlsx ​ 例：使用示例数据对销售额进行向下取整。 语法设置： INT(销售额) FineBI函数类型数值函数 日期函数 文本函数 逻辑函数 聚合函数 聚合函数可以对一组数据进行汇总，一般使用聚合函数汇总后的值进行再计算。 公司的销售额合计是多少（求和：SUM_AGG(销售额)) 商品的平均售价是多少（平均值：AVG_AGG(售价)） 总共有多少个会员（去重计数：COUNT_AGG(会员)） 昨日的最大交易订单金额是多少（最大值：MAX_AGG(订单金额)） 聚合函数的使用场景是什么? 一般我们会使用聚合汇总后的值达行再计算。随着分析维度的切换，计算字段会自动跟随维度动态调整。 为什么在组件中才可以使用聚合函数? 编辑数据中都是针对个体的行级别的计算，组件中可以指定维度进行聚合计算 SUM_ AGG (A&#x2F;B) 和SUM_ AGG(A)&#x2F;SUM_ AGG(B)有什么区别呢? 先相除再汇总 和 先分别汇总得到各自的总值再相除 分析函数 FineBI函数最佳实践技巧01 [明确业务需要] : ​ 场景背景:某网站的运营人员想要就用户的激活登录信息分析出网站的用户留存情况，来制定接下来的用户运营策略。现有一-张“用户登录信息”表，运营人员想要通过该表分析出用户的每日的新增用户数、当日留存率、次日留存率、三周留存率….. ​ 指标定义: ​ 留存率&#x3D;新增用户中登录用户数&#x2F;新增用户数*100% ​ N日留存人数:指新增用户日(T)之后的第N日，依然登录的用户数 ​ N周内留存率:指新增用户日之后，“注册(激活)登录时间差”为1~7N(含)天的登录用户数&#x2F;新增用户日总 ​ 人数 ​ 注:一般情况下登录时间晚于注册时间，但是可能会存在部分”游客”用户先登录体验后注册身份。 02 [梳理计算步骤] ​ ①梳理字段，有登录时间、激活时间…等字段，各字段所代表的含是…..​ ②是否需要规范字段&#x2F;数据清洗​ ③求出每日的新增用户数，求时间差，求新增用户中登录的用户数​ ④相除求留存率​ ….. 03 [找到合适的函数] ​ 计算日期差(日)函数用DATESUBDATE&#x2F;DATEDIF函数或者使用快捷功能“时间差” ;​ 计算去重用户数用COUNTD_AGG函数或者用记录数(去重) 04 [正确使用函数] 05 [函数校验] FineBI函数书写注意事项【1】公式中的字段能手动输入注意： ​ 输入字段名部分文字或首字母FineBI能自动匹配对应字段，选择字段即可。也支持在左侧的字段选择框中选择。​ 添加的字段名要和表内字段匹配上,添加的字段为蓝色。如果为黑色则无效,取不到字段内数据。 【2】 BI 里的「不等于」表示法: !&#x3D; 【3】公式里书写文本的表达式 在文本表达式左右需要增加「双引号」 【4】新增公式列不支持直接输出聚合函数 因为聚合函数是对不同行进行汇总的计算。编辑数据是行级别的明细计算。如果想直接输出聚合函数，可以在组件中计算。如果在数据编辑中进行聚合，公式需要使用def函数嵌套,或者直接使用新增汇总列。 【5】公式报错「不合法」? 公式不合法原因排查","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"FineBI","slug":"FineBI","permalink":"https://www.yiuhangblog.com/tags/FineBI/"},{"name":"函数","slug":"函数","permalink":"https://www.yiuhangblog.com/tags/%E5%87%BD%E6%95%B0/"}],"author":"Yiuhang Chan"},{"title":"数据处理 (FineBI)","slug":"20200515数据处理","date":"2020-05-14T23:55:42.000Z","updated":"2024-02-28T10:49:43.000Z","comments":true,"path":"2020/05/15/20200515数据处理/","permalink":"https://www.yiuhangblog.com/2020/05/15/20200515%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/","excerpt":"数据处理，帆软BI软件基本操作","text":"字段图表含义 数据处理所谓的【数据清洗】就是提前对数据进行一系列的操作,为满足实际业务场景中数据的处理需求。这些操作能够从杂乱无章的数据中整理出有序的、可靠的数据，为后续的分析和决策提供有力支持。 场景一: 临近放假,老师准备对全班的同学成绩进行一些分析.于是找来了之前录入的考试成绩表,但是在开始分析前就遇到了一个难题,如图所示 常见数据处理顺序很多数据由于未经过处理，不方便用来直接制作图表。 我们可以将数据添加到主题后，在主题中先对数据进行分析，然后用分析后的数据再制作图表会比使用原数据表更方便。 以数据成绩表 1 为例 姓名 考试结果 录入时间 滑玛 语文90 数学80 英语80 2&#x2F;12&#x2F;2020 16:30 阿里和卓 语文91 数学 英语85 2&#x2F;12&#x2F;2020 16:31 福伦 语文54 数学78 英语66 2&#x2F;12&#x2F;2020 16:32 令妃 语文78 数学63 英语95 2&#x2F;12&#x2F;2020 16:43 语文73 数学75 英语88 2&#x2F;12&#x2F;2020 17:57 滑玛 语文90 数学88 英语80 2&#x2F;12&#x2F;2020 17:30 首先进入我的分析 创建新的文件夹数据处理_测试 接着导入成绩表1.xls的数据并创建新的分析主题 修改分析主题名称数据处理1后进入编辑 信息 误操作可以通过右边数据来源进行删除回溯 重复行操作 系统的一些问题带来的两条完全一样的数据，直接去重 有业务含义的，需要有选择的去重，先【排序】再【删除重复行】。 ​ 例：姓名是唯一字段，相同的姓名只留下一条 信息 删除时,是删除处在下方的数据,以更新成绩为例： 假设同一个人的成绩第一次登记的作废,需要留下第二次输入的,那么可以将时间设置为【降序】，这时先登记的成绩在下，后更新的成绩在上，这样就能保证数据的准确性。 删除空值空值作为一个必定会遇到的问题，在不同的业务场景下会有截然不同的处理方式。 “大海里的一滴水”，放着不管，问题不大 害群之马不可留”，通过过滤，删除含null的数据 灵活分析要保留，有业务含义时，打上【标签】，方便分析时过滤： 方式一: 【新增公式列】 方式二: 【条件标签列】 示例 1 删除空值行点击上方功能栏的过滤进行筛选操作 示例 2 快捷删除空值列点击表头右侧的三角形表示进行快捷过滤 数据结构调整数据结构: ​ 把数据处理成要分析的维度和指标 ​ 相关功能:【更多】中找到【拆分行列】、【行列转换】，进行字段设置 示例 1 拆分考试结果使用拆分行列，行列转换，字段设置对考试结果进行处理 首先使用拆分行把成绩按照空格进行第一次拆分 随后使用拆分列对结果按照字符数为2进行拆分，生成前两列 然后通过字符设置对不用的列和不符合属性的列进行隐藏和修改 最后对语数英三列进行列转行即可 信息 通过新增公式列对于需要保留的空缺列可以添加标识行例如IF(${数学}=null||${语文}=null||${英语}=null,&quot;缺考&quot;,&quot;出席&quot;) 多表合并分析场景二: 在完成数据处理后，老师觉得只分析自己班游局限性，又要来了同年级另外两个班的数据….. 年级主任还补充,近几年鼓励学生全面发展,现在把体育,美术,课外实践也归纳成一门综合素质评定. 1）多个表格上下扩展，分析指标不变，只是行数增加，就用【上下合并】 2）多个表格左右扩展，分析指标变多，只是列数增加，先考虑【其他表添加列】也可以使用【左右合并】 示例 1 上下合并（增加行） 在导入成绩表 2 后数据来源选中数据表 1 回溯操作到第一步 姓名 考试结果 录入时间 夏紫薇 语文90 数学80 英语80 2&#x2F;12&#x2F;2020 18:30 福尔康 语文91 数学 英语85 2&#x2F;12&#x2F;2020 18:31 永琪 语文54 数学78 英语66 2&#x2F;12&#x2F;2020 18:32 小燕子 语文78 数学63 英语95 2&#x2F;12&#x2F;2020 18:43 然后选中上下合并 选中数据来源最后的操作即可把合并后的数据按照原先的操作自动再操作一遍 示例 2 左合并（增加列） 首先导入产品成本表和产品销售表 产品成本表： 产品 成本额 苹果 40 香蕉 35 栗子 38 产品销售表： 产品 销售额 苹果 90 香蕉 70 橘子 70 以产品成本表为主表，产品列为依据，进行左合并，则合并产品销售表的所有销售额到产品成本表的最右列。 如果合并表没有主表所包含的依据列则其值为空 如果主表没有合并表所包含的依据列则不合并该值 示例 3 右合并（增加列） 以产品成本表为主表，产品列为依据，进行右合并，则合并产品销售表的所有销售额到产品成本表的最右列。 如果主表没有合并表所包含的依据列则其值为空 如果合并表没有主表所包含的依据列则不合并该值 示例 4 并集合并（增加列） 以产品成本表为主表，产品列为依据，进行并集合并，则合并产品销售表的所有销售额到产品成本表的最右列。 合并所有的值 如果主表没有合并表所包含的依据列则其值为空 如果合并表没有主表所包含的依据列则其值为空 示例 5 交集合并（增加列） 以产品成本表为主表，产品列为依据，进行交集合并，则合并产品销售表的所有销售额到产品成本表的最右列。 合并共有的值 如果主表没有合并表所包含的依据列则不合并该值 如果合并表没有主表所包含的依据列则不合并该值 示例 6 左右合并（增加列）导入学生信息表数据 姓名 性别 年龄 班级 滑玛 男 14 六年1班 阿里和卓 男 14 六年1班 福伦 男 14 六年1班 令妃 女 14 六年1班 容嬷嬷 女 14 六年2班 明月 女 12 六年2班 彩霞 女 12 六年2班 小凳子 男 12 六年2班 小桌子 男 12 六年2班 夏紫薇 女 12 六年3班 福尔康 男 13 六年3班 永琪 男 13 六年3班 小燕子 女 12 六年3班 含香 女 12 六年3班 蒙丹 男 13 六年3班 以学生信息表为主表合并处理过的成绩表 1 进行左合并 示例 7 快捷合并依据列唯一（增加列） 进入在数据工具列进入成绩表 1 在上方工具栏使用其他表添加列功能 结果类似左合并 示例 7 快捷合并依据列不唯一（增加列） 导入综合素质成绩表的数据 姓名 科目 综合素质成绩 滑玛 体育 (30%) 30 滑玛 美术 (30%) 30 滑玛 社会实践 (40%) 40 阿里和卓 体育 (30%) 30 阿里和卓 美术 (30%) 20 阿里和卓 社会实践 (40%) 40 福伦 体育 (30%) 20 福伦 美术 (30%) 20 福伦 社会实践 (40%) 29 令妃 体育 (30%) 10 令妃 美术 (30%) 18 令妃 社会实践 (40%) 10 容嬷嬷 体育 (30%) 30 容嬷嬷 美术 (30%) 5 容嬷嬷 社会实践 (40%) 10 明月 体育 (30%) 30 明月 美术 (30%) 5 明月 社会实践 (40%) 12 彩霞 体育 (30%) 30 彩霞 美术 (30%) 10 彩霞 社会实践 (40%) 4 小凳子 体育 (30%) 10 小凳子 美术 (30%) 10 小凳子 社会实践 (40%) 10 小桌子 体育 (30%) 11 小桌子 美术 (30%) 12 小桌子 社会实践 (40%) 13 夏紫薇 体育 (30%) 5 夏紫薇 美术 (30%) 30 夏紫薇 社会实践 (40%) 30 福尔康 体育 (30%) 30 福尔康 美术 (30%) 29 福尔康 社会实践 (40%) 40 永琪 体育 (30%) 30 永琪 美术 (30%) 29 永琪 社会实践 (40%) 40 小燕子 体育 (30%) 30 小燕子 美术 (30%) 6 小燕子 社会实践 (40%) 36 含香 体育 (30%) 5 含香 美术 (30%) 30 含香 社会实践 (40%) 38 蒙丹 体育 (30%) 30 蒙丹 美术 (30%) 6 蒙丹 社会实践 (40%) 32 使用其它表添加列功能添加总和素质成绩表的求和值 新增分析指标场景三: 经过各种处理,我们已经可以基于现有的数据做分析了,但现有的指标还是比较单调的,如果我们希望有更多的指标呢? 比如各年级的,各班的三科总分时多少,各科平均分是多少,多少学生在平均分之上… 假设需要的指标非常的多，则需要如下操作 1）要写公式的:【新增公式列】 2）要算汇总值的:【新增汇总列】 3）要写多重if嵌套的，直接用:【条件标签列】 真正的数据处理还是要根据实际的业务场景区处理，以上只是大概的处理步骤 调整字段通过字段设置，可以选择需要保留或排除的字段，快速调整字段位置、重命名字段，从而快速整理数据。 1）删除多余列 ​ 有一些不需要参与分析或者空白列，点击字段表头，下拉删除列 2）转化字段类型 ​ 分析的时候，会按照字段类型进行分类，用维度衡量指标。需要调整类型不正确的字段。例如1号产品和2号产品不等于3号产品 3）重命名、翻译字段 ​ 将一些不规范的字段名进行重命名。例如将英文字段转化为中文 切换数据源当我们已经做了很多分析步骤,但是这时候想要换源数据表。这时候，若我们不想要重新再做一遍这些分析步骤，只需要在第一步【切换数据】即可。系统会自动将当前表和要更换的目标表【字段名称相同的字段】进行匹配。 必须在历史记录的第一步上切换 如图所示: A 为切换数据源 ​ B 为数据操作步骤的第一步,且鼠标悬停在B处可查看数据来源 数据校验计算过程中，我们需要一边分析一边校验查看,查看数据是否跟预期的一样 点击一个字段，预览下方会自动出现校验数据，帮助用户快速发现问题，快速调整计算。如下图所示： 1）点击数值字段，显示该列「求和」、「平均」数值 2）点击文本&#x2F;日期字段，显示该列「去重计数」数值 3）点击下拉框，可以检查该字段中每个字段的计数值，帮助用户检查","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"FineBI","slug":"FineBI","permalink":"https://www.yiuhangblog.com/tags/FineBI/"},{"name":"数据处理","slug":"数据处理","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}],"author":"Yiuhang Chan"},{"title":"数据分析工具基础 (FineBI)","slug":"20200511数据分析基础","date":"2020-05-11T01:12:43.000Z","updated":"2024-02-28T10:49:40.000Z","comments":true,"path":"2020/05/11/20200511数据分析基础/","permalink":"https://www.yiuhangblog.com/2020/05/11/20200511%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/","excerpt":"数据分析基本介绍，帆软BI软件基本介绍和操作","text":"一 概念 数据： 是数据分析的首要材料，它可以是汇总后的数据，也可以是未汇总的原始数据 数据分析：指的是适当的统计分析方法对收集来的大量数据进行分析，将它们加以汇总和理解并消化，以求最大化开发数据的功能，发挥数据的作用 数据分析的目的：为了提取有用的信息和形成结论对数据加以详细研究和概括总结的过程，说白了就是以数据为中心，运用各种分析方法和分析手段得到自己的结论 二 数据分析模式对比 分析模式有两种： • 传统分析模式：数据准备可能不够充分，沟通成本大，对业务人员的限制大，工作效率低下，成本大• 自助分析模式: 业务人员能够自主分析，降低沟通成本，效率高 三 FineBI商业智能工具越来越多的企业采购开始偏好现代的、以业务用户为中心的自助服务数据分析平台。传统的以IT为主导的，高度集中化的工具正面临替换。 FineBI 作为新一代自助大数据分析的商业智能工具，旨在帮助企业快速搭建面向全员的自助分析BI平台，让每一个成员都能充分了解并利用他们的数据，可以自己处理数据、分析数据，从而辅助决策、提升业务效果。 FineBI 为企业提供了一站式商业智能解决方案，提供了从数据准备、数据处理、可视化分析、数据共享与管理于一体的完整解决方案，创造性地将各种“重科技”轻量化，使用户可以更加直观简便地获取信息、探索知识、共享知识。 FineBI功能结构: 数据层：设计用户创建数据源。 应用层：设计用户进行仪表板设计，管理用户配置用户和权限体系。 展示层：普通用户在前端进行可视化展示和分享来编辑和查看仪表板。 四 BI可视化概念 商业智能 （Business Intelligence ，简称：BI），指用现代数据仓库技术、线上分析处理技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。 可视化 （Visualization），是指利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，从而清晰、有效的传达与沟通信息。 五 FineBI功能介绍FineBI分析思路FineBI提供分析主题概念，通过分析主题，将用户完成一个分析所需要的数据、组件、仪表板更紧密的联系在一起，通过简单明确的操作路径，实现沉浸式数据分析，轻松掌握分析技能 数据管理 数据接入，支持30种以上的大数据平台和SQL数据源，支持Excel文件数据集，支持多维数据库，程序数据集等更丰富的数据源。 数据空间，分为【公共数据】和【我的分析】两个模块。【公共数据】作为企业的数据资源，用户可基于【公共数据】来继续分析，同时用户可将自己的数据发布到【公共数据】中来为其他人提供数据分析的基础。【我的分析】主要用于进行个人数据分析制作仪表板等。 数据分类，FineBI 以文件夹的形式进行数据管理，让用户可以根据不同的业务包主题进行数据的分类。提供了数据相关的各种信息，让用户更好的了解自己所拥有的数据。 数据关联，FineBI提供的关联建模功能，让管理员能够在选择需要的数据之后，自动根据数据仓库的关联关系进行建模，同时也提供了手动的关联关系配置，支持组合主键的关联关系配置。基于这样的基础模型，分析用户在使用自助数据集进行自助取数时，可以直接对有关联的数据进行联合分析，而不需要分析用户再去梳理和配置关联关系。 数据编辑FineBI 提供可视化的数据分析，能够快速直观的了解数据，发现数据问题。同时操作简单方便。以用户思维为主导的可视化分析模式能够根据用户选择的数据自动推荐可视化效果，使数据分析更高效 超强函数FineBI除去支持部分常用计算的可视化配置外，还提供了公式来新增计算字段。计算字段允许利用数据源中已存在的数据创建新数据。创建计算字段时，本质上是在数据源中创建一个新字段（或列），其值或成员由所控制的计算来确定。此新计算字段将保存到 FineBI 中，并且可用于创建图表 数据可视化管理 多维度探索分析，FineBI 根据数据的类型，自动将数据识别为维度和指标，对于维度和指 标分别提供了丰富的分析功能，方便用户对基础数据进行分析和计算 可视化图表，基于图形语法设计改良，提供了无限的视觉分析可能。 仪表板，让用户将多个分析内容，分组组件组合成一个仪表板或者报告，是一个面向分析主题的数据呈现方式。 数据协作共享FineBI 支持【主题协作】【数据共享】【仪表板共享】三种数据协作共享模式。 【主题协作】：FineBI 将自助数据集、组件、仪表板融合到分析主题中，通过实现分析主题的协作，从而实现了自助数据集，组件，仪表板的共享查看与共享编辑功能。 【数据共享】：FineBI 支持公共数据的独立模块，在公共数据中，不仅有管理员添加的基础数据集，如DB表，sql数据集等，也支持用户将我的分析中的自助数据集发布到公共数据中。经过用户申请发布数据集、管理员审核、审核通过发布至对应文件夹的流程，实现数据共享。 【仪表板共享】：在完成数据分析的仪表板以后，可以通过创建公共链接给别人访问、申请发布到目录节点或者直接分享给其他人查看 六 FineBI基本操作 FineBI主界面的功能选择区 FineBI功能目录区 FineBI数据处理主界面区 注：切换不同的功能选区，功能目录也将跟随变化 主要功能目录【目录】主要分为目录区域和预览区域，通常的操作是完成分析报告后把分析报告挂载出来的地方，把分析报告挂载到目录上就可以给其他用户分享 我的分析【我的分析】是在BI中进行分析的容器，是我们学习的重点，所有的分析操作都是在【分析主题】中进行。同时【分析主题】支持不同用户之间进行协作编辑，极大的方便了用户对分析内容的共享。 创建方式 方式一：点击【新建文件夹】或者点击【加号】，再到文件夹下添加相关的数据表和创建分析 特点：从创建文件夹开始，所有相关分析表都将在一个文件夹下，更加体现整体关联性，适用于同主题的多个分析的情况 方式二：点击【新建分析主题】 特点：直接在分析目录下创建分析主题，分析主题将直接在【全部分析】中展示出来，更加直观的看到分析的结果,适用于分析主题比较单一的情况 方式三: 选中【公共数据】中的数据表，操作界面的右上角有【创建分析主题】 特点：直接对现有的数据进行分析 添加数据【选择数据】 新建分析主题后，会自动进入分析主题内的【选择数据】界面 方式一：【当前工程上】直接挑选自己需要的已上传到FineBI中的数据,此处的数据在学习时可以自己提前上传一份数据到【公共数据】中 方式二：【本地Excel文件】在自己电脑盘符上存放的数据表 以上两种方式选择的数据表选择好之后【确定】上传 信息 以上两种方式没有本质区别，【当前工程上】的数据也是要先从本地上传 FineBI可上传的表类型为 .csv、.xls、.xlsx 三种格式 若上传失败，可能是.cvs文件格式导致的,进入[管理系统]-&gt;[安全管理]-&gt;[安全防护]，关闭[文件上传校验]。若还上传失败,则具体问题具体分析 公共数据【公共数据】顾名思义就是用户可以公共使用的数据存放的地方。管理员可以将复用度很高的表，添加或发布到公共数据集 。如果是个人使用，那我们更多时候的操作是直接在【我的分析】中操作了，对个人来说【公共数据】和【我的分析】其实是一个概念。对于企业来说，【公共数据】是由IT人员或者管理数据的人员来准备数据,我们只需要到这里找自己需要的数据去使用就行了 管理系统管理系统为管理员进行数据决策系统管理的地方，支持目录、用户、外观、权限等的管理配置 数据处理FineBI工程上的数据来源数据来源有两种: 第一种: 当前工程上的数据 此种方式是企业一般为我们准备，在【公共数据】里已经添加并授权给我们需要使用的数据。我们可以直接添加即可。 第二种: 本地Excel文件数据 信息 【本地Excel数据】方式的注意点: 可上传的表类型为 csv、xls、xlsx 三种格式 在上传 csv 格式文件前，需要关闭「文件上传校验」，才能上传成功。 关闭方式：进入【管理系统】-》【安全管理】-》【安全防护 】-》【文件上传校验】 Excel表中首行不能有合并单元格 在上传前要确认，添加的 Excel表时，首行不能有合并单元格，否则会上传失败。 Excel表中不能有 Excel 函数计算的内容 例如：vlookup(是种查找函数)，sumifs(是多条件求和函数) 函数等 数据上传数据分析的基础是数据。因此，进入分析主题后的第一步，就是添加数据。数据上传方式： 方式一：创建分析主题后，会自动进入添加数据页面 方式二：点击【分析主题】界面的【加号】进入【选择数据】的界面,若需要对多张表进行操作,可点击【批量操作】 上传后的数据存放位置查看在进行数据分析前，需要创建分析主题，在分析主题中，可以添加数据，用户进一步的分析。在【我的分析】-&gt;【分析主题】-&gt;【数据】下存放着数据表 数据处理界面 黄色区域：管理主题内的数据表，可以添加，删除，保存，更新数据表等 绿色区域：数据预览区域 红色区域：编辑数据区域对数据进行分析，包括表头分析，以及添加分析步骤，分析历史记录等 数据编辑数据上传成功后，我们可以直接编辑数据。 如果数据质量好,那就直接进行可视化大屏制作 如果数据质量差,那就需要先进行数据处理 [注]数据处理是为了能更快捷、更清晰地完成数据分析和可视化 哪些情况需要进行数据处理原始数据可能存在的问题： 存在null值,会影响计算 字段类型不正确时,影响分析例: 数值类型的数字可以计算,但是文本类型的数字不可以计算数 数据的结构不清晰时,不方便分析","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"FineBI","slug":"FineBI","permalink":"https://www.yiuhangblog.com/tags/FineBI/"}],"author":"Yiuhang Chan"},{"title":"MySQL","slug":"20190315认识mysql","date":"2019-03-15T03:02:13.000Z","updated":"2024-02-28T10:49:38.000Z","comments":true,"path":"2019/03/15/20190315认识mysql/","permalink":"https://www.yiuhangblog.com/2019/03/15/20190315%E8%AE%A4%E8%AF%86mysql/","excerpt":"MySQL的认识操作，可视化图表创建","text":"数据库数据库（Database），简称DB，本质上是由一系列文件构成的集合，构建成一个用于存储数据的仓库。这种数据存储系统是建立在文件系统之上的，设计用来以特定格式组织、存储和管理数据。数据库使用户能够对数据执行一系列操作，如增加（Create）、删除（Delete）、修改（Update）和查询（Retrieve）等，从而有效地管理和操纵数据。可以将数据库比喻为哆啦A梦的百宝袋，其中存储的数据就像袋中的各种道具，可以根据需要被取出或存入。 关系型数据库关系型数据库基于关系模型，即数据以二维表格的形式进行组织。它由一系列具有固定结构（列）和可变数据项（行）的表格（数据表）及这些表格之间的关系所组成。核心元素包括： 数据行：代表一条记录，类似于Python中的一个对象。 数据列：代表一个字段，相当于对象的属性。 数据表：由数据行（记录）的集合构成，每个数据表存储一类相似的数据。 数据库：由一个或多个相关数据表的集合构成，形成了数据的整体结构。 常见的关系型数据库系统包括Oracle、DB2、Microsoft SQL Server、Microsoft Access、和MySQL等。 非关系型数据库非关系型数据库，也称为NoSQL（Not Only SQL）数据库，是指不仅仅支持SQL的分布式数据存储系统。它不依赖固定的表结构，允许存储无固定格式的数据，因此提供了更为灵活的数据模型，并能够处理大规模分布式数据的存储。非关系型数据库按数据模型可分为： 键值存储数据库：以键值对的方式存储数据，适用于快速查询和存储简单数据模型的场景。 文档型数据库：存储文档格式数据（如JSON、XML），适用于存储结构化或半结构化的数据，便于开发者直接在应用程序中使用。 列存储数据库：将数据以列簇方式存储在硬盘上，适用于分析大规模数据集，提高读写性能。 图数据库：使用图结构存储实体及其关系，适合处理复杂的网络结构数据。 常见的非关系型数据库系统包括NoSql、Cloudant、MongoDb、Redis、HBase等。 关系型数据库和非关系型数据库各有优势和适用场景。关系型数据库适合需要严格数据完整性和复杂查询的应用场景，而非关系型数据库则更适合于需要灵活数据模型、快速迭代和能够水平扩展处理大量数据的场景。在现代的数据架构设计中，根据应用需求选择合适的数据库类型是至关重要的。 什么是MySQL数据库技术是计算机科学领域中发展最迅速且应用最为广泛的技术之一。它在现代信息社会扮演着核心角色，其应用范围覆盖了几乎所有行业和领域。个人身份信息、在线购物的登录、支付和购物车信息、旅行的订票和酒店预订信息、天气和交通信息，以及QQ、微信等通讯服务的数据，都是通过数据库进行记录、查询、修改和管理的。在大数据时代，数据库技术和大数据分析的结合更是释放了巨大的潜力，使得我们能够从庞杂的数据中提炼出难以直接观察到的信息规律和价值，进一步促进了决策制定和创新。 数据库技术不仅快速发展、应用范围广泛，而且具有高度的信息价值挖掘能力。全球许多最大及发展最快的组织，如Facebook、Twitter、Booking.com、Verizon等，都依赖于MySQL这类数据库管理系统来支撑他们的高容量网站、关键业务系统和软件产品。MySQL数据库，从其诞生之初的完全开源，发展至今已经衍生出了免费的社区版以及收费的标准版和企业版，满足了不同用户和组织的需求。 随着信息技术的不断进步和大数据技术的应用，数据库技术的发展未来仍然充满广阔的前景。它不仅是现代信息领域从业人员的必备技能，也是推动社会信息化进程、实现数据驱动决策的重要基础。因此，深入理解数据库技术的原理、掌握其应用和管理的技巧，对于追求事业发展和技术创新的专业人士来说至关重要。 MySQL数据库的结构可以被分解为几个关键的组件，每个组件都扮演着特定的角色，确保数据库能够高效且安全地存储和处理数据。 形式结构1234567891011121314151617graph LR Client[客户端] --&gt;|发出请求| LoadBalancer[负载均衡] LoadBalancer --&gt;|分发请求| Server1[服务器1] LoadBalancer --&gt;|分发请求| Server2[服务器2] LoadBalancer --&gt;|分发请求| Server3[服务器3] Server1 --&gt;|读写请求| MySQLMaster[MySQL 主服务器] Server2 --&gt;|读写请求| MySQLMaster Server3 --&gt;|只读请求| MySQLSlave[MySQL 从服务器] MySQLMaster --&gt;|数据复制| MySQLSlave classDef server fill:#f96,stroke:#333,stroke-width:2px; classDef database fill:#9f6,stroke:#333,stroke-width:2px; class LoadBalancer,Server1,Server2,Server3 server; class MySQLMaster,MySQLSlave database; 客户端发送请求到负载均衡器，负载均衡器将请求分发到多个服务器。服务器对 MySQL 主服务器进行读写操作，而对从服务器进行只读操作。MySQL 主服务器将数据复制到从服务器，以保持数据的一致性。 运行逻辑1234567891011121314151617graph LR Client --&gt;|发送查询| LoadBalancer LoadBalancer --&gt;|读请求| Slave1[MySQL 从服务器1] LoadBalancer --&gt;|读请求| Slave2[MySQL 从服务器2] LoadBalancer --&gt;|写请求| Master[MySQL 主服务器] Master --&gt;|复制日志| Slave1 Master --&gt;|复制日志| Slave2 classDef read fill:#9f6,stroke:#333,stroke-width:2px; classDef write fill:#f96,stroke:#333,stroke-width:2px; classDef database fill:#ff6,stroke:#333,stroke-width:2px; class LoadBalancer read; class Master write; class Slave1,Slave2 database; 客户端发送查询到负载均衡器。 负载均衡器根据查询类型将读请求分发到从服务器，将写请求发送到主服务器。 主服务器处理写请求，并将更改通过复制日志发送到从服务器，确保数据的一致性。 语句类型MySQL作为一款流行的关系型数据库管理系统，提供了一套丰富的语句类型来管理和操作数据库。这些语句类型可以分为四大类：数据定义语言（DDL）、数据操纵语言（DML）、数据查询语言（DQL）和数据控制语言（DCL），每种语言类型都承担着不同的职责和功能。 数据定义语言（DDL）：DDL语句用于定义和修改数据库的结构。这包括创建、修改、删除数据库和其中的对象，如表、视图、索引、触发器、存储过程等。DDL操作通常是自动提交的，这意味着一旦执行，就不能回滚。主要的DDL语句包括： CREATE：用于创建新的数据库、表、索引等对象。 ALTER：用于修改现有数据库对象的结构。 DROP：用于删除数据库对象。 TRUNCATE：用于删除表中的所有记录，但不删除表本身，这通常比删除每一行要快得多。 数据操纵语言（DML）：DML语句用于数据库记录的添加、删除、更新，并检查数据的完整性。它们直接影响到数据库中的数据，但不改变数据库的结构。DML主要的语句包括： INSERT：用于向表中添加新的记录。 UPDATE：用于修改表中的现有记录。 DELETE：用于从表中删除记录。 SELECT：虽然通常被分类为DQL，但有时也被视为DML的一部分，用于检索数据。 数据查询语言（DQL）：DQL主要是指SELECT语句，用于查询数据库中表的记录。通过SELECT语句，可以读取一个或多个表中的数据，支持复杂的查询，包括联结、分组和排序等操作。SELECT语句的灵活性和强大功能是数据库交互中最常用的部分之一。 数据控制语言（DCL）：DCL语句用于定义或改变数据库的访问权限和安全级别。DCL提供了管理数据库安全性的机制，包括授权用户访问和操作数据库的权限。主要的DCL语句包括： GRANT：用于给用户分配权限。 REVOKE：用于撤销用户的权限。 数据类型数值类型MySQL 支持所有标准 SQL 数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。 作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 Bytes (-128，127) (0，255) 小整数值 SMALLINT 2 Bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 Bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 Bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 Bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 Bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 Bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01&#x2F;9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’&#x2F;‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901&#x2F;2155 YYYY 年份值 DATETIME 8 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ YYYY-MM-DD hh:mm:ss 混合日期和时间值 TIMESTAMP 4 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYY-MM-DD hh:mm:ss 混合日期和时间值，时间戳 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 枚举与集合类型（Enumeration and Set Types） ENUM: 枚举类型，用于存储单一值，可以选择一个预定义的集合。 SET: 集合类型，用于存储多个值，可以选择多个预定义的集合。 空间数据类型（Spatial Data Types）GEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION: 用于存储空间数据（地理信息、几何图形等）。 约束类型MySQL数据库通过使用不同类型的约束来保证数据的完整性、准确性以及关系的一致性。约束是施加在表列上的规则，用于限制存入表中的数据类型。以下是MySQL中常见的约束类型，它们各自承担着不同的职责和作用： 主键约束（Primary Key）：主键约束确保表中的每一行都有一个唯一标识。因此，被标记为主键的列不允许有重复值，且不能为NULL。一个表中只能有一个主键，该主键可以包含一个或多个列（复合主键）。 自增约束（Auto Increment）：自增约束通常与主键一起使用，用于在新记录插入表时自动生成一个唯一的数字。这对于用户不需要手动输入且需保证唯一性的ID非常有用。自增字段通常是整数类型，每当向表中添加新行时，该字段的值会自动递增。 唯一约束（Unique）：唯一约束保证表中一列的所有值都是唯一的。这意味着在该列中，两行不能有相同的值。一个表可以有多个唯一约束，但唯一约束允许含有空值（NULL），并且每个唯一约束可以包含多个列。 非空约束（NOT NULL）：非空约束确保列中的值不能为NULL。这适用于那些必须有实际值的场合，确保数据的完整性。 默认约束（Default）：默认约束为列定义一个默认值。当插入记录时，如果没有为该列提供值，就会使用默认值。这对于定义某些列的典型值非常有用，例如，可以为布尔字段指定默认值false。 外键约束（Foreign Key）：外键约束用于建立两个表之间的关系，确保关系的一致性。外键在一个表中的字段（或多个字段）上定义，用于指向另一个表的主键。这保证了在子表中不能添加不存在于父表主键列中的值。如果尝试插入或更新不存在的值，或者删除在子表中仍被引用的父表中的记录，操作会失败并抛出异常。 案例12#查看所有的数据库 SHOW DATABASES; 12#删除数据库 DROP DATABASE DEMO; 12#创建数据库 CREATE DATABASE DEMO; 12#选择数据库 USE DEMO; 123456#创建数据表CREATE TABLE class( id INT PRIMARY KEY AUTO_INCREMENT, class_name VARCHAR(30), class_id INT UNSIGNED DEFAULT 101); id: 该字段为表的主键，数据类型为整数(INT)。使用了AUTO_INCREMENT属性，意味着每次向表中插入新行时，MySQL会自动为这个字段生成一个唯一的递增数字。这样做确保了表中每条记录的id都是唯一的，便于快速检索和引用。 class_name: 此字段用于存储班级或课程的名称，数据类型为变长字符串(VARCHAR)，最大长度为30个字符。这允许存储各种班级名称，从而为用户提供灵活的命名选项。 class_id: 该字段用于表示班级或课程的唯一标识符，数据类型为无符号整数(INT UNSIGNED)，默认值为101。使用无符号整数意味着这个字段只能存储正数或零，适用于标识符这样的数据。默认值101意味着，如果在插入记录时没有指定class_id的值，它将自动设为101。 12#查看表结构DESC class; 12345678910 #创建数据表CREATE TABLE `学生表`( id INT PRIMARY KEY AUTO_INCREMENT, stu_name VARCHAR(30), age INT UNSIGNED DEFAULT 18, `身高` DECIMAL(5,2), `性别` ENUM(&#x27;男&#x27;, &#x27;女&#x27;, &#x27;保密&#x27;), class_id INT UNSIGNED DEFAULT 101, date_id DATE); id: 这是表的主键字段，数据类型为整数(INT)。该字段使用了AUTO_INCREMENT属性，意味着每当向表中插入新行时，MySQL会自动为这个字段生成一个唯一的递增数字，确保每条记录都能通过一个唯一标识符(id)来区分。这对于快速检索、更新或删除特定记录非常有用。 stu_name: 存储学生名称的字段，数据类型为变长字符串(VARCHAR)，最大长度为30个字符。这意味着可以存储最多30个字符的学生名字。 age: 存储学生年龄的字段，使用了无符号整数(INT UNSIGNED)类型，且默认值为18。无符号意味着这个字段只能存储正数或零，适用于年龄这种不会有负值的数据。 身高: 存储学生身高的字段，使用了十进制数(DECIMAL)类型，最大值为999.99（因为定义为(5,2)，意味着总共5位数字，其中2位为小数）。这种类型适用于需要精确表示的数值，如身高。 性别: 用于存储学生性别的字段，数据类型为枚举(ENUM)，只允许三个值：&#39;男&#39;、&#39;女&#39;或&#39;保密&#39;。枚举类型限制了字段可能的值，确保数据的准确性和一致性。 class_id: 表示学生所在班级的ID，使用了无符号整数(INT UNSIGNED)类型，并且默认值为101。这个字段可能用于关联到另一张表（如class表），用于存储班级相关信息。 date_id: 存储日期的字段，数据类型为DATE。这可能用于记录学生入学日期或其他重要日期。DATE类型的格式为YYYY-MM-DD。 123#删除表DROP TABLE class;DROP TABLE `学生表`; 字段操作添加新的字段 基本添加: 使用ADD关键字向表中添加新字段。基本语法如下: 1ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件]; 在开头添加字段: 如果需要将新字段添加到表的开始位置，使用FIRST关键字。语法如下: 1ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] FIRST; 在中间添加字段: 要在已存在的字段之后添加新字段，使用AFTER关键字。语法如下: 1ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] AFTER &lt;已经存在的字段名&gt;; 修改字段属性&#x2F;数值类型 修改字段类型: 使用MODIFY关键字修改字段的数据类型或约束。语法如下:1ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;新数据类型&gt; [新约束条件]; 修改字段名称 修改字段名称和类型: 使用CHANGE关键字同时更改字段的名称和数据类型。语法如下:1ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt; [新约束条件]; 删除字段 删除字段: 使用DROP关键字从表中删除字段。语法如下:1ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;; 数据操作添加表数据 基本插入: 使用INSERT INTO关键字向表中添加数据。基本语法如下: 1INSERT INTO 表名 VALUES (值1, 值2, 值3...); 批量插入示例: 向students表中插入多条记录。示例如下: 1234INSERT INTO students VALUES(1, &#x27;张三&#x27;, 18, 1.82, &#x27;男&#x27;, 001, &#x27;2019-09-01&#x27;),...(17, &#x27;熊二&#x27;, 21, 1.90, &#x27;男&#x27;, 002, &#x27;2020-09-01&#x27;); 修改数据 基本更新: 使用UPDATE关键字更新表中的数据。基本语法如下:1UPDATE 数据表名 SET 字段1=新值, 字段2=新值 [WHERE 条件]; 删除数据 物理删除: 使用DELETE FROM关键字从表中删除数据。基本语法如下: 1DELETE FROM 表名 [WHERE 条件]; 逻辑删除: 通过添加一个字段并改变其值来隐藏数据，而不是物理删除。这样，数据仍然存在于表中，但在查询时不会显示。示例如下: 1ALTER TABLE 表名 ADD 字段 INT DEFAULT 0; 案例 将id为3的年龄修改为22并且性别为女: 1UPDATE students SET age=22, 性别=&#x27;女&#x27; WHERE id=3; 将张三的名字改成怪兽: 1UPDATE students SET stu_name=&#x27;怪兽&#x27; WHERE stu_name=&#x27;张三&#x27;; 将女生的名字都修改为rose: 1UPDATE students SET stu_name=&#x27;rose&#x27; WHERE 性别=&#x27;女&#x27;; 男生的名字修改为jake: 1UPDATE students SET stu_name=&#x27;jake&#x27; WHERE 性别=&#x27;男&#x27;; 基础查询查询指定字段 查询所有字段: 使用SELECT * FROM 表名;。*代表所有字段，可以根据需要替换为特定的字段名。 查询指定字段并重命名 (AS) 字段重命名: 使用AS关键字给查询结果中的列赋予一个新的名称。语法如下:1SELECT 列名1 AS &#x27;新列名1&#x27;, 列名2 AS &#x27;新列名2&#x27; FROM 表名; 查询指定字段并去重 (DISTINCT) 去重查询: 使用DISTINCT关键字去除查询结果中的重复项。语法如下: 1SELECT DISTINCT 列名 FROM 表名; 行条件查询 (WHERE) 条件查询: 使用WHERE子句过滤符合特定条件的记录。语法如下:1SELECT * FROM 表名 WHERE 条件; 运算符常见的SQL运算符 算术运算符: + (加): 对两个数值进行加法运算。 - (减): 对两个数值进行减法运算或表示一个负数。 * (乘): 对两个数值进行乘法运算。 / (除): 对两个数值进行除法运算。 % (模): 返回两个数相除后的余数。 比较运算符: = (等于): 检查两个表达式的值是否相等。 != 或 &lt;&gt; (不等于): 检查两个表达式的值是否不相等。 &gt; (大于): 检查左边表达式的值是否大于右边的值。 &lt; (小于): 检查左边表达式的值是否小于右边的值。 &gt;= (大于等于): 检查左边表达式的值是否大于或等于右边的值。 &lt;= (小于等于): 检查左边表达式的值是否小于或等于右边的值。 逻辑运算符: AND: 如果所有给定的条件都为真，则返回真。 OR: 如果任一给定的条件为真，则返回真。 NOT: 如果给定的条件为假，则返回真。 位运算符: &amp;: 按位与操作。 |: 按位或操作。 ^: 按位异或操作。 ~: 按位非操作。 赋值运算符: =: 将表达式的值赋给变量或表的列。 使用场景示例 算术运算符: 1SELECT salary, salary * 0.10 AS bonus FROM employees; 比较运算符: 1SELECT name, age FROM students WHERE age &gt;= 18; 逻辑运算符: 1SELECT * FROM orders WHERE amount &gt; 100 AND status = &#x27;Shipped&#x27;; 位运算符: 1SELECT flags, flags | 1 FROM permissions; 注意 优先级: SQL运算符有不同的优先级，比如算术运算符的优先级高于比较运算符，比较运算符的优先级又高于逻辑运算符。使用括号()可以改变执行顺序。 类型兼容性: 在进行运算时，确保参与运算的数据类型兼容，否则可能会导致错误或不预期的结果。 性能考虑: 在使用逻辑运算符时，尤其是在大型数据集上，应注意其对查询性能的影响。合理使用索引和优化查询条件可以显著提高性能。 NULL值的处理: SQL中的NULL表示一个未知值。在使用比较运算符时，任何包含NULL的比较操作都会返回NULL。使用IS NULL或IS NOT NULL来检查NULL值。 模糊查询 (LIKE) 模糊匹配: 使用LIKE关键字进行模糊查询，%表示任意多个字符，_表示单个任意字符。例如:123SELECT 列名 FROM 表名 WHERE 列名 LIKE &#x27;a%&#x27;; -- 以a开头的SELECT 列名 FROM 表名 WHERE 列名 LIKE &#x27;%a%&#x27;; -- 包含a的SELECT 列名 FROM 表名 WHERE 列名 LIKE &#x27;_a&#x27;; -- 以任意字符开头，后接a的 非连续查询 (IN) 指定范围查询: 使用IN关键字查询列值在指定列表中的记录。语法如下:1SELECT * FROM 表名 WHERE 列名 IN (值1, 值2, 值3); 连续查询 (BETWEEN…AND…) 范围查询: 使用BETWEEN...AND...查询列值在某个连续范围内的记录。语法如下:1SELECT * FROM 表名 WHERE 列名 BETWEEN 值1 AND 值2; 空判断 (IS NULL, IS NOT NULL) 空值查询: 使用IS NULL或IS NOT NULL检查列值是否为空。语法如下:12SELECT * FROM 表名 WHERE 列名 IS NULL;SELECT * FROM 表名 WHERE 列名 IS NOT NULL; 案例查询出所有女生: 1SELECT * FROM 表名 WHERE 性别 = &#x27;女&#x27;; 查询出年龄为18和20和22的学生: 1SELECT * FROM 表名 WHERE 年龄 IN (18, 20, 22); 查询年龄在20到24的学生: 1SELECT * FROM 表名 WHERE 年龄 BETWEEN 20 AND 24; 查询姓王的学生: 1SELECT * FROM 表名 WHERE 名字 LIKE &#x27;王%&#x27;; 查询出所有男生的信息: 1SELECT * FROM 表名 WHERE 性别 = &#x27;男&#x27;; 查询名字带有”王”字的学生: 1SELECT * FROM 表名 WHERE 名字 LIKE &#x27;%王%&#x27;; 字符函数字符函数在SQL中用于对字符串类型的数据进行操作，包括获取长度、拼接、拆分、大小写转换、搜索、裁剪和替换等。以下是一些常用的MySQL字符函数及其应用实例。 1. 获取字符串长度: LENGTH() 作用: 返回字符串的字节数。 示例:1SELECT LENGTH(&#x27;linli&#x27;); 2. 拼接字符串: CONCAT() 作用: 将多个字符串值连接成一个字符串。 示例:1SELECT CONCAT(字段1, &#x27; &#x27;, 字段2) FROM 表名; 3. 拆分字符串: SUBSTRING_INDEX() 作用: 根据指定的分隔符拆分字符串，并返回请求的部分。 示例:1234SELECT SUBSTRING_INDEX(字段, &#x27;分隔符&#x27;, 1) AS 新字段名1, SUBSTRING_INDEX(字段, &#x27;分隔符&#x27;, -1) AS 新字段名2FROM 表名; 4. 字符串转大写: UPPER() 作用: 将字符串转换为大写字母。 示例:123SELECT UPPER(&#x27;linli&#x27;);SELECT UPPER(字段) FROM 表名;UPDATE 表名 SET 字段 = UPPER(字段); 5. 字符串转小写: LOWER() 作用: 将字符串转换为小写字母。 示例:123SELECT LOWER(&#x27;linli&#x27;);SELECT LOWER(字段) FROM 表名;UPDATE 表名 SET 字段 = LOWER(字段); 6. 字符串中字符首次出现的位置: INSTR() 作用: 返回子字符串在字符串中第一次出现的位置。 示例:1SELECT INSTR(&#x27;abcdf&#x27;, &#x27;c&#x27;); 7. 去除字符串两端的空白: TRIM() 作用: 去除字符串两端的空格或指定的字符。 示例:12SELECT TRIM(&#x27; abc &#x27;);SELECT TRIM(&#x27;a&#x27; FROM &#x27;aaaaaaaa林里aaaa&#x27;); 8. 字符串左&#x2F;右填充: LPAD()&#x2F;RPAD() 作用: 使用指定的字符串对原字符串进行左填充或右填充到指定长度。 示例:12SELECT LPAD(&#x27;林里&#x27;, 10, &#x27;a&#x27;);SELECT RPAD(&#x27;林里&#x27;, 10, &#x27;a&#x27;); 9. 替换字符串中的所有指定子串: REPLACE() 作用: 在字符串中替换所有出现的指定子串。 示例:12SELECT REPLACE(&#x27;周芷若张无忌爱上周芷若&#x27;, &#x27;周芷若&#x27;, &#x27;赵敏&#x27;);UPDATE 表名 SET 字段 = REPLACE(字段, &#x27;可替换数值&#x27;, &#x27;待替换数值&#x27;) WHERE id = 2; 数学函数MySQL提供了多种数学函数，用于处理数值数据。这些函数可以执行从基本算术到复杂数学计算的各种操作。 1. 四舍五入: ROUND() 作用: 对数值进行四舍五入到指定的小数位数。 示例:1SELECT ROUND(数值/字段, x) FROM 表名; -- x为要保留的小数位数，当x为0时保留整数位 2. 向上取整: CEIL() 作用: 向上取整，即取大于等于该数的最小整数。 示例:12SELECT CEIL(1.02);SELECT CEIL(-1.59); 3. 向下取整: FLOOR() 作用: 向下取整，即取小于等于该数的最大整数。 示例:12SELECT FLOOR(1.02);SELECT FLOOR(-1.02); 4. 截断: TRUNCATE() 作用: 将数值截断到指定的小数位数，不进行四舍五入。 示例:12SELECT TRUNCATE(1.699999, 2);SELECT TRUNCATE(69999.999999, 5); 5. 取余: MOD() 作用: 返回两个数相除的余数。 示例:1SELECT MOD(10, 3); 6. 生成随机数: RAND() 作用: 生成一个0到1之间的随机浮点数。 示例:1SELECT RAND(); 案例生成随机整数: 生成1到10之间的随机整数:1SELECT FLOOR(RAND() * 10) + 1; 生成-10到10之间的随机整数:1SELECT FLOOR(RAND() * 21) - 10; 日期函数MySQL的日期函数允许对日期和时间值进行操作，包括提取日期部分、转换日期格式等。 1. 获取当前日期和时间: NOW() 作用: 返回当前的日期和时间。 示例:1SELECT NOW(); 2. 获取当前日期: CURDATE() 作用: 返回当前的日期。 示例:1SELECT CURDATE(); 3. 获取当前时间: CURTIME() 作用: 返回当前的时间。 示例:1SELECT CURTIME(); 4. 提取日期部分 获取年份: YEAR() 获取月份: MONTH() 获取日: DAY() 获取星期几: DAYNAME() 示例:1SELECT YEAR(字段), MONTH(字段), DAY(字段), DAYNAME(字段) FROM 表名; 5. 日期格式转换: STR_TO_DATE() 作用: 将字符串转换为日期格式。 示例: 12SELECT STR_TO_DATE(&#x27;1998-3-2&#x27;, &#x27;%Y-%c-%d&#x27;);SELECT * FROM 表名 WHERE 日期列 = STR_TO_DATE(&#x27;4-3-1992&#x27;, &#x27;%m-%d-%Y&#x27;); 6. 日期差异函数: DATEDIFF()DATEDIFF()函数在MySQL中用来计算两个日期之间的天数差异。 示例: 计算两个指定日期之间的天数差: 1SELECT DATEDIFF(&#x27;2022-12-31&#x27;, &#x27;2022-12-01&#x27;); 计算某个列中的日期与另一个日期之间的天数差，并为结果指定一个新列名: 1SELECT id, DATEDIFF(日期列1, 日期列2) AS 新列名 FROM 表名; 计算与当前系统日期的天数差: 1SELECT DATEDIFF(&#x27;2022-12-31&#x27;, CURDATE()); 聚合函数聚合函数用于执行对一组值的计算，并返回单个值。在MySQL中，常用的聚合函数包括COUNT(), MAX(), MIN(), SUM(), 和AVG()。 示例: 总数 (COUNT()): 计算表中符合条件的行数。 12SELECT COUNT(*) FROM 表名;SELECT COUNT(字段) FROM 表名 WHERE 条件; 最大值 (MAX()): 查找字段的最大值。 1SELECT MAX(字段) FROM 表名; 最小值 (MIN()): 查找字段的最小值。 1SELECT MIN(字段) FROM 表名; 求和 (SUM()): 计算字段值的总和。 1SELECT SUM(字段) FROM 表名; 平均值 (AVG()): 计算字段值的平均值。 1SELECT AVG(字段) FROM 表名; 案例 查询女生的人数: 1SELECT COUNT(*) FROM 表名 WHERE 性别 = &#x27;女&#x27;; 查询年龄为18岁的人数: 1SELECT COUNT(*) FROM 表名 WHERE 年龄 = 18; 查询年纪最大的男生: 1SELECT MAX(年龄) FROM 表名 WHERE 性别 = &#x27;男&#x27;; 查询女生的最大id: 1SELECT MAX(id) FROM 表名 WHERE 性别 = &#x27;女&#x27;; 查询年纪最小的女生: 1SELECT MIN(年龄) FROM 表名 WHERE 性别 = &#x27;女&#x27;; 查询男生的最小id: 1SELECT MIN(id) FROM 表名 WHERE 性别 = &#x27;男&#x27;; 查询女生的年龄和: 1SELECT SUM(年龄) FROM 表名 WHERE 性别 = &#x27;女&#x27;; 查询男生的id和: 1SELECT SUM(id) FROM 表名 WHERE 性别 = &#x27;男&#x27;; 查询男生的平均年龄，保留两位小数: 1SELECT ROUND(AVG(年龄), 2) FROM 表名 WHERE 性别 = &#x27;男&#x27;; 排序和分组排序: ORDER BYORDER BY子句用于根据一个或多个列的数值大小或字母顺序对查询结果进行排序，默认为升序排序。 基本排序: 1SELECT 字段1, 字段2 FROM 表名 ORDER BY 字段2; 升序排序 (ASC): 1SELECT 字段 FROM 表名 ORDER BY 字段 ASC; 降序排序 (DESC): 1SELECT 字段 FROM 表名 ORDER BY 字段 DESC; 显示指定行数 (LIMIT): 1SELECT 字段 FROM 表名 LIMIT 1, 4; -- 显示从第二行开始的四行数据 分组: GROUP BYGROUP BY子句按照对应的字段进行分组，查询结果会根据指定的列进行分组，相同值的行将被合并到同一个分组中。 基本分组: 1SELECT 字段1, 字段2 FROM 表名 GROUP BY 字段2; 分组并计数: 1SELECT COUNT(*), 字段1, 字段2 FROM 表名 GROUP BY 字段2; 分组并使用聚合函数: 1SELECT COUNT(*), GROUP_CONCAT(字段1), 字段2 FROM 表名 GROUP BY 字段2; 分组汇总 (WITH ROLLUP): 1SELECT 字段 FROM 表名 GROUP BY 字段 WITH ROLLUP; 条件筛选: HAVING和WHERE WHERE: 在分组前对数据进行过滤。 HAVING: 在分组后对分组的结果进行条件筛选。 案例 如果男生或者女生的平均年龄超过18岁就输出他们的平均年龄和性别: 1SELECT 性别, AVG(年龄) AS 平均年龄 FROM 表名 GROUP BY 性别 HAVING AVG(年龄) &gt; 18; 查询年龄在18-26岁之间的男生，年龄从小到大排序: 1SELECT * FROM 表名 WHERE 性别 = &#x27;男&#x27; AND 年龄 BETWEEN 18 AND 26 ORDER BY 年龄 ASC; 查询年龄从18到20的女生，id从低到高排序: 1SELECT * FROM 表名 WHERE 性别 = &#x27;女&#x27; AND 年龄 BETWEEN 18 AND 20 ORDER BY id ASC; 子查询子查询是嵌套在另一个查询中的查询，用于提供外部查询使用的条件或数据。 示例:1SELECT stuname, height FROM students WHERE height = (SELECT MAX(height) FROM students WHERE gender = 1); 在这个示例中，(SELECT MAX(height) FROM students WHERE gender = 1)是一个子查询，它先找出所有男生中身高最高的值，然后外部查询使用这个结果来找出具有该身高的学生信息。 表连接在数据库中，表连接是用来组合来自两个或多个表的行的过程。根据连接的类型，可以选择不同的方法来组合这些行。 内连接 (INNER JOIN) 定义: 内连接返回两个表中满足连接条件的记录。只有在两个表中都有匹配时，记录才会被包含在结果集中。 示例:123SELECT 表1.字段1, 表1.字段2, 表2.字段1 FROM 表1 INNER JOIN 表2 ON 表1.字段1 = 表2.字段2; 外连接外连接返回一个表中的所有记录和另一个表中的匹配记录。如果某侧表中的行在另一侧表中没有匹配，结果集中这些行的缺失侧将包含NULL。 左外连接 (LEFT JOIN): 定义: 返回左表的所有记录和右表中符合连接条件的记录。 示例:123SELECT 表1.字段1, 表1.字段2, 表2.字段1 FROM 表1 LEFT JOIN 表2 ON 表1.字段1 = 表2.字段2; 右外连接 (RIGHT JOIN): 定义: 返回右表的所有记录和左表中符合连接条件的记录。 示例:123SELECT 表1.字段1, 表1.字段2, 表2.字段1 FROM 表1 RIGHT JOIN 表2 ON 表1.字段1 = 表2.字段2; 表连接的区别 内连接 (INNER JOIN) 只返回两个表中关联字段相匹配的行。 外连接 (LEFT JOIN, RIGHT JOIN) 除了返回匹配的行外，还会返回左表或右表中未匹配的行，并用NULL填充未匹配的另一侧表的列。 案例假设有一个students表和class表，students表中有学生的信息，包括他们报名的班级，而class表包含班级信息。 统计两个班各有多少人报名1234SELECT class.class_name, COUNT(students.id) AS enrolment_countFROM classLEFT JOIN students ON class.id = students.class_idGROUP BY class.class_name; 统计出他们的在校时间这个查询需要有学生的入学时间和当前日期来计算在校时间，假设students表中有一个admission_date字段： 123SELECT class.class_name, students.id, DATEDIFF(CURDATE(), students.admission_date) AS days_in_schoolFROM classJOIN students ON class.id = students.class_id; 查询出报名了大数据分析基础班的女生人数假设students表中有gender字段表示性别： 1234SELECT COUNT(*) AS female_students_countFROM studentsJOIN class ON students.class_id = class.idWHERE class.class_name = &#x27;大数据分析基础班&#x27; AND students.gender = &#x27;女&#x27;; 查询报名了大数据分析全栈在18岁到20岁之间有多少人假设students表中有age字段表示年龄： 1234SELECT COUNT(*) AS students_countFROM studentsJOIN class ON students.class_id = class.idWHERE class.class_name = &#x27;大数据分析全栈&#x27; AND students.age BETWEEN 18 AND 20; 多表连接与高级数据库操作1. 多表连接在数据库设计中，多表连接是一种常用的数据查询方式，允许我们从不同的表中提取并合并信息。通过JOIN语句，我们可以实现内连接、左连接、右连接等，以满足不同的数据合并需求。 2. 临时表 定义: MySQL中的临时表用于存储会话或事务中的临时数据。这些表仅在创建它们的数据库会话中可见，并在会话结束时自动删除。 应用场景: 临时表适用于存储查询过程中的临时结果，这对于复杂的数据处理操作特别有用。 创建临时表:12345CREATE TEMPORARY TABLE temp_table_name ( column1 datatype, column2 datatype, ...); 使用示例:12345678910-- 创建临时表CREATE TEMPORARY TABLE temp_orders ASSELECT * FROM orders WHERE order_date &gt;= &#x27;2023-01-01&#x27;;-- 查询临时表SELECT * FROM temp_orders;-- 插入数据到临时表INSERT INTO temp_orders (order_id, customer_id, order_date)VALUES (1001, 1, &#x27;2023-01-05&#x27;); 3. 流程控制函数流程控制函数在SQL查询中用于根据条件返回不同的结果，这提高了SQL语句的灵活性和表达能力。 IF函数: 语法: IF(condition, true_value, false_value) 示例: SELECT IF(score &gt;= 60, &#39;Passed&#39;, &#39;Failed&#39;) AS result FROM grades; CASE表达式: 语法:1234567SELECT column_name, CASE WHEN condition1 THEN &#x27;result1&#x27; WHEN condition2 THEN &#x27;result2&#x27; ELSE &#x27;resultN&#x27; END AS alias_nameFROM table_name; 示例:12345678SELECT name, CASE WHEN score &gt;= 90 THEN &#x27;Excellent&#x27; WHEN score &gt;= 80 THEN &#x27;Good&#x27; WHEN score &gt;= 60 THEN &#x27;Pass&#x27; ELSE &#x27;Fail&#x27; END AS resultFROM scores; 4. MySQL正则表达式MySQL正则表达式提供了一种强大的工具来进行复杂的模式匹配和数据检索。通过使用正则表达式，你可以在SQL查询中执行高级文本匹配，从而筛选出满足特定模式的数据行。这在处理文本数据时尤其有用，比如搜索日志、验证数据格式或提取特定格式的信息等场景。 基本使用在MySQL中，REGEXP或RLIKE运算符用于正则表达式匹配，检查左侧的字符串是否匹配右侧的正则表达式模式。 语法:1SELECT column FROM table WHERE column REGEXP pattern; 常用模式 ^: 匹配输入字符串的开始位置。 $: 匹配输入字符串的结束位置。 .: 匹配除“\\n”之外的任何单个字符。 *: 匹配前面的字符零次或多次。 +: 匹配前面的字符一次或多次。 ?: 匹配前面的字符零次或一次。 [...]: 匹配方括号内的任意字符。 |: 选择，匹配|前后的任一模式。 (..): 分组标记，将()内的作为一个整体进行处理。 示例 匹配以特定字符开始的字符串: 1SELECT * FROM table WHERE column REGEXP &#x27;^abc&#x27;; 匹配包含特定字符的字符串: 1SELECT * FROM table WHERE column REGEXP &#x27;abc&#x27;; 匹配以特定字符结束的字符串: 1SELECT * FROM table WHERE column REGEXP &#x27;abc$&#x27;; 匹配任意位置包含数字的字符串: 1SELECT * FROM table WHERE column REGEXP &#x27;[0-9]&#x27;; 匹配包含两个连续相同字符的字符串: 1SELECT * FROM table WHERE column REGEXP &#x27;(.)\\\\1&#x27;; 高级应用 分组和选择:使用分组()和选择|可以构造更复杂的匹配模式。例如，匹配包含abc或def的字符串： 1SELECT * FROM table WHERE column REGEXP &#x27;abc|def&#x27;; 字符类:使用字符类[...]可以匹配指定范围内的字符。例如，匹配任何小写字母： 1SELECT * FROM table WHERE column REGEXP &#x27;[a-z]&#x27;; MySQL的正则表达式功能提供了灵活而强大的数据匹配能力，使得对于复杂文本数据的查询和分析变得更加高效和精确。通过合理利用正则表达式，可以极大地提升数据处理的能力和效率。 5. UNION操作 定义: UNION操作符用于合并两个或多个SELECT语句的结果集，并默认去除重复行。 语法: 123SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2; 示例: 123SELECT student_name FROM studentsUNIONSELECT teacher_name FROM teachers; UNION ALL: 如果希望保留重复行，可以使用UNION ALL。 123SELECT column_name FROM table1UNION ALLSELECT column_name FROM table2; 这些高级功能和操作提供了强大的工具，用于管理和查询数据库中的数据，允许进行复杂的数据分析和处理。通过灵活使用这些工具，可以有效地解决多种数据处理的需求。 案例围绕一个学校的数据库模型，涉及学生(Student)、课程(Course)、教师(Teacher)和成绩(Scores)四个主要表。 数据库表结构 学生表(Student) S (VARCHAR(10)): 学生编号 Sname (VARCHAR(10)): 学生姓名 Sage (DATETIME): 学生出生日期 Ssex (VARCHAR(10)): 学生性别 课程表(Course) C (VARCHAR(10)): 课程编号 Cname (VARCHAR(10)): 课程名称 T (VARCHAR(10)): 教师编号 教师表(Teacher) T (VARCHAR(10)): 教师编号 Tname (VARCHAR(10)): 教师姓名 成绩表(SC) S (VARCHAR(10)): 学生编号 C (VARCHAR(10)): 课程编号 score (DECIMAL(18,1)): 成绩 查询需求及SQL实现 查询”01”课程比”02”课程成绩高的学生的信息及课程分数 思路：使用自连接查询SC表，比较同一学生的两门课成绩。 12345SELECT s1.S, Sname, s1.score AS &#x27;01_Score&#x27;, s2.score AS &#x27;02_Score&#x27;FROM SC s1JOIN SC s2 ON s1.S = s2.S AND s1.C = &#x27;01&#x27; AND s2.C = &#x27;02&#x27;JOIN Student ON Student.S = s1.SWHERE s1.score &gt; s2.score; 查询同时选修01和02课程的情况 思路：查找同时在SC表中存在课程编号为”01”和”02”记录的学生。 1234SELECT DISTINCT s.S, SnameFROM Student sJOIN SC sc1 ON s.S = sc1.S AND sc1.C = &#x27;01&#x27;JOIN SC sc2 ON s.S = sc2.S AND sc2.C = &#x27;02&#x27;; 查询存在”01”课程但可能不存在”02”课程的情况 思路：使用左连接确保”01”课程存在，而”02”课程可能不存在。 12345SELECT DISTINCT s.S, SnameFROM Student sJOIN SC sc1 ON s.S = sc1.S AND sc1.C = &#x27;01&#x27;LEFT JOIN SC sc2 ON s.S = sc2.S AND sc2.C = &#x27;02&#x27;WHERE sc2.S IS NULL; 查询不存在”01”课程但存在”02”课程的情况 思路：反转第3题的逻辑，使用左连接确保”02”课程存在，而”01”课程不存在。 12345SELECT DISTINCT s.S, SnameFROM Student sJOIN SC sc2 ON s.S = sc2.S AND sc2.C = &#x27;02&#x27;LEFT JOIN SC sc1 ON s.S = sc1.S AND sc1.C = &#x27;01&#x27;WHERE sc1.S IS NULL; 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩 思路：对SC表进行分组聚合查询，计算每个学生的平均成绩。 12345SELECT s.S, Sname, AVG(score) AS Avg_ScoreFROM Student sJOIN SC ON s.S = SC.SGROUP BY s.S, SnameHAVING AVG(score) &gt;= 60; 查询SC表存在成绩的学生信息 思路：查询SC表中有成绩记录的学生信息。 123SELECT DISTINCT Student.S, SnameFROM StudentJOIN SC ON Student.S = SC.S; 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩 思路：对SC表进行分组聚合查询，同时计算选课总数和成绩总和。 1234SELECT s.S, Sname, COUNT(SC.C) AS Course_Count, SUM(SC.score) AS Total_ScoreFROM Student sLEFT JOIN SC ON s.S = SC.SGROUP BY s.S, Sname; 查没有成绩的学生信息 思路：查询Student表中不存在于SC表中的学生信息。 123SELECT S, SnameFROM StudentWHERE S NOT IN (SELECT DISTINCT S FROM SC); 查询「李」姓老师的数量 思路：根据教师姓名筛选并计数。 123SELECT COUNT(*) AS Li_TeachersFROM TeacherWHERE Tname LIKE &#x27;李%&#x27;; 查询学过「张三」老师授课的同学的信息 思路：先找到「张三」老师的课程，再查询选修这些课程的学生信息。 123456SELECT DISTINCT Student.S, SnameFROM StudentJOIN SC ON Student.S = SC.SJOIN Course ON SC.C = Course.CJOIN Teacher ON Course.T = Teacher.TWHERE Teacher.Tname = &#x27;张三&#x27;; 查询没有学全所有课程的同学的信息 思路：需要比较学生选修的课程数量和课程表中课程总数。 12345SELECT s.S, SnameFROM Student sJOIN SC ON s.S = SC.SGROUP BY s.S, SnameHAVING COUNT(DISTINCT SC.C) &lt; (SELECT COUNT(*) FROM Course); 查询至少有一门课与学号为”01”的同学所学相同的同学的信息 思路：首先找出学号为”01”的同学所学的课程，然后查找至少选修了这些课程之一的其他同学。 1234SELECT DISTINCT Student.S, SnameFROM StudentJOIN SC ON Student.S = SC.SWHERE SC.C IN (SELECT SC.C FROM SC WHERE S = &#x27;01&#x27;) AND Student.S != &#x27;01&#x27;; 项目本项目通过分析广州的wassup网店在12月份的用户交易情况和产品情况，目的是为了提供数据支持，帮助店主更好地经营小店。通过对产品情况表product_tb和销售数据表sales_tb的查询分析，以下是从五个关键方面的详细分析和查询实现。 产品情况表 (product_tb) 表结构： item_id (VARCHAR(30)): 商品的具体货号。 style_id (VARCHAR(30)): 商品的款号。 tag_price (INT): 商品的标签价格。 inventory (INT): 商品的库存量。 示例数据： 商品范围从A001到C002，覆盖三个不同的款式（A、B、C）。 每个款式下有不同的货号，价格和库存量各不相同。 123456789101112131415CREATE TABLE product_tb(item_id VARCHAR(30), style_id VARCHAR(30), tag_price INT, inventory INT); INSERT INTO product_tb VALUES(&#x27;A001&#x27;,&#x27;A&#x27;,100,20),(&#x27;A002&#x27;,&#x27;A&#x27;,120,30),(&#x27;A003&#x27;,&#x27;A&#x27;,200,15),(&#x27;B001&#x27;,&#x27;B&#x27;,130,18),(&#x27;B002&#x27;,&#x27;B&#x27;,150,22),(&#x27;B003&#x27;,&#x27;B&#x27;,125,10),(&#x27;B004&#x27;,&#x27;B&#x27;,155,12),(&#x27;C001&#x27;,&#x27;C&#x27;,260,25),(&#x27;C002&#x27;,&#x27;C&#x27;,280,18); 销售数据表 (sales_tb) 表结构： sales_date (DATE): 销售日期。 user_id (INT): 用户编号。 item_id (VARCHAR(30)): 销售的商品货号。 sales_num (INT): 销售数量。 sales_price (INT): 销售结算金额。 示例数据： 销售记录从2023-12-01到2023-12-06，涵盖了多个用户对不同货号商品的购买行为。 销售数据包含销售数量和销售结算金额，可以通过这些数据分析商品的销售情况和用户购买偏好。 123456789101112131415161718192021CREATE TABLE sales_tb(sales_date DATE, user_id INT, item_id VARCHAR(30), sales_num INT, sales_price INT);INSERT INTO sales_tb VALUES(&#x27;2023-12-01&#x27;,&#x27;1&#x27;,&#x27;A001&#x27;,&#x27;1&#x27;,90),(&#x27;2023-12-01&#x27;,&#x27;2&#x27;,&#x27;A002&#x27;,&#x27;2&#x27;,220),(&#x27;2023-12-01&#x27;,&#x27;2&#x27;,&#x27;B001&#x27;,&#x27;1&#x27;,120),(&#x27;2023-12-02&#x27;,&#x27;3&#x27;,&#x27;C001&#x27;,&#x27;2&#x27;,500),(&#x27;2023-12-02&#x27;,&#x27;4&#x27;,&#x27;B001&#x27;,&#x27;1&#x27;,120),(&#x27;2023-12-03&#x27;,&#x27;5&#x27;,&#x27;C001&#x27;,&#x27;1&#x27;,240),(&#x27;2023-12-03&#x27;,&#x27;6&#x27;,&#x27;C002&#x27;,&#x27;1&#x27;,270),(&#x27;2023-12-04&#x27;,&#x27;7&#x27;,&#x27;A003&#x27;,&#x27;1&#x27;,180),(&#x27;2023-12-04&#x27;,&#x27;8&#x27;,&#x27;B002&#x27;,&#x27;1&#x27;,140),(&#x27;2023-12-04&#x27;,&#x27;9&#x27;,&#x27;B001&#x27;,&#x27;1&#x27;,125),(&#x27;2023-12-04&#x27;,&#x27;10&#x27;,&#x27;B003&#x27;,&#x27;1&#x27;,120),(&#x27;2023-12-05&#x27;,&#x27;10&#x27;,&#x27;B004&#x27;,&#x27;1&#x27;,150),(&#x27;2023-12-05&#x27;,&#x27;10&#x27;,&#x27;A003&#x27;,&#x27;1&#x27;,180),(&#x27;2023-12-06&#x27;,&#x27;11&#x27;,&#x27;B003&#x27;,&#x27;1&#x27;,120),(&#x27;2023-12-06&#x27;,&#x27;10&#x27;,&#x27;B004&#x27;,&#x27;1&#x27;,150); 问题1: 查询每款的SPU（货号）数量及排序 目的：了解店铺的产品种类和每个款式下具体货号的数量。 SQL 查询：1234SELECT style_id, COUNT(item_id) AS SPU FROM product_tb GROUP BY style_id ORDER BY COUNT(item_id) DESC; 问题2: 查询实际总销售额与客单价 目的：分析用户的平均消费金额，以及总销售额。 SQL 查询：1234SELECT SUM(sales_price) AS `销售总额`, ROUND(SUM(sales_price)/COUNT(DISTINCT user_id), 2) AS `客单价`FROM sales_tb; 问题3: 查询折扣率 目的：分析店铺的促销效果，了解整体和各款式、各货号的折扣情况。 总的折扣率查询：12345SELECT CONCAT( (1 - SUM(sales_price) / SUM(sales_tb.sales_num * product_tb.tag_price)) * 100, &#x27;%&#x27;) AS `折扣率`FROM sales_tbJOIN product_tb ON sales_tb.item_id = product_tb.item_id; 每个款号的折扣率查询：1234567SELECT product_tb.style_id, CONCAT( ((SUM(sales_tb.sales_num * product_tb.tag_price) - SUM(sales_tb.sales_price)) / SUM(sales_tb.sales_num * product_tb.tag_price)) * 100, &#x27;%&#x27;) AS `折扣率`FROM sales_tbJOIN product_tb ON sales_tb.item_id = product_tb.item_idGROUP BY product_tb.style_id; 问题4: 查询每款的动销率与售罄率 目的：了解每款产品的销售情况，包括动销率和售罄率，以评估库存和销售效率。 SQL 查询：1234567891011121314SELECT a.style_id, ROUND(b.sum_num/(a.sum_inv-b.sum_num)*100, 2) AS &#x27;pin_rate(%)&#x27;, ROUND(b.GMV/a.sum_pri*100, 2) AS &#x27;sell-through_rate(%)&#x27;FROM (SELECT style_id, SUM(inventory) AS sum_inv, SUM(tag_price * inventory) AS sum_pri FROM product_tb GROUP BY style_id) AS aLEFT JOIN (SELECT LEFT(item_id, 1) AS style_id, SUM(sales_num) AS sum_num, SUM(sales_price) AS GMV FROM sales_tb GROUP BY style_id) AS b ON a.style_id = b.style_idORDER BY a.style_id; 问题5: 查询连续2天及以上在该店铺购物的用户及其对应的次数 目的：分析用户消费频率与粘性，特别是连续购物行为的用户。 SQL 查询：1234567891011SELECT user_id, COUNT(rn)FROM (SELECT DISTINCT user_id, sales_date, DENSE_RANK() OVER (PARTITION BY user_id ORDER BY sales_date) rn FROM sales_tb) AS aGROUP BY user_id, DATE_SUB(sales_date, INTERVAL rn DAY)HAVING COUNT(*) &gt; 2; 以上分析从产品种类和数量、销售额和客单价、促销折扣率、产品动销率和售罄率、以及用户消费频率和粘性五个方面全面分析了wassup网店的12月份经营情况。这些数据分析可以为店铺","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://www.yiuhangblog.com/tags/SQL/"}],"author":"Yiuhang Chan"},{"title":"Matplotlib","slug":"20181206Matplotlib","date":"2018-12-06T08:39:37.000Z","updated":"2024-03-19T11:05:01.000Z","comments":true,"path":"2018/12/06/20181206Matplotlib/","permalink":"https://www.yiuhangblog.com/2018/12/06/20181206Matplotlib/","excerpt":"Python Matplotlib包","text":"MatplotlibMatplotlib 是一个广泛用于 Python 中的绘图库，它可以帮助我们创建各种图表和图形，适用于数据可视化。 安装 Matplotlib为了安装 Matplotlib，我们首先确保 Python 和 pip（Python 的包安装器）已经安装在系统上。接着可以通过下面的命令来安装或更新 Matplotlib： 12345# 首先，更新 pip 到最新版本python -m pip install --upgrade pip# 然后，使用 pip 安装 Matplotlibpython -m pip install matplotlib 注意，如果使用的是 Linux 或 macOS 系统，可能需要使用 python3 和 pip3 命令替代 python 和 pip。 导入 Matplotlib安装完成后，我们可以通过以下方式导入 Matplotlib： 1import matplotlib 实际上，更常见的做法是导入 matplotlib.pyplot，这是一个提供了类似 MATLAB 接口的绘图模块： 1import matplotlib.pyplot as plt Matplotlib Pyplot 常用函数Pyplot 模块提供了很多用于创建和操作图形的函数。以下是一些常用的 Pyplot 函数： plot()：这是最常用的函数之一，用于绘制点和线。例如，plt.plot(x, y) 会绘制 x 对 y 的图。 scatter()：这个函数专门用于创建散点图。例如，plt.scatter(x, y) 会创建 x 和 y 数据点的散点图。 bar()：这个函数用来创建条形图。例如，plt.bar(x, height) 会在 x 的位置创建条形图，其中 height 是条形的高度。 hist()：此函数用于绘制直方图，是数据分布可视化的重要工具。例如，plt.hist(data) 会绘制 data 的直方图。 pie()：这个函数用于绘制饼图，常用于显示部分整体的比例关系。例如，plt.pie(sizes) 会根据 sizes 的比例绘制一个饼图。 imshow()：这个函数常用于显示图像，特别是在处理图像数据的时候。例如，plt.imshow(image) 会显示一个图像数组。 subplots()：此函数用于创建一个包含多个子图的图形。例如，fig, ax = plt.subplots() 创建一个新的图形和一个子图。 简单示例下面是一个简单的 Matplotlib Pyplot 使用示例： 12345678910111213141516171819202122232425import matplotlib.pyplot as plt# 准备数据x = [1, 2, 3, 4]y = [10, 20, 25, 30]# 创建图表plt.figure(figsize=(8, 6))# 绘制线图plt.plot(x, y, label=&#x27;Line&#x27;)# 绘制散点图plt.scatter(x, y, color=&#x27;red&#x27;, label=&#x27;Scatter&#x27;)# 添加标题和标签plt.title(&#x27;Sample Plot&#x27;)plt.xlabel(&#x27;X Axis&#x27;)plt.ylabel(&#x27;Y Axis&#x27;)# 显示图例plt.legend()# 展示图形plt.show() 高级功能 图形风格：Matplotlib 允许选择多种预设的风格，例如 plt.style.use(&#39;ggplot&#39;)。 保存图形：可以使用 plt.savefig(&#39;filename.png&#39;) 将图形保存到文件中。 交互式模式：Matplotlib 还可以创建交互式图形，使用 plt.ion() 开启交互模式。 完整制作示例制作图表是数据分析中一项重要的工作，它有助于从视觉上展现和理解数据。提供的步骤是图表制作的基本流程，包括了从导入库到设置xy轴数据，以及绘制和显示图形。现在我们就来细化这个流程，并添加一些细节和扩展，使其更为完整和专业。 步骤1：导入必要的库123import matplotlib.pyplot as pltimport numpy as npimport pandas as pd 这一步导入了创建图表所需的主要 Python 库：matplotlib 用于绘图，numpy 用于处理数值数据，pandas 用于读取和处理数据文件。 步骤2：设置xy轴数据方法1：使用 Numpy 创建数据12xpoints = np.array([0, 6])ypoints = np.array([0, 100]) 这个方法是手动创建数据，适合理解绘图的基础概念或当有一些固定的数据点时使用。 方法2：从数据文件导入123456789# 从 CSV 文件中读取数据open_df = pd.read_csv(&#x27;./财务差旅人员费用分析.csv&#x27;)xpoints = open_df[&#x27;姓名&#x27;]ypoints = open_df[&#x27;金额&#x27;]# 另一个例子df = pd.read_csv(&#x27;./年龄段借款情况.csv&#x27;)xpoints = df[&#x27;年龄&#x27;]ypoints = df[&#x27;已还清&#x27;] 在实际应用中，数据通常来源于数据集，因此使用 Pandas 读取和处理数据是非常常见的。 步骤3：绘制图形1234567891011121314151617181920# 绘制基础的线图plt.plot(xpoints, ypoints)# 设置图表的标题和轴标签plt.title(&#x27;Loan Status by Age&#x27;)plt.xlabel(&#x27;Age&#x27;)plt.ylabel(&#x27;Loans Paid Off&#x27;)# 显示图例plt.legend([&#x27;Loans Paid Off&#x27;])# 在图表中添加网格plt.grid(True)# 设置轴的范围plt.xlim(0, 100)plt.ylim(0, 120)# 展示图形plt.show() 这一步创建了图形，并对其进行了一些基础的格式设置，包括添加标题、轴标签、图例和网格，这使图表更易于理解和分析。 扩展和细节 样式定制：可以通过添加颜色、线型和标记样式来定制图形的外观，如 plt.plot(xpoints, ypoints, &#39;o:r&#39;)，表示圆圈标记、虚线和红色。 多系列绘制：可以在同一个图中绘制多个数据系列，以对比不同数据集，如通过多次调用 plt.plot()。 子图：使用 plt.subplots() 创建一个包含多个子图的图形布局。 保存图形：使用 plt.savefig(&#39;filename.png&#39;) 将图形保存到文件中。 其他图形类型：除了线图，还可以使用 plt.bar(), plt.scatter(), plt.hist() 等函数来创建条形图、散点图和直方图等。 通过以上步骤，我们可以创建一个简单但完整的图表。在实践中，可能需要根据数据的具体情况和分析目的进行更多的定制和调整。使用 Matplotlib，可以灵活地制作出满足不同需求的图表。 图表的属性能够帮助我们创建更为精细和吸引人的视觉效果，这对于数据的呈现和解释非常重要。以下是有关如何使用 Matplotlib 的一些详细和专业的笔记，涵盖了图表窗口的创建和自定义，以及如何使用标记来突出数据点。 图表属性画布123456import matplotlib.pyplot as plt# 创建一个新的图形窗口并设置尺寸plt.figure(figsize=(8, 6), dpi=150, facecolor=&#x27;white&#x27;, edgecolor=&#x27;black&#x27;, tight_layout=True, num=&#x27;Window 1&#x27;)plt.plot([1, 2, 3, 4], [1, 4, 9, 16])plt.show() 画布属性说明： figsize: 设置图形窗口的尺寸，单位为英寸。更大的尺寸可以让图表更清晰地显示更多的细节。 dpi: 分辨率（每英寸点数），默认通常为 100 或 80。增加此值可以获得更高清的图形。 facecolor 和 edgecolor: 分别用于设置图形窗口的背景色和边框颜色。 tight_layout: 当设置为 True 时，它会自动调整子图参数，以便子图填满图形窗口的整个画布区域。 num: 当你需要创建多个图形窗口时，使用此参数给图形命名或编号。 Marker在 plt.plot() 中使用 marker 参数可以突出显示每个数据点，提高图表的可读性，特别是在绘制散点图或者需要标示数据点的场景中。 123456xpoints = [1, 2, 3, 4]ypoints = [1, 4, 9, 16]# 绘制带有自定义标记的线图plt.plot(xpoints, ypoints, marker=&#x27;o&#x27;, ms=20, mfc=&#x27;r&#x27;, mec=&#x27;b&#x27;)plt.show() Marker 相关属性说明： marker: 定义数据点的标记类型，如 &#39;o&#39; 表示圆圈。 ms (markersize): 标记的大小。 mfc (markerfacecolor): 标记内部的颜色。 mec (markeredgecolor): 标记边框的颜色。 扩展属性 线条样式: 通过 linestyle 或简写 ls 参数定义线条的样式，如 &#39;--&#39; 表示虚线。 1plt.plot(xpoints, ypoints, linestyle=&#x27;--&#x27;) 线条宽度: 使用 linewidth 或简写 lw 参数定义线条的宽度。 1plt.plot(xpoints, ypoints, linewidth=2) 颜色: 通过 color 参数指定线条的颜色。 1plt.plot(xpoints, ypoints, color=&#x27;green&#x27;) 文本和注释: 使用 plt.text() 在图表中添加文本，使用 plt.annotate() 在图表中添加注释。 12plt.text(1, 15, &#x27;Sample Text&#x27;, fontsize=12)plt.annotate(&#x27;Important Point&#x27;, xy=(2, 4), xytext=(3, 5), arrowprops=dict(arrowstyle=&#x27;-&gt;&#x27;)) 坐标轴范围: 使用 plt.xlim() 和 plt.ylim() 设置坐标轴的范围。 12plt.xlim(0, 5)plt.ylim(0, 20) 坐标轴标签: 使用 plt.xlabel() 和 plt.ylabel() 给坐标轴添加标签。 12plt.xlabel(&#x27;X Axis Label&#x27;)plt.ylabel(&#x27;Y Axis Label&#x27;) 图表标题: 使用 plt.title() 添加图表的标题。 1plt.title(&#x27;Chart Title&#x27;) 在 Matplotlib 中，线条样式和宽度是定义图表外观的关键属性，它们可以帮助我们区分图中的不同数据系列或者强调某些数据点。下面详细说明了如何设置线条样式和宽度。 线条样式linestyle 或简写 ls 参数用来定义线条的样式。这个参数可以接受多种不同的值，以改变线条的显示方式。 linestyle 的可用样式: &#39;-&#39; 或 &#39;solid&#39;: 实线 &#39;--&#39; 或 &#39;dashed&#39;: 虚线 &#39;-.&#39; 或 &#39;dashdot&#39;: 点划线 &#39;:&#39; 或 &#39;dotted&#39;: 点线 &#39;&#39; 或 &#39;None&#39;: 无线条 示例代码：12345678import matplotlib.pyplot as pltxpoints = [0, 1, 2, 3]ypoints = [0, 3, 6, 9]# 使用点线样式plt.plot(xpoints, ypoints, linestyle=&#x27;:&#x27;)plt.show() 线条宽度linewidth 或简写 lw 参数用来定义线条的宽度，可以是任何浮点数。线宽越大，线条越粗。 示例代码：123# 使用线宽为10的实线plt.plot(xpoints, ypoints, linestyle=&#x27;-&#x27;, linewidth=10)plt.show() 请注意，linewidth 的值不应该是字符串，因此 lw=&#39;10&#39; 需要改为 lw=10。 颜色除了线条样式和宽度，我们还可以通过 color 参数来定义线条的颜色。颜色可以是 CSS 颜色的名称（如 &#39;blue&#39;、&#39;green&#39; 等），也可以是十六进制颜色代码（如 &#39;#008000&#39;）或 RGB 元组（如 (0, 0.5, 0)）。 示例代码：123# 使用绿色线条plt.plot(xpoints, ypoints, color=&#x27;green&#x27;)plt.show() 扩展属性 坐标轴刻度: 使用 plt.xticks() 和 plt.yticks() 设置坐标轴的刻度。 12plt.xticks([0, 1, 2, 3, 4])plt.yticks([0, 5, 10, 15, 20]) 网格线: 使用 plt.grid() 添加网格线，提高图表的可读性。 1plt.grid(True) 保存图表: 使用 plt.savefig() 保存图表到文件，支持多种格式，如 PNG、JPEG、SVG、PDF 等。 1plt.savefig(&#x27;my_plot.png&#x27;) 在 Matplotlib 中，色彩、多线条绘制、图表的标签和标题都是用来增强图表表达能力的重要元素。以下是对你所提供内容的整理和扩展。 颜色（Color）color 参数用于定义线条的颜色。可以使用多种方法来指定颜色，例如使用预定义的颜色码（如 &#39;r&#39; 表示红色）或者 CSS 颜色名称。 示例代码：12plt.plot(xpoints, ypoints, color=&#x27;red&#x27;) # 或者使用 &#x27;r&#x27;plt.show() 多线条（Multiple Lines）在同一个图表中绘制多条线可以帮助我们比较不同数据集之间的关系。 示例代码：1234plt.plot(xpoints, ypoints1, marker=&#x27;o&#x27;, linestyle=&#x27;:&#x27;, linewidth=1, label=&#x27;Paid Off&#x27;)plt.plot(xpoints, ypoints2, marker=&#x27;o&#x27;, linestyle=&#x27;:&#x27;, linewidth=1, label=&#x27;Overdue&#x27;)plt.legend()plt.show() 这里，每条 plot 命令绘制了一组数据点，label 参数用于定义每条线的图例名称。 标签和标题（Labels and Title）使用 xlabel(), ylabel(), 和 title() 方法来设置 x 轴、y 轴标签和图表的标题。 标题与标签的定位：可以指定标题和标签在轴上的位置，以提高图表的美观度或强调某部分内容。 12345plt.title(&quot;Title&quot;, loc=&#x27;left&#x27;)plt.xlabel(&quot;X Label&quot;, loc=&#x27;center&#x27;)plt.ylabel(&quot;Y Label&quot;, loc=&#x27;bottom&#x27;)plt.plot(x, y)plt.show() loc 参数用于设置对齐方式。 标签设置（Setting Line Labels）为了区分图中的多条线，我们可以给每条线添加标签，然后用 legend() 方法显示图例。 1234plt.plot(xpoints, ypoints1, label=&#x27;Paid Off&#x27;)plt.plot(xpoints, ypoints2, label=&#x27;Overdue&#x27;)plt.legend()plt.show() 扩展和细节： 字体大小和样式：可以通过 fontsize 和 fontweight 参数来调整标签和标题的字体大小和粗细。 1plt.title(&quot;Title&quot;, loc=&#x27;left&#x27;, fontsize=14, fontweight=&#x27;bold&#x27;) 图例位置和样式：legend() 方法接受 loc 参数来指定图例的位置，例如 &#39;upper right&#39;、&#39;lower left&#39; 等。还可以设置边框和背景。 1plt.legend(loc=&#x27;upper right&#x27;, frameon=False) # frameon=False 去除图例边框 设置网格：grid() 函数可用于添加网格线，提高图表的可读性。 1plt.grid(color=&#x27;gray&#x27;, linestyle=&#x27;--&#x27;, linewidth=0.5) 坐标轴刻度格式：可以使用 xticks() 和 yticks() 方法来定制轴刻度的显示方式。 1plt.xticks(rotation=45) # X轴刻度标签旋转45度 坐标轴范围：使用 xlim() 和 ylim() 设置轴的范围，更精确地控制图表中显示的数据范围。 12plt.xlim(0, 10)plt.ylim(0, 20) 保存图表：使用 savefig() 方法，可以将图表保存到文件中，如 PNG、PDF、SVG等格式。 1plt.savefig(&#x27;my_chart.png&#x27;, dpi=300, bbox_inches=&#x27;tight&#x27;) 多图布局创建多图在Python的matplotlib库中，subplot()和subplots()方法是绘制多图布局中非常重要的工具。这些方法允许我们在一个画布(canvas)上创建多个子图(subplots)。下面，我将对你提供的笔记进行整理和修正，确保其内容既准确又专业。 subplot()subplot()方法用于在画布上创建单个子图。其使用方式如下： subplot(nrows, ncols, index, **kwargs): 将画布分为nrows行和ncols列，index确定子图的位置。 subplot(pos, **kwargs): pos参数可以是三位数字，分别表示行数、列数和索引位置。 subplot(**kwargs): 直接通过关键字参数来指定布局和位置。 subplot(ax): 允许在已存在的轴对象ax上创建子图。 在使用subplot()时，整个绘图区域被分成nrows行和ncols列，然后从左到右、从上到下对每个子区域进行编号（1到N）。左上的子区域编号为1，右下的区域编号为N。可以通过index参数指定子图的具体位置。 创建多图示例示例1: 1x2布局123456789101112131415161718192021import matplotlib.pyplot as plt# 设置画布大小和分辨率plt.figure(figsize=(10, 8), dpi=120)# 第一个子图：借款笔数占比plt.subplot(1, 2, 1)x = df[&#x27;年龄&#x27;]y = df[&#x27;借款笔数占比&#x27;]plt.plot(x, y)plt.title(&quot;借款笔数占比&quot;)# 第二个子图：已还清占比plt.subplot(1, 2, 2)x = df[&#x27;年龄&#x27;]y = df[&#x27;已还清占比&#x27;]plt.plot(x, y)plt.title(&quot;已还清占比&quot;)plt.suptitle(&quot;借款情况分析&quot;)plt.show() 示例2: 2x2布局在2x2的布局中，我们可以创建4个子图： 1234567891011121314151617181920212223242526272829303132333435import matplotlib.pyplot as plt# 设置画布大小和分辨率plt.figure(figsize=(10, 8), dpi=120)# 第一个子图：年龄段已还清人数plt.subplot(2, 2, 1)x = df[&#x27;年龄&#x27;]y = df[&#x27;已还清&#x27;]plt.plot(x, y, marker=&#x27;v&#x27;, color=&#x27;green&#x27;, ls=&#x27;-.&#x27;)plt.title(&quot;年龄段已还清人数&quot;)# 第二个子图：年龄段历史借款次数plt.subplot(2, 2, 2)x = df[&#x27;年龄&#x27;]y = df[&#x27;历史成功借款次数&#x27;]plt.plot(x, y, marker=&#x27;v&#x27;, color=&#x27;purple&#x27;, ls=&#x27;-&#x27;)plt.title(&quot;年龄段历史借款次数&quot;)# 第三个子图：年龄段正常还款plt.subplot(2, 2, 3)x = df[&#x27;年龄&#x27;]y = df[&#x27;正常还款中&#x27;]plt.plot(x, y, marker=&#x27;x&#x27;, color=&#x27;brown&#x27;, ls=&#x27;:&#x27;)plt.title(&quot;年龄段正常还款&quot;)# 第四个子图：年龄段借款金额plt.subplot(2, 2, 4)x = df[&#x27;年龄&#x27;]y = df[&#x27;借款金额&#x27;]plt.plot(x, y, marker=&#x27;X&#x27;, color=&#x27;orange&#x27;, ls=&#x27;-&#x27;)plt.title(&quot;年龄段借款金额&quot;)plt.suptitle(&quot;年龄段借款情况&quot;)plt.show() 在上述示例中，plt.figure()用于设置整个画布的大小和分辨率，而plt.subplot()用于创建并定位子图。我们可以通过调整marker、color和ls（线型）参数来美化图表。 接下来，我们将讨论如何在Matplotlib中共享x轴以及调整多图之间的间距，这对于创建清晰、易于理解的视觉表示特别重要。 共享X轴在某些情况下，我们可能需要在同一图表中显示两组数据，这些数据共享x轴但有不同的y轴。这可以通过使用ax.twinx()方法来实现，它允许我们为同一个x轴创建一个新的y轴。 单图示例在单个图表中展示两组数据，共享x轴： 1234567891011121314151617181920212223import matplotlib.pyplot as plt# 创建第一个轴对象ax1 = plt.subplot()ax2 = ax1.twinx() # 创建共享x轴的第二个轴对象x = df[&#x27;年龄&#x27;]y1 = df[&#x27;已还清&#x27;]# 在第一个轴上绘制数据ax1.plot(x, y1, marker=&#x27;v&#x27;, color=&#x27;green&#x27;, ls=&#x27;-.&#x27;)ax1.set_ylabel(&#x27;已还清&#x27;, color=&#x27;green&#x27;)y2 = df[&#x27;历史成功借款次数&#x27;]# 在第二个轴上绘制数据ax2.plot(x, y2, marker=&#x27;v&#x27;, color=&#x27;purple&#x27;, ls=&#x27;-&#x27;)ax2.set_ylabel(&#x27;历史成功借款次数&#x27;, color=&#x27;purple&#x27;)# 设置共享x轴的标签ax1.set_xlabel(&#x27;年龄&#x27;)plt.show() 多图示例在一个画布上绘制两个图表，每个图表中都展示两组数据，共享x轴： 123456789101112131415161718192021222324252627282930313233343536import matplotlib.pyplot as plt# 第一个图表ax1 = plt.subplot(1, 2, 1)ax2 = ax1.twinx()x = df[&#x27;年龄&#x27;]y1 = df[&#x27;已还清&#x27;]ax1.plot(x, y1, marker=&#x27;v&#x27;, color=&#x27;green&#x27;, ls=&#x27;-.&#x27;)ax1.set_ylabel(&#x27;已还清&#x27;, color=&#x27;green&#x27;)y2 = df[&#x27;历史成功借款次数&#x27;]ax2.plot(x, y2, marker=&#x27;v&#x27;, color=&#x27;purple&#x27;, ls=&#x27;-&#x27;)ax2.set_ylabel(&#x27;历史成功借款次数&#x27;, color=&#x27;purple&#x27;)ax1.set_xlabel(&#x27;年龄&#x27;)# 第二个图表ax1 = plt.subplot(1, 2, 2)ax2 = ax1.twinx()y1 = df[&#x27;借款金额&#x27;]ax1.plot(x, y1, marker=&#x27;v&#x27;, color=&#x27;green&#x27;, ls=&#x27;-.&#x27;)ax1.set_ylabel(&#x27;借款金额&#x27;, color=&#x27;green&#x27;)y2 = df[&#x27;逾期中&#x27;]ax2.plot(x, y2, marker=&#x27;v&#x27;, color=&#x27;purple&#x27;, ls=&#x27;-&#x27;)ax2.set_ylabel(&#x27;逾期中&#x27;, color=&#x27;purple&#x27;)ax1.set_xlabel(&#x27;年龄&#x27;)plt.show() 注意：在第二个图表中，y轴的标签需要根据实际数据进行相应的修改。 调整多图之间的间距当在一个画布上绘制多个子图时，可能需要调整它们之间的间距以避免标签和图表元素的相互重叠。这可以通过plt.subplots_adjust()方法实现： 12345# 调整子图之间的水平间距plt.subplots_adjust(wspace=0.5)# 调整子图之间的垂直间距plt.subplots_adjust(hspace=0.5) wspace和hspace参数控制子图之间的宽度和高度的间距，值为比例（相对于子图宽度和高度的比例）。 柱状图是数据可视化中常用的图表类型，适用于展示不同类别间的比较。在Matplotlib中，使用plt.bar()和plt.barh()可以分别绘制垂直和水平的柱状图。以下是如何在Matplotlib中创建和自定义柱状图的详细说明。 基础柱状图创建一个基础柱状图，用于展示不同年龄段的已还清金额： 1234567import matplotlib.pyplot as pltplt.figure(figsize=(8, 10), dpi=120)x = df[&#x27;年龄&#x27;]y = df[&#x27;已还清&#x27;]plt.bar(x, y)plt.show() 自定义属性可以通过传递不同的参数来自定义柱状图的外观。 修改颜色：通过color参数设置柱子的颜色。 1plt.bar(x, y, color=&#x27;green&#x27;) 修改柱宽：使用width参数调整柱的宽度。 1plt.bar(x, y, width=0.5) 水平柱状图：plt.barh()用于绘制水平柱状图。 1plt.barh(x, y) 堆叠柱状图堆叠柱状图适用于展示不同组数据在相同类别中的分布情况。 12345678x = df[&#x27;年龄&#x27;]y1 = df[&#x27;已还清&#x27;]y2 = df[&#x27;正常还款中&#x27;]plt.bar(x, y1)plt.bar(x, y2, bottom=y1)plt.legend([&#x27;已还清&#x27;, &#x27;正常还款中&#x27;])plt.show() 显示数值在柱状图的柱子上显示数值，可以更直观地展示数据的具体数值。 单独柱子显示数值： 1plt.bar_label(plt.bar(x, y1), labels=x, label_type=&#x27;edge&#x27;) 堆叠柱状图显示数值： 123456bar1 = plt.bar(x, y1)plt.bar_label(bar1, labels=y1, label_type=&#x27;edge&#x27;)bar2 = plt.bar(x, y2, bottom=y1)plt.bar_label(bar2, labels=y2, label_type=&#x27;edge&#x27;)plt.legend([&#x27;已还清&#x27;, &#x27;正常还款中&#x27;])plt.show() 这里，label_type=&#39;center&#39;将标签放在柱子的中心位置，而label_type=&#39;edge&#39;则将标签放在柱子的边缘位置。这些自定义选项使得柱状图不仅能够提供数据的视觉比较，还能提供精确的数值信息，使得数据的解读更加直观明了。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://www.yiuhangblog.com/tags/Matplotlib/"},{"name":"可视化","slug":"可视化","permalink":"https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"author":"Yiuhang Chan"},{"title":"JavaScript","slug":"20181128JavaScript","date":"2018-11-27T21:25:02.000Z","updated":"2024-03-06T11:32:31.000Z","comments":true,"path":"2018/11/28/20181128JavaScript/","permalink":"https://www.yiuhangblog.com/2018/11/28/20181128JavaScript/","excerpt":"JavaScript基本介绍","text":"JavaScript介绍JavaScript是一种高级的、解释型的编程语言，它在Web开发中扮演着至关重要的角色。与HTML和CSS共同，JavaScript构成了Web世界的三大核心技术。HTML负责结构的定义，CSS负责表现的样式，而JavaScript则添加了交互性，使得网页变得“活”起来。 JavaScript的特点 动态性：JavaScript允许动态修改HTML和CSS，实现网页内容的动态更新，无需重新加载页面。 易于学习：相对于其他编程语言，JavaScript的入门门槛较低，但它也支持复杂的功能，适用于从初学者到专业开发者。 跨平台：JavaScript可以在几乎所有的现代浏览器上运行，无需特定平台的依赖。 事件驱动：JavaScript能够响应用户操作，如点击、滑动、按键等事件，实现丰富的交互效果。 支持多种编程范式：包括命令式、函数式和面向对象编程。 JavaScript与HTML和CSS的关系 HTML：定义了网页的结构和内容。它是网页的骨架，用于组织和展示静态内容。 CSS：负责网页的布局和视觉效果。通过CSS，开发者可以改变网页的布局、颜色、字体和动画等，使页面美观和用户友好。 JavaScript：添加动态行为到网页上。JavaScript可以读取和修改HTML元素和CSS样式，控制DOM元素，实现页面内容的动态变化。此外，它还可以处理事件和用户交互，进行数据验证，以及与Web服务器进行异步通信（如Ajax）。 JavaScript在Web开发中的应用 页面动态效果：如轮播图、下拉菜单、模态框等。 表单验证：检查用户输入的有效性，如电子邮件格式、密码强度等。 异步加载内容：通过Ajax从服务器获取数据，无需刷新页面即可更新网页内容。 Web应用程序：开发单页应用（SPA），如React、Angular和Vue等前端框架所展现的富客户端应用。 服务器端开发：通过Node.js，JavaScript也可以用于服务器端编程。 JavaScript的普及和发展，推动了Web技术的快速进步，使得现代网页不仅仅是静态的信息展示，而是提供了丰富的交互和动态内容，极大地丰富了用户的网上冲浪体验。随着时间的发展，JavaScript的生态系统不断壮大，它的重要性和影响力在当今的Web开发领域中仍在不断增长。 JavaScript的使用方法主要可以分为两类：内联JavaScript代码和外部JavaScript文件。了解这两种方法的使用场景和优缺点，能帮助开发者更高效地编写和管理JavaScript代码。 JavaScript使用方法1. 内联JavaScript代码将JavaScript代码直接写在HTML文档中，通常是放在&lt;script&gt;标签内。这种方法适合少量的JavaScript代码，可以快速实现简单的逻辑和交互。 示例：在&lt;body&gt;标签的底部添加&lt;script&gt;标签： 12345678&lt;body&gt; &lt;!-- 网页内容 --&gt; &lt;script&gt; // 在这里写JavaScript逻辑代码 console.log(&#x27;Hello, JavaScript!&#x27;); &lt;/script&gt;&lt;/body&gt; 优点： 简单，易于实现小规模的交互效果。 不需要额外的文件请求，减少加载时间（对于非常小的脚本）。 缺点： 随着代码量增加，HTML文件会变得臃肿，难以维护。 多个页面如果需要相同的JavaScript逻辑，需要在每个页面中重复相同的代码，增加了维护成本。 2. 外部JavaScript文件将JavaScript代码写在一个单独的.js文件中，然后通过在HTML文档的&lt;head&gt;或&lt;body&gt;部分引入这个文件。 示例：在&lt;head&gt;或&lt;body&gt;的底部引入外部JavaScript文件： 1234&lt;head&gt; &lt;!-- 其他标签 --&gt; &lt;script src=&quot;path/to/your-script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 或者，为了页面加载性能优化，推荐在&lt;body&gt;标签的底部引入： 12345&lt;body&gt; &lt;!-- 网页内容 --&gt; &lt;script src=&quot;path/to/your-script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 优点： 代码更加组织化，易于维护。 可以在多个页面共享同一个.js文件，减少代码冗余。 浏览器可以缓存外部JavaScript文件，提高页面加载速度。 缺点： 页面必须等待外部JavaScript文件加载完成，可能会影响页面渲染速度（尤其是在网络条件不佳时）。 最佳实践 对于小的项目或简单的脚本，可以使用内联JavaScript代码。 对于大型项目，推荐使用外部JavaScript文件，并在HTML文档的&lt;body&gt;标签底部引入，以提高页面加载速度和代码的可维护性。 使用现代Web开发工具和技术（如模块化JavaScript、Webpack等），可以进一步优化代码组织和性能。 JavaScript输出JavaScript提供了多种输出数据的方式，其中最常用的是console.log和alert函数。这些方法在调试代码、向用户显示信息或简单的数据交互中非常有用。了解它们的使用场景和特点，可以帮助你更有效地在JavaScript开发中进行信息输出和调试。 1. console.log：在控制台输出console.log是开发者在日常开发过程中最频繁使用的JavaScript输出方法之一。它将信息输出到浏览器的控制台中，这对于调试代码和查看变量的当前状态非常有帮助。 示例代码：12345&lt;body&gt;&lt;script&gt; console.log(&#x27;Hello JavaScript!&#x27;);&lt;/script&gt;&lt;/body&gt; 注意： 输出的内容只能在浏览器的开发者工具中的控制台(Console)看到。 console.log不会对用户界面产生任何影响，因此它主要用于开发调试。 2. alert：在网页中弹出对话框alert函数会在网页上显示一个警告对话框，显示指定的文本内容，并在用户点击”确定”按钮之前阻止任何其他操作。 示例代码：12345&lt;body&gt;&lt;script&gt; alert(&#x27;Hello JavaScript!&#x27;);&lt;/script&gt;&lt;/body&gt; 注意： 对话框会立即在加载包含alert函数的网页时弹出。 alert对话框是模态的，这意味着它会暂停代码的执行，并阻止用户与网页上的其他元素交互，直到对话框被关闭。 使用alert过于频繁可能会影响用户体验，因为它强制用户进行交互才能继续浏览网页。 使用场景 **console.log**：主要用于开发过程中的调试。它允许开发者在开发者工具的控制台中查看变量值、调试信息或任何其他输出，而不会影响用户的正常使用。 **alert**：可用于向用户显示重要消息，如表单验证反馈、操作确认等。但应谨慎使用，以避免打扰用户体验。 JavaScript注释在JavaScript中，注释是对代码的解释和说明，它们能帮助开发者理解代码的功能和目的。注释对于代码的执行没有任何影响，因此可以自由地添加解释性的文字来帮助你和其他开发者更好地理解和维护代码。JavaScript支持两种类型的注释：单行注释和多行注释。 单行注释单行注释以双斜杠//开头，仅对其后的内容进行注释，直到行末。单行注释通常用于对代码行的简短说明或临时禁用某行代码。 示例代码：123456&lt;body&gt;&lt;script&gt; // 这是一个单行注释 alert(&#x27;Hello JavaScript!&#x27;);&lt;/script&gt;&lt;/body&gt; 多行注释多行注释以/*开始，以*/结束。它可以跨越多行，用于注释掉多行代码或提供更详细的说明。 示例代码：12345678&lt;body&gt;&lt;script&gt; /* 这是一个多行注释 可以跨越多行 很适合写更多的注释内容 */ alert(&#x27;Hello JavaScript!&#x27;);&lt;/script&gt;&lt;/body&gt; 快捷键在许多开发环境和代码编辑器中，可以使用快捷键Ctrl+/（在Mac上通常是Cmd+/）来快速添加或移除单行注释。这个快捷键可以提高编写和管理注释的效率。 注释的作用 解释性说明：注释可以解释代码的功能和目的，使代码更易于理解。 代码调试：在调试过程中，你可以通过注释掉一部分代码来帮助定位问题。 文档记录：在复杂的项目中，注释可以作为代码的文档记录，说明特定功能的开发者、开发日期和修改历史等。 注意事项 使用注释时应保持适度，避免过多或过少。过多的注释可能会让代码变得难以阅读，而过少的注释则可能导致代码的意图和逻辑不够清晰。 对于自解释性强的代码，简洁明了的注释或者不注释可能是更好的选择。 保持注释的更新。随着代码的修改和迭代，应该相应地更新注释内容，避免出现注释与代码不一致的情况。 注释是代码的重要组成部分，恰当地使用注释能够大大提高代码的可读性和可维护性。 变量在JavaScript中，变量是用来存储数据值的容器。通过使用变量，你可以在代码中引用和操作这些值。JavaScript提供了几种不同的方式来声明变量，包括var、let和const。这里我们将重点讨论let和const，因为它们提供了比var更强大的功能和更好的作用域控制。 变量声明使用let关键字来声明一个变量。这告诉JavaScript你正在创建一个新的变量。 示例代码：1let 小皮; 变量赋值一旦声明了变量，你就可以给它赋值了。赋值是通过等号=完成的，等号左边是变量名，右边是要赋给变量的值。 示例代码：1小皮 = &#x27;我家的一条狗&#x27;; 变量声明并赋值你也可以在声明变量的同时给它赋值。这是最常见的做法，因为它可以减少代码量并提高效率。 示例代码：123456&lt;body&gt;&lt;script&gt; let 小皮 = &#x27;我家的一条狗&#x27;; console.log(小皮); // 在控制台输出变量的值&lt;/script&gt;&lt;/body&gt; let vs const **let**：用于声明一个可以重新赋值的变量。如果你的变量值在后面的代码中需要改变，应该使用let。 **const**：用于声明一个常量，即一旦赋值后就不能再改变的变量。如果你知道变量的值在整个程序中都不会改变，使用const更合适。 注意事项 尽量使用const来声明变量，除非你知道变量的值会改变，这样可以帮助避免程序中的错误。 避免使用var进行变量声明，因为它的作用域规则（函数作用域）与let和const的块级作用域相比，更容易导致错误。 变量命名应遵循JavaScript的命名规则，尽量使用描述性的名称，避免使用保留字。 JavaScript是大小写敏感的，因此小皮和小皮是两个不同的变量。 数据类型JavaScript是一种动态类型语言，意味着变量不直接指定数据类型。变量的数据类型会在脚本运行时动态决定。JavaScript有五种基本数据类型（也称为原始类型）：字符串（String）、数值（Number）、布尔（Boolean）、未定义（Undefined）、空（Null）；以及一种复杂数据类型：对象（Object）。此外，ES6引入了Symbol作为新的原始数据类型。 字符串型 (String)字符串用于表示文本数据。它是字符的序列，可以使用单引号&#39;、双引号&quot;或者ES6中的模板字符串&#96;&#96;&#96;（反引号）。 12let a = &#x27;我是一个字符串a&#x27;;let c = &quot;我是一个字符串b&quot;; 数值型 (Number)Number类型用于表示整数或浮点数（小数）。JavaScript不区分整数类型和浮点数类型，所有的数字在JavaScript中都是Number类型。 12let a = 10; // 整数let c = 10.25; // 浮点数 布尔型 (Boolean)布尔类型只有两个值：true（真）和false（假），用于执行逻辑操作。 12let a = true; // 真let c = false; // 假 未定义 (Undefined)当一个变量被声明了但没有被赋值时，它的值就是undefined。 12let a;console.log(a); // 输出：undefined 空 (Null)null用于表示一个明确的空值。通常用于初始化一个变量，可能稍后会被赋予一个对象值。 12let a = null;let b = null; 运算符typeof运算符typeof运算符用于检查一个变量的数据类型。它是确定基本数据类型的一个有效工具，但对于null值会返回&quot;object&quot;，这是一个历史遗留问题。 1234567891011let a = &#x27;我是字符串类型&#x27;;let b = 10;let c = undefined;let d = null;let e = true;console.log(typeof a); // stringconsole.log(typeof b); // numberconsole.log(typeof c); // undefinedconsole.log(typeof d); // object, 特殊情况console.log(typeof e); // boolean 算术运算符算术运算符用于基本的数学运算。它们可以应用于字面量数值、变量中的数值，以及任何返回数值的表达式。 **加法 (+)**：计算两个操作数的和。 **减法 (-)**：从第一个操作数中减去第二个操作数。 *乘法 ()**：计算两个操作数的乘积。 **除法 (&#x2F;)**：将第一个操作数除以第二个操作数。 示例：123456let a = 30;let b = 20;console.log(a + b); // 结果: 50console.log(a - b); // 结果: 10console.log(a * b); // 结果: 600console.log(a / b); // 结果: 1.5 赋值运算符赋值运算符用于将值赋给JavaScript变量。 **= (赋值)**：将右侧的值赋给左侧的变量。 **+= (加后赋值)**：将右侧的值加上左侧的变量的当前值，然后将结果赋给左侧的变量。 **-= (减后赋值)**：从左侧变量的当前值中减去右侧的值，然后将结果赋给左侧的变量。 示例：12345let a = 30;let b = 20;console.log(a = 100); // 结果: 100console.log(a += b); // a = a + b 结果：120console.log(a -= b); // a = a - b 结果: 100 比较运算符比较运算符用于比较两个值，根据比较结果返回布尔值（true或false）。 **== (等于)**：检查两个操作数的值是否相等，如果相等返回true。 **!= (不等于)**：检查两个操作数的值是否不相等，如果不相等返回true。 **=== (全等于)**：检查两个操作数的值和类型是否完全相同，如果完全相同返回true。 **!== (全不等于)**：检查两个操作数的值和类型是否完全不相同，如果完全不相同返回true。 示例：123456let a = 30;let b = &#x27;30&#x27;;console.log(a == b); // 结果: true (因为值相等)console.log(a != b); // 结果: false (因为值相等)console.log(a === b); // 结果: false (因为值相等但类型不同)console.log(a !== b); // 结果: true (因为值相等但类型不同)","categories":[{"name":"前端","slug":"前端","permalink":"https://www.yiuhangblog.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yiuhangblog.com/tags/JavaScript/"}],"author":"Yiuhang Chan"},{"title":"CSS","slug":"20181124CSS","date":"2018-11-24T09:16:34.000Z","updated":"2024-03-06T11:13:08.000Z","comments":true,"path":"2018/11/24/20181124CSS/","permalink":"https://www.yiuhangblog.com/2018/11/24/20181124CSS/","excerpt":"CSS基本介绍","text":"什么是CSSCSS代表“层叠样式表”（Cascading Style Sheets）。它是一种用于控制网页布局和设计的技术，允许网页开发者和设计师为HTML（超文本标记语言）元素指定字体、颜色、间距、布局以及各种视觉效果。CSS可以提高网页的表现力，使其更加丰富和吸引人，同时也可以使内容与表现分离，从而简化网页的维护和更新。 通过使用CSS，开发者可以为不同的设备（如桌面显示器、手机、打印机等）创建特定的样式，以确保网页在各种浏览环境中都能以最佳方式呈现。CSS的“层叠”特性允许多个样式表按照一定的优先级顺序应用于同一个HTML文档，这意味着可以根据需要轻松地覆盖和修改样式。 CSS的使用不仅提升了网页的美观性和可用性，还有助于提高网页的加载速度和搜索引擎优化（SEO）。因为它允许开发者将结构（HTML）与设计（CSS）分离，从而使HTML代码更加简洁和清晰，更易于搜索引擎理解。随着Web技术的发展，CSS也在不断进化，CSS3是最新的版本，引入了更多的布局选项、动画和其他视觉效果。 为什么使用CSS使用CSS（层叠样式表）的原因非常多样，它改变了网页开发和设计的方式。以下是使用CSS的一些主要原因： 分离内容与样式：CSS允许开发者将网页的设计样式与内容分离。这意味着可以独立修改HTML文档的结构和CSS样式表的设计，而无需重写整个页面，从而提高了网站的维护效率和灵活性。 节省时间和资源：通过使用CSS，可以在多个网页中重复使用同一样式表。当需要更改网站的设计时，只需修改一个CSS文件，网站上的所有页面都会自动更新，这大大节省了时间和资源。 提高页面加载速度：将样式信息保存在外部样式表中可以减少每个页面的HTML代码量。因为样式表只需要在首次访问网站时加载一次，然后就可以被缓存起来用于后续页面，这样可以减少数据传输量，加快页面加载速度。 增强网页的可访问性：CSS提供了更多的布局和设计选项，可以创建更易于阅读和导航的网页布局。这对于包括视觉障碍人士在内的所有用户都非常重要。 提升网站的兼容性：通过使用CSS，可以针对不同的浏览器、设备和屏幕尺寸创建特定的样式。这意味着无论用户使用什么设备访问网站，都可以提供最佳的浏览体验。 支持高级用户界面和动画：CSS3引入了许多新特性，如动画、过渡、形状、渐变等，这些都可以用来创建吸引人的视觉效果和动态用户界面，而无需依赖于重量级的JavaScript或Flash插件。 提高搜索引擎优化（SEO）：通过使用CSS，可以创建更加语义化的HTML结构，这有助于搜索引擎更好地理解页面内容的结构和重要性，从而提高网站在搜索结果中的排名。 作用CSS（层叠样式表）的作用在网页开发和设计中至关重要，它具有以下主要功能和作用： 样式控制：CSS允许开发者精确控制网页中文本、图像和元素的样式。这包括字体样式、颜色、大小、行间距、文本对齐、链接表现等。 布局设计：CSS使得布局设计成为可能，不再依赖于HTML表格或其他传统方法。使用CSS，可以实现多栏布局、网格布局和弹性布局等复杂设计，以适应不同的屏幕大小和设备。 响应式网页设计：通过使用媒体查询（Media Queries），CSS可以根据不同的屏幕尺寸和设备特性来应用不同的样式规则。这使得创建响应式网站成为可能，确保网站在各种设备上都能提供良好的用户体验。 视觉效果：CSS提供了一系列视觉效果的实现方法，如阴影、圆角、透明度、过渡和动画效果，使得网页具有更加吸引人的视觉表现。 页面性能优化：使用外部样式表可以减少页面的代码冗余，因为样式信息可以被缓存并在多个页面之间共享。这可以减少页面加载时间，提升用户体验。 提升网站的可访问性：CSS允许开发者为不同的浏览设备（包括屏幕阅读器）提供更加适合的样式，提高网站的可访问性。 提高网站的可维护性：通过将样式信息从HTML中分离出来，CSS简化了网站的维护。当需要改变网站的视觉风格时，只需修改样式表，而不必触及HTML代码。 增强网站的互动性和动态效果：CSS3引入的动画和过渡效果使得无需使用JavaScript或Flash等技术，就能在用户与网页交互时产生动态效果，增强用户体验。 CSS通过提供这些功能和作用，使得网页开发者和设计师能够创建出既美观又功能强大的网站，同时确保内容的可访问性、网站的响应性以及维护的便捷性。 应用方式CSS（Cascading Style Sheets）的应用方式主要分为三种：内部样式、行内样式和外部样式。每种方式有其适用场景和优先级，根据具体需求选择合适的引用方式是开发高质量网页的关键。下面是对这三种方式的详细说明和示例： 1. 内部样式（内联样式表）内部样式通过在HTML文档的&lt;head&gt;部分放置&lt;style&gt;标签并在其中编写CSS代码来实现。这种方式适用于单个页面的样式定义，当样式仅在当前页面中有效时非常有用。 123456789101112&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 在这里写CSS代码 */ body &#123; background-color: #f0f0f0; &#125; &lt;/style&gt;&lt;/head&gt; 2. 行内样式行内样式是通过在HTML元素的style属性中直接写入CSS代码来定义样式的方法。这种方式适用于对单个元素进行快速样式调整，但不推荐用于大规模样式定义，因为这样做会增加HTML代码的复杂性和维护难度。 1&lt;div style=&quot;color: red; font-size: 14px;&quot;&gt;这是行内样式的示例文本。&lt;/div&gt; 3. 外部样式（外联样式表）外部样式通过创建一个单独的CSS文件（例如styles.css），然后在HTML文档的&lt;head&gt;部分使用&lt;link&gt;标签引入这个CSS文件来实现。这是最推荐的方法，因为它有利于样式的复用和维护，同时也减少了页面的加载时间。 1234567&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;&lt;/head&gt; CSS应用方式的优先级当多种样式同时作用于同一个HTML元素时，CSS的应用方式决定了它们的优先级：行内样式 &gt; 内部样式 &gt; 外部样式。此外，样式表的优先级还受到CSS选择器权重、继承和!important声明的影响。在实际开发中，了解并正确应用这些原则是非常重要的，它们帮助开发者高效地管理和维护网页的样式。 选择器CSS选择器是CSS中的一种模式，用于选择需要应用样式的元素。它们是CSS规则的关键组成部分，使开发者能够精确地定位到HTML文档中的元素。以下是关于常用CSS选择器的详细说明： 1. 标签选择器（元素选择器）标签选择器，也称为元素选择器，使用HTML标签的名称作为选择器。它将样式应用于所有具有该标签名称的元素。这种选择器非常适合应用全局样式。 示例1234567891011&lt;style&gt; /* 所有的div元素都将应用以下样式 */ div &#123; color: blue; font-size: 16px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;我是div标签&lt;/div&gt;&lt;/body&gt; 2. 类选择器类选择器使用点（.）作为前缀，后面跟上自定义的类名。通过HTML元素的class属性来应用对应的样式。类选择器非常灵活，因为同一个类可以应用于多个元素，同时一个元素也可以有多个类。 示例12345678910111213&lt;style&gt; /* 所有class为&quot;name&quot;的元素都将应用以下样式 */ .name &#123; color: red; font-weight: bold; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;name&quot;&gt;我是div标签&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;我是div标签&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;我是div标签&lt;/div&gt;&lt;/body&gt; 3. ID选择器ID选择器使用井号（#）作为前缀，后面跟上自定义的ID名称。通过HTML元素的id属性来应用对应的样式。ID选择器是唯一的，一个页面中的一个ID只能用于一个元素。 示例1234567891011&lt;style&gt; /* ID为&quot;name&quot;的元素将应用以下样式 */ #name &#123; color: green; font-size: 20px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;name&quot;&gt;我是div标签&lt;/div&gt;&lt;/body&gt; 使用建议和注意事项 标签选择器适用于定义全局样式和元素的默认样式。 类选择器非常灵活，适用于组件和重复元素的样式设计，支持复用。 ID选择器用于特定元素的唯一样式，但应谨慎使用，因为ID具有高优先级，可能导致样式覆盖问题。 在实际开发中，合理地组合使用这些选择器，可以创建出既美观又具有良好结构的网页。了解每种选择器的特点和使用场景，可以帮助开发者更高效地编写CSS代码，实现精确的样式控制。 CSS（Cascading Style Sheets）提供了丰富的属性用于控制网页上的元素样式。在这里，我们将聚焦于字体属性，它们是调整文本外观的重要工具，包括font-size、font-weight和font-family。通过合理应用这些属性，可以大幅提升网页内容的可读性和美观性。 属性字体属性1. font-sizefont-size属性用于设置字体的大小，可以使用不同的单位，如像素(px)、em、rem等。 示例代码：123p &#123; font-size: 16px; /* 设置字体大小为16像素 */&#125; 2. font-weightfont-weight属性用于设置字体的粗细。它可以取多个值，如normal、bold、或具体的数值（400对应normal，700对应bold）。 示例代码：123strong &#123; font-weight: bold; /* 设置字体为粗体 */&#125; 3. font-familyfont-family属性用于设置元素的字体。可以指定一个字体列表，浏览器将按列表顺序尝试使用，直到找到可用的字体。 示例代码：123body &#123; font-family: &quot;Arial&quot;, &quot;Helvetica&quot;, sans-serif; /* 如果Arial不可用，则尝试Helvetica，依此类推 */&#125; 完整示例 在下面的示例中，我们将展示如何在HTML文档的&lt;head&gt;部分使用内部样式来定义ID选择器#name的字体样式。 12345678910111213141516&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #name &#123; font-size: 20px; /* 设置字体大小为20像素 */ font-weight: 400; /* 设置字体粗细为400，即正常粗细 */ font-family: &#x27;仿宋&#x27;, &#x27;宋体&#x27;, serif; /* 设置字体为仿宋，如果不可用，则尝试宋体 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;name&quot;&gt;我是div标签&lt;/div&gt;&lt;/body&gt; 通过这个示例，我们可以看到如何利用CSS字体属性来改善网页上文本的表现。记住，在实际开发中选择字体时要考虑到字体的可用性和版权问题，特别是在使用非标准或商业字体时。正确使用字体属性不仅能够提升网页的视觉效果，还能改善用户的阅读体验。 文本属性在CSS中，处理文本的外观和布局是常见的需求。line-height和text-align是两个重要的文本属性，它们分别控制文本的行高和水平对齐方式。理解并正确应用这些属性对于改善网页的可读性和美观性至关重要。 1. line-height（行高） 含义：line-height属性用于设置行间的距离，即一行文本的底部到下一行文本顶部的距离。它决定了文本的垂直间距，对提高文本的可读性非常重要。 单位：可以使用不同的单位来设置line-height，包括像素(px)、百分比(%)、em、或没有单位的数值（相对于当前字体大小的倍数）。使用没有单位的数值可以保持字体大小与行高之间的相对关系，即使字体大小发生变化。 示例代码：123p &#123; line-height: 1.5; /* 设置行高为字体大小的1.5倍 */&#125; 2. text-align（水平对齐） 含义：text-align属性用于设置文本的水平对齐方式。它可以控制文本在其包含块内的对齐方式。 取值： left：文本左对齐。 center：文本居中对齐。 right：文本右对齐。 justify：文本两端对齐，自动调整单词间的间距来实现这一效果。 示例代码：123p &#123; text-align: center; /* 文本居中对齐 */&#125; 应用示例结合line-height和text-align，可以控制文本的垂直间距和水平对齐方式，从而创建出既舒适又美观的文本布局。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;style&gt; body &#123; font-family: Arial, sans-serif; &#125; p &#123; line-height: 1.6; /* 提高行间距，增强可读性 */ text-align: justify; /* 文本两端对齐，提升文档的正式性 */ margin: 20px; /* 增加段落周围的空间 */ &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. Cras elementum ultrices diam. Maecenas ligula massa, varius a, semper congue, euismod non, mi. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 通过合理设置这些文本属性，可以大大提升网页内容的阅读体验。 颜色 color: 用于设置文本的颜色。可以使用颜色名（如red）、十六进制值（如#FF0000）、RGB（如rgb(255, 0, 0)）、RGBA（如rgba(255, 0, 0, 0.5)）、HSL（如hsl(0, 100%, 50%)）等方式指定颜色。 background-color: 用于设置元素的背景颜色。颜色的指定方式同color属性。 示例代码1234div &#123; color: #f7f2f2; /* 设置文本颜色 */ background-color: red; /* 设置背景颜色 */&#125; 盒子模型在CSS中，每个元素都被视为一个盒子，这些盒子共同构成了网页的布局。盒子模型包括几个关键的组成部分：内容（Content）、内边距（Padding）、边框（Border）、外边距（Margin），以及可选的背景信息。 属性 width 和 height: 分别设置盒子的宽度和高度。默认情况下，这些尺寸仅包括内容区域，不包含内边距、边框或外边距。 border: 设置元素的边框样式、宽度和颜色。 padding: 设置元素内容与边框之间的空间，即内边距。 margin: 设置元素与其他元素之间的空间，即外边距。 border-radius: 设置边框角的圆滑度。当设置为50%时，如果盒子的宽度和高度相等，盒子将呈现为圆形。 示例代码12345678div &#123; width: 100px; height: 100px; border: 1px solid #000; /* 边框为1px黑色实线 */ padding: 10px; /* 内边距 */ margin: 10px; /* 外边距 */ border-radius: 10px; /* 边框圆角 */&#125; 清除默认的内外边距网页元素默认带有内外边距，这有时会影响布局效果。使用CSS可以全局重置这些默认值，以确保页面在不同浏览器中具有一致的外观。 示例代码12345* &#123; margin: 0; /* 清除外边距 */ padding: 0; /* 清除内边距 */ box-sizing: border-box; /* 当设置width和height时，元素的边框和内边距的空间也包含在内 */&#125; 信息 行内块（Inline-Block）与行内（Inline）元素 div（行内块元素的使用场景）：默认情况下，div是一个块级元素，用于布局和容纳其他元素。通过将div的display属性设置为inline-block，可以使其同时拥有行内元素和块级元素的特性。这意味着它可以像行内元素一样在文本流中不换行显示，同时又可以设置宽度和高度。 span（行内元素）：span是一个典型的行内元素，主要用于对文本的小块进行样式设置。默认情况下，行内元素不能设置宽度和高度，因为它们的尺寸由内容决定。但是，通过将span或其他行内元素的display属性改为inline-block，可以使其支持宽度和高度的设置。 盒子居中 使用margin: 0 auto;是一个常用的技巧，用于将块级元素在其父容器中水平居中。为了使这个技巧有效，元素必须有一个指定的宽度。 示例代码： 1234.centered-div &#123; width: 50%; /* 指定宽度 */ margin: 0 auto; /* 上下边距为0，左右自动调整以居中 */&#125; 清除浏览器的默认内外边距 浏览器为许多HTML元素提供了默认的内外边距，这可能会影响到布局。使用通配符（*）选择器设置所有元素的margin和padding为0是一个常见的做法，用来重置这些默认样式，以保证跨浏览器的一致性。 示例代码： 12345* &#123; margin: 0; padding: 0; box-sizing: border-box; /* 添加box-sizing以包含边框和内边距在元素的宽度和高度内 */&#125; 注意，代码中的box-sizing: border-box;是一个有用的补充，它更改了盒子模型的工作方式，使元素的宽度和高度包含其边框和内边距，这样做可以简化布局的计算。 CSS中的:hover伪类选择器用于定义当鼠标悬停在元素上时的样式。这是一种常用的技术，用于增强网页的交互性和视觉反馈。通过使用:hover，你可以指定元素在用户鼠标悬停时的不同样式，例如改变背景颜色、文字颜色、边框等。这里，我们将详细说明如何使用:hover来创建移入效果，并给出一个具体的示例。 移入效果使用:hover创建移入效果:hover伪类可以应用于任何元素，不仅限于链接。当元素处于悬停状态（即鼠标指针悬浮在元素上方）时，:hover伪类就会被激活，元素的样式将根据:hover后定义的规则改变。 示例：改变背景色和文字颜色假设有一个类名为.box2的元素，你想要在鼠标悬停时改变其背景色和文字颜色，可以这样编写CSS： 1234.box2:hover &#123; background-color: rgb(85, 219, 61); /* 鼠标悬停时的背景颜色 */ color: #fff; /* 鼠标悬停时的文字颜色 */&#125; HTML结构1&lt;div class=&quot;box2&quot;&gt;1&lt;/div&gt; 在这个示例中，.box2是一个div元素的类名。当用户将鼠标指针移动到这个div上时，它的背景色将变为绿色（RGB(85, 219, 61)），文字颜色变为白色（#fff）。 注意事项 使用:hover时，确保选择的颜色或样式变化在视觉上有明显区别，以便用户可以清楚地看到效果变化。 虽然:hover主要用于鼠标悬停效果，但在触摸设备上，这种效果可能会有所不同。在设计时应考虑到这一点，确保网站或应用在不同设备上的可用性。 通过合理使用:hover伪类，可以在不增加JavaScript代码的情况下，仅通过CSS就能创建出丰富的交互效果，提升用户体验。 在CSS中，定位（Positioning）是一种强大的布局工具，允许你控制元素的位置。通过使用position属性，你可以定义元素是如何在页面上定位的。这里我们将探讨position属性的几种不同类型：relative、absolute、和fixed，以及如何使用它们。 定位 Position1. 相对定位（Relative Positioning）当元素设置为相对定位（position: relative;）时，它将相对于其原始（正常流）位置进行定位。你可以使用top、right、bottom和left属性来指定元素应该移动的距离。 示例：123456.box &#123; width: 200px; height: 200px; background-color: red; position: relative;&#125; 2. 绝对定位（Absolute Positioning）绝对定位的元素（position: absolute;）是相对于最近的已定位的祖先元素进行定位的。如果没有已定位的祖先元素，那么它将相对于文档的&lt;html&gt;元素进行定位。绝对定位使元素脱离正常文档流。 示例：123456789101112.box &#123; position: relative; /* 父元素设置为相对定位 */&#125;.box1 &#123; width: 80px; height: 80px; background-color: blue; position: absolute; bottom: 10px; /* 距离父元素底部10px */ left: 20px; /* 距离父元素左边20px */&#125; 3. 固定定位（Fixed Positioning）固定定位（position: fixed;）的元素是相对于浏览器窗口进行定位的，即使页面滚动，元素也会保持在指定的位置。这通常用于创建始终可见的导航栏。 示例：12345678.box &#123; height: 100px; width: 100%; position: fixed; top: 0; /* 距离浏览器窗口顶部是0px */ left: 0; /* 距离浏览器窗口左边是0px */ background-color: red;&#125; 注意事项： 脱离文档流：使用absolute和fixed定位的元素会从正常的文档流中脱离出来，这意味着它们不会影响其他元素的布局。 块级和行内元素：定位属性可应用于块级和行内元素。 祖先元素的影响：对于绝对定位，元素的位置是相对于最近的已定位祖先元素确定的。如果没有这样的祖先，那么它相对于初始包含块定位。 Flex布局Flex布局，也称为弹性布局，自2009年由W3C提出以来，已经成为现代网页设计中不可或缺的布局解决方案。它旨在提供一种更高效、更灵活的方式来设计、布置和分配容器内项目的空间，无论容器的大小如何变化。Flex布局特别适用于响应式设计和复杂组件布局中。现在，Flex布局已获得所有现代浏览器的广泛支持，可以安全地在生产环境中使用。 何为Flex布局Flex布局即“弹性布局”，它允许容器内的子元素能够按照指定的方向排列，并且这些子元素的尺寸可以根据额外空间的多少进行伸缩。使用Flex布局，开发者可以轻松实现各种复杂的布局结构，同时保持代码的简洁性和可维护性。 使用Flex布局要使用Flex布局，首先需要在父容器上设置display: flex;属性。这一步将该容器指定为Flex容器，其直接子元素将成为Flex项目（Flex items），并开始遵循Flex布局的规则。 示例代码：123456789101112131415&lt;style&gt;.box &#123; display: flex;&#125;.box_hz &#123; padding: 20px; border: 1px solid #000;&#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box_hz&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box_hz&quot;&gt;2&lt;/div&gt;&lt;/div&gt; 响应式Flex项目在Flex布局中，可以通过flex属性来控制Flex项目的伸缩性。flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。通过调整这些值，可以控制Flex项目如何增长（占据更多空间）或收缩（占据较少空间），以及它们在默认情况下应该有多大。 设置flex: 1意味着所有子元素将等分容器的空间，如果空间不足，它们也会等比例缩小以适应容器。 增强的示例代码：12345.box_hz &#123; padding: 20px; border: 1px solid #000; flex: 1; /* 使子盒子响应式 */&#125; 通过上述设置，.box_hz中的每个子元素将平等地分配.box容器的空间，从而实现了响应式设计。 总结Flex布局极大地简化了复杂布局的实现过程，使得开发者可以更加专注于内容和功能的实现，而不必担心布局问题。通过使用Flex布局，可以创建出灵活、适应性强且易于维护的网页布局，从而提升用户体验和开发效率。 Flex布局中的容器属性是管理和控制Flex容器内部元素排列的关键。特别是justify-content和align-items属性，它们分别控制容器内项目沿主轴（x轴）和交叉轴（y轴）的对齐方式。下面是这些属性的详细说明及示例，帮助你更好地理解和使用Flex布局。 Flex容器容器的属性1. justify-content：沿主轴（水平方向）的对齐方式 **flex-start**（默认）：项目位于容器的开始位置。 **center**：项目位于容器的中心。 **flex-end**：项目位于容器的末尾。 **space-between**：项目之间的间隔相等，第一个项目在容器的开始位置，最后一个项目在容器的末尾。 **space-around**：项目周围的间隔相等。每个项目两侧的空间相等。 **space-evenly**：项目和容器边缘之间的空间以及项目之间的空间都相等。 2. align-items：沿交叉轴（垂直方向）的对齐方式 **flex-start**：项目位于容器的起始边缘。 **center**：项目位于容器的中心。 **flex-end**：项目位于容器的末端。 **baseline**：项目的基线对齐。 **stretch**（默认）：如果项目未设置高度或设为auto，将占满整个容器的高度。 示例下面的示例展示了一个Flex容器（.box1），它将内部的两个Flex项目（.box2）在水平和垂直方向上居中对齐。 12345678910111213141516171819202122&lt;style&gt;.box1 &#123; width: 100%; height: 100vh; background-color: pink; display: flex; justify-content: center; /* 沿主轴居中对齐 */ align-items: center; /* 沿交叉轴居中对齐 */&#125;.box2 &#123; height: 30px; width: 50px; border: 1px solid #000; margin: 10px; /* 为了更清楚地展示两个项目，添加了margin */&#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;&lt;/div&gt; 在这个例子中，.box1是一个Flex容器，它通过设置justify-content: center;和align-items: center;属性来确保所有子项目（.box2）在容器中水平和垂直居中对齐。这是创建中心对齐布局的常用方法，特别适合于制作登录页面、居中卡片等布局结构。 理解和掌握justify-content和align-items这两个属性，对于使用Flex布局来说是非常重要的，它们提供了强大的对齐控制能力，使得布局变得既简单又灵活。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.yiuhangblog.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"CSS","slug":"CSS","permalink":"https://www.yiuhangblog.com/tags/CSS/"}],"author":"Yiuhang Chan"},{"title":"HTML","slug":"20181113HTML","date":"2018-11-13T13:09:16.000Z","updated":"2024-03-06T10:33:26.000Z","comments":true,"path":"2018/11/13/20181113HTML/","permalink":"https://www.yiuhangblog.com/2018/11/13/20181113HTML/","excerpt":"HTML基本介绍","text":"什么是HTMLHTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签，通过这些标签可以将网络上的文档格式统一。简单来说，网页就是用HTML语言制作的。HTML是一门描述性语言，是一门非常容易入门的语言。 HTML的作用 内容结构化：HTML通过标签（tags）来组织和格式化网页上的信息，如段落、标题、链接、图片等，使得文本不仅仅是一串字符，而是具有特定结构和意义的内容。 创建超链接：HTML的一个核心功能是能够创建超文本链接，这些链接不仅可以链接到同一个网站内的不同页面，还可以链接到其他网站的页面。这种链接性是互联网互联互通的基础。 嵌入媒体：HTML允许开发者在网页上嵌入图片、音频、视频等多媒体资源，使网页内容更加丰富和动态。 表单功能：HTML提供了创建表单的功能，允许用户输入数据，如用户名、密码、评论等。这些数据可以被网站收集和处理，用于各种互动和功能，比如搜索、用户注册、评论等。 与CSS和JavaScript协作：虽然HTML本身主要负责网页的结构和内容，但它可以与CSS（层叠样式表）和JavaScript协同工作，分别负责网页的样式和行为。通过这种分工合作，开发者可以创建出既美观又功能丰富的网页应用。 网页的组成部分网页的组成部分主要包括以下几个方面： HTML (HyperText Markup Language): HTML 是网页的基础，用于创建和组织网页内容的结构。它包含了一系列的标记（tags）来定义文本、链接、图片、列表、表格等元素。 CSS (Cascading Style Sheets): CSS 用于设置网页的布局和样式。它允许开发者控制文字大小、颜色、间距、布局、背景图像等样式属性，从而使网页更加美观和用户友好。 JavaScript: JavaScript 是一种脚本语言，用于创建动态内容和交互式效果。通过JavaScript，可以实现用户事件处理、动画、数据验证、与服务器的通信等功能。 图片和多媒体内容: 网页中可能包含图片、视频、音频等多媒体内容，用于增强信息传达和用户体验。 字体和图标: 自定义字体和图标可以提高网页的视觉吸引力和品牌识别度。 数据和API (Application Programming Interface): 现代网页可能会与服务器进行数据交换，通过API获取动态数据，实现网页内容的实时更新和用户个性化体验。 Meta标签: Meta标签提供了网页的元数据信息，如网页描述、关键词、作者等，这些信息虽然不直接显示给用户，但对搜索引擎优化（SEO）非常重要。 网页框架和库: 如React, Vue, Angular等，这些现代的JavaScript框架和库提供了构建复杂、高效、响应式网页应用的工具和组件。 每个部分都扮演着重要的角色，共同工作以创建富有功能、用户友好和视觉吸引力的网页。 结构介绍生成结构Visual Studio Code 可以通过shift + ! 然后回车生产html结构 结构详情介绍 html由标签和属性构成。 标签：长在尖角号后面的第一个单词就是标签 属性：长在标签后面的并且用空格隔开的，称作 属性 结构标签介绍 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;!-- html为根标签 --&gt;&lt;html lang=&quot;en&quot;&gt;&lt;!-- head包裹的称为头部区域 --&gt;&lt;head&gt; &lt;!-- 网页采用utf-8的编码格式 --&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 网页标题 --&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- body包裹的称为内容区域 --&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 在HTML（HyperText Markup Language，超文本标记语言）中，&lt;html&gt;, &lt;head&gt;, 和 &lt;body&gt; 标签扮演着构建网页的基础框架的角色。它们每一个都有特定的用途和重要性： &lt;html&gt; 标签 &lt;html&gt; 标签是一个HTML文档的根元素。它包含了整个页面的内容，包括&lt;head&gt;和&lt;body&gt;两个部分。 它告诉浏览器页面的内容是HTML，确保浏览器正确解析页面内容。 通常，一个HTML文档的开始和结束都会被&lt;html&gt;标签包围。 &lt;head&gt; 标签 &lt;head&gt; 标签包含了一系列的元信息（meta-information）关于HTML文档，这些信息不会直接显示在页面上。 它通常包含标题(&lt;title&gt;)、样式表(&lt;link&gt;标签，用于链接CSS文件)、脚本(&lt;script&gt;标签，用于包含JavaScript)、元数据(&lt;meta&gt;标签，用于指定字符集、页面描述、关键词等)等。 &lt;title&gt; 标签定义的文本会显示在浏览器的标题栏或页面的标签上。 &lt;head&gt;标签是必须的，尽管有些情况下浏览器可以推断出它的存在。 &lt;body&gt; 标签 &lt;body&gt; 标签包含了所有可见的页面内容，比如文本、图片、视频、游戏、可播放的音频等。 实际上，用户在浏览器中看到的一切，除了一些由浏览器插件（如工具栏）生成的内容外，都是放在&lt;body&gt;标签内的。 它是HTML文档的主要部分，通常只有一个&lt;body&gt;标签。 简而言之，&lt;html&gt;标签定义了整个HTML文档的范围，&lt;head&gt;标签包含了文档的元信息和引用资源，而&lt;body&gt;标签则包含了实际呈现给用户看到的内容。 网页中常见的标签标题标签HTML中的标题标签用于定义文档的标题和子标题，有六级，从&lt;h1&gt;到&lt;h6&gt;。这些标签不仅用于视觉上区分不同层次的标题和子标题，而且对于搜索引擎优化（SEO）也非常重要，因为搜索引擎利用这些标签来理解页面的结构和内容的重点。 &lt;h1&gt;标签 通常用于页面的主标题。 每个页面上建议只使用一次&lt;h1&gt;标签，以便清楚地传达页面的主要主题。 对于SEO来说，&lt;h1&gt;标签是非常重要的，它告诉搜索引擎哪部分内容是页面上最重要的。 &lt;h2&gt;到&lt;h6&gt;标签 用于定义从次要标题到最不重要的标题。 这些标签帮助创建内容的层次结构，使得信息易于理解和导航。 使用这些标签时，最好按顺序使用，不要跳跃使用（例如，直接从&lt;h1&gt;跳到&lt;h3&gt;，跳过&lt;h2&gt;），以保持内容的结构清晰。 SEO和可访问性 标题标签在帮助搜索引擎理解页面内容方面发挥着关键作用。通过合理使用标题标签，可以提高网站的搜索引擎排名。 对于屏幕阅读器用户，合理的标题层次也非常重要，因为它们依赖于这些标签来导航内容。 示例123456&lt;h1&gt;页面主标题&lt;/h1&gt;&lt;h2&gt;主要部分标题&lt;/h2&gt;&lt;h3&gt;次级部分标题&lt;/h3&gt;&lt;h4&gt;小节标题&lt;/h4&gt;&lt;h5&gt;更细小节标题&lt;/h5&gt;&lt;h6&gt;最小节标题&lt;/h6&gt; 在实际使用中，应该根据内容的重要性和结构来选择合适级别的标题标签，以帮助用户和搜索引擎更好地理解和导航内容。 段落标签在HTML中，段落标签&lt;p&gt;用于定义文本的段落。这是最常用的标签之一，用于组织和展示网页上的文本内容。段落标签帮助创建清晰的文本结构，使得内容易于阅读和理解。 使用&lt;p&gt;标签 当你需要在网页上添加一段文字时，你应该将这段文字放在&lt;p&gt;标签之间。 浏览器会自动在段落的前后添加一些垂直空间（上下边距），以便区分相邻的段落和其他元素。 &lt;p&gt;标签是块级元素，这意味着它通常会显示为新的一行开始，并且占据其父元素的全部宽度。 示例12&lt;p&gt;这是一个段落，它包含了一些文本内容。&lt;/p&gt;&lt;p&gt;这是另一个段落，用于展示如何在HTML中创建多个段落。&lt;/p&gt; 样式和结构 尽管&lt;p&gt;标签主要用于文本内容，但可以通过CSS来改变它的外观，比如修改字体、大小、颜色、行高以及边距等。 使用段落标签而不是通过连续的&lt;br&gt;标签来创建新行是一种更好的实践。这样做不仅符合HTML的语义，而且使得内容的结构更清晰，也便于通过CSS进行全局样式的控制。 为了提高内容的可访问性和SEO效果，建议合理使用段落标签来组织文本，使其结构化和易于理解。 与其他文本元素的关系 &lt;p&gt;标签通常与标题标签（&lt;h1&gt;-&lt;h6&gt;）一起使用，标题标签定义了各个部分的标题，而段落标签则用于包含实际的内容文本。 在段落内部，你还可以使用其他标签，如加强标签&lt;strong&gt;和强调标签&lt;em&gt;，来提高文本的可读性和表达特定的语义。 强调标签在HTML中，用于强调文本的标签主要包括&lt;em&gt;和&lt;strong&gt;，它们各自表达不同程度的强调意义，同时也对搜索引擎优化（SEO）有一定的影响，因为这些标签能帮助搜索引擎理解哪些词语或短语是重要的。 &lt;em&gt;标签 &lt;em&gt;标签用于表示文本的强调，通常表现为斜体。 这种强调是为了改变单词或短语的语气，类似于我们在说话时通过语音的变化来强调某些词。 使用示例： 1&lt;p&gt;我真的&lt;em&gt;非常喜欢&lt;/em&gt;这部电影。&lt;/p&gt; 在这个例子中，”非常喜欢”这个短语会以斜体显示，以突出强调。 &lt;strong&gt;标签 &lt;strong&gt;标签用于表示文本的重要性，通常表现为加粗。 这种标记不仅改变了文本的外观，更重要的是，它传达了内容的重要性，可以用于突出显示关键信息或重点。 使用示例： 1&lt;p&gt;重要：&lt;strong&gt;明天的会议取消了。&lt;/strong&gt;&lt;/p&gt; 在这个例子中，”明天的会议取消了”这个短语会被加粗显示，以强调其重要性。 语义和搜索引擎优化（SEO） &lt;em&gt;和&lt;strong&gt;标签不仅仅是为了改变文本的外观，它们具有语义的意义，表示文本的某部分比周围的文本更加重要或需要强调。 从SEO的角度看，合理使用这些标签可以帮助搜索引擎识别出页面中的关键信息，从而可能影响搜索结果的排名。 注意事项 尽管这些标签在视觉上可能与使用CSS样式（如font-style: italic;或font-weight: bold;）达到的效果相似，但它们的目的是传达语义，而不仅仅是外观。 应当谨慎使用这些标签，以确保不会过度强调文本，从而分散了读者的注意力或降低了页面的可读性。 通过合理利用&lt;em&gt;和&lt;strong&gt;标签，开发者不仅能提高网页内容的表现力，还能增强其语义结构，对提高用户体验和优化搜索引擎排名都有积极作用。 换行标签 br标签 123&lt;body&gt; 窗前明月光&lt;br&gt;疑是地上霜&lt;br&gt;举头望明月&lt;br&gt;低头思故乡&lt;/body&gt; hr标签作用：标签变成分割线 12345&lt;body&gt; 你好呀 &lt;hr&gt; 哈哈&lt;/body&gt; div标签 div标签 是用来布局的，并没有语义，只是一个区块 12345&lt;body&gt; &lt;div&gt; 这是个盒子 &lt;/div&gt;&lt;/html&gt; span标签 没有语义，一般用来包裹文字,让文字更好被选中。 123&lt;body&gt; &lt;span&gt;这是个盒子&lt;/span&gt;&lt;/html&gt; img标签(图片标签) 作用：插入图片 属性 src: 引入图片路径 alt: 对图片的描述 height: 设置图片的高 width: 设置图片的宽度 123456789101112131415// 可以链接引入&lt;img src=&quot;https://image.baidu.com/search/detail?ct=503316480&amp;z=undefined&amp;tn=baiduimagedetail&amp;ipn=d&amp;word=csdn&amp;step_word=&amp;ie=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefined&amp;cs=3710574112,2880096239&amp;os=1416383172,4248936337&amp;simid=3710574112,2880096239&amp;pn=2&amp;rn=1&amp;di=7214885350303334401&amp;ln=1613&amp;fr=&amp;fmq=1684939880586_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face=undefined&amp;is=0,0&amp;istype=0&amp;ist=&amp;jit=&amp;bdtype=0&amp;spn=0&amp;pi=0&amp;gsm=1e&amp;objurl=https%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%253A%252F%252Fdingyue.ws.126.net%252F2021%252F1228%252F42dd5c8ej00r4t6c6000ld200u000iug00u000iu.jpg%26thumbnail%3D660x2147483647%26quality%3D80%26type%3Djpg&amp;rpstart=0&amp;rpnum=0&amp;adpicid=0&amp;nojc=undefined&amp;dyTabStr=MCw2LDEsNCw1LDMsMiw3LDgsOQ%3D%3D&quot; alt=&quot;&quot;&gt;// 也可以本地引入&lt;img src=&quot;./图片.png&quot; alt=&quot;&quot;&gt; a标签 作用:点击跳转到另一个网页 href：指定访问资源的URL target:指定打开资源的方式 _self：默认值，在当前页面打开 _blank：在空白页面打开 1234&lt;body&gt; &lt;a href=&quot;https://baidu.com&quot;&gt;点击当前页面跳转到百度&lt;/a&gt; &lt;a href=&quot;https://baidu.com&quot; target=&quot;_blank&quot;&gt;点击重新打开页面跳转到百度&lt;/a&gt;&lt;/body&gt; 列表标签 有序列表 ol li 12345678&lt;body&gt; &lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt; 无序列表 ul li 12345678&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 表单标签在网页中主要负责数据采集功能表单项(元素)：不同类型的input元素、下拉列表、文本域等 input 标签 type属性： text: 默认值、定义单行输入字段 123&lt;body&gt; &lt;input type=&quot;text&quot;&gt;&lt;/body&gt; password：定义密码字段 123&lt;body&gt; &lt;input type=&quot;password&quot;&gt;&lt;/body&gt; radio：定义单选框 12345678910&lt;!--单选框--&gt;&lt;!--想要多个单选按钮互斥，需要把他们的name设为一样的--&gt;&lt;!--要格外注意加value及对应的值，这样提交以后会把这个值提交进去，从而区分是男是女--&gt;&lt;body&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; id=&quot;male&quot;&gt; &lt;label &gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;2&quot; id=&quot;female&quot;&gt; &lt;label &gt;女&lt;/label&gt;&lt;/body&gt; checkbox：复选框 12345&lt;body&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt;旅游 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt;电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot;&gt;阅读&lt;/body&gt; button: 按钮 123&lt;!--按钮--&gt; &lt;input type=&quot;button&quot; value=&quot;一个普通按钮&quot;&gt; &lt;button&gt;一个普通按钮的第二个写法&lt;/button&gt; file：会将头像文件上传 12&lt;!--上传文件--&gt;&lt;input type=&quot;file&quot;&gt;&lt;br&gt; select :定义下拉列表，option定义列表项 1234567&lt;body&gt; &lt;select&gt; &lt;option value=&quot;1&quot;&gt;红色&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;绿色&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;黄色&lt;/option&gt; &lt;/select&gt;&lt;/body&gt; textarea ：文本域 123&lt;body&gt; &lt;textarea&gt;&lt;/textarea&gt;&lt;/body&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.yiuhangblog.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"HTML","slug":"HTML","permalink":"https://www.yiuhangblog.com/tags/HTML/"}],"author":"Yiuhang Chan"},{"title":"Pandas","slug":"20181112Pandas","date":"2018-11-12T02:23:47.000Z","updated":"2024-03-19T09:53:53.000Z","comments":true,"path":"2018/11/12/20181112Pandas/","permalink":"https://www.yiuhangblog.com/2018/11/12/20181112Pandas/","excerpt":"Python Pandas包","text":"Pandas简介文件的读取与数据创建读取CSV文件12345678910111213141516171819202122232425import pandas as pd# 读取CSV文件（基本）df = pd.read_csv( &quot;./路径/文件.csv&quot;, encoding=&#x27;utf-8&#x27;, # 指定文件编码 index_col=None, # 指定索引列，None表示不将任何列用作索引 sep=&#x27;,&#x27;, # 指定字段分隔符，逗号(,)是默认值 usecols=None, # 指定要读取的列，None表示读取所有列 names=None # 指定列名，None表示使用文件第一行作为列名)# 读取TSV文件（制表符分隔的文件）df_tsv = pd.read_csv( &quot;./路径/文件.tsv&quot;, sep=&#x27;\\t&#x27; # 制表符作为字段分隔符)# 读取文本文件，指定分隔符，列名和没有标题行df_txt = pd.read_csv( &#x27;./路径/文件.txt&#x27;, sep=&#x27;\\t&#x27;, # 制表符作为字段分隔符 header=0, # 指定标题所在行的索引，0表示第一行 names=[&#x27;字段1&#x27;, &#x27;字段2&#x27;] # 指定列名) 存储CSV文件12345678910111213141516# 存储为CSV文件（基本）df.to_csv(&quot;./路径/文件.csv&quot;)# 存储为TSV文件（制表符分隔的文件）df.to_csv( &quot;./路径/文件.tsv&quot;, sep=&#x27;\\t&#x27;, # 指定制表符作为字段分隔符 index=False # 不保存索引列到文件)# 存储为文本文件，使用制表符作为分隔符，不保存索引df.to_csv( &quot;./路径/文件.txt&quot;, sep=&#x27;\\t&#x27;, # 指定制表符作为字段分隔符 index=False # 不保存索引列到文件) 对于处理Excel文件、JSON数据、以及与MySQL数据库交互的操作，我们可以整理和规范化代码示例，以提供清晰的指导。 处理Excel文件读取Excel文件123456789import pandas as pd# 读取Excel文件df = pd.read_excel( &quot;./路径/文件.xlsx&quot;, engine=&quot;openpyxl&quot;, # 指定读取引擎，对于.xlsx文件推荐使用&#x27;openpyxl&#x27; sheet_name=&#x27;Sheet1&#x27;, # 指定工作表名称 header=0 # 指定标题所在行的索引，0表示第一行，None时不将任何行用作列名) 存储为Excel文件123456# 存储DataFrame为Excel文件df.to_excel( &#x27;./路径/文件.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;, # 指定工作表名称 index=False # 不保存索引列到文件) 处理JSON数据读取JSON数据123456# 从文件读取JSON数据df_from_file = pd.read_json(&#x27;./路径/文件.json&#x27;)# 从URL直接读取JSON数据URL = &#x27;https://example.com/data.json&#x27;df_from_url = pd.read_json(URL) 存储为JSON文件12# 存储DataFrame为JSON文件df.to_json(&#x27;./路径/文件.json&#x27;) 与MySQL数据库交互读取MySQL数据库数据123456789101112131415161718import pandas as pdimport mysql.connector# 连接MySQL数据库cnx = mysql.connector.connect( user=&#x27;用户名&#x27;, password=&#x27;密码&#x27;, host=&#x27;主机地址&#x27;, database=&#x27;数据库名&#x27;, charset=&#x27;utf8&#x27;)# 使用SQL查询读取数据query = &quot;SELECT * FROM 表名&quot;df = pd.read_sql(query, cnx)# 关闭数据库连接cnx.close() 存储数据到MySQL数据库123456789101112from sqlalchemy import create_engine# 创建数据库连接引擎engine = create_engine(&#x27;mysql+mysqlconnector://用户名:密码@主机地址/数据库名&#x27;)# 存储DataFrame到MySQL表中df.to_sql( &#x27;tablename&#x27;, # 指定数据库表名 con=engine, # 指定数据库连接 if_exists=&#x27;replace&#x27;, # 如果表存在，替换原数据 index=False # 不将DataFrame的索引列存入数据库) 对于创建Pandas Series的基础知识和示例代码，我们可以进行以下整理以提供清晰、规范的说明和操作步骤。 创建Pandas SeriesSeries的特点 索引(Index): 每个Series对象都有一个索引，用于标识每个数据点。索引的类型可以是整数、字符串、日期等。如果创建Series时未显式指定索引，Pandas会自动生成一个从0开始的整数索引。 数据类型(Datatype): Series可以包含各种类型的数据（整数、浮点数、字符串等）。Pandas允许Series内的数据类型不同，但通常情况下，为了效率，Series中的数据类型会保持一致。 灵活性: Series支持多种操作，包括数学运算、索引&#x2F;选择、数据对齐等。 基础语法创建Series的基础语法如下： 1pandas.Series(data=None, index=None, dtype=None, name=None, copy=False) 参数说明 data: 可以是列表、数组等形式的数据集合。这是Series中存储的主要数据。 index: 与数据同长度的索引标签列表。如果未指定，将自动生成从0开始的整数索引。 dtype: 数据的类型（如int, float, str等）。如果未指定，dtype将自动推断。 name: 为Series指定一个名称，便于理解和输出显示。 copy: 是否复制输入数据，默认为False。设置为True可以避免修改原始数据。 创建Series示例示例1: 使用列表创建Series12345import pandas as pddata = [1, 2, 3]series = pd.Series(data)print(series) 示例2: 使用NumPy数组创建Series123456import pandas as pdimport numpy as npdata = np.array([1, 2, 3])series = pd.Series(data)print(series) 在这两个示例中，我们创建了包含三个整数的Series对象。由于未指定索引，Pandas自动生成了从0开始的整数索引。这些示例展示了如何从基本的数据结构（列表或NumPy数组）创建Series，并展示了Series的基础属性，如自动索引和数据类型推断。 使用Pandas Series时，索引是一个强大的特性，允许快速访问、修改数据。以下是如何使用索引获取数据和指定索引的整理和示例。 使用索引获取数据当创建一个Pandas Series对象时，每个元素都会自动分配一个索引。这个索引可以是默认的整数索引，也可以是自定义的索引。 示例1: 使用默认整数索引获取数据12345678import pandas as pd# 创建Seriesdata = [1, 2, 3]series = pd.Series(data)# 使用索引获取数据print(series[1]) 此代码会输出Series中索引为1的元素，即2。 指定索引可以在创建Series时通过index参数自定义索引。 示例2: 使用自定义索引12345678import pandas as pd# 创建Series，指定索引data = [&quot;Google&quot;, &quot;Runoob&quot;, &quot;Wiki&quot;]series = pd.Series(data, index=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])# 输出整个Seriesprint(series) 输出结果将展示一个Series，其中每个元素都由指定的索引标记： 1234x Googley Runoobz Wikidtype: object 在这个例子中，字符串&quot;Google&quot;, &quot;Runoob&quot;, &quot;Wiki&quot;分别被赋予了自定义索引&quot;x&quot;, &quot;y&quot;, &quot;z&quot;。通过指定索引，可以提高数据检索的可读性和灵活性。 当创建Pandas Series时，指定索引和使用键值对（类似于字典）作为数据源是两种常见的方法。这提供了灵活的数据结构创建和数据访问方式。下面是对这些概念的整理和示例说明。 示例3: 使用自定义索引访问数据12345678import pandas as pd# 创建Series并指定索引data = [&quot;Google&quot;, &quot;Runoob&quot;, &quot;Wiki&quot;]series = pd.Series(data, index=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])# 使用指定的索引访问数据print(series[&quot;y&quot;]) 此代码段会输出索引为&quot;y&quot;的元素，即&quot;Runoob&quot;。 使用字典创建Series当使用字典创建Series时，字典的键自动成为Series的索引，而字典的值成为Series的数据。 示例1: 从字典创建Series12345678import pandas as pd# 使用字典创建Seriessites = &#123;1: &quot;Google&quot;, 2: &quot;Runoob&quot;, 3: &quot;Wiki&quot;&#125;series = pd.Series(sites)# 输出Seriesprint(series) 这段代码创建了一个Series，其中字典的键（1, 2, 3）自动成为了Series的索引。 示例2: 指定索引过滤数据如果在使用字典创建Series时还指定了index参数，那么只有在index参数中指定的键会被包含在Series中。 12345678import pandas as pd# 使用字典创建Series，并指定索引sites = &#123;1: &quot;Google&quot;, 2: &quot;Runoob&quot;, 3: &quot;Wiki&quot;&#125;series = pd.Series(sites, index=[1, 2])# 输出Seriesprint(series) 这段代码将只输出键为1和2的数据项，即&quot;Google&quot;和&quot;Runoob&quot;，因为在创建Series时我们通过index参数指定了只包含这些键。 在处理Pandas Series时，了解如何设置名称、执行基本操作、进行基本运算、以及使用属性和方法是非常重要的。以下是对这些概念的整理和示例说明。 设置Series名称参数可以在创建Series时通过name参数为Series设置一个名称，这有助于标识Series代表的数据集。 123456import pandas as pd# 创建Series并设置名称sites = &#123;1: &quot;Google&quot;, 2: &quot;Runoob&quot;, 3: &quot;Wiki&quot;&#125;myvar = pd.Series(sites, index=[1, 2], name=&quot;RUNOOB-Series-TEST&quot;)print(myvar) 基本操作获取值12345# 使用索引获取单个值value = myvar[2]# 使用切片获取多个值subset = myvar[1:3] # 注意: 切片操作在使用显式索引时是包含结束索引的 遍历Series123# 索引和值的遍历for index, value in myvar.items(): print(f&quot;Index: &#123;index&#125;, Value: &#123;value&#125;&quot;) 基本运算算术运算12# 对Series中的每个元素进行乘法运算result = myvar * 2 过滤12# 使用条件过滤Series中的元素filtered_series = myvar[myvar &gt; 2] 应用数学函数1234import numpy as np# 对Series中的每个元素应用平方根函数result = np.sqrt(myvar) 属性和方法获取索引和值12345# 获取Series的索引index = myvar.index# 获取Series的值values = myvar.values 描述统计1234567# 对DataFrame中的数值列进行描述性统计data = &#123;&#x27;name&#x27;: [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;, &#x27;David&#x27;, &#x27;Emily&#x27;], &#x27;score&#x27;: [90, 85, 75, 80, 95], &#x27;age&#x27;: [20, 25, 30, 35, 40]&#125;df = pd.DataFrame(data)stats = df.describe()print(stats) 获取最大值和最小值的索引123# 获取Series中最大值和最小值的索引max_index = myvar.idxmax()min_index = myvar.idxmin() DataFramePandas的DataFrame是一个二维的、大小可变的、潜在的异构表格数据结构，带有标记的轴（行和列）。理解DataFrame的基础语法和创建方法是使用Pandas进行数据分析和数据处理的基础。 基础语法创建DataFrame的基础语法如下： 1pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) 参数说明 data: 接受多种类型的输入，包括但不限于ndarray、Series、map、lists、dict等。这是DataFrame中存储的主要数据。 index: 行标签。如果没有指定，就像在Series中一样，Pandas会默认创建从0开始的整数索引。 columns: 列标签，默认为RangeIndex (0, 1, 2, …, n)。如果数据输入是字典，则默认列标签是字典键排序后的顺序。 dtype: 数据类型。可以为整个DataFrame指定一个统一的数据类型。如果不指定，则会自动推断。 copy: 是否复制输入数据，默认为False。如果为True，则复制，这可以避免修改到原始数据。 创建DataFrame示例通过列表创建DataFrame12345678910import pandas as pd# 创建数据列表data = [[&#x27;Google&#x27;, 10], [&#x27;Runoob&#x27;, 12], [&#x27;Wiki&#x27;, 13]]# 创建DataFramedf = pd.DataFrame(data, columns=[&#x27;Site&#x27;, &#x27;Age&#x27;], dtype=float)# 打印DataFrameprint(df) 输出结果将是一个DataFrame，包含两列Site和Age，数据类型被设置为浮点数： 1234 Site Age0 Google 10.01 Runoob 12.02 Wiki 13.0 在这个例子中，data是一个列表，其中包含三个子列表，每个子列表代表一行数据。通过columns参数指定了列名为Site和Age，通过dtype参数将所有数值数据类型指定为浮点数。 在Pandas中，DataFrame是用于存储和操作结构化数据的主要数据结构。以下内容整理了DataFrame的创建、基本操作、属性和方法，以及如何从外部数据源创建DataFrame的相关信息。 通过ndarrays或列表的字典创建123456import pandas as pd# 使用字典创建DataFramedata = &#123;&#x27;Site&#x27;: [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Wiki&#x27;], &#x27;Age&#x27;: [10, 12, 13]&#125;df = pd.DataFrame(data)print(df) 输出结果： 1234 Site Age0 Google 101 Runoob 122 Wiki 13 通过字典列表创建1234# 使用字典列表创建DataFramedata = [&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;, &#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 10, &#x27;c&#x27;: 20&#125;]df = pd.DataFrame(data)print(df) 输出结果： 123 a b c0 1 2 NaN1 5 10 20.0 注意：缺失的数据部分为NaN，而非NULL。 loc 属性返回指定行的数据首先，导入Pandas库，并创建一个包含数据的字典，然后将其载入到DataFrame对象中。默认情况下，如果没有指定索引，Pandas会自动创建一个从0开始的整数索引。 12345678import pandas as pddata = &#123; &quot;calories&quot;: [420, 380, 390], &quot;duration&quot;: [50, 40, 45]&#125;df = pd.DataFrame(data) 返回单行数据使用loc属性，可以通过指定行索引来返回对应的数据行。此时，返回的结果是一个Pandas Series数据类型。 返回第一行数据： 1print(df.loc[0]) 返回第二行数据： 1print(df.loc[1]) 返回多行数据loc同样可以用于返回多行数据，通过传递一个包含多个索引的列表作为参数。 返回第一行和第二行数据： 1print(df.loc[[0, 1]]) 使用自定义索引Pandas允许为DataFrame对象的行设置自定义索引。 12df = pd.DataFrame(data, index = [&quot;day1&quot;, &quot;day2&quot;, &quot;day3&quot;])print(df) 使用自定义索引后，可以使用这些索引值来检索数据行。 使用loc属性返回自定义索引对应的某一行： 1print(df.loc[&quot;day2&quot;]) 在这个例子中，我们首先设置了自定义索引（”day1”, “day2”, “day3”），然后通过这些索引来检索数据。当使用loc与自定义索引时，指定的索引值必须存在于DataFrame的索引中，否则会引发KeyError。 在使用Pandas处理数据时，DataFrame是一个非常核心的数据结构，它允许以表格的形式存储和操作结构化数据。以下是对提供的代码和概念的整理和解释，帮助更好地理解如何使用DataFrame进行基本操作、属性和方法的调用、数据操作技巧，以及如何从外部数据源创建DataFrame。 基本操作获取列1name_column = df[&#x27;Name&#x27;] 获取行1first_row = df.loc[0] 选择多列1subset = df[[&#x27;Name&#x27;, &#x27;Age&#x27;]] 过滤行1filtered_rows = df[df[&#x27;Age&#x27;] &gt; 30] 属性和方法获取列名1columns = df.columns 获取形状（行数和列数）1shape = df.shape 获取索引1index = df.index 获取描述统计信息1stats = df.describe() 数据操作添加新列1df[&#x27;Salary&#x27;] = [50000, 60000, 70000] 删除列1df.drop(&#x27;City&#x27;, axis=1, inplace=True) 排序1df.sort_values(by=&#x27;Age&#x27;, ascending=False, inplace=True) 重命名列1df.rename(columns=&#123;&#x27;Name&#x27;: &#x27;Full Name&#x27;&#125;, inplace=True) 从外部数据源创建 DataFrame从CSV文件创建1df_csv = pd.read_csv(&#x27;example.csv&#x27;) 从Excel文件创建1df_excel = pd.read_excel(&#x27;example.xlsx&#x27;) 从字典列表创建12data_list = [&#123;&#x27;Name&#x27;: &#x27;Alice&#x27;, &#x27;Age&#x27;: 25&#125;, &#123;&#x27;Name&#x27;: &#x27;Bob&#x27;, &#x27;Age&#x27;: 30&#125;]df_from_list = pd.DataFrame(data_list) 注意 灵活性：DataFrame可以容纳不同数据类型的列（例如整数、浮点数、字符串等）。 索引：列名和行索引可以是字符串、整数等。Pandas提供了丰富的索引功能，以便于数据选择和操作。 数据操作：可以通过多种方式进行数据选择、过滤、修改和分析，这使得DataFrame非常适合数据清洗、转换、分析和可视化等工作。 案例缺失率缺失率是指在数据集中缺失值所占的比例，通常用于数据清洗和预处理阶段，以评估数据的完整性。计算缺失率的基本公式如下： $$ \\text{缺失率 (%)} &#x3D; \\left( \\frac{\\text{缺失值数量}}{\\text{总值数量}} \\right) \\times 100 $$ 其中， 数据集中的缺失值数量是指那些空白或者NULL值的数量。 数据集中的总值数量是指数据集中所有可能的数据点的数量，包括有效值和缺失值。 缺失率可以帮助我们了解数据缺失的严重程度，进而决定如何处理这些缺失值，比如通过删除缺失值、填补缺失值或者采用模型估计等方法。 创建数据表在这个DataFrame中，包含了几个列：id、date、city、age、category，以及price。 1234567891011import pandas as pdimport numpy as npdf = pd.DataFrame(&#123; &quot;id&quot;: [1001, 1002, 1003, 1004, 1005, 1006], &quot;date&quot;: pd.date_range(&#x27;20130102&#x27;, periods=6), &quot;city&quot;: [&#x27;Beijing &#x27;, &#x27;SH&#x27;, &#x27; guangzhou &#x27;, &#x27;Shenzhen&#x27;, &#x27;shanghai&#x27;, &#x27;BEIJING &#x27;], &quot;age&quot;: [23, 44, 54, 32, 34, 32], &quot;category&quot;: [&#x27;100-A&#x27;, &#x27;100-B&#x27;, &#x27;110-A&#x27;, &#x27;110-C&#x27;, &#x27;210-A&#x27;, &#x27;130-F&#x27;], &quot;price&quot;: [1200, np.nan, 2133, 5433, np.nan, 4432]&#125;, columns=[&#x27;id&#x27;, &#x27;date&#x27;, &#x27;city&#x27;, &#x27;category&#x27;, &#x27;age&#x27;, &#x27;price&#x27;]) 这段代码首先导入了必要的库：pandas和numpy。numpy在这里的用途是提供np.nan来表示缺失值，这在处理真实世界的数据时非常常见。 id列包含唯一标识符。 date列使用pd.date_range函数生成了一个日期范围。 city列包含了一些城市名称，注意这些城市名称前后可能包含空格。 age列包含了年龄。 category列包含了分类代码。 price列包含了价格，使用np.nan表示某些价格未知或缺失。 通过指定columns参数，确保了DataFrame列的顺序按照id、date、city、category、age、price的顺序排列，即使在字典中的顺序不是这样的。 数据概览1print(df) id date city category age price 0 1001 2013-01-02 Beijing 100-A 23 1200.0 1 1002 2013-01-03 SH 100-B 44 NaN 2 1003 2013-01-04 guangzhou 110-A 54 2133.0 3 1004 2013-01-05 Shenzhen 110-C 32 5433.0 4 1005 2013-01-06 shanghai 210-A 34 NaN 5 1006 2013-01-07 BEIJING 130-F 32 4432.0 每列缺失值的数量123# 计算每列缺失值的数量missing_values_count = df.isnull().sum()print(missing_values_count) id 0 date 0 city 0 category 0 age 0 price 2 dtype: int64 信息 1234显示所有的数据pd.set_option(&#x27;display.max_rows&#x27;, None) # 显示所有行pd.set_option(&#x27;display.max_columns&#x27;, None) # 显示所有列pd.set_option(&#x27;expand_frame_repr&#x27;, False) # 不自动换行 缺失率123# 计算缺失率missing_rate = (missing_values_count / len(df)) * 100print(missing_rate) id 0.000000 date 0.000000 city 0.000000 category 0.000000 age 0.000000 price 33.333333 dtype: float64 DataFrame常规操作修改index、columns修改DataFrame的索引（index）在Pandas中，修改DataFrame的索引是一个常见操作，可以帮助更好地定位和引用数据行。下面是如何修改DataFrame索引的步骤和示例： 设置默认显示行数：首先，我们可以通过pd.set_option来设置Pandas默认显示的行数。这里未展示设置方法，但可以通过print(df.head())来显示前几行数据，其中df是DataFrame变量名。 直接修改索引：可以通过直接赋值给df.index属性来修改整个DataFrame的索引。例如，如果有一个DataFrame row，并且想要将索引修改为[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]，需要确保索引的长度与DataFrame的行数相匹配。如果不匹配，会导致错误。 1row.index = [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;] 读取文件时只处理部分行当处理大型文件时，为了测试或其他目的，可能只想读取文件的一部分。使用pd.read_csv时，可以通过nrows参数来限制读取的行数。 1df = pd.read_csv(&#x27;./LCIS.csv&#x27;, nrows=3) 修改DataFrame的列名（columns）修改列名可以通过直接赋值给df.columns属性或使用rename方法。 直接修改所有列名：通过直接赋值给df.columns属性，可以为所有列设置新的列名。 1row.columns = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] 使用rename方法修改列名：如果只想修改某些列的名称，可以使用rename方法，并通过columns参数传入一个字典，字典的键是旧列名，值是新列名。使用inplace=True可以直接在原DataFrame上进行修改，而不是返回一个新的DataFrame。 1row.rename(columns=&#123;&#x27;ListingId&#x27;: &#x27;ID&#x27;&#125;, inplace=True) 单独修改一个索引或列名同样，使用rename方法也可以修改单个索引或列名，方法与修改列名类似。 1row.rename(index=&#123;0: &#x27;A&#x27;&#125;, inplace=True) 综合示例现在，让我们通过一个综合示例来展示如何实际应用上述操作，并提供预期的输出结果。 数据导入123import pandas as pddf = pd.read_csv(&#x27;LCIS.csv&#x27;,nrows=5, usecols=range(10))row = pd.DataFrame(df) 修改索引前的输出12print(&quot;修改索引前:&quot;)print(row.head()) 1234567修改索引前: ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别0 1693100 3629 6 12 2015/1/28 AA 普通 否 31 男1 1713229 3000 12 12 2015/1/30 AA 普通 是 24 男2 1904026 3629 12 12 2015/3/7 AA 普通 否 27 男3 2158281 3919 12 18 2015/4/14 C 普通 否 28 男4 2257194 14000 12 18 2015/4/23 C 普通 否 46 男 修改索引后的输出1234# 修改索引row.index = [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]print(&quot;\\n修改索引后:&quot;)print(row.head()) 1234567修改索引后: ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别x 1693100 3629 6 12 2015/1/28 AA 普通 否 31 男y 1713229 3000 12 12 2015/1/30 AA 普通 是 24 男z 1904026 3629 12 12 2015/3/7 AA 普通 否 27 男a 2158281 3919 12 18 2015/4/14 C 普通 否 28 男b 2257194 14000 12 18 2015/4/23 C 普通 否 46 男 修改列名1234# 修改列名row.columns = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;]print(&quot;\\n修改列名后:&quot;)print(row.head()) 1234567修改列名后: A B C D E F G H I Jx 1693100 3629 6 12 2015/1/28 AA 普通 否 31 男y 1713229 3000 12 12 2015/1/30 AA 普通 是 24 男z 1904026 3629 12 12 2015/3/7 AA 普通 否 27 男a 2158281 3919 12 18 2015/4/14 C 普通 否 28 男b 2257194 14000 12 18 2015/4/23 C 普通 否 46 男 使用rename方法重命名列1234# 使用rename方法重命名列row.rename(columns=&#123;&#x27;A&#x27;: &#x27;ID&#x27;&#125;, inplace=True)print(&quot;\\n使用rename方法修改列名后:&quot;)print(row) 1234567使用rename方法修改列名后: ID B C D E F G H I Jx 1693100 3629 6 12 2015/1/28 AA 普通 否 31 男y 1713229 3000 12 12 2015/1/30 AA 普通 是 24 男z 1904026 3629 12 12 2015/3/7 AA 普通 否 27 男a 2158281 3919 12 18 2015/4/14 C 普通 否 28 男b 2257194 14000 12 18 2015/4/23 C 普通 否 46 男 单独修改一个索引1234# 单独修改一个索引row.rename(index=&#123;&#x27;x&#x27;: &#x27;A&#x27;&#125;, inplace=True)print(&quot;\\n单独修改一个索引后:&quot;)print(row) 1234567单独修改一个索引后: ID B C D E F G H I JA 1693100 3629 6 12 2015/1/28 AA 普通 否 31 男y 1713229 3000 12 12 2015/1/30 AA 普通 是 24 男z 1904026 3629 12 12 2015/3/7 AA 普通 否 27 男a 2158281 3919 12 18 2015/4/14 C 普通 否 28 男b 2257194 14000 12 18 2015/4/23 C 普通 否 46 男 数据合并concat()函数概览pd.concat()可以沿着一条轴将多个对象堆叠到一起。主要参数包括： objs：一个序列或映射，表示要合并的pandas对象。 axis：默认为0，表示沿着行合并；设置为1表示沿着列合并。 ignore_index：如果为True，不使用索引标签进行连接；这将对结果DataFrame使用默认整数索引。 在Pandas中，pd.concat()函数是合并数据的一个非常有用的工具，它允许沿着特定的轴将多个DataFrame合并在一起。下面，我们将通过具体的示例来展示如何使用pd.concat()进行数据合并，包括沿着列(axis&#x3D;1)和沿着行(axis&#x3D;0)的合并。每个案例都将提供代码示例和预期的输出结果。 示例数据选择性读取行有时候，在读取文件创建DataFrame时，可能想要跳过某些行或只读取特定的行。可以通过skiprows和nrows参数来实现这一点： 123df = pd.read_csv(&#x27;./LCIS.csv&#x27;, skiprows=range(1, 4), nrows=3, usecols=range(2, 6))res = pd.DataFrame(df)print(res) 这里，skiprows=range(1, 4)跳过了文件的第1到第3行（注意行数是从0开始计数的），而nrows=3指定了之后只读取3行。 1234借款期限 借款利率 借款成功日期 初始评级0 12 18 2015/4/14 C1 12 18 2015/4/23 C2 6 15 2015/4/29 B 首先，让我们定义两个DataFrame，row和res，以便进行合并操作。假设这些DataFrame已经根据上文中的说明进行了加载和修改： 123456789101112import pandas as pd# 假设这是从文件中读取的DataFramerow = pd.read_csv(&#x27;LCIS.csv&#x27;, skiprows=range(1, 11), header=0, nrows=10, usecols=range(10))# 假设res是另一个文件中读取DataFrameres = pd.read_csv(&#x27;LCIS.csv&#x27;,skiprows=range(12, 20), header=0, nrows=10, usecols=range(10))print(&#x27;row DataFrame&#x27;)print(row)print(&quot;=============================================&quot;)print(&#x27;res DataFrame&#x27;)print(res) 12345678910111213141516171819202122232425row DataFrame ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 男1 2707322 5000 3 10.0 2015/6/5 AA 普通 否 35 男2 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 男3 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 男4 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 男5 3155520 7008 10 11.0 2015/7/12 AA 普通 否 34 男6 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 男7 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 男8 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 男9 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 男=============================================res DataFrame ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别0 1693100 3629 6 12 2015/1/28 AA 普通 否 31 男1 1713229 3000 12 12 2015/1/30 AA 普通 是 24 男2 1904026 3629 12 12 2015/3/7 AA 普通 否 27 男3 2158281 3919 12 18 2015/4/14 C 普通 否 28 男4 2257194 14000 12 18 2015/4/23 C 普通 否 46 男5 2272036 40000 6 15 2015/4/29 B 电商 是 32 男6 2315058 3200 3 10 2015/4/29 AA 普通 否 25 男7 2332817 3000 6 12 2015/5/6 AA 普通 是 38 男8 2365175 4260 7 12 2015/5/6 AA 普通 否 25 男9 2370723 11987 12 16 2015/5/7 B 其他 否 33 女 沿着列合并DataFrame当想要将两个DataFrame按列拼接（即并排放置），可以设置axis=1。这通常用于合并具有相同索引的DataFrame，但列不同的情况。 12num = pd.concat([row, res], axis=1)print(num) 预期输出是row和resDataFrame并排放置的结果，这里由于row和res的行数相同，因此可以直接并排合并。 1234567891011121314151617181920212223 ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别 ListingId \\0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 男 1693100 1 2707322 5000 3 10.0 2015/6/5 AA 普通 否 35 男 1713229 2 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 男 1904026 3 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 男 2158281 4 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 男 2257194 5 3155520 7008 10 11.0 2015/7/12 AA 普通 否 34 男 2272036 6 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 男 2315058 7 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 男 2332817 8 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 男 2365175 9 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 男 2370723 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别 0 3629 6 12 2015/1/28 AA 普通 否 31 男 1 3000 12 12 2015/1/30 AA 普通 是 24 男 2 3629 12 12 2015/3/7 AA 普通 否 27 男 3 3919 12 18 2015/4/14 C 普通 否 28 男 4 14000 12 18 2015/4/23 C 普通 否 46 男 5 40000 6 15 2015/4/29 B 电商 是 32 男 6 3200 3 10 2015/4/29 AA 普通 否 25 男 7 3000 6 12 2015/5/6 AA 普通 是 38 男 8 4260 7 12 2015/5/6 AA 普通 否 25 男 9 11987 12 16 2015/5/7 B 其他 否 33 女 沿着行合并DataFrame如果想将两个DataFrame上下拼接，可以设置axis=0。这通常用于合并具有相同列的DataFrame，或者即使列不完全相同也可以合并，Pandas会自动处理不匹配的列。 12num = pd.concat([row, res], axis=0)print(num) 在这个例子中，由于res仅包含row的部分列，合并结果会展示所有列，不在res中的列对应的行会显示为NaN。 123456789101112131415161718192021 ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 男1 2707322 5000 3 10.0 2015/6/5 AA 普通 否 35 男2 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 男3 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 男4 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 男5 3155520 7008 10 11.0 2015/7/12 AA 普通 否 34 男6 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 男7 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 男8 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 男9 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 男0 1693100 3629 6 12.0 2015/1/28 AA 普通 否 31 男1 1713229 3000 12 12.0 2015/1/30 AA 普通 是 24 男2 1904026 3629 12 12.0 2015/3/7 AA 普通 否 27 男3 2158281 3919 12 18.0 2015/4/14 C 普通 否 28 男4 2257194 14000 12 18.0 2015/4/23 C 普通 否 46 男5 2272036 40000 6 15.0 2015/4/29 B 电商 是 32 男6 2315058 3200 3 10.0 2015/4/29 AA 普通 否 25 男7 2332817 3000 6 12.0 2015/5/6 AA 普通 是 38 男8 2365175 4260 7 12.0 2015/5/6 AA 普通 否 25 男9 2370723 11987 12 16.0 2015/5/7 B 其他 否 33 女 重置索引以避免索引重复在进行行合并时，如果不希望保留原始的索引，可以设置ignore_index=True，以避免索引重复的问题。 12num = pd.concat([row, res], axis=0, ignore_index=True)print(num) 这会创建一个新的DataFrame，其中索引是重新生成的，从0开始，避免了任何索引重复的问题。 123456789101112131415161718192021 ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 男1 2707322 5000 3 10.0 2015/6/5 AA 普通 否 35 男2 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 男3 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 男4 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 男5 3155520 7008 10 11.0 2015/7/12 AA 普通 否 34 男6 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 男7 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 男8 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 男9 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 男10 1693100 3629 6 12.0 2015/1/28 AA 普通 否 31 男11 1713229 3000 12 12.0 2015/1/30 AA 普通 是 24 男12 1904026 3629 12 12.0 2015/3/7 AA 普通 否 27 男13 2158281 3919 12 18.0 2015/4/14 C 普通 否 28 男14 2257194 14000 12 18.0 2015/4/23 C 普通 否 46 男15 2272036 40000 6 15.0 2015/4/29 B 电商 是 32 男16 2315058 3200 3 10.0 2015/4/29 AA 普通 否 25 男17 2332817 3000 6 12.0 2015/5/6 AA 普通 是 38 男18 2365175 4260 7 12.0 2015/5/6 AA 普通 否 25 男19 2370723 11987 12 16.0 2015/5/7 B 其他 否 33 女 merge()在Pandas中，pd.merge()函数提供了一个强大的方式来合并两个DataFrame，基于一个或多个共同的键。下面，将详细介绍如何使用pd.merge()进行数据合并，包括基于相同列的简单合并、处理行的选择性读取、以及基于不同列名进行合并。每个案例都会提供代码示例和预期的输出。 示例数据使用concat()示例中同样的数据 基于共同列合并DataFrame当两个DataFrame具有至少一个共同的列时，可以使用这个共同列作为合并的基础。以下是如何根据共同列&#39;借款期限&#39;合并两个DataFrame的示例： 12345import pandas as pd# 假设row和res是concat()示例中已经加载的DataFrame，且它们有一个共同列&#x27;借款期限&#x27;num = pd.merge(row, res, on=&#x27;借款期限&#x27;)print(num) 在这个示例中，pd.merge()通过on=&#39;借款期限&#39;参数指定了合并的基础列。这将只保留那些在两个DataFrame中都存在的&#39;借款期限&#39;值的行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 ListingId_x 借款金额_x 借款期限 借款利率_x 借款成功日期_x 初始评级_x 借款类型_x 是否首标_x 年龄_x \\0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 1 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 2 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 3 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 4 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 5 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 6 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 7 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 8 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 9 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 10 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 11 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 12 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 13 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 14 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 15 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 16 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 17 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 18 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 19 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 20 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 21 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 22 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 23 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 24 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 25 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 26 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 27 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 28 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 29 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 30 2707322 5000 3 10.0 2015/6/5 AA 普通 否 35 31 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 32 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 33 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 性别_x ListingId_y 借款金额_y 借款利率_y 借款成功日期_y 初始评级_y 借款类型_y 是否首标_y 年龄_y \\0 男 1713229 3000 12 2015/1/30 AA 普通 是 24 1 男 1904026 3629 12 2015/3/7 AA 普通 否 27 2 男 2158281 3919 18 2015/4/14 C 普通 否 28 3 男 2257194 14000 18 2015/4/23 C 普通 否 46 4 男 2370723 11987 16 2015/5/7 B 其他 否 33 5 男 1713229 3000 12 2015/1/30 AA 普通 是 24 6 男 1904026 3629 12 2015/3/7 AA 普通 否 27 7 男 2158281 3919 18 2015/4/14 C 普通 否 28 8 男 2257194 14000 18 2015/4/23 C 普通 否 46 9 男 2370723 11987 16 2015/5/7 B 其他 否 33 10 男 1713229 3000 12 2015/1/30 AA 普通 是 24 11 男 1904026 3629 12 2015/3/7 AA 普通 否 27 12 男 2158281 3919 18 2015/4/14 C 普通 否 28 13 男 2257194 14000 18 2015/4/23 C 普通 否 46 14 男 2370723 11987 16 2015/5/7 B 其他 否 33 15 男 1713229 3000 12 2015/1/30 AA 普通 是 24 16 男 1904026 3629 12 2015/3/7 AA 普通 否 27 17 男 2158281 3919 18 2015/4/14 C 普通 否 28 18 男 2257194 14000 18 2015/4/23 C 普通 否 46 19 男 2370723 11987 16 2015/5/7 B 其他 否 33 20 男 1713229 3000 12 2015/1/30 AA 普通 是 24 21 男 1904026 3629 12 2015/3/7 AA 普通 否 27 22 男 2158281 3919 18 2015/4/14 C 普通 否 28 23 男 2257194 14000 18 2015/4/23 C 普通 否 46 24 男 2370723 11987 16 2015/5/7 B 其他 否 33 25 男 1713229 3000 12 2015/1/30 AA 普通 是 24 26 男 1904026 3629 12 2015/3/7 AA 普通 否 27 27 男 2158281 3919 18 2015/4/14 C 普通 否 28 28 男 2257194 14000 18 2015/4/23 C 普通 否 46 29 男 2370723 11987 16 2015/5/7 B 其他 否 33 30 男 2315058 3200 10 2015/4/29 AA 普通 否 25 31 男 1693100 3629 12 2015/1/28 AA 普通 否 31 32 男 2272036 40000 15 2015/4/29 B 电商 是 32 33 男 2332817 3000 12 2015/5/6 AA 普通 是 38 性别_y 0 男 1 男 2 男 3 男 4 女 5 男 6 男 7 男 8 男 9 女 10 男 11 男 12 男 13 男 14 女 15 男 16 男 17 男 18 男 19 女 20 男 21 男 22 男 23 男 24 女 25 男 26 男 27 男 28 男 29 女 30 男 31 男 32 男 33 男 基于不同列名的合并如果两个DataFrame要合并的列名不同，可以分别使用left_on和right_on参数来指定各自的列名： 12num = pd.merge(row, res, left_on=&#x27;借款期限&#x27;, right_on=&#x27;借款利率&#x27;)print(num) 在这个例子中，尽管row和res中要合并的列名不同，但通过left_on和right_on参数，我们能够指定如何将两个DataFrame基于对应列的值进行合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104 ListingId_x 借款金额_x 借款期限_x 借款利率_x 借款成功日期_x 初始评级_x 借款类型_x 是否首标_x 年龄_x \\0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 1 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 2 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 3 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 4 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 5 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 6 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 7 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 8 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 9 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 10 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 11 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 12 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 13 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 14 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 15 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 16 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 17 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 18 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 19 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 20 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 21 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 22 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 23 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 24 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 25 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 26 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 27 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 28 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 29 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 30 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 31 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 32 3155520 7008 10 11.0 2015/7/12 AA 普通 否 34 性别_x ListingId_y 借款金额_y 借款期限_y 借款利率_y 借款成功日期_y 初始评级_y 借款类型_y 是否首标_y \\0 男 1693100 3629 6 12 2015/1/28 AA 普通 否 1 男 1713229 3000 12 12 2015/1/30 AA 普通 是 2 男 1904026 3629 12 12 2015/3/7 AA 普通 否 3 男 2332817 3000 6 12 2015/5/6 AA 普通 是 4 男 2365175 4260 7 12 2015/5/6 AA 普通 否 5 男 1693100 3629 6 12 2015/1/28 AA 普通 否 6 男 1713229 3000 12 12 2015/1/30 AA 普通 是 7 男 1904026 3629 12 12 2015/3/7 AA 普通 否 8 男 2332817 3000 6 12 2015/5/6 AA 普通 是 9 男 2365175 4260 7 12 2015/5/6 AA 普通 否 10 男 1693100 3629 6 12 2015/1/28 AA 普通 否 11 男 1713229 3000 12 12 2015/1/30 AA 普通 是 12 男 1904026 3629 12 12 2015/3/7 AA 普通 否 13 男 2332817 3000 6 12 2015/5/6 AA 普通 是 14 男 2365175 4260 7 12 2015/5/6 AA 普通 否 15 男 1693100 3629 6 12 2015/1/28 AA 普通 否 16 男 1713229 3000 12 12 2015/1/30 AA 普通 是 17 男 1904026 3629 12 12 2015/3/7 AA 普通 否 18 男 2332817 3000 6 12 2015/5/6 AA 普通 是 19 男 2365175 4260 7 12 2015/5/6 AA 普通 否 20 男 1693100 3629 6 12 2015/1/28 AA 普通 否 21 男 1713229 3000 12 12 2015/1/30 AA 普通 是 22 男 1904026 3629 12 12 2015/3/7 AA 普通 否 23 男 2332817 3000 6 12 2015/5/6 AA 普通 是 24 男 2365175 4260 7 12 2015/5/6 AA 普通 否 25 男 1693100 3629 6 12 2015/1/28 AA 普通 否 26 男 1713229 3000 12 12 2015/1/30 AA 普通 是 27 男 1904026 3629 12 12 2015/3/7 AA 普通 否 28 男 2332817 3000 6 12 2015/5/6 AA 普通 是 29 男 2365175 4260 7 12 2015/5/6 AA 普通 否 30 男 2158281 3919 12 18 2015/4/14 C 普通 否 31 男 2257194 14000 12 18 2015/4/23 C 普通 否 32 男 2315058 3200 3 10 2015/4/29 AA 普通 否 年龄_y 性别_y 0 31 男 1 24 男 2 27 男 3 38 男 4 25 男 5 31 男 6 24 男 7 27 男 8 38 男 9 25 男 10 31 男 11 24 男 12 27 男 13 38 男 14 25 男 15 31 男 16 24 男 17 27 男 18 38 男 19 25 男 20 31 男 21 24 男 22 27 男 23 38 男 24 25 男 25 31 男 26 24 男 27 27 男 28 38 男 29 25 男 30 28 男 31 46 男 32 25 男 指定合并方式pd.merge()允许通过how参数来指定合并方式，包括&#39;inner&#39;（内连接）、&#39;outer&#39;（外连接）、&#39;left&#39;（左连接）和&#39;right&#39;（右连接）： 12num = pd.merge(row, res, left_on=&#x27;借款期限&#x27;, right_on=&#x27;借款利率&#x27;, how=&#x27;inner&#x27;)print(num) 这里，how=&#39;inner&#39;意味着结果中只包含那些两个DataFrame在指定列上都有匹配值的行。不同的how值可以根据需要选择，以实现不同的合并逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104 ListingId_x 借款金额_x 借款期限_x 借款利率_x 借款成功日期_x 初始评级_x 借款类型_x 是否首标_x 年龄_x \\0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 1 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 2 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 3 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 4 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 5 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 6 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 7 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 8 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 9 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 10 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 11 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 12 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 13 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 14 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 15 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 16 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 17 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 18 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 19 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 20 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 21 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 22 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 23 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 24 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 25 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 26 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 27 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 28 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 29 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 30 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 31 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 32 3155520 7008 10 11.0 2015/7/12 AA 普通 否 34 性别_x ListingId_y 借款金额_y 借款期限_y 借款利率_y 借款成功日期_y 初始评级_y 借款类型_y 是否首标_y \\0 男 1693100 3629 6 12 2015/1/28 AA 普通 否 1 男 1713229 3000 12 12 2015/1/30 AA 普通 是 2 男 1904026 3629 12 12 2015/3/7 AA 普通 否 3 男 2332817 3000 6 12 2015/5/6 AA 普通 是 4 男 2365175 4260 7 12 2015/5/6 AA 普通 否 5 男 1693100 3629 6 12 2015/1/28 AA 普通 否 6 男 1713229 3000 12 12 2015/1/30 AA 普通 是 7 男 1904026 3629 12 12 2015/3/7 AA 普通 否 8 男 2332817 3000 6 12 2015/5/6 AA 普通 是 9 男 2365175 4260 7 12 2015/5/6 AA 普通 否 10 男 1693100 3629 6 12 2015/1/28 AA 普通 否 11 男 1713229 3000 12 12 2015/1/30 AA 普通 是 12 男 1904026 3629 12 12 2015/3/7 AA 普通 否 13 男 2332817 3000 6 12 2015/5/6 AA 普通 是 14 男 2365175 4260 7 12 2015/5/6 AA 普通 否 15 男 1693100 3629 6 12 2015/1/28 AA 普通 否 16 男 1713229 3000 12 12 2015/1/30 AA 普通 是 17 男 1904026 3629 12 12 2015/3/7 AA 普通 否 18 男 2332817 3000 6 12 2015/5/6 AA 普通 是 19 男 2365175 4260 7 12 2015/5/6 AA 普通 否 20 男 1693100 3629 6 12 2015/1/28 AA 普通 否 21 男 1713229 3000 12 12 2015/1/30 AA 普通 是 22 男 1904026 3629 12 12 2015/3/7 AA 普通 否 23 男 2332817 3000 6 12 2015/5/6 AA 普通 是 24 男 2365175 4260 7 12 2015/5/6 AA 普通 否 25 男 1693100 3629 6 12 2015/1/28 AA 普通 否 26 男 1713229 3000 12 12 2015/1/30 AA 普通 是 27 男 1904026 3629 12 12 2015/3/7 AA 普通 否 28 男 2332817 3000 6 12 2015/5/6 AA 普通 是 29 男 2365175 4260 7 12 2015/5/6 AA 普通 否 30 男 2158281 3919 12 18 2015/4/14 C 普通 否 31 男 2257194 14000 12 18 2015/4/23 C 普通 否 32 男 2315058 3200 3 10 2015/4/29 AA 普通 否 年龄_y 性别_y 0 31 男 1 24 男 2 27 男 3 38 男 4 25 男 5 31 男 6 24 男 7 27 男 8 38 男 9 25 男 10 31 男 11 24 男 12 27 男 13 38 男 14 25 男 15 31 男 16 24 男 17 27 男 18 38 男 19 25 男 20 31 男 21 24 男 22 27 男 23 38 男 24 25 男 25 31 男 26 24 男 27 27 男 28 38 男 29 25 男 30 28 男 31 46 男 32 25 男 通过上述示例，可以看到pd.merge()在Pandas中合并数据时的灵活性和强大功能。这些基础知识使得在进行数据分析和处理时，能够根据实际需求选择合适的合并策略。 join()在Pandas中，join()函数是用于将两个或多个DataFrame按照索引合并。这个函数默认执行的是左连接操作，即以调用join()的DataFrame的索引为基准。不过，可以通过how参数来指定连接类型，包括left（左连接）、right（右连接）、inner（内连接）和outer（外连接）。 警告 在尝试使用join()合并两个DataFrame时，两个DataFrame中存在相同名称的列。join()方法默认通过索引来合并数据，如果合并的DataFrame中有重叠的列名（即非索引列），则需要指定后缀来区分这些重叠的列，否则会抛出ValueError。 为了解决这个问题，可以使用lsuffix和rsuffix参数来为左右DataFrame中重叠的列名分别添加后缀。这样，即使列名相同，添加了后缀之后也能区分开来。 下面的代码展示了如何使用这些参数来避免错误： 123456# 使用lsuffix和rsuffix添加后缀result_right = row.join(res, how=&#x27;right&#x27;, lsuffix=&#x27;_left&#x27;, rsuffix=&#x27;_right&#x27;)print(result_right)result_outer = row.join(res, how=&#x27;outer&#x27;, lsuffix=&#x27;_left&#x27;, rsuffix=&#x27;_right&#x27;)print(result_outer) 在这个例子中，lsuffix=&#39;_left&#39;会给左侧DataFrame的重叠列名添加后缀_left，rsuffix=&#39;_right&#39;会给右侧DataFrame的重叠列名添加后缀_right。这样，即便原始列名相同，通过添加的后缀也能将它们区分开来，从而避免了错误。 如果目标是基于某些列值而不是索引来合并DataFrame，可能merge()方法更适合需求，因为它提供了更灵活的列合并选项。 左连接（Left Join）左连接会保留左侧DataFrame的所有行，即使在右侧DataFrame中没有匹配的索引。如果右侧DataFrame中存在匹配的索引，则相应的列会被添加到结果中。如果不存在，则结果中这些列的值会设置为NaN。 123# 左连接result_left = row.join(res, how=&#x27;left&#x27;, lsuffix=&#x27;_left&#x27;, rsuffix=&#x27;_right&#x27;)print(result_left) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 ListingId_left 借款金额_left 借款期限_left 借款利率_left 借款成功日期_left 初始评级_left \\0 2526671 5115 12 12.0 2015/5/23 AA 1 2707322 5000 3 10.0 2015/6/5 AA 2 2722356 3132 12 20.0 2015/6/13 D 3 2828736 3000 12 12.0 2015/6/19 AA 4 2850335 17640 18 16.0 2015/6/18 B 5 3155520 7008 10 11.0 2015/7/12 AA 6 3207478 19928 12 16.0 2015/7/14 B 7 3617672 7000 12 11.5 2015/8/12 AA 8 3637812 4000 6 10.5 2015/8/17 AA 9 3705094 1000 12 11.5 2015/8/21 AA 借款类型_left 是否首标_left 年龄_left 性别_left ListingId_right 借款金额_right \\0 普通 否 34 男 1693100 3629 1 普通 否 35 男 1713229 3000 2 普通 否 30 男 1904026 3629 3 普通 是 24 男 2158281 3919 4 其他 是 28 男 2257194 14000 5 普通 否 34 男 2272036 40000 6 其他 是 22 男 2315058 3200 7 普通 是 43 男 2332817 3000 8 其他 是 24 男 2365175 4260 9 普通 是 26 男 2370723 11987 借款期限_right 借款利率_right 借款成功日期_right 初始评级_right 借款类型_right 是否首标_right \\0 6 12 2015/1/28 AA 普通 否 1 12 12 2015/1/30 AA 普通 是 2 12 12 2015/3/7 AA 普通 否 3 12 18 2015/4/14 C 普通 否 4 12 18 2015/4/23 C 普通 否 5 6 15 2015/4/29 B 电商 是 6 3 10 2015/4/29 AA 普通 否 7 6 12 2015/5/6 AA 普通 是 8 7 12 2015/5/6 AA 普通 否 9 12 16 2015/5/7 B 其他 否 年龄_right 性别_right 0 31 男 1 24 男 2 27 男 3 28 男 4 46 男 5 32 男 6 25 男 7 38 男 8 25 男 9 33 女 右连接（Right Join）右连接与左连接相反，它会保留右侧DataFrame的所有行，即使在左侧DataFrame中没有匹配的索引。 123# 右连接result_right = row.join(res, how=&#x27;right&#x27;, lsuffix=&#x27;_left&#x27;, rsuffix=&#x27;_right&#x27;)print(result_right) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 ListingId_left 借款金额_left 借款期限_left 借款利率_left 借款成功日期_left 初始评级_left \\0 2526671 5115 12 12.0 2015/5/23 AA 1 2707322 5000 3 10.0 2015/6/5 AA 2 2722356 3132 12 20.0 2015/6/13 D 3 2828736 3000 12 12.0 2015/6/19 AA 4 2850335 17640 18 16.0 2015/6/18 B 5 3155520 7008 10 11.0 2015/7/12 AA 6 3207478 19928 12 16.0 2015/7/14 B 7 3617672 7000 12 11.5 2015/8/12 AA 8 3637812 4000 6 10.5 2015/8/17 AA 9 3705094 1000 12 11.5 2015/8/21 AA 借款类型_left 是否首标_left 年龄_left 性别_left ListingId_right 借款金额_right \\0 普通 否 34 男 1693100 3629 1 普通 否 35 男 1713229 3000 2 普通 否 30 男 1904026 3629 3 普通 是 24 男 2158281 3919 4 其他 是 28 男 2257194 14000 5 普通 否 34 男 2272036 40000 6 其他 是 22 男 2315058 3200 7 普通 是 43 男 2332817 3000 8 其他 是 24 男 2365175 4260 9 普通 是 26 男 2370723 11987 借款期限_right 借款利率_right 借款成功日期_right 初始评级_right 借款类型_right 是否首标_right \\0 6 12 2015/1/28 AA 普通 否 1 12 12 2015/1/30 AA 普通 是 2 12 12 2015/3/7 AA 普通 否 3 12 18 2015/4/14 C 普通 否 4 12 18 2015/4/23 C 普通 否 5 6 15 2015/4/29 B 电商 是 6 3 10 2015/4/29 AA 普通 否 7 6 12 2015/5/6 AA 普通 是 8 7 12 2015/5/6 AA 普通 否 9 12 16 2015/5/7 B 其他 否 年龄_right 性别_right 0 31 男 1 24 男 2 27 男 3 28 男 4 46 男 5 32 男 6 25 男 7 38 男 8 25 男 9 33 女 外连接（Outer Join）外连接会保留左右两侧DataFrame中的所有行。如果某些行在另一侧没有匹配的索引，则结果DataFrame中这些行的相应列会被设置为NaN。 123# 外连接result_outer = row.join(res, how=&#x27;outer&#x27;, lsuffix=&#x27;_left&#x27;, rsuffix=&#x27;_right&#x27;)print(result_outer) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 ListingId_left 借款金额_left 借款期限_left 借款利率_left 借款成功日期_left 初始评级_left \\0 2526671 5115 12 12.0 2015/5/23 AA 1 2707322 5000 3 10.0 2015/6/5 AA 2 2722356 3132 12 20.0 2015/6/13 D 3 2828736 3000 12 12.0 2015/6/19 AA 4 2850335 17640 18 16.0 2015/6/18 B 5 3155520 7008 10 11.0 2015/7/12 AA 6 3207478 19928 12 16.0 2015/7/14 B 7 3617672 7000 12 11.5 2015/8/12 AA 8 3637812 4000 6 10.5 2015/8/17 AA 9 3705094 1000 12 11.5 2015/8/21 AA 借款类型_left 是否首标_left 年龄_left 性别_left ListingId_right 借款金额_right \\0 普通 否 34 男 1693100 3629 1 普通 否 35 男 1713229 3000 2 普通 否 30 男 1904026 3629 3 普通 是 24 男 2158281 3919 4 其他 是 28 男 2257194 14000 5 普通 否 34 男 2272036 40000 6 其他 是 22 男 2315058 3200 7 普通 是 43 男 2332817 3000 8 其他 是 24 男 2365175 4260 9 普通 是 26 男 2370723 11987 借款期限_right 借款利率_right 借款成功日期_right 初始评级_right 借款类型_right 是否首标_right \\0 6 12 2015/1/28 AA 普通 否 1 12 12 2015/1/30 AA 普通 是 2 12 12 2015/3/7 AA 普通 否 3 12 18 2015/4/14 C 普通 否 4 12 18 2015/4/23 C 普通 否 5 6 15 2015/4/29 B 电商 是 6 3 10 2015/4/29 AA 普通 否 7 6 12 2015/5/6 AA 普通 是 8 7 12 2015/5/6 AA 普通 否 9 12 16 2015/5/7 B 其他 否 年龄_right 性别_right 0 31 男 1 24 男 2 27 男 3 28 男 4 46 男 5 32 男 6 25 男 7 38 男 8 25 男 9 33 女 内连接（Inner Join）内连接只保留两个DataFrame中都有匹配的行。如果某行在另一侧没有匹配的索引，则这行不会出现在结果DataFrame中。 12# 内连接通常使用merge()而不是join(), 因为join()默认基于索引连接# result_inner = row.join(res, how=&#x27;inner&#x27;) # 不适用 使用示例在的例子中，使用join()可能不会直接给出期望的结果，因为join()默认是按索引进行合并的。如果DataFrame没有设置索引或者两个DataFrame的索引并不完全匹配，那么合并的结果可能不会是期望的。在这种情况下，使用merge()函数可能更为合适，因为它允许指定合并的列。 不过，如果仍想使用join()并基于列进行合并，可能需要先将某个列设置为索引，然后再进行连接操作。这里给出的代码示例直接使用join()，假设已经有了适当的索引设置。 123456# 假设df和res是要合并的DataFramedf = pd.read_csv(&#x27;./LCIS.csv&#x27;, nrows=5, usecols=range(3,6))res = pd.DataFrame(df)# 尝试使用右连接和外连接，展示效果print(row.join(res, how=&#x27;right&#x27;, lsuffix=&#x27;_left&#x27;, rsuffix=&#x27;_right&#x27;))print(row.join(res, how=&#x27;outer&#x27;, lsuffix=&#x27;_left&#x27;, rsuffix=&#x27;_right&#x27;)) 123456789101112131415161718192021222324252627282930313233343536 ListingId 借款金额 借款期限 借款利率_left 借款成功日期_left 初始评级_left 借款类型 是否首标 年龄 性别 \\0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 男 1 2707322 5000 3 10.0 2015/6/5 AA 普通 否 35 男 2 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 男 3 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 男 4 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 男 借款利率_right 借款成功日期_right 初始评级_right 0 12 2015/1/28 AA 1 12 2015/1/30 AA 2 12 2015/3/7 AA 3 18 2015/4/14 C 4 18 2015/4/23 C ListingId 借款金额 借款期限 借款利率_left 借款成功日期_left 初始评级_left 借款类型 是否首标 年龄 性别 \\0 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 男 1 2707322 5000 3 10.0 2015/6/5 AA 普通 否 35 男 2 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 男 3 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 男 4 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 男 5 3155520 7008 10 11.0 2015/7/12 AA 普通 否 34 男 6 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 男 7 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 男 8 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 男 9 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 男 借款利率_right 借款成功日期_right 初始评级_right 0 12.0 2015/1/28 AA 1 12.0 2015/1/30 AA 2 12.0 2015/3/7 AA 3 18.0 2015/4/14 C 4 18.0 2015/4/23 C 5 NaN NaN NaN 6 NaN NaN NaN 7 NaN NaN NaN 8 NaN NaN NaN 9 NaN NaN NaN 如果DataFrame没有公共列作为索引，可能需要先使用.set_index()方法来设置索引。 数据删除当处理数据集时，删除不需要的列或行是常见的数据清理步骤。在Pandas中，可以通过del语句或DataFrame.drop方法来实现。下面是如何使用这两种方法来删除数据的详细说明和示例： 使用del语句删除列del语句是Python的一个内置功能，它可以从DataFrame中直接删除指定的列。使用del语句时，更改是立即生效的，并且直接在原DataFrame上进行，不返回新的DataFrame。 示例代码： 1del row[&#x27;ListingId&#x27;] 这行代码会从row DataFrame中删除名为&#39;ListingId&#39;的列。 使用drop方法删除数据drop方法在Pandas中更加灵活，可以用于删除行或列，且可以控制是直接在原DataFrame上进行修改还是返回一个新的DataFrame。 删除行：12print(row.drop(0)) # 删除索引为0的行，不修改原DataFrame，除非指定inplace=Trueprint(row.drop([1, 2], inplace=False)) # 删除索引为1和2的行，不修改原DataFrame 删除列：1print(row.drop([&#x27;ListingId&#x27;], axis=1)) # 删除名为&#x27;ListingId&#x27;的列，不修改原DataFrame，除非指定inplace=True 在使用drop方法时，重要的参数包括： labels: 指定要删除的行标签或列名称。 axis: 通过设置0或1指定删除行或列。0代表行，1代表列。 inplace: 通过设置True或False指定是否在原地修改DataFrame。True表示在原DataFrame上修改，False（默认值）表示返回一个新的DataFrame，原DataFrame不变。 Pandas数据清洗在数据分析过程中，经常会遇到包含重复行的数据集，这可能会对分析结果产生不利影响。Pandas提供了方便的工具来帮助识别和删除这些重复的数据。下面是如何在Pandas中清洗重复数据的详细说明和示例： 清洗重复数据读取数据首先，我们通过读取一个CSV文件来创建一个DataFrame，作为处理重复数据的示例： 12345import pandas as pd# 读取50行数据df = pd.read_csv(&#x27;./LCIS.csv&#x27;, nrows=50)row = pd.DataFrame(df) 检查重复行使用DataFrame.duplicated()方法可以检查DataFrame中的重复行。此方法返回一个布尔系列，其中True表示对应的行是重复的，而False表示行是唯一的。 1print(row.duplicated()) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950510 False1 False2 False3 False4 False5 False6 False7 False8 False9 False10 False11 False12 False13 False14 False15 False16 False17 False18 False19 False20 False21 False22 False23 False24 False25 False26 False27 False28 False29 False30 False31 False32 False33 False34 False35 False36 False37 False38 False39 False40 False41 False42 False43 False44 False45 False46 False47 False48 False49 Falsedtype: bool 此外，还可以通过对一个简单的DataFrame进行操作来理解重复值的检查： 1234567data = &#123;&#x27;A&#x27;: [1, 1, 2, 3, 3], &#x27;B&#x27;: [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;]&#125;df = pd.DataFrame(data)# 统计重复行的个数df_count = df.duplicated().sum()print(df_count) 12 删除重复行使用DataFrame.drop_duplicates()方法可以删除DataFrame中的重复行。如果设置inplace=True，则会在原地修改DataFrame，而不是返回一个新的DataFrame。 1234567# 删除重复行，并在原地修改DataFramerow.drop_duplicates(inplace=True)print(row)print(&quot;=============================================&quot;)# 对于之前创建的简单DataFrame，也删除重复行df.drop_duplicates(inplace=True)print(df) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162 ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别 ... \\0 1693100 3629 6 12.0 2015/1/28 AA 普通 否 31 男 ... 1 1713229 3000 12 12.0 2015/1/30 AA 普通 是 24 男 ... 2 1904026 3629 12 12.0 2015/3/7 AA 普通 否 27 男 ... 3 2158281 3919 12 18.0 2015/4/14 C 普通 否 28 男 ... 4 2257194 14000 12 18.0 2015/4/23 C 普通 否 46 男 ... 5 2272036 40000 6 15.0 2015/4/29 B 电商 是 32 男 ... 6 2315058 3200 3 10.0 2015/4/29 AA 普通 否 25 男 ... 7 2332817 3000 6 12.0 2015/5/6 AA 普通 是 38 男 ... 8 2365175 4260 7 12.0 2015/5/6 AA 普通 否 25 男 ... 9 2370723 11987 12 16.0 2015/5/7 B 其他 否 33 女 ... 10 2526671 5115 12 12.0 2015/5/23 AA 普通 否 34 男 ... 11 2707322 5000 3 10.0 2015/6/5 AA 普通 否 35 男 ... 12 2722356 3132 12 20.0 2015/6/13 D 普通 否 30 男 ... 13 2828736 3000 12 12.0 2015/6/19 AA 普通 是 24 男 ... 14 2850335 17640 18 16.0 2015/6/18 B 其他 是 28 男 ... 15 3155520 7008 10 11.0 2015/7/12 AA 普通 否 34 男 ... 16 3207478 19928 12 16.0 2015/7/14 B 其他 是 22 男 ... 17 3617672 7000 12 11.5 2015/8/12 AA 普通 是 43 男 ... 18 3637812 4000 6 10.5 2015/8/17 AA 其他 是 24 男 ... 19 3705094 1000 12 11.5 2015/8/21 AA 普通 是 26 男 ... 20 3846919 5719 6 18.0 2015/8/26 C 普通 否 34 男 ... 21 7285364 8000 12 20.0 2016/1/6 C 普通 否 26 男 ... 22 7447346 4650 12 22.0 2016/1/9 C 普通 否 29 男 ... 23 7760072 9000 12 20.0 2016/1/21 C 其他 是 37 男 ... 24 7777242 9000 12 20.0 2016/1/21 C 普通 是 29 女 ... 25 7966976 8500 12 20.0 2016/1/24 C 普通 否 43 男 ... 26 8148541 13500 12 20.0 2016/1/28 C 普通 否 32 女 ... 27 8260540 6500 12 20.0 2016/1/30 C 普通 否 26 男 ... 28 8297477 6500 12 22.0 2016/1/31 C 普通 否 35 男 ... 29 8359807 8000 12 18.0 2016/2/3 B 普通 是 27 男 ... 30 8377465 11500 12 20.0 2016/2/2 C 普通 否 46 男 ... 31 8883343 25000 12 20.0 2016/2/23 C 普通 否 27 男 ... 32 8978256 8000 12 18.0 2016/2/25 B APP闪电 是 23 男 ... 33 8987694 5000 6 20.0 2016/2/26 C 普通 否 42 男 ... 34 9045950 4000 6 18.0 2016/2/28 B APP闪电 是 21 男 ... 35 9182372 8000 12 18.0 2016/3/2 B APP闪电 是 46 男 ... 36 9482974 3300 6 20.0 2016/3/11 C 普通 否 36 女 ... 37 9581580 7000 12 18.0 2016/3/12 B APP闪电 是 23 女 ... 38 9597362 1000 6 10.0 2016/3/17 AA 普通 是 23 男 ... 39 9601032 3000 12 18.0 2016/3/13 B APP闪电 是 25 女 ... 40 9602590 1200 12 12.0 2016/3/13 AA APP闪电 是 24 男 ... 41 9809712 4000 12 16.0 2016/3/20 A APP闪电 是 21 女 ... 42 9993691 3000 12 18.0 2016/3/26 B APP闪电 是 26 男 ... 43 10240655 2725 12 18.0 2016/4/4 B 普通 否 32 男 ... 44 10259916 1500 12 20.0 2016/3/29 C APP闪电 是 22 女 ... 45 10410378 4497 6 18.0 2016/4/1 B 其他 否 31 女 ... 46 10604020 2055 6 18.0 2016/4/6 B 普通 否 25 男 ... 47 10646264 2000 12 12.0 2016/4/7 AA APP闪电 是 25 女 ... 48 10829990 5782 12 20.0 2016/4/12 C 其他 否 32 男 ... 49 11055233 4139 12 22.0 2016/4/17 C 普通 否 36 男 ... 待还利息 标当前逾期天数 标当前状态 上次还款日期 上次还款本金 上次还款利息 下次计划还款日期 下次计划还款本金 \\0 0.00 0 已还清 2015/7/28 34.20 0.30 NaN NaN 1 0.00 0 已还清 2015/10/19 173.39 1.05 NaN NaN 2 0.00 0 已还清 2016/3/6 44.04 0.38 NaN NaN 3 0.00 0 已还清 2015/5/19 92.34 0.22 NaN NaN 4 9.92 589 逾期中 NaN NaN NaN 2015/5/23 7.66 5 0.00 0 已还清 2015/10/27 35.43 0.42 NaN NaN 6 0.00 0 已还清 2015/7/17 134.45 1.11 NaN NaN 7 0.00 0 已还清 2015/11/6 8.74 0.05 NaN NaN 8 0.00 0 已还清 2015/8/5 29.59 0.00 NaN NaN 9 0.00 0 已还清 2016/1/22 35.16 0.18 NaN NaN 10 0.00 0 已还清 2016/5/22 3.58 0.00 NaN NaN 11 0.00 0 已还清 2015/9/5 63.20 0.51 NaN NaN 12 0.00 0 已还清 2015/7/20 7.31 0.00 NaN NaN 13 0.00 0 已还清 2016/4/21 52.54 0.01 NaN NaN 14 0.25 0 正常还款中 2016/12/15 1.14 0.11 2017/1/18 1.16 15 0.00 0 已还清 2016/5/12 52.11 0.44 NaN NaN 16 0.00 0 已还清 2016/12/13 26.74 0.28 NaN NaN 17 0.00 0 已还清 2015/10/18 43.94 0.36 NaN NaN 18 0.00 0 已还清 2015/9/14 300.00 2.45 NaN NaN 19 0.00 0 已还清 2016/8/20 13.22 0.07 NaN NaN 20 0.00 0 已还清 2015/11/15 33.84 0.32 NaN NaN 21 2.02 179 逾期中 2016/6/6 4.05 0.58 2016/7/6 4.12 22 0.00 0 已还清 2016/11/25 9.14 0.05 NaN NaN 23 0.02 0 正常还款中 2016/12/20 4.48 0.15 2017/1/21 4.61 24 0.02 0 正常还款中 2016/12/20 4.48 0.15 2017/1/21 4.61 25 0.02 0 正常还款中 2016/12/24 4.48 0.15 2017/1/24 4.61 26 0.00 0 已还清 2016/8/26 22.08 0.00 NaN NaN 27 0.17 2 逾期中 2016/11/30 4.40 0.23 2016/12/30 4.48 28 0.04 0 正常还款中 2016/12/31 4.51 0.16 2017/1/31 4.63 29 0.04 0 正常还款中 2016/12/3 1.40 0.06 2017/1/3 1.42 30 0.02 0 正常还款中 2016/12/18 4.48 0.15 2017/2/2 4.61 31 0.00 0 已还清 2016/12/23 4.61 0.02 NaN NaN 32 0.14 0 正常还款中 2016/12/30 4.38 0.20 2017/1/25 4.44 33 0.00 0 已还清 2016/6/29 17.24 0.00 NaN NaN 34 0.00 0 已还清 2016/8/23 8.68 0.09 NaN NaN 35 0.34 0 正常还款中 2016/12/1 4.31 0.27 2017/1/2 4.38 36 0.00 0 已还清 2016/9/3 8.71 0.11 NaN NaN 37 0.34 0 正常还款中 2016/12/10 4.31 0.27 2017/1/12 4.38 38 0.00 0 已还清 2016/9/17 85.08 0.70 NaN NaN 39 0.34 0 正常还款中 2016/12/11 4.31 0.27 2017/1/13 4.38 40 2.55 0 正常还款中 2016/12/14 42.68 1.74 2017/1/13 43.11 41 0.30 0 正常还款中 2016/12/23 4.30 0.23 2017/1/20 4.35 42 0.00 0 已还清 2016/12/23 4.58 0.00 NaN NaN 43 0.14 0 正常还款中 2016/12/28 4.38 0.20 2017/3/4 4.44 44 0.40 0 正常还款中 2016/12/29 4.33 0.30 2017/1/29 4.40 45 0.00 0 已还清 2016/8/29 8.68 0.00 NaN NaN 46 0.00 0 已还清 2016/8/28 17.19 0.16 NaN NaN 47 1.66 0 正常还款中 2016/12/8 16.90 0.86 2017/1/7 0.00 48 0.81 0 正常还款中 2016/12/10 4.94 0.43 2017/1/12 5.02 49 0.00 0 已还清 2016/10/24 26.38 0.09 NaN NaN 下次计划还款利息 recorddate 0 NaN 2016/12/31 1 NaN 2016/12/31 2 NaN 2016/12/31 3 NaN 2016/12/31 4 1.50 2016/12/31 5 NaN 2016/12/31 6 NaN 2016/12/31 7 NaN 2016/12/31 8 NaN 2016/12/31 9 NaN 2016/12/31 10 NaN 2016/12/31 11 NaN 2016/12/31 12 NaN 2016/12/31 13 NaN 2016/12/31 14 0.09 2016/12/31 15 NaN 2016/12/31 16 NaN 2016/12/31 17 NaN 2016/12/31 18 NaN 2016/12/31 19 NaN 2016/12/31 20 NaN 2016/12/31 21 0.51 2016/12/31 22 NaN 2016/12/31 23 0.02 2016/12/31 24 0.02 2016/12/31 25 0.02 2016/12/31 26 NaN 2016/12/31 27 0.15 2016/12/31 28 0.04 2016/12/31 29 0.04 2016/12/31 30 0.02 2016/12/31 31 NaN 2016/12/31 32 0.14 2016/12/31 33 NaN 2016/12/31 34 NaN 2016/12/31 35 0.20 2016/12/31 36 NaN 2016/12/31 37 0.20 2016/12/31 38 NaN 2016/12/31 39 0.20 2016/12/31 40 1.31 2016/12/31 41 0.18 2016/12/31 42 NaN 2016/12/31 43 0.14 2016/12/31 44 0.23 2016/12/31 45 NaN 2016/12/31 46 NaN 2016/12/31 47 0.00 2016/12/31 48 0.35 2016/12/31 49 NaN 2016/12/31 [50 rows x 37 columns]============================================= A B0 1 a2 2 b3 3 c 通过这种方式，可以有效地清理数据集中的重复项，确保进行数据分析时数据的准确性和可靠性。在实际的数据处理中，根据数据的具体情况和需求，合理地使用这些方法可以大大提高数据分析的质量和效率。 清洗空值在数据处理和分析中，处理缺失值是一个重要的步骤，因为缺失值可能会影响数据分析的结果。Pandas 提供了多种方法来处理 DataFrame 中的缺失值。下面我们将详细探讨如何统计空值，计算缺失率，删除含有空值的行或列，以及填充空值的不同方法。 统计空值和计算缺失率统计空值数量123456789import pandas as pd# 读取数据df = pd.read_csv(&#x27;./LCIS.csv&#x27;, nrows=50)row = pd.DataFrame(df)# 统计各列空值的数量res = row.isnull().sum()print(res) 1234567891011121314151617181920212223242526272829303132333435363738ListingId 0借款金额 0借款期限 0借款利率 0借款成功日期 0初始评级 0借款类型 0是否首标 0年龄 0性别 0手机认证 0户口认证 0视频认证 0学历认证 0征信认证 0淘宝认证 0历史成功借款次数 0历史成功借款金额 0总待还本金 0历史正常还款期数 0历史逾期还款期数 0我的投资金额 0当前到期期数 0当前还款期数 0已还本金 0已还利息 0待还本金 0待还利息 0标当前逾期天数 0标当前状态 0上次还款日期 1上次还款本金 1上次还款利息 1下次计划还款日期 30下次计划还款本金 30下次计划还款利息 30recorddate 0dtype: int64 计算缺失率 计算各列的缺失率： 1234# 计算各列的缺失率，并保留两位小数res = round((row.isnull().sum() / len(row) * 100), 2)row = pd.DataFrame(&#123;&#x27;列名&#x27;: res.index, &#x27;缺失值占比&#x27;: res.values&#125;)print(row) 1234567891011121314151617181920212223242526272829303132333435363738 列名 缺失值占比0 ListingId 0.01 借款金额 0.02 借款期限 0.03 借款利率 0.04 借款成功日期 0.05 初始评级 0.06 借款类型 0.07 是否首标 0.08 年龄 0.09 性别 0.010 手机认证 0.011 户口认证 0.012 视频认证 0.013 学历认证 0.014 征信认证 0.015 淘宝认证 0.016 历史成功借款次数 0.017 历史成功借款金额 0.018 总待还本金 0.019 历史正常还款期数 0.020 历史逾期还款期数 0.021 我的投资金额 0.022 当前到期期数 0.023 当前还款期数 0.024 已还本金 0.025 已还利息 0.026 待还本金 0.027 待还利息 0.028 标当前逾期天数 0.029 标当前状态 0.030 上次还款日期 2.031 上次还款本金 2.032 上次还款利息 2.033 下次计划还款日期 60.034 下次计划还款本金 60.035 下次计划还款利息 60.036 recorddate 0.0 计算总的缺失率： 12345678910# 假设df是已经加载的DataFramedf = pd.read_csv(&#x27;./LCIS.csv&#x27;) # 示例代码，根据实际路径加载# 计算至少含有一个空值的行数rows_with_na = df.isnull().any(axis=1).sum()# 计算总缺失率，这里的“总缺失”是指含有至少一个空值的行占总行数的比例total_missing_rate = round((rows_with_na / len(df) * 100), 2)print(f&quot;总缺失率: &#123;total_missing_rate&#125;%&quot;) 1总缺失率: 45.15% 删除含有空值的行或列使用 dropna() 方法可以根据不同的需求删除含有空值的行或列。 DataFrame.dropna 参数说明： axis: 控制删除含有缺失值的行或列。默认值为 0，意味着删除任何含有缺失值的行。如果设置为 1，则删除任何含有缺失值的列。 how: 定义了行或列被删除的条件。默认为 &#39;any&#39;，表示如果行或列中存在任何缺失值，就将其删除。如果设置为 &#39;all&#39;，则只有当行或列中的所有值都是缺失值时，才删除该行或列。 thresh: 指定一个行或列中非缺失值的最小数量，只有当非缺失值的数量达到这个阈值时，该行或列才会被保留。 subset: 用于指定一个列的子集来检查缺失值。这可以是单个列名，或者是多个列名组成的列表。只有在这个子集中检查到缺失值时，相应的行或列才会根据how参数的设置被删除。 inplace: 用于指定是否在原地修改DataFrame。如果设置为True，则原地修改DataFrame并返回None；如果设置为False（默认），则返回修改后的新DataFrame，原DataFrame不变。 删除含有任何空值的行： 1row.dropna(axis=0, inplace=True) 删除含有任何空值的列： 1row.dropna(axis=1, inplace=True) 填充空值在很多情况下，直接删除含有空值的数据可能会导致信息的大量丢失，特别是在数据量不是很大的情况下。此时，填充空值成为了一种更好的选择。 使用固定值填充所有空值： 12# 使用0填充所有空值row.fillna(0, inplace=True) 针对特定列使用不同的填充值： 12# 以1234填充&#x27;下次计划还款日期&#x27;列的空值row[&#x27;下次计划还款日期&#x27;].fillna(1234, inplace=True) 使用列的统计值（均值、中位数、众数）填充空值： 1234567891011# 使用均值填充mean_val = row[&#x27;下次计划还款利息&#x27;].mean()row[&#x27;下次计划还款利息&#x27;].fillna(mean_val, inplace=True)# 使用中位数填充median_val = row[&#x27;下次计划还款利息&#x27;].median()row[&#x27;下次计划还款利息&#x27;].fillna(median_val, inplace=True)# 使用众数填充（注意：众数可能返回多个值）mode_val = row[&#x27;下次计划还款利息&#x27;].mode()[0] # 选取第一个众数row[&#x27;下次计划还款利息&#x27;].fillna(mode_val, inplace=True) 错误数据清洗在数据处理和分析中，清洗数据是一项基础而重要的任务，用于修正或删除数据集中的错误或不一致的数据。Pandas 是一个强大的 Python 数据分析库，它提供了多种方法来清洗错误数据。 替换错误数据直接替换特定错误数据如果已知特定数据项错误，可以直接替换它。例如，如果我们知道某个人的年龄被错误地录入为12345，而正确的年龄应为30，可以直接修改这个值： 12345678910111213import pandas as pd# 创建DataFrameperson = &#123; &quot;name&quot;: [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;], &quot;age&quot;: [50, 40, 12345] # 12345 是错误的年龄数据&#125;df = pd.DataFrame(person)# 直接替换错误数据df.loc[2, &#x27;age&#x27;] = 30 # 将年龄12345改为30print(df) 基于条件的批量替换在某些情况下，我们可能需要根据条件批量替换数据。例如，将所有大于120岁的年龄替换为120岁： 123456789101112import pandas as pdperson = &#123; &quot;name&quot;: [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;], &quot;age&quot;: [50, 200, 12345] &#125;df = pd.DataFrame(person)# 条件替换df.loc[df[&#x27;age&#x27;] &gt; 120, &#x27;age&#x27;] = 120print(df) 删除错误数据有时，与其修正错误的数据，不如直接将其删除。例如，删除年龄大于120岁的记录： 123456789101112import pandas as pdperson = &#123; &quot;name&quot;: [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;], &quot;age&quot;: [50, 40, 12345] # 12345 是错误的年龄数据&#125;df = pd.DataFrame(person)# 删除错误数据df = df[df[&#x27;age&#x27;] &lt;= 120]print(df) 数据格式错误处理假设我们有一个包含日期和持续时间的数据集，但日期的格式不统一，这可能会导致分析时出现问题。以下是如何使用 Pandas 来解决这一问题的示例： 123456789101112131415import pandas as pd# 假设数据集中的日期格式不统一，第三个日期格式错误data = &#123; &quot;Date&quot;: [&#x27;2020/12/01&#x27;, &#x27;2020/12/02&#x27;, &#x27;20201226&#x27;], # 第三个日期格式与其他两个不同 &quot;Duration&quot;: [50, 40, 45]&#125;# 使用字典创建 DataFramedf = pd.DataFrame(data, index=[&quot;day1&quot;, &quot;day2&quot;, &quot;day3&quot;])# 将日期列的格式统一转换为 datetime 格式df[&#x27;Date&#x27;] = pd.to_datetime(df[&#x27;Date&#x27;], errors=&#x27;coerce&#x27;, format=&#x27;%Y/%m/%d&#x27;)print(df) 代码解析 导入 Pandas 库：首先，我们需要导入 Pandas 库，这是进行数据分析和数据清洗的基础。 创建 DataFrame：我们通过传递一个包含数据的字典（包括不一致的日期格式）来创建一个 DataFrame。这个 DataFrame 包括一个日期列和一个持续时间列。 转换日期格式：使用 pd.to_datetime() 方法将日期列转换为统一的 datetime 格式。这个方法非常强大，能够自动识别和转换多种日期格式。如果存在无法识别的格式，errors=&#39;coerce&#39; 参数会将这些无法转换的日期替换为 NaT (时间戳数据的缺失值)。format=&#39;%Y/%m/%d&#39; 参数是尝试按照这种格式解析日期，但不一定所有日期都能完全匹配此格式，故 errors=&#39;coerce&#39; 在这里起着兜底的作用。 扩展和改进 处理转换错误：在转换过程中，如果存在无法识别的日期格式，我们可以通过 errors=&#39;coerce&#39; 参数来处理这些错误，将它们转换为 NaT，然后根据需要进行进一步处理，比如填充缺失值或者删除包含缺失值的行。 格式化输出：在完成日期格式的统一后，我们还可以根据需要对日期进行格式化，比如将所有日期转换为特定的字符串格式。 其他数据清洗任务：除了解决日期格式问题外，数据清洗可能还包括诸如删除重复值、处理缺失值、数据类型转换等任务。Pandas 提供了丰富的函数和方法来处理这些问题，比如 drop_duplicates()、fillna() 或 replace() 方法。 数据统计和运算是数据分析的基础，它涉及到对数据集进行概括性描述和数学计算的过程。Pandas 是一个强大的 Python 数据分析库，提供了一系列方便的数据统计和运算工具，帮助我们快速对数据进行处理和分析。以下是一些使用 Pandas 进行数据统计和运算的常用方法及其应用示例。 数据统计和运算数据统计和运算是数据分析的基础，它涉及到对数据集进行概括性描述和数学计算的过程。Pandas 是一个强大的 Python 数据分析库，提供了一系列方便的数据统计和运算工具，帮助我们快速对数据进行处理和分析。以下是一些使用 Pandas 进行数据统计和运算的常用方法及其应用示例。 最大值和最小值：max() 和 min()12345678910111213import pandas as pd# 读取数据df = pd.read_csv(&quot;./LCIS.csv&quot;)# 获取&#x27;借款金额&#x27;列的最大值max_value = df[&#x27;借款金额&#x27;].max()# 获取&#x27;借款金额&#x27;列的最小值min_value = df[&#x27;借款金额&#x27;].min()print(&quot;最大借款金额:&quot;, max_value)print(&quot;最小借款金额:&quot;, min_value) 这段代码展示了如何读取一个 CSV 文件，并计算某一列（例如“借款金额”）的最大值和最小值。 非缺失值的数量：count()df.count(axis=0, level=None, numeric_only=False) axis：指定计算的方向，0 表示按列计算，1 表示按行计算，默认为 0。 level：用于 MultiIndex 的级别，在多层索引 DataFrame 中指定要计算的级别。 numeric_only：布尔值，表示是否只计算数值型列（int、float）的非缺失值，默认为 False，表示计算所有列的非缺失值数量。 123456789101112import pandas as pddf = pd.read_csv(&quot;./LCIS.csv&quot;)# 计算每列的非缺失值数量column_non_missing_count = df.count()# 计算每行的非缺失值数量row_non_missing_count = df.count(axis=1)print(column_non_missing_count)print(row_non_missing_count) 此代码展示了如何计算 DataFrame 中每列或每行的非缺失值（非 NaN 值）的数量。可以通过设置 axis 参数为 0（默认）计算每列的非缺失值数量，或设置为 1 计算每行的非缺失值数量。 求和与累加：sum() 和 cumsum()1234567# 求和total = df[&#x27;借款金额&#x27;].sum()print(&quot;借款金额总和:&quot;, total)# 累加df[&#x27;累计借款金额&#x27;] = df[&#x27;借款金额&#x27;].cumsum()print(df) 这部分代码用于计算特定列的总和（sum()）和累加值（cumsum()）。cumsum() 方法在原有数据的基础上添加了一个累加列，显示到当前行为止的累计总和。 排序：sort_values() 和 sort_index()按列值排序12345# 按照&#x27;借款金额&#x27;列的值进行升序排序df.sort_values(&#x27;借款金额&#x27;, inplace=True)# 根据&#x27;借款金额&#x27;进行升序排序，&#x27;年龄&#x27;进行降序排序df.sort_values([&#x27;借款金额&#x27;, &#x27;年龄&#x27;], ascending=[True, False], inplace=True) 这些例子展示了如何按照一个或多个列的值对 DataFrame 进行排序。可以通过 ascending 参数控制排序的方向（升序或降序）。 按索引排序12# 按照索引进行排序df.sort_index(inplace=True) 如果需要根据行索引进行排序，可以使用 sort_index() 方法。这在重置数据顺序时特别有用。 扩展 计算缺失值：利用 count() 方法的结果可以间接计算出某列或整个 DataFrame 的缺失值数量。例如，DataFrame 总行数减去 count() 方法返回的非缺失值数量即为缺失值数量。 设置列名：当从函数返回一个 Series 或需要更改 DataFrame 的列名时，可以直接通过修改 columns 属性或者在创建 DataFrame 时指定列名。 读取部分数据：对于大型数据集，可以使用 pd.read_csv() 函数的 nrows 参数仅读取前 N 行数据，有助于快速测试代码或减少内存消耗。 数据分组和聚合df.groupby(column_name)groupby() 方法是用来对数据进行分组的，特别是当你想要按照某个（或某些）列的值对整个数据集进行分组时。分组后，可以对每个分组应用聚合函数，比如求和、平均、最大值和最小值等。 1234567891011121314151617181920212223# 按照&#x27;年龄&#x27;列分组，并计算每个年龄组的数量age_group_count = df.groupby(&#x27;年龄&#x27;).count()print(age_group_count)# 只统计不同年龄组的&#x27;借款金额&#x27;总和age_group_loan_sum = df.groupby(&#x27;年龄&#x27;)[&#x27;借款金额&#x27;].sum()print(age_group_loan_sum)# 计算每个年龄组的&#x27;借款金额&#x27;的最大值、最小值和平均值age_group_loan_max = df.groupby(&#x27;年龄&#x27;)[&#x27;借款金额&#x27;].max()age_group_loan_min = df.groupby(&#x27;年龄&#x27;)[&#x27;借款金额&#x27;].min()age_group_loan_mean = df.groupby(&#x27;年龄&#x27;)[&#x27;借款金额&#x27;].mean()print(age_group_loan_max)print(age_group_loan_min)print(age_group_loan_mean)# 按照&#x27;性别&#x27;分组，并计算&#x27;借款金额&#x27;的最大值、最小值和平均值gender_group_loan_max = df.groupby(&#x27;性别&#x27;)[&#x27;借款金额&#x27;].max()gender_group_loan_min = df.groupby(&#x27;性别&#x27;)[&#x27;借款金额&#x27;].min()gender_group_loan_mean = df.groupby(&#x27;性别&#x27;)[&#x27;借款金额&#x27;].mean()print(gender_group_loan_max)print(gender_group_loan_min)print(gender_group_loan_mean) df.aggregate(function_name)aggregate() 方法允许你对整个 DataFrame 或某些选定的列应用一个或多个聚合函数。 1234567# 对整个 DataFrame 应用多个聚合函数agg_results = df.aggregate([&#x27;sum&#x27;, &#x27;mean&#x27;])print(agg_results) # 可能会报错，因为字符类型的列不能进行数学计算# 对指定列应用聚合函数agg_specific = df.aggregate(&#123;&#x27;借款金额&#x27;: &#x27;sum&#x27;, &#x27;年龄&#x27;: &#x27;mean&#x27;&#125;)print(agg_specific) 如果数据集中包含非数值类型（如字符串），直接应用 sum 或 mean 会导致错误。为了避免这种情况，你应该指定要应用聚合函数的列，或者通过 numeric_only=True 参数来排除非数值列。 df.pivot_table(values, index, columns, aggfunc)pivot_table() 方法是用来创建透视表的，这在你想要对数据进行多维度的分组聚合时特别有用。 123# 创建透视表，将&#x27;性别&#x27;作为索引，对&#x27;借款金额&#x27;进行求和gender_loan_pivot_table = df.pivot_table(values=&#x27;借款金额&#x27;, index=&#x27;性别&#x27;, aggfunc=&#x27;sum&#x27;)print(gender_loan_pivot_table) 在透视表中，values 参数是你想要聚合的列，index 参数是你想要作为行索引的列，columns 参数（可选）是你想要作为列索引的列，aggfunc 是定义聚合函数的参数。 这些方法不仅可以帮助你从数据集中提取有意义的统计信息，还可以根据你的特定需求进行高度定制化的数据处理和分析。通过使用这些工具，你可以轻松地对数据进行分组和聚合，从而提取出关键的洞见。 案例数据导入与演示123456789import pandas as pddf = pd.read_csv(&#x27;./LCIS.csv&#x27;) # 显示所有的数据# pd.set_option(&#x27;display.max_rows&#x27;, None) # 显示所有行pd.set_option(&#x27;display.max_columns&#x27;, None) # 显示所有列# pd.set_option(&#x27;expand_frame_repr&#x27;, False) # 不自动换行print(df) ListingId 借款金额 借款期限 借款利率 借款成功日期 初始评级 借款类型 是否首标 年龄 性别 手机认证 \\ 0 1693100 3629 6 12.0 2015/1/28 AA 普通 否 31 男 成功认证 1 1713229 3000 12 12.0 2015/1/30 AA 普通 是 24 男 成功认证 2 1904026 3629 12 12.0 2015/3/7 AA 普通 否 27 男 成功认证 3 2158281 3919 12 18.0 2015/4/14 C 普通 否 28 男 成功认证 4 2257194 14000 12 18.0 2015/4/23 C 普通 否 46 男 成功认证 ... ... ... ... ... ... ... ... ... .. .. ... 292534 29087298 7193 12 22.0 2016/12/29 C 普通 否 48 男 成功认证 292535 29995173 3241 12 22.0 2017/1/5 C 其他 否 25 女 成功认证 292536 30355195 3004 12 22.0 2017/1/8 C 其他 否 28 男 未成功认证 292537 30649717 2082 12 22.0 2017/1/11 C 普通 否 52 男 成功认证 292538 31620657 10000 12 22.0 2017/1/20 D 普通 是 24 女 未成功认证 户口认证 视频认证 学历认证 征信认证 淘宝认证 历史成功借款次数 历史成功借款金额 总待还本金 \\ 0 未成功认证 未成功认证 未成功认证 未成功认证 未成功认证 1.0 3000.0 1313.46 1 未成功认证 未成功认证 未成功认证 未成功认证 未成功认证 0.0 0.0 0.00 2 未成功认证 未成功认证 未成功认证 未成功认证 未成功认证 1.0 3000.0 878.58 3 成功认证 未成功认证 未成功认证 未成功认证 未成功认证 4.0 13800.0 6523.11 4 未成功认证 未成功认证 未成功认证 未成功认证 未成功认证 11.0 54840.0 11491.04 ... ... ... ... ... ... ... ... ... 292534 未成功认证 未成功认证 未成功认证 未成功认证 未成功认证 1.0 3500.0 306.54 292535 未成功认证 未成功认证 成功认证 未成功认证 未成功认证 1.0 5000.0 1758.28 292536 未成功认证 未成功认证 未成功认证 未成功认证 未成功认证 1.0 2200.0 1495.67 292537 未成功认证 未成功认证 未成功认证 未成功认证 未成功认证 6.0 22064.0 5747.77 292538 未成功认证 未成功认证 成功认证 未成功认证 未成功认证 0.0 0.0 0.00 历史正常还款期数 历史逾期还款期数 我的投资金额 当前到期期数 当前还款期数 已还本金 已还利息 待还本金 \\ 0 2 2 200 6 6 200.00 7.00 0.00 1 0 0 500 12 9 500.00 29.80 0.00 2 5 0 500 12 12 500.00 33.04 0.00 3 25 0 100 12 2 100.00 1.72 0.00 4 53 0 100 12 0 0.00 0.00 100.00 ... ... ... ... ... ... ... ... ... 292534 11 0 55 2 2 8.35 1.94 46.65 292535 3 3 50 1 1 3.76 0.91 46.24 292536 4 0 50 1 1 3.76 0.91 46.24 292537 39 6 55 1 1 4.13 1.01 50.87 292538 0 0 73 1 1 5.49 1.34 67.51 待还利息 标当前逾期天数 标当前状态 上次还款日期 上次还款本金 上次还款利息 下次计划还款日期 下次计划还款本金 \\ 0 0.00 0 已还清 2015/7/28 34.20 0.30 NaN NaN 1 0.00 0 已还清 2015/10/19 173.39 1.05 NaN NaN 2 0.00 0 已还清 2016/3/6 44.04 0.38 NaN NaN 3 0.00 0 已还清 2015/5/19 92.34 0.22 NaN NaN 4 9.92 589 逾期中 NaN NaN NaN 2015/5/23 7.66 ... ... ... ... ... ... ... ... ... 292534 4.83 0 正常还款中 2017/2/26 4.22 0.93 2017/3/28 4.29 292535 5.24 0 正常还款中 2017/2/9 3.76 0.91 2017/3/5 3.83 292536 5.24 0 正常还款中 2017/2/8 3.76 0.91 2017/3/8 3.83 292537 5.76 0 正常还款中 2017/2/10 4.13 1.01 2017/3/10 4.22 292538 7.64 0 正常还款中 2017/2/20 5.49 1.34 2017/3/20 5.59 下次计划还款利息 recorddate 0 NaN 2016/12/31 1 NaN 2016/12/31 2 NaN 2016/12/31 3 NaN 2016/12/31 4 1.50 2016/12/31 ... ... ... 292534 0.86 2017/2/28 292535 0.85 2017/2/28 292536 0.85 2017/2/28 292537 0.93 2017/2/28 292538 1.24 2017/2/28 [292539 rows x 37 columns] 总缺失率1234567# 计算至少含有一个空值的行数rows_with_na = df.isnull().any(axis=1).sum()# 计算总缺失率，这里的“总缺失”是指含有至少一个空值的行占总行数的比例total_missing_rate = round((rows_with_na / len(df) * 100), 2)print(f&quot;总缺失率: &#123;total_missing_rate&#125;%&quot;) 总缺失率: 45.15% 手机认证用户借贷笔数1234# 手机认证借贷笔数 loan_phone = df[df[&#x27;手机认证&#x27;] == &#x27;成功认证&#x27;].shape[0]print(loan_phone) 153453 户门认证用户借贷情况12345678910111213141516171819# 筛选户口认证为“成功认证”的用户df_hukou_success = df[df[&#x27;户口认证&#x27;] == &#x27;成功认证&#x27;]# 计算平均借款金额avg_loan_amount_hukou_success = df_hukou_success[&#x27;借款金额&#x27;].mean()# 计算平均借款期限avg_loan_duration_hukou_success = df_hukou_success[&#x27;借款期限&#x27;].mean()# 计算平均借款利率avg_interest_rate_hukou_success = df_hukou_success[&#x27;借款利率&#x27;].mean()# 计算平均年龄avg_age_hukou_success = df_hukou_success[&#x27;年龄&#x27;].mean()print(f&quot;户口认证成功的用户平均借款金额: &#123;avg_loan_amount_hukou_success:.2f&#125;&quot;)print(f&quot;户口认证成功的用户平均借款期限: &#123;avg_loan_duration_hukou_success:.2f&#125; 个月&quot;)print(f&quot;户口认证成功的用户平均借款利率: &#123;avg_interest_rate_hukou_success:.2f&#125;%&quot;)print(f&quot;户口认证成功的用户平均年龄: &#123;avg_age_hukou_success:.2f&#125; 岁&quot;) 户口认证成功的用户平均借款金额: 36955.01 户口认证成功的用户平均借款期限: 10.04 个月 户口认证成功的用户平均借款利率: 17.15% 户口认证成功的用户平均年龄: 31.42 岁 征信认证用户借贷情况12345678910111213141516171819# 筛选出征信认证为成功认证的行df_credit_approved = df[df[&#x27;征信认证&#x27;] == &#x27;成功认证&#x27;]# 计算平均借款金额avg_loan_amount_credit_approved = df_credit_approved[&#x27;借款金额&#x27;].mean()# 计算平均借款期限avg_loan_duration_credit_approved = df_credit_approved[&#x27;借款期限&#x27;].mean()# 计算平均借款利率avg_interest_rate_credit_approved = df_credit_approved[&#x27;借款利率&#x27;].mean()# 计算平均年龄avg_age_credit_approved = df_credit_approved[&#x27;年龄&#x27;].mean()print(f&quot;征信认证成功的用户平均借款金额: &#123;avg_loan_amount_credit_approved:.2f&#125;&quot;)print(f&quot;征信认证成功的用户平均借款期限: &#123;avg_loan_duration_credit_approved:.2f&#125; 个月&quot;)print(f&quot;征信认证成功的用户平均借款利率: &#123;avg_interest_rate_credit_approved:.2f&#125;%&quot;)print(f&quot;征信认证成功的用户平均年龄: &#123;avg_age_credit_approved:.2f&#125; 岁&quot;) 征信认证成功的用户平均借款金额: 9138.00 征信认证成功的用户平均借款期限: 10.59 个月 征信认证成功的用户平均借款利率: 18.27% 征信认证成功的用户平均年龄: 29.79 岁 性别认证用户还款情况123456789101112131415# 确保性别列存在并且不为空df_with_gender = df[df[&#x27;性别&#x27;].notna()]# 按性别分组，并计算各项指标的平均值repayment_status = df_with_gender.groupby(&#x27;性别&#x27;).agg(&#123; &#x27;借款金额&#x27;: &#x27;mean&#x27;, &#x27;历史成功借款次数&#x27;: &#x27;mean&#x27;, &#x27;历史逾期还款期数&#x27;: &#x27;mean&#x27;, &#x27;总待还本金&#x27;: &#x27;mean&#x27;&#125;).reset_index()# 重命名列以更清晰地表示它们的内容repayment_status.columns = [&#x27;性别&#x27;, &#x27;平均借款金额&#x27;, &#x27;平均历史成功借款次数&#x27;, &#x27;平均历史逾期还款期数&#x27;, &#x27;平均待还本金&#x27;]print(repayment_status) 性别 平均借款金额 平均历史成功借款次数 平均历史逾期还款期数 平均待还本金 0 女 6896.238214 2.651062 17.975806 4706.631430 1 男 9385.546621 2.547655 18.575870 4388.516472 不同性别用户还款占比情况123456789101112131415# 定义正常还款状态normal_repayment_statuses = [&#x27;已还清&#x27;, &#x27;正常还款中&#x27;]df_per_gender = df# 创建一个新列，用于标记是否正常还款df_per_gender[&#x27;是否正常还款&#x27;] = df_per_gender[&#x27;标当前状态&#x27;].apply(lambda x: &#x27;正常还款&#x27; if x in normal_repayment_statuses else &#x27;未还清&#x27;)# 计算每个性别的还款占比repayment_by_gender = df_per_gender.groupby(&#x27;性别&#x27;)[&#x27;是否正常还款&#x27;].value_counts(normalize=True).unstack().fillna(0)# 将占比转换为百分比repayment_by_gender_percentage = repayment_by_gender * 100print(repayment_by_gender_percentage) 是否正常还款 未还清 正常还款 性别 女 3.216114 96.783886 男 3.948184 96.051816 学历认证用户还款情况123456789101112131415df_sty_auth = df[df[&#x27;学历认证&#x27;] == &#x27;成功认证&#x27;]# 分析学历认证用户的还款情况# 计算历史正常还款期数和历史逾期还款期数的平均值avg_normal_re = df_sty_auth[&#x27;历史正常还款期数&#x27;].mean()avg_dishor_re = df_sty_auth[&#x27;历史逾期还款期数&#x27;].mean()# 计算已还本金、已还利息的总和org_done_total = df_sty_auth[&#x27;已还本金&#x27;].sum()fee_done_total = df_sty_auth[&#x27;已还利息&#x27;].sum()print(f&quot;学历认证用户平均历史正常还款期数: &#123;avg_normal_re&#125;&quot;)print(f&quot;学历认证用户平均历史逾期还款期数: &#123;avg_dishor_re&#125;&quot;)print(f&quot;学历认证用户总已还本金: &#123;org_done_total&#125;&quot;)print(f&quot;学历认证用户总已还利息: &#123;fee_done_total&#125;&quot;) 学历认证用户平均历史正常还款期数: 78.98516016370341 学历认证用户平均历史逾期还款期数: 13.045753352616355 学历认证用户总已还本金: 6445238.179999999 学历认证用户总已还利息: 499930.52000000014 学历认证用户还款占比情况1234567891011121314# 筛选学历认证成功的用户df_education_certified = df[df[&#x27;学历认证&#x27;] == &#x27;成功认证&#x27;]# 计算各状态下的用户数量status_counts = df_education_certified[&#x27;标当前状态&#x27;].value_counts()# 计算总数，用于计算比例total_certified = df_education_certified.shape[0]# 计算占比status_proportions = status_counts / total_certified# 打印结果print(status_proportions) 标当前状态 正常还款中 0.692517 已还清 0.279435 逾期中 0.027097 0 0.000620 0.7 0.000040 2.35 0.000020 0.62 0.000013 5.76 0.000013 1.16 0.000013 1.07 0.000013 4.73 0.000007 1.33 0.000007 0.2 0.000007 2.82 0.000007 0.4 0.000007 0.34 0.000007 2.95 0.000007 3.15 0.000007 2.6 0.000007 2.66 0.000007 5.5 0.000007 2.65 0.000007 0.11 0.000007 5.81 0.000007 1.17 0.000007 1.74 0.000007 0.77 0.000007 4.92 0.000007 2.46 0.000007 0.38 0.000007 6.47 0.000007 1.78 0.000007 0.76 0.000007 3.42 0.000007 0.13 0.000007 1.51 0.000007 0.73 0.000007 0.48 0.000007 3.76 0.000007 4.83 0.000007 0.49 0.000007 3.39 0.000007 Name: count, dtype: float64 不同年龄段用户借款统计12345678910111213141516# 定义年龄段bins = [18, 25, 35, 45, 55, 65, 75]labels = [&#x27;18-24&#x27;, &#x27;25-34&#x27;, &#x27;35-44&#x27;, &#x27;45-54&#x27;, &#x27;55-64&#x27;, &#x27;65-74&#x27;]age_df = dfage_df[&#x27;年龄段&#x27;] = pd.cut(age_df[&#x27;年龄&#x27;], bins=bins, labels=labels, right=False)# 计算每个年龄段的借款统计age_group_stats = df.groupby(&#x27;年龄段&#x27;).agg(&#123; &#x27;借款金额&#x27;: [&#x27;sum&#x27;, &#x27;mean&#x27;, &#x27;count&#x27;]&#125;)age_group_stats.columns = [&#x27;借款金额总和&#x27;, &#x27;平均借款金额&#x27;, &#x27;借款次数&#x27;]age_group_stats = age_group_stats.reset_index()# 显示结果print(age_group_stats) 年龄段 借款金额总和 平均借款金额 借款次数 0 18-24 296139563 4755.963239 62267 1 25-34 1554537910 8642.275290 179876 2 35-44 527141564 12732.272934 41402 3 45-54 106455104 12088.928458 8806 4 55-64 4524174 24722.262295 183 5 65-74 2500000 500000.000000 5 不同年龄段用户还款占比统计1234567891011121314151617181920# 添加年龄段分类bins = [0, 24, 34, 44, 54, 100]labels = [&#x27;&lt;25&#x27;, &#x27;25-34&#x27;, &#x27;35-44&#x27;, &#x27;45-54&#x27;, &#x27;55+&#x27;]age_per_df = dfage_per_df[&#x27;年龄段&#x27;] = pd.cut(age_per_df[&#x27;年龄&#x27;], bins=bins, labels=labels, right=False)# 计算每个年龄段的已还本金总额repayment_by_age_group = df.groupby(&#x27;年龄段&#x27;)[&#x27;已还本金&#x27;].sum()# 计算总的已还本金以确定占比total_repayment = df[&#x27;已还本金&#x27;].sum()# 计算占比repayment_ratio = (repayment_by_age_group / total_repayment * 100).reset_index()# 设置新的列名以改进展示repayment_ratio.columns = [&#x27;年龄段&#x27;, &#x27;已还本金占比（%）&#x27;]# 输出结果print(repayment_ratio) 年龄段 已还本金占比（%） 0 &lt;25 14.278337 1 25-34 62.234454 2 35-44 18.792848 3 45-54 4.536181 4 55+ 0.158180 数据分析常用函数数据筛选如果是筛选行列的话，通常有以下几种方法：有时我们需要按条件选择部分列、部分行，一般常用的方法有： 操作 语法 返回结果 选择列 df[col] Series 按索引选择行 df.loc[label] Series 按数字索引选择行 df.iloc[loc] Series 使用切片选择行 df[:5] DataFrame 用表达式筛选行[3] df[bool_vec] DataFrame 除此以外，还有很多方法&#x2F;函数可以用于“数据筛选” 数据预览对于探索性数据分析来说，做数据分析前需要先看一下数据的总体概况。 info()方法用来查看数据集信息 describe()方法将返回描述性统计信息，这两个函数大家应该都很熟悉了。 describe方法默认只给出数值型变量的常用统计量，要想对DataFrame中的每个变量进行汇总统计，可以将其中的参数include设为all。head()方法显示数据集的前n行 tail() 方法显示数据集的后n行。 sample()方法随机看N行的数据。 1df.sample(3) df.dtypes 检查数据中各列的数据类型。 df.columns 查看所有的列名 。 12df.dtypesdf.columns 1Index([&#x27;日期&#x27;, &#x27;销量&#x27;], dtype=&#x27;object&#x27;) .dfshape() 获得数据集的大小（长宽）。 1df.shape 1(5, 2) len(df)可以查看总个数 df.count()则可以查看有效个数，不包含无效值（Nan） 缺失值与重复值Pandas清洗数据时，判断缺失值一般采用isnull()方法。isnull().any()会判断哪些”列”存在缺失值。isnull().sum()用于将列中为空的个数统计出来。 1df.isnull().any() 123日期 False销量 Truedtype: bool 发现“销量”这列存在缺失值后，处理办法要么删除dropna() ，要么填充fillna()。 1df.fillna(50) Pandas清洗数据时，判断重复值一般采用duplicated()方法。 如果想要直接删除重复值，可以使用drop_duplicates() 方法。 数据值操作在数值数据操作中，apply()函数的功能是将一个自定义函数作用于DataFrame的行或者列；applymap()函数的功能是将自定义函数作用于DataFrame的所有元素。 1df[&quot;数量&quot;].apply(lambda x: x+1) 数据批量替换的情况，replace()是很好的解决方法。它既支持替换全部或者某一行，也支持替换指定的某个或指定的多个数值（用字典的形式）。还可以使用正则表达式替换。 1df[&quot;编号&quot;].replace(r&#x27;BA.$&#x27;, value=&#x27;NEW&#x27;, regex=True, inplace = True) 调⽤rank()⽅法可以实现数据排名。 1df[&quot;排名&quot;] = df.rank(method=&quot;dense&quot;).astype(&quot;int&quot;) rank()⽅法中的method参数，它有5个常⽤选项，可以帮助我们实现不同情况下的排名。 唯一值，unique()是以数组形式返回列的所有唯一值，而nunique()返回的是唯一值的个数。 12df[&quot;gender&quot;].unique()df[&quot;gender&quot;].nunique() clip()方法，用于对超过或者低于某些数的数值进行截断[1]，来保证数值在一定范围。比如每月的迟到天数一定是在0-31天之间。 1df[&quot;迟到天数&quot;] = df[&quot;迟到天数&quot;].clip(0,31) 行&#x2F;列操作rename()重命名用于更改行列的标签，即行列的索引。可以传入一个字典或者一个函数。在数据预处理中，比较常用。 1df.rename(columns=&#123;&#x27;mark&#x27;: &#x27;sell&#x27;&#125;, inplace=True) 数据清洗时，会将带空值的行删除，此时DataFrame或Series类型的数据不再是连续的索引，可以使用reset_index()重置索引。 1df.reset_index(drop=True) 删除行列，可以使用drop()。 1df.drop(columns=[&quot;mark&quot;]) 行列转置，我们可以使用T属性获得转置后的DataFrame。 1df.T melt()方法可以将宽表转长表，即表格型数据转为树形数据。 1df.melt(id_vars=&quot;姓名&quot;, var_name=&quot;科目&quot;, value_name=&quot;成绩&quot;) pivot()方法可以将长表转宽表，即树形数据转为表格型数据。 1df.pivot(index=&#x27;姓名&#x27;, columns=&#x27;科目&#x27;, values=&#x27;成绩&#x27;) 数据分组与数据透视表更是一个常见的需求，groupby()方法可以用于数据分组。 1df.groupby(&quot;科目&quot;).mean() pivot_table()数据透视表 数值数据统计运算在对数值型的数据进行统计运算时，除了有算术运算、比较预算还有各种常见的汇总统计运行函数，具体如下表所示 函数方法 用法释义 count 非NaN数据项计数 sum 求和 mean 平均值 median 中位数 mode 众数 max 最大值 min 最小值 std 标准差 var 方差 quantile 分位数 skew 返回偏态系数 kurt 返回峰态系数 累加cumsum()。 1df[&quot;累计销量&quot;] = df[&quot;销量&quot;].cumsum() 文本数据操作在对文本型的数据进行处理时，我们会大量应用字符串的函数，来实现对一列文本数据进行操作。 函数方法 用法释义 cat 字符串的拼接 contains 判断某个字符串是否包含给定字符 startswith&#x2F;endswith 判断某个字符串是否以…开头&#x2F;结尾 get 获取指定位置的字符串 len 计算字符串长度 upper、lower 英文大小写转换 pad&#x2F;center 在字符串的左边、右边或左右两边添加给定字符 repeat 重复字符串几次 slice_replace 使用给定的字符串，替换指定的位置的字符 split 分割字符串，将一列扩展为多列 strip、rstrip、lstrip 去除空白符、换行符 findall 利用正则表达式，去字符串中匹配，返回查找结果的列表 extract、extractall 接受正则表达式，抽取匹配的字符串(一定要加上括号)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"Pandas","slug":"Pandas","permalink":"https://www.yiuhangblog.com/tags/Pandas/"}],"author":"Yiuhang Chan"},{"title":"NumPy","slug":"20181022NumPy","date":"2018-10-22T08:02:56.000Z","updated":"2024-02-28T10:49:26.000Z","comments":true,"path":"2018/10/22/20181022NumPy/","permalink":"https://www.yiuhangblog.com/2018/10/22/20181022NumPy/","excerpt":"Python NumPy包","text":"NumPy简介NumPy（Numerical Python）是一个开源的Python库，它提供了高性能的多维数组对象和一系列用于处理这些数组的函数。这使得NumPy成为执行许多科学计算和数据分析任务的基础库之一。NumPy的核心功能是围绕着一个强大的N维数组对象ndarray展开的，这个对象允许进行高效的数组计算。此外，NumPy还包括： 广播功能函数，它支持不同大小数组之间的运算。 整合C&#x2F;C++&#x2F;Fortran代码的工具，这些底层算法的设计初衷就是要提供优异的性能，使NumPy在执行数值计算时比纯Python代码高效得多。 线性代数、傅里叶变换、随机数生成等功能，这些是执行科学计算的常用工具。 NumPy的主要对象是同种元素的多维数组。这是一个表格，所有元素类型相同，每个元素都通过一个正整数元组进行索引。在NumPy中，数组的维度称为“轴”，轴的数量称为“秩”。 更专业地补充，NumPy的设计哲学强调数组的重要性，它通过以下特点体现了这一点： 内存效率：NumPy的数组对象直接映射到内存中，减少了Python解释器的开销，提高了数据处理的效率。 广播机制：这是一种强大的功能，允许NumPy在执行数组运算时自动扩展维度，简化了代码的复杂度，提高了开发效率。 矢量化操作：NumPy允许用户对数组进行批量操作而无需编写循环语句，这不仅使代码更简洁，也利用了底层优化，提升了性能。 底层语言接口：NumPy提供了API，使得在C、C++或Fortran编写的代码可以轻松集成进Python程序中，进一步提升了执行效率。 科学计算工具集成：NumPy是许多高级科学计算库（如SciPy、Pandas、Matplotlib）的基石，为复杂的数据处理和分析提供了强大的支持。 以上特性使NumPy成为科学计算、数据分析、机器学习等领域不可或缺的工具，它的高效、灵活和易于使用的特性，为Python在科学计算领域的流行提供了坚实的基础。 导入NumPy库import numpy as np 读取文件NumPy库提供了多种方法来读取数据，其中np.loadtxt是一种非常高效且简便的方式，特别适合于读取CSV（逗号分隔值）文件。这个函数允许用户定制化地读取数据，通过指定函数参数来适应不同格式的数据文件。下面是对np.loadtxt方法参数的进一步解释和扩展，以提供更全面的理解： path: 这是一个必需的参数，用于指定要读取的文件的路径。这个路径可以是相对路径或绝对路径。相对路径是相对于当前工作目录的路径，而绝对路径是从根目录开始的完整路径。例如，&#39;./data/myfile.csv&#39;是一个相对路径，它指向当前目录下的data文件夹中的myfile.csv文件。 delimiter: 用于指定文件中用于分隔数据列的字符。在CSV文件中，最常见的分隔符是逗号(&#39;,&#39;)，但有时也可能使用制表符(&#39;\\t&#39;)、空格或其他字符。正确指定分隔符是确保数据正确读取的关键。 skiprows: 该参数允许用户指定在开始读取数据之前应跳过的行数。这对于忽略文件头部的标题行或注释行非常有用。例如，skiprows=1会跳过文件的第一行。 dtype: 默认情况下，np.loadtxt尝试将读取的数据转换为浮点数。但是，如果数据集中包含非数值数据（如字符串或日期），则需要通过dtype参数指定数据类型。例如，dtype=&#39;str&#39;会将所有数据读取为字符串类型。 encoding: 当处理非英文字符的文件时，指定正确的文件编码是必要的，以防止编码错误。encoding=&#39;utf-8&#39;是一个常见的选项，适用于包含UTF-8编码字符的文件。 信息 进阶用法和注意事项： 处理非数值数据: 除了dtype参数，NumPy提供了converters参数，允许对特定列应用转换函数，以处理文件中的非标准数据，如将日期字符串转换为日期对象。 读取部分列: 使用usecols参数可以指定一个列索引列表，只读取感兴趣的列，提高读取效率。 内存管理: 对于大型文件，np.loadtxt可能会消耗大量内存。在这种情况下，考虑使用np.genfromtxt，它提供了更灵活的数据加载机制，包括处理缺失值。 Excel文件: 正如笔记中提到的，NumPy不能直接读取Excel（.xlsx）文件。需要先将Excel文件转换为CSV格式或使用专门的库（如pandas）来读取Excel文件。 1234567891011import numpy as np# path = &#x27;./工作/8.Advertising.csv&#x27;# numpy读入df = np.loadtxt(&#x27;./LC.csv&#x27;, delimiter=&#x27;,&#x27;,skiprows=1,dtype=&#x27;str&#x27;,encoding=&#x27;utf-8&#x27;)print(df)# 那我们是不是可以直接把括号里面的path直接换成路径呢？# 其次注意numpy不能直接读取excel文件，就是xlsx后缀的文件，得先将文件存储为csv文件 创建数组NumPy的array()函数是创建数组的基础工具，它允许从多种数据结构（如列表、元组、数组、生成器等）创建数组。此功能的强大之处在于它提供了一种高效的方式来存储和操作大量数据，这是NumPy库核心功能之一。 NumPy数组可以包含多种数据类型（dtype），如int（整数）、float（浮点数）、str（字符串）等。在创建数组时，可以通过dtype参数显式指定数组的数据类型，这对于优化内存使用和提高计算效率至关重要。 创建一维数组 直接从列表或元组创建：通过传递一个列表或元组给np.array()函数，可以创建一个一维数组。数组的数据类型会根据列表或元组中的元素自动确定，但也可以通过dtype参数显式指定。array()函数创建，括号内可以是列表、元祖、数组、生成器等 123import numpy as npa = np.array([1, 2, 3])print(a) 输出的数组a是一个一维数组，包含了三个整数元素。 使用数组属性： a.ndim：显示数组的维数。对于一维数组，此属性值为1。 a.shape：返回一个表示数组形状的元组，对于一维数组，形状会显示为(n,)，其中n是数组中元素的数量。 a.size：表示数组中元素的总数。 a.dtype：显示数组元素的数据类型，例如int64。 a.itemsize：数组中每个元素的字节大小。 a.data：指向数组数据的内存缓冲区。 创建数组的其他方式 直接传入列表的方式 123a= np.array([1,2,3,4])print(a)print(type(a)) 通过range生成序列： 12b = np.array(range(5))print(b) 这会创建一个包含0到4的整数的一维数组。 使用np.linspace()生成等间距数值： np.linspace()函数用于在指定的区间内生成等间隔的数值。它接受起始值、终止值和数值数量作为输入，并生成一个一维数组。如果endpoint参数设置为True（默认值），则包含终止值；如果为False，则不包含。 参数解释： start：序列的起始值。 stop：序列的结束值。 num：生成的样本数，默认为 50。 endpoint：如果为 True（默认），则包括停止值；如果为 False，则不包括停止值。 retstep：如果为 True，则返回 (samples, step)，其中 step 是样本之间的间距。 dtype：输出数组的数据类型。 axis：生成数组的轴。 123numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)arr = np.linspace(0, 10, 5)print(arr) 这将在0到10之间均匀分布生成5个数值的数组。 信息 高级创建数组方法除了上述方法，NumPy还提供了其他函数来创建特殊数组： **np.zeros()**：创建一个所有元素都为0的数组。 **np.ones()**：创建一个所有元素都为1的数组。 **np.empty()**：创建一个未初始化的数组，其元素值不确定。 **np.arange()**：类似于Python的range，但返回的是数组。 **np.full()**：创建一个所有元素都设定为指定值的数组。 创建二维数组列表嵌套转换为ndarray使用numpy库可以方便地将嵌套列表转换为二维数组。这是一种常见的创建二维数组的方法，适用于已经有一个列表数据结构，希望将其转换为numpy的ndarray格式进行更高效的数值计算。 12345678910import numpy as np# 创建列表lst = [[1, 2], [3, 4], [5, 6]]# 转换为numpy的二维数组num1 = np.array(lst)# 打印二维数组print(num1) 使用元组创建浮点型二维数组通过将元组传递给np.array()函数，可以直接创建二维数组。如果元组中包含浮点数，则数组的数据类型会自动适应为浮点型，这对于需要进行浮点数计算的场景非常有用。 12345# 使用元组创建，并指定为浮点型num2 = np.array([(1.5, 2, 3), (4, 5, 6)])# 打印二维数组print(num2) 各种类型的数组创建Numpy提供了灵活的方式来创建数组，这些方法可以满足不同场景的需求。 使用np.array()创建一维数组： 从range()创建数组 直接传递单个数值创建零维数组（标量） 传递列表创建一维数组 传递嵌套列表创建二维数组 1234567891011import numpy as npar1 = np.array(range(10))ar2 = np.array(10)ar3 = np.array([1, 2, 3, 4, 5])ar4 = np.array([[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]])print(ar1)print(ar2)print(ar3)print(ar4) 使用np.arange()创建数组： np.arange()是一个非常有用的函数，它在指定的间隔内返回等间隔的值。它类似于Python内置的range()函数，但np.arange()可以生成浮点数序列，并且可以直接用于创建numpy数组。 12345print(np.arange(10)) # 整型，0到9print(np.arange(10.0)) # 浮点型，0.0到9.0print(np.arange(5, 15)) # 5到14print(np.arange(5.0, 12.0, 2)) # 5.0到11.0，步长为2print(np.arange(100000000)) # 大数组，numpy自动优化显示 数组的数据类型在创建数组时，numpy会根据提供的数据自动确定数组的数据类型，但也可以通过dtype参数显式指定数据类型。这对于需要控制数据存储和计算精度的应用场景非常重要。 12345678# 创建整型数组arr_int = np.array([1, 2, 3], dtype=np.int32)# 创建浮点型数组arr_float = np.array([1, 2, 3], dtype=np.float64)print(arr_int.dtype)print(arr_float.dtype) 三维数组在NumPy中是一种非常有用的数据结构，它可以被视为一个由多个二维数组（矩阵）组成的数据立方体。这种结构非常适合表示多维数据集，比如时间序列数据、空间数据或多通道图像数据（例如彩色图像的RGB通道）。 创建三维数组三维数组的创建可以通过直接传递一个三层嵌套的列表（或元组）给np.array()函数，也可以使用特定的NumPy函数如np.zeros(), np.ones(), np.empty(), 或np.random.rand()等，来创建具有特定形状的三维数组。 通过列表创建三维数组12345678import numpy as np# 创建一个三维数组# 这里可以看成是由3个2x2的矩阵组成lst_3d = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]]arr_3d = np.array(lst_3d)print(arr_3d) 使用NumPy函数创建三维数组123456789101112# 使用np.zeros创建一个3x2x2的三维数组，所有元素初始化为0arr_zeros = np.zeros((3, 2, 2))# 使用np.ones创建一个3x3x3的三维数组，所有元素初始化为1arr_ones = np.ones((3, 3, 3))# 使用np.random.rand创建一个3x4x2的三维数组，所有元素为随机数arr_random = np.random.rand(3, 4, 2)print(&quot;Zeros:\\n&quot;, arr_zeros)print(&quot;Ones:\\n&quot;, arr_ones)print(&quot;Random:\\n&quot;, arr_random) 访问三维数组元素访问三维数组的元素类似于访问二维数组，但需要指定三个索引：第一个索引表示哪一个二维数组（矩阵），第二和第三个索引分别表示该二维数组中的行和列。 123# 访问第一个二维数组的第二行第一列的元素element = arr_3d[0, 1, 0]print(element) 三维数组的应用三维数组在科学计算、数据分析、图像处理等领域有广泛的应用。例如，在图像处理中，彩色图像可以表示为一个三维数组，其中两个维度对应于图像的宽度和高度，第三个维度用于表示颜色通道（如RGB）。 数学函数和统计函数NumPy数组操作实例首先，这是创建和打印NumPy数组的基础代码： 123import numpy as nparr1 = np.array([1, 7, 2, 19, 23, 0, 88, 11, 6, 11])print(arr1) 基本统计操作 最大值和最小值 arr1.max()返回数组中的最大值。 arr1.min()返回数组中的最小值。 平均值和中位数 arr1.mean()计算数组所有元素的平均值。 np.median(arr1)计算数组中的中位数，注意是使用np.median()而不是arr1.median()。 索引操作 arr1.argmax()返回数组中最大值的索引。 arr1.argmin()返回数组中最小值的索引。 np.argwhere(arr1 &gt; 20)返回数组中所有大于20的元素的索引。 聚合操作 总和和累积总和 np.sum(arr1)计算数组元素的总和。 np.cumsum(arr1)计算数组元素的累积总和，即每个元素是原数组到该位置的所有元素的总和。 分散度测量 标准差和方差 np.std(arr1)计算数组的标准差，衡量数据的分散程度。 np.var(arr1)计算数组的方差，方差越大，数据的分散程度越高。 数学函数 指数和对数 np.exp(arr1)计算数组中所有元素的指数。 np.log(arr1)计算数组中所有元素的自然对数。注意，对数运算要求数组中的所有元素都必须大于0。 信息 扩展信息 数据归一化 在数据处理中，经常需要对数据进行归一化处理，以便将数据限制在特定的范围内。使用NumPy可以轻松实现这一点，例如通过将数组的每个元素减去数组的最小值然后除以数组的范围（最大值-最小值）来实现归一化。 条件选择 NumPy允许使用条件表达式选择数组中的元素，这对于数据分析和预处理非常有用。例如，arr1[arr1 &gt; 10]将返回arr1中所有大于10的元素组成的数组。 多维数组操作 虽然这里主要讨论的是一维数组的操作，但NumPy的真正强大之处在于它可以无缝地处理多维数组（如二维数组或三维数组）。许多上述操作（如求和、最大值、最小值等）都可以沿指定轴在多维数组上执行。 随机数生成整数随机数NumPy的np.random.randint()函数用于生成指定范围内的随机整数。生成一个4行5列的随机整数数组，其中整数范围是从0（包含）到10（不包含）。 123import numpy as nparr2 = np.random.randint(0, 10, size=(4, 5))print(arr2) 浮点数随机数与此同时，np.random.uniform()函数用于生成一个给定范围内的浮点数随机数组。展示了如何创建一个4行5列的数组，并且如何使用np.around()函数来保留结果至指定的小数位数。 1234arr2 = np.random.uniform(0, 10, size=(4, 5))print(arr2)arr2_rounded = np.around(arr2, decimals=2)print(arr2_rounded) 计算平均值计算数组的平均值是数据分析中的基本操作，axis参数允许指定沿哪个轴计算平均值。 列平均值 (axis=0): 计算每列的平均值。 行平均值 (axis=1): 计算每行的平均值。 1234# 列平均值print(arr2.mean(axis=0))# 行平均值print(arr2.mean(axis=1)) 数组连接与拆分连接数组numpy.concatenate()函数是连接两个或多个数组的工具。提供了列对齐和行对齐连接的示例，这非常有助于理解如何根据实际需求选择合适的axis参数。 1234567891011# 列对齐连接arr1 = np.array([[1, 2], [3, 4]])arr2 = np.array([[5, 6]])result = np.concatenate((arr1, arr2), axis=0)print(result)# 行对齐连接arr1 = np.array([[1, 2], [3, 4]])arr2 = np.array([[5, 6], [8, 9]])result = np.concatenate((arr1, arr2), axis=1)print(result) 拆分数组numpy.split()函数提供了一种灵活的方式来拆分数组。它可以根据指定的段数均匀拆分数组，也可以根据提供的索引数组来拆分。 12345678910111213# 均匀拆分一维数组arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])result = np.split(arr, 3)print(result)# 按照索引拆分result = np.split(arr, [2, 5])print(result)# 二维数组的拆分arr1 = np.array([[1, 2], [3, 4]])result = np.split(arr1, 2, axis=0)print(result) 信息 扩展信息 多维数组的连接与拆分：numpy.concatenate()和numpy.split()不仅限于处理一维或二维数组，它们也可以用于更高维度的数组。当处理多维数组时，选择正确的axis参数变得尤为重要。 其他数组操作函数：NumPy提供了其他函数如np.vstack()（垂直栈）、np.hstack()（水平栈）以及np.array_split()（允许不等量的分割），这些函数提供了更多 灵活性在数组的操作上。 随机数种子：为了使随机数生成的结果可复现，可以通过np.random.seed()函数设置随机数生成的种子。 NumPy数组的shape属性 获取数组形状：shape属性是NumPy数组的内置属性，用于返回数组的维度信息。这是理解和操作多维数组的基础。 对于一维数组，shape返回的是一个元组，其中只有一个元素，表示数组中的元素数量。 对于二维数组，shape返回的是两个元素的元组，分别表示数组的行数和列数。 对于高维数组，shape将以此类推，返回每个维度的大小。 123# 示例代码print(arr1.shape) # 打印arr1的形状print(arr2.shape) # 打印arr2的形状 数组类型的转换 使用astype方法：astype方法用于数组的数据类型转换。这个方法返回数组的一个新副本，其中的元素已转换为指定的类型。 更新的数据类型表示：在新版本的NumPy中，建议使用Python标准的数据类型名称，如float代替np.float，以避免弃用警告或错误。 1234# 示例代码arr3 = arr1.astype(float) # 将arr1的数据类型转换为floatprint(arr3)print(arr3.dtype) # 查看转换后的数据类型 数据类型和显示方式：转换为浮点数后，即使是0值也会显示为0.0，这是浮点数表示法的一部分，并不影响值的实际大小或精度。 NumPy数据类型概览 布尔型：bool，表示真值True或False，使用一个字节存储。 整型：包括int8, int16, int32, int64及其无符号版本uint8, uint16, uint32, uint64，分别对应不同的大小范围。 浮点型：float16, float32, float64（或简写为float），用于表示小数，具有不同的精度和表示范围。 复数型：complex64, complex128（或简写为complex），用于表示复数，其中实部和虚部分别由浮点数表示。 创建特殊数组全零数组 np.zeros()函数非常适用于初始化固定大小的数组。全零数组在算法初期的数据准备阶段特别有用，可以作为数据容器的起点。 1234567# 一维全零数组zeros_array = np.zeros(5)print(zeros_array)# 二维全零数组zeros_array = np.zeros((2, 3))print(zeros_array) 全一数组 np.ones()函数创建的是全一数组，这在需要初始化为特定值的数组时非常有用，例如在某些算法中初始化权重。 1234567# 一维全一数组ones_array = np.ones(5)print(ones_array)# 二维全一数组ones_array = np.ones((2, 3))print(ones_array) 未初始化数组 np.empty()函数用于创建未初始化的数组。这种数组的内容是内存中的随机值，因此np.empty()比np.zeros()或np.ones()更快，但使用时需要注意其值是不确定的。 1234567# 一维未初始化数组empty_array = np.empty(5)print(empty_array)# 二维未初始化数组empty_array = np.empty((2, 3))print(empty_array) 数组结构的变化获取数组形状 使用.shape属性而不是.shape()方法来获取数组的形状。这是一个常见的误区。 12ar1 = np.random.randint(0, 10, size=(4, 5))print(ar1.shape) 转置操作 .T属性用于数组的转置。对于二维数组，它会交换数组的行和列。对于一维数组，.T不会改变数组。 123ar2 = np.random.randint(0, 10, size=(4, 5))print(ar2)print(ar2.T) 改变数组形状 np.reshape()函数用于在不改变数据的前提下改变数组的形状。重塑后的数组元素总数必须与原始数组相同。 1234567891011arr1 = np.array([1, 7, 2, 19, 23, 0, 88, 11, 6, 11])reshaped_arr = np.reshape(arr1, (2, 5))print(reshaped_arr)# 把二维变一维reshaped_arr = np.reshape(arr1, (1, 10))print(reshaped_arr)# 使用arange生成的一维数组变成二维arr2 = np.reshape(np.arange(20), (4, 5))print(arr2) 信息 进阶提示 数组重塑的灵活性：np.reshape()可以接受一个参数为-1，这意味着该维度的大小将自动计算。这在将多维数组平坦化为一维数组时非常有用，或者在不知道某个维度具体大小但知道总元素数量时使用。 内存顺序：order参数在np.zeros(), np.ones(), np.empty()函数中指定了数组在内存中的布局。&#39;C&#39;代表C语言风格，即行优先；&#39;F&#39;代表Fortran风格，即列优先。了解这一点对于性能优化尤其重要。 NumPy数组的操作与迭代数组的操作数组的切片和索引一维数组的索引一维数组的索引相对简单直观。通过指定下标，可以访问数组中的特定元素或子数组。 1234567891011import numpy as npar = np.arange(20)print(ar) # 打印数组中的所有元素# 索引下标取值print(ar[4]) # 获取下标为4的元素print(ar[3:6]) # 获取下标为3到5的元素，注意这里是左闭右开区间# 使用步长进行索引print(ar[2:8:2]) # 从下标2开始到下标7结束，步长为2 负值索引: 负数索引允许从数组的末尾开始计数，例如，-1代表最后一个元素，-2代表倒数第二个元素，依此类推。 123print(ar[-1]) # 获取最后一个元素print(ar[-1:-8:-1]) # 获取最后一个到倒数第八个元素，步长为-1print(ar[9:0:-1]) # 从下标9开始到1（不包括0），步长为-1 注意，当使用负数步长时，起始索引应该大于结束索引。 完整数组索引: 1234print(ar[:]) # 获取数组的所有元素print(ar[:9]) # 获取从开始到下标8的所有元素print(ar[9:]) # 获取从下标9到数组结束的所有元素print(ar[::-1]) # 获取数组的所有元素，反向 二维数组索引二维数组的索引更加复杂，涉及行和列的概念。NumPy数组的索引遵循[行, 列]的格式。 123456789101112131415ar = np.arange(16).reshape(4,4)print(ar) # 打印二维数组# 行取值print(ar[2:3]) # 获取第3行的数据# 列取值print(ar[:,2:3]) # 获取第3列的数据# 复杂索引示例# 如果想取出1，2，5，6，9，10，13，14这些值print(ar[0:4, 1:3])# 如果想取出10，11，14，15这些值print(ar[2:, 2:]) 注意，在二维数组中，:用于表示选取该维度的所有数据。 三维数组索引三维数组的索引引入了更多层次，通常表示为[深度, 行, 列]。 123456789101112131415ar = np.arange(27).reshape(3,3,3) # 创建一个三维数组print(ar)# 获取第一个二维数组print(ar[0,:,:])# 获取所有二维数组中的第一行print(ar[:,0,:])# 获取所有二维数组中的第一列print(ar[:,:,0])# 更复杂的索引# 获取第二个二维数组中，第二行及之后的数据print(ar[1, 1:,:]) 在三维数组中，可以通过指定每个维度的索引来访问特定的元素、行、列或子数组。这些示例展示了如何通过多维索引来操作和访问数组中的数据。 数据的排序排序是数据处理中的一个基本操作，它按照一定的顺序重新排列数据元素。NumPy提供了numpy.sort()函数来执行数组的排序。 NumPy排序函数numpy.sort()是NumPy中用于排序的函数，它的参数如下： a: 要排序的数组。 axis: 指定沿着哪个轴进行排序。默认值为-1，意味着沿最后一个轴排序。 kind: 选择排序算法。可选值包括&#39;quicksort&#39;、&#39;mergesort&#39;、&#39;heapsort&#39;。默认为&#39;quicksort&#39;。 order: 当数组是结构化数组时，这个参数可以指定根据哪个字段进行排序。 示例代码： 12345678import numpy as nparr = np.array([3, 1, 2, 4])sorted_arr = np.sort(arr) # 默认使用快速排序print(sorted_arr) # 输出：[1 2 3 4]sorted_arr = np.sort(arr, kind=&#x27;mergesort&#x27;) # 使用归并排序print(sorted_arr) # 输出：[1 2 3 4] 归并排序算法归并排序是一种分治策略的算法，通过递归地将数组分割成更小的数组，直到每个子数组只有一个元素，然后将这些数组合并成一个有序数组。 归并排序的步骤: 分割（Divide）: 将数组不断二分，直到每个子数组只包含一个元素。 合并（Merge）: 将分割后的子数组合并，过程中将它们排序。 Python实现示例： 12345678910111213141516171819202122232425262728293031323334353637def merge_sort(arr): if len(arr) &lt;= 1: return arr # 分割数组 mid = len(arr) // 2 left_arr = arr[:mid] right_arr = arr[mid:] # 递归排序左右两部分 left_arr = merge_sort(left_arr) right_arr = merge_sort(right_arr) # 合并排序后的两部分 return merge(left_arr, right_arr)def merge(left_arr, right_arr): result = [] i = j = 0 while i &lt; len(left_arr) and j &lt; len(right_arr): if left_arr[i] &lt; right_arr[j]: result.append(left_arr[i]) i += 1 else: result.append(right_arr[j]) j += 1 # 将剩余元素添加到结果数组中 result.extend(left_arr[i:]) result.extend(right_arr[j:]) return result# 测试归并排序arr = [38, 27, 43, 3, 9, 82, 10]sorted_arr = merge_sort(arr)print(&quot;排序后的数组：&quot;, sorted_arr) 这份笔记概述了在NumPy中进行二维数组排序、使用结构化数据以及特殊函数numpy.argsort()的基本应用。我将对这些主题进行扩展和细化，以提供更加全面和专业的视角。 二维数组排序在NumPy中，对二维数组进行排序可以根据指定轴进行。这意味着可以按行或按列对数组中的元素进行排序。 沿着指定轴排序通过设置axis参数，numpy.sort()允许指定沿数组的哪个轴进行排序： axis&#x3D;0: 沿着第一个轴（垂直方向，即列）进行排序，即对每一列的元素进行排序。 axis&#x3D;1: 沿着第二个轴（水平方向，即行）进行排序，即对每一行的元素进行排序。 示例代码： 12345678import numpy as nparr = np.array([[3, 1], [2, 4]])sorted_arr_axis0 = np.sort(arr, axis=0) # 沿着第一个轴（行）排序sorted_arr_axis1 = np.sort(arr, axis=1) # 沿着第二个轴（列）排序print(sorted_arr_axis0) # 输出：[[2 1] [3 4]]print(sorted_arr_axis1) # 输出：[[1 3] [2 4]] 数组结构优化：结构化数据NumPy支持创建结构化数组，这种数组可以包含不同类型的数据，类似于数据库表或Excel电子表格中的数据。 结构化数组的排序使用结构化数组时，numpy.sort()函数允许通过order参数指定根据哪个字段进行排序。 示例代码： 12345678import numpy as npdtype = [(&#x27;name&#x27;, &#x27;S10&#x27;), (&#x27;age&#x27;, int)]values = [(&#x27;Tom&#x27;, 25), (&#x27;Kate&#x27;, 22), (&#x27;John&#x27;, 30)]arr = np.array(values, dtype=dtype)sorted_arr = np.sort(arr, order=&#x27;age&#x27;) # 按照 &#x27;age&#x27; 字段排序print(sorted_arr) # 输出按照年龄升序排列的结构化数组 访问结构化数组中的数据可以通过字段名访问结构化数组中的数据，这使得操作结构化数据变得非常方便。 1234567# 输出所有人的姓名和年龄print(&quot;所有人的姓名：&quot;, arr[&#x27;name&#x27;])print(&quot;所有人的年龄：&quot;, arr[&#x27;age&#x27;])# 访问特定位置的姓名和年龄print(&quot;第二个人的姓名：&quot;, arr[1][&#x27;name&#x27;])print(&quot;第三个人的年龄：&quot;, arr[2][&#x27;age&#x27;]) 这份笔记已经概述了NumPy中一些特殊函数的使用，包括numpy.argsort(), numpy.lexsort(), numpy.insert(), numpy.delete(), 和numpy.unique()等函数，以及数组堆叠的基本概念。下面我将对这些主题进行扩展和细化，以提供更加全面和专业的视角。 特殊函数numpy.argsort() 功能: 返回数组排序后的索引。 语法: numpy.argsort(a, axis=-1, kind=&#39;quicksort&#39;, order=None) a: 要排序的数组。 axis: 沿着哪个轴排序，默认为 -1，表示沿最后一个轴排序。 kind: 排序算法，可选&#39;quicksort&#39;、&#39;mergesort&#39;、&#39;heapsort&#39;，默认为 &#39;quicksort&#39;。 order: 结构化数组排序时指定字段。 示例代码： 1234567891011import numpy as np# 一维数组示例arr = np.array([3, 1, 2, 4])sorted_indices = np.argsort(arr)print(sorted_indices) # 输出：[1 2 0 3]# 二维数组示例ar = np.reshape(np.arange(16), (4,4))sorted_indices = np.argsort(ar)print(sorted_indices) # 输出每行元素排序后的索引 numpy.lexsort() 功能: 对多个序列进行间接排序。 语法: numpy.lexsort(keys, axis=-1) keys: 排序的键值对，多个序列的元组或数组。 axis: 排序轴，默认为 -1。 示例代码： 1234names = np.array([&#x27;Tom&#x27;, &#x27;Kate&#x27;, &#x27;John&#x27;])ages = np.array([25, 22, 30])sorted_indices = np.lexsort((names, ages)) # 先按ages排序，若相同则按names排序print(sorted_indices) # 输出：[1 0 2] 数据的添加在你的笔记中，你提到了使用np.append()函数在NumPy数组中添加元素的不同情况，包括未指定轴时的行为以及如何沿特定轴添加元素。下面，我将对这部分内容进行更专业和详细的整理，同时纠正一些错误用法。 numpy.append()np.append() 函数用于在数组的末尾添加元素。这个函数可以处理不同维度的数组，但其行为会根据是否指定axis参数而改变。 未指定轴（默认行为）当未指定axis参数时，np.append()会先将输入数组扁平化为一维数组，然后再添加元素。 123456import numpy as nparr0 = np.array([[1, 2, 3], [4, 5, 6]])# 未指定轴，结果为一维数组result = np.append(arr0, [[7, 8, 9]])print(result) # 输出: [1 2 3 4 5 6 7 8 9] 这说明，如果没有明确指定axis，无论原数组的维度如何，结果都会是一维数组。 指定轴进行添加 沿着行添加（axis=0） 当指定axis=0时，元素或数组将会作为新行添加到原数组中。这要求新添加的数组在非指定轴的维度上与原数组相匹配。 1234567# 沿着行（axis=0）添加result = np.append(arr0, [[7, 8, 9]], axis=0)print(result) # 输出:# [[1 2 3]# [4 5 6]# [7 8 9]] 沿着列添加（axis=1） 沿列添加要求新添加的行数与原数组匹配。下面是一个正确的例子，展示了如何沿列正确添加元素： 123456# 沿着列（axis=1）正确添加result = np.append(arr0, [[7], [8]], axis=1)print(result)# 输出:# [[1 2 3 7]# [4 5 6 8]] 注意，在尝试沿着列添加时，你需要确保添加的数组在行的数量上与原数组一致。下面是一个修正的示例，正确展示了如何沿列添加多个元素： 123456789# 正确的沿列添加result = np.append(arr0, [[7, 10], [8, 11], [9, 12]], axis=0)print(result)# 输出:# [[ 1 2 3]# [ 4 5 6]# [ 7 10]# [ 8 11]# [ 9 12]] numpy.insert() 功能: 在指定位置插入元素。 语法: numpy.insert(arr, obj, values, axis=None) arr: 输入数组。 obj: 插入的索引位置。 values: 要插入的值或数组。 axis: 指定的轴向。 示例代码： 123456789# 一维数组示例arr = np.array([1, 2, 3, 4, 5])arr = np.insert(arr, 2, 10)print(&quot;插入后的数组：&quot;, arr) # 输出：[1 2 10 3 4 5]# 二维数组示例arr = np.array([[1, 2, 3], [4, 5, 6]])arr = np.insert(arr, 1, [7, 8, 9], axis=0)print(arr) # 在第1行后插入一行[7, 8, 9] 数据的删除与去重这份笔记已经概述了numpy.delete()函数的使用，numpy.unique()函数的多个功能，以及如何使用numpy.hstack()和numpy.vstack()进行数组的堆叠。我将对这些内容进行更详细的整理和补充，以提供一个全面的视角。 numpy.delete()函数numpy.delete()用于删除数组中的元素。 语法: numpy.delete(arr, obj, axis=None) arr: 输入数组。 obj: 表示要删除的子数组的索引。 axis: 指定要从哪个轴删除元素。如果不指定，输入数组将会被展平。 示例 12345678910111213141516171819202122import numpy as np# 创建一个数组a = np.arange(12).reshape(3, 4)print(a)# 未指定轴，数组被展平后删除指定索引的元素print(np.delete(a, 8))# 删除第二行print(np.delete(a, 1, axis=0))# 删除第二列print(np.delete(a, 1, axis=1))# 按索引删除多列a = np.delete(a, [0, 2], axis=1)print(a)# 按索引删除多行a = np.delete(a, [0], axis=0)print(a) numpy.unique()函数numpy.unique()用于找出数组中的唯一值并返回已排序的结果。 语法: numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None) ar: 输入数组。 return_index: 如果为True，返回唯一值的原始索引。 return_inverse: 如果为True，返回重构原数组的索引数组。 return_counts: 如果为True，返回每个唯一值的出现次数。 示例 123456789101112131415a = np.array([1, 2, 2, 3, 5, 6, 6, 7, 12, 6, 8])u = np.unique(a)print(u) # 返回唯一值# 返回唯一值及其原始索引u, indices = np.unique(a, return_index=True)print(indices)# 返回唯一值及其出现次数u, counts = np.unique(a, return_counts=True)print(counts)# 返回重构原数组的索引数组u, inverse = np.unique(a, return_inverse=True)print(inverse) 数组的堆叠 **numpy.hstack()**：水平堆叠数组。 12345678910a = np.array([[1, 2], [3, 4]])b = np.array([[5, 6], [7, 8]])ar1 = np.hstack((a, b))print(ar1)# 对于一维数组a = np.arange(5)b = np.arange(5, 9)ar1 = np.hstack((a, b))print(ar1) **numpy.vstack()**：垂直堆叠数组。 12345678910a = np.array([[1, 2], [3, 4]])b = np.array([[5, 6], [7, 8]])ar2 = np.vstack((a, b))print(ar2)# 形状不同的数组也可以垂直堆叠a = np.array([[1], [2], [3]])b = np.array([[&#x27;a&#x27;], [&#x27;b&#x27;], [&#x27;c&#x27;], [&#x27;d&#x27;]])ar2 = np.vstack((a, b))print(ar2, ar2.shape) 信息 当使用np.vstack()和np.hstack()进行堆叠时，形状的兼容性是关键：对于np.hstack()，输入数组必须在除了第一个轴以外的维度上有相同的形状；对于np.vstack()，则是在第一个轴以外的其他轴必须形状相同。 当形状不完全匹配时，可以通过调整数组形状或使用不同的堆叠函数（如np.concatenate()）来实现堆叠。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"NumPy","slug":"NumPy","permalink":"https://www.yiuhangblog.com/tags/NumPy/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"author":"Yiuhang Chan"},{"title":"迭代器和生成器, 数据结构","slug":"20181018迭代器和生成器","date":"2018-10-18T06:04:36.000Z","updated":"2024-02-28T10:49:22.000Z","comments":true,"path":"2018/10/18/20181018迭代器和生成器/","permalink":"https://www.yiuhangblog.com/2018/10/18/20181018%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"Python 迭代器和生成器基础, 数据结构","text":"推导式在 Python 中，推导式（Comprehensions）提供了一种简洁且高效的方式来创建和操作数据集合。推导式可以应用于列表（list）、字典（dict）、集合（set）以及元组（tuple，仅在 Python 3.8 及以上版本中以生成器表达式的形式支持）。通过使用推导式，可以从一个已存在的数据序列生成一个新的数据序列，同时还可以在过程中对数据进行过滤和转换。 列表推导式列表推导式是最常用的推导式类型之一，它允许快速生成列表，格式如下： 基本形式： 1[表达式 for 变量 in 列表] 其中，表达式为每个元素的生成公式，for 变量 in 列表部分则是迭代原列表中的每一个元素。 带有条件的形式： 1[表达式 for 变量 in 列表 if 条件] 在这种形式中，if 条件用于筛选符合条件的元素，仅对这些元素应用表达式生成新的列表元素。 在 Python 中，除了列表推导式之外，还支持字典推导式、集合推导式和元组推导式（实际上是生成器表达式）。这些推导式提供了一种高效、简洁的方式来生成新的集合数据类型。以下是对这些推导式的详细介绍和示例。 字典推导式字典推导式用于创建字典，基本格式如下： 1&#123;key_expr: value_expr for value in collection&#125; 或者，如果需要根据条件过滤元素： 1&#123;key_expr: value_expr for value in collection if condition&#125; **key_expr**：键表达式，定义如何生成字典的键。 **value_expr**：值表达式，定义如何生成字典的值。 **collection**：一个可迭代对象，如列表、元组、集合等。 **condition**：一个布尔表达式，用于过滤哪些元素应该被包含在新字典中。 集合推导式集合推导式用于创建集合，基本格式如下： 1&#123;expression for item in Sequence&#125; 或者，带有条件的形式： 1&#123;expression for item in Sequence if conditional&#125; 集合推导式类似于列表推导式，但它生成的是集合，因此结果中自动去除了重复元素。 元组推导式（生成器表达式）虽然通常称之为元组推导式，但实际上 Python 使用的是生成器表达式来生成元组。生成器表达式返回一个生成器对象，而不是一个立即执行的集合。基本格式如下： 1(expression for item in Sequence) 或者，带有条件的形式： 1(expression for item in Sequence if conditional) 生成器表达式使用圆括号()，与列表推导式的中括号[]和字典、集合推导式的大括号&#123;&#125;相区分。 示例推导式示例 列表推导式示例： 1squares = [x**2 for x in range(10)] 字典推导式示例： 1square_dict = &#123;x: x**2 for x in range(5)&#125; 集合推导式示例： 1square_set = &#123;x**2 for x in [1, -1, 2]&#125; 元组（生成器）推导式示例： 1square_gen = (x**2 for x in range(10)) 迭代器python中的迭代器是访问集合的一种方式，每次访问记住遍历的位置。 迭代（Iteration）是指重复执行某个过程的行为，每次都在基于上一次的结果进行操作。在编程中，迭代通常用于遍历数据结构中的元素，例如列表、字典等。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 **next()**。 迭代器通过 iter()将一个可迭代对象变成迭代器，例如list tuple dict set str等，还有就是后面讲到的生成器（generator） 都是可迭代对象 通过next()或者for循环访问迭代的数据 Python中常见的迭代器 有： 列表迭代器：使用for循环遍历列表。 字典迭代器：使用for循环遍历字典的键、值或键值对。 文件迭代器：使用for循环遍历文件中的行。 生成器：使用yield语句来生成迭代器，可以节省内存空间和计算资源。 itertools模块中的迭代器：包括count、cycle、repeat、chain、zip_longest、islice、takewhile、dropwhile等。这些迭代器可以实现更加复杂的迭代操作 语法和参数说明 iter函数是一个内置函数，用于创建一个迭代器对象。迭代器是一种特殊的对象，可以通过调用next()函数来逐个访问其中的元素。iter函数接受一个可迭代对象作为参数，并返回一个迭代器对象 iter函数的语法如下所示： iter(iterable) 其中，iterable是一个可迭代对象，比如列表、元组、字符串等 生成器在 Python 中，使用了 yield 的函数被称为生成器（generator）。 yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。 然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。 调用一个生成器函数，返回的是一个迭代器对象。 下面是一个简单的示例，展示了生成器函数的使用： 1234567891011121314def countdown(n): while n &gt; 0: yield n n -= 1 # 创建生成器对象 generator = countdown(5) # 通过迭代生成器获取值 print(next(generator)) # 输出: 5 print(next(generator)) # 输出: 4 print(next(generator)) # 输出: 3 # 使用 for 循环迭代生成器 for value in generator: print(value) # 输出: 2 1 上实例中，countdown 函数是一个生成器函数。它使用 yield 语句逐步产生从 n 到 1 的倒数数字。在每次调用 yield 语句时，函数会返回当前的倒数值，并在下一次调用时从上次暂停的地方继续执行。 通过创建生成器对象并使用 next() 函数或 for 循环迭代生成器，我们可以逐步获取生成器函数产生的值。在这个例子中，我们首先使用 next() 函数获取前三个倒数值，然后通过 for 循环获取剩下的两个倒数值。 生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。此外，生成器还可以与其他迭代工具（如for循环）无缝配合使用，提供简洁和高效的迭代方式。 数据结构在网络上储存了各种形式的数据，当数据量大了的时候，我们对数据进行 增、减、改、查都是建立在数据结构上的。 pthon的数据结构有四种，分别是：列表、字典、元组、集合。这四种代表四种储存数据的方式。 列表（List）Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能，列表是Python中最基本的数据结构。列表的方法如append(), count(), extend(), index(), insert(), pop(), remove(), reverse(), 和 sort() 提供了丰富的操作，使得列表成为处理序列数据的强大工具。 以下是 Python 中列表的方法： 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 [list.pop(index&#x3D;-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort(cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False) 对原列表进行排序 列表切片列表切片提供了一种灵活访问列表部分元素的方法。通过指定索引范围，可以轻松获取、修改或删除列表的一部分，这是处理和分析数据时常用的技术。 list&#x3D;[1,2,3,4,5] 列表是可以切片的，就像我们切面包一样，你想要中间的面包就切中间，要左边就切左边。这个功能有什么用呢，主要作用就是能够让我们对列表中的数值进行索引。 我们要先将列表中的元素进行排序，排序从0开始，如[1,2,3,4,5]分别对应0,1,2,3,4 ,然后通过list&#x3D;[元素序号:元素序号]进行索引，或者直接填入位置编号。 字典（Dictionary）建立字典 字典是一种映射类型，它存储键值对，其中键是唯一的。字典的直观性和快速访问特性使它成为存储和操作关联数据的理想选择。创建和访问字典都非常简单高效，是处理复杂数据结构时常用的数据类型。 12345myInformation=&#123;&quot;myName&quot;:&quot;zhangzexiang&quot;&#125; #&quot;myName&quot;就是键，&quot;zhangzexiang&quot;就是值。print(myInformation)myInformation=&#123;&quot;MyName&quot;:&quot;zhangzexiang&quot;,&quot;Sex&quot;:&quot;man&quot;,&quot;Age&quot;:&quot;100&quot;&#125; #包含了姓名、性别、年龄print(myInformation) 元组（Tuple）元组是不可变的序列类型，这意味着一旦创建，元组中的元素不能被修改。元组的不可变性使其成为存储不应改变数据的理想选择，例如函数的参数列表。 123a=(1,2,3,4,5)print(a[0])print(a) 集合（Set）集合是一个无序的、不包含重复元素的集。它提供了许多标准的集合操作，如并集、交集、差集等。集合的独特性和操作使其成为处理非重复项集时的理想选择。 12345a=&#123;1,2,3,4,5&#125;print(a)a.add(6) #添加a.discard(1) #删除print(a) 让我们通过具体的Python代码示例深入理解堆栈和队列的实现及其应用。 堆栈（Stack）堆栈是一种遵循后进先出（LIFO）原则的数据结构。在Python中，列表的append()方法用于添加元素到列表的末尾，而pop()方法用于移除列表末尾的元素。这两个方法使得列表可以非常方便地被用作堆栈。 示例：使用列表实现堆栈 123456789101112131415stack = []# 向堆栈添加元素stack.append(&#x27;A&#x27;)stack.append(&#x27;B&#x27;)stack.append(&#x27;C&#x27;)print(&quot;Initial stack:&quot;, stack)# 弹出堆栈顶的元素print(&quot;Popped element:&quot;, stack.pop())print(&quot;Stack after popping:&quot;, stack)# 再次弹出堆栈顶的元素print(&quot;Popped element:&quot;, stack.pop())print(&quot;Stack after popping:&quot;, stack) 在这个示例中，我们首先创建了一个空列表stack作为堆栈。然后，我们通过append()方法向堆栈中添加了三个元素。通过调用pop()方法，我们移除了堆栈顶的元素，并打印了每次弹出操作后堆栈的状态。 队列（Queue）队列是一种遵循先进先出（FIFO）原则的数据结构。尽管可以使用列表来实现队列，但在列表的开始位置插入或删除元素的效率较低。因此，Python的collections模块提供了deque（双端队列），它是为两端都可以高效操作（添加和删除元素）而设计的。 示例：使用collections.deque实现队列 123456789101112131415161718from collections import deque# 创建一个空的双端队列queue = deque()# 向队列中添加元素queue.append(&#x27;A&#x27;)queue.append(&#x27;B&#x27;)queue.append(&#x27;C&#x27;)print(&quot;Initial queue:&quot;, list(queue))# 从队列中移除元素print(&quot;Popped element:&quot;, queue.popleft())print(&quot;Queue after popping:&quot;, list(queue))# 再次从队列中移除元素print(&quot;Popped element:&quot;, queue.popleft())print(&quot;Queue after popping:&quot;, list(queue)) 在这个示例中，我们首先导入了collections.deque，然后创建了一个名为queue的双端队列。我们通过append()方法在队列末尾添加了元素，并通过popleft()方法从队列的开始位置移除了元素。每次操作后，我们打印了队列的当前状态，以展示队列的先进先出特性。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基本语法","slug":"基本语法","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"迭代器","slug":"迭代器","permalink":"https://www.yiuhangblog.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"生成器","slug":"生成器","permalink":"https://www.yiuhangblog.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Yiuhang Chan"},{"title":"正则表达式","slug":"20181012正则表达式","date":"2018-10-12T10:24:40.000Z","updated":"2024-02-28T10:49:20.000Z","comments":true,"path":"2018/10/12/20181012正则表达式/","permalink":"https://www.yiuhangblog.com/2018/10/12/20181012%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"Python 正则表达式基础","text":"re模块正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在Python中，正则表达式的功能通过 re 模块提供。这个模块包含了各种基于正则表达式的操作，比如匹配、查找、替换等。 re.match()re.match() 方法用于从字符串的开始位置匹配一个模式。如果匹配成功，返回一个匹配对象；如果不匹配，返回 None。 12345678910import repattern = r&quot;Hello&quot;string = &quot;Hello World&quot;match = re.match(pattern, string)if match: print(&quot;Match found:&quot;, match.group())else: print(&quot;No match&quot;) 这个例子中，pattern 是我们要查找的模式（”Hello”），而 string 是我们要搜索的字符串（”Hello World”）。由于 “Hello World” 以 “Hello” 开头，所以 re.match() 会找到一个匹配。 re.search()re.search() 方法在整个字符串中搜索模式的第一个匹配项。如果找到匹配项，返回一个匹配对象；如果没有找到，返回 None。 12345678910import repattern = r&quot;World&quot;string = &quot;Hello World&quot;search = re.search(pattern, string)if search: print(&quot;Match found:&quot;, search.group())else: print(&quot;No match&quot;) 在这个例子中，尽管 “World” 不是字符串 “Hello World” 的开始部分，re.search() 依然可以找到匹配项。 re.findall()re.findall() 方法在字符串中找到正则表达式所匹配的所有子串，并返回一个列表。如果没有找到匹配的，则返回一个空列表。 1234567import repattern = r&quot;l&quot;string = &quot;Hello World&quot;findall = re.findall(pattern, string)print(&quot;Matches found:&quot;, findall) 这里，re.findall() 查找 “Hello World” 中所有的 “l” 字符。因此，它会返回 [&#39;l&#39;, &#39;l&#39;]。 注意事项 正则表达式是一个复杂的主题，有很多特殊字符和模式，如特殊字符 *, +, ?, &#123;&#125;，以及字符类 [] 等。 在使用 re 模块时，通常建议使用原始字符串（如 r&quot;Hello&quot;），这样可以避免Python对字符串中的反斜杠进行转义。 返回的匹配对象有多个方法，如 group()，可以用来获取匹配的特定部分。 元字符 元字符 描述 示例 示例说明 . 匹配任何单个字符（除换行符） &quot;.a&quot; 匹配 ‘ca’ 在 “cat” 中 ^ 匹配字符串的开始 &quot;^Hello&quot; 匹配 ‘Hello’ 在 “Hello World” 的开始 $ 匹配字符串的结束 &quot;World$&quot; 匹配 ‘World’ 在 “Hello World” 的结束 * 匹配0次或多次前面的字符 &quot;ho*&quot; 匹配 ‘hooo’ 在 “hoooray” 中 + 匹配1次或多次前面的字符 &quot;ho+&quot; 匹配 ‘hooo’ 在 “hoooray” 中 ? 匹配0次或1次前面的字符 &quot;ho?&quot; 匹配 ‘ho’ 在 “hoooray” 中 &#123;m,n&#125; 匹配至少 m 次，最多 n 次前面的字符 &quot;(ho)&#123;1,2&#125;&quot; 匹配 ‘hoho’ 在 “hohohooray” 中 [] 匹配方括号中的任意一个字符 &quot;[Hh]ello&quot; 匹配 ‘hello’ 在 “hello” 中 [^] 匹配不在方括号中的任意一个字符 &quot;[^abc]&quot; 匹配 ‘g’ 在 “g” 中 &#96; &#96; “或” 操作，匹配符号左或右的字符 &#96;”cat () 创建捕获组 &#96;”(hello hi) (world \\d 匹配任何十进制数字 &quot;\\d+&quot; 匹配 ‘1234’ 在 “Room number: 1234” 中 \\D 匹配任何非数字字符 &quot;\\D+&quot; 匹配 ‘ABC’ 在 “1234ABC” 中 \\s 匹配任何空白字符 &quot;\\s&quot; 匹配空格在 “Hello World” 中 \\S 匹配任何非空白字符 &quot;\\S+&quot; 匹配 ‘Hello’ 在 “ Hello World” 中 \\w 匹配任何字母数字字符 &quot;\\w+&quot; 匹配 ‘_hello123’ 在 “_hello123” 中 \\W 匹配任何非字母数字字符 &quot;\\W+&quot; 匹配 ‘,’ 在 “Hello, World!” 中 \\b 匹配一个单词边界 &quot;\\bWorld\\b&quot; 匹配 ‘World’ 在 “Hello World!” 中 \\B 匹配非单词边界 &quot;\\BWorld\\B&quot; 在 “HelloWorld!” 中不匹配 点号 (.)表示任何单个字符（除了换行符）。 示例： 12345import repattern = r&quot;.a&quot;string = &quot;cat&quot;match = re.search(pattern, string)print(match.group()) # 输出: ca 脱字符 (^)匹配字符串的开头。 示例： 12345import repattern = r&quot;^Hello&quot;string = &quot;Hello World&quot;match = re.search(pattern, string)print(match.group()) # 输出: Hello 美元符号 ($)匹配字符串的结尾。 示例： 12345import repattern = r&quot;World$&quot;string = &quot;Hello World&quot;match = re.search(pattern, string)print(match.group()) # 输出: World 星号 (*)表示0次或多次匹配前面的字符。 示例： 12345import repattern = r&quot;ho*&quot;string = &quot;hoooray&quot;match = re.search(pattern, string)print(match.group()) # 输出: hooo 加号 (+)表示1次或多次匹配前面的字符。 示例： 12345import repattern = r&quot;ho+&quot;string = &quot;hoooray&quot;match = re.search(pattern, string)print(match.group()) # 输出: hooo 问号 (?)表示0次或1次匹配前面的字符。 示例： 12345import repattern = r&quot;ho?&quot;string = &quot;hoooray&quot;match = re.search(pattern, string)print(match.group()) # 输出: ho 花括号 ({m,n})表示至少 m 次，最多 n 次匹配前面的字符。 示例： 12345import repattern = r&quot;(ho)&#123;1,2&#125;&quot;string = &quot;hohohooray&quot;match = re.search(pattern, string)print(match.group()) # 输出: hoho 方括号 ([])用于表示一组字符中的任何一个字符。 示例： 12345import repattern = r&quot;[Hh]ello&quot;string = &quot;hello&quot;match = re.search(pattern, string)print(match.group()) # 输出: hello 反斜杠 ()用于转义特殊字符或表示特殊序列。 示例： 12345import repattern = r&quot;\\d&quot; # \\d 表示任何数字string = &quot;number 5&quot;match = re.search(pattern, string)print(match.group()) # 输出: 5 竖杠 (|)表示“或”操作。 示例： 12345import repattern = r&quot;cat|dog&quot;string = &quot;I like cats&quot;match = re.search(pattern, string)print(match.group()) # 输出: cat 小括号 (())用于创建捕获组。 示例： 123456import repattern = r&quot;(hello|hi) (world|earth)&quot;string = &quot;hello world&quot;match = re.search(pattern, string)print(match.group()) # 输出: hello worldprint(match.group(1)) # 输出: hello 数字和字母的特殊序列 \\d: 匹配任何十进制数字，等同于 [0-9]。 123pattern = r&quot;\\d+&quot;string = &quot;Room number: 1234&quot;print(re.search(pattern, string).group()) # 输出: 1234 \\D: 匹配任何非数字字符，等同于 [^0-9]。 123pattern = r&quot;\\D+&quot;string = &quot;1234ABC&quot;print(re.search(pattern, string).group()) # 输出: ABC \\s: 匹配任何空白字符。 123pattern = r&quot;\\s&quot;string = &quot;Hello World&quot;print(re.search(pattern, string).group()) # 输出: （空格字符） \\S: 匹配任何非空白字符。 123pattern = r&quot;\\S+&quot;string = &quot; Hello World&quot;print(re.search(pattern, string).group()) # 输出: Hello \\w: 匹配任何字母数字字符，等同于 [a-zA-Z0-9_]。 123pattern = r&quot;\\w+&quot;string = &quot;_hello123&quot;print(re.search(pattern, string).group()) # 输出: _hello123 \\W: 匹配任何非字母数字字符，等同于 [^a-zA-Z0-9_]。 123pattern = r&quot;\\W+&quot;string = &quot;Hello, World!&quot;print(re.search(pattern, string).group()) # 输出: , 边界匹配符 \\A 和 \\Z \\A 和 \\Z 分别用于匹配字符串的开头和结尾。它们类似于 ^ 和 $，但主要区别在于，\\A 和 \\Z 不受多行模式的影响，而 ^ 和 $ 在多行模式（re.MULTILINE）下分别匹配每一行的开头和结尾。 12345678910111213import re# \\A 匹配字符串开头pattern = r&quot;\\AHello&quot;string = &quot;Hello World&quot;match = re.search(pattern, string)print(match.group()) # 输出: Hello# \\Z 匹配字符串结尾pattern = r&quot;World\\Z&quot;string = &quot;Hello World&quot;match = re.search(pattern, string)print(match.group()) # 输出: World \\b: 匹配一个单词边界，即单词和空格之间的位置。 12345678910111213import re# 匹配单词边界pattern = r&quot;\\bWorld\\b&quot;string = &quot;Hello World!&quot;match = re.search(pattern, string)print(match.group()) # 输出: World# 不匹配非边界位置pattern = r&quot;\\bWorld\\b&quot;string = &quot;HelloWorld!&quot;match = re.search(pattern, string)print(match) # 输出: None \\B: 匹配非单词边界。 12345678910111213import re# 匹配非单词边界pattern = r&quot;\\BWorld\\B&quot;string = &quot;HelloWorld!&quot;match = re.search(pattern, string)print(match.group()) # 输出: World# 不匹配单词边界位置pattern = r&quot;\\BWorld\\B&quot;string = &quot;Hello World!&quot;match = re.search(pattern, string)print(match) # 输出: None 原始字符串 r 前缀在Python中用于表示原始字符串（raw string）。在正则表达式中，这个前缀非常重要，因为它确保了字符串中的特殊字符（如反斜杠 \\）不会被Python解释器作为转义字符处理。在编写正则表达式时，建议总是使用原始字符串。 为什么使用原始字符串？在正则表达式中，反斜杠 \\ 用于指示特殊序列或作为转义字符。如果不使用原始字符串，Python解释器会首先解释这个反斜杠。例如，\\n 在普通的Python字符串中表示换行符，但在正则表达式中可能表示一个特殊序列。使用原始字符串可以避免这种混淆。 示例不使用原始字符串： 123456import repattern = &quot;\\\\bword\\\\b&quot;string = &quot;A word and another word.&quot;match = re.search(pattern, string)print(match.group()) # 这将不会工作如预期 在这个例子中，每个 \\ 都必须写成 \\\\，因为Python字符串会尝试解释 \\b 作为一个退格符。 使用原始字符串： 123456import repattern = r&quot;\\bword\\b&quot;string = &quot;A word and another word.&quot;match = re.search(pattern, string)print(match.group()) # 输出: word 在这个例子中，使用 r 前缀，所以 \\b 被正确地解释为单词边界匹配符，而不是退格符。 当编写涉及到反斜杠的正则表达式时，总是使用原始字符串（如 r&quot;\\bword\\b&quot;）来确保反斜杠被正确处理。这样可以让正则表达式更易读，也减少了由于转义字符引起的错误。 案例QQ邮箱12345import remail = &quot;daf ghsegtw345 erw123445667@qq.com2342t ewsafc3&quot;print(re.findall(r&#x27;\\d&#123;5,10&#125;@qq\\.com&#x27;, mail)) 手机号12345import rephone = &quot;13312345678&quot;print(re.findall(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;, phone))","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基本语法","slug":"基本语法","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.yiuhangblog.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"re模块","slug":"re模块","permalink":"https://www.yiuhangblog.com/tags/re%E6%A8%A1%E5%9D%97/"},{"name":"元字符","slug":"元字符","permalink":"https://www.yiuhangblog.com/tags/%E5%85%83%E5%AD%97%E7%AC%A6/"}],"author":"Yiuhang Chan"},{"title":"异常处理","slug":"20181005异常","date":"2018-10-05T00:15:10.000Z","updated":"2024-02-28T10:49:16.000Z","comments":true,"path":"2018/10/05/20181005异常/","permalink":"https://www.yiuhangblog.com/2018/10/05/20181005%E5%BC%82%E5%B8%B8/","excerpt":"Python 异常处理基础","text":"异常（Exception）在Python中，异常（Exception）是程序执行过程中发生的错误事件。当Python检测到一个错误时，它会引发一个异常。异常是Python用来管理程序执行中错误的一种机制。 异常的基本概念 异常 (Exception): 这是程序执行中发生的异常事件。在Python中，异常是一个对象，表示一个错误。 引发异常 (Raise an Exception): 当Python解释器遇到一个错误时，它会”引发”一个异常。程序员也可以在代码中显式地引发异常。 捕获异常 (Catch&#x2F;Handle an Exception): 使用try和except语句来捕获并处理异常。这允许程序在发生异常时优雅地恢复，而不是完全崩溃。 try块 (try block): 这是用来测试可能引发异常的代码块。 except块 (except block): 当try块中的代码触发异常时执行的代码块。可以指定捕获特定类型的异常。 finally块 (finally block): 无论是否发生异常，finally块中的代码都会执行。常用于执行清理操作，如关闭文件。 else块 (else block): 如果try块没有引发异常，则执行else块中的代码。 异常类型ValueError当传递给函数的参数类型正确，但值不适当或不在预期范围内时，将引发ValueError。 12345678def convert_to_int(text): try: return int(text) except ValueError: return &quot;请提供一个有效的整数字符串&quot;print(convert_to_int(&quot;123&quot;)) # 输出: 123print(convert_to_int(&quot;abc&quot;)) # 输出: 请提供一个有效的整数字符串 TypeError当操作或函数应用于类型不正确的对象时，会引发TypeError。 12345678def add_numbers(a, b): try: return a + b except TypeError: return &quot;两个参数都必须是数字&quot;print(add_numbers(10, 20)) # 输出: 30print(add_numbers(10, &quot;20&quot;)) # 输出: 两个参数都必须是数字 IndexError当尝试访问序列中不存在的索引时，会引发IndexError。 12345my_list = [1, 2, 3]try: print(my_list[3])except IndexError: print(&quot;索引超出了列表的范围&quot;) KeyError当在字典中查找不存在的键时，会引发KeyError。 12345my_dict = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;try: print(my_dict[&quot;gender&quot;])except KeyError: print(&quot;键不存在&quot;) IOError当尝试执行一个与输入&#x2F;输出相关的操作（如打开不存在的文件）时，会引发IOError（在Python 3中，通常是OSError或其子类）。 12345try: with open(&quot;nonexistent_file.txt&quot;) as f: content = f.read()except IOError: print(&quot;文件打开失败&quot;) ZeroDivisionError当尝试将一个数字除以零时，会引发ZeroDivisionError。 1234try: result = 10 / 0except ZeroDivisionError: print(&quot;除以零错误&quot;) AttributeError当尝试访问对象不存在的属性或方法时，会引发AttributeError。 123456789class MyClass: def __init__(self): self.name = &quot;ChatGPT&quot;try: obj = MyClass() print(obj.age) # obj没有定义age属性except AttributeError: print(&quot;属性不存在&quot;) FileNotFoundError在尝试打开一个不存在的文件时，Python 3中会引发FileNotFoundError，这是OSError的一个子类。 12345try: with open(&quot;some_nonexistent_file.txt&quot;) as f: content = f.read()except FileNotFoundError: print(&quot;文件未找到&quot;) ImportError当尝试导入一个不存在的模块时，会引发ImportError。 1234try: import non_existent_moduleexcept ImportError: print(&quot;模块无法导入&quot;) OverflowError当一个算术运算产生的结果太大而无法表示时，会引发OverflowError。 123456import mathtry: # 这可能会引发OverflowError print(math.exp(1000))except OverflowError: print(&quot;数值溢出&quot;) NameError当尝试访问一个尚未声明&#x2F;定义的局部或全局变量时，会引发NameError。 1234try: print(undefined_variable)except NameError: print(&quot;变量未定义&quot;) RecursionError当递归过深超过最大递归深度时，会引发RecursionError。这是RuntimeError的一个子类。 1234567def recursive_function(): recursive_function()try: recursive_function()except RecursionError: print(&quot;递归过深&quot;) 这些例子涵盖了Python中的一些其他常见异常类型。理解和处理这些异常对于编写稳健的Python程序至关重要。 SyntaxError当Python解释器遇到语法错误时，会引发SyntaxError。这通常发生在代码编写不正确时。 1234try: exec(&quot;for i in range(5) print(i)&quot;) # 缺少冒号except SyntaxError: print(&quot;发生了语法错误&quot;) IndentationError当代码的缩进不正确时，会引发IndentationError，这是SyntaxError的一个子类。 1234try: exec(&quot;def foo():\\nprint(&#x27;Hello&#x27;)&quot;)except IndentationError: print(&quot;缩进错误&quot;) AssertionError当assert语句失败时，会引发AssertionError。assert用于调试阶段的自我检查。 12345try: assert 2 + 2 == 5, &quot;计算错误&quot;except AssertionError as e: print(&quot;断言错误:&quot;, e) KeyboardInterrupt当用户中断程序执行（通常是通过按Ctrl+C），会引发KeyboardInterrupt。 12345try: while True: continueexcept KeyboardInterrupt: print(&quot;程序被用户中断&quot;) MemoryError当程序运行时内存不足，无法执行操作时，会引发MemoryError。 1234try: large_list = [0] * 10**10except MemoryError: print(&quot;内存不足&quot;) StopIteration在使用迭代器时，当没有更多的项可以返回时，会自动引发StopIteration。 12345678iterator = iter([1, 2, 3])next(iterator) # 1next(iterator) # 2next(iterator) # 3try: next(iterator) # 迭代完毕except StopIteration: print(&quot;迭代器没有更多元素&quot;) EnvironmentErrorEnvironmentError是在与外部环境（如操作系统）交互时可能遇到的错误的基类。在Python 3中，它被分为更具体的异常，如OSError。 其它这并不是一个完整的列表： ArithmeticError: 所有数值计算错误的基类。 BufferError: 与缓冲区相关的操作无法执行时。 EOFError: 当input()遇到文件结束标记（EOF）时。 FloatingPointError: 浮点计算错误。 LookupError: 索引或键查询错误的基类，IndexError和KeyError是它的子类。 ReferenceError: 当试图访问一个已经被垃圾回收器回收的资源时。 RuntimeError: 通常发生在检测到不属于其他类别的错误时。 SystemError: 解释器系统错误。 UnicodeError: Unicode相关的错误，是ValueError的一个子类。 UnicodeEncodeError: Unicode编码时的错误。 UnicodeDecodeError: Unicode解码时的错误。 UnicodeTranslateError: Unicode转换时的错误。 异常处理的语法123456789101112131415161718192021try: # 尝试执行的代码 passexcept ExceptionType1: # 处理ExceptionType1 passexcept ExceptionType2: # 处理ExceptionType2 passexcept (ExceptionType3, ExceptionType4): # 处理多种异常 passexcept: # 处理未指定的其他异常 passelse: # 如果没有异常发生，则执行此处代码 passfinally: # 无论是否有异常，都会执行此处代码 pass 捕获特定异常在Python中，可以使用try-except块来捕获特定类型的异常。这允许您对特定错误进行专门的错误处理。 12345try: # 可能会引发异常的代码 result = 10 / 0except ZeroDivisionError: print(&quot;捕获到除以零的异常&quot;) 捕获所有异常捕获所有异常并且仅打印出错误信息，可以使用一个通用的 except Exception as e 块。这将捕获所有继承自 Exception 的错误（几乎包括了Python中所有的标准异常） 12345try: # 可能会引发异常的代码 result = 10 / 0except Exception as e: print(f&quot;发生错误: &#123;e&#125;&quot;) 使用finally块无论是否发生异常，finally块中的代码都会被执行。这非常适合用来执行清理操作，如关闭文件或释放资源。 12345678try: file = open(&quot;test.txt&quot;, &quot;r&quot;) data = file.read()except IOError as e: print(f&quot;读取文件时发生错误：&#123;e&#125;&quot;)finally: file.close() print(&quot;文件已关闭&quot;) 主动抛出异常可以使用raise语句来主动引发异常。这在需要根据特定条件显式地触发错误时非常有用。 123456789101112def check_age(age): if age &lt; 0: raise ValueError(&quot;年龄不能为负数&quot;) elif age &lt; 18: print(&quot;未成年&quot;) else: print(&quot;成年&quot;)try: check_age(-5)except ValueError as e: print(f&quot;捕获到异常：&#123;e&#125;&quot;) 使用断言（assert）断言是一种调试辅助工具，用于检查一个条件是否为真。如果条件为假，将引发AssertionError。 12345678def check_age(age): assert age &gt;= 0, &quot;年龄不能为负数&quot; # 其余处理try: check_age(-5)except AssertionError as e: print(f&quot;捕获到异常：&#123;e&#125;&quot;) 信息 断言：通常用于内部一致性检查，表示“这里不可能出错，除非程序内部逻辑有问题”。 异常：更适合于处理程序执行过程中可能遇到的预期错误情况，例如不满足输入条件、资源不可用等。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基本语法","slug":"基本语法","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"异常","slug":"异常","permalink":"https://www.yiuhangblog.com/tags/%E5%BC%82%E5%B8%B8/"},{"name":"断言","slug":"断言","permalink":"https://www.yiuhangblog.com/tags/%E6%96%AD%E8%A8%80/"}],"author":"Yiuhang Chan"},{"title":"文件系统","slug":"20180928文件系统","date":"2018-09-28T10:08:12.000Z","updated":"2024-02-28T10:49:13.000Z","comments":true,"path":"2018/09/28/20180928文件系统/","permalink":"https://www.yiuhangblog.com/2018/09/28/20180928%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"Python 持久化存储 OS模块","text":"文件系统持久化存储在Python中，持久化存储是指将数据保存到一个持久的存储介质（如硬盘）中，以便即使在程序结束后也能再次访问这些数据。Python提供了多种方式来实现数据的持久化存储，包括但不限于文件存储、使用数据库以及利用特定的数据序列化格式。以下是一些常见的Python数据持久化方法： 1. 使用文件系统最基本的持久化存储方法是直接读写文件。Python提供了多种方式来处理文件，包括文本文件和二进制文件。 1234567# 写入文本文件with open(&#x27;example.txt&#x27;, &#x27;w&#x27;) as file: file.write(&#x27;Hello, world!&#x27;)# 读取文本文件with open(&#x27;example.txt&#x27;, &#x27;r&#x27;) as file: content = file.read() 警告 出现的 UnicodeEncodeError 错误通常与编码有关。当尝试将包含非ASCII字符的字符串写入文件时，在某些情况下，Python的默认编码（如cp1252）可能无法正确处理这些字符。要解决这个问题，可以在写入文件时明确指定一个能够处理这些字符的编码，如UTF-8。 可以通过在 open 函数中添加 encoding=&#39;utf-8&#39; 参数来修改代码。这将确保使用UTF-8编码来写入文件，UTF-8编码可以处理大多数字符集。 2. 数据序列化Python提供了几种数据序列化（转换数据结构为可存储或传输的格式）的方法，例如JSON、Pickle等。 JSON：用于将数据结构转换为JSON格式。 12345678910import jsondata = &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;&#125;# 序列化到文件with open(&#x27;data.json&#x27;, &#x27;w&#x27;) as json_file: json.dump(data, json_file)# 从文件反序列化with open(&#x27;data.json&#x27;, &#x27;r&#x27;) as json_file: data = json.load(json_file) Pickle：用于Python对象的序列化，可以序列化几乎所有的Python对象类型。 123456789import pickle# 序列化到文件with open(&#x27;data.pkl&#x27;, &#x27;wb&#x27;) as pkl_file: pickle.dump(data, pkl_file)# 从文件反序列化with open(&#x27;data.pkl&#x27;, &#x27;rb&#x27;) as pkl_file: data = pickle.load(pkl_file) 3. 使用数据库对于复杂的数据持久化需求，常常会使用数据库。Python提供了许多连接和操作数据库的库，支持包括SQLite、MySQL、PostgreSQL等多种数据库。 SQLite（使用标准库sqlite3）： 123456789101112131415import sqlite3# 连接到SQLite数据库# 数据库文件是&#x27;data.db&#x27;conn = sqlite3.connect(&#x27;data.db&#x27;)# 创建一个Cursor对象cursor = conn.cursor()# 执行一个查询cursor.execute(&#x27;SELECT * FROM table_name&#x27;)# 关闭Cursor和Connectioncursor.close()conn.close() 4. ORM（对象关系映射）ORM框架如SQLAlchemy或Django ORM允许开发者以面向对象的方式来操作数据库，而无需直接编写SQL语句。 123456789101112131415161718192021from sqlalchemy import create_engine, Column, Integer, Stringfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerBase = declarative_base()class User(Base): __tablename__ = &#x27;users&#x27; id = Column(Integer, primary_key=True) name = Column(String)engine = create_engine(&#x27;sqlite:///data.db&#x27;)Base.metadata.create_all(engine)Session = sessionmaker(bind=engine)session = Session()new_user = User(name=&#x27;John Doe&#x27;)session.add(new_user)session.commit()session.close() 总结Python的数据持久化选项非常多样，可以根据具体的应用场景和需求选择最合适的方法。对于简单的数据存储，文件读写或使用JSON、Pickle等序列化方式可能就足够了。对于更复杂的数据和需求，使用数据库和ORM框架可能是更好的选择 文件操作open 函数及其模式 &#39;r&#39;模式：以只读方式打开文件。 12with open(&#x27;file.txt&#x27;, &#x27;r&#x27;) as file: content = file.read() &#39;w&#39;模式：以写入方式打开文件，如果文件存在则覆盖，不存在则创建。 12with open(&#x27;file.txt&#x27;, &#x27;w&#x27;) as file: file.write(&#x27;Hello, World!&#x27;) &#39;a&#39;模式：以写入方式打开文件，如果文件存在，则在文件末尾追加内容。 12with open(&#x27;file.txt&#x27;, &#x27;a&#x27;) as file: file.write(&#x27;Append content&#x27;) &#39;r+&#39;模式：以读写方式打开文件。 &#39;w+&#39;模式：以读写方式打开文件，如果文件存在则覆盖，不存在则创建。 &#39;a+&#39;模式：以读写方式打开文件，如果文件存在，则在文件末尾追加内容。 二进制模式（在模式字符串中加入&#39;b&#39;），例如&#39;rb&#39;, &#39;wb&#39;, &#39;ab&#39;, &#39;rb+&#39;, &#39;wb+&#39;, &#39;ab+&#39;，用于非文本文件。 信息 r - 这个模式代表“只读”模式。当你打开一个文件进行读取时，如果没有指定特定的模式，Python会默认使用这个模式。在这种模式下，只能从文件中读取数据，而不能写入或修改数据。如果文件不存在，尝试以这种模式打开文件会导致错误。 文件操作 file.read()：读取整个文件。 file.write()：写入字符串到文件。 file.tell()：返回文件的当前位置。 file.seek(offset)：改变文件的当前位置。 file.close()：关闭文件。通常与with语句一起使用，可以省略。 with 上下文管理器使用with上下文管理器可以保证即使在发生异常时文件资源也能被正确释放。 12with open(&#x27;file.txt&#x27;, &#x27;r&#x27;) as file: content = file.read() os 模块函数 os.getcwd()：返回当前工作目录。 123import oscwd = os.getcwd()print(cwd) os.listdir()：返回指定目录下的文件和子目录列表。 12entries = os.listdir(cwd)print(entries) os.mkdir()：创建新目录。 1os.mkdir(&#x27;new_directory&#x27;) os.rmdir()：删除目录。 1os.rmdir(&#x27;new_directory&#x27;) os.remove()：删除文件。 1os.remove(&#x27;file.txt&#x27;) os.rename()：重命名文件或目录。 1os.rename(&#x27;old_name.txt&#x27;, &#x27;new_name.txt&#x27;)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基本语法","slug":"基本语法","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"持久化存储","slug":"持久化存储","permalink":"https://www.yiuhangblog.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"},{"name":"os模块","slug":"os模块","permalink":"https://www.yiuhangblog.com/tags/os%E6%A8%A1%E5%9D%97/"}],"author":"Yiuhang Chan"},{"title":"New方法、单例模式、装饰器","slug":"20180915New单例模式装饰器","date":"2018-09-15T09:24:27.000Z","updated":"2024-02-28T10:49:10.000Z","comments":true,"path":"2018/09/15/20180915New单例模式装饰器/","permalink":"https://www.yiuhangblog.com/2018/09/15/20180915New%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"Python New方法、单例模式、装饰器","text":"类中的_ _new_ _(魔术方法&#x2F;构造器)在Python中，__new__方法确实是一个特别的方法，但它和__init__方法有着明显的区别。__new__是一个静态方法（虽然通常不明确地声明为静态方法），而__init__是一个实例方法。 _ _new_ _方法的作用__new__方法主要用于创建一个新的实例对象。它是类的一个静态方法，即便不明确声明也是如此。__new__在__init__方法之前被调用，用于生成实例对象。通常情况下，我们不需要自己编写__new__方法，但在某些特殊情况下，修改__new__方法能够提供额外的灵活性。 _ _new_ _ 方法的基本结构12345class MyClass(object): def __new__(cls, *args, **kwargs): # 创建对象的逻辑 instance = super(MyClass, cls).__new__(cls, *args, **kwargs) return instance 类定义1class MyClass(object): 这行代码定义了一个名为MyClass的新类，它继承自Python内置的object类。在Python 3中，所有的类默认继承自object，所以即使不显式地继承，它仍然会继承自object。 _ _new_ _ 方法1def __new__(cls, *args, **kwargs): 这是__new__方法的定义。__new__是一个特殊方法，用于在一个对象实例化时创建并返回这个对象。 cls：这个参数是对当前类MyClass的引用，这与实例方法中的self参数类似，但cls是在对象创建之前使用的。 *args和**kwargs：这两个参数允许传递任意数量的位置参数和关键字参数。这些参数将会被传递给__init__方法。 创建实例的逻辑1instance = super(MyClass, cls).__new__(cls, *args, **kwargs) 这行代码是创建类实例的核心。 super(MyClass, cls)：这部分调用了MyClass的父类的方法。在这个例子中，父类是object。super函数是用来获取父类定义，以便调用其方法的一种方式。 .__new__(cls, *args, **kwargs)：这部分实际上调用了父类object的__new__方法，并传递了必要的参数。这个调用负责创建一个新的实例。 instance：__new__方法返回的是一个实例对象，这里我们将其赋值给变量instance。 返回实例1return instance 最后，__new__方法返回了新创建的实例instance。这个实例接下来将被用来调用__init__方法，以便进行进一步的初始化。 总结这个MyClass类示例展示了如何在Python中自定义__new__方法。通常，不需要重写__new__，除非有改变实例创建方式的特殊需求，比如实现单例模式、返回一个不同的类的实例或者在创建实例之前做一些额外的操作。在大多数情况下，只需要关注__init__方法来初始化实例。 使用场景__new__方法通常在下面的情况下使用： 单例模式：确保一个类只有一个实例。 不可变类型的子类：例如扩展某些内置不可变类型，如tuple或str。 控制实例的创建：在某些复杂的情况下，可能需要在对象创建时进行额外的处理。 单例模式单例模式是一种常见的软件设计模式，其核心思想是确保一个类在应用程序中只有一个实例，并提供一个全局访问点来获取这个实例。这种模式在需要控制资源的访问或管理共享资源时特别有用，如数据库连接或文件系统的操作。 单例模式的特点 唯一实例：单例类只允许创建一个实例。 全局访问点：单例类提供一个全局访问的方法，全局的代码都可以通过这个方法访问到这个唯一实例。 自我管理：单例类负责创建、初始化和管理自己的唯一实例。 Python中实现单例模式在Python中，单例模式可以通过多种方法实现，如使用模块级别的变量、装饰器、元类或重写__new__方法等。以下是通过重写__new__方法实现单例模式的一个示例： 1234567class Singleton: _instance = None def __new__(cls): if cls._instance is None: cls._instance = super(Singleton, cls).__new__(cls) return cls._instance 类变量_instance用于存储类的唯一实例。 在__new__方法中，首先检查_instance是否已经被创建。如果没有，则创建一个新实例并将其赋值给_instance。 之后的所有实例化操作都将返回这个已创建的实例。 单例模式的使用场景单例模式通常用于以下场景： 管理共享资源，如数据库连接、日志记录、配置信息等。 控制资源的访问，确保资源的一致性和状态的同步。 减少资源的重复创建和销毁，提高效率。 注意事项 单例模式在多线程环境下可能需要特别的处理来保证线程安全。 过度使用单例模式可能导致代码间的耦合度过高，应当谨慎使用。 在分布式系统中，单例模式的使用需要考虑到进程间的通信和资源共享的问题。 单例模式是一种简单但强大的设计模式，能够有效地管理共享资源和全局状态，但也需要注意其带来的限制和潜在问题。 私有属性在Python中，私有属性（Private Attributes）是指仅能在其所属的类内部访问的属性，而无法从类外部直接访问。这是面向对象编程中封装的一个重要概念，用于隐藏类的内部实现细节，并保护类的状态免受外部干扰。 如何定义私有属性在Python中，私有属性通常是通过在属性名前加上双下划线（__）来定义的。 123class MyClass: def __init__(self): self.__private_attribute = 42 在这个例子中，__private_attribute就是一个私有属性。由于它的名字以双下划线开头，它只能在MyClass内部访问。 访问和修改私有属性私有属性只能在定义它们的类的内部访问和修改。如果你试图从类外部访问或修改这些属性，将会导致AttributeError。 12obj = MyClass()print(obj.__private_attribute) # 将引发错误 要在类外部访问或修改私有属性的值，你需要在类内部提供公共的方法（例如getter和setter方法）。 12345678910111213class MyClass: def __init__(self): self.__private_attribute = 42 def get_private_attribute(self): return self.__private_attribute def set_private_attribute(self, value): self.__private_attribute = valueobj = MyClass()print(obj.get_private_attribute()) # 正确obj.set_private_attribute(100) # 正确 名称改写（Name Mangling）在Python中，私有属性的名称实际上会被改写，这个过程称为名称改写（Name Mangling）。Python解释器自动地把属性名__private_attribute转换为_MyClass__private_attribute。这意味着理论上你可以通过改写过的名称来访问私有属性，但这并不是一个好的做法，因为它违反了封装的原则。 1print(obj._MyClass__private_attribute) # 可行，但不推荐 为什么使用私有属性使用私有属性的主要理由是封装和抽象。通过限制对类内部状态的直接访问，你可以防止外部代码无意中破坏类的内部状态，从而保持对象的完整性和一致性。 总结私有属性是面向对象编程中的一个重要概念，它有助于实现封装和数据隐藏。在Python中，私有属性通过在属性名前加双下划线来定义，并且只能通过类内部定义的方法进行访问和修改。尽管技术上可以通过名称改写访问私有属性，但这并不符合封装的原则，应当避免这样做 装饰器装饰器（Decorators）是Python中一个非常强大且有用的功能，它们允许程序员修改或增强函数和方法的行为，而不需要改变其本身的代码。装饰器在很多高级Python应用中都有广泛的使用，如Web框架、事件监听、日志处理等。 装饰器的基本原理在Python中，装饰器本质上是一个Python函数，它可以接收一个函数作为参数并返回一个新的函数。使用装饰器可以在不修改原函数的情况下，增加额外的功能。 1234567891011def my_decorator(func): def wrapper(): print(&quot;Something is happening before the function is called.&quot;) func() print(&quot;Something is happening after the function is called.&quot;) return wrapperdef say_hello(): print(&quot;Hello!&quot;)say_hello = my_decorator(say_hello) 在上面的例子中，my_decorator是一个装饰器，它在say_hello函数前后添加了额外的打印操作。 使用@语法糖Python提供了一个简单的方式来应用装饰器，即使用@符号，这也被称为语法糖。这让代码更加简洁易读。 123@my_decoratordef say_hello(): print(&quot;Hello!&quot;) 使用@my_decorator语法，上面的代码与之前例子中的功能完全相同。 带参数的装饰器装饰器也可以带参数，这需要在其外层再加一层函数。这种装饰器也称为装饰器工厂。 123456789101112def repeat(number=3): def decorator_repeat(func): def wrapper(*args, **kwargs): for _ in range(number): value = func(*args, **kwargs) return value return wrapper return decorator_repeat@repeat(number=4)def greet(name): print(f&quot;Hello &#123;name&#125;&quot;) 在这个例子中，repeat是一个带参数的装饰器，它接受一个参数number，指定了函数执行的次数。 装饰器的用途 日志记录：添加日志功能，以跟踪函数的调用细节。 性能测试：检测函数执行时间，用于性能优化。 权限验证：检查用户是否有权执行某个操作。 缓存：缓存函数的返回结果，提高程序性能。 总结装饰器是Python中非常有用的工具，可以在不修改原有函数代码的情况下，给函数增加新的功能。它通过语法简单但功能强大的方式，提高了代码的可读性和可维护性。在Python的日常使用中，熟练运用装饰器是一个非常有价值的技能。 信息 在Python中，装饰器的实现通常依赖于闭包的概念。 闭包（Closure）简介 闭包是一种在动态编程语言中常见的概念，它指的是一个函数记住了它的词法作用域，即使这个函数在自己的词法作用域之外执行。在Python中，闭包表现为一个内嵌函数记住了其外部函数的状态或环境。 装饰器中的闭包 在装饰器中使用闭包，是为了在装饰器函数内创建一个包装函数（wrapper），这个包装函数能够记住并访问其外部函数（即装饰器函数）的变量和参数。这使得装饰器能够在不修改被装饰函数的情况下增加额外的功能。 my_decorator 是一个装饰器函数。 wrapper 是一个内嵌函数，它是闭包的体现。wrapper 能够记住并访问func，即使在my_decorator函数的执行已经完成之后。 当我们使用@my_decorator装饰say_hello函数时，实际上是将say_hello作为参数传递给了my_decorator，并将返回的wrapper函数赋值给了say_hello。 闭包的作用 闭包在装饰器中的主要作用是让我们能够延伸或修改函数的行为。闭包使得装饰器内部的包装函数能够访问到装饰器接收的原始函数，从而在不改变原始函数定义的前提下，对其进行包装，增加额外的操作和逻辑。 总结 简言之，装饰器中的闭包是Python中一种强大的函数式编程特性，它允许内嵌函数捕获并保持外部函数的状态，从而使得我们可以在不修改原函数的情况下，为其增加新的功能。这种特性在Python中广泛用于日志记录、性能测试、权限校验等场景。 详见函数篇 闭包","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基本语法","slug":"基本语法","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"装饰器","slug":"装饰器","permalink":"https://www.yiuhangblog.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"new方法","slug":"new方法","permalink":"https://www.yiuhangblog.com/tags/new%E6%96%B9%E6%B3%95/"},{"name":"私有属性","slug":"私有属性","permalink":"https://www.yiuhangblog.com/tags/%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7/"},{"name":"单列模式","slug":"单列模式","permalink":"https://www.yiuhangblog.com/tags/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F/"}],"author":"Yiuhang Chan"},{"title":"面向对象","slug":"20180908面向对象","date":"2018-09-08T04:13:23.000Z","updated":"2024-02-28T10:49:07.000Z","comments":true,"path":"2018/09/08/20180908面向对象/","permalink":"https://www.yiuhangblog.com/2018/09/08/20180908%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"Python 面对像基础","text":"核心概念面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，它使用“对象”来设计软件。这种方法不仅侧重于数据（即属性），还侧重于操作这些数据的代码（即方法）。面向对象编程基于几个核心概念，包括类、对象、继承、多态和封装。 类（Class）：类是创建对象的蓝图或模板。它定义了对象的属性和方法。属性是类中的变量，方法是类中的函数。类本身不占用内存空间，它只是定义了对象的结构。 对象（Object）：对象是类的实例。当类被实例化时，会创建一个对象。对象具有类定义的属性和方法。每个对象都有自己的属性值，但共享相同的方法。 继承（Inheritance）：继承允许一个类继承另一个类的属性和方法。这有助于代码重用，并实现多层次的分类。在继承关系中，有基类（父类）和派生类（子类）。 多态（Polymorphism）：多态是指即使不同类的对象可能有不同的实现，但它们可以通过相同的接口进行交互。这意味着，可以用统一的方式来处理不同类的对象，即使它们具有不同的内部结构。 封装（Encapsulation）：封装是隐藏对象内部实现细节的过程，仅公开必要的接口。这有助于防止外部代码随意更改对象内部状态，从而保护对象的完整性并简化接口。 抽象（Abstraction）：抽象是将复杂的现实世界问题简化为模型的过程。在面向对象编程中，这通常意味着创建类，这些类代表了现实世界中的实体或概念，但只包括与当前问题相关的部分。 优点 模块化：OOP 促进了代码的模块化，使得不同模块可以独立开发和测试，提高了代码的可维护性和复用性。 可扩展性：通过继承和多态，可以在现有代码的基础上添加新功能，而不必大幅修改现有代码。 可维护性：封装提供了一种方式，使得代码更易于理解和维护。 缺点 性能：相较于面向过程的编程，面向对象的程序可能在性能上稍微逊色，因为它需要额外的内存和处理。 复杂性：面向对象的系统可能比简单的面向过程的系统更复杂。 应用面向对象编程在软件工程中广泛应用，从桌面和移动应用程序到大型企业级系统。众多流行的编程语言，如 Java、C#、Python、Ruby 和 C++，都支持面向对象的编程范式。 类 (Class)类（Class）是面向对象编程（OOP）中的一个核心概念。在很多现代编程语言中，类作为一种构造，提供了一种封装数据和行为（即代码）的方式。它们允许开发者创建复杂的数据结构 类的定义首先，我们定义一个名为Car的类： 1234567891011121314151617class Car: # 这些是成员属性 brand = None color = None speed = 0 # 这是一个成员方法 def start(self): print(f&quot;&#123;self.brand&#125;车启动了。&quot;) def accelerate(self, increase): self.speed += increase print(f&quot;&#123;self.brand&#125;车加速到了&#123;self.speed&#125;公里/小时。&quot;) def brake(self): print(f&quot;&#123;self.brand&#125;车正在刹车。&quot;) self.speed = 0 在这个Car类中： 成员属性：brand（品牌）、color（颜色）和speed（速度）是类的属性。它们用来描述这个类的状态。 成员方法：start、accelerate 和 brake 是类的方法。它们描述了Car可以执行的操作。 实例化类接下来，我们创建几个Car类的实例： 1234567891011first_car = Car() # 实例化第一辆车first_car.brand = &#x27;Toyota&#x27;first_car.color = &#x27;红色&#x27;first_car.start()first_car.accelerate(30)second_car = Car() # 实例化第二辆车second_car.brand = &#x27;Ford&#x27;second_car.color = &#x27;蓝色&#x27;second_car.start()second_car.accelerate(40) 每次调用Car()时，我们都创建了一个新的Car类的实例（即一个新的汽车对象）。通过为不同的实例分别设置属性（如brand和color），每辆车都有自己的特点。 QA 问： 通过类名()可以实例化一个对象吗？ 答： 在Python中，你可以通过调用类名并传递所需的参数（如果有的话）来创建（实例化）一个类的实例。例如，如果有一个名为 MyClass 的类，可以通过 my_instance = MyClass() 来创建这个类的一个实例。 问： 类具有属性和方法吗？ 答： 在Python中，类可以拥有属性（有时称为数据成员）和方法（类内定义的函数）。属性用于保存数据值，而方法用于定义对象可以执行的操作。 问： 一个类只能创建一个对象吗？ 答： 这个说法是错误的。一个类可以用来创建任意数量的对象。每个对象都是类的实例，拥有自己的属性集和方法。例如，如果有一个 Dog 类，可以用它来创建许多 Dog 实例，每个实例代表一个不同的狗。 问： 对象是一个实体吗？ 答： 在编程中，对象通常指的是一个具体的实例，它由类创建。对象是类定义的实体的具体表现。它拥有类中定义的属性和方法。 成员方法中的self在Car类的成员方法中，self关键字是对当前对象实例的引用。它用于访问对象的属性和调用其他方法。例如，在accelerate方法中，self.speed += increase表示将当前车辆的速度增加increase单位。 _ _init_ _初始化方法(魔术方法&#x2F;构造器)__init__ 是一个在 Python 中特别重要的方法，它是类的一个特殊方法（有时被称为“魔术方法”或“构造器”）。当创建类的新实例时，__init__ 方法被自动调用，用于为新创建的对象初始化其属性或执行其他必要的设置。以下是关于 __init__ 方法的一些关键点： 构造器：__init__ 方法可以看作是类的“构造器”。它在对象创建时立即执行，允许类接受参数并据此初始化对象的属性。 self 参数：__init__ 方法的第一个参数总是 self，它是对类实例本身的引用。通过 self，可以在方法内部访问类的属性和其他方法。 初始化属性：可以在 __init__ 方法中定义并初始化对象的属性。这样做的好处是，可以为不同的对象实例设置不同的初始状态。 接受参数：__init__ 方法可以接受参数（除了自身 self 参数外），这些参数在创建类实例时传递给它，用于设置对象的属性或进行其他操作。 12345678910111213141516171819202122232425262728class Car: # 使用 __init__ 方法初始化成员属性 def __init__(self, brand, color): self.brand = brand self.color = color self.speed = 0 # 成员方法 def start(self): print(f&quot;&#123;self.brand&#125;车启动了。&quot;) def accelerate(self, increase): self.speed += increase print(f&quot;&#123;self.brand&#125;车加速到了&#123;self.speed&#125;公里/小时。&quot;) def brake(self): print(f&quot;&#123;self.brand&#125;车正在刹车。&quot;) self.speed = 0# 使用 __init__ 方法实例化第一辆车first_car = Car(&#x27;Toyota&#x27;, &#x27;红色&#x27;)first_car.start()first_car.accelerate(30)# 使用 __init__ 方法实例化第二辆车second_car = Car(&#x27;Ford&#x27;, &#x27;蓝色&#x27;)second_car.start()second_car.accelerate(40) 在这个例子中， Car 类中添加了 __init__ 方法，它接受 brand 和 color 作为参数，并将它们分别赋值给实例的 brand 和 color 属性。现在，在创建 Car 类的实例时，我们需要提供品牌和颜色作为参数。这样一来，每个 Car 实例在创建时都会有自己的品牌和颜色属性。 QA 问：为什么accelerate不在car(brand, color)里直接写？ 答：将 accelerate 方法放在 Car 类的构造方法 (__init__) 中与放在类的外部作为一个独立的方法有不同的含义和用途。理解这一点，需要对面向对象编程中的一些基本概念有所了解： 构造方法 (__init__): __init__ 方法用于初始化新创建的对象的状态。它通常用于设置对象的初始属性值。构造方法在对象被创建时自动调用一次，用于设置对象的初始状态。 成员方法: 类中定义的其他方法（如 accelerate）用于描述对象的行为。这些方法可以在对象的整个生命周期内被多次调用，并且通常用于执行特定的操作，比如修改对象的状态或者与其他对象进行交互。 职责分离: 在面向对象设计中，通常推荐遵循单一职责原则。这意味着每个部分（如方法）应该只负责一项功能。将 accelerate 方法放在类的外部作为一个独立的方法，而不是在 __init__ 中定义，可以使类的结构更加清晰，每个方法的职责更加明确。 灵活性与可重用性: 将 accelerate 作为独立的方法可以在任何时候调用以改变对象的速度属性。如果它被放在 __init__ 中，它只能在对象创建时执行，这限制了方法的用途。 总结来说，accelerate 不放在 __init__ 中是为了保持代码的清晰性和组织性，确保每个方法只负责一项特定的功能，并允许在对象的生命周期中多次调用 accelerate 方法。这是一种更灵活、可维护和符合面向对象设计原则的做法。 问：self.speed = 0 为什么在(__init__) 里？ 答：将 self.speed = 0 放在 __init__ 方法中是为了初始化 Car 类的每个实例的速度属性。这是一种常见的做法，用于设定对象的初始状态。以下是放置这个语句在 __init__ 中的几个理由： 初始状态设定：在面向对象编程中，构造方法（如 Python 中的 __init__）用于设定对象的初始状态。对于汽车来说，初始速度设为 0 是合理的，因为当汽车被“创建”（或实例化）时，它通常是静止的。 统一属性管理：将所有属性的初始化集中在 __init__ 方法中可以使代码更加清晰和易于维护。这样，可以在一个地方看到对象所有属性的初始值。 确保属性存在：在 __init__ 方法中初始化 speed 确保了每个 Car 实例都具有 speed 属性，并且有一个明确的初始值。这避免了在其他方法（如 accelerate 或 brake）中使用 speed 属性之前需要检查其是否存在的情况。 避免未初始化的属性：如果不在 __init__ 中初始化 speed，那么在调用 accelerate 方法之前，尝试访问 speed 属性可能会导致错误，因为 Python 不会自动创建这个属性。 综上所述，将 self.speed = 0 放在 __init__ 方法中是为了初始化对象的速度属性，保证对象的完整性，并为后续的操作（如加速或刹车）提供一个明确和稳定的起点。 案例类定义与初始化首先，我们定义一个名为Car的类，并在其中使用__init__方法来初始化类的实例。__init__是一个特殊的方法，它在类的实例化时自动调用。我们可以通过它来设置初始的成员属性。 1234567891011121314class Car: # 使用 __init__ 方法初始化成员属性 def __init__(self, brand, color, weight): # self.brand 创建了一个名为 brand 的属性 # brand = None 的效果类似于此 # self.brand = brand 用传入的参数 brand 初始化 self.brand = brand # 同理，为 color 和 weight 属性赋值 self.color = color self.weight = weight # 定义一个成员方法用于显示汽车的信息 def display_info(self): print(f&quot;这辆车是 &#123;self.color&#125;色的 &#123;self.brand&#125;，重 &#123;self.weight&#125;公斤。&quot;) 实例化类当我们实例化这个类时，我们需要提供品牌、颜色和重量这三个参数。 1234# 实例化 Car 类first_car = Car(&quot;Toyota&quot;, &quot;红色&quot;, 1500)# 调用方法显示信息first_car.display_info() 这里，first_car 是 Car 类的一个实例，代表了一辆特定的汽车。我们给它赋予了“Toyota”品牌、“红色”颜色和1500公斤重量的属性，并通过display_info方法打印了这些信息。 总结通过修改这个例子，我们可以看到如何在类中使用初始化方法（__init__）来设置对象的初始状态，并通过实例化这个类来创建具体的对象。每个对象都有自己的属性值，但它们共享相同的方法（如display_info）。 QA 问：以女娲造人为例子 什么是类？ 什么是实例化类？ 什么是面向对象？ 答： 什么是类？ 在女娲造人的故事中，女娲的想法或设计可以被看作是一个“类”（Class）。这个类是一个抽象的概念，它定义了人类将拥有的特征（如眼睛、鼻子、嘴巴）和行为（如走路、说话）。类是面向对象编程中定义数据结构和行为的蓝图或模板。 什么是实例化类？ 当女娲根据她的想法创造出一个具体的人时，这个过程就像是在面向对象编程中的“实例化”（Instantiation）。实例化类的过程就是根据类的定义创建一个具体的对象（在这个故事中就是一个具体的人）。每个人（对象）都有类定义的特征和行为，但每个人也有自己的个性（即对象的状态可以独立于其他对象）。 什么是面向对象？ 面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，它使用对象来模拟现实世界的实体。在女娲造人的故事中，整个造人过程（设计-创造-赋予行为）就类似于面向对象的过程。面向对象编程的核心是类和对象，以及它们之间的交互。 问：面向对象的好处是什么？我们以后开发代码需要怎么做？ 答： 好处 封装：面向对象允许封装数据和方法，提高数据安全性。 继承：通过继承，新的类可以扩展现有类的功能。 多态：相同的接口可以用在不同的对象上，提高代码的灵活性和可重用性。 代码组织和可读性：OOP 提高了代码的组织性和可读性，使大型项目更易于管理。 开发时的做法 使用类和对象来模拟现实世界的实体和概念。 封装相关的属性和方法，确保数据安全性和减少外部干扰。 通过继承和多态性来重用代码和提高代码的灵活性。 关注对象之间的交互，而不仅仅是代码的执行流程。 问： self 在初始化__init__的作用是什么？ 在普通方法中的作用是什么？ 答： 在 __init__ 方法中 self 在 __init__ 方法中代表新创建的对象本身。 它用于初始化对象的属性。 通过 self，可以将对象的属性与局部变量区分开来。 在普通方法中 self 在类的其他方法中也代表对象本身。 它用于访问和修改对象的属性。 同样，self 用于调用对象的其他方法。 简而言之，self 是类方法中的一个参数，它提供了对类实例本身的引用。这允许类的方法在操作对象时访问和修改对象的属性，以及调用其他方法。 问：请根据闹钟 来写一个类 并创造三个闹钟 123456789101112131415161718192021222324252627282930313233343536from datetime import datetimefrom playsound import playsound# print(current_time) 测试格式class Alarm: # 使用init方法初始化成员属性 def __init__(self, time, music): self.time = time # time 是字符串格式 &#x27;HH:MM:SS&#x27; self.music = music # 成员方法 def sound(self): # 一些写音乐文件调用的逻辑 playsound(self.music) # 播放歌曲 print(f&quot;&#123;self.music&#125; has been played&quot;) def clock(self): # 调用当前当前时间 current_time = datetime.now().strftime(&#x27;%H:%M:%S&#x27;) if self.time == current_time: Alarm.sound(self) print(f&quot;&#123;self.time&#125;, time to wake up !&quot;) # 起床 else: print(f&quot;Current time is &#123;current_time&#125;, wake up at &#123;self.time&#125;&quot;) # 报时# 实例化first_alarm = Alarm(&#x27;15:46:25&#x27;, &#x27;test1.mp3&#x27;)second_alarm = Alarm(&#x27;22:06:50&#x27;, &#x27;test2.mp3&#x27;)third_alarm = Alarm(&#x27;05:10:33&#x27;, &#x27;test3.mp3&#x27;)# 调用 clock 方法first_alarm.clock()second_alarm.clock()third_alarm.clock() 面向对象的特点封装 (Encapsulation)封装是面向对象编程中的一个核心概念，它指的是将对象的数据（属性）和行为（方法）组合在一起，形成一个独立的单元。在封装过程中，可以对对象的成员进行访问限制。 私有属性 (Private Attributes) 属性名前加了两个下划线表示它是私有属性，只能在类的内部被访问。 作用: 不能被外部直接访问 self.__资金 = 0 私有属性，代表车辆的资金 私有方法 (Private Methods) 方法名前加了两个下划线表示它是私有方法，只能在类的内部被调用。 作用: 不能被外部直接访问 12def __start_engine(self): print(&#x27;引擎启动，准备行驶&#x27;) 以汽车为例： 1234567891011121314151617181920212223class Car: # 初始化 def __init__(self, brand, engine, seats): # 公有属性 self.brand = brand self.engine = engine self.seats = seats # 私有属性 self.__资金 = 0 # 公有方法 def drive(self): print(f&#x27;&#123;self.brand&#125; 正在行驶&#x27;) # 在公有方法中使用私有方法 self.__start_engine() # 私有方法 def __start_engine(self): print(&#x27;引擎启动，准备行驶&#x27;)# 实例化类my_car = Car(&#x27;宝马&#x27;, &#x27;V6&#x27;, 5)my_car.drive() 在类中，成员属性和成员方法可以通过在名称前加上两个下划线 __ 来设为私有。这样做的好处是能够保证这些成员不会被外界直接访问，但它们仍然可以在类的内部通过 self 被访问。这种方式有助于隐藏数据和实现细节，提高了代码的安全性和健壮性。 QA 问：为什么class AdvancedCar(Car)不用super() 答：AdvancedCar 类继承自 Car 类。在这个特定的情况下，super() 没有被使用，原因如下： 不需要覆盖父类的方法： 在 AdvancedCar 类中，我们添加了新的方法（autopilot 和 advanced_navigation），而没有修改或覆盖任何继承自 Car 类的方法。因此，没有必要使用 super() 来调用父类 Car 的任何方法。 构造函数未被重写： 如果子类不重写父类的构造函数（__init__ 方法），则默认调用父类的构造函数。在例子中，AdvancedCar 没有定义自己的 __init__ 方法，因此它会自动使用父类 Car 的构造函数来初始化对象。如果在子类中重写了构造函数并且想要执行父类的构造函数，那么在子类的构造函数中使用 super().__init__() 是必要的。 独立的新方法： AdvancedCar 类中新增的方法（autopilot 和 advanced_navigation）是独立的，它们不依赖于 Car 类中定义的任何方法，因此没有必要使用 super()。 总结一下，super() 主要用于需要调用或扩展父类中定义的方法时。如果只是在子类中添加新的独立方法或属性，并且没有重写父类的构造函数，就不需要使用 super()。在例子中，由于这些条件都未满足，因此不使用 super() 是合理的。 继承 (Inheritance)在面向对象编程中，继承允许我们从一个已存在的类（称为父类）派生出一个新的类（称为子类）。子类会继承父类的所有属性和方法，并可以添加新的属性和方法或重写某些方法。 以汽车为例，我们可以从一个基本的汽车类派生出一个具有更多功能的特殊汽车类。 首先是父类，表示基本的汽车： 1234567891011class Car: def __init__(self, brand, engine, seats): self.brand = brand self.engine = engine self.seats = seats def start_engine(self): print(f&#x27;&#123;self.brand&#125; 的引擎启动了&#x27;) def drive(self): print(f&#x27;&#123;self.brand&#125; 正在行驶&#x27;) 然后是子类，这里我们假设有一个增强版的汽车，它除了有基本的汽车功能外，还增加了自动驾驶和先进的导航系统： 12345678910111213class AdvancedCar(Car): # 继承自 Car 类 def autopilot(self): print(f&#x27;&#123;self.brand&#125; 的自动驾驶系统已启动&#x27;) def advanced_navigation(self): print(f&#x27;&#123;self.brand&#125; 正在使用先进的导航系统&#x27;)# 实例化一个增强版的汽车my_advanced_car = AdvancedCar(&#x27;特斯拉&#x27;, &#x27;电动&#x27;, 5)my_advanced_car.start_engine() # 继承自 Car 类的方法my_advanced_car.drive() # 继承自 Car 类的方法my_advanced_car.autopilot() # AdvancedCar 类的新增方法my_advanced_car.advanced_navigation() # AdvancedCar 类的新增方法 在这个例子中，AdvancedCar 类继承了 Car 类的所有属性和方法（如 start_engine 和 drive），并新增了 autopilot 和 advanced_navigation 方法。这表明 AdvancedCar 不仅保留了基本汽车的特性，还加入了新的功能，充分展示了继承的实用性和灵活性。 多态 (Polymorphism)多态是面向对象编程中的一个重要概念，它允许不同类的对象对同一消息做出响应。即不同的对象可以通过相同的接口（方法或函数）执行不同的操作。这增加了程序的灵活性和可扩展性。 1234567891011121314151617181920class Dog: def speak(self): return &quot;汪汪！&quot;class Cat: def speak(self): return &quot;喵喵！&quot;# 定义一个函数，接受不同的动物对象def animal_sound(animal): # 无论传入的是什么动物，调用相同的speak方法 print(animal.speak())# 实例化Dog和Catdog = Dog()cat = Cat()# 调用animal_sound函数，展示多态animal_sound(dog) # 输出: 汪汪！animal_sound(cat) # 输出: 喵喵！ 在这个例子中，Dog 和 Cat 类都实现了同一个方法 speak，但它们以不同的方式响应（狗叫声和猫叫声）。函数 animal_sound 接受任何有 speak 方法的对象作为参数，然后调用这个方法。这就是多态的核心：通过同一接口，不同的对象可以执行各自不同的操作。 总结来说，多态允许我们编写更通用和可重用的代码，因为我们可以设计函数或方法，它们可以与任何符合特定接口（即实现特定方法）的对象交互，而不关心对象的具体类型。这样可以提高代码的灵活性和可扩展性。 学生管理系统案例这个学员管理系统示例演示了面向对象编程的几个关键概念，如类的定义、初始化、封装、私有属性和方法的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 定义一个名为StudentManagementSystem的类class StudentManagementSystem: # 类的构造函数，用于初始化对象的属性 def __init__(self, name, gender, age): # 公有属性，可以被外部访问 self.name = name self.gender = gender self.age = age # 私有属性，前面有两个下划线，仅在类内部可访问 self.__balance = 1000 # 设置初始余额为1000 # 私有方法，用于扣除费用，仅在类内部可调用 def __deduct_fee(self, amount): # 检查余额是否足够 if self.__balance &gt;= amount: self.__balance -= amount print(f&#x27;扣除&#123;amount&#125;元成功。&#x27;) else: print(&#x27;余额不足，无法扣款。&#x27;) # 公有方法，用于展示学员信息 def show_info(self): # 打印学员信息，包括私有属性余额 print(f&quot;姓名: &#123;self.name&#125;, 性别: &#123;self.gender&#125;, 年龄: &#123;self.age&#125;, 余额: &#123;self.__balance&#125;&quot;) # 公有方法，用于购买课程 def purchase_course(self): try: # 输入价格，并尝试转换为整数 price = int(input(&#x27;请输入购买的价格:&#x27;)) # 调用私有方法扣款 self.__deduct_fee(price) except ValueError: print(&quot;请输入有效的价格。&quot;) # 新增的公有方法，用于为学员账户充值 def recharge(self, amount): # 增加学员余额 self.__balance += amount print(f&#x27;已成功充值&#123;amount&#125;元。&#x27;) # 新增的公有方法，用于学员对课程进行评价 def rate_course(self, course, rating): # 打印学员对课程的评分 print(f&#x27;学员&#123;self.name&#125;给课程&#123;course&#125;的评分是: &#123;rating&#125;&#x27;)# 实例化一个StudentManagementSystem类的对象user = StudentManagementSystem(&#x27;用户&#x27;, &#x27;男&#x27;, &#x27;18&#x27;)user.purchase_course() # 调用方法购买课程user.purchase_course() # 再次调用方法购买课程user.show_info() # 展示学员信息user.recharge(500) # 调用方法充值500元user.rate_course(&quot;Python编程基础&quot;, 5) # 对课程进行评分 为了在现有的 StudentManagementSystem 类中引入继承和多态的特点，我们可以创建一个基类来表示一般的用户，然后让 StudentManagementSystem 类成为这个基类的子类。此外，我们可以定义一个接口（一个具有共同方法但没有具体实现的基类），来展示多态。 首先是基类和接口的定义： 1234567891011121314# 基类 User，表示一般的用户class User: def __init__(self, name, gender, age): self.name = name self.gender = gender self.age = age def show_info(self): print(f&quot;姓名: &#123;self.name&#125;, 性别: &#123;self.gender&#125;, 年龄: &#123;self.age&#125;&quot;)# 接口类 CourseConsumer，定义了一个没有具体实现的方法 purchase_courseclass CourseConsumer: def purchase_course(self): raise NotImplementedError(&quot;Subclass must implement this method&quot;) 然后是修改后的 StudentManagementSystem 类，它继承自 User 并实现了 CourseConsumer 接口： 1234567891011121314151617181920212223242526272829303132# StudentManagementSystem 类继承自 User 类并实现了 CourseConsumer 接口class StudentManagementSystem(User, CourseConsumer): def __init__(self, name, gender, age): super().__init__(name, gender, age) # 调用父类的构造函数 self.__balance = 1000 # 私有属性 def __deduct_fee(self, amount): if self.__balance &gt;= amount: self.__balance -= amount print(f&#x27;扣除&#123;amount&#125;元成功。&#x27;) else: print(&#x27;余额不足，无法扣款。&#x27;) # 重写父类的 show_info 方法 def show_info(self): super().show_info() # 调用父类方法 print(f&quot;余额: &#123;self.__balance&#125;&quot;) # 实现接口中定义的方法 def purchase_course(self): try: price = int(input(&#x27;请输入购买的价格:&#x27;)) self.__deduct_fee(price) except ValueError: print(&quot;请输入有效的价格。&quot;) def recharge(self, amount): self.__balance += amount print(f&#x27;已成功充值&#123;amount&#125;元。&#x27;) def rate_course(self, course, rating): print(f&#x27;学员&#123;self.name&#125;给课程&#123;course&#125;的评分是: &#123;rating&#125;&#x27;) 在这个修改后的版本中，StudentManagementSystem 类继承了 User 类，并且实现了 CourseConsumer 接口的 purchase_course 方法。这样的设计不仅引入了继承，还通过实现接口展示了多态。继承允许 StudentManagementSystem 类重用 User 类的代码，而多态则体现在 StudentManagementSystem 类能够以不同方式实现 CourseConsumer 接口中定义的方法。这样的设计使得代码更加灵活和可扩展。 信息 在面向对象编程中，super() 函数的使用通常出现在继承体系中，尤其是在子类需要调用父类的方法或构造函数时。以下是一些使用 super() 的典型情况： 在子类的构造函数中调用父类的构造函数： 当创建一个子类时，可能需要在子类中初始化一些继承自父类的属性。使用 super() 调用父类的构造函数可以确保这些属性被适当地初始化。 12345678class Parent: def __init__(self): print(&quot;Parent init&quot;)class Child(Parent): def __init__(self): super().__init__() # 调用父类的 __init__ 方法 print(&quot;Child init&quot;) 在子类中覆盖父类的方法时调用父类的实现： 如果在子类中重写了父类的方法，并且还想保留父类方法的行为，可以在子类方法中使用 super() 调用父类的方法。 12345678class Parent: def say_hello(self): print(&quot;Hello from Parent&quot;)class Child(Parent): def say_hello(self): super().say_hello() # 调用父类的 say_hello 方法 print(&quot;Hello from Child&quot;) 多重继承中解决方法解析顺序（Method Resolution Order, MRO）问题： 在使用多重继承时，super() 被用来确保每个父类都被适当地初始化或调用相应的方法。它按照方法解析顺序遍历所有的基类。 123456789101112131415161718class Base: def __init__(self): print(&quot;Base init&quot;)class A(Base): def __init__(self): super().__init__() print(&quot;A init&quot;)class B(Base): def __init__(self): super().__init__() print(&quot;B init&quot;)class Child(A, B): def __init__(self): super().__init__() print(&quot;Child init&quot;) 总之，super() 的使用有助于确保父类的适当初始化和方法调用，尤其是在有继承关系的类之间。这有助于减少代码重复，并确保继承体系中的逻辑一致性。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"基本语法","slug":"基本语法","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"对象","slug":"对象","permalink":"https://www.yiuhangblog.com/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://www.yiuhangblog.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"类","slug":"类","permalink":"https://www.yiuhangblog.com/tags/%E7%B1%BB/"},{"name":"继承","slug":"继承","permalink":"https://www.yiuhangblog.com/tags/%E7%BB%A7%E6%89%BF/"},{"name":"多态","slug":"多态","permalink":"https://www.yiuhangblog.com/tags/%E5%A4%9A%E6%80%81/"},{"name":"封装","slug":"封装","permalink":"https://www.yiuhangblog.com/tags/%E5%B0%81%E8%A3%85/"},{"name":"抽象","slug":"抽象","permalink":"https://www.yiuhangblog.com/tags/%E6%8A%BD%E8%B1%A1/"}],"author":"Yiuhang Chan"},{"title":"函数","slug":"20180812函数","date":"2018-08-12T08:43:23.000Z","updated":"2024-02-28T10:49:04.000Z","comments":true,"path":"2018/08/12/20180812函数/","permalink":"https://www.yiuhangblog.com/2018/08/12/20180812%E5%87%BD%E6%95%B0/","excerpt":"Python 基础函数语法","text":"什么是函数函数是一段可重复使用的代码块，用于执行特定的任务 函数的作用 提高代码的可重用性: 使用函数可以将代码块组织成更小的可重用模块，减少代码的冗余。 提高代码的可读性: 使用函数可以使代码更加简洁和易于理解，也更容易进行调试和维护。 提高代码的模块化: 使用函数可以将程序分解成更小的模块，每个模块都可以处理特定的任务，这样程序的组织结构更加清晰。 提高代码的可扩展性: 使用函数可以使程序更易于扩展和修改，因为函数可以独立地编写和测试，而不会影响程序的其他部分。 函数就是设计一个技能需要时自己调用，调用的方法本质上是个函数 。两者的区别是使用的方式不一样。 函数写法1234567# 用def定义一个函数def User(): 内容# 调用函数 必须顶格User() 函数的形参和实参 不传值给函数可以不带形参和实参 形参名字可以随意定义 形参和实参数量必须一致 实参对应形参 形参可以赋默认参数 没有传就以默认参数 传了就以实参 实参也可以指定形参 通过*形参名可以获取所有实参，通过索引获取对应实参 1234567# 用def定义一个函数def User(形参): 内容# 调用函数 必须顶格User(实参) 案例1234567891011# 形参的默认参数# 如果没有传就以默认参数 传了就以实参def user(x, y): print(x) print(y)user(13, 14)# 13# 14 123456789# 通过*形参名可以获取所有实参def user(*item): # 通过形参名索引获取对应实参 print(item[0])user(13, 14, 16, 17)# 13 内置函数Python自带的一些函数，我们可以直接拿来使用 12345# 打印print()# 类型判断type()# 字符串、列表、元组、集合 的增删改查的方法 字符串、列表、元组、集合 的增删改查的方法 数值类型，详细内容与调用方法跳转查阅 函数的说明文档 给函数中的代码做解释说明 让其他程序员知道函数的作用 函数里的注释 如何写说明文档 三引号包裹 1234def add(a, b): &#x27;&#x27;&#x27; 内容 &#x27;&#x27;&#x27; 123456789def add(a, b): &quot;&quot;&quot; 这个函数用于计算两个数的和。 :param a: 第一个加数 :param b: 第二个加数 :return: 两个数的和 &quot;&quot;&quot; return a + b 函数的嵌套在函数内部调用其它函数 尽量不要嵌套太多层，不然就是屎山了 1234567891011121314151617# 1.定义一个函数adef a(): print(&#x27;我是函数a&#x27;) # 3.在函数a内部调用函数b b()# 2.定义一个函数bdef b(): print(&#x27;我是函数b&#x27;)# 4.调用函数aa() # 我是函数a# 我是函数b 函数的作用域Python 中的函数作用域分为两种: 全局作用域和局部作用域 全局作用域指的是在模块(文件)中定义的变量和函数，可以在模块的任何地方被访问和使用 局部作用域指的是在函数内部定义的变量和函数，只能在该函数内部被访问和使用 1234567891011121314# 变量a 全局作用域a = 100# 定义一个 函数textAdef textA(): # 变量b 局部作用域 b = 20# 因为变量a在全局作用域 所以可以访问到print(a) # 100# 因为变量b 在局部作用域 变量b 访问不到 所以会报错print(b) # NameError: name &#x27;b&#x27; is not defined global 关键字使用 global 关键字 可以在函数内部声明变量为全局变量 1234567891011121314# 定义两个变量 textA textBdef textA(): # gLobal 声明 money 为全局变量 global money money = 100 print(money)def textB(): print(money)textA() # 100textB() # 100 闭包 Closure内部函数使用了外部函数的变量 12345678910111213141516def func(): # 外部函数 # 1. 变量a 是func函数的局部变量 a = 10 print(&quot;函数func调用&quot;) def func1(): # 内部函数 # 2. 我们在func1这个内部函数里面 使用了 外部函数的变量a 这种现象就叫闭包，没有用到 变量 就不叫闭包 print(a) return func1 # 3. 我们需要返回func1函数的本身给外部函数 才能看到闭包的效果 闭包不需要调用只需要返回demo = func() # 函数func调用demo() # 10# 或者func()() 好处好处: 保存局部变量的状态 我们可以将相关的功能和数据绑定在一起，而不用担心数据被其他代码修改。 应用：想保存数据状态和不被污染 我们就可以使用闭包。很多框架底层 保存数据都是用的闭包 1234567891011121314151617181920def func(): a = 0 def func1(): nonlocal a # nonlocal 指向外部函数func的a 不会指向全局作用域 如果外部func没有a就会报错 a += 1 # 累加，主要做逻辑处理，每次调用func1就会累加1 return a # 将累加的结果返回出来给func1 return func1 # 返func1本身传递给func 覆盖原始a=0 我们才能看到闭包的效果# 目的调用func1 让a累加一次# 需要调用看结果demo = func()# 通过demo来调用里面的func1print(demo())# 输出 1print(demo())# 输出 2print(demo())# 输出 3 因此可以发现通过闭包，可以使得数据状态得到存储，例如存储累加的结果 且闭包的数据无法通过全局变量进行修改，保证数据完整性，因为是由子函数进行累加的 需要保存数据状态的时候就需要使用闭包 使用场景例如 第三方库 能够保存数据状态 信息 1234567891011121314a = &quot;Global&quot;def fun_out(): a = &quot;external_function&quot; def fun_in(): print(a) return fun_indemo = fun_out()demo() # external_function 在 Python 中，变量的使用和修改遵循不同的规则，特别是在涉及嵌套函数时。这是因为 Python 对变量的查找（读取）和赋值（修改）有不同的作用域规则。 读取变量：当代码尝试读取一个变量的值时（如在 print(a) 中），Python 会遵循作用域查找规则。这意味着它会首先在当前函数的局部作用域查找该变量。如果在当前作用域找不到，它会在外围作用域中查找，一直查找到全局作用域，最后是内置作用域。这就是为什么在上面的例子中，即使没有使用 nonlocal 关键字，fun_in 也能访问 fun_out 中定义的 a 变量。 修改变量：当尝试修改一个变量的值时，Python 的默认行为是在当前作用域创建或更新该变量。如果在一个嵌套的函数中不加声明地修改一个变量，Python 会认为这是一个新的局部变量，而不是一个外围作用域中的变量。 使用 nonlocal 关键字：当想在一个嵌套函数中修改外围函数的局部变量时，需要使用 nonlocal 关键字。这样做可以告诉 Python 想修改的是外围作用域中的变量，而不是创建一个新的局部变量。 全局变量：如果想在一个函数中修改全局变量，而不是创建同名的局部变量，需要使用 global 关键字。 这种区分是为了避免意外修改外围作用域中的变量，这可能会导致难以追踪的错误。通过要求显式声明 nonlocal 或 global，Python 增强了代码的可读性和可维护性。 闭包（Closure）和嵌套函数（Nested Functions）的区别闭包（Closure） 在编程中，闭包是指那些能够访问自己外部作用域中变量的函数。一个闭包至少由两部分组成：一个函数以及该函数引用的外部变量。Python 中闭包的一个关键特征是它保持了对其外部变量的引用，即使在外部函数已经结束执行之后。 在代码中，fun_in 是一个闭包，因为它是在 fun_out 内部定义的，并且引用了 fun_out 作用域内的变量 a。当 fun_out 被调用并返回 fun_in 时，尽管 fun_out 的执行已经结束，fun_in 依然保留了对变量 a 的引用。这样，即使是在 fun_out 执行完毕之后，fun_in 仍然可以访问并打印变量 a 的值。 嵌套函数（Nested Functions） 嵌套函数是在另一个函数内部定义的函数。虽然所有闭包都是嵌套函数，但并非所有嵌套函数都是闭包。一个嵌套函数只有在引用了其外部函数的变量时，它才构成一个闭包。 总结 fun_in 作为一个闭包，即使在其外部函数 fun_out 执行完毕后，仍然可以访问并使用 fun_out 作用域中的变量 a。 匿名函数匿名函数，通常在 Python 中通过 lambda 关键字来定义，是一种没有显式函数名的简短函数。它们在语法上是简洁的，通常用于编写小的、一次性的、不需要单独定义函数名的函数。 匿名函数是一个可以定义并立即使用的简洁函数形式。在 Python 中，匿名函数使用 lambda 关键字创建，其基本语法是： 1lambda 参数列表: 表达式 这种函数通常用于简单的操作，比如简单的数学运算、字符串操作等。由于它们只是单个表达式，所以不能像普通函数那样执行复杂的操作 1234567891011# lambda : 8 创建了一个匿名函数，这个函数没有参数，并且总是返回数字 8func = lambda : 8 # lambda 关键字 代表匿名函数print(func()) # 输出: 8# 匿名函数的一个限制是它只能包含一个表达式，不能包含多个独立的语句或复杂的逻辑。如果函数体较复杂，或者需要重复使用，那么定义一个普通函数会更合适。它与匿名函数执行相同的操作，但是更适合复杂逻辑或多次调用的情况。def func() : return 8print(func()) 匿名函数的作用匿名函数的主要作用是简化代码，尤其是在需要小的函数作为参数时，例如在排序操作、高阶函数（如 map()、filter()）或任何需要函数对象的地方。由于它们不需要定义传统的函数结构，因此可以在代码中快速定义和使用。 何时使用匿名函数匿名函数通常在以下情况下使用： 简单的功能：当函数的功能非常简单，只需要一行代码就可以实现时，使用匿名函数是一个很好的选择。 一次性使用：当有一个不会在代码的其他地方复用的小函数时，使用匿名函数可以减少不必要的函数定义。 作为参数传递：当一个函数接受另一个函数作为参数时，如果这个参数函数非常简短，使用匿名函数可以使代码更加清晰。常见的例子包括 map()、filter() 和 sorted() 等函数。 QA 问： 函数通过function关键字定义吗？ 答： 这个说法是错误的。在Python中，函数是通过 def 关键字来定义的，而不是 function。例如：def my_function():。 问： 调用函数使用函数名即可吗？ 答： 这个说法是正确的。在Python中，函数通过其名称来调用，可能跟随一对圆括号和必要的参数。例如，如果有一个名为 my_function 的函数，可以通过 my_function() 来调用它。 问： 函数必须要有返回值return 答： 这个说法是错误的。函数不一定需要有 return 语句。如果没有 return 语句，函数默认返回 None。return 语句用于从函数中返回一个值。 问： 函数里面直接定义的变量外部不能访问 答： 这个说法是正确的，但需要一些澄清。在Python中，函数内部定义的变量是局部的，意味着它们只在函数内部可见。外部代码不能直接访问函数内部的局部变量。然而，如果需要在外部访问这些变量的值，可以通过函数返回这些值来实现。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"嵌套","slug":"嵌套","permalink":"https://www.yiuhangblog.com/tags/%E5%B5%8C%E5%A5%97/"},{"name":"基本语法","slug":"基本语法","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"内置函数","slug":"内置函数","permalink":"https://www.yiuhangblog.com/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"name":"形参","slug":"形参","permalink":"https://www.yiuhangblog.com/tags/%E5%BD%A2%E5%8F%82/"},{"name":"实参","slug":"实参","permalink":"https://www.yiuhangblog.com/tags/%E5%AE%9E%E5%8F%82/"},{"name":"说明文档","slug":"说明文档","permalink":"https://www.yiuhangblog.com/tags/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"},{"name":"作用域","slug":"作用域","permalink":"https://www.yiuhangblog.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"https://www.yiuhangblog.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"匿名函数","slug":"匿名函数","permalink":"https://www.yiuhangblog.com/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"}],"author":"Yiuhang Chan"},{"title":"控制流程","slug":"20180802流程控制","date":"2018-08-02T03:13:45.000Z","updated":"2024-02-28T10:49:00.000Z","comments":true,"path":"2018/08/02/20180802流程控制/","permalink":"https://www.yiuhangblog.com/2018/08/02/20180802%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"Python 基础逻辑语法","text":"条件判断前置知识：Input方法在 Python 中，input()是一个内置函数，用于从标准输入中获取用户输入的数据 注意 输入的值是字符串类型 如果想输入是整数 那就需要进行类型转换 a = int(input(&quot;请输入想输入的内容&#39;)) 1234# 变量a 就存储着用户输入的数据a = input(&#x27;请输入想输入的内容 )# 当我们输入完后可以通过print将输入的内容打印出来print(a) 什么是条件判断 条件判断是编程中一种非常常见的控制结构，它可以帮助我们根据不同的条件来执行不同的代码。可以把它想象成我们生活中的决策过程。 判断的过程中，比较的类型需要一样，例如都是数值类型 1. 语法：12345678if 判断条件: # 执行语句....else: # 执行语句.... # if：如果# else 否则# if 可以单独存在，如果不满足就不会执行if里面的代码，但会继续执行if外面的代码 2. 案例 1假如天气晴朗，我就去打篮球，否则我就去看电影。 123456# 定义一个a变量 存储今天的天气a = input(&#x27;输入今天的天气:&#x27;) if a == &#x27;晴天&#x27;: # == 是否等于 print(&#x27;今天是晴天,我要出去打篮球&#x27;)else: print(&#x27;今天是下雨天,我要去看电影&#x27;) 3. 案例 2随意输入0-100的整数，如果大于60 就在控制台返回 会当凌绝顶一览众山小 如果小于60就返回 三十年河东三十年河西 莫欺少年穷 12345a = int(input(&#x27;随意输入0-100的整数:&#x27;))if a &gt; 60: print(&#x27;会当凌绝顶一览众山小&#x27;)else: print(&#x27;三十年河东三十年河西 莫欺少年穷&#x27;) 多个条件判断1. 什么是多个条件判断有些时候，我们的判断语句不可能只有两个，有些时候需要多个，比如说大于等于 60 的为及格，那我们还要判断大于等于 90 的为优秀，在 80 到 90 之间的良好呢？ 这时候需要用到 if 语句多个判断条件 2. 语法123456789101112if 判断条件1: # 执行语句1.....elif 判断条件2: # 执行语句2.....elif 判断条件3: # 执行语句3.....else: # 执行语句4.....# if：如果# elif:或者# else 否则 3. 案例 1123456789a = int(input(&#x27;请输入分数&#x27;))if a &gt;= 90: print(&#x27;优秀&#x27;)elif a &gt;= 80: print(&#x27;良好&#x27;)elif a &gt;= 60: print(&#x27;及格&#x27;)else: print(&#x27;恭喜 没有及格 ) 4. 案例 2有时候我们会遇到多个条件的时候该怎么操作呢？ 比如说：学校举行一场考试，要求小明的python和java两门语言 都达到80分才算优秀。 这时候我们可以结合 or 和 and 来使用。 or (或)表示两个条件有一个成立时判断条件成功 and (与)表示只有两个条件同时成立的情况下，判断条件才成功。 1234567python = int(input(&#x27;请输入python分数&#x27;))java = int(input(&#x27;请输入java分数&#x27;))# 当我们输入完 我们的变量python和java就分别存储着 python和java的分数if python &gt;= 80 and java &gt;= 80: print(&#x27;优秀&#x27;)else: print(&#x27;不优秀&#x27;) 12345678python = int(input(&#x27;请输入python分数&#x27;))java = int(input(&#x27;请输入java分数&#x27;))# 当我们输入完 我们的变量python和java就分别存储着 python和java的分数# 将and改为or 就意味着 只需要一个条件满足就是优秀if python &gt;= 80 or java &gt;= 80: print(&#x27;优秀&#x27;)else: print(&#x27;不优秀&#x27;) 嵌套1. 嵌套是指什么就跟字面意思差不多，指 if 语句中可以嵌套 if 语句。 2. 案例 1小明，平时正常上班太累了，到了周末如果是晴天，那就出去打篮球，如果不是那就在家看电视 1234567891011# 定义一个变量来保存今天是不是周末# 定义一个变量b来保存今天的天气a = &#x27;周末&#x27;b = &#x27;晴&#x27;if a == &#x27;周末&#x27;: if b == &#x27;晴&#x27;: print(&#x27;今天是周末，又是晴天可以去打篮球&#x27;) else: print(&#x27;今天是周末，但是下雨在家乖乖看电视&#x27;)else: print(&#x27;乖乖上班&#x27;) match…casePython 3.10 引入了 match...case 语句，提供了一种更加结构化和可读性更强的方式来进行条件判断。这个新特性使得编写复杂的条件逻辑变得更加简单和直观，是 Python 对模式匹配功能的实现。以下是对 match...case 语句的使用方法和特点的详细解析。 基本语法match...case 语句的基本语法如下： 123456789match subject: case 条件1: &lt;action_1&gt; case 条件2: &lt;action_2&gt; case 条件3: &lt;action_3&gt; case _: &lt;action_wildcard&gt; match 后面跟着的是要匹配的对象（subject）。 case 后面定义了匹配的条件，如果 subject 满足某个条件，则执行该 case 下的代码块。 **_**（通配符）用于匹配所有未被前面的 case 匹配的情况。 多条件匹配一个 case 语句可以包含多个用管道符（|）隔开的匹配条件，如果 subject 与其中任何一个条件相匹配，则执行该 case 下的代码块。 1234567match subject: case 条件1 | 条件2: &lt;action_1_2&gt; case 条件3: &lt;action_3&gt; case _: &lt;action_wildcard&gt; 使用场景match...case 语句适用于需要基于一个对象的值或类型进行多个条件判断的场景。它使得代码更加清晰易读，特别是在处理复杂的条件逻辑时，相比于传统的多层 if-else 语句，提供了更好的可读性和效率。 示例以下是一个使用 match...case 语句的示例，根据不同的水果名称打印相应的颜色： 12345678910fruit = &quot;apple&quot;match fruit: case &quot;apple&quot;: print(&quot;red&quot;) case &quot;banana&quot;: print(&quot;yellow&quot;) case &quot;orange&quot;: print(&quot;orange&quot;) case _: print(&quot;Unknown color&quot;) 注意 match...case 语句是 Python 3.10 及以后版本的新特性，在此之前的版本中不可用。 使用 match...case 时，需要确保 case 后的条件覆盖了所有可能的情况，或者使用通配符 _ 来处理未匹配到的情况。 三目运算 也叫三元运算符，是一种简洁的条件语句表达式。它可以根据条件的成立与否来返回两个值中的一个。 ​ 作用：简化代码 之前案例，今天学校期末数学考试(60分及格)，小明考了66分，请问小明是及格还是没有及格。 123456789# 定义一个变量a 来保存小明的数学成绩a = 66# 三目运算print(&#x27;及格&#x27;) if a &gt; 6 else print(&#x27;不及格&#x27;)# 普通的if判断if a &gt; 60: print(&#x27;及格&#x27;)else: print(&#x27;不及格&#x27;) 循环语句 Python 提供了 for 循环和 while 循环（在 Python 中没有 do..while 循环）: 循环类型 描述 while 循环 在给定的判断条件为 true 时执行循环体，否则退出循环体。 for 循环 重复执行语句 嵌套循环 你可以在while循环体中嵌套for循环 循环控制语句循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句： 控制语句 描述 break 语句 在语句块执行过程中终止循环，并且跳出整个循环 continue 语句 在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。 pass 语句 pass是空语句，是为了保持程序结构的完整性。 1. 什么是循环可以让程序自动地执行多次相同或类似的任务，从而节省编写代码的时间和精力。 一共有两种循环： for循环 while循环 2. for循环 可以遍历一个序列或其他可迭代对象中的元素，并执行特定的代码块。 语法12for 形参 in 遍历对象: print(形参) 信息 对象（Objects）： 在Python中，几乎所有东西都是对象。这包括数字、字符串、列表、函数，甚至是类和类型本身。每个对象都有三个特性：身份、类型和值。 身份：每个对象都有一个唯一的身份，用于区分不同的对象。可以通过 id() 函数来查看对象的身份。 类型：对象的类型定义了它可以进行哪些操作或拥有哪些方法。类型可以通过 type() 函数查看。 值：对象表示的数据。 形参（Formal Parameters）： 当定义一个函数时，可以在函数定义中指定一些参数。这些参数被称为形式参数（形参），它们是函数内部的局部变量。当函数被调用时，形参会接收传递给函数的实际值。这些值被称为实参（实际参数）。 例如： 12def add(a, b): # a 和 b 是形参 return a + b 在这个例子中，a 和 b 是形参，它们在函数 add 被调用时接收实际的输入值。 案例1234567891011# 案例: 将List的内容全部打印出来# 定义一个列表Listlist = [&#x27;苹果&#x27;, &#x27;香蕉&#x27;, &#x27;梨子&#x27;]# 以前print(list[0])print(list[1])print(list[2])# 如果List里面有1000 个值呢，是不是要写一干遍# 我们学习for循环后for item in list: print(item) range函数Python 中的 range() 函数是一个非常有用的工具，用于生成一个不可变的数值序列。与 for 循环结合使用时，range() 使得遍历数字序列变得简单高效。这个函数在数据迭代、循环执行等多种场景下都有广泛应用。 功能和用法 生成数字序列：range() 可以生成一个从起始值到终值（不包含终值），按照指定步长的数字序列。 基本语法12range(stop)range(start, stop[, step]) **start**：序列的起始值，默认为0。 **stop**：序列的终止值，生成的序列不包含此值。 **step**：序列中每个数之间的差（步长），默认为1。当步长为正时，序列按升序排列；步长为负时，序列按降序排列。 示例 基本遍历： 12for i in range(5): print(i) # 输出 0 到 4 指定区间的值： 12for i in range(5, 9): print(i) # 输出 5 到 8 指定步长： 12for i in range(0, 10, 2): print(i) # 输出 0, 2, 4, 6, 8 反方向迭代： 12for i in range(0, -8, -2): print(i) # 输出 0, -2, -4, -6 访问和转换 通过下标访问： 12a = range(1, 3)print(a[0], a[1]) # 输出 1 2 转换为列表、元组、集合： 123456a = list(range(0, -8, -2))b = tuple(range(0, -8, -2))c = set(range(0, -8, -2))print(a) # 输出 [0, -2, -4, -6]print(b) # 输出 (0, -2, -4, -6)print(c) # 输出 &#123;0, -2, -4, -6&#125; 结合 len() 遍历序列索引123a = [&#x27;Google&#x27;, &#x27;Baidu&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;QQ&#x27;]for i in range(len(a)): print(i, a[i]) 列表、元组、集合、字典、字符串的for循环的使用案例 列表、元组、集合、字典、字符串皆为 数值类型，详细内容与调用方法跳转查阅 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 列表List_test = [&#x27;香蕉&#x27;, &#x27;苹果&#x27;, &#x27;梨子&#x27;]for item in List_test: print(item)# 香蕉# 苹果# 梨子 # 元组tuple_test = (&#x27;香蕉&#x27;, &#x27;苹果&#x27;, &#x27;梨子&#x27;)for item in tuple_test: print(item)# 香蕉# 苹果# 梨子# 集合set_test = &#123;&#x27;香蕉&#x27;, &#x27;苹果&#x27;, &#x27;梨子&#x27;&#125;for item in set_test: print(item)# 香蕉# 苹果# 梨子# 字典dict_test = &#123; &quot;username&quot;: &#x27;user&#x27;, &#x27;age&#x27;: 25&#125;for item in dict_test: # 在字典中 item:key print(item) # 如果想拿到vaLue的值 : List[item] print(item, dict_test[item])# username# username user# age# age 25 #字符串str_test = &#x27;hello word&#x27;for item in str_test: print(item)# h# e# l# l# o # w# o# r# d 双层for循环也可以用于遍历嵌套的数据结构 1234567891011121314151617181920# 列表里面包字典，这是开发最常见的一种数据方式，我们需要把里面的数据给拿出来list_dic = [&#123; &#x27;username&#x27;: &#x27;users1&#x27;, &#x27;age&#x27;: 18&#125;, &#123; &#x27;username&#x27;: &#x27;users2&#x27;, &#x27;age&#x27;: 20&#125;]# 第一层for循环遍历出两个字典for item in list_dic: # 第二层for循环遍历出字典里面的值 for i in item: # 通过i形参就是传递出字典里的值 # item就是字典本身，通过遍历item获取value print(i, item[i]) # items 就是拿到了，item字典里面的key # username users1# age 18# username users2# age 20 3. while循环 常见的循环结构，它可以在条件满足的情况下重复执行一段代码块，直到条件不再满足为止。 语法12while 判断条件: 输出内容 案例1234567a = 11while a &gt; 10: # 这样会陷入无尽的循环 因为a会一直大于 10 这个时候 print(&#x27;a大于10 这行代码就会一直运行&#x27;) break #我们可以用break来终止# a大于10 这行代码就会一直运行 12345678a = 8while a &lt; 10: # 可以在循环里面加改变条件的运算 让循环变成 有限循环 而不是无限循环 a += 1 print(&#x27;aaaaaaa&#x27;) # aaaaaaa# aaaaaaa QA 问： break用于退出当前循环？ 答： 在Python中，break 语句用于立即退出循环，无论是 for 循环还是 while 循环。一旦执行了 break，循环将完全终止。 问： for对可迭代对象进行遍历 答： for 循环在Python中用于遍历可迭代对象（如列表、字符串、元组等），对其中的每个元素执行循环体内的语句。 问： break和continue必须成对出现 答： 这个说法是错误的。break 和 continue 是两个不同的循环控制语句，它们可以独立使用。break 用于完全退出循环，而 continue 用于跳过当前循环的剩余部分并继续执行下一次循环迭代。它们没有必须成对出现的要求。 问： continue是退出当前循环，继续下一轮循环 答： 这个说法是正确的，但需要稍微澄清。continue 语句并不是退出整个循环，而是结束当前的循环迭代，并立即开始下一次的迭代。如果是在 for 循环中使用 continue，则会跳到循环的下一个元素；如果是在 while 循环中，会重新评估循环条件。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"控制流程","slug":"控制流程","permalink":"https://www.yiuhangblog.com/tags/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"name":"条件判断","slug":"条件判断","permalink":"https://www.yiuhangblog.com/tags/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"},{"name":"循环语句","slug":"循环语句","permalink":"https://www.yiuhangblog.com/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"嵌套","slug":"嵌套","permalink":"https://www.yiuhangblog.com/tags/%E5%B5%8C%E5%A5%97/"},{"name":"三目运算","slug":"三目运算","permalink":"https://www.yiuhangblog.com/tags/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97/"}],"author":"Yiuhang Chan"},{"title":"语法基础和数据类型","slug":"20180723数据类型和序列类型","date":"2018-07-23T07:34:56.000Z","updated":"2024-02-28T10:48:57.000Z","comments":true,"path":"2018/07/23/20180723数据类型和序列类型/","permalink":"https://www.yiuhangblog.com/2018/07/23/20180723%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/","excerpt":"Python语法基础和数据类型","text":"标识符在 Python 编程语言中，理解标识符和变量的概念对于编写高效、易读的代码至关重要。以下是关于标识符和变量的详细解析，旨在为初学者提供清晰的指南。 标识符的基本规则 组成：标识符可以由字母、数字以及下划线（_）组成。 开头：标识符的第一个字符不能是数字，可以是字母或下划线。 区分大小写：在 Python 中，标识符是区分大小写的。例如，ABC 和 abc 被视为两个不同的标识符。 作用：标识符用作变量名、函数名、方法名等，是对程序中某些实体的命名。 变量变量的概念 定义：变量是程序中用于存储数据的标识符。Python 通过变量名访问这块存储单元。 命名规则：变量名遵循标识符的命名规则，但不能使用 Python 的保留字（关键字）作为变量名。 关键字查询：Python 的标准库提供了一个 keyword 模块，可以用来查看当前 Python 版本的所有关键字。 变量使用注意事项 类型声明：Python 是动态类型语言，变量不需要事先声明类型。 赋值前必须初始化：变量在使用前必须被赋值，变量的赋值操作同时也是变量声明的过程。 值可变性：变量的值可以随时修改，Python 中的变量更像是数据的引用而非数据存储的实体。 数据类型：变量的数据类型是根据赋值的数据类型自动确定的。 赋值运算符：Python 使用 = 作为赋值运算符，赋值的顺序是从右向左。 多变量赋值：Python 支持同时为多个变量赋值，例如 a, b, c = 1, 2, &quot;python&quot;。 实用示例 查看所有关键字： 12import keywordprint(keyword.kwlist) 变量赋值与使用： 12345678# 单个变量赋值x = 10# 多变量同时赋值a, b, c = 5, 3.2, &quot;Hello&quot;# 交换两个变量的值a, b = b, a 避免与关键字冲突的命名： 12345# 错误的命名，因为 if 是一个关键字if = 10 # 这将引发语法错误# 正确的命名if_condition = 10 在 Python 中，理解基础数据类型、输入输出操作以及代码的基本结构对于编写有效且易于理解的程序至关重要。以下是关于 Python 数据类型转换、输入输出操作、注释、缩进和导入模块等方面的专业整理。 Python 数据类型转换Python 支持多种数据类型的转换，使用以下内置函数： int(): 将数据转换为整型 (int)，适用于字符串、浮点数等。 str(): 将数据转换为字符串 (str) 类型，适用于数字等。 float(): 将数据转换为浮点数 (float) 类型，适用于字符串、整数等。 complex(x): 将 x 转换为复数，实数部分为 x，虚数部分为 0。 complex(x, y): 将 x 和 y 转换为复数，实数部分为 x，虚数部分为 y。 输入 使用 input(prompt) 函数读取用户的键盘输入，返回值为字符串类型。 示例：创建一个简单的加法程序。 123num1 = input(&quot;请输入一个数字: &quot;)num2 = input(&quot;请再输入一个数字: &quot;)print(int(num1) + int(num2)) 输出 print 函数：用于在屏幕上显示文本、变量或其他类型的数据。 支持直接打印文本（中文需要加引号）、数学表达式、变量等。 空格与连接：使用 , 会自动在变量间添加空格，使用 + 连接时不添加空格。 英文大小写转换：title() 将字符串首字母大写，upper() 转换为全大写，lower() 转换为全小写。 不换行输出：使用 end 参数指定结尾字符，默认为换行符 \\n。 指定分隔符：使用 sep 参数定义输出间的分隔符，默认为空格。 注释 单行注释：以 # 开头。 多行注释：使用三个单引号 &#39;&#39;&#39; 或三个双引号 &quot;&quot;&quot; 包裹。 行与缩进 Python 使用缩进来定义代码块，而非大括号 &#123;&#125;。 同一代码块的语句必须具有相同的缩进空格数。 不一致的缩进会导致 IndentationError。 多行语句 多行语句可以使用反斜杠 \\ 实现。 在 []、&#123;&#125;、() 中的语句不需要使用反斜杠。 同一行显示多条语句 Python 允许在同一行中使用多条语句，语句之间使用分号 ; 分割。 import 与 from…import 导入模块：使用 import modulename 或 from modulename import functionname。 安装模块：如果需要安装外部模块，可以使用 pip install modulename 命令。 Python 作为一门强大的编程语言，提供了丰富的数字运算能力，涵盖了从基本的算术运算到复杂的数学计算。本文档旨在全面概述 Python 中的数字运算，包括算术运算、位运算、比较运算，以及使用数学模块进行高级数学运算的方法。 算术运算Python 支持的基本算术运算符包括： 加法 (+) 减法 (-) 乘法 (*) 除法 (/) 整数除法 (//)：返回除法运算结果的整数部分。 取余 (%) 指数 (**)：进行幂运算。 示例代码： 1234print(2 + 2) # 加法print(50 - 5 * 6) # 减法print((50 - 5 * 6) / 4) # 除法print(8 / 5) # 除法总是返回一个浮点数 位运算位运算符对整数在内存中的二进制位进行操作： 按位与 (&amp;) 按位或 (|) 按位异或 (^) 按位取反 (~) 左移 (&lt;&lt;) 右移 (&gt;&gt;) 比较运算Python 中的比较运算符包括： 等于 (==) 不等于 (!=) 大于 (&gt;) 小于 (&lt;) 大于等于 (&gt;=) 小于等于 (&lt;=) 数学模块 (math)Python 的标准库中的 math 模块提供了许多常见的数学函数和常量。 常量：如 math.pi (圆周率) 和 math.e (自然对数的底数)。 函数：如 math.sqrt(x) (平方根)、math.floor(x) (向下取整)、math.ceil(x) (向上取整)、math.exp(x) (指数函数)、math.log10(x) (对数函数) 等。 示例代码： 12345678910import mathprint(&quot;圆周率：&quot;, math.pi)print(&quot;自然对数的底数：&quot;, math.e)x = 2.5y = 3.7print(x, &quot;的平方根：&quot;, math.sqrt(x))print(y, &quot;的向下取整值：&quot;, math.floor(y)) 注意 浮点运算的结果可能会因机器而异，这是由于计算机内部对浮点数的表示和四舍五入误差有关。 整数和浮点数混合运算时，整数将被转换为浮点数。 给变量赋值 使用等号 (=) 对变量进行赋值。Python 中的变量不需要声明类型，解释器会根据赋值自动确定类型。 运算符Python算术运算符以下假设变量： a&#x3D;10，b&#x3D;20： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 30 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 &#x2F; 除 - x除以y b &#x2F; a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 ** 幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 &#x2F;&#x2F; 取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 Python比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 &#x3D;&#x3D; 等于 - 比较对象是否相等 (a &#x3D;&#x3D; b) 返回 False。 !&#x3D; 不等于 - 比较两个对象是否不相等 (a !&#x3D; b) 返回 True。 &lt;&gt; 不等于 - 比较两个对象是否不相等。python3 已废弃。 (a &lt;&gt; b) 返回 True。这个运算符类似 !&#x3D; 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量 True 和 False 等价。 (a &lt; b) 返回 True。 &gt;&#x3D; 大于等于 - 返回x是否大于等于y。 (a &gt;&#x3D; b) 返回 False。 &lt;&#x3D; 小于等于 - 返回x是否小于等于y。 (a &lt;&#x3D; b) 返回 True。 Python赋值运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 &#x3D; 简单的赋值运算符 c &#x3D; a + b 将 a + b 的运算结果赋值为 c +&#x3D; 加法赋值运算符 c +&#x3D; a 等效于 c &#x3D; c + a -&#x3D; 减法赋值运算符 c -&#x3D; a 等效于 c &#x3D; c - a *&#x3D; 乘法赋值运算符 c *&#x3D; a 等效于 c &#x3D; c * a &#x2F;&#x3D; 除法赋值运算符 c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a %&#x3D; 取模赋值运算符 c %&#x3D; a 等效于 c &#x3D; c % a **&#x3D; 幂赋值运算符 c **&#x3D; a 等效于 c &#x3D; c ** a &#x2F;&#x2F;&#x3D; 取整除赋值运算符 c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a Python位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13，二进制格式如下： 12345678910111213a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：将二进制表示中的每一位取反，0 变为 1，1 变为 0。**~x** 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011 (以补码形式表示)，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，**&gt;&gt;** 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 Python逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 Python身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) &#x3D;&#x3D; id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 **id(a) !&#x3D; id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注意 id() 函数用于获取对象内存地址。 Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * &#x2F; % &#x2F;&#x2F; 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;&#x3D; &lt; &gt; &gt;&#x3D; 比较运算符 &lt;&gt; &#x3D;&#x3D; !&#x3D; 等于运算符 &#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D; 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 数据类型Python数据类型分为 三大类： 数值类型 序列类型 散列（映射）类型 一 数值类型这些类型都是不可变的。 1. 整数类型 int什么是整数？ 由0-9组成的数都叫整数 12# 0 1 2 3 4 5 6 7 8 9a = 0 2. 浮点数类型 float什么是浮点数？ 有小数点的数叫浮点数 也就是我们数学中说的小数 1234# 10.1# 10.0# 10.25a = 10.1 3. 布尔类型 bool什么是布尔类型？ 布尔类型代表真假 只有两个值 布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。 布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。 布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。 在Python中，布尔类型实际上是整型（int）的子类，因此布尔值在某些情况下可以与数字进行操作，并被视为数字 1（True）和 0（False）。与其他数值类型一样，布尔类型也是不可变的，它有两个值：True 和 False True 真 12Truea = True # 1 False 假 12Falsea = False # 0 注意 在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 0、空字符串、空列表、空元组等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。 4. 复数 complex复数在Python中也是一种数值类型，用于表示具有实部和虚部的数。在数学中，复数通常写作 a + bj，其中 a 是实部，b 是虚部，而 j（在Python中用 j 或 J 表示）是虚数单位。 实部（Real Part）：这是复数中的常规数字部分，没有乘以虚数单位。 虚部（Imaginary Part）：这部分乘以虚数单位 j。在数学上，j 是一个特殊的值，其平方等于 -1。 在Python中，可以使用 complex(real, imag) 函数或直接用 real + imagj 表式来创建复数。例如 12345# 使用 complex 函数c1 = complex(2, 3) # 创建复数 2 + 3j# 直接定义c2 = 2 + 3j # 同样创建复数 2 + 3j 5. 算术运算符 加法运算符（+）：用于对两个数值或字符串进行相加操作。 减法运算符（-）：用于对两个数值进行相减操作。 乘法运算符（*）：用于对两个数值进行相乘操作。 除法运算符（&#x2F;）：用于对两个数值进行相除操作。 二 序列类型非常常见的一种数据类型，它表示一组按照一定顺序排列的值的集合 序列类型的基本介绍1. 字符串 str写在单引号、双引号的内容 被称为字符串类型。 可以随便写任何内容、小数、特殊符号、文字 不能修改里面的数据 特点：可以存任意内容，不能修改 写法： 单引号 123&#x27;我是字符串 随便写什么内容 @！123123&#x27;# 示例：a = &#x27;我是字符串 随便写什么内容 @！123123&#x27; 双引号 123&quot;我是字符串 随便写什么内容 @！123123&quot;# 示例：a = &quot;我是字符串 随便写什么内容 @！123123&quot; 有没有区别？ 没有区别 反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n 会显示，并不是换行。 按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。 字符串可以用 + 运算符连接在一起，用 ***** 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python 中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 索引值以 0 为开始值，**-1** 为从末尾的开始位置 Python字符串运算符下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”： 操作符 描述 实例 + 字符串连接 &gt;&gt;&gt;a + b ‘HelloPython’ * 重复输出字符串 &gt;&gt;&gt;a * 2 ‘HelloHello’ [] 通过索引获取字符串中字符 &gt;&gt;&gt;a[1] ‘e’ [ : ] 截取字符串中的一部分 &gt;&gt;&gt;a[1:4] ‘ell’ in 成员运算符 - 如果字符串中包含给定的字符返回 True &gt;&gt;&gt;”H” in a True not in 成员运算符 - 如果字符串中不包含给定的字符返回 True &gt;&gt;&gt;”M” not in a True r&#x2F;R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 &gt;&gt;&gt;print r’\\n’ \\n &gt;&gt;&gt; print R’\\n’ \\n 2. 列表 list 可以存储多个值，每个数据用逗号分隔可以修改存储的数据，数据是可以修改的 特点：存多个值、可修改 写法： 123[1, &#x27;武松&#x27;, 12.3, True]# 示例：a = [1, &#x27;武松&#x27;, 12.3, True] Python列表脚本操作符列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。 如下所示： Python 表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 Python列表截取描述： Python 表达式 结果 描述 L[2] ‘Taobao’ 读取列表中第三个元素 L[-2] ‘Runoob’ 读取列表中倒数第二个元素 L[1:] [‘Runoob’, ‘Taobao’] 从第二个元素开始截取列表 3. 元组 tuple 可以存储多个值，每个数据用逗号分隔，不可以修改里面的数据 特点：存多个值、不可以修改 写法： 123(1, &#x27;武松&#x27;, 12.3, True)# 示例a = (1, &#x27;武松&#x27;, 12.3, True) 元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print x, 1 2 3 迭代 元组索引，截取因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示： 元组： 1L = (&#x27;spam&#x27;, &#x27;Spam&#x27;, &#x27;SPAM!&#x27;) Python 表达式 结果 描述 L[2] ‘SPAM!’ 读取第三个元素 L[-2] ‘Spam’ 反向读取，读取倒数第二个元素 L[1:] (‘Spam’, ‘SPAM!’) 截取元素 序列类型的方法1. 索引123作用： 取序列类型的一个元素 从左往右取值 从0开始： 12# 以变量a为例子a = &#x27;我真的很帅&#x27; 字符 我 真 的 很 帅 索引 0 1 2 3 4 12345a[0] # 我a[1] # 真a[2] # 的a[3] # 很a[4] # 帅 从右往左取值 从-1开始 12# 以变量a为例子a = &#x27;我真的很帅&#x27; 字符 我 真 的 很 帅 索引 -5 -4 -3 -2 -1 2. 切片123作用： 取序列类型的多个元素 如何使用？ 1234567[形参1:形参2:形参3]# 形参1 是从索引几开始# 形参2 是到索引几结束 但是不包含当前索引# 形参3 是步长 根据索引每次走几步a = &#x27;我真的很帅&#x27;print(a[0:3:1]) # 我真的print(a[0:3:2]) # 我的 3. 类型切换列表转字符串假设有一个列表 my_list，可以使用 join() 函数将其元素连接成一个字符串。join() 函数需要一个字符串作为分隔符，用来连接列表中的元素。 123my_list = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]my_string = &#x27;, &#x27;.join(my_list)print(my_string) # 输出: apple, banana, cherry 使用字符串连接 1234lst = [1, 2, 3, 4, 5]result_str = &quot;&quot;for item in lst: result_str += str(item) # 转换每个元素为字符串并连接 使用列表推导和字符串连接 12lst = [1, 2, 3, 4, 5]result_str = &#x27;&#x27;.join([str(item) for item in lst]) 使用 join 和映射（map） 12lst = [1, 2, 3, 4, 5]result_str = &#x27;&#x27;.join(map(str, lst)) 元组转字符串对于元组，方法与列表类似。假设有一个元组 my_tuple，同样可以使用 join() 函数。 123my_tuple = (&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;)my_string = &#x27;, &#x27;.join(my_tuple)print(my_string) # 输出: apple, banana, cherry 注意事项 如果列表或元组中包含非字符串类型（如整数或浮点数），则需要先将它们转换为字符串，然后才能使用 join() 函数。例如，对于一个整数列表 my_list = [1, 2, 3]，可以使用列表推导式 [str(x) for x in my_list] 将其转换为字符串列表，然后再使用 join()。 join() 函数中的分隔符可以是任何字符串，包括空字符串。 str(my_list)：提供列表的完整文本表示，包括方括号和元素引号。 str(my_tuple)：提供元组的完整文本表示，包括圆括号和元素引号。 join()：用于将列表或元组中的字符串元素连接成一个单一的、格式化的字符串，不包括列表的结构标记，如方括号。需要列表元素都是字符串类型。 字符串转列表使用 split() 方法可以将字符串分割成列表。需要指定一个分隔符，它将字符串在每个分隔符处分割。 例如，有一个以逗号分隔的字符串，可以这样将其转换为列表： 123my_string = &quot;apple, banana, cherry&quot;my_list = my_string.split(&quot;, &quot;)print(my_list) # 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;] 如果字符串没有明显的分隔符，split() 方法将默认以空格作为分隔符。 字符串转元组将字符串转换为元组的过程与转换为列表类似，只是在分割字符串之后，需要将得到的列表转换为元组。这可以通过将列表作为参数传递给 tuple() 函数来实现。 例如： 1234my_string = &quot;apple, banana, cherry&quot;my_list = my_string.split(&quot;, &quot;)my_tuple = tuple(my_list)print(my_tuple) # 输出: (&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;) 注意事项 如果字符串中包含特殊字符或格式复杂，可能需要使用更复杂的方法（如正则表达式）来正确分割字符串。 分隔符应根据字符串的实际内容选择。如果选择错误的分隔符，结果可能不会按预期分割。 信息 .join() 是 Python 中的一个字符串方法，用于将序列中的元素连接成一个新的字符串。这个方法是非常有用的，尤其是在需要将多个字符串元素组合成一个单一字符串的情况下。下面详细介绍这个方法的工作原理和使用方式。 工作原理 .join() 方法被调用的对象必须是一个字符串，这个字符串会成为元素之间的连接符。 它接受一个参数，这个参数是一个包含字符串元素的序列（如列表、元组、集合或任何可迭代对象）。 方法将序列中的每个元素合并成一个字符串，元素之间插入调用 .join() 的字符串。 基本用法 假设有一个列表 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]，你想将其连接成一个字符串，每个元素之间用逗号分隔： 123elements = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]result = &#x27;,&#x27;.join(elements)print(result) # 输出: a,b,c 在这个例子中，.join() 被逗号字符串 &#39;,&#39; 调用，因此它会在列表 elements 中的每个元素之间插入逗号。 注意事项 序列中的元素必须是字符串。如果序列中包含任何非字符串类型（如整数或浮点数），则会引发 TypeError。在这种情况下，你需要先将元素转换为字符串，通常可以通过列表推导和 str() 函数实现。 如果序列为空，.join() 返回一个空字符串。 示例 将数字列表转换为逗号分隔的字符串： 12345numbers = [1, 2, 3, 4, 5]# 将数字转换为字符串string_numbers = [str(num) for num in numbers]result = &#x27;,&#x27;.join(string_numbers)print(result) # 输出: 1,2,3,4,5 在这个例子中，我们首先使用列表推导将数字列表 numbers 转换为字符串列表 string_numbers。然后使用 .join() 方法来连接这些字符串。 使用场景 连接日志文件的多行。 生成或解析CSV文件。 创建查询字符串或URL。 .join() 是一个非常实用的方法，尤其在处理字符串和文本处理时非常有用。它的效率通常比传统的字符串连接（使用 + 操作符）要高，尤其是在处理大量字符串时。 三 序列类型方法什么是方法？方法是对象的属性，是一种可以对对象进行操作的 函数 为什么使用方法？使用方法可以让代码更加模块化和可复用。通过把一些操作封装在方法中，我们可以更方便地对数据进行处理，也可以避免代码的重复和冗余。同时，方法的使用也可以使代码更易读、易懂和易维护。 列表、元组、字符串方法？用来对里面的数据进行增删改查 1.我们可以把 列表、字符串和元组、分别理解为三个英雄 2.它们都有 对应的方法、方法也就是英雄的技能、 3.使用 英雄的技能可以快速杀敌 4.使用方法能快速的进行数据的 增删改查 列表 1. 增加示例12345678910111213141516171819a = [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;] # 创建一个变量名a，这是一个列表# 内置方法：# 增加# 1. append 方法 在列表末尾添加一个元素# 添加 &#x27;这是添加物&#x27;a.append(&#x27;这是添加物&#x27;) # 通过append 这个方法 向 变量a 增加了 这是添加物print(a) # [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;, &#x27;这是添加物&#x27;]# 2. insert 方法 在列表指定位置插入元素# 插入&#x27;这是插入物&#x27;a.insert(1, &#x27;这是插入物&#x27;)print(a) # [&#x27;这&#x27;, &#x27;这是插入物&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;, &#x27;这是添加物&#x27;]# 3. extend 方法 在列表末尾添加另一个列表的所有元素# 添加列表b = [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;另&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]a.extend(b)print(a) #[&#x27;这&#x27;, &#x27;这是插入物&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;, &#x27;这是添加物&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;另&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;] 2. 删除示例12345678910111213a = [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;] # 创建一个变量名a，这是一个列表# 删除# 4. pop 方法 通过索引移除列表中的一个元素（默认最后一个），并返回该元素的值a.pop(3)print(a) # [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]# 5. remove 方法 通过元素移除列表中的一个元素a.remove(&#x27;一&#x27;)print(a) #[&#x27;这&#x27;, &#x27;是&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]# 6. clear 方法 移除列表的所有元素a.clear()print(a) #[] 3. 修改示例1234a = [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;] # 创建一个变量名a，这是一个列表# 7. 直接在对于索引修改用 &#x27;=&#x27;a[0] = &#x27;不&#x27;print(a) #[&#x27;不&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;] 4. 查询示例12345678a = [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;] # 创建一个变量名a，这是一个列表# 8. index 方法 返回指定元素在列表第一次出现的索引位置result = a.index(&#x27;一&#x27;)print(result) # 2# 9. count 方法 返回指定元素在列表出现的次数result = a.count(&#x27;列&#x27;)print(result) # 1 5. 其它示例12345678910111213141516a = [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;] # 创建一个变量名a，这是一个列表# 10. copy 方法 复制一份变量的内容result = a.copy()print(result) # [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]# 11. reverse 方法 反转列表的元素a.reverse()print(a) # [&#x27;表&#x27;, &#x27;列&#x27;, &#x27;个&#x27;, &#x27;一&#x27;, &#x27;是&#x27;, &#x27;这&#x27;]b = [89, 5, 43, 38, 34, 78] # 创建一个变量名b，存储列表用于排序# 12. sort方法 从小到大排序列表b.sort()print(b) # [5, 34, 38, 43, 78, 89]# reverse = True 则从大到小 b.sort(reverse = True)print(b) # [89, 78, 43, 38, 34, 5] 注意 1、List写在方括号之间，元素用逗号隔开。 2、和字符串一样，list可以被索引和切片。 3、List可以使用+操作符进行拼接。 4、List中的元素是可以改变的。 Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 元组 1. 查询示例123456789101112a = (&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;) # 创建一个变量名a，这是一个元组# 1. count 方法 返回指定元素在元组出现的次数result = a.count(&#x27;列&#x27;)print(result) # 1# 2. index 方法 返回指定元素在元组第一次出现的索引位置result = a.index(&#x27;一&#x27;)print(result) # 2# 3. len 方法 返回元组中元素的个数result = len(a)print(result) # 6 2. 添加示例1234567a = (&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;) # 创建一个变量名a，这是一个元组b = (&#x27;这&#x27;, &#x27;是&#x27;, &#x27;另&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;) # 创建一个变量名b，这是另一个元组# 4. 合并两个元组为一个元组print(a + b) #[&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;另&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;]# 5. 将元组重复指定次数print(a * 4) # [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;] 3. 内置方法12345678910c = (1, 2, 3) # 创建一个变量名c，1,2,3# 6. max 方法 返回元组中元素的最大值print(max(c)) # 3# 7. min 方法 返回元组中元素的最小值print(min(c)) # 1d = &#x27;12345&#x27;# 8. tuple 方法 将列表或者其它可迭代对象转成元组print(tuple(d)) # (&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;) 字符串 1. 删除示例12345# 1. replace 把对象中有的值放到第一个参数中替换成第二个参数a = &#x27;值1&#x27;b = a.replace(&#x27;1&#x27;,&#x27;2&#x27;)print(a) # 值1, 字符串不允许被修改print(b) # 值2，修改结果存储到新的变量b 2. 修改示例1234567891011121314# 2. upper 把所有字符串字母改成大写a = &#x27;asd&#x27;result = a.upper()print(result) # ASD# 3. lower 把所有字符串字母改成小写a = &#x27;ASD&#x27;result = a.lower()print(result) # asd# 4. strip 去除字符串首尾指定字符，不传参默认空格a = &#x27;AsAA&#x27;result = a.strip(&#x27;A&#x27;)print(result) # s 3. 查询示例123456789101112a = &#x27;这是一个字符串&#x27; # 创建一个变量名a，这是一个字符串# 5. count 方法 返回指定元素在字符串出现的次数result = a.count(&#x27;一&#x27;)print(result) # 1# 8. find 方法 如果包含子字符串返回开始的索引值，否则返回-1result = a.find(&#x27;一&#x27;)print(result) # 2# 7. index 方法 返回指定元素在字符串第一次出现的索引位置，没有则报错result = a.index(&#x27;一&#x27;)print(result) # 2 4. 转义示例1234567891011121314151617181920212223242526272829303132# 8. \\n 换行a = &#x27;这是一个\\n字符串&#x27; # 创建一个变量名a，这是一个字符串print(a) #这是一个 #字符串 # 9. \\t 水平制表符/空格a = &#x27;这是一个\\t字符串&#x27; # 创建一个变量名a，这是一个字符串print(a) #这是一个 字符串# 10. \\b 退格a = &#x27;这是一个\\b字符串&#x27; # 创建一个变量名a，这是一个字符串print(a) #这是一字符串# 11. \\r 回车，当前位置回到开头，会把前面整个去掉a = &#x27;这是一个\\r字符串&#x27; # 创建一个变量名a，这是一个字符串print(a) #字符串# 12. \\\\ 反斜杠a = &#x27;这是一个\\\\字符串&#x27; # 创建一个变量名a，这是一个字符串print(a) #这是一个\\字符串# 13. \\&#x27; 单引号a = &#x27;这是一个\\&#x27;字符串&#x27; # 创建一个变量名a，这是一个字符串print(a) #这是一个&#x27;字符串# 14. \\0 空字符a = &#x27;这是一个\\0字符串&#x27; # 创建一个变量名a，这是一个字符串print(a) #这是一个 字符串# 15. \\a 系统提示音a = &#x27;这是一个\\a字符串&#x27; # 创建一个变量名a，这是一个字符串print(a) #这是一个字符串 5. 拼接示例123456789101112131415161718192021# 16. + 拼接方法a = &#x27;这是&#x27;b = &#x27;字符串&#x27;print(a + b) # 这是字符串 # 17. join 拼接方法a = [&#x27;2023&#x27;, &#x27;12&#x27;, &#x27;02&#x27;] # 列表result = &#x27;-&#x27;.join(a)print(result) # 2023-12-02 结果会变为字符串# 18. format 拼接方法a = &#x27;这是&#x27;b = &#x27;一个&#x27;result = &#x27;&#123;&#125;&#123;&#125;字符串&#x27;.format(a, b) # 插入多个值有顺序关系与&#123;&#125;一一对应print(result) # 这是一个字符串# 19. f插值法a = &#x27;这是&#x27;b = &#x27;一个&#x27;print(f&quot;&#123;a&#125;&#123;b&#125;字符串&quot;) # 这是一个字符串 6. 编码和解码 123456789# 编码name = &quot;字符串&quot; # 定义一个变量叫name 存储字符串encode_result = name.encode(&quot;UTF-8&quot;) # 通过encode进行编码为UTF-8print(encode_result) # 结果为b&#x27;\\xe5\\xad\\x97\\xe7\\xac\\xa6\\xe4\\xb8\\xb2&#x27;# &quot;意味着字符串&quot;在utf8中为\\xe5\\xad\\x97\\xe7\\xac\\xa6\\xe4\\xb8\\xb2,其中b是二进制的意思# 解码decode_result = encode_result.decode(&quot;UTF-8&quot;)print(decode_result) # 字符串 四 散列（映射）类型集合和字典集合、字典方法用来对里面的数据进行增删改查 我们可以把集合、字典、分别理解为二个英雄 它们都有对应的方法、方法也就是英雄的技能、 使用英雄的技能可以快速杀敌 使用方法能快速的进行数据的增删改查 1. 集合 set集合的特点： 不重复 里面有字符串的话就是无规则排序 没有字符串则按照输入的顺序排序 集合不能取值，因为是无序的，因为索引只在序列类型不在散列类型 12d = &#123;&quot;字符串2&quot;, 1, 2, 3, 2, &quot;字符串1&quot;&#125;print(d) # &#123;1, 2, 3, &#x27;字符串2&#x27;, &#x27;字符串1&#x27;&#125; 增加：1234d = &#123;&quot;字符串2&quot;, 1, 2, 3, 2, &quot;字符串1&quot;&#125; # 变量d存储集合# 1. add 方法 将元素无序添加到集合中去d.add(&#x27;添加的字符串&#x27;)print(d) # &#123;1, 2, 3, &#x27;字符串1&#x27;, &#x27;添加的字符串&#x27;, &#x27;字符串2&#x27;&#125; 删除：123456789101112131415d = &#123;&quot;字符串2&quot;, 1, 2, 3, 2, &quot;字符串1&quot;&#125; # 变量d存储集合# 2. pop 方法 随机删除一个元素result = d.pop()print(&quot;被删除的元素是：&quot;, result) # 被删除的元素是： 1print(&quot;被删除后的集合结果：&quot;, d) # 被删除后的集合结果： &#123;2, 3, &#x27;字符串2&#x27;, &#x27;字符串1&#x27;&#125;# 3. remove 方法 删除指定元素，变量a里面没有的元素，就会报错d.remove(2)print(d) # &#123;1, 3, &#x27;字符串2&#x27;, &#x27;字符串1&#x27;&#125;# 4. update 方法 将另一个集合的元素随机且不重复添加到当前的集合中d = &#123;&quot;字符串2&quot;, 1, 2, 3, 2, &quot;字符串1&quot;&#125; # 变量d存储集合e = &#123;&quot;另外一个字符串3&quot;, &quot;另外一个字符串4&quot;, 5, 5, 7, 8&#125; # 变量d存储集合d.update(e)print(d) # &#123;1, 2, 3, &#x27;字符串1&#x27;, 5, &#x27;另外一个字符串4&#x27;, 7, 8, &#x27;字符串2&#x27;, &#x27;另外一个字符串3&#x27;&#125; 2. 字典 dict 字典的特点： 存值的方式以键值对的方式存储 可以取值 不能用索引 1234567891011# 键值对a = &#123; # &#x27;key&#x27; 键 所有的键都要用引号 # &#x27;value&#x27; 值 任意定义 # 冒号 作用分割 左右两边 &#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12&#125;# 利用key来取值print(a[&#x27;key1&#x27;]) #value1 增加：12345678910111213# 键值对a = &#123; # &#x27;key&#x27; 键 所有的键都要用引号 # &#x27;value&#x27; 值 任意定义 # 冒号 作用分割 左右两边 &#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12&#125;#5. setdefault 有则查，无则增a.setdefault(&#x27;key3&#x27;, &#x27;value2&#x27;)print(a) # &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12, &#x27;key3&#x27;: &#x27;value2&#x27;&#125; 增加print(a.setdefault(&#x27;key2&#x27;)) # 12 查询 删除：12345678910111213141516# 键值对a = &#123; # &#x27;key&#x27; 键 所有的键都要用引号 # &#x27;value&#x27; 值 任意定义 # 冒号 作用分割 左右两边 &#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12&#125;#6. pop 删除指定key的键值对a.pop(&#x27;key1&#x27;) # 删除了变量a中的key1print(a) # &#123;&#x27;key2&#x27;: 12&#125;# 7. popitem 返回并删除字典中的最后一对键和值a.popitem() # 删除了变量a中的key2print(a) # &#123;&#x27;key1&#x27;: &#x27;value1&#x27;&#125; 修改：12345678910111213141516171819# 键值对# 8. update 用于将一个字典中的键值对添加到另一个字典中a = &#123; # &#x27;key&#x27; 键 所有的键都要用引号 # &#x27;value&#x27; 值 任意定义 # 冒号 作用分割 左右两边 &#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12&#125;b = &#123; # &#x27;key&#x27; 键 所有的键都要用引号 # &#x27;value&#x27; 值 任意定义 # 冒号 作用分割 左右两边 &#x27;key3&#x27;: &#x27;value3&#x27;&#125;a.update(b) # 将字典b的值update 写到这个变量a中去print(a) # &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12, &#x27;key3&#x27;: &#x27;value3&#x27;&#125; 查询：12345678910111213141516171819a = &#123; # &#x27;key&#x27; 键 所有的键都要用引号 # &#x27;value&#x27; 值 任意定义 # 冒号 作用分割 左右两边 &#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12&#125;# 9. get 获取指定key对应的value，如果key不存在返回noneprint(a.get(&#x27;key1&#x27;)) # value1# 10. keys 取出所有的keyprint(a.keys()) # dict_keys([&#x27;key1&#x27;, &#x27;key2&#x27;])# 11. values 取出所有的valuesprint(a.values()) # dict_values([&#x27;value1&#x27;, 12])# 12. items 取出所有完整的键值对print(a.items()) # dict_items([(&#x27;key1&#x27;, &#x27;value1&#x27;), (&#x27;key2&#x27;, 12)]) 3. 区别 都是花括号，但是存值方式 集合 是一个一个存， 用逗号, 分割，无序不重复，不能取值 字典 以键值对的方式存储，应用场景更多，可以取值 冻结集合冻结集合（Frozen Set）是Python中的一个内置类型，它与普通集合（Set）类似，但有一个关键的区别：冻结集合是不可变的。这意味着一旦创建了冻结集合，就不能再添加或删除其中的元素。这种特性使得冻结集合成为一种特殊的、不可更改的集合类型。 特性和用途 不可变性（Immutability）： 冻结集合一旦创建，其内容不能被更改。这包括不能添加新元素，也不能从集合中删除元素。 可哈希性（Hashability）： 由于其不可变性，冻结集合是可哈希的（hashable），这意味着它们可以用作字典的键或另一个集合的元素。普通集合由于是可变的，不能被哈希，因此不能用在这些场景中。 支持集合操作： 冻结集合支持普通集合的各种操作，如并集、交集、差集和对称差集等。 创建冻结集合冻结集合可以通过内置的 frozenset() 函数创建。例如： 123456789# 创建一个空的冻结集合f_set = frozenset()# 从现有集合创建冻结集合normal_set = &#123;1, 2, 3&#125;f_set_from_normal = frozenset(normal_set)# 从其他可迭代对象创建冻结集合f_set_from_list = frozenset([4, 5, 6]) 使用场景由于其不可变性和可哈希性，冻结集合特别适用于以下场景： 作为字典的键。 作为另一个集合的元素。 在需要保证集合内容不被更改的情况下使用。 与普通集合的比较 普通集合：可变，支持添加和删除操作，不可哈希，不能用作字典的键或集合的元素。 冻结集合：不可变，不支持添加和删除操作，可哈希，可以用作字典的键或集合的元素。 总结 QA 问： 哪种数据类型属于可变数据类型？ 答： 在Python中，数据类型可以分为几种主要类别，如数值类型、序列类型和散列（映射）类型。在这些类别中，并不是只有列表是可变的。让我们逐一看看这些类型中的可变性： 数值类型（Numeric Types）: 这些包括整型（int）、浮点型（float）和复数（complex）。这些类型都是不可变的。 序列类型（Sequence Types）: 列表（List）: 这是可变的。你可以在列表中添加、删除或更改元素。 字符串（String）和元组（Tuple）: 这些是不可变的。一旦创建，你不能更改其内部的元素或字符。 散列类型（Mapping Types）: 字典（Dictionary）: 字典是可变的。你可以在字典中添加、删除或修改条目。 还有其他的类型，比如集合类型（Set Types），其中： 集合（Set） 是可变的，可以添加或删除元素。 冻结集合（Frozen Set） 是不可变的。 综上所述，在这些主要的数据类型中，列表、字典和集合是可变的，而数值类型、字符串、元组和冻结集合是不可变的。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"数据类型","slug":"数据类型","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"序列类型","slug":"序列类型","permalink":"https://www.yiuhangblog.com/tags/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/"},{"name":"方法","slug":"方法","permalink":"https://www.yiuhangblog.com/tags/%E6%96%B9%E6%B3%95/"},{"name":"编码和解码","slug":"编码和解码","permalink":"https://www.yiuhangblog.com/tags/%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/"}],"author":"Yiuhang Chan"}],"categories":[{"name":"RPA","slug":"RPA","permalink":"https://www.yiuhangblog.com/categories/RPA/"},{"name":"人工智能","slug":"人工智能","permalink":"https://www.yiuhangblog.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"数据抓取","slug":"数据抓取","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"数据库","slug":"数据库","permalink":"https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/categories/Python/"},{"name":"前端","slug":"前端","permalink":"https://www.yiuhangblog.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"理论","slug":"理论","permalink":"https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"},{"name":"CUDA","slug":"CUDA","permalink":"https://www.yiuhangblog.com/tags/CUDA/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.yiuhangblog.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"弘玑","slug":"弘玑","permalink":"https://www.yiuhangblog.com/tags/%E5%BC%98%E7%8E%91/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"JS逆向","slug":"JS逆向","permalink":"https://www.yiuhangblog.com/tags/JS%E9%80%86%E5%90%91/"},{"name":"编码","slug":"编码","permalink":"https://www.yiuhangblog.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"加解密","slug":"加解密","permalink":"https://www.yiuhangblog.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://www.yiuhangblog.com/tags/Scrapy/"},{"name":"Redis","slug":"Redis","permalink":"https://www.yiuhangblog.com/tags/Redis/"},{"name":"分布式","slug":"分布式","permalink":"https://www.yiuhangblog.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"网页抓取","slug":"网页抓取","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96/"},{"name":"Scrapyd","slug":"Scrapyd","permalink":"https://www.yiuhangblog.com/tags/Scrapyd/"},{"name":"算法","slug":"算法","permalink":"https://www.yiuhangblog.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"图像识别","slug":"图像识别","permalink":"https://www.yiuhangblog.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"自动化工具","slug":"自动化工具","permalink":"https://www.yiuhangblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"},{"name":"滑块验证","slug":"滑块验证","permalink":"https://www.yiuhangblog.com/tags/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81/"},{"name":"点触验证","slug":"点触验证","permalink":"https://www.yiuhangblog.com/tags/%E7%82%B9%E8%A7%A6%E9%AA%8C%E8%AF%81/"},{"name":"字符验证","slug":"字符验证","permalink":"https://www.yiuhangblog.com/tags/%E5%AD%97%E7%AC%A6%E9%AA%8C%E8%AF%81/"},{"name":"Selenium","slug":"Selenium","permalink":"https://www.yiuhangblog.com/tags/Selenium/"},{"name":"Requests","slug":"Requests","permalink":"https://www.yiuhangblog.com/tags/Requests/"},{"name":"页面解析","slug":"页面解析","permalink":"https://www.yiuhangblog.com/tags/%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90/"},{"name":"BS4","slug":"BS4","permalink":"https://www.yiuhangblog.com/tags/BS4/"},{"name":"beautifulsoup4","slug":"beautifulsoup4","permalink":"https://www.yiuhangblog.com/tags/beautifulsoup4/"},{"name":"Xpath","slug":"Xpath","permalink":"https://www.yiuhangblog.com/tags/Xpath/"},{"name":"网络协议","slug":"网络协议","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"网络类型","slug":"网络类型","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B/"},{"name":"网络架构","slug":"网络架构","permalink":"https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"可视化","slug":"可视化","permalink":"https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"商务智能","slug":"商务智能","permalink":"https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"Tableau","slug":"Tableau","permalink":"https://www.yiuhangblog.com/tags/Tableau/"},{"name":"Power BI","slug":"Power-BI","permalink":"https://www.yiuhangblog.com/tags/Power-BI/"},{"name":"Power Query","slug":"Power-Query","permalink":"https://www.yiuhangblog.com/tags/Power-Query/"},{"name":"函数","slug":"函数","permalink":"https://www.yiuhangblog.com/tags/%E5%87%BD%E6%95%B0/"},{"name":"思路","slug":"思路","permalink":"https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"},{"name":"用户画像","slug":"用户画像","permalink":"https://www.yiuhangblog.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"},{"name":"业务目标","slug":"业务目标","permalink":"https://www.yiuhangblog.com/tags/%E4%B8%9A%E5%8A%A1%E7%9B%AE%E6%A0%87/"},{"name":"RFM","slug":"RFM","permalink":"https://www.yiuhangblog.com/tags/RFM/"},{"name":"关联分析","slug":"关联分析","permalink":"https://www.yiuhangblog.com/tags/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"},{"name":"模板","slug":"模板","permalink":"https://www.yiuhangblog.com/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"指标拆解","slug":"指标拆解","permalink":"https://www.yiuhangblog.com/tags/%E6%8C%87%E6%A0%87%E6%8B%86%E8%A7%A3/"},{"name":"落地流程","slug":"落地流程","permalink":"https://www.yiuhangblog.com/tags/%E8%90%BD%E5%9C%B0%E6%B5%81%E7%A8%8B/"},{"name":"报告","slug":"报告","permalink":"https://www.yiuhangblog.com/tags/%E6%8A%A5%E5%91%8A/"},{"name":"FineBI","slug":"FineBI","permalink":"https://www.yiuhangblog.com/tags/FineBI/"},{"name":"数据处理","slug":"数据处理","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"案例","slug":"案例","permalink":"https://www.yiuhangblog.com/tags/%E6%A1%88%E4%BE%8B/"},{"name":"组件","slug":"组件","permalink":"https://www.yiuhangblog.com/tags/%E7%BB%84%E4%BB%B6/"},{"name":"数据库","slug":"数据库","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://www.yiuhangblog.com/tags/SQL/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://www.yiuhangblog.com/tags/Matplotlib/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yiuhangblog.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://www.yiuhangblog.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://www.yiuhangblog.com/tags/HTML/"},{"name":"Pandas","slug":"Pandas","permalink":"https://www.yiuhangblog.com/tags/Pandas/"},{"name":"NumPy","slug":"NumPy","permalink":"https://www.yiuhangblog.com/tags/NumPy/"},{"name":"Python","slug":"Python","permalink":"https://www.yiuhangblog.com/tags/Python/"},{"name":"基本语法","slug":"基本语法","permalink":"https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"迭代器","slug":"迭代器","permalink":"https://www.yiuhangblog.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"生成器","slug":"生成器","permalink":"https://www.yiuhangblog.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.yiuhangblog.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"re模块","slug":"re模块","permalink":"https://www.yiuhangblog.com/tags/re%E6%A8%A1%E5%9D%97/"},{"name":"元字符","slug":"元字符","permalink":"https://www.yiuhangblog.com/tags/%E5%85%83%E5%AD%97%E7%AC%A6/"},{"name":"异常","slug":"异常","permalink":"https://www.yiuhangblog.com/tags/%E5%BC%82%E5%B8%B8/"},{"name":"断言","slug":"断言","permalink":"https://www.yiuhangblog.com/tags/%E6%96%AD%E8%A8%80/"},{"name":"持久化存储","slug":"持久化存储","permalink":"https://www.yiuhangblog.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"},{"name":"os模块","slug":"os模块","permalink":"https://www.yiuhangblog.com/tags/os%E6%A8%A1%E5%9D%97/"},{"name":"装饰器","slug":"装饰器","permalink":"https://www.yiuhangblog.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"new方法","slug":"new方法","permalink":"https://www.yiuhangblog.com/tags/new%E6%96%B9%E6%B3%95/"},{"name":"私有属性","slug":"私有属性","permalink":"https://www.yiuhangblog.com/tags/%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7/"},{"name":"单列模式","slug":"单列模式","permalink":"https://www.yiuhangblog.com/tags/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F/"},{"name":"对象","slug":"对象","permalink":"https://www.yiuhangblog.com/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://www.yiuhangblog.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"类","slug":"类","permalink":"https://www.yiuhangblog.com/tags/%E7%B1%BB/"},{"name":"继承","slug":"继承","permalink":"https://www.yiuhangblog.com/tags/%E7%BB%A7%E6%89%BF/"},{"name":"多态","slug":"多态","permalink":"https://www.yiuhangblog.com/tags/%E5%A4%9A%E6%80%81/"},{"name":"封装","slug":"封装","permalink":"https://www.yiuhangblog.com/tags/%E5%B0%81%E8%A3%85/"},{"name":"抽象","slug":"抽象","permalink":"https://www.yiuhangblog.com/tags/%E6%8A%BD%E8%B1%A1/"},{"name":"嵌套","slug":"嵌套","permalink":"https://www.yiuhangblog.com/tags/%E5%B5%8C%E5%A5%97/"},{"name":"内置函数","slug":"内置函数","permalink":"https://www.yiuhangblog.com/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"name":"形参","slug":"形参","permalink":"https://www.yiuhangblog.com/tags/%E5%BD%A2%E5%8F%82/"},{"name":"实参","slug":"实参","permalink":"https://www.yiuhangblog.com/tags/%E5%AE%9E%E5%8F%82/"},{"name":"说明文档","slug":"说明文档","permalink":"https://www.yiuhangblog.com/tags/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"},{"name":"作用域","slug":"作用域","permalink":"https://www.yiuhangblog.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"https://www.yiuhangblog.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"匿名函数","slug":"匿名函数","permalink":"https://www.yiuhangblog.com/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"name":"控制流程","slug":"控制流程","permalink":"https://www.yiuhangblog.com/tags/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"name":"条件判断","slug":"条件判断","permalink":"https://www.yiuhangblog.com/tags/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"},{"name":"循环语句","slug":"循环语句","permalink":"https://www.yiuhangblog.com/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"三目运算","slug":"三目运算","permalink":"https://www.yiuhangblog.com/tags/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97/"},{"name":"数据类型","slug":"数据类型","permalink":"https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"序列类型","slug":"序列类型","permalink":"https://www.yiuhangblog.com/tags/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/"},{"name":"方法","slug":"方法","permalink":"https://www.yiuhangblog.com/tags/%E6%96%B9%E6%B3%95/"},{"name":"编码和解码","slug":"编码和解码","permalink":"https://www.yiuhangblog.com/tags/%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/"}]}