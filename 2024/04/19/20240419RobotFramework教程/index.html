<!DOCTYPE html>
<html lang="zh-CN,en,zh-TW,default">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Yiuhang Chan">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://www.yiuhangblog.com/2024/04/19/20240419robotframework教程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="Robot Framewor教程">
<meta property="og:type" content="article">
<meta property="og:title" content="Robot Framework教程">
<meta property="og:url" content="https://www.yiuhangblog.com/2024/04/19/20240419RobotFramework%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="角灯随笔">
<meta property="og:description" content="Robot Framewor教程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/30f9c15e-c904-4a47-6cde-d1cb3ba19900/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a8f424da-9faa-40fb-2adf-d3cb9b462100/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c917360e-1817-4962-de2f-0a68254a0b00/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d84105c8-19e3-445a-ce35-66360e9a1700/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6a381063-0304-4e9b-6da7-5312ec6f5600/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/709fba20-2801-4012-0612-4d57cbc43200/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1ac9b381-8f71-4466-9681-368a1e69a800/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93ca4a58-a443-4027-9294-03ca806b6b00/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/34c91105-04f3-434f-f33a-6e3a158b1200/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/35893b31-67ea-4ca1-09bd-cab884e15e00/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8a97fa57-b2c6-4d5e-4435-7d21045fcc00/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3d3a5186-3154-42c0-f5b0-3c9475e82200/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2fd623f9-0666-45a3-153e-59b80a81a900/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2fd623f9-0666-45a3-153e-59b80a81a900/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2d991a9f-4459-460d-bd01-e4f43e7faf00/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a40df1c6-4ecb-4437-8dc2-939499e0c900/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/069aff0f-278c-4451-ad5c-d1cebb8f0900/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b59df1e5-797c-4079-0589-fbe885be5300/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/566a2630-666b-4bec-05a3-8eba7d2b8100/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/13ab6da9-18d2-4f79-09c7-b6696b2b1600/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/51120498-1e4d-4ff1-7174-748d8e830d00/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7a0b8697-21e4-4e9e-b22a-3fd202cfb600/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/593d9fd8-0a8c-480f-d07e-f8dec216af00/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7f041165-1451-418f-d454-1c4785938100/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bf52e2d4-81e5-4a49-ee76-6d131c334700/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9cc77ea9-064a-430b-ca42-a40a32760e00/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8dd82891-bf26-465a-2f08-616832e84700/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/33f1f2de-75e4-4140-3f48-628a0cd44800/public">
<meta property="og:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/be820dc8-4cc1-4691-1a32-66549a58b400/public">
<meta property="article:published_time" content="2024-04-19T03:17:08.000Z">
<meta property="article:modified_time" content="2024-04-25T08:44:46.043Z">
<meta property="article:author" content="Yiuhang Chan">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="理论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/30f9c15e-c904-4a47-6cde-d1cb3ba19900/public">
    
    
        <!-- Google tag (gtag.js) -->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-MQ43G0NKCT"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-MQ43G0NKCT');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e75f26bb-7787-428d-ec58-214a6faf9800/public" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e75f26bb-7787-428d-ec58-214a6faf9800/public">
    <meta name="theme-color" content="#A1AFC9">
    <link rel="shortcut icon" href="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e75f26bb-7787-428d-ec58-214a6faf9800/public">
    <!--- Page Info-->
    
    <title>
        
            Robot Framework教程 -
        
        角灯随笔
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        角灯随笔
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    


    <script id="hexo-configurations">
    window.config = {"hostname":"www.yiuhangblog.com","root":"/","language":["zh-CN","en","zh-TW","default"]};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"5rem","h2":"4rem","h3":"2.8rem","h4":"2.5rem","h5":"2.2rem","h6":"2rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":5,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A1AFC9","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"10000px","sidebar_width":"2100px","hover":{"shadow":true,"scale":true},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":true,"id":"G-MQ43G0NKCT"}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e63fc400-dd0e-4395-bd1b-9ee1ac3bfb00/public","dark":"https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a34140d6-7960-45dd-b8b5-c3ddd14d1f00/public"},"title":"角灯随笔","subtitle":{"text":["全栈也不是不行"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":false,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/CosmicTrace","instagram":null,"zhihu":null,"twitter":null,"email":"kenchansk0@gmail.com"},"qrs":null}},"plugins":{"feed":{"enable":true},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.6.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Tags":{"icon":"fa-solid fa-tags","path":"/tags/"},"Categories":{"icon":"fa-solid fa-folder","path":"/categories/"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"娱乐":{"icon":"fa-solid fa-gamepad","submenus":{"王者荣耀":"/hok","守望先锋":"/ow","使命召唤":"/cod"}},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/CosmicTrace"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"谦逊","show_on_mobile":true,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":8}},"footerStart":"2018/07/15 10:15:24"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="角灯随笔" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e75f26bb-7787-428d-ec58-214a6faf9800/public">
                </a>
            
            <a class="logo-title" href="/">
                
                角灯随笔
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-solid fa-gamepad fa-fw"></i>
                                    娱乐
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/hok">
                                                    王者荣耀
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a href="/ow">
                                                    守望先锋
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a href="/cod">
                                                    使命召唤
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    关于
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/CosmicTrace">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-娱乐"
                        >
                            <span>
                                娱乐
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-娱乐">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/hok">王者荣耀</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/ow">守望先锋</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/cod">使命召唤</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                关于
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/CosmicTrace">GITHUB</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">96</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">41</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                
                
                <img src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c3a21ff5-1f9a-481f-be10-75d841af2200/public" alt="Robot Framework教程" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75"/>
                
                <div class="w-full flex items-center absolute bottom-0 justify-start">
                    <h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-bold backdrop-blur-lg rounded-xl border border-border-color ">Robot Framework教程</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/26329e9f-d1fb-4280-a0a5-754547bf8500/public">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">Yiuhang Chan</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-04-19 11:17:08</span>
        <span class="mobile">2024-04-19 11:17:08</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-04-25 16:44:46</span>
            <span class="mobile">2024-04-25 16:44:46</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/RPA/">RPA</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E7%90%86%E8%AE%BA/">理论</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>145.1k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>563 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <h2 id="Robot-Framework-简介"><a href="#Robot-Framework-简介" class="headerlink" title="Robot Framework 简介"></a>Robot Framework 简介</h2><p>Robot Framework是一个通用的开源自动化框架。它可用于测试自动化和机器人流程自动化（RPA）。</p>
<p>Robot Framework受Robot Framework基金会支持。许多行业领先的公司在其软件开发中使用该工具。</p>
<p>Robot Framework是开放且可扩展的。Robot Framework可以与几乎任何其他工具集成，以创建强大且灵活的自动化解决方案。Robot Framework可以免费使用，无需许可费用。</p>
<p>Robot Framework具有易于理解的语法，利用人类可读的关键字。其功能可以通过使用Python、Java或许多其他编程语言实现的库来扩展。Robot Framework周围有一个丰富的生态系统，包括作为单独项目开发的库和工具。</p>
<p>Robot Framework的开发由非营利性的Robot Framework基金会资助。它由希望确保Robot Framework现在和将来持续发展的公司和组织组成。Robot Framework仍然完全免费使用，并且在积极进行维护和开发。基金会还覆盖其他相关费用，如开发此网站和组织各种聚会。</p>
<p>基金会成员：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/30f9c15e-c904-4a47-6cde-d1cb3ba19900/public"
                      width = "600"
                >

<h3 id="为什么选择-Robot-Framework？"><a href="#为什么选择-Robot-Framework？" class="headerlink" title="为什么选择 Robot Framework？"></a>为什么选择 Robot Framework？</h3><ul>
<li>提供了易于使用的表格语法，以统一的方式创建测试用例。</li>
<li>允许从现有关键字创建可重用的高级关键字。</li>
<li>提供易于阅读的以 HTML 格式的结果报告和日志。</li>
<li>平台和应用程序无关。</li>
<li>提供了一个简单的库 API，用于创建可以使用 Python 原生实现的定制测试库。</li>
<li>提供了命令行界面和基于 XML 的输出文件，用于集成到现有的构建基础设施（连续集成系统）中。</li>
<li>支持测试 Web 应用程序、REST API、移动应用程序、运行的进程、通过 Telnet 或 SSH 连接到远程系统等。</li>
<li>支持创建数据驱动的测试用例。</li>
<li>具有内置的变量支持，特别适用于在不同环境中进行测试。</li>
<li>提供标记以对测试用例进行分类和选择执行。</li>
<li>可以与源代码控制轻松集成：测试套件只是可以与生产代码一起进行版本控制的文件和目录。</li>
<li>提供了测试用例和测试套件级别的设置和拆卸。</li>
<li>模块化架构支持为具有多个不同接口的应用程序创建测试。</li>
</ul>
<h3 id="高级架构"><a href="#高级架构" class="headerlink" title="高级架构"></a>高级架构</h3><p>Robot Framework 是一个通用的、与应用程序和技术无关的框架。它具有高度模块化的架构，如下图所示：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a8f424da-9faa-40fb-2adf-d3cb9b462100/public"
                      width = "600"
                >

<p>测试数据以简单、易于编辑的表格格式存在。当启动 Robot Framework 时，它会处理数据，执行测试用例，并生成日志和报告。核心框架对被测试对象一无所知，与其交互由库处理。库可以直接使用应用程序接口，也可以使用较低级别的测试工具作为驱动程序。</p>
<h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><p>以下截屏展示了测试数据以及生成的报告和日志的示例。</p>
<p><strong>测试用例文件：</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c917360e-1817-4962-de2f-0a68254a0b00/public"
                      width = "600"
                >

<p><strong>报告和日志：</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d84105c8-19e3-445a-ce35-66360e9a1700/public"
                      width = "600"
                >

<h3 id="获取更多信息"><a href="#获取更多信息" class="headerlink" title="获取更多信息"></a>获取更多信息</h3><h4 id="项目页面"><a href="#项目页面" class="headerlink" title="项目页面"></a>项目页面</h4><p>有关 Robot Framework 及其丰富生态系统的更多信息，首要去处是 <a class="link"   target="_blank" rel="noopener" href="http://robotframework.org/" >http://robotframework.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。Robot Framework 本身托管在 GitHub 上。</p>
<h4 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h4><p>有几个 Robot Framework 邮件列表可供询问和搜索更多信息。邮件列表存档对所有人（包括搜索引擎）开放，每个人也可以自由加入这些列表。但只有列表成员才能发送邮件，为了防止垃圾邮件，新用户需要经过审核，这意味着的第一条消息可能需要一些时间才能通过。不要害怕向邮件列表发送问题，但请记住如何聪明地提问。</p>
<ul>
<li><strong>robotframework-users（Robot Framework 用户）</strong>：关于所有与 Robot Framework 相关问题的一般讨论。可以将问题和问题发送到此列表。也用于向所有用户共享信息。</li>
<li><strong>robotframework-announce（Robot Framework 公告）</strong>：仅供公告的邮件列表，只有管理员才能发送消息。所有公告也发送到 robotframework-users 邮件列表，因此没有必要加入两个列表。</li>
<li><strong>robotframework-devel（Robot Framework 开发）</strong>：关于 Robot Framework 开发的讨论。</li>
</ul>
<h4 id="版权和许可证"><a href="#版权和许可证" class="headerlink" title="版权和许可证"></a>版权和许可证</h4><p>Robot Framework 是一款开源软件，采用 Apache License 2.0 提供。Robot Framework 的文档，例如本用户指南，使用 Creative Commons Attribution 3.0 Unported 许可证。围绕该框架的更大生态系统中的大多数库和工具也是开源的，但它们可能使用不同的许可证。</p>
<p>完整的 Robot Framework 版权声明如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2008-2015 Nokia Networks</span><br><span class="line">Copyright 2016-     Robot Framework Foundation</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure></div>

<p>根据 Apache 许可证第 2.0 版（“许可证”）许可；除非符合许可证的规定，否则不得使用此文件。可以在以下网址获取许可证的副本：<a class="link"   target="_blank" rel="noopener" href="http://www.apache.org/licenses/LICENSE-2.0" >http://www.apache.org/licenses/LICENSE-2.0 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>除非适用法律要求或书面同意，否则根据许可证分发的软件以“原样”分发，不附带任何明示或暗示的保证或条件。请参阅许可证以了解特定语言下的权限和限制。</p>
<h2 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h2><p>这些指南涵盖了在不同操作系统上安装Robot Framework及其前置条件的步骤。如果已经安装了Python，可以使用标准的软件包管理器pip来安装Robot Framework：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install robotframework</span><br></pre></td></tr></table></figure></div>

<h3 id="Python-安装"><a href="#Python-安装" class="headerlink" title="Python 安装"></a>Python 安装</h3><p><strong>Robot Framework</strong> 是使用 <strong>Python</strong> 实现的，安装它的前提条件是已经安装了 <strong>Python</strong> 或其替代实现 <strong>PyPy</strong>。另一个推荐的前提条件是有 <strong>pip</strong> 包管理器可用。</p>
<p><strong>Robot Framework</strong> 需要 <strong>Python 3.8</strong> 或更新版本。支持 <strong>Python 3.6</strong> 和 <strong>3.7</strong> 的最新版本是 <strong>Robot Framework 6.1.1</strong>。如果需要使用 <strong>Python 2</strong>，<strong>Jython</strong> 或 <strong>IronPython</strong>，可以使用 <strong>Robot Framework 4.1.3</strong>。</p>
<h3 id="在-Linux-上安装-Python"><a href="#在-Linux-上安装-Python" class="headerlink" title="在 Linux 上安装 Python"></a>在 Linux 上安装 Python</h3><p>在 Linux 上，默认应该已经安装了适合的 Python 版本和 pip。如果没有，需要查阅发行版的文档来了解如何安装它们。如果想使用默认提供的 Python 版本之外的其他版本，这同样适用。</p>
<p>要检查已安装的 Python 版本，可以在终端运行 <code>python --version</code> 命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python --version</span></span><br><span class="line">Python 3.10.13</span><br></pre></td></tr></table></figure></div>

<p>注意，如果的发行版也提供了较旧的 Python 2，运行 <code>python</code> 可能会使用那个。要使用 Python 3，可以使用 <code>python3</code> 命令，或者更具体的版本命令，如 <code>python3.8</code>。如果安装了多个 Python 3 版本，也需要使用这些具体版本的变体来确定使用哪一个：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.11 --version</span></span><br><span class="line">Python 3.11.7</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.12 --version</span></span><br><span class="line">Python 3.12.1</span><br></pre></td></tr></table></figure></div>

<p>直接在系统提供的 Python 下安装 Robot Framework 存在风险，可能的问题会影响到操作系统本身也在使用的整个 Python 安装。现在的 Linux 发行版通常默认使用用户安装来避免此类问题，但用户也可以自己决定使用虚拟环境。</p>
<h3 id="Windows-上的-Python-安装"><a href="#Windows-上的-Python-安装" class="headerlink" title="Windows 上的 Python 安装"></a>Windows 上的 Python 安装</h3><ul>
<li>Windows 默认不提供 Python，但安装起来很简单。推荐使用官方 Windows 安装程序，可在 <a class="link"   target="_blank" rel="noopener" href="http://python.org/" >http://python.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 获取。</li>
<li>安装 Python 时，建议将 Python 添加到 PATH，以便从命令行更容易执行 Python 及其工具，如 pip 和 Robot Framework。使用官方安装程序时，只需在第一个对话框中选择 Add Python 3.x to PATH 复选框。</li>
</ul>
<p>验证 Python 安装是否成功并已添加到 PATH：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;python --version</span><br><span class="line">Python 3.10.9</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果在 Windows 上安装了多个 Python 版本，执行 python 时使用的是 PATH 中排在首位的版本。要使用其他版本，最简单的方法是使用 py 启动器：</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;py --version</span><br><span class="line">Python 3.10.9</span><br><span class="line">C:\&gt;py -3.12 --version</span><br><span class="line">Python 3.12.1</span><br></pre></td></tr></table></figure></div>

<h3 id="macOS-上的-Python-安装"><a href="#macOS-上的-Python-安装" class="headerlink" title="macOS 上的 Python 安装"></a>macOS 上的 Python 安装</h3><ul>
<li>macOS 默认不提供与 Python 3 兼容的 Python 版本，需要单独安装。推荐使用官方 macOS 安装程序，可在 <a class="link"   target="_blank" rel="noopener" href="http://python.org/" >http://python.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 获取。如果使用包管理器如 Homebrew，也可以通过它安装 Python。</li>
</ul>
<h3 id="PyPy-安装"><a href="#PyPy-安装" class="headerlink" title="PyPy 安装"></a>PyPy 安装</h3><ul>
<li>PyPy 是 Python 的替代实现。与标准 Python 实现相比，其主要优势是可能更快且使用更少内存，但这取决于使用的上下文。如果执行速度重要，至少测试 PyPy 是个好主意。</li>
</ul>
<p>PyPy 安装是一个简单的过程，可以在 <a class="link"   target="_blank" rel="noopener" href="http://pypy.org/" >http://pypy.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 找到安装程序和安装说明。验证 PyPy 安装是否成功：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pypy --version</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pypy3 --version</span></span><br></pre></td></tr></table></figure></div>

<p>注意：仅在 Linux 上官方支持使用 PyPy 的 Robot Framework。</p>
<h3 id="配置-PATH"><a href="#配置-PATH" class="headerlink" title="配置 PATH"></a>配置 PATH</h3><ul>
<li>PATH 环境变量列出了系统中执行命令时搜索的目录。为了便于从命令行使用 Python、pip 和 Robot Framework，建议将 Python 安装目录以及 pip 和 robot 等命令安装的目录添加到 PATH。</li>
<li>在 Linux 或 macOS 上使用 Python 时，Python 及其安装的工具应自动在 PATH 中。如果仍需更新 PATH，则通常需要编辑某些系统范围或用户特定的配置文件。具体编辑哪个文件以及如何编辑取决于操作系统，需要查阅其文档了解更多详情。</li>
<li>在 Windows 上，确保 PATH 配置正确的最简单方法是在运行安装程序时勾选 Add Python 3.x to PATH 复选框。手动修改 Windows 上的 PATH，请按照以下步骤操作：</li>
</ul>
<ol>
<li>在设置中找到环境变量。有影响整个系统的变量和仅影响当前用户的变量。修改前者将需要管理员权限，但通常只需修改后者。</li>
<li>选择 PATH（通常写作 Path）并点击编辑。如果正在编辑用户变量且 PATH 不存在，则点击新建。</li>
<li>将 Python 安装目录和安装目录下的 Scripts 目录都添加到 PATH 中。</li>
<li>点击确定退出对话框以保存更改。</li>
<li>启动新的命令提示符以使更改生效。</li>
</ol>
<h3 id="使用-pip-安装"><a href="#使用-pip-安装" class="headerlink" title="使用 pip 安装"></a>使用 pip 安装</h3><h4 id="pip-命令的运行"><a href="#pip-命令的运行" class="headerlink" title="pip 命令的运行"></a>pip 命令的运行</h4><ul>
<li>在 Linux 上，可能需要使用 <code>pip3</code> 或更具体的 Python 版本命令，如 <code>pip3.8</code>。</li>
<li>在 Windows 上，当执行 <code>python</code> 时，PATH 中首先找到的版本将被使用。如果需要使用其他版本，可以运行 <code>py</code> 启动器。</li>
</ul>
<h4 id="验证-pip-是否可用"><a href="#验证-pip-是否可用" class="headerlink" title="验证 pip 是否可用"></a>验证 pip 是否可用</h4><ul>
<li>Linux 示例：</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip --version</span></span><br><span class="line">pip 23.2.1 from ... (python 3.10)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.12 -m pip --version</span></span><br><span class="line">pip 23.3.1 from ... (python 3.12)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Windows 示例：</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; pip --version</span><br><span class="line">pip 23.2.1 from ... (python 3.10)</span><br><span class="line">C:\&gt; py -m 3.12 -m pip --version</span><br><span class="line">pip 23.3.2 from ... (python 3.12)</span><br></pre></td></tr></table></figure></div>

<h4 id="安装与卸载-Robot-Framework"><a href="#安装与卸载-Robot-Framework" class="headerlink" title="安装与卸载 Robot Framework"></a>安装与卸载 Robot Framework</h4><ul>
<li>从 Python 包索引 (PyPI) 安装和下载包是 pip 的常用方法。</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装最新版本（不升级）</span></span><br><span class="line">pip install robotframework</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级到最新稳定版本</span></span><br><span class="line">pip install --upgrade robotframework</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级到最新版本，即使它是预发布版本</span></span><br><span class="line">pip install --upgrade --pre robotframework</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装特定版本</span></span><br><span class="line">pip install robotframework==7.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装单独下载的包（无需网络连接）</span></span><br><span class="line">pip install robotframework-7.0-py3-none-any.whl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接从 GitHub 安装最新（可能未发布）的代码</span></span><br><span class="line">pip install https://github.com/robotframework/robotframework/archive/master.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载</span></span><br><span class="line">pip uninstall robotframework</span><br></pre></td></tr></table></figure></div>

<h3 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h3><p>如果没有pip可用，可以通过下载PyPI上的zip包并解压，或者克隆GitHub仓库并检出所需的发布标签来获取Robot Framework源代码。</p>
<p>安装源代码的命令如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></div>

<p><code>setup.py</code> 脚本接受多个参数，例如允许安装到不需要管理员权限的非默认位置。此外，该脚本也用于创建不同的发行包。运行 <code>python setup.py --help</code> 可以获取更多详情。</p>
<h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>为了确保安装了正确版本的Robot Framework，可以运行以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ robot --version</span><br></pre></td></tr></table></figure></div>

<p>如果出现命令未找到或无法识别的消息，首先应该检查PATH配置。</p>
<p>如果在多个Python版本下安装了Robot Framework，运行 <code>robot</code> 将执行PATH中的第一个。要显式选择，可以运行 <code>python -m robot</code> 并用正确的Python版本替换 <code>python</code>。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3.12 -m robot --version</span><br></pre></td></tr></table></figure></div>

<p>或在Windows上：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;py -3.11 -m robot --version</span><br></pre></td></tr></table></figure></div>

<h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>Python虚拟环境允许将Python包安装在特定系统或应用程序的隔离位置，而不是将所有包安装在同一全局位置。主要有两个用途：</p>
<ul>
<li>为不同项目将所需包安装在各自的环境中，避免如果项目需要不同版本的同一包时发生冲突。</li>
<li>避免在全局Python安装下安装所有内容。这在Linux上尤其重要，因为全局Python安装可能被发行版本身使用，搞乱它可能会导致严重问题。</li>
</ul>
<h2 id="设置集成开发环境"><a href="#设置集成开发环境" class="headerlink" title="设置集成开发环境"></a>设置集成开发环境</h2><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul>
<li><strong>Visual Studio Code</strong><ul>
<li>代码编辑。重新定义。免费。基于开源。无处不在。</li>
</ul>
</li>
<li><strong>PyCharm</strong><ul>
<li>专业开发人员的Python集成开发环境</li>
</ul>
</li>
</ul>
<h3 id="安装IDE和扩展"><a href="#安装IDE和扩展" class="headerlink" title="安装IDE和扩展"></a>安装IDE和扩展</h3><p>许多IDE和代码编辑器支持开发Robot Framework测试。</p>
<p>支持范围从简单的代码高亮、代码完成到测试执行和调试。</p>
<p>这里列出了几个IDE和扩展，但还有很多其他的选择。</p>
<h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p>由Microsoft开发的开源轻量级代码编辑器。它提供了许多不同语言和技术的扩展。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6a381063-0304-4e9b-6da7-5312ec6f5600/public"
                      width = "600"
                >

<p><strong>VS Code</strong></p>
<p>针对Robot Framework的常用扩展：</p>
<ul>
<li>Robot Code</li>
<li>Robot Framework Language Server</li>
</ul>
<h4 id="安装Visual-Studio-Code"><a href="#安装Visual-Studio-Code" class="headerlink" title="安装Visual Studio Code"></a>安装Visual Studio Code</h4><p>查看VS Code设置指南以获取更多信息。</p>
<ol>
<li>从Visual Studio Code下载Windows安装程序</li>
<li>使用默认设置运行安装程序</li>
<li>启动Visual Studio Code，方式有：<ul>
<li>按下 <code>Windows键 + R</code>，键入 <code>code</code>，然后按 <code>Enter</code></li>
<li>打开开始菜单，搜索 <code>Visual Studio Code</code>并单击打开</li>
</ul>
</li>
</ol>
<h4 id="Visual-Studio-Code扩展"><a href="#Visual-Studio-Code扩展" class="headerlink" title="Visual Studio Code扩展"></a>Visual Studio Code扩展</h4>
  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>确保仅安装了一个Robot Framework扩展。</p>

    </div>
  </div>

<p><strong>RobotCode</strong>是Visual Studio Code的一个Robot Framework扩展。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/709fba20-2801-4012-0612-4d57cbc43200/public"
                      width = "600"
                >

<ol>
<li>打开Visual Studio Code</li>
<li>点击扩展图标或按 <code>Ctrl + Shift + X</code></li>
<li>搜索 <code>RobotCode</code>并点击安装</li>
<li>点击安装</li>
</ol>
<p><strong>Robot Framework Language Server</strong>是Visual Studio Code的一个Robot Framework扩展。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1ac9b381-8f71-4466-9681-368a1e69a800/public"
                      width = "600"
                >

<ol>
<li>打开Visual Studio Code</li>
<li>点击扩展图标或按 <code>Ctrl + Shift + X</code></li>
<li>搜索 <code>Robot Framework Language Server</code>并点击安装</li>
<li>点击安装</li>
</ol>
<h4 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h4><p>PyCharm是一个免费开源的Python集成开发环境。</p>
<p>针对Robot Framework的常用扩展：</p>
<ul>
<li>Robot Framework Language Server</li>
</ul>
<h4 id="安装PyCharm"><a href="#安装PyCharm" class="headerlink" title="安装PyCharm"></a>安装PyCharm</h4><p>查看PyCharm安装指南以获取更多信息。</p>
<p>有两种安装方法：</p>
<ol>
<li>推荐使用JetBrains的Toolbox App。</li>
<li>替代的独立安装方法</li>
</ol>
<h4 id="PyCharm扩展"><a href="#PyCharm扩展" class="headerlink" title="PyCharm扩展"></a>PyCharm扩展</h4>
  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>确保仅安装了一个Robot Framework扩展。</p>

    </div>
  </div>

<p><strong>Robot Framework Language Server</strong></p>
<ol>
<li>按 <code>Ctrl + Alt + S</code>打开设置对话框</li>
<li>选择 <code>插件</code></li>
<li>选择 <code>市场</code>选项卡</li>
<li>搜索 <code>Robot Framework Language Server</code>并点击安装</li>
<li>为Robot Framework添加调试配置以运行当前测试套件</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93ca4a58-a443-4027-9294-03ca806b6b00/public"
                      width = "600"
                >

<ol start="6">
<li>为Robot Framework添加调试配置以运行当前测试用例（通过选择的文本）</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/34c91105-04f3-434f-f33a-6e3a158b1200/public"
                      width = "600"
                >


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果控制台输出问号或者乱码则在环境变量(Environment variables) 添加编码变量PYTHONIOENCODING&#x3D;UTF-8</p>

    </div>
  </div>

<h3 id="运行和调试Robot-Framework测试"><a href="#运行和调试Robot-Framework测试" class="headerlink" title="运行和调试Robot Framework测试"></a>运行和调试Robot Framework测试</h3><h4 id="使用Visual-Studio-Code和RobotCode"><a href="#使用Visual-Studio-Code和RobotCode" class="headerlink" title="使用Visual Studio Code和RobotCode"></a>使用Visual Studio Code和RobotCode</h4><p><strong>运行</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/35893b31-67ea-4ca1-09bd-cab884e15e00/public"
                      width = "600"
                >

<p><strong>调试</strong></p>
<ul>
<li>在测试套件或资源文件中点击行的左侧添加断点。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8a97fa57-b2c6-4d5e-4435-7d21045fcc00/public"
                      width = "600"
                >

<ul>
<li>右键单击播放按钮</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3d3a5186-3154-42c0-f5b0-3c9475e82200/public"
                      width = "600"
                >

<ul>
<li>从上下文菜单中选择“调试测试”，测试执行将开始，并在断点处停止。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2fd623f9-0666-45a3-153e-59b80a81a900/public"
                      width = "600"
                >

<ul>
<li>使用调试工具栏选择操作，如单步执行、进入、跳出、继续、暂停等。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2fd623f9-0666-45a3-153e-59b80a81a900/public"
                      width = "600"
                >

<ul>
<li>在调试控制台中调试时运行Robot Framework命令。</li>
<li>命令需要以！开头。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2d991a9f-4459-460d-bd01-e4f43e7faf00/public"
                      width = "600"
                >

<h4 id="使用PyCharm和Robot-Framework-Language-Server"><a href="#使用PyCharm和Robot-Framework-Language-Server" class="headerlink" title="使用PyCharm和Robot Framework Language Server"></a>使用PyCharm和Robot Framework Language Server</h4><p><strong>运行</strong></p>
<ul>
<li>运行当前测试套件</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a40df1c6-4ecb-4437-8dc2-939499e0c900/public"
                      width = "600"
                >

<ul>
<li>运行当前测试用例（通过选择的文本）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/069aff0f-278c-4451-ad5c-d1cebb8f0900/public"
                      width = "600"
                >

<p><strong>调试</strong></p>
<ul>
<li>调试测试</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b59df1e5-797c-4079-0589-fbe885be5300/public"
                      width = "600"
                >

<h3 id="使用Poetry管理依赖"><a href="#使用Poetry管理依赖" class="headerlink" title="使用Poetry管理依赖"></a>使用Poetry管理依赖</h3><p>Poetry是Python的一个依赖管理和打包工具。</p>
<p>它允许声明项目所依赖的库，并会为管理（安装&#x2F;更新）它们。在开始任何新的Python或Robot Framework项目时，都可以使用它。</p>
<p>按照官方指南安装Poetry。</p>
<p>在PowerShell中运行以下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -</span><br></pre></td></tr></table></figure></div>

<p>如果通过Microsoft Store安装了Python，将上述命令中的py替换为python。</p>
<p>运行一次poetry以检查是否已安装。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry --version</span><br></pre></td></tr></table></figure></div>

<h4 id="虚拟环境文件夹"><a href="#虚拟环境文件夹" class="headerlink" title="虚拟环境文件夹"></a>虚拟环境文件夹</h4><p>Poetry会在 <code>.poetry/envs</code>文件夹中保存虚拟环境。可以更改该设置，并通过运行以下命令将虚拟环境存储在项目文件夹中：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry config virtualenvs.in-project true</span><br></pre></td></tr></table></figure></div>

<h4 id="初始化新项目"><a href="#初始化新项目" class="headerlink" title="初始化新项目"></a>初始化新项目</h4><p>要初始化新项目，在终端中运行以下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry init</span><br></pre></td></tr></table></figure></div>

<p>Poetry会询问一些关于项目的问题。可以通过按Enter键留下默认值，或者输入自己的值。</p>
<p>示例：</p>
<p>此命令将引导创建 <code>pyproject.toml</code>配置。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Package name [your-project-name]:</span><br><span class="line">Version [0.1.0]:</span><br><span class="line">Description []:</span><br><span class="line">Author [Your Name &lt;your.email@example.com&gt;, n to skip]:</span><br><span class="line">License []:</span><br><span class="line">Compatible Python versions [^3.10]:</span><br><span class="line"></span><br><span class="line">Would you like to define your main dependencies interactively? (yes/no) [yes] no</span><br><span class="line">Would you like to define your development dependencies interactively? (yes/no) [yes] no</span><br></pre></td></tr></table></figure></div>

<p>初始化后，会在项目文件夹中看到一个名为 <code>pyproject.toml</code>的新文件。此文件包含有关项目和依赖项的所有信息。</p>
<h4 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h4><p>要添加依赖项，在终端中运行以下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add robotframework</span><br></pre></td></tr></table></figure></div>

<p>也可以一次添加多个依赖项：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add robotframework robotframework-browser robotframework-requests</span><br></pre></td></tr></table></figure></div>

<p>在首次运行时，poetry将为项目创建一个虚拟环境并安装依赖项。</p>
<h4 id="在虚拟环境中运行命令"><a href="#在虚拟环境中运行命令" class="headerlink" title="在虚拟环境中运行命令"></a>在虚拟环境中运行命令</h4><p>要在虚拟环境中运行命令，可以使用 <code>poetry run</code>命令。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run robot --version</span><br></pre></td></tr></table></figure></div>

<p>例如，要安装 <code>robotframework-browser</code>的playwright依赖项，可以运行以下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run rfbrowser init</span><br></pre></td></tr></table></figure></div>

<p>还可以使用 <code>poetry shell</code>命令在虚拟环境中打开一个shell。 在此shell中运行的所有命令都将在虚拟环境中执行。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poetry shell</span><br><span class="line">(.venv) robot --version</span><br></pre></td></tr></table></figure></div>

<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>有几个演示项目介绍了Robot Framework并帮助开始使用它：</p>
<ul>
<li>快速入门指南：介绍Robot Framework最重要的特性，并作为可执行演示。<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst" >https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li>Robot Framework演示：简单的示例测试用例。还演示了如何创建自定义测试库。<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://github.com/robotframework/RobotDemo" >https://github.com/robotframework/RobotDemo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li>网页测试演示：演示如何创建测试和更高级别的关键字。测试的系统是一个简单的网页，使用SeleniumLibrary进行测试。<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://github.com/robotframework/WebDemo" >https://github.com/robotframework/WebDemo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li>使用Robot Framework进行ATDD：演示如何在遵循接受测试驱动开发（ATDD）过程时使用Robot Framework。<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://code.google.com/p/atdd-with-robot-framework" >https://code.google.com/p/atdd-with-robot-framework <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h2 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h2><h3 id="测试数据语法"><a href="#测试数据语法" class="headerlink" title="测试数据语法"></a>测试数据语法</h3><p>此部分涵盖Robot Framework的整体测试数据语法。以下各节将解释如何实际创建测试用例、测试套件等。尽管本节主要使用测试一词，但创建任务时也适用相同规则。</p>
<h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h4><p>安排测试用例的层次结构建立如下：</p>
<ul>
<li>测试用例在套件文件中创建。</li>
<li>测试用例文件自动创建一个包含该文件中测试用例的测试套件。</li>
<li>包含测试用例文件的目录形成一个更高级别的测试套件。这样的套件目录拥有从测试用例文件创建的子测试套件。</li>
<li>测试套件目录也可以包含其他测试套件目录，这种层次结构可以根据需要深入嵌套。</li>
<li>测试套件目录可以有一个特殊的初始化文件，用于配置创建的测试套件。</li>
</ul>
<p>此外，还包括：</p>
<ul>
<li>包含最低级关键字的测试库。</li>
<li>带有变量和更高级用户关键字的资源文件。</li>
<li>提供比资源文件更灵活的创建变量方式的变量文件。</li>
</ul>
<p>测试用例文件、测试套件初始化文件和资源文件都使用Robot Framework测试数据语法创建。测试库和变量文件使用“真实”编程语言创建，通常是Python。</p>
<h4 id="测试数据部分"><a href="#测试数据部分" class="headerlink" title="测试数据部分"></a>测试数据部分</h4><p>Robot Framework数据在不同部分定义，这些部分通常也称为表格，如下所列：</p>
<table>
<thead>
<tr>
<th align="left">部分</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Settings</td>
<td align="left">1) 导入测试库、资源文件和变量文件。<br />2) 定义测试套件和测试用例的元数据。</td>
</tr>
<tr>
<td align="left">Variables</td>
<td align="left">定义可以在测试数据中其他地方使用的变量。</td>
</tr>
<tr>
<td align="left">Test Cases</td>
<td align="left">从可用关键字创建测试用例。</td>
</tr>
<tr>
<td align="left">Tasks</td>
<td align="left">使用可用关键字创建任务。单个文件只能包含测试或任务。</td>
</tr>
<tr>
<td align="left">Keywords</td>
<td align="left">从现有的低级关键字创建用户关键字。</td>
</tr>
<tr>
<td align="left">Comments</td>
<td align="left">额外的评论或数据。被Robot Framework忽略。</td>
</tr>
</tbody></table>
<p>不同部分通过其标题行被识别。推荐的标题格式是 <code>*** Settings***</code>，但标题不区分大小写，周围的空格是可选的，星号字符的数量可以变化，只要开头至少有一个星号。例如，<code>*Settings</code>也会被识别为部分标题。</p>
<p>Robot Framework也支持单数标题，如 <code>*** Setting***</code>，但该支持在Robot Framework 6.0中已被弃用。从Robot Framework 7.0开始会有可见的弃用警告，最终单数标题将完全不被支持。</p>
<p>标题行也可以包含实际部分标题以外的其他数据。额外的数据必须使用数据格式依赖的分隔符与部分标题分开，通常是两个或更多空格。这些额外的标题在解析时会被忽略，但它们可以用于文档记录目的。在使用数据驱动风格创建测试用例时，这特别有用。</p>
<p>第一部分之前的可能数据被忽略。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>部分标题可以本地化。有关支持的翻译，请参阅翻译。</p>

    </div>
  </div>


<h4 id="支持的文件格式"><a href="#支持的文件格式" class="headerlink" title="支持的文件格式"></a>支持的文件格式</h4><p>创建Robot Framework数据的最常见方法是使用空格分隔的格式，其中数据的各个部分，例如关键字及其参数，用两个或更多空格分隔。</p>
<p>另一种方法是使用管道分隔的格式，其中分隔符是用空格括起来的管道字符 <code>|</code>。</p>
<p>套件文件通常使用 <code>.robot</code>扩展名，但可以配置解析哪些文件。资源文件也可以使用 <code>.robot</code>扩展名，但建议使用专用的 <code>.resource</code>扩展名，并且在将来可能会被强制执行。</p>
<p>包含非ASCII字符的文件必须使用UTF-8编码保存。</p>
<p>Robot Framework还支持reStructuredText文件，以便将普通的Robot Framework数据嵌入到代码块中。默认情况下，仅解析具有 <code>.robot.rst</code>扩展名的文件。如果更喜欢使用 <code>.rst</code>或 <code>.rest</code>扩展名，那么需要单独配置。</p>
<p>Robot Framework数据还可以以JSON格式创建，该格式更针对工具开发人员而不是普通的Robot Framework用户。默认情况下，仅解析具有自定义 <code>.rbt</code>扩展名的JSON文件。</p>
<p>较早的Robot Framework版本还支持HTML和TSV格式的数据。如果数据与空格分隔格式兼容，则TSV格式仍然有效，但完全删除了对HTML格式的支持。如果遇到此类数据文件，需要将其转换为纯文本格式，以便在Robot Framework 3.2或更新版本中使用。最简单的方法是使用Tidy工具，但必须使用Robot Framework 3.1附带的版本，因为更新版本根本不理解HTML格式。</p>
<h4 id="空格分隔格式"><a href="#空格分隔格式" class="headerlink" title="空格分隔格式"></a>空格分隔格式</h4><p>当Robot Framework解析数据时，它首先将数据拆分为行，然后将行拆分为诸如关键字和参数之类的标记。在使用空格分隔格式时，标记之间的分隔符是两个或更多空格，或者是一个或多个制表符。除了正常的ASCII空格之外，任何被视为空格的Unicode字符（例如不间断空格）都可以作为分隔符。分隔标记所使用的空格数量可以变化，只要至少有两个，这样在设置和其他地方对齐数据时就可以使数据更易于理解。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation     使用空格分隔格式的示例。</span><br><span class="line">Library           OperatingSystem</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;MESSAGE&#125;        Hello, world!</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">My Test</span><br><span class="line">    [Documentation]    Example test.</span><br><span class="line">    Log    $&#123;MESSAGE&#125;</span><br><span class="line">    My Keyword    $&#123;CURDIR&#125;</span><br><span class="line"></span><br><span class="line">Another Test</span><br><span class="line">    Should Be Equal    $&#123;MESSAGE&#125;    Hello, world!</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">My Keyword</span><br><span class="line">    [Arguments]    $&#123;path&#125;</span><br><span class="line">    Directory Should Exist    $&#123;path&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个示例中：</p>
<ul>
<li><code>*** Settings ***</code>：定义了测试或任务的设置。</li>
<li><code>Documentation</code>：提供了对测试或任务的描述。</li>
<li><code>Library</code>：指定了测试或任务中将使用的库。</li>
<li><code>*** Variables ***</code>：声明了在测试中使用的变量。</li>
<li><code>$&#123;MESSAGE&#125;</code>：变量的名称，其值为“好，世界！”。</li>
<li><code>*** Test Cases ***</code>：标记了测试用例的开始。</li>
<li><code>的测试</code>和 <code>另一个测试</code>：测试用例的名称。</li>
<li><code>[Documentation]</code>：为测试用例提供了额外的描述。</li>
<li><code>Log</code>：一个关键字，用于记录信息。</li>
<li><code>My Keyword</code>：自定义关键字的名称。</li>
<li><code>Should Be Equal</code>：一个内置关键字，用于断言两个值是否相等。</li>
<li><code>*** Keywords ***</code>：标记了自定义关键字的开始。</li>
<li><code>[Arguments]</code>：定义了关键字的参数。</li>
<li><code>Directory Should Exist</code>：一个内置关键字，用于验证指定路径的目录是否存在。</li>
</ul>
<p>因为制表符和连续的空格被视为分隔符，所以如果在关键字参数或实际数据的其他位置需要它们，则必须对它们进行转义。可以使用特殊的转义语法，如 <code>\t</code>表示制表符，<code>\xA0</code>表示不间断空格，以及内置变量 <code>$&#123;SPACE&#125;</code>和 <code>$&#123;EMPTY&#125;</code>。详情请参阅转义部分。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/566a2630-666b-4bec-05a3-8eba7d2b8100/public"
                      width = "600"
                >


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>虽然使用两个空格作为分隔符就足够了，但建议使用四个空格，以便更容易识别分隔符。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 3.2之前，数据中使用的非ASCII空格在解析过程中会被转换为ASCII空格。现在所有数据都保持原样。</p>

    </div>
  </div>

<h4 id="管道分隔格式"><a href="#管道分隔格式" class="headerlink" title="管道分隔格式"></a>管道分隔格式</h4><p>空格分隔格式的最大问题是在视觉上将关键字与参数分开可能会很棘手。这个问题特别突出，特别是如果关键字需要很多参数和&#x2F;或参数包含空格的情况下。在这种情况下，管道分隔的变体可能会更好，因为它使分隔符更加明显可见。</p>
<p>一个文件可以同时包含空格分隔和管道分隔的行。管道分隔的行通过强制性的前导管道字符进行识别，但行尾的管道是可选的。除了在行的开头和结尾，管道的两侧始终必须至少有一个空格或制表符。不需要对齐管道，但通常这样做会使数据更易于阅读。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">| *** Settings ***   |</span><br><span class="line">| Documentation      | Example using the pipe separated format.</span><br><span class="line">| Library            | OperatingSystem</span><br><span class="line"></span><br><span class="line">| *** Variables ***  |</span><br><span class="line">| $&#123;MESSAGE&#125;         | Hello, world!</span><br><span class="line"></span><br><span class="line">| *** Test Cases *** |                 |               |</span><br><span class="line">| My Test            | [Documentation] | Example test. |</span><br><span class="line">|                    | Log             | $&#123;MESSAGE&#125;    |</span><br><span class="line">|                    | My Keyword      | $&#123;CURDIR&#125;     |</span><br><span class="line">| Another Test       | Should Be Equal | $&#123;MESSAGE&#125;    | Hello, world!</span><br><span class="line"></span><br><span class="line">| *** Keywords ***   |                        |         |</span><br><span class="line">| My Keyword         | [Arguments]            | $&#123;path&#125; |</span><br><span class="line">|                    | Directory Should Exist | $&#123;path&#125; |</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/13ab6da9-18d2-4f79-09c7-b6696b2b1600/public"
                      width = "600"
                >

<p>在使用管道分隔格式时，参数内部的连续空格或制表符不需要转义。同样，空列不需要转义，除非它们位于末尾。然而，在实际测试数据中可能被空格包围的管道必须使用反斜杠进行转义：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| *** Test Cases *** |                 |                 |                      |</span><br><span class="line">| Escaping Pipe      | $&#123;file count&#125; = | Execute Command | ls -1 *.txt \| wc -l |</span><br><span class="line">|                    | Should Be Equal | $&#123;file count&#125;   | 42                   |</span><br></pre></td></tr></table></figure></div>

<ol>
<li><code>Execute Command</code> 关键字执行了 <code>ls -1 *.txt | wc -l</code> 命令。</li>
<li><code>ls -1 *.txt</code> 列出了当前目录中所有以 <code>.txt</code> 结尾的文件。</li>
<li><code>wc -l</code> 统计了文件的行数。</li>
</ol>
<p>最终，验证了文件的行数是否等于 42。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>保留参数中的连续空格和制表符是Robot Framework 3.2的新功能。在此之前，数据中使用的非ASCII空格也会被转换为ASCII空格。</p>

    </div>
  </div>

<h4 id="reStructuredText-格式"><a href="#reStructuredText-格式" class="headerlink" title="reStructuredText 格式"></a>reStructuredText 格式</h4><p>reStructuredText（reST）是一种易于阅读的纯文本标记语法，通常用于Python项目的文档，包括Python本身以及本用户指南。reST文档最常编译为HTML，但也支持其他输出格式。使用reST与Robot Framework结合使用，允许在简洁的文本格式中混合富格式文档和测试数据，这样就可以使用简单的文本编辑器、差异工具和源代码控制系统轻松地处理。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>使用reStructuredText文件与Robot Framework需要安装Python docutils模块。</p>
<p>当使用Robot Framework与reStructuredText文件时，普通的Robot Framework数据被嵌入到所谓的代码块中。在标准reST中，代码块使用代码指令进行标记，但Robot Framework还支持Sphinx工具使用的code-block或sourcecode指令。</p>

    </div>
  </div>

<h5 id="reStructuredText-示例"><a href="#reStructuredText-示例" class="headerlink" title="reStructuredText 示例"></a>reStructuredText 示例</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">reStructuredText example</span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">This text is outside code blocks and thus ignored.</span><br><span class="line"></span><br><span class="line">.. code:: robotframework</span><br><span class="line"></span><br><span class="line">   *** Settings ***</span><br><span class="line">   Documentation    Example using the reStructuredText format.</span><br><span class="line">   Library          OperatingSystem</span><br><span class="line"></span><br><span class="line">   *** Variables ***</span><br><span class="line">   $&#123;MESSAGE&#125;       Hello, world!</span><br><span class="line"></span><br><span class="line">   *** Test Cases ***</span><br><span class="line">   My Test</span><br><span class="line">       [Documentation]    Example test.</span><br><span class="line">       Log    $&#123;MESSAGE&#125;</span><br><span class="line">       My Keyword    $&#123;CURDIR&#125;</span><br><span class="line"></span><br><span class="line">   Another Test</span><br><span class="line">       Should Be Equal    $&#123;MESSAGE&#125;    Hello, world!</span><br><span class="line"></span><br><span class="line">Also this text is outside code blocks and ignored. Code blocks not</span><br><span class="line">containing Robot Framework data are ignored as well.</span><br><span class="line"></span><br><span class="line">.. code:: robotframework</span><br><span class="line"></span><br><span class="line">   # Both space and pipe separated formats are supported.</span><br><span class="line"></span><br><span class="line">   | *** Keywords ***  |                        |         |</span><br><span class="line">   | My Keyword        | [Arguments]            | $&#123;path&#125; |</span><br><span class="line">   |                   | Directory Should Exist | $&#123;path&#125; |</span><br><span class="line"></span><br><span class="line">.. code:: python</span><br><span class="line"></span><br><span class="line">   # This code block is ignored.</span><br><span class="line">   def example():</span><br><span class="line">       print(&#x27;Hello, world!&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>Robot Framework支持使用 <code>.robot.rst</code>、<code>.rst</code>和 <code>.rest</code>扩展名的reStructuredText文件。为了避免解析不相关的reStructuredText文件，当执行目录时，默认情况下仅解析具有 <code>.robot.rst</code>扩展名的文件。可以通过使用 <code>--parseinclude</code>或 <code>--extension</code>选项来启用解析具有其他扩展名的文件。</p>
<p>当Robot Framework解析reStructuredText文件时，忽略严重级别以下的错误，以避免可能的非标准指令和其他标记的噪音。这也可能隐藏了真正的错误，但在通常使用reStructuredText工具处理文件时可以看到它们。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>自动解析 <code>.robot.rst</code>文件是Robot Framework 6.1的新功能。</p>

    </div>
  </div>

<h4 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h4><p>Robot Framework 支持 JSON 格式的数据。这种格式主要为工具开发者设计，而不是为常规的 Robot Framework 用户设计，因此不建议手动编辑。它的主要用途包括：</p>
<ul>
<li>在进程和机器之间传输数据。可以在一台机器上将套件转换为 JSON，然后在其他地方重新创建。</li>
<li>将可能是嵌套套件的套件，从常规的 Robot Framework 数据构建成单个的 JSON 文件，这样解析起来更快。</li>
<li>为生成测试或任务的外部工具提供替代的数据格式。</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>JSON 数据支持是在 Robot Framework 6.1 中新增的，未来的 Robot Framework 版本中可能会进行增强。</p>

    </div>
  </div>

<h5 id="将套件转换为-JSON"><a href="#将套件转换为-JSON" class="headerlink" title="将套件转换为 JSON"></a>将套件转换为 JSON</h5><p>可以使用 <code>TestSuite.to_json</code> 方法将套件结构序列化为 JSON。如果没有参数，它会返回 JSON 数据作为字符串，但它也接受一个路径或一个打开的文件，以及与 JSON 格式相关的配置选项：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> TestSuite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于文件系统上的数据创建套件。</span></span><br><span class="line">suite = TestSuite.from_file_system(<span class="string">&#x27;/path/to/data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 JSON 数据作为字符串。</span></span><br><span class="line">data = suite.to_json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 JSON 数据保存到文件中，自定义缩进。</span></span><br><span class="line">suite.to_json(<span class="string">&#x27;data.rbt&#x27;</span>, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果更愿意使用 Python 数据，然后自己将其转换为 JSON 或其他格式，可以使用 <code>TestSuite.to_dict</code>。</p>
<h5 id="从-JSON-创建套件"><a href="#从-JSON-创建套件" class="headerlink" title="从 JSON 创建套件"></a>从 JSON 创建套件</h5><p>可以使用 <code>TestSuite.from_json</code> 方法从 JSON 数据构建套件。它既可以处理 JSON 字符串，也可以处理 JSON 文件的路径：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> TestSuite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中的 JSON 数据创建套件。</span></span><br><span class="line">suite = TestSuite.from_json(<span class="string">&#x27;data.rbt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 JSON 字符串创建套件。</span></span><br><span class="line">suite = TestSuite.from_json(<span class="string">&#x27;&#123;&quot;name&quot;: &quot;Suite&quot;, &quot;tests&quot;: [&#123;&quot;name&quot;: &quot;Test&quot;&#125;]&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行套件。注意，日志和报告需要单独创建。</span></span><br><span class="line">suite.run(output=<span class="string">&#x27;example.xml&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果有一个 Python 字典的数据，可以使用 <code>TestSuite.from_dict</code>。无论套件是如何重新创建的，它只存在于内存中，原始的数据文件在文件系统上不会被重新创建。</p>
<p>如上例所示，可以使用 <code>TestSuite.run</code> 方法执行创建的套件。然而，直接执行 JSON 文件可能更容易，如下一节所述。</p>
<h5 id="执行-JSON-文件"><a href="#执行-JSON-文件" class="headerlink" title="执行 JSON 文件"></a>执行 JSON 文件</h5><p>当使用 <code>robot</code> 命令执行测试或任务时，带有自定义 <code>.rbt</code> 扩展名的 JSON 文件会被自动解析。这包括运行像 <code>robot tests.rbt</code> 这样的单个 JSON 文件，以及运行包含 <code>.rbt</code> 文件的目录。如果更愿意使用标准的 <code>.json</code> 扩展名，需要配置哪些文件需要解析。</p>
<h5 id="调整套件源"><a href="#调整套件源" class="headerlink" title="调整套件源"></a>调整套件源</h5><p>从 <code>TestSuite.to_json</code> 和 <code>TestSuite.to_dict</code> 获取的数据中的套件源是绝对格式的。如果稍后在不同的机器上重新创建套件，源可能不匹配该机器上的目录结构。为了避免这种情况，可以使用 <code>TestSuite.adjust_source</code> 方法在获取数据之前使套件源相对化，并在套件重新创建后添加正确的根目录：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> TestSuite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建套件，调整源并转换为 JSON。</span></span><br><span class="line">suite = TestSuite.from_file_system(<span class="string">&#x27;/path/to/data&#x27;</span>)</span><br><span class="line">suite.adjust_source(relative_to=<span class="string">&#x27;/path/to&#x27;</span>)</span><br><span class="line">suite.to_json(<span class="string">&#x27;data.rbt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在其他地方重新创建套件并相应地调整源。</span></span><br><span class="line">suite = TestSuite.from_json(<span class="string">&#x27;data.rbt&#x27;</span>)</span><br><span class="line">suite.adjust_source(root=<span class="string">&#x27;/new/path/to&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h5 id="JSON-结构"><a href="#JSON-结构" class="headerlink" title="JSON 结构"></a>JSON 结构</h5><p>在套件文件中创建的导入项、变量和关键字都包含在生成的 JSON 中，以及测试和任务。具体的 JSON 结构在 <code>running.json</code> 架构文件中有文档说明。</p>
<h4 id="数据解析规则"><a href="#数据解析规则" class="headerlink" title="数据解析规则"></a>数据解析规则</h4><h5 id="忽略的数据"><a href="#忽略的数据" class="headerlink" title="忽略的数据"></a>忽略的数据</h5><p>当 Robot Framework 解析测试数据文件时，它会忽略：</p>
<ul>
<li>第一个测试数据部分之前的所有数据。</li>
<li>评论部分中的数据。</li>
<li>所有空行。</li>
<li>当使用管道分隔格式时，行尾的所有空单元格。</li>
<li>当不用于转义时，所有的单个反斜杠（\）。</li>
<li>当它是单元格的第一个字符时，井号（#）后面的所有字符。这意味着可以使用井号在测试数据中输入注释。</li>
</ul>
<p>当 Robot Framework 忽略一些数据时，这些数据在任何生成的报告中都不可用，此外，大多数与 Robot Framework 一起使用的工具也会忽略它们。要添加在 Robot Framework 输出中可见的信息，请将其放在测试用例或套件的文档或其他元数据中，或使用 BuiltIn 关键字 Log 或 Comment 进行记录。</p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>Robot Framework 测试数据中的转义字符是反斜杠 <code>\</code>，此外，内置变量 EMPTY和{SPACE} 通常也可以用于转义。下面的各节将讨论不同的转义机制。</p>
<h5 id="转义特殊字符"><a href="#转义特殊字符" class="headerlink" title="转义特殊字符"></a>转义特殊字符</h5><p>反斜杠字符可以用来转义特殊字符，以便使用它们的字面值:</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">含义</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$</td>
<td align="left">美元符号，不会开始标量变量。</td>
<td align="left">${notvar}</td>
</tr>
<tr>
<td align="left">@</td>
<td align="left">电子邮件符号，不会开始列表变量。</td>
<td align="left">@{notvar}</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">和号，不会开始字典变量。</td>
<td align="left">&amp;{notvar}</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">百分号，不会开始环境变量。</td>
<td align="left">%{notvar}</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">井号，不会开始注释。</td>
<td align="left"># not comment</td>
</tr>
<tr>
<td align="left">=</td>
<td align="left">等号，不会成为命名参数语法的一部分。</td>
<td align="left">not=named</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">管道字符，不是管道分隔格式的分隔符。</td>
<td align="left">ls -1 *.txt| wc -l</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">反斜杠字符，不会转义任何东西。</td>
<td align="left">c:\temp, \${var}</td>
</tr>
</tbody></table>
<h5 id="形成转义序列"><a href="#形成转义序列" class="headerlink" title="形成转义序列"></a>形成转义序列</h5><p>反斜杠字符也允许创建特殊的转义序列，这些序列被识别为在测试数据中难以或无法创建的字符:</p>
<p>转义序列：</p>
<table>
<thead>
<tr>
<th align="left">序列</th>
<th align="left">含义</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行符</td>
<td align="left">first line\n2nd line</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车符</td>
<td align="left">text\rmore text</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符</td>
<td align="left">text\tmore text</td>
</tr>
<tr>
<td align="left">\xhh</td>
<td align="left">十六进制值为 hh 的字符</td>
<td align="left">空字节：\x00，ä：\xE4</td>
</tr>
<tr>
<td align="left">\uhhhh</td>
<td align="left">十六进制值为 hhhh 的字符</td>
<td align="left">雪人：\u2603</td>
</tr>
<tr>
<td align="left">\Uhhhhhhhh</td>
<td align="left">十六进制值为 hhhhhhhh 的字符</td>
<td align="left">爱情旅馆：\U0001f3e9</td>
</tr>
</tbody></table>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在测试数据中创建的所有字符串，包括像 <code>\x02</code> 这样的字符，都是 Unicode，如果需要，必须显式地转换为字节字符串。这可以通过使用 BuiltIn 和 String 库中的 <code>Convert To Bytes</code> 或 <code>Encode String To Bytes</code> 关键字来完成，或者在 Python 代码中使用类似于 <code>value.encode(&#39;UTF-8&#39;)</code> 的语句来完成。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果在 <code>\x</code>、<code>\u</code> 或 <code>\U</code> 转义中使用了无效的十六进制值，最终的结果是原始值，但没有反斜杠字符。例如，<code>\xAX</code>（不是十六进制）和 <code>\U00110000</code>（值过大）分别会得到 <code>xAX</code> 和 <code>U00110000</code>。尽管如此，这种行为在未来可能会改变。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果需要操作系统依赖的行终止符，可以使用内置变量 <code>${\n}</code>（在 Windows 上是 <code>\r\n</code>，在其他地方是 <code>\n</code>）。</p>

    </div>
  </div>

<h4 id="处理空值"><a href="#处理空值" class="headerlink" title="处理空值"></a>处理空值</h4><p>当使用空格分隔格式时，用作分隔符的空格数量可以变化，因此除非进行转义，否则无法识别空值。空单元格可以用反斜杠字符或内置变量 <code>$&#123;EMPTY&#125;</code> 进行转义。通常推荐使用后者，因为它更容易理解。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Using backslash</span><br><span class="line">    Do Something    first arg    \</span><br><span class="line">    Do Something    \            second arg</span><br><span class="line"></span><br><span class="line">Using $&#123;EMPTY&#125;</span><br><span class="line">    Do Something    first arg    $&#123;EMPTY&#125;</span><br><span class="line">    Do Something    $&#123;EMPTY&#125;     second arg</span><br></pre></td></tr></table></figure></div>

<p>当使用管道分隔格式时，只有当空值位于行尾时，才需要对空值进行转义：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| *** Test Cases *** |              |           |            |</span><br><span class="line">| Using backslash    | Do Something | first arg | \          |</span><br><span class="line">|                    | Do Something |           | second arg |</span><br><span class="line">|                    |              |           |            |</span><br><span class="line">| Using $&#123;EMPTY&#125;     | Do Something | first arg | $&#123;EMPTY&#125;   |</span><br><span class="line">|                    | Do Something |           | second arg |</span><br></pre></td></tr></table></figure></div>

<h4 id="处理空格"><a href="#处理空格" class="headerlink" title="处理空格"></a>处理空格</h4><p>空格，尤其是连续的空格，作为关键字的参数或者其他需要的一部分，会有两个问题：</p>
<ul>
<li>当使用空格分隔格式时，两个或更多连续的空格被视为分隔符。</li>
<li>当使用管道分隔格式时，忽略前导和尾随空格。</li>
</ul>
<p>在这些情况下，需要对空格进行转义。与转义空值类似，可以通过使用反斜杠字符或使用内置变量 <code>$&#123;SPACE&#125;</code> 来实现。</p>
<p>转义空格示例：</p>
<table>
<thead>
<tr>
<th>使用反斜杠转义</th>
<th>使用 <code>$&#123;SPACE&#125;</code> 转义</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>\ leading space</td>
<td><code>$&#123;SPACE&#125;</code>leading space</td>
<td></td>
</tr>
<tr>
<td>trailing space \</td>
<td>trailing space <code>$&#123;SPACE&#125;</code></td>
<td>反斜杠必须在空格后面。</td>
</tr>
<tr>
<td>\ \</td>
<td><code>$&#123;SPACE&#125;</code></td>
<td>两边都需要反斜杠。</td>
</tr>
<tr>
<td>consecutive \ \ spaces</td>
<td>consecutive <code>$&#123;SPACE * 3&#125;</code>spaces</td>
<td>使用扩展变量语法。</td>
</tr>
</tbody></table>
<p>如上例所示，使用 <code>$&#123;SPACE&#125;</code> 变量通常使测试数据更容易理解。当需要多个空格时，它与扩展变量语法结合使用特别方便。</p>
<h4 id="将数据分割到多行"><a href="#将数据分割到多行" class="headerlink" title="将数据分割到多行"></a>将数据分割到多行</h4><p>如果一行的数据过多，可以将其分割，并使用省略号（…）开始连续的行。省略号可以缩进以匹配起始行的缩进，并且必须始终跟随正常的测试数据分隔符。</p>
<p>在大多数地方，分割的行与未分割的行具有完全相同的语义。此规则的例外是套件、测试和关键字文档以及套件元数据。对于它们，分割的值会自动用换行符连接在一起，以便创建多行值。</p>
<p><code>...</code> 语法也允许在变量部分分割变量。当长标量变量（例如 <code>$&#123;STRING&#125;</code>）被分割到多行时，最终的值是通过将行连接在一起得到的。默认的分隔符是空格，但可以通过以 <code>SEPARATOR=&lt;sep&gt;</code> 开始值来更改。</p>
<p>以下两个示例说明了分割行，它们包含了完全相同的数据，但一个没有分割，一个进行了分割:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation      Here we have documentation for this suite.\nDocumentation is often quite long.\n\nIt can also contain multiple paragraphs.</span><br><span class="line">Default Tags       default tag 1    default tag 2    default tag 3    default tag 4    default tag 5</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;STRING&#125;          This is a long string. It has multiple sentences. It does not have newlines.</span><br><span class="line">$&#123;MULTILINE&#125;       This is a long multiline string.\nThis is the second line.\nThis is the third and the last line.</span><br><span class="line">@&#123;LIST&#125;            this     list     is    quite    long     and    items in it can also be long</span><br><span class="line">&amp;&#123;DICT&#125;            first=This value is pretty long.    second=This value is even longer. It has two sentences.</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]    you    probably    do    not    have    this    many    tags    in    real    life</span><br><span class="line">    Do X    first argument    second argument    third argument    fourth argument    fifth argument    sixth argument</span><br><span class="line">    $&#123;var&#125; =    Get X    first argument passed to this keyword is pretty long    second argument passed to this keyword is long too</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation      Here we have documentation for this suite.</span><br><span class="line">...                Documentation is often quite long.</span><br><span class="line">...</span><br><span class="line">...                It can also contain multiple paragraphs.</span><br><span class="line">Default Tags       default tag 1    default tag 2    default tag 3</span><br><span class="line">...                default tag 4    default tag 5</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;STRING&#125;          This is a long string.</span><br><span class="line">...                It has multiple sentences.</span><br><span class="line">...                It does not have newlines.</span><br><span class="line">$&#123;MULTILINE&#125;       SEPARATOR=\n</span><br><span class="line">...                This is a long multiline string.</span><br><span class="line">...                This is the second line.</span><br><span class="line">...                This is the third and the last line.</span><br><span class="line">@&#123;LIST&#125;            this     list     is      quite    long     and</span><br><span class="line">...                items in it can also be long</span><br><span class="line">&amp;&#123;DICT&#125;            first=This value is pretty long.</span><br><span class="line">...                second=This value is even longer. It has two sentences.</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]    you    probably    do    not    have    this    many</span><br><span class="line">    ...       tags    in    real    life</span><br><span class="line">    Do X    first argument    second argument    third argument</span><br><span class="line">    ...    fourth argument    fifth argument    sixth argument</span><br><span class="line">    $&#123;var&#125; =    Get X</span><br><span class="line">    ...    first argument passed to this keyword is pretty long</span><br><span class="line">    ...    second argument passed to this keyword is long too</span><br></pre></td></tr></table></figure></div>

<h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>Robot Framework 的本地化工作始于 Robot Framework 6.0，它允许翻译部分标题、设置、在行为驱动开发（BDD）中使用的 Given&#x2F;When&#x2F;Then 前缀，以及在自动布尔参数转换中使用的 true 和 false 字符串。未来计划扩展本地化支持，例如，到日志和报告，甚至可能也包括控制结构。</p>
<p>本节解释如何激活语言，支持哪些内置语言，如何创建自定义语言文件，以及如何贡献新的翻译。</p>
<h5 id="启用语言"><a href="#启用语言" class="headerlink" title="启用语言"></a>启用语言</h5><p>使用命令行选项 激活语言的主要机制是使用 <code>--language</code> 选项从命令行指定它们。当启用内置语言时，可以使用语言名称（如 Chinese Simplified）或语言代码（如 fi）。名称和代码都不区分大小写和空格，也忽略连字符（-）。要启用多种语言，需要多次使用 <code>--language</code> 选项：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --language Chinese Simplified testit.robot</span><br><span class="line">robot --language pt --language ptbr testes.robot</span><br></pre></td></tr></table></figure></div>

<p>当激活自定义语言文件时，也使用相同的 <code>--language</code> 选项。对于它们，值可以是文件的路径，或者，如果文件在模块搜索路径中，可以是模块名称：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --language Custom.py tests.robot</span><br><span class="line">robot --language MyLang tests.robot</span><br></pre></td></tr></table></figure></div>

<p>出于向后兼容性的原因，以及为了支持部分翻译，英语总是自动激活的。未来的版本可能允许禁用它。</p>
<p>预文件配置 也可以直接在数据文件中启用语言，方法是在任何部分标题之前有一行 <code>Language: &lt;value&gt;</code>（不区分大小写）。冒号后的值与 <code>--language</code> 选项的解释方式相同：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Language: Chinese Simplified</span><br><span class="line"></span><br><span class="line">*** Asetukset ***</span><br><span class="line">Dokumentaatio        Example using Chinese Simplified.</span><br></pre></td></tr></table></figure></div>

<p>如果需要启用多种语言，可以重复 <code>Language:</code> 行。这些配置行不能在注释中，所以像 <code># Language: Chinese Simplified</code> 这样的内容没有效果。</p>
<p>由于技术限制，每个文件的语言配置也会影响后续文件的解析以及整个执行。这种行为可能在未来会改变，因此不应依赖它。如果使用每个文件的配置，应该在所有文件中使用它，或者使用 <code>--language</code> 选项全局启用语言。</p>
<h5 id="自定义语言文件"><a href="#自定义语言文件" class="headerlink" title="自定义语言文件"></a>自定义语言文件</h5><p>如果需要的语言不是内置语言，或者想为某些特定需求创建一个完全自定义的语言，可以轻松地创建一个自定义语言文件。语言文件是 Python 文件，包含一个或多个语言定义，当语言文件被使用时，所有的语言定义都会被加载。语言定义是通过扩展 <code>robot.api.Language</code> 基类并根据需要覆盖类属性来创建的：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> Language</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>(<span class="title class_ inherited__">Language</span>):</span><br><span class="line">    test_cases_header = <span class="string">&#x27;Validations&#x27;</span></span><br><span class="line">    tags_setting = <span class="string">&#x27;Labels&#x27;</span></span><br><span class="line">    given_prefixes = [<span class="string">&#x27;Assuming&#x27;</span>]</span><br><span class="line">    true_strings = [<span class="string">&#x27;OK&#x27;</span>, <span class="string">&#x27;\N&#123;THUMBS UP SIGN&#125;&#x27;</span>]</span><br></pre></td></tr></table></figure></div>

<p>假设上述代码位于 <code>example.py</code> 文件中，当激活语言文件时，可以使用该文件的路径或仅使用模块名称 <code>example</code>。</p>
<p>上述示例只添加了一些可能的翻译。这是可以的，因为英语总是会自动启用。大多数值必须指定为字符串，但 BDD 前缀和 true&#x2F;false 字符串允许多个值，并且必须给出列表。有关更多示例，请参见 Robot Framework 的内部语言模块，该模块包含 <code>Language</code> 类以及所有内置语言定义。</p>
<h3 id="创建测试用例"><a href="#创建测试用例" class="headerlink" title="创建测试用例"></a>创建测试用例</h3><p>当创建测试用例时，通常会采用以下的测试用例语法。将测试用例组织成测试套件，可以使用套件文件和套件目录，具体内容请参阅下一节。</p>
<p>当在使用机器人框架进行除了测试自动化以外的其他自动化任务时，建议创建任务而不是测试。任务的语法在大部分情况下与测试的语法相同，不同之处将在创建任务部分进行解释。</p>
<h4 id="测试用例语法"><a href="#测试用例语法" class="headerlink" title="测试用例语法"></a>测试用例语法</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>测试用例是在测试用例部分中从可用关键字构建的。关键字可以从测试库或资源文件导入，或者在测试用例文件本身的关键字部分中创建。</p>
<p>测试用例部分的第一列包含测试用例名称。测试用例从此列中有内容的行开始，并继续到下一个测试用例名称或部分的结束。在部分标题和第一个测试之间有内容是错误的。</p>
<p>第二列通常有关键字名称。此规则的一个例外是从关键字返回值设置变量，当第二列和可能的后续列包含变量名称，并且关键字名称位于它们之后。在任一情况下，关键字名称后的列包含指定关键字的可能参数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Valid Login</span><br><span class="line">    Open Login Page</span><br><span class="line">    Input Username    demo</span><br><span class="line">    Input Password    mode</span><br><span class="line">    Submit Credentials</span><br><span class="line">    Welcome Page Should Be Open</span><br><span class="line"></span><br><span class="line">Setting Variables</span><br><span class="line">    Do Something    first argument    second argument</span><br><span class="line">    $&#123;value&#125; =    Get Some Value</span><br><span class="line">    Should Be Equal    $&#123;value&#125;    Expected value</span><br><span class="line">Note</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>虽然测试用例名称可以包含任何字符，但通常不建议使用 ? 和尤其是 *，因为它们在选择测试用例时被视为通配符。例如，尝试只运行名为 Example * 的测试，如 <code>--test &#39;Example *&#39;</code>，实际上会运行以 Example 开头的任何测试。</p>

    </div>
  </div>

<h5 id="在测试用例部分的设置"><a href="#在测试用例部分的设置" class="headerlink" title="在测试用例部分的设置"></a>在测试用例部分的设置</h5><p>测试用例也可以有自己的设置。设置名称总是在第二列，通常是关键字的位置，它们的值在后续的列中。设置名称周围有方括号，以便将它们与关键字区分开来。下面列出了可用的设置，并在本节后面进行了解释。</p>
<p><em>[Documentation]</em></p>
<pre><code>[文档] 用于指定测试用例文档。
</code></pre>
<p><em>[Setup]</em>, <em>[Teardown]</em></p>
<pre><code>[设置], [拆卸] 指定测试设置和拆卸。
</code></pre>
<p><em>[Tags]</em></p>
<pre><code>[标签] 用于标记测试用例。
</code></pre>
<p> <em>[Template]</em></p>
<pre><code>[模板] 指定要使用的模板关键字。测试本身将只包含用作该关键字参数的数据。
</code></pre>
<p><em>[Timeout]</em></p>
<pre><code>[超时] 用于设置测试用例超时。超时在其自己的部分中进行了讨论。
</code></pre>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>设置名称不区分大小写，但推荐使用上述格式。设置曾经也不区分空格，但在 Robot Framework 3.1 中已被弃用，尝试使用像 [T a g s] 这样的东西会在 Robot Framework 3.2 中引发错误。仍然允许在括号和名称之间可能存在的空格（例如 [ 标签 ]）。</p>

    </div>
  </div>

<p>带有设置的测试用例示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Test With Settings</span><br><span class="line">    [Documentation]    Another dummy test</span><br><span class="line">    [Tags]    dummy    owner-johndoe</span><br><span class="line">    Log    Hello, world!</span><br></pre></td></tr></table></figure></div>

<h5 id="在设置部分的测试用例相关设置"><a href="#在设置部分的测试用例相关设置" class="headerlink" title="在设置部分的测试用例相关设置"></a>在设置部分的测试用例相关设置</h5><p>设置部分可以有以下与测试用例相关的设置。这些设置主要是前面列出的特定于测试用例的设置的默认值。</p>
<p>测试设置，测试拆卸 测试设置和拆卸的默认值。 测试标签 套件中所有测试将获得的标签，除了它们可能自己的标签。 测试模板 要使用的默认模板关键字。 测试超时 测试用例超时的默认值。超时在其自己的部分中进行了讨论。</p>
<p>[<em>Test Setup</em>, <em>Test Teardown</em>]</p>
<pre><code>[测试设置，测试拆卸] 默认值为测试设置和拆卸。
</code></pre>
<p>[<em>Test Tags</em>]</p>
<pre><code>[测试标签] 套件中所有测试将获得的标签，除了它们可能自己的标签。
</code></pre>
<p>[<em>Test Template</em>]</p>
<pre><code>[测试模板] 要使用的默认模板关键字。
</code></pre>
<p>[<em>Test Timeout</em>]</p>
<pre><code>[测试超时] 测试用例超时的默认值。超时在其自己的部分中进行了讨论。
</code></pre>
<h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p>前面的例子已经展示了关键字如何接受不同的参数，本节将更全面地讨论这一重要功能。如何实际实现带有不同参数的用户定义关键字和库关键字将在后续章节中讨论。</p>
<p>关键字可以接受零个或多个参数，某些参数可能具有默认值。关键字接受哪些参数取决于其实现，通常最好的信息来源是关键字的文档。在本节的例子中，文档预期是使用Libdoc工具生成的，但相同的信息也可在使用通用文档工具如pydoc生成的文档中找到。</p>
<h5 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h5><p>大多数关键字都有一定数量的参数，必须始终给出。在关键字文档中，这通过指定用逗号分隔的参数名表示，如 <code>first, second, third</code>。在这种情况下，参数名实际上并不重要，除了它们应该解释参数的作用，但重要的是必须有与文档中指定的完全相同数量的参数。使用的参数太少或太多都会导致错误。</p>
<p>下面的测试使用了来自<a class="link"   target="_blank" rel="noopener" href="https://robotframework.org/robotframework/latest/libraries/OperatingSystem.html" >OperatingSystem <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>库的关键字 <code>Create Directory</code> 和 <code>Copy File</code>。它们的参数分别指定为 <code>path</code> 和 <code>source, destination</code>，这意味着它们分别接受一个和两个参数。最后一个关键字，来自BuiltIn的 No Operation，不接受任何参数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Create Directory    $&#123;TEMPDIR&#125;/stuff</span><br><span class="line">    Copy File    $&#123;CURDIR&#125;/file.txt    $&#123;TEMPDIR&#125;/stuff</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>参数通常具有默认值，可以给出或不给出。在文档中，默认值通常与参数名称用等号分隔，如 <code>name=default value</code>。所有参数都有默认值是可能的，但在具有默认值的参数之后不能有任何位置参数。</p>
<p>使用默认值的示例如下所示，其中使用了 <code>Create File</code> 关键字，其参数为 <code>path</code>、<code>content=</code> 和 <code>encoding=UTF-8</code>。尝试在没有任何参数或多于三个参数的情况下使用它将无法正常工作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Create File    $&#123;TEMPDIR&#125;/empty.txt</span><br><span class="line">    Create File    $&#123;TEMPDIR&#125;/utf-8.txt         Hyvä esimerkki</span><br><span class="line">    Create File    $&#123;TEMPDIR&#125;/iso-8859-1.txt    Hyvä esimerkki    ISO-8859-1</span><br></pre></td></tr></table></figure></div>

<h5 id="可变数量的参数"><a href="#可变数量的参数" class="headerlink" title="可变数量的参数"></a>可变数量的参数</h5><p>也有可能某个关键字接受任意数量的参数。这些所谓的变长参数可以与必需参数和具有默认值的参数组合使用，但它们始终在它们之后给出。在文档中，它们的参数名称前面有一个星号，如 *varargs。</p>
<p>例如，操作系统库中的 <code>Remove Files</code> 和 <code>Join Paths</code> 关键字具有参数 <em>paths 和 base、</em>parts，分别。前者可以接受任意数量的参数，但后者至少需要一个参数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Remove Files    $&#123;TEMPDIR&#125;/f1.txt    $&#123;TEMPDIR&#125;/f2.txt    $&#123;TEMPDIR&#125;/f3.txt</span><br><span class="line">    @&#123;paths&#125; =    Join Paths    $&#123;TEMPDIR&#125;    f1.txt    f2.txt    f3.txt    f4.txt</span><br></pre></td></tr></table></figure></div>

<p>在这个示例中：</p>
<ul>
<li><code>*** Test Cases ***</code>：定义了测试用例的开始。</li>
<li><code>Example</code>：测试用例的名称。</li>
<li><code>Remove Files    $&#123;TEMPDIR&#125;/f1.txt    $&#123;TEMPDIR&#125;/f2.txt    $&#123;TEMPDIR&#125;/f3.txt</code>：执行了一个关键字，删除了指定的文件。</li>
<li><code>@&#123;paths&#125; =    Join Paths    $&#123;TEMPDIR&#125;    f1.txt    f2.txt    f3.txt    f4.txt</code>：执行了另一个关键字，将路径组合在一起。</li>
</ul>
<h5 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h5><p>命名参数语法使得使用具有默认值的参数更加灵活，并允许明确标记某个参数值的含义。从技术上讲，命名参数的工作方式与Python中的关键字参数完全相同。</p>
<h6 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h6><p>可以通过在值前加上参数名（如 <code>arg=value</code>）来命名给关键字的参数。当多个参数具有默认值时，这特别有用，因为可以只命名一些参数，让其他参数使用其默认值。例如，如果一个关键字接受参数 <code>arg1=a</code>，<code>arg2=b</code>，<code>arg3=c</code>，并且它被调用时只有一个参数 <code>arg3=override</code>，那么参数 <code>arg1</code> 和 <code>arg2</code> 将获得其默认值，但 <code>arg3</code> 将获得值 <code>override</code>。如果这听起来很复杂，下面的命名参数示例应该会使其更清晰。</p>
<p>命名参数语法对大小写和空格都很敏感。前者意味着，如果有一个参数 <code>arg</code>，必须像 <code>arg=value</code> 这样使用它，而 <code>Arg=value</code> 或 <code>ARG=value</code> 都不行。后者意味着，在 <code>=</code> 符号前不允许有空格，可能在其后的空格将被视为给定值的一部分。</p>
<p>当命名参数语法与用户关键字一起使用时，必须在不带 <code>$&#123;&#125;</code> 装饰的情况下给出参数名。例如，带有参数 <code>$&#123;arg1&#125;=first</code>，<code>$&#123;arg2&#125;=second</code> 的用户关键字必须像 <code>arg2=override</code> 这样使用。</p>
<p>在命名参数之后使用普通位置参数，例如 <code>| Keyword | arg=value | positional |</code>，是不行的。命名参数的相对顺序并不重要。</p>
<h6 id="命名参数与变量"><a href="#命名参数与变量" class="headerlink" title="命名参数与变量"></a>命名参数与变量</h6><p>在命名参数的名称和值中都可以使用变量。如果值是单个标量变量，它将按原样传递给关键字。这允许在使用命名参数语法时，也可以使用任何对象，而不仅仅是字符串，作为值。例如，调用像 <code>arg=$&#123;object&#125;</code> 这样的关键字将把变量 <code>$&#123;object&#125;</code> 传递给关键字，而不会将其转换为字符串。</p>
<p>如果在命名参数名称中使用变量，变量在与参数名称匹配之前就会被解析。</p>
<p>命名参数语法要求在关键字调用中直接写入等号。这意味着，即使变量具有像 <code>foo=bar</code> 这样的值，单独的变量也永远不会触发命名参数语法。这一点在将关键字包装到其他关键字中时尤其需要记住。例如，如果一个关键字接受像 <code>@&#123;args&#125;</code> 这样的变量数量的参数，并使用相同的 <code>@&#123;args&#125;</code> 语法将所有参数传递给另一个关键字，那么在调用端使用的可能的 <code>named=arg</code> 语法将不会被识别。下面的示例进行了说明。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Run Program    shell=True    # 这将不会作为一个命名参数传递给 Run Process</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Run Program</span><br><span class="line">    [Arguments]    @&#123;args&#125;</span><br><span class="line">    Run Process    program.py    @&#123;args&#125;    # 在 @&#123;args&#125; 内部不会识别命名参数</span><br></pre></td></tr></table></figure></div>

<p>如果关键字需要接受并传递任何命名参数，它必须被改变以接受自由命名参数。参见自由命名参数示例，了解一个可以传递位置参数和命名参数的包装关键字版本。</p>
<h5 id="转义命名参数语法"><a href="#转义命名参数语法" class="headerlink" title="转义命名参数语法"></a>转义命名参数语法</h5><p>命名参数语法仅在等号前的参数部分与关键字的某个参数匹配时使用。可能存在一个位置参数，其字面值如 <code>foo=quux</code>，并且还有一个名为 <code>foo</code> 的无关参数。在这种情况下，参数 <code>foo</code> 可能错误地获取值 <code>quux</code>，或者更可能的是，出现语法错误。</p>
<p>在这些偶尔出现的匹配错误的情况下，可以使用反斜杠字符来转义语法，如 <code>foo\=quux</code>。现在，参数将获得字面值 <code>foo=quux</code>。请注意，如果没有名为 <code>foo</code> 的参数，那么不需要转义，但是因为它使情况更加明确，所以可能仍然是个好主意。</p>
<h6 id="命名参数支持的位置"><a href="#命名参数支持的位置" class="headerlink" title="命名参数支持的位置"></a>命名参数支持的位置</h6><p>如前所述，命名参数语法适用于关键字。除此之外，它还适用于导入库时。</p>
<p>用户关键字和大多数测试库都支持命名参数。唯一的例外是明确使用位置参数的Python关键字。</p>
<h6 id="命名参数示例"><a href="#命名参数示例" class="headerlink" title="命名参数示例"></a>命名参数示例</h6><p>以下示例演示了如何在库关键字、用户关键字以及导入 Telnet 测试库时使用命名参数语法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    Telnet    prompt=$    default_log_level=DEBUG</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Open connection    10.0.0.42    port=$&#123;PORT&#125;    alias=example</span><br><span class="line">    List files    options=-lh</span><br><span class="line">    List files    path=/tmp    options=-l</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">List files</span><br><span class="line">    [Arguments]    $&#123;path&#125;=.    $&#123;options&#125;=</span><br><span class="line">    Execute command    ls $&#123;options&#125; $&#123;path&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="自由命名参数"><a href="#自由命名参数" class="headerlink" title="自由命名参数"></a>自由命名参数</h5><p>Robot Framework支持自由命名参数，通常也被称为自由关键字参数或kwargs，类似于Python支持的**kwargs。这意味着一个关键字可以接收所有使用命名参数语法（<code>name=value</code>）的参数，并且不匹配关键字签名中指定的任何参数。</p>
<p>自由命名参数由与普通命名参数相同的关键字类型支持。关键字如何指定它们接受自由命名参数取决于关键字类型。例如，基于Python的关键字简单地使用**kwargs，用户关键字使用 <code>&amp;&#123;kwargs&#125;</code>。</p>
<p>自由命名参数支持变量，就像命名参数一样。在实践中，这意味着变量可以同时用在名称和值中，但是转义符必须始终直接可见。例如，只要使用的变量存在，<code>foo=$&#123;bar&#125;</code>和 <code>$&#123;foo&#125;=$&#123;bar&#125;</code>都是有效的。额外的限制是自由参数名称必须始终是字符串。</p>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>作为使用自由命名参数的第一个示例，看一下Process库中的Run Process关键字。它有一个签名 <code>command</code>，<code>*arguments</code>，<code>**configuration</code>，这意味着它接收要执行的命令（<code>command</code>），其参数作为可变数量的参数（<code>*arguments</code>）以及最后的可选配置参数作为自由命名参数（<code>**configuration</code>）。下面的示例还显示了变量与自由关键字参数一起工作的方式，就像使用命名参数语法时一样。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Free Named Arguments</span><br><span class="line">    Run Process    program.py    arg1    arg2    cwd=/home/user</span><br><span class="line">    Run Process    program.py    argument    shell=True    env=$&#123;ENVIRON&#125;</span><br></pre></td></tr></table></figure></div>

<p>请参阅创建测试库下的自由关键字参数（**kwargs）部分，以获取有关在自定义测试库中使用自由命名参数语法的更多信息。</p>
<p>作为第二个示例，创建一个包装用户关键字，用于运行上述示例中的program.py。包装关键字Run Program接受所有位置和命名参数，并将它们连同要执行的命令名称一起传递给Run Process。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Free Named Arguments</span><br><span class="line">    Run Program    arg1    arg2    cwd=/home/user</span><br><span class="line">    Run Program    argument    shell=True    env=$&#123;ENVIRON&#125;</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Run Program</span><br><span class="line">    [Arguments]    @&#123;args&#125;    &amp;&#123;config&#125;</span><br><span class="line">    Run Process    program.py    @&#123;args&#125;    &amp;&#123;config&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="仅命名参数"><a href="#仅命名参数" class="headerlink" title="仅命名参数"></a>仅命名参数</h5><p>从Robot Framework 3.1开始，关键字可以接受必须始终使用命名参数语法进行命名的参数。例如，如果一个关键字接受一个仅命名参数 <code>example</code>，那么它必须始终像 <code>example=value</code> 这样使用，而不能仅使用 <code>value</code>。这种语法受到了Python 3支持的仅关键字参数语法的启发。</p>
<p>在大多数情况下，仅命名参数的工作方式与命名参数相同。主要的区别是，使用静态库API实现的Python 2库不支持此语法。</p>
<p>作为使用用户关键字的仅命名参数的一个示例，下面是上述自由命名参数示例中的Run Program的一个变体，它只支持配置shell：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Named-only Arguments</span><br><span class="line">    Run Program    arg1    arg2              # &#x27;shell&#x27; 是 False (默认)</span><br><span class="line">    Run Program    argument    shell=True    # &#x27;shell&#x27; 是 True</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Run Program</span><br><span class="line">    [Arguments]    @&#123;args&#125;    $&#123;shell&#125;=False</span><br><span class="line">    Run Process    program.py    @&#123;args&#125;    shell=$&#123;shell&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="嵌入到关键字名称中的参数"><a href="#嵌入到关键字名称中的参数" class="headerlink" title="嵌入到关键字名称中的参数"></a>嵌入到关键字名称中的参数</h6><p>指定参数的一种完全不同的方法是将参数嵌入到关键字名称中。这种语法由测试库关键字和用户关键字都支持。</p>
<h4 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h4><h5 id="测试用例失败时"><a href="#测试用例失败时" class="headerlink" title="测试用例失败时"></a>测试用例失败时</h5><p>如果测试用例使用的任何关键字失败，测试用例就会失败。通常，这意味着该测试用例的执行将停止，可能执行测试拆解，然后从下一个测试用例继续执行。如果不希望停止测试执行，也可以使用特殊的可继续失败。</p>
<h5 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h5><p>分配给失败的测试用例的错误消息直接来自失败的关键字。通常，错误消息是由关键字本身创建的，但是一些关键字允许配置它们。</p>
<p>在某些情况下，例如当使用可继续失败时，一个测试用例可能会失败多次。在这种情况下，最终的错误消息是通过组合各个错误得到的。非常长的错误消息会自动从中间切断，以使报告更易于阅读，但完整的错误消息始终作为失败关键字的消息在日志文件中可见。</p>
<p>默认情况下，错误消息是普通文本，但它们可以包含HTML格式。这通过在错误消息开始处使用标记字符串 <em>HTML</em> 来启用。这个标记将从报告和日志中显示的最终错误消息中删除。下面的第二个示例显示了在自定义消息中使用HTML。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Normal Error</span><br><span class="line">    Fail    这是一个相当无聊的例子...</span><br><span class="line"></span><br><span class="line">HTML Error</span><br><span class="line">    $&#123;number&#125; =    Get Number</span><br><span class="line">    Should Be Equal    $&#123;number&#125;    42    *HTML* 数字不是的&lt;b&gt;魔法&lt;/b&gt;数字。</span><br></pre></td></tr></table></figure></div>

<h4 id="测试用例名称和文档"><a href="#测试用例名称和文档" class="headerlink" title="测试用例名称和文档"></a>测试用例名称和文档</h4><p>测试用例名称直接来自测试用例部分：它就是输入到测试用例列中的内容。一个测试套件中的测试用例应该有唯一的名称。关于这一点，也可以在测试本身中使用自动变量 <code>$&#123;TEST_NAME&#125;</code> 来引用测试名称。无论何时执行测试，包括所有用户关键字，以及测试设置和测试拆解，它都是可用的。</p>
<p>从Robot Framework 3.2开始，测试用例名称中可能的变量会被解析，以便最终名称将包含变量值。如果变量不存在，其名称将保持不变。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;MAX AMOUNT&#125;      $&#123;5000000&#125;</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Amount cannot be larger than $&#123;MAX AMOUNT&#125;</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure></div>

<p>[Documentation] 设置允许为测试用例设置自由形式的文档。该文本将显示在命令行输出和生成的日志和报告中。如果文档过长，可以将其分割成多行。可以使用简单的HTML格式，并且可以使用变量使文档动态化。可能不存在的变量将保持不变。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Simple</span><br><span class="line">    [Documentation]    简单且短小的文档。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Multiple lines</span><br><span class="line">    [Documentation]    文档的第一行。</span><br><span class="line">    ...</span><br><span class="line">    ...                文档在这里继续。这些行在HTML输出中形成</span><br><span class="line">    ...                一个段落。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Formatting</span><br><span class="line">    [Documentation]</span><br><span class="line">    ...    这个列表有：</span><br><span class="line">    ...    - *粗体*</span><br><span class="line">    ...    - _斜体_</span><br><span class="line">    ...    - 链接: http://robotframework.org</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Variables</span><br><span class="line">    [Documentation]    在 $&#123;HOST&#125; 上由 $&#123;USER&#125; 执行</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<p>测试用例有清晰和描述性的名称是很重要的，而在这种情况下，它们通常不需要任何文档。如果测试用例的逻辑需要文档化，这通常是一个信号，表示测试用例中的关键字需要更好的名称，它们需要被增强，而不是添加额外的文档。最后，元数据，如上述最后一个示例中的环境和用户信息，通常最好使用标签来指定。</p>
<h4 id="标记测试用例"><a href="#标记测试用例" class="headerlink" title="标记测试用例"></a>标记测试用例</h4><p>在Robot Framework中使用标签是一种简单而强大的机制，用于分类测试用例和用户关键字。标签是自由文本，Robot Framework本身对它们没有特殊的含义，除了下面讨论的保留标签。标签至少可以用于以下目的：</p>
<ul>
<li>它们显示在测试报告、日志以及测试数据中，因此它们为测试用例提供元数据。</li>
<li>基于它们自动收集关于测试用例（总数、通过、失败和跳过）的统计信息。</li>
<li>它们可以用于包含和排除以及跳过测试用例。</li>
</ul>
<p>有多种方式可以为测试用例指定标签，如下所述：</p>
<ul>
<li>在设置部分中的测试标签设置<ul>
<li>具有此设置的测试用例文件中的所有测试始终获得指定的标签。如果在套件初始化文件中使用此设置，所有子套件中的测试都会获得这些标签。</li>
</ul>
</li>
<li>每个测试用例的[Tags]设置<ul>
<li>测试将获得这些标签，除了使用测试标签设置指定的标签。[Tags]设置还允许使用-tag语法删除使用测试标签设置的标签。</li>
</ul>
</li>
<li>–settag命令行选项<ul>
<li>所有测试都会获得此选项设置的标签，除了它们在其他地方获得的标签。</li>
</ul>
</li>
<li>Set Tags，Remove Tags，Fail和Pass Execution关键字<ul>
<li>这些BuiltIn关键字可以用于在测试执行期间动态操作标签。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***git fetch origin</span><br><span class="line">Test Tags       requirement: 42    smoke</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;HOST&#125;         10.0.1.42</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">No own tags</span><br><span class="line">    [Documentation]    测试有标签 &#x27;requirement: 42&#x27; 和 &#x27;smoke&#x27;。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own tags</span><br><span class="line">    [Documentation]    测试有标签 &#x27;requirement: 42&#x27;，&#x27;smoke&#x27; 和 &#x27;not ready&#x27;。</span><br><span class="line">    [Tags]    not ready</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own tags with variable</span><br><span class="line">    [Documentation]    测试有标签 &#x27;requirement: 42&#x27;，&#x27;smoke&#x27; 和 &#x27;host: 10.0.1.42&#x27;。</span><br><span class="line">    [Tags]    host: $&#123;HOST&#125;</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Remove common tag</span><br><span class="line">    [Documentation]    测试只有标签 &#x27;requirement: 42&#x27;。</span><br><span class="line">    [Tags]    -smoke</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Remove common tag using a pattern</span><br><span class="line">    [Documentation]    测试只有标签 &#x27;smoke&#x27;。</span><br><span class="line">    [Tags]    -requirement: *</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Set Tags and Remove Tags keywords</span><br><span class="line">    [Documentation]    这个测试有标签 &#x27;smoke&#x27;，&#x27;example&#x27; 和 &#x27;another&#x27;。</span><br><span class="line">    Set Tags    example    another</span><br><span class="line">    Remove Tags    requirement: *</span><br></pre></td></tr></table></figure></div>

<p>如示例所示，可以使用变量创建标签，但否则它们保留数据中使用的确切名称。当比较标签时，例如，收集统计信息，选择要执行的测试，或者删除重复项，比较是大小写、空格和下划线不敏感的。</p>
<p>如上述示例所示，使用-tag语法删除标签支持简单的模式，如-requirement: *。以连字符开头的标签除了在[Tags]设置中没有其他特殊含义。如果需要使用[Tags]设置一个以连字符开头的标签，可以使用转义格式，如-tag。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>测试标签设置是在Robot Framework 6.0中新增的。早期版本支持Force Tags和Default Tags设置，这将在下一节中讨论。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>删除常见标签的-tag语法是在Robot Framework 7.0中新增的。</p>

    </div>
  </div>

<h5 id="弃用-Force-Tags-和-Default-Tags"><a href="#弃用-Force-Tags-和-Default-Tags" class="headerlink" title="弃用 Force Tags 和 Default Tags"></a>弃用 Force Tags 和 Default Tags</h5><p>在Robot Framework 6.0之前，可以使用两种不同的设置在设置部分为测试指定标签：</p>
<p>Force Tags 所有测试无条件地获得这些标签。这与现在的Test Tags完全相同。 Default Tags 所有测试默认获得这些标签。如果测试有[Tags]，它将不会获得这些标签。 这两种设置仍然可以工作，但它们被认为是已弃用的。将来会添加一个可见的弃用警告，最可能在Robot Framework 8.0中，最终这些设置将被删除。可以使用像Tidy这样的工具来简化过渡。</p>
<p>更新Force Tags只需要将其重命名为Test Tags。Default Tags设置将被完全删除，但在Robot Framework 7.0中引入的-tag功能提供了相同的基础功能。下面的示例演示了所需的更改。</p>
<p>旧语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Force Tags      all</span><br><span class="line">Default Tags    default</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Common only</span><br><span class="line">    [Documentation]    测试有标签 &#x27;all&#x27; 和 &#x27;default&#x27;。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">No default</span><br><span class="line">    [Documentation]    测试只有标签 &#x27;all&#x27;。</span><br><span class="line">    [Tags]</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own and no default</span><br><span class="line">    [Documentation]    测试有标签 &#x27;all&#x27; 和 &#x27;own&#x27;。</span><br><span class="line">    [Tags]    own</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<p>新语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Test Tags      all    default</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Common only</span><br><span class="line">    [Documentation]    测试有标签 &#x27;all&#x27; 和 &#x27;default&#x27;。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">No default</span><br><span class="line">    [Documentation]    测试只有标签 &#x27;all&#x27;。</span><br><span class="line">    [Tags]    -default</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own and no default</span><br><span class="line">    [Documentation]    测试有标签 &#x27;all&#x27; 和 &#x27;own&#x27;。</span><br><span class="line">    [Tags]    own    -default</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<h5 id="保留标签"><a href="#保留标签" class="headerlink" title="保留标签"></a>保留标签</h5><p>用户通常可以自由地使用在他们的上下文中工作的任何标签。然而，有一些标签对于Robot Framework本身有预定义的含义，用它们来做其他用途可能会有意想不到的结果。Robot Framework现在和将来所有的特殊标签都有 <code>robot:</code> 前缀。为了避免问题，用户因此不应该使用任何带有这个前缀的标签，除非实际激活特殊功能。当前的保留标签列在下面，但是未来可能会添加更多这样的标签。</p>
<ul>
<li><pre><code>robot:continue-on-failure
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
robot:recursive-continue-on-failure
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 用于启用继续失败模式。</span><br><span class="line">- ```</span><br><span class="line">  robot:stop-on-failure</span><br></pre></td></tr></table></figure></div>

和

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot:recursive-stop-on-failure</span><br></pre></td></tr></table></figure></div>

- 用于禁用继续失败模式。
</code></pre>
</li>
<li><pre><code>robot:skip-on-failure
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 如果测试失败，则标记为跳过。</span><br><span class="line">- ```</span><br><span class="line">  robot:skip</span><br></pre></td></tr></table></figure></div>

- 无条件跳过测试。
</code></pre>
</li>
<li><pre><code>robot:exclude
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 无条件排除测试。</span><br><span class="line">- ```</span><br><span class="line">  robot:private</span><br></pre></td></tr></table></figure></div>

- 标记关键字为私有。
</code></pre>
</li>
<li><pre><code>robot:no-dry-run
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 标记关键字在干运行模式下不执行。</span><br><span class="line">- ```</span><br><span class="line">  robot:exit</span><br></pre></td></tr></table></figure></div>

- 当执行停止时，自动添加到测试中。
</code></pre>
</li>
<li><pre><code>robot:flatten
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在执行时间启用平铺关键字。</span><br><span class="line"></span><br><span class="line">从RobotFramework 4.1开始，默认情况下在标签统计中抑制保留标签。当它们通过 `--tagstatinclude robot:*` 命令行选项明确包含时，它们将被显示。</span><br><span class="line"></span><br><span class="line">#### 测试设置和拆解</span><br><span class="line"></span><br><span class="line">Robot Framework具有与许多其他测试自动化框架类似的测试设置和拆解功能。简单来说，测试设置是在测试用例之前执行的操作，而测试拆解是在测试用例之后执行的操作。在Robot Framework中，设置和拆解只是具有可能参数的普通关键字。</span><br><span class="line"></span><br><span class="line">设置和拆解总是单个关键字。如果它们需要处理多个独立的任务，可以创建高级用户关键字来实现。另一种解决方案是使用BuiltIn关键字Run Keywords执行多个关键字。</span><br><span class="line"></span><br><span class="line">测试拆解在两个方面特殊。首先，即使测试用例失败，它也会被执行，所以它可以用于必须完成的清理活动，无论测试用例的状态如何。此外，即使其中一个关键字失败，拆解中的所有关键字也会被执行。这种继续失败的功能也可以用于普通关键字，但在拆解中它默认是开启的。</span><br><span class="line"></span><br><span class="line">在测试用例文件中为测试用例指定设置或拆解的最简单方法是使用设置部分中的Test Setup和Test Teardown设置。单个测试用例也可以有自己的设置或拆解。它们是在测试用例部分的[Setup]或[Teardown]设置中定义的，并且它们会覆盖可能的Test Setup和Test Teardown设置。在[Setup]或[Teardown]设置后没有关键字意味着没有设置或拆解。也可以使用值NONE来表示测试没有设置/拆解。</span><br><span class="line"></span><br><span class="line">```robotframework</span><br><span class="line">*** Settings ***</span><br><span class="line">Test Setup       Open Application    App A</span><br><span class="line">Test Teardown    Close Application</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Default values</span><br><span class="line">    [Documentation]    设置和拆解来自设置部分</span><br><span class="line">    Do Something</span><br><span class="line"></span><br><span class="line">Overridden setup</span><br><span class="line">    [Documentation]    自己的设置，拆解来自设置部分</span><br><span class="line">    [Setup]    Open Application    App B</span><br><span class="line">    Do Something</span><br><span class="line"></span><br><span class="line">No teardown</span><br><span class="line">    [Documentation]    默认设置，完全没有拆解</span><br><span class="line">    Do Something</span><br><span class="line">    [Teardown]</span><br><span class="line"></span><br><span class="line">No teardown 2</span><br><span class="line">    [Documentation]    设置和拆解也可以通过特殊值NONE禁用</span><br><span class="line">    Do Something</span><br><span class="line">    [Teardown]    NONE</span><br><span class="line"></span><br><span class="line">Using variables</span><br><span class="line">    [Documentation]    使用变量指定设置和拆解</span><br><span class="line">    [Setup]    $&#123;SETUP&#125;</span><br><span class="line">    Do Something</span><br><span class="line">    [Teardown]    $&#123;TEARDOWN&#125;</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
<p>作为设置或拆解执行的关键字的名称可以是一个变量。这通过从命令行给出关键字名称作为变量，便于在不同环境中有不同的设置或拆解。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>测试套件可以有自己的设置和拆解。套件设置在该测试套件中的任何测试用例或子测试套件之前执行，同样，套件拆解在它们之后执行。</p>

    </div>
  </div>

<h4 id="测试模板"><a href="#测试模板" class="headerlink" title="测试模板"></a>测试模板</h4><p>测试模板将普通的关键字驱动测试用例转换为数据驱动的测试。关键字驱动的测试用例的主体是由关键字和它们可能的参数构成的，而带有模板的测试用例只包含模板关键字的参数。与其在每个测试和&#x2F;或文件中的所有测试中多次重复相同的关键字，不如只在每个测试或文件中使用一次。</p>
<p>模板关键字可以接受正常的位置参数和命名参数，以及嵌入到关键字名称中的参数。与其他设置不同，不能使用变量定义模板。</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>以下示例测试用例说明了如何将接受正常位置参数的关键字用作模板。这两个测试在功能上完全相同。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Normal test case</span><br><span class="line">    Example keyword    first argument    second argument</span><br><span class="line"></span><br><span class="line">Templated test case</span><br><span class="line">    [Template]    Example keyword</span><br><span class="line">    first argument    second argument</span><br></pre></td></tr></table></figure></div>

<p>如示例所示，可以使用 [Template] 设置为单个测试用例指定模板。另一种方法是在设置部分使用 Test Template 设置，在这种情况下，模板将应用于该测试用例文件中的所有测试用例。[Template] 设置会覆盖设置部分设置的可能的模板，而 [Template] 的空值意味着测试没有模板，即使使用了 Test Template。也可以使用值 NONE 来表示测试没有模板。</p>
<p>如果一个带模板的测试用例在其主体中有多个数据行，那么模板将逐行应用于所有行。这意味着相同的关键字会被执行多次，每行数据执行一次。模板化的测试也是特殊的，因为即使其中一个或多个失败，所有的轮次也会被执行。这种继续失败模式也可以用于普通测试，但在模板化的测试中，该模式是自动开启的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Test Template    Example keyword</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Templated test case</span><br><span class="line">    first round 1     first round 2</span><br><span class="line">    second round 1    second round 2</span><br><span class="line">    third round 1     third round 2</span><br></pre></td></tr></table></figure></div>

<p>使用具有默认值或接受可变数量参数的关键字，以及使用命名参数和自由命名参数，与模板的工作方式完全相同。在参数中使用变量也是正常支持的。</p>
<h5 id="嵌入参数的模板"><a href="#嵌入参数的模板" class="headerlink" title="嵌入参数的模板"></a>嵌入参数的模板</h5><p>模板支持嵌入参数语法的变体。使用模板时，此语法的工作方式是，如果模板关键字的名称中有变量，它们被视为参数的占位符，并用模板使用的实际参数替换。然后使用结果关键字，而不使用位置参数。这最好通过一个例子来说明：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">带嵌入参数的普通测试用例</span><br><span class="line">    1 + 1 的结果应该是 2</span><br><span class="line">    1 + 2 的结果应该是 3</span><br><span class="line"></span><br><span class="line">带嵌入参数的模板</span><br><span class="line">    [Template]    $&#123;calculation&#125; 的结果应该是 $&#123;expected&#125;</span><br><span class="line">    1 + 1    2</span><br><span class="line">    1 + 2    3</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">$&#123;calculation&#125; 的结果应该是 $&#123;expected&#125;</span><br><span class="line">    $&#123;result&#125; =    计算    $&#123;calculation&#125;</span><br><span class="line">    应该相等    $&#123;result&#125;     $&#123;expected&#125;</span><br></pre></td></tr></table></figure></div>

<p>当使用模板的嵌入参数时，模板关键字名称中的参数数量必须与其使用的参数数量匹配。尽管参数名称不需要匹配原始关键字的参数，也可以完全使用不同的参数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">不同的参数名称</span><br><span class="line">    [Template]    $&#123;foo&#125; 的结果应该是 $&#123;bar&#125;</span><br><span class="line">    1 + 1    2</span><br><span class="line">    1 + 2    3</span><br><span class="line"></span><br><span class="line">只有一些参数</span><br><span class="line">    [Template]    $&#123;calculation&#125; 的结果应该是 3</span><br><span class="line">    1 + 2</span><br><span class="line">    4 - 1</span><br><span class="line"></span><br><span class="line">新的参数</span><br><span class="line">    [Template]    $&#123;life&#125; 的 $&#123;meaning&#125; 应该是 42</span><br><span class="line">    result    21 * 2</span><br></pre></td></tr></table></figure></div>

<p>使用模板的嵌入参数的主要好处是参数名称被明确指定。当使用普通参数时，可以通过命名包含参数的列来达到相同的效果。这在下一节的数据驱动样式示例中有所说明。</p>
<h5 id="使用FOR循环的模板"><a href="#使用FOR循环的模板" class="headerlink" title="使用FOR循环的模板"></a>使用FOR循环的模板</h5><p>如果模板与FOR循环一起使用，模板将应用于循环内的所有步骤。在这种情况下，也会使用继续失败模式，这意味着即使有失败，所有的步骤也会与所有的循环元素一起执行。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">带FOR循环的模板</span><br><span class="line">    [Template]    Example keyword</span><br><span class="line">    FOR    $&#123;item&#125;    IN    @&#123;ITEMS&#125;</span><br><span class="line">        $&#123;item&#125;    2nd arg</span><br><span class="line">    END</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    42</span><br><span class="line">        1st arg    $&#123;index&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="使用IF-ELSE结构的模板"><a href="#使用IF-ELSE结构的模板" class="headerlink" title="使用IF&#x2F;ELSE结构的模板"></a>使用IF&#x2F;ELSE结构的模板</h5><p>IF&#x2F;ELSE结构也可以与模板一起使用。例如，当与FOR循环一起使用时，这可以用于过滤执行的参数，这可能很有用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">带FOR和IF的模板</span><br><span class="line">    [Template]    Example keyword</span><br><span class="line">    FOR    $&#123;item&#125;    IN    @&#123;ITEMS&#125;</span><br><span class="line">        IF  $&#123;item&#125; &lt; 5</span><br><span class="line">            $&#123;item&#125;    2nd arg</span><br><span class="line">        END</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h4 id="不同的测试用例风格"><a href="#不同的测试用例风格" class="headerlink" title="不同的测试用例风格"></a>不同的测试用例风格</h4><p>测试用例可以以多种不同的方式编写。描述某种工作流的测试用例可以以关键字驱动或行为驱动的风格编写。数据驱动的风格可以用于测试具有不同输入数据的相同工作流。</p>
<h5 id="关键字驱动风格"><a href="#关键字驱动风格" class="headerlink" title="关键字驱动风格"></a>关键字驱动风格</h5><p>工作流测试，如前面描述的有效登录测试，是由几个关键字及其可能的参数构建的。它们的正常结构是首先将系统置于初始状态（在有效登录示例中打开登录页面），然后对系统进行一些操作（输入名称，输入密码，提交凭据），最后验证系统的行为是否符合预期（应打开欢迎页面）。</p>
<h5 id="数据驱动风格"><a href="#数据驱动风格" class="headerlink" title="数据驱动风格"></a>数据驱动风格</h5><p>编写测试用例的另一种风格是数据驱动的方法，其中测试用例只使用一个高级关键字（通常作为用户关键字创建），该关键字隐藏了实际的测试工作流。当需要使用不同的输入和&#x2F;或输出数据测试相同的场景时，这些测试非常有用。可以在每个测试中重复相同的关键字，但是测试模板功能允许只指定一次要使用的关键字。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Test Template    Login with invalid credentials should fail</span><br><span class="line"></span><br><span class="line">*** Test Cases ***                USERNAME         PASSWORD</span><br><span class="line">Invalid User Name                 invalid          $&#123;VALID PASSWORD&#125;</span><br><span class="line">Invalid Password                  $&#123;VALID USER&#125;    invalid</span><br><span class="line">Invalid User Name and Password    invalid          invalid</span><br><span class="line">Empty User Name                   $&#123;EMPTY&#125;         $&#123;VALID PASSWORD&#125;</span><br><span class="line">Empty Password                    $&#123;VALID USER&#125;    $&#123;EMPTY&#125;</span><br><span class="line">Empty User Name and Password      $&#123;EMPTY&#125;         $&#123;EMPTY&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>像上面的例子那样命名列可以使测试更易于理解。这是可能的，因为在标题行中，除第一个单元格外的其他单元格都被忽略。</p>

    </div>
  </div>

<p>上面的示例有六个独立的测试，每个无效的用户&#x2F;密码组合一个，下面的示例说明了如何只有一个测试包含所有的组合。使用测试模板时，即使有失败，测试中的所有轮次也会被执行，所以这两种风格之间没有真正的功能差异。在上面的示例中，单独的组合被命名，所以更容易看出它们测试了什么，但是可能有大量的这些测试可能会混乱统计数据。使用哪种风格取决于上下文和个人偏好。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Invalid Password</span><br><span class="line">    [Template]    Login with invalid credentials should fail</span><br><span class="line">    invalid          $&#123;VALID PASSWORD&#125;</span><br><span class="line">    $&#123;VALID USER&#125;    invalid</span><br><span class="line">    invalid          whatever</span><br><span class="line">    $&#123;EMPTY&#125;         $&#123;VALID PASSWORD&#125;</span><br><span class="line">    $&#123;VALID USER&#125;    $&#123;EMPTY&#125;</span><br><span class="line">    $&#123;EMPTY&#125;         $&#123;EMPTY&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="行为驱动风格"><a href="#行为驱动风格" class="headerlink" title="行为驱动风格"></a>行为驱动风格</h5><p>也可以将测试用例编写为非技术项目利益相关者也必须理解的需求。这些可执行的需求是通常被称为接受测试驱动开发（ATDD）或示例规范化的过程的基石。</p>
<p>编写这些需求&#x2F;测试的一种方式是由行为驱动开发（BDD）普及的Given-When-Then风格。在这种风格的测试用例中，初始状态通常用以Given开头的关键字表示，动作用以When开头的关键字描述，预期用以Then开头的关键字表示。如果一个步骤有多个动作，可以使用以And或But开头的关键字。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Valid Login</span><br><span class="line">    Given 登录页面已打开</span><br><span class="line">    When 插入有效的用户名和密码</span><br><span class="line">    and 提交凭据</span><br><span class="line">    Then 应该打开欢迎页面</span><br></pre></td></tr></table></figure></div>

<h6 id="忽略Given-When-Then-And-But前缀"><a href="#忽略Given-When-Then-And-But前缀" class="headerlink" title="忽略Given&#x2F;When&#x2F;Then&#x2F;And&#x2F;But前缀"></a>忽略Given&#x2F;When&#x2F;Then&#x2F;And&#x2F;But前缀</h6><p>当搜索匹配的关键字时，如果没有找到全名匹配，将丢弃前缀Given、When、Then、And和But。这对于用户关键字和库关键字都有效。例如，在上面的示例中，Given登录页面已打开可以实现为用户关键字，无论是否带有单词Given。忽略前缀还允许使用不同的前缀使用相同的关键字。例如，欢迎页面应该打开也可以用作And欢迎页面应该打开。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>这些前缀可以本地化。请参阅翻译附录以获取支持的翻译。</p>

    </div>
  </div>

<h6 id="嵌入数据到关键字"><a href="#嵌入数据到关键字" class="headerlink" title="嵌入数据到关键字"></a>嵌入数据到关键字</h6><p>在编写具体示例时，能够将实际数据传递给关键字实现是很有用的。用户关键字通过允许将参数嵌入到关键字名称中来支持这一点。</p>
<h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>除了测试自动化，Robot Framework还可以用于其他自动化目的，包括机器人流程自动化（RPA）。这一直是可能的，但Robot Framework 3.1添加了对自动化任务的官方支持，而不仅仅是测试。在大多数情况下，创建任务的工作方式与创建测试相同，唯一的实质区别在于术语。任务也可以像测试用例一样组织成套件。</p>
<h4 id="任务语法"><a href="#任务语法" class="headerlink" title="任务语法"></a>任务语法</h4><p>任务是基于可用关键字创建的，就像测试用例一样，任务语法通常与测试用例语法相同。主要区别在于，任务是在任务部分创建的，而不是在测试用例部分：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Tasks ***</span><br><span class="line">Process invoice</span><br><span class="line">    Read information from PDF</span><br><span class="line">    Validate information</span><br><span class="line">    Submit information to backend system</span><br><span class="line">    Validate information is visible in web UI</span><br></pre></td></tr></table></figure></div>

<p>在同一文件中同时有测试和任务是错误的。</p>
<h4 id="与任务相关的设置"><a href="#与任务相关的设置" class="headerlink" title="与任务相关的设置"></a>与任务相关的设置</h4><p>可以在任务部分使用的设置与测试用例部分中可以使用的设置完全相同。在设置部分，可以使用任务设置、任务拆解、任务模板和任务超时，而不是它们的测试变体。</p>
<h3 id="创建测试套件"><a href="#创建测试套件" class="headerlink" title="创建测试套件"></a>创建测试套件</h3><p>Robot Framework的测试用例是在测试用例文件中创建的，这些文件可以组织成目录。这些文件和目录创建了一个分层的测试套件结构。创建任务时也适用相同的概念，但术语有所不同。</p>
<h4 id="套件文件"><a href="#套件文件" class="headerlink" title="套件文件"></a>套件文件</h4><p>Robot Framework的测试用例是在套件文件（也称为测试用例文件）中的测试用例部分创建的。这样的文件会自动从它包含的所有测试用例创建一个测试套件。测试用例的数量没有上限，但建议少于十个，除非使用数据驱动的方法，其中一个测试用例只包含一个高级关键字。</p>
<p>在设置部分，可以使用以下设置来自定义套件：</p>
<ul>
<li>Name<ul>
<li>用于设置自定义套件名称。默认名称是根据文件或目录名称创建的。</li>
</ul>
</li>
<li>Documentation<ul>
<li>用于指定套件文档。</li>
</ul>
</li>
<li>Metadata<ul>
<li>用于设置自由套件元数据作为名称-值对。</li>
</ul>
</li>
<li>Suite Setup, Suite Teardown<ul>
<li>指定套件设置和拆解。</li>
</ul>
</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>设置名称是不区分大小写的，但推荐使用上述格式。</p>

    </div>
  </div>

<h4 id="套件目录"><a href="#套件目录" class="headerlink" title="套件目录"></a>套件目录</h4><p>测试用例文件可以组织成目录，这些目录创建了更高级别的测试套件。从目录创建的测试套件不能直接包含任何测试用例，而是包含其他包含测试用例的测试套件。然后，这些目录可以放置到其他目录中，创建更高级别的套件。结构没有限制，所以可以根据需要组织测试用例。</p>
<p>当执行一个测试目录时，它包含的文件和目录会被递归处理，如下所示：</p>
<ul>
<li>以点（.）或下划线（_）开头的文件和目录名会被忽略。</li>
<li>名称为CVS的目录会被忽略（区分大小写）。</li>
<li>支持的文件格式的文件会被处理。</li>
<li>其他文件会被忽略。</li>
<li>如果处理的文件或目录不包含任何测试用例，它会被静默忽略（向系统日志写入一条消息），并继续处理。</li>
</ul>
<h4 id="套件初始化文件"><a href="#套件初始化文件" class="headerlink" title="套件初始化文件"></a>套件初始化文件</h4><p>从目录创建的测试套件可以有与从测试用例文件创建的套件相似的设置。因为目录本身不能包含这种信息，所以必须将其放入一个特殊的测试套件初始化文件中。初始化文件的名称必须始终采用<code>__init__.ext</code>的格式，其中扩展名必须是支持的文件格式之一（通常是<code>__init__.robot</code>）。这种命名格式借鉴自Python，其中以这种方式命名的文件表示目录是一个模块。</p>
<p>从Robot Framework 6.1开始，也可以为通过给出多个路径启动测试执行时自动创建的套件定义套件初始化文件。</p>
<p>初始化文件的结构和语法与测试用例文件相同，只是它们不能有测试用例部分，而且不是所有的设置都被支持。在初始化文件中创建或导入的变量和关键字在较低级别的测试套件中不可用。如果需要共享变量或关键字，可以将它们放入资源文件中，这些文件可以由初始化和测试用例文件导入。</p>
<p>初始化文件的主要用途是指定与套件文件类似的测试套件相关设置，但也可以设置一些与测试用例相关的设置。如何在初始化文件中使用不同的设置在下面解释。</p>
<ul>
<li>Name, Documentation, Metadata, Suite Setup, Suite Teardown<ul>
<li>这些套件特定的设置在套件初始化文件中的工作方式与套件文件中的工作方式相同。</li>
</ul>
</li>
<li>Test Tags<ul>
<li>指定的标签无条件地设置为此目录包含的所有套件文件中的所有测试，递归地。新的在Robot Framework 6.1。需要使用旧版本的Force Tags。</li>
</ul>
</li>
<li>Test Setup, Test Teardown, Test Timeout<ul>
<li>将测试设置&#x2F;拆解或测试超时的默认值设置为此目录包含的所有测试用例。可以在较低级别覆盖。注意，用作设置和拆解的关键字必须在使用它们的测试的测试用例文件中可用。在初始化文件本身中定义关键字是不够的。</li>
</ul>
</li>
<li>Task Setup, Task Teardown, Task Tags, Task Timeout<ul>
<li>分别是Test Setup, Test Teardown, Test Tags和Test Timeout的别名，可以在创建任务，而不是测试时使用。</li>
</ul>
</li>
<li>Default Tags, Test Template<ul>
<li>在初始化文件中不支持。</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation    示例套件</span><br><span class="line">Suite Setup      Do Something    $&#123;MESSAGE&#125;</span><br><span class="line">Test Tags        example</span><br><span class="line">Library          SomeLibrary</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;MESSAGE&#125;       Hello, world!</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Do Something</span><br><span class="line">    [Arguments]    $&#123;args&#125;</span><br><span class="line">    Some Keyword    $&#123;arg&#125;</span><br><span class="line">    Another Keyword</span><br></pre></td></tr></table></figure></div>

<h4 id="套件名称"><a href="#套件名称" class="headerlink" title="套件名称"></a>套件名称</h4><p>测试套件的名称默认由文件或目录名称构造。创建名称时，将忽略扩展名，可能的下划线被替换为空格，全小写的名称被转换为标题大小写。例如，<code>some_tests.robot</code>变成<code>Some Tests</code>，<code>My_test_directory</code>变成<code>My test directory</code>。</p>
<p>文件或目录名称可以包含一个前缀来控制套件的执行顺序。前缀与基本名称之间用两个下划线分隔，当构造实际的测试套件名称时，前缀和下划线都被删除。例如，文件<code>01__some_tests.robot</code>和<code>02__more_tests.robot</code>分别创建测试套件<code>Some Tests</code>和<code>More Tests</code>，前者在后者之前执行。</p>
<p>从Robot Framework 6.1开始，也可以通过在设置部分使用<code>Name</code>设置为套件指定一个自定义名称：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Name            Custom suite name</span><br></pre></td></tr></table></figure></div>

<p>可以使用<code>--name</code>选项从命令行覆盖顶级套件的名称。</p>
<h4 id="套件文档"><a href="#套件文档" class="headerlink" title="套件文档"></a>套件文档</h4><p>使用设置部分中的<code>Documentation</code>设置设置测试套件的文档。它可以在套件文件和套件初始化文件中使用。套件文档与测试用例文档在显示位置和创建方式上具有完全相同的特性。有关语法的详细信息，请参阅文档格式化附录。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation    An example suite documentation with *some* _formatting_.</span><br><span class="line">...              Long documentation can be split into multiple lines.</span><br></pre></td></tr></table></figure></div>

<p>可以使用<code>--doc</code>选项从命令行覆盖顶级套件的文档。</p>
<h4 id="自由套件元数据"><a href="#自由套件元数据" class="headerlink" title="自由套件元数据"></a>自由套件元数据</h4><p>除了文档外，套件还可以有自由元数据。这些元数据以名称-值对的形式在设置部分使用<code>Metadata</code>设置定义。它在报告和日志中的显示方式与文档类似。</p>
<p>元数据的名称是给<code>Metadata</code>设置的第一个参数，剩余的参数指定其值。值的处理方式与文档相同，这意味着它支持HTML格式和变量，而且较长的值可以分成多行。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Metadata        Version            2.0</span><br><span class="line">Metadata        Robot Framework    http://robotframework.org</span><br><span class="line">Metadata        Platform           $&#123;PLATFORM&#125;</span><br><span class="line">Metadata        Longer Value</span><br><span class="line">...             Longer metadata values can be split into multiple</span><br><span class="line">...             rows. Also *simple* _formatting_ is supported.</span><br></pre></td></tr></table></figure></div>

<p>可以使用<code>--metadata</code>选项从命令行设置顶级套件的自由元数据。</p>
<h4 id="套件设置和拆解"><a href="#套件设置和拆解" class="headerlink" title="套件设置和拆解"></a>套件设置和拆解</h4><p>不仅测试用例，而且测试套件也可以有一个设置和一个拆解。套件设置在运行任何套件的测试用例或子测试套件之前执行，套件拆解在它们之后执行。所有的测试套件都可以有一个设置和一个拆解；对于从目录创建的套件，它们必须在套件初始化文件中指定。</p>
<p>与测试用例类似，套件设置和拆解是可能带有参数的关键字。它们在设置部分中使用<code>Suite Setup</code>和<code>Suite Teardown</code>设置定义，分别。关键字名称和可能的参数位于设置名称后的列中。</p>
<p>如果套件设置失败，那么它和其子测试套件中的所有测试用例都会立即被分配一个失败状态，并且它们实际上不会被执行。这使得套件设置成为在可能运行测试用例之前必须满足的预条件的理想选择。</p>
<p>套件拆解通常用于在所有测试用例执行完毕后进行清理。即使同一套件的设置失败，它也会被执行。如果套件拆解失败，那么套件中的所有测试用例都会被标记为失败，无论它们的原始执行状态如何。注意，即使其中一个失败，套件拆解中的所有关键字也会被执行。</p>
<p>作为设置或拆解执行的关键字的名称可以是一个变量。这通过从命令行给出关键字名称作为变量，便于在不同环境中有不同的设置或拆解。</p>
<h3 id="使用测试库"><a href="#使用测试库" class="headerlink" title="使用测试库"></a>使用测试库</h3><p>测试库包含那些最低级别的关键字，通常被称为库关键字，它们实际上与被测试的系统进行交互。所有的测试用例总是使用来自某个库的关键字，通常通过高级用户关键字。本节解释如何使用测试库以及如何使用它们提供的关键字。创建测试库在另一节中描述。</p>
<h4 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h4><p>测试库通常使用<code>Library</code>设置导入，但也可以使用<code>Import Library</code>关键字。</p>
<h5 id="使用Library设置"><a href="#使用Library设置" class="headerlink" title="使用Library设置"></a>使用<code>Library</code>设置</h5><p>测试库通常使用设置部分中的<code>Library</code>设置导入，并在后续列中有库名称。与大多数其他数据不同，库名称既区分大小写又区分空格。如果库在一个包中，必须使用包括包名在内的全名。</p>
<p>在那些库需要参数的情况下，它们列在库名称后的列中。在测试库导入中可以像关键字的参数一样使用默认值、可变数量的参数和命名参数。库名称和参数都可以使用变量设置。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    OperatingSystem</span><br><span class="line">Library    my.package.TestLibrary</span><br><span class="line">Library    MyLibrary    arg1    arg2</span><br><span class="line">Library    $&#123;LIBRARY&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以在套件文件、资源文件和套件初始化文件中导入测试库。在所有这些情况下，导入的库中的所有关键字都在该文件中可用。对于资源文件，这些关键字也在使用它们的其他文件中可用。</p>
<h5 id="使用Import-Library关键字"><a href="#使用Import-Library关键字" class="headerlink" title="使用Import Library关键字"></a>使用<code>Import Library</code>关键字</h5><p>另一种使用测试库的可能性是使用<code>BuiltIn</code>库中的关键字<code>Import Library</code>。这个关键字接受库名称和可能的参数，就像<code>Library</code>设置一样。导入的库中的关键字在使用<code>Import Library</code>关键字的测试套件中可用。这种方法在库在测试执行开始时不可用，只有其他一些关键字使其可用的情况下很有用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Do Something</span><br><span class="line">    Import Library    MyLibrary    arg1    arg2</span><br><span class="line">    KW From MyLibrary</span><br></pre></td></tr></table></figure></div>

<h4 id="指定要导入的库"><a href="#指定要导入的库" class="headerlink" title="指定要导入的库"></a>指定要导入的库</h4><p>要导入的库可以通过使用库名称或库路径来指定。无论是使用<code>Library</code>设置还是<code>Import Library</code>关键字导入库，这些方法的工作方式都是相同的。</p>
<h5 id="使用库名称"><a href="#使用库名称" class="headerlink" title="使用库名称"></a>使用库名称</h5><p>指定要导入的测试库的最常见方法是使用其名称，就像本节中的所有示例所做的那样。在这些情况下，Robot Framework试图从模块搜索路径中找到实现库的类或模块。以某种方式安装的库应该自动在模块搜索路径中，但对于其他库，可能需要单独配置搜索路径。</p>
<p>这种方法的最大好处是，当配置了模块搜索路径（通常使用自定义的启动脚本）后，普通用户不需要考虑库实际上安装在哪里。缺点是，将自己的（可能非常简单的）库放入搜索路径可能需要一些额外的配置。</p>
<h5 id="使用库的物理路径"><a href="#使用库的物理路径" class="headerlink" title="使用库的物理路径"></a>使用库的物理路径</h5><p>指定要导入的库的另一种机制是使用文件系统中的路径。这个路径被认为是相对于当前测试数据文件所在的目录的，就像资源和变量文件的路径一样。这种方法的主要好处是不需要配置模块搜索路径。</p>
<p>如果库是一个文件，那么它的路径必须包含扩展名，即.py。如果库是作为目录实现的，那么如果路径是相对的，它的路径必须有一个尾随的正斜杠（&#x2F;）。对于绝对路径，尾随的斜杠是可选的。以下示例演示了这些不同的用法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    PythonLibrary.py</span><br><span class="line">Library    relative/path/PythonDirLib/    possible    arguments</span><br><span class="line">Library    $&#123;RESOURCES&#125;/Example.class</span><br></pre></td></tr></table></figure></div>

<p>这种方法的一个限制是，作为Python类实现的库必须在与类同名的模块中。</p>
<h4 id="设置库的自定义名称"><a href="#设置库的自定义名称" class="headerlink" title="设置库的自定义名称"></a>设置库的自定义名称</h4><p>库名称在关键字名称之前显示在测试日志中，如果多个关键字有相同的名称，它们必须使用关键字名称前缀为库名称。库名称通常从实现它的模块或类名称中获取，但在某些情况下，更改它是可取的：</p>
<ul>
<li>需要多次导入相同的库，但参数不同。否则这是不可能的。</li>
<li>库名称过长不便。</li>
<li>希望使用变量在不同的环境中导入不同的库，但用相同的名称引用它们。</li>
<li>库名称误导或其他贫穷。在这种情况下，更改实际名称当然是更好的解决方案。</li>
</ul>
<p>指定新名称的基本语法是在库名称后面有文本<code>AS</code>（区分大小写），然后在其后面有新名称。指定的名称显示在日志中，并且在使用关键字的全名（<code>LibraryName.Keyword Name</code>）时必须在测试数据中使用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    packagename.TestLib    AS    TestLib</span><br><span class="line">Library    $&#123;LIBRARY&#125;    AS    MyName</span><br></pre></td></tr></table></figure></div>

<p>库的可能参数放在原始库名称和<code>AS</code>标记之间。以下示例说明了如何使用不同的参数多次导入相同的库：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    SomeLibrary    localhost        1234    AS    LocalLib</span><br><span class="line">Library    SomeLibrary    server.domain    8080    AS    RemoteLib</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    LocalLib.Some Keyword     some arg       second arg</span><br><span class="line">    RemoteLib.Some Keyword    another arg    whatever</span><br><span class="line">    LocalLib.Another Keyword</span><br></pre></td></tr></table></figure></div>

<p>在设置部分导入库和使用<code>Import Library</code>关键字时，都可以为测试库设置自定义名称。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 6.0之前，给库指定自定义名称时使用的标记是<code>WITH NAME</code>，而不是<code>AS</code>。旧的语法继续工作，但它被认为是已弃用的，最终将被删除。</p>

    </div>
  </div>

<h4 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h4><p>有些测试库是与Robot Framework一起分发的，这些库被称为标准库。<code>BuiltIn</code>库是特殊的，因为它是自动使用的，因此它的关键字总是可用的。其他标准库需要像任何其他库一样导入，但是不需要安装它们。</p>
<h5 id="普通标准库"><a href="#普通标准库" class="headerlink" title="普通标准库"></a>普通标准库</h5><p>下面列出了可用的普通标准库，并附有链接到它们的文档：</p>
<ul>
<li>BuiltIn</li>
<li>Collections</li>
<li>DateTime</li>
<li>Dialogs</li>
<li>OperatingSystem</li>
<li>Process</li>
<li>Screenshot</li>
<li>String</li>
<li>Telnet</li>
<li>XML</li>
</ul>
<h5 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h5><p>除了上面列出的普通标准库，还有一个远程库，它与其他标准库完全不同。它本身没有任何关键字，但它作为Robot Framework和实际测试库实现之间的代理。这些库可以在核心框架之外的其他机器上运行，甚至可以使用Robot Framework原生不支持的语言实现。</p>
<p>有关此概念的更多信息，请参阅单独的远程库接口部分。</p>
<h4 id="外部库"><a href="#外部库" class="headerlink" title="外部库"></a>外部库</h4><p>任何不是标准库的测试库，按定义，都是外部库。Robot Framework的开源社区已经实现了几个通用库，如<code>SeleniumLibrary</code>和<code>SwingLibrary</code>，这些库没有与核心框架一起打包。可以从 <a class="link"   target="_blank" rel="noopener" href="http://robotframework.org/" >http://robotframework.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 找到公开可用的库列表。</p>
<p>显然，使用Robot Framework的团队也可以实现通用和自定义库。有关该主题的更多信息，请参阅创建测试库部分。</p>
<p>不同的外部库可能有完全不同的安装和使用机制。有时，它们可能还需要单独安装一些其他依赖项。所有的库都应该有清晰的安装和使用文档，最好能自动化安装过程。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>变量是Robot Framework的一个重要特性，它们可以在测试数据的大多数地方使用。最常见的是在测试用例和关键字部分的关键字参数中使用，但所有设置也允许在其值中使用变量。普通的关键字名称不能用变量指定，但可以使用<code>BuiltIn</code>关键字<code>Run Keyword</code>来达到同样的效果。</p>
<p>Robot Framework有自己的变量，可以分别使用语法<code>$&#123;SCALAR&#125;</code>、<code>@&#123;LIST&#125;</code>和<code>&amp;&#123;DICT&#125;</code>作为标量、列表或字典使用。除此之外，还可以直接使用语法<code>%&#123;ENV_VAR&#125;</code>使用环境变量。</p>
<p>变量在以下情况下很有用：</p>
<ul>
<li>当测试数据中的字符串经常变化时。使用变量，只需要在一个地方做这些更改。</li>
<li>当创建系统独立和操作系统独立的测试数据时。使用变量而不是硬编码的字符串可以大大简化这个过程（例如，使用<code>$&#123;RESOURCES&#125;</code>代替<code>c:\resources</code>，或者使用<code>$&#123;HOST&#125;</code>代替<code>10.0.0.1:8080</code>）。因为变量可以在启动测试时从命令行设置，所以更改系统特定的变量很容易（例如，<code>--variable HOST:10.0.0.2:1234 --variable RESOURCES:/opt/resources</code>）。这也有助于本地化测试，这通常涉及使用不同的字符串运行相同的测试。</li>
<li>当需要将除字符串以外的对象作为关键字的参数时。没有变量，这是不可能的。</li>
<li>当不同的关键字，甚至在不同的测试库中，需要通信时。可以将一个关键字的返回值分配给一个变量，并将它作为另一个的参数传递。</li>
<li>当测试数据中的值很长或者复杂时。例如，<code>$&#123;URL&#125;</code>比<code>http://long.domain.name:8080/path/to/service?foo=1&amp;bar=2&amp;zap=42</code>短。</li>
<li>如果在测试数据中使用了不存在的变量，使用它的关键字会失败。如果需要将用于变量的相同语法作为字面字符串，必须使用反斜杠转义，如<code>\$&#123;NAME&#125;</code>。</li>
</ul>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>本节解释如何使用变量，包括常规标量变量语法<code>$&#123;var&#125;</code>，如何在列表和字典上下文中使用变量，如<code>@&#123;var&#125;</code>和<code>&amp;&#123;var&#125;</code>，以及如何使用环境变量，如<code>%&#123;var&#125;</code>。后续部分将讨论创建变量的不同方式。</p>
<p>Robot Framework的变量，类似于关键字，是不区分大小写的，而且也忽略空格和下划线。然而，建议使用大写字母表示全局变量（例如，<code>$&#123;PATH&#125;</code>或<code>$&#123;TWO WORDS&#125;</code>），使用小写字母表示只在某些测试用例或用户关键字中可用的局部变量（例如，<code>$&#123;my var&#125;</code>）。更重要的是，应该一致地使用大小写。</p>
<p>变量名由变量类型标识符（$，@，&amp;，%），花括号（{，}）和花括号之间的实际变量名组成。与使用类似变量语法的某些编程语言不同，花括号总是必需的。变量名基本上可以在花括号之间有任何字符。然而，建议只使用从a到z的字母、数字、下划线和空格，这甚至是使用扩展变量语法的要求。</p>
<h5 id="标量变量语法"><a href="#标量变量语法" class="headerlink" title="标量变量语法"></a>标量变量语法</h5><p>在Robot Framework测试数据中使用变量的最常见方式是使用标量变量语法，如<code>$&#123;var&#125;</code>。当使用这种语法时，变量名被其值替换。大多数时候，变量值是字符串，但变量可以包含任何对象，包括数字、列表、字典，甚至自定义对象。</p>
<p>下面的例子说明了标量变量的使用。假设变量<code>$&#123;GREET&#125;</code>和<code>$&#123;NAME&#125;</code>可用，并分别赋值为字符串Hello和world，那么下面的示例测试用例是等价的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Constants</span><br><span class="line">    Log    Hello</span><br><span class="line">    Log    Hello, world!!</span><br><span class="line"></span><br><span class="line">Variables</span><br><span class="line">    Log    $&#123;GREET&#125;</span><br><span class="line">    Log    $&#123;GREET&#125;, $&#123;NAME&#125;!!</span><br></pre></td></tr></table></figure></div>

<p>当一个标量变量单独使用，没有其他文本或变量围绕它，就像上面的<code>$&#123;GREET&#125;</code>，变量被其值替换，值可以是任何对象。如果变量不是单独使用，就像上面的<code>$&#123;GREER&#125;, $&#123;NAME&#125;!!</code>，它的值首先被转换为字符串，然后与其他数据连接。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>当使用命名参数语法向关键字传递参数时，也会按原样使用变量值，如<code>argname=${var}</code>。</p>

    </div>
  </div>

<p>下面的例子演示了变量单独使用和与其他内容一起使用的区别。首先，假设有一个变量<code>$&#123;STR&#125;</code>设置为字符串Hello, world!和<code>$&#123;OBJ&#125;</code>设置为以下Python对象的实例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObj</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hi, terra!&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>设置了这两个变量后，有以下测试数据：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Objects</span><br><span class="line">    KW 1    $&#123;STR&#125;</span><br><span class="line">    KW 2    $&#123;OBJ&#125;</span><br><span class="line">    KW 3    I said &quot;$&#123;STR&#125;&quot;</span><br><span class="line">    KW 4    You said &quot;$&#123;OBJ&#125;&quot;</span><br></pre></td></tr></table></figure></div>

<p>最后，当执行这个测试数据时，不同的关键字接收到的参数如下所示：</p>
<ul>
<li>KW 1得到一个字符串Hello, world!</li>
<li>KW 2得到存储在变量<code>$&#123;OBJ&#125;</code>中的对象</li>
<li>KW 3得到一个字符串I said “Hello, world!”</li>
<li>KW 4得到一个字符串You said “Hi, terra!”</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果变量不能表示为Unicode，那么将变量转换为Unicode显然会失败。例如，如果试图使用字节序列作为关键字的参数，那么将值连接在一起，如<code>${byte1}${byte2}</code>。一个解决方法是创建一个包含整个值的变量，并在单元格中单独使用它（例如，<code>${bytes}</code>），因为这样值就会按原样使用。</p>

    </div>
  </div>

<h5 id="列表变量语法"><a href="#列表变量语法" class="headerlink" title="列表变量语法"></a>列表变量语法</h5><p>当一个变量像<code>$&#123;EXAMPLE&#125;</code>那样作为标量使用时，它的值会被原样使用。如果一个变量的值是一个列表或类似列表，那么也可以像<code>@&#123;EXAMPLE&#125;</code>那样将它作为一个列表变量使用。在这种情况下，列表会被展开，单个项会作为单独的参数传入。这最容易通过一个例子来解释。假设一个变量<code>@&#123;USER&#125;</code>的值是<code>[&#39;robot&#39;, &#39;secret&#39;]</code>，那么下面的两个测试用例是等价的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Constants</span><br><span class="line">    Login    robot    secret</span><br><span class="line"></span><br><span class="line">List Variable</span><br><span class="line">    Login    @&#123;USER&#125;</span><br></pre></td></tr></table></figure></div>

<p>Robot Framework将其自己的变量存储在一个内部存储中，并允许将它们作为标量、列表或字典使用。将一个变量作为列表使用需要它的值是一个Python列表或类似列表的对象。Robot Framework不允许将字符串用作列表，但接受其他可迭代的对象，如元组或字典。</p>
<p>从Robot Framework 4.0开始，可以将列表扩展与列表项访问结合使用，使得以下用法成为可能：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Nested container</span><br><span class="line">    $&#123;nested&#125; =    Evaluate    [[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#123;&#x27;key&#x27;: [&#x27;x&#x27;, &#x27;y&#x27;]&#125;]</span><br><span class="line">    Log Many    @&#123;nested&#125;[0]         # Logs &#x27;a&#x27;, &#x27;b&#x27; and &#x27;c&#x27;.</span><br><span class="line">    Log Many    @&#123;nested&#125;[1][key]    # Logs &#x27;x&#x27; and &#x27;y&#x27;.</span><br><span class="line"></span><br><span class="line">Slice</span><br><span class="line">    $&#123;items&#125; =    Create List    first    second    third</span><br><span class="line">    Log Many    @&#123;items&#125;[1:]         # Logs &#x27;second&#x27; and  &#x27;third&#x27;.</span><br></pre></td></tr></table></figure></div>

<h6 id="使用列表变量与其他数据"><a href="#使用列表变量与其他数据" class="headerlink" title="使用列表变量与其他数据"></a>使用列表变量与其他数据</h6><p>可以将列表变量与其他参数一起使用，包括其他列表变量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Keyword    @&#123;LIST&#125;    more    args</span><br><span class="line">    Keyword    $&#123;SCALAR&#125;    @&#123;LIST&#125;    constant</span><br><span class="line">    Keyword    @&#123;LIST&#125;    @&#123;ANOTHER&#125;    @&#123;ONE MORE&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="使用列表变量与设置"><a href="#使用列表变量与设置" class="headerlink" title="使用列表变量与设置"></a>使用列表变量与设置</h6><p>列表变量只能与一些设置一起使用。它们可以用作导入的库和变量文件的参数，但库和变量文件的名称本身不能是列表变量。也可以在设置和拆解中使用列表变量作为关键字的参数，但不能用作关键字的名称。对于与标签相关的设置，它们可以自由地使用。在不支持列表变量的地方，可以使用标量变量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library         ExampleLibrary      @&#123;LIB ARGS&#125;    # This works</span><br><span class="line">Library         $&#123;LIBRARY&#125;          @&#123;LIB ARGS&#125;    # This works</span><br><span class="line">Library         @&#123;LIBRARY AND ARGS&#125;                # This does not work</span><br><span class="line">Suite Setup     Some Keyword        @&#123;KW ARGS&#125;     # This works</span><br><span class="line">Suite Setup     $&#123;KEYWORD&#125;          @&#123;KW ARGS&#125;     # This works</span><br><span class="line">Suite Setup     @&#123;KEYWORD AND ARGS&#125;                # This does not work</span><br><span class="line">Default Tags    @&#123;TAGS&#125;                            # This works</span><br></pre></td></tr></table></figure></div>

<h5 id="字典变量语法"><a href="#字典变量语法" class="headerlink" title="字典变量语法"></a>字典变量语法</h5><p>如上所述，包含列表的变量可以作为列表变量使用，将列表项作为单独的参数传递给关键字。类似地，包含Python字典或类似字典的对象的变量可以像<code>&amp;&#123;EXAMPLE&#125;</code>那样作为字典变量使用。实际上，这意味着字典被展开，单个项作为命名参数传递给关键字。假设一个变量<code>&amp;&#123;USER&#125;</code>的值是<code>&#123;&#39;name&#39;: &#39;robot&#39;, &#39;password&#39;: &#39;secret&#39;&#125;</code>，那么下面的两个测试用例是等价的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Constants</span><br><span class="line">    Login    name=robot    password=secret</span><br><span class="line"></span><br><span class="line">Dict Variable</span><br><span class="line">    Login    &amp;&#123;USER&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>从Robot Framework 4.0开始，可以将字典扩展与字典项访问结合使用，使得像<code>&amp;{nested}[key]</code>这样的用法成为可能。</p>

    </div>
  </div>

<h6 id="使用字典变量与其他数据"><a href="#使用字典变量与其他数据" class="headerlink" title="使用字典变量与其他数据"></a>使用字典变量与其他数据</h6><p>可以将字典变量与其他参数一起使用，包括其他字典变量。因为命名参数语法要求位置参数在命名参数之前，所以字典只能跟在命名参数或其他字典后面。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Keyword    &amp;&#123;DICT&#125;    named=arg</span><br><span class="line">    Keyword    positional    @&#123;LIST&#125;    &amp;&#123;DICT&#125;</span><br><span class="line">    Keyword    &amp;&#123;DICT&#125;    &amp;&#123;ANOTHER&#125;    &amp;&#123;ONE MORE&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="使用字典变量与设置"><a href="#使用字典变量与设置" class="headerlink" title="使用字典变量与设置"></a>使用字典变量与设置</h6><p>字典变量通常不能与设置一起使用。唯一的例外是导入、设置和拆解，其中字典可以作为参数使用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library        ExampleLibrary    &amp;&#123;LIB ARGS&#125;</span><br><span class="line">Suite Setup    Some Keyword      &amp;&#123;KW ARGS&#125;     named=arg</span><br></pre></td></tr></table></figure></div>

<h6 id="访问列表和字典项"><a href="#访问列表和字典项" class="headerlink" title="访问列表和字典项"></a>访问列表和字典项</h6><p>可以使用特殊语法<code>$&#123;var&#125;[item]</code>或<code>$&#123;var&#125;[nested][item]</code>访问可下标的变量（例如，列表和字典）的项。从Robot Framework 4.0开始，也可以通过使用语法<code>@&#123;var&#125;[item]</code>和<code>&amp;&#123;var&#125;[item]</code>将项访问与列表扩展和字典扩展一起使用。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 3.1之前，正常的项访问语法是列表的<code>@{var}[item]</code>和字典的<code>&amp;{var}[item]</code>。Robot Framework 3.1引入了通用的<code>${var}[item]</code>语法以及一些其他的好的增强，旧的项访问语法在Robot Framework 3.2中被弃用。</p>

    </div>
  </div>

<h6 id="访问序列项"><a href="#访问序列项" class="headerlink" title="访问序列项"></a>访问序列项</h6><p>可以使用语法<code>$&#123;var&#125;[index]</code>访问包含序列（例如，列表、字符串或字节）的变量的某个项，其中<code>index</code>是所选值的索引。索引从零开始，可以使用负索引从末尾访问项，尝试访问索引过大的项会导致错误。索引会自动转换为整数，也可以使用变量作为索引。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Positive index</span><br><span class="line">    Login    $&#123;USER&#125;[0]    $&#123;USER&#125;[1]</span><br><span class="line">    Title Should Be    Welcome $&#123;USER&#125;[0]!</span><br><span class="line"></span><br><span class="line">Negative index</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[-1]</span><br><span class="line"></span><br><span class="line">Index defined as variable</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[$&#123;INDEX&#125;]</span><br></pre></td></tr></table></figure></div>

<p>序列项访问也支持Python的相同的”切片”功能，语法如<code>$&#123;var&#125;[1:]</code>。使用这种语法，不会得到一个单独的项，而是得到原始序列的一个切片。与Python一样，可以指定开始索引、结束索引和步长：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Start index</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[1:]</span><br><span class="line"></span><br><span class="line">End index</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[:4]</span><br><span class="line"></span><br><span class="line">Start and end</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[2:-1]</span><br><span class="line"></span><br><span class="line">Step</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[::2]</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[1:-1:10]</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>切片语法在Robot Framework 3.1中是新的。它在Robot Framework 4.0中被扩展，可以与列表扩展像<code>@{var}[1:]</code>这样一起工作。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 3.2之前，只有包含列表、元组或其他被认为是类似列表的对象的变量支持项和切片访问。现在，所有的序列，包括字符串和字节，都被支持。</p>

    </div>
  </div>

<h6 id="访问单个字典项"><a href="#访问单个字典项" class="headerlink" title="访问单个字典项"></a>访问单个字典项</h6><p>可以使用语法<code>$&#123;NAME&#125;[key]</code>访问字典变量的某个值，其中<code>key</code>是所选值的名称。键被认为是字符串，但非字符串键可以作为变量使用。以这种方式访问的字典值可以像标量变量一样使用。</p>
<p>如果一个键是一个字符串，也可以使用属性访问语法<code>$&#123;NAME.key&#125;</code>访问它的值。有关此语法的更多详细信息，请参阅创建字典变量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Dictionary variable item</span><br><span class="line">    Login    $&#123;USER&#125;[name]    $&#123;USER&#125;[password]</span><br><span class="line">    Title Should Be    Welcome $&#123;USER&#125;[name]!</span><br><span class="line"></span><br><span class="line">Key defined as variable</span><br><span class="line">    Log Many    $&#123;DICT&#125;[$&#123;KEY&#125;]    $&#123;DICT&#125;[$&#123;42&#125;]</span><br><span class="line"></span><br><span class="line">Attribute access</span><br><span class="line">    Login    $&#123;USER.name&#125;    $&#123;USER.password&#125;</span><br><span class="line">    Title Should Be    Welcome $&#123;USER.name&#125;!</span><br></pre></td></tr></table></figure></div>

<h6 id="嵌套项访问"><a href="#嵌套项访问" class="headerlink" title="嵌套项访问"></a>嵌套项访问</h6><p>也可以使用相同的项访问语法<code>$&#123;var&#125;[item1][item2]</code>访问嵌套的可下标变量。这在处理经常由REST服务返回的JSON数据时特别有用。例如，如果一个变量<code>$&#123;DATA&#125;</code>包含<code>[&#123;&#39;id&#39;: 1, &#39;name&#39;: &#39;Robot&#39;&#125;, &#123;&#39;id&#39;: 2, &#39;name&#39;: &#39;Mr. X&#39;&#125;]</code>，这个测试将通过：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Nested item access</span><br><span class="line">    Should Be Equal    $&#123;DATA&#125;[0][name]    Robot</span><br><span class="line">    Should Be Equal    $&#123;DATA&#125;[1][id]      $&#123;2&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>Robot Framework允许在测试数据中使用环境变量，语法为<code>%&#123;ENV_VAR_NAME&#125;</code>。它们限制为字符串值。可以通过将变量名和默认值用等号分隔，如<code>%&#123;ENV_VAR_NAME=default value&#125;</code>，来指定一个默认值，如果环境变量不存在，则使用该默认值。</p>
<p>在测试执行之前在操作系统中设置的环境变量在执行期间是可用的，可以使用<code>OperatingSystem</code>库中的关键字<code>Set Environment Variable</code>创建新的环境变量，或者使用关键字<code>Delete Environment Variable</code>删除现有的环境变量。因为环境变量是全局的，所以在一个测试用例中设置的环境变量可以在执行后的其他测试用例中使用。然而，对环境变量的更改在测试执行后不会生效。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Environment variables</span><br><span class="line">    Log    Current user: %&#123;USER&#125;</span><br><span class="line">    Run    %&#123;JAVA_HOME&#125;$&#123;/&#125;javac</span><br><span class="line"></span><br><span class="line">Environment variables with defaults</span><br><span class="line">    Set port    %&#123;APPLICATION_PORT=8080&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 3.2中，新增了指定默认值的支持。</p>

    </div>
  </div>

<h5 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h5><p>变量可以从不同的来源产生。</p>
<h6 id="变量部分"><a href="#变量部分" class="headerlink" title="变量部分"></a>变量部分</h6><p>变量最常见的来源是套件文件和资源文件中的变量部分。变量部分很方便，因为它们允许在与其他测试数据相同的地方创建变量，而且所需的语法非常简单。它们的主要缺点是值总是字符串，而且不能动态创建。如果这两者中的任何一个是问题，可以使用变量文件代替。</p>
<h6 id="创建标量变量"><a href="#创建标量变量" class="headerlink" title="创建标量变量"></a>创建标量变量</h6><p>最简单的变量赋值就是将一个字符串设置为一个标量变量。这是通过在变量部分的第一列给出变量名（包括<code>$&#123;&#125;</code>），在第二列给出值来完成的。如果第二列为空，则设置一个空字符串作为值。也可以在值中使用已定义的变量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;NAME&#125;         Robot Framework</span><br><span class="line">$&#123;VERSION&#125;      2.0</span><br><span class="line">$&#123;ROBOT&#125;        $&#123;NAME&#125; $&#123;VERSION&#125;</span><br></pre></td></tr></table></figure></div>

<p>也可以（但不是必须）在变量名后面使用等号<code>=</code>，使变量赋值稍微明确一些。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;NAME&#125; =       Robot Framework</span><br><span class="line">$&#123;VERSION&#125; =    2.0</span><br></pre></td></tr></table></figure></div>

<p>如果一个标量变量有一个长值，可以使用<code>...</code>语法将它分割成多行。默认情况下，行是用一个空格连接在一起的，但是可以通过在最后一个值后面使用一个分隔符配置选项来改变这一点：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;EXAMPLE&#125;      This value is joined</span><br><span class="line">...             together with a space.</span><br><span class="line">$&#123;MULTILINE&#125;    First line.</span><br><span class="line">...             Second line.</span><br><span class="line">...             Third line.</span><br><span class="line">...             separator=\n</span><br></pre></td></tr></table></figure></div>

<p>分隔符选项在Robot Framework 7.0中是新的，但也支持旧版本的分隔符配置。在它们中，第一个值可以包含一个特殊的<code>SEPARATOR</code>标记：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;MULTILINE&#125;    SEPARATOR=\n</span><br><span class="line">...             First line.</span><br><span class="line">...             Second line.</span><br><span class="line">...             Third line.</span><br></pre></td></tr></table></figure></div>

<p>分隔符选项和<code>SEPARATOR</code>标记都是区分大小写的。建议使用分隔符选项，除非需要支持旧版本。</p>
<h6 id="创建列表变量"><a href="#创建列表变量" class="headerlink" title="创建列表变量"></a>创建列表变量</h6><p>创建列表变量和创建标量变量一样容易。同样，变量名在变量部分的第一列，值在后续的列中。一个列表变量可以有任意数量的值，从零开始，如果需要多个值，它们可以分割成几行。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">@&#123;NAMES&#125;        Matti       Teppo</span><br><span class="line">@&#123;NAMES2&#125;       @&#123;NAMES&#125;    Seppo</span><br><span class="line">@&#123;NOTHING&#125;</span><br><span class="line">@&#123;MANY&#125;         one         two      three      four</span><br><span class="line">...             five        six      seven</span><br></pre></td></tr></table></figure></div>

<h6 id="创建字典变量"><a href="#创建字典变量" class="headerlink" title="创建字典变量"></a>创建字典变量</h6><p>在变量部分创建字典变量与创建列表变量类似。区别在于，项需要使用<code>name=value</code>语法或现有的字典变量创建。如果有多个具有相同名称的项，最后一个值具有优先权。如果名称包含一个字面等号，可以使用反斜杠<code>\=</code>进行转义。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">&amp;&#123;USER 1&#125;       name=Matti    address=xxx         phone=123</span><br><span class="line">&amp;&#123;USER 2&#125;       name=Teppo    address=yyy         phone=456</span><br><span class="line">&amp;&#123;MANY&#125;         first=1       second=$&#123;2&#125;         $&#123;3&#125;=third</span><br><span class="line">&amp;&#123;EVEN MORE&#125;    &amp;&#123;MANY&#125;       first=override      empty=</span><br><span class="line">...             =empty        key\=here=value</span><br></pre></td></tr></table></figure></div>

<p>字典变量与普通Python字典相比有两个额外的属性。首先，这些字典的值可以像属性一样访问，这意味着可以使用扩展变量语法，如<code>$&#123;VAR.key&#125;</code>。这只有在键是一个有效的属性名称，并且不匹配Python字典有的任何正常属性时才有效。例如，单个值<code>&amp;&#123;USER&#125;[name]</code>也可以像<code>$&#123;USER.name&#125;</code>（注意在这种情况下需要<code>$</code>）那样访问，但是使用<code>$&#123;MANY.3&#125;</code>是不可能的。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>对于嵌套的字典变量，键可以像<code>${VAR.nested.key}</code>那样访问。这简化了处理嵌套数据结构的工作。</p>

    </div>
  </div>

<p>字典变量的另一个特殊属性是它们是有序的。这意味着，如果遍历这些字典，它们的项总是按照它们定义的顺序出现。如果字典被用作列表变量与FOR循环或其他方式一起使用，这可能很有用。当一个字典被用作一个列表变量时，实际的值包含字典键。例如，<code>@&#123;MANY&#125;</code>变量将具有值<code>[&#39;first&#39;, &#39;second&#39;, 3]</code>。</p>
<h6 id="基于另一个变量创建变量名"><a href="#基于另一个变量创建变量名" class="headerlink" title="基于另一个变量创建变量名"></a>基于另一个变量创建变量名</h6><p>从Robot Framework 7.0开始，可以根据另一个变量动态创建变量名：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;X&#125;        Y</span><br><span class="line">$&#123;$&#123;X&#125;&#125;     Z    # Name is created based on &#x27;$&#123;X&#125;&#x27;.</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Dynamically created name</span><br><span class="line">    Should Be Equal    $&#123;Y&#125;    Z</span><br></pre></td></tr></table></figure></div>

<h4 id="变量文件"><a href="#变量文件" class="headerlink" title="变量文件"></a>变量文件</h4><p>变量文件是创建不同类型变量的最强大的机制。使用它们，可以将变量赋值给任何对象，并且它们还支持动态创建变量。变量文件的语法和如何使用变量文件在资源和变量文件部分有解释。</p>
<h5 id="在命令行中设置变量"><a href="#在命令行中设置变量" class="headerlink" title="在命令行中设置变量"></a>在命令行中设置变量</h5><p>可以在命令行中单独使用<code>--variable</code>（-v）选项或使用变量文件与<code>--variablefile</code>（-V）选项来设置变量。从命令行设置的变量对所有执行的测试数据文件全局可用，并且它们还会覆盖变量部分和测试数据中导入的变量文件中具有相同名称的可能变量。</p>
<p>设置单个变量的语法是<code>--variable name:value</code>，其中<code>name</code>是变量的名称（不包括<code>$&#123;&#125;</code>），<code>value</code>是它的值。可以通过多次使用此选项来设置多个变量。只有标量变量可以使用此语法设置，它们只能获取字符串值。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--variable EXAMPLE:value</span><br><span class="line">--variable HOST:localhost:7272 --variable USER:robot</span><br></pre></td></tr></table></figure></div>

<p>在上面的例子中，设置了变量，使得</p>
<ul>
<li><code>$&#123;EXAMPLE&#125;</code>得到值<code>value</code></li>
<li><code>$&#123;HOST&#125;</code>和<code>$&#123;USER&#125;</code>得到值<code>localhost:7272</code>和<code>robot</code></li>
</ul>
<p>从命令行使用变量文件的基本语法是<code>--variablefile path/to/variables.py</code>，在使用变量文件部分有更多的细节。实际创建的变量取决于引用的变量文件中有哪些变量。</p>
<p>如果从命令行给出了变量文件和单个变量，那么后者具有更高的优先级。</p>
<h4 id="关键字的返回值"><a href="#关键字的返回值" class="headerlink" title="关键字的返回值"></a>关键字的返回值</h4><p>关键字的返回值也可以设置为变量。这允许在不同的测试库中的不同关键字之间进行通信。</p>
<p>以这种方式设置的变量与其他任何变量在其他方面是相似的，但它们只在创建它们的局部范围内可用。因此，例如，不可能在一个测试用例中设置一个变量，然后在另一个测试用例中使用它。这是因为，一般来说，自动化测试用例不应该相互依赖，而且意外地设置一个在其他地方使用的变量可能会导致难以调试的错误。如果真正需要在一个测试用例中设置一个变量，并在另一个测试用例中使用它，可以使用<code>BuiltIn</code>关键字，如下一节所解释的。</p>
<h5 id="分配标量变量"><a href="#分配标量变量" class="headerlink" title="分配标量变量"></a>分配标量变量</h5><p>任何由关键字返回的值都可以分配给一个标量变量。如下例所示，所需的语法非常简单：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Returning</span><br><span class="line">    $&#123;x&#125; =    Get X    an argument</span><br><span class="line">    Log    We got $&#123;x&#125;!</span><br></pre></td></tr></table></figure></div>

<p>在上述例子中，<code>Get X</code>关键字返回的值首先被设置到变量<code>$&#123;x&#125;</code>中，然后被<code>Log</code>关键字使用。在变量名后面有等号<code>=</code>不是必须的，但它使赋值更明确。像这样在测试用例和用户关键字级别创建局部变量都可以工作。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>虽然一个值被赋值给一个标量变量，但如果它有一个类似列表的值，它可以作为一个列表变量使用，如果它有一个类似字典的值，它可以作为一个字典变量使用。</p>

    </div>
  </div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    $&#123;list&#125; =    Create List    first    second    third</span><br><span class="line">    Length Should Be    $&#123;list&#125;    3</span><br><span class="line">    Log Many    @&#123;list&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="分配带有项值的变量"><a href="#分配带有项值的变量" class="headerlink" title="分配带有项值的变量"></a>分配带有项值的变量</h5><p>从Robot Framework 6.1开始，当使用支持项赋值的变量，如列表或字典，可以通过使用语法<code>$&#123;var&#125;[item]</code>指定项的索引或键来设置它们的值，其中<code>item</code>部分本身可以包含一个变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Item assignment to list</span><br><span class="line">    $&#123;list&#125; =          Create List      one    two    three    four</span><br><span class="line">    $&#123;list&#125;[0] =       Set Variable     first</span><br><span class="line">    $&#123;list&#125;[$&#123;1&#125;] =    Set Variable     second</span><br><span class="line">    $&#123;list&#125;[2:3] =     Evaluate         [&#x27;third&#x27;]</span><br><span class="line">    $&#123;list&#125;[-1] =      Set Variable     last</span><br><span class="line">    Log Many           @&#123;list&#125;          # Logs &#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27; and &#x27;last&#x27;</span><br><span class="line"></span><br><span class="line">Item assignment to dictionary</span><br><span class="line">    $&#123;dict&#125; =                Create Dictionary    first_name=unknown</span><br><span class="line">    $&#123;dict&#125;[first_name] =    Set Variable         John</span><br><span class="line">    $&#123;dict&#125;[last_name] =     Set Variable         Doe</span><br><span class="line">    Log                      $&#123;dictionary&#125;        # Logs &#123;&#x27;first_name&#x27;: &#x27;John&#x27;, &#x27;last_name&#x27;: &#x27;Doe&#x27;&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="基于另一个变量创建变量名-1"><a href="#基于另一个变量创建变量名-1" class="headerlink" title="基于另一个变量创建变量名"></a>基于另一个变量创建变量名</h5><p>从Robot Framework 7.0开始，可以根据另一个变量动态创建被赋值变量的名称：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Dynamically created name</span><br><span class="line">    $&#123;x&#125; =    Set Variable    y</span><br><span class="line">    $&#123;$&#123;x&#125;&#125; =    Set Variable    z    # Name is created based on &#x27;$&#123;x&#125;&#x27;.</span><br><span class="line">    Should Be Equal    $&#123;y&#125;    z</span><br></pre></td></tr></table></figure></div>

<h5 id="分配列表变量"><a href="#分配列表变量" class="headerlink" title="分配列表变量"></a>分配列表变量</h5><p>如果一个关键字返回一个列表或任何类似列表的对象，可以将其分配给一个列表变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    @&#123;list&#125; =    Create List    first    second    third</span><br><span class="line">    Length Should Be    $&#123;list&#125;    3</span><br><span class="line">    Log Many    @&#123;list&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为所有的Robot Framework变量都存储在同一个命名空间中，所以将一个值分配给一个标量变量或一个列表变量之间没有太大的区别。这可以通过比较上面的最后两个例子来看出。主要的区别是，当创建一个列表变量时，Robot Framework会自动验证该值是否是一个列表或类似列表，存储的变量值将是从返回值创建的一个新列表。当分配给一个标量变量时，返回值不会被验证，存储的值将是返回的完全相同的对象。</p>
<h5 id="分配字典变量"><a href="#分配字典变量" class="headerlink" title="分配字典变量"></a>分配字典变量</h5><p>如果一个关键字返回一个字典或任何类似字典的对象，可以将其分配给一个字典变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    &amp;&#123;dict&#125; =    Create Dictionary    first=1    second=$&#123;2&#125;    $&#123;3&#125;=third</span><br><span class="line">    Length Should Be    $&#123;dict&#125;    3</span><br><span class="line">    Do Something    &amp;&#123;dict&#125;</span><br><span class="line">    Log    $&#123;dict.first&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为所有的Robot Framework变量都存储在同一个命名空间中，也可以将一个字典分配给一个标量变量，然后在需要的时候将其作为一个字典使用。然而，显式创建一个字典变量有一些实际的好处。首先，Robot Framework验证返回的值是否是一个字典或类似字典，就像它验证列表变量只能得到一个类似列表的值一样。</p>
<p>一个更大的好处是，该值被转换为一个特殊的字典，它也在创建变量部分中创建字典变量时使用。这些字典中的值可以使用属性访问，如上例中的<code>$&#123;dict.first&#125;</code>。这些字典也是有序的，但如果原始字典不是有序的，结果的顺序是任意的。</p>
<h5 id="分配多个变量"><a href="#分配多个变量" class="headerlink" title="分配多个变量"></a>分配多个变量</h5><p>如果一个关键字返回一个列表或一个类似列表的对象，可以将单个值分配给多个标量变量或标量变量和一个列表变量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Assign multiple</span><br><span class="line">    $&#123;a&#125;    $&#123;b&#125;    $&#123;c&#125; =    Get Three</span><br><span class="line">    $&#123;first&#125;    @&#123;rest&#125; =    Get Three</span><br><span class="line">    @&#123;before&#125;    $&#123;last&#125; =    Get Three</span><br><span class="line">    $&#123;begin&#125;    @&#123;middle&#125;    $&#123;end&#125; =    Get Three</span><br></pre></td></tr></table></figure></div>

<p>假设关键字<code>Get Three</code>返回一个列表<code>[1, 2, 3]</code>，则创建以下变量：</p>
<ul>
<li><code>$&#123;a&#125;</code>、<code>$&#123;b&#125;</code>和<code>$&#123;c&#125;</code>的值分别为1、2和3。</li>
<li><code>$&#123;first&#125;</code>的值为1，<code>@&#123;rest&#125;</code>的值为<code>[2, 3]</code>。</li>
<li><code>@&#123;before&#125;</code>的值为<code>[1, 2]</code>，<code>$&#123;last&#125;</code>的值为3。</li>
<li><code>$&#123;begin&#125;</code>的值为1，<code>@&#123;middle&#125;</code>的值为<code>[2]</code>，<code>$&#123;end&#125;</code>的值为3。</li>
</ul>
<p>如果返回的列表的值多于或少于要分配的标量变量的数量，那么这是一个错误。此外，只允许一个列表变量，字典变量只能单独分配。</p>
<h5 id="自动记录分配的变量值"><a href="#自动记录分配的变量值" class="headerlink" title="自动记录分配的变量值"></a>自动记录分配的变量值</h5><p>为了更容易理解执行过程中发生了什么，分配的值的开始部分会被自动记录。默认情况下，显示前200个字符，但可以通过在运行测试时使用<code>--maxassignlength</code>命令行选项来改变这个值。如果值为零或负数，整个分配的值将被隐藏。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--maxassignlength 1000</span><br><span class="line">--maxassignlength 0</span><br></pre></td></tr></table></figure></div>

<p>不完全记录值的原因是，它可能非常大。如果总是想完全看到某个值，可以使用<code>BuiltIn Log</code>关键字在分配后记录它。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>--maxassignlength</code>选项在Robot Framework 5.0中是新的。</p>

    </div>
  </div>

<h5 id="VAR语法"><a href="#VAR语法" class="headerlink" title="VAR语法"></a>VAR语法</h5><p>从Robot Framework 7.0开始，可以使用VAR语法在测试和用户关键字内部创建变量。VAR标记是区分大小写的，必须跟着一个变量名和值。除了必须的VAR，整体语法大多与在变量部分创建变量时的语法相同。</p>
<p>新的语法旨在使创建变量更简单、更统一。它特别用于替代<code>BuiltIn</code>关键字<code>Set Variable</code>、<code>Set Test Variable</code>、<code>Set Suite Variable</code>和<code>Set Global Variable</code>，但也可以用来替代<code>Catenate</code>、<code>Create List</code>和<code>Create Dictionary</code>。</p>
<h5 id="创建标量变量-1"><a href="#创建标量变量-1" class="headerlink" title="创建标量变量"></a>创建标量变量</h5><p>在简单的情况下，通过给出一个变量名和它的值来创建标量变量。值可以是一个硬编码的字符串，也可以包含一个变量。如果值很长，可以将其分割成多个列和行。在这种情况下，默认情况下，部分会用一个空格连接在一起，但可以使用分隔符配置选项来指定要使用的分隔符。在创建基于关键字的返回值的变量和在变量部分中的变量时，变量名后面可以有一个可选的<code>=</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Scalar examples</span><br><span class="line">     VAR    $&#123;simple&#125;       variable</span><br><span class="line">     VAR    $&#123;equals&#125; =     this works too</span><br><span class="line">     VAR    $&#123;variable&#125;     value contains $&#123;simple&#125;</span><br><span class="line">     VAR    $&#123;sentence&#125;     This is a bit longer variable value</span><br><span class="line">     ...                    that is split into multiple rows.</span><br><span class="line">     ...                    These parts are joined with a space.</span><br><span class="line">     VAR    $&#123;multiline&#125;    This is another longer value.</span><br><span class="line">     ...                    This time there is a custom separator.</span><br><span class="line">     ...                    As the result this becomes a multiline string.</span><br><span class="line">     ...                    separator=\n</span><br></pre></td></tr></table></figure></div>

<h5 id="创建列表和字典变量"><a href="#创建列表和字典变量" class="headerlink" title="创建列表和字典变量"></a>创建列表和字典变量</h5><p>列表和字典变量的创建与标量变量类似。创建字典时，必须使用<code>name=value</code>语法指定项。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">List examples</span><br><span class="line">     VAR    @&#123;two items&#125;     Robot    Framework</span><br><span class="line">     VAR    @&#123;empty list&#125;</span><br><span class="line">     VAR    @&#123;lot of stuff&#125;</span><br><span class="line">     ...    first item</span><br><span class="line">     ...    second item</span><br><span class="line">     ...    third item</span><br><span class="line">     ...    fourth item</span><br><span class="line">     ...    last item</span><br><span class="line"></span><br><span class="line">Dictionary examples</span><br><span class="line">     VAR    &amp;&#123;two items&#125;     name=Robot Framework    url=http://robotframework.org</span><br><span class="line">     VAR    &amp;&#123;empty dict&#125;</span><br><span class="line">     VAR    &amp;&#123;lot of stuff&#125;</span><br><span class="line">     ...    first=1</span><br><span class="line">     ...    second=2</span><br><span class="line">     ...    third=3</span><br><span class="line">     ...    fourth=4</span><br><span class="line">     ...    last=5        </span><br></pre></td></tr></table></figure></div>

<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>使用VAR语法创建的变量只在创建它们的测试或用户关键字内部可用。然而，可以通过使用作用域配置选项来改变这一点。支持的值有LOCAL（默认）、TEST（在当前测试中可用）、TASK（TEST的别名）、SUITE（在当前套件中可用）和GLOBAL（全局可用）。尽管Robot Framework变量是不区分大小写的，但建议使用大写字母表示非局部变量名。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;SUITE&#125;         this value is overridden</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Scope example</span><br><span class="line">    VAR    $&#123;local&#125;     local value</span><br><span class="line">    VAR    $&#123;TEST&#125;      test value      scope=TEST</span><br><span class="line">    VAR    $&#123;SUITE&#125;     suite value     scope=SUITE</span><br><span class="line">    VAR    $&#123;GLOBAL&#125;    global value    scope=GLOBAL</span><br><span class="line">    Should Be Equal    $&#123;local&#125;     local value</span><br><span class="line">    Should Be Equal    $&#123;TEST&#125;      test value</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    global value</span><br><span class="line">    Keyword</span><br><span class="line">    Should Be Equal    $&#123;TEST&#125;      new test value</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     new suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    new global value</span><br><span class="line"></span><br><span class="line">Scope example, part 2</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     new suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    new global value</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Keyword</span><br><span class="line">    Should Be Equal    $&#123;TEST&#125;      test value</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    global value</span><br><span class="line">    VAR    $&#123;TEST&#125;      new $&#123;TEST&#125;      scope=TEST</span><br><span class="line">    VAR    $&#123;SUITE&#125;     new $&#123;SUITE&#125;     scope=SUITE</span><br><span class="line">    VAR    $&#123;GLOBAL&#125;    new $&#123;GLOBAL&#125;    scope=GLOBAL</span><br><span class="line">    Should Be Equal    $&#123;TEST&#125;      new test value</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     new suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    new global value</span><br></pre></td></tr></table></figure></div>

<h5 id="条件创建变量"><a href="#条件创建变量" class="headerlink" title="条件创建变量"></a>条件创建变量</h5><p>VAR语法可以与IF&#x2F;ELSE结构一起工作，这使得条件创建变量变得容易。在简单的情况下，使用内联IF可能很方便。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">IF/ELSE example</span><br><span class="line">    IF    &quot;$&#123;ENV&#125;&quot; == &quot;devel&quot;</span><br><span class="line">        VAR    $&#123;address&#125;    127.0.0.1</span><br><span class="line">        VAR    $&#123;name&#125;       demo</span><br><span class="line">    ELSE</span><br><span class="line">        VAR    $&#123;address&#125;    192.168.1.42</span><br><span class="line">        VAR    $&#123;name&#125;       robot</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Inline IF</span><br><span class="line">    IF    &quot;$&#123;ENV&#125;&quot; == &quot;devel&quot;    VAR    $&#123;name&#125;    demo    ELSE    VAR    $&#123;name&#125;    robot</span><br></pre></td></tr></table></figure></div>

<h5 id="基于另一个变量创建变量名-2"><a href="#基于另一个变量创建变量名-2" class="headerlink" title="基于另一个变量创建变量名"></a>基于另一个变量创建变量名</h5><p>如果有需要，也可以根据另一个变量动态创建变量名。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Dynamic name</span><br><span class="line">    VAR    $&#123;x&#125;       y    # Normal assignment.</span><br><span class="line">    VAR    $&#123;$&#123;x&#125;&#125;    z    # Name created dynamically.</span><br><span class="line">    Should Be Equal    $&#123;y&#125;    z</span><br></pre></td></tr></table></figure></div>

<h4 id="使用Set-Test-Suite-Global-Variable关键字"><a href="#使用Set-Test-Suite-Global-Variable关键字" class="headerlink" title="使用Set Test&#x2F;Suite&#x2F;Global Variable关键字"></a>使用Set Test&#x2F;Suite&#x2F;Global Variable关键字</h4>
  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在使用Robot Framework 7.0或更高版本时，推荐使用VAR语法而不是这些关键字。</p>

    </div>
  </div>

<p><code>BuiltIn</code>库有<code>Set Test Variable</code>、<code>Set Suite Variable</code>和<code>Set Global Variable</code>关键字，可以用于在测试执行期间动态设置变量。如果一个变量已经存在于新的作用域中，其值将被覆盖，否则将创建一个新的变量。</p>
<p>使用<code>Set Test Variable</code>关键字设置的变量在当前执行的测试用例的作用域内处处可用。例如，如果在一个用户关键字中设置了一个变量，它既可以在测试用例级别使用，也可以在当前测试中使用的所有其他用户关键字中使用。其他的测试用例将不会看到用这个关键字设置的变量。在测试的作用域之外调用<code>Set Test Variable</code>（例如，在套件设置或拆卸中）是一个错误。</p>
<p>使用<code>Set Suite Variable</code>关键字设置的变量在当前执行的测试套件的作用域内处处可用。因此，使用这个关键字设置变量具有与在测试数据文件中使用变量部分创建它们或从变量文件中导入它们相同的效果。其他的测试套件，包括可能的子测试套件，将不会看到用这个关键字设置的变量。</p>
<p>使用<code>Set Global Variable</code>关键字设置的变量在设置它们后执行的所有测试用例和套件中全局可用。因此，使用这个关键字设置变量具有与使用<code>--variable</code>或<code>--variablefile</code>选项从命令行创建它们相同的效果。因为这个关键字可以在任何地方改变变量，所以应该小心使用。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>Set Test/Suite/Global Variable</code>关键字直接将命名变量设置到测试、套件或全局变量作用域，并且不返回任何东西。另一方面，另一个<code>BuiltIn</code>关键字<code>Set Variable</code>使用返回值设置局部变量。</p>

    </div>
  </div>

<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p>Robot Framework自动提供了一些内置变量。</p>
<h4 id="操作系统变量"><a href="#操作系统变量" class="headerlink" title="操作系统变量"></a>操作系统变量</h4><p>与操作系统相关的内置变量使得测试数据对操作系统无关。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$&#123;CURDIR&#125;</code></td>
<td>测试数据文件所在目录的绝对路径。此变量区分大小写。</td>
</tr>
<tr>
<td><code>$&#123;TEMPDIR&#125;</code></td>
<td>系统临时目录的绝对路径。在类 UNIX 系统中通常是 <code>/tmp</code>，在 Windows 中是 <code>c:\Documents and Settings\&lt;user&gt;\Local Settings\Temp</code>。</td>
</tr>
<tr>
<td><code>$&#123;EXECDIR&#125;</code></td>
<td>测试执行开始的目录的绝对路径。</td>
</tr>
<tr>
<td><code>$&#123;/&#125;</code></td>
<td>系统目录路径分隔符。在类 UNIX 系统中是 <code>/</code>，在 Windows 中是 <code>\</code>。</td>
</tr>
<tr>
<td><code>$&#123;:&#125;</code></td>
<td>系统路径元素分隔符。在类 UNIX 系统中是 <code>:</code>，在 Windows 中是 <code>;</code>。</td>
</tr>
<tr>
<td><code>$&#123;\n&#125;</code></td>
<td>系统行分隔符。在类 UNIX 系统中是 <code>\n</code>，在 Windows 中是 <code>\r\n</code>。</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Create Binary File    $&#123;CURDIR&#125;$&#123;/&#125;input.data    Some text here$&#123;\n&#125;on two lines</span><br><span class="line">    Set Environment Variable    CLASSPATH    $&#123;TEMPDIR&#125;$&#123;:&#125;$&#123;CURDIR&#125;$&#123;/&#125;foo.jar</span><br></pre></td></tr></table></figure></div>

<h4 id="数字变量"><a href="#数字变量" class="headerlink" title="数字变量"></a>数字变量</h4><p>变量语法可以用于创建整数和浮点数，如下例所示。当一个关键字期望得到一个实际的数字，而不是一个看起来像数字的字符串作为参数时，这是有用的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example 1A</span><br><span class="line">    Connect    example.com    80       # Connect gets two strings as arguments</span><br><span class="line"></span><br><span class="line">Example 1B</span><br><span class="line">    Connect    example.com    $&#123;80&#125;    # Connect gets a string and an integer</span><br><span class="line"></span><br><span class="line">Example 2</span><br><span class="line">    Do X    $&#123;3.14&#125;    $&#123;-1e-4&#125;        # Do X gets floating point numbers 3.14 and -0.0001</span><br></pre></td></tr></table></figure></div>

<p>也可以使用0b、0o和0x前缀分别从二进制、八进制和十六进制值创建整数。语法不区分大小写。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Should Be Equal    $&#123;0b1011&#125;    $&#123;11&#125;</span><br><span class="line">    Should Be Equal    $&#123;0o10&#125;      $&#123;8&#125;</span><br><span class="line">    Should Be Equal    $&#123;0xff&#125;      $&#123;255&#125;</span><br><span class="line">    Should Be Equal    $&#123;0B1010&#125;    $&#123;0XA&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="布尔和None-null变量"><a href="#布尔和None-null变量" class="headerlink" title="布尔和None&#x2F;null变量"></a>布尔和None&#x2F;null变量</h4><p>也可以使用变量语法创建布尔值和Python的None，就像创建数字一样。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Boolean</span><br><span class="line">    Set Status    $&#123;true&#125;               # Set Status gets Boolean true as an argument</span><br><span class="line">    Create Y    something   $&#123;false&#125;    # Create Y gets a string and Boolean false</span><br><span class="line"></span><br><span class="line">None</span><br><span class="line">    Do XYZ    $&#123;None&#125;                   # Do XYZ gets Python None as an argument</span><br></pre></td></tr></table></figure></div>

<p>这些变量是不区分大小写的，所以例如<code>$&#123;True&#125;</code>和<code>$&#123;true&#125;</code>是等价的。</p>
<h4 id="空格和空变量"><a href="#空格和空变量" class="headerlink" title="空格和空变量"></a>空格和空变量</h4><p>可以使用变量<code>$&#123;SPACE&#125;</code>和<code>$&#123;EMPTY&#125;</code>分别创建空格和空字符串。这些变量在需要转义空格或空单元格时很有用。如果需要多个空格，可以使用扩展变量语法，如<code>$&#123;SPACE * 5&#125;</code>。在下面的例子中，<code>Should Be Equal</code>关键字得到相同的参数，但使用变量的那些比使用反斜杠的更容易理解。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">One space</span><br><span class="line">    Should Be Equal    $&#123;SPACE&#125;          \ \</span><br><span class="line"></span><br><span class="line">Four spaces</span><br><span class="line">    Should Be Equal    $&#123;SPACE * 4&#125;      \ \ \ \ \</span><br><span class="line"></span><br><span class="line">Ten spaces</span><br><span class="line">    Should Be Equal    $&#123;SPACE * 10&#125;     \ \ \ \ \ \ \ \ \ \ \</span><br><span class="line"></span><br><span class="line">Quoted space</span><br><span class="line">    Should Be Equal    &quot;$&#123;SPACE&#125;&quot;        &quot; &quot;</span><br><span class="line"></span><br><span class="line">Quoted spaces</span><br><span class="line">    Should Be Equal    &quot;$&#123;SPACE * 2&#125;&quot;    &quot; \ &quot;</span><br><span class="line"></span><br><span class="line">Empty</span><br><span class="line">    Should Be Equal    $&#123;EMPTY&#125;          \</span><br></pre></td></tr></table></figure></div>

<p>还有一个空列表变量<code>@&#123;EMPTY&#125;</code>和一个空字典变量<code>&amp;&#123;EMPTY&#125;</code>。因为它们没有内容，所以当它们在测试数据中被使用时，基本上就消失了。它们在测试模板中很有用，例如当模板关键字没有参数时，或者在不同的作用域中覆盖列表或字典变量时。不能修改<code>@&#123;EMPTY&#125;</code>或<code>&amp;&#123;EMPTY&#125;</code>的值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Template</span><br><span class="line">    [Template]    Some keyword</span><br><span class="line">    @&#123;EMPTY&#125;</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line">    Set Global Variable    @&#123;LIST&#125;    @&#123;EMPTY&#125;</span><br><span class="line">    Set Suite Variable     &amp;&#123;DICT&#125;    &amp;&#123;EMPTY&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p><code>${SPACE}</code>表示ASCII空格（<code>\x20</code>），其他空格应使用转义序列指定，如<code>\xA0</code>（NO-BREAK SPACE）和<code>\u3000</code>（IDEOGRAPHIC SPACE）。</p>

    </div>
  </div>

<h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><p>在测试数据中也可以使用一些自动变量。这些变量在测试执行期间可以有不同的值，有些甚至不是一直可用。改变这些变量的值不会影响原始值，但是一些值可以使用<code>BuiltIn</code>库的关键字动态改变。</p>
<p>可用的自动变量如下：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>解释</th>
<th>可用性</th>
</tr>
</thead>
<tbody><tr>
<td>${TEST NAME}</td>
<td>当前测试用例的名称。</td>
<td>测试用例</td>
</tr>
<tr>
<td>@{TEST TAGS}</td>
<td>包含当前测试用例的标签，按字母顺序排列。可以使用<code>Set Tags</code>和<code>Remove Tags</code>关键字动态修改。</td>
<td>测试用例</td>
</tr>
<tr>
<td>${TEST DOCUMENTATION}</td>
<td>当前测试用例的文档。可以使用<code>Set Test Documentation</code>关键字动态设置。</td>
<td>测试用例</td>
</tr>
<tr>
<td>${TEST STATUS}</td>
<td>当前测试用例的状态，<code>PASS</code>或<code>FAIL</code>。</td>
<td>测试拆卸</td>
</tr>
<tr>
<td>${TEST MESSAGE}</td>
<td>当前测试用例的消息。</td>
<td>测试拆卸</td>
</tr>
<tr>
<td>${PREV TEST NAME}</td>
<td>上一个测试用例的名称，如果没有执行过测试，则为空字符串。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${PREV TEST STATUS}</td>
<td>上一个测试用例的状态：<code>PASS</code>、<code>FAIL</code>，或者当没有执行过测试时为空字符串。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${PREV TEST MESSAGE}</td>
<td>上一个测试用例可能的错误消息。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${SUITE NAME}</td>
<td>当前测试套件的全名。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${SUITE SOURCE}</td>
<td>套件文件或目录的绝对路径。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${SUITE DOCUMENTATION}</td>
<td>当前测试套件的文档。可以使用<code>Set Suite Documentation</code>关键字动态设置。</td>
<td>任何地方</td>
</tr>
<tr>
<td>&amp;{SUITE METADATA}</td>
<td>当前测试套件的自由元数据。可以使用<code>Set Suite Metadata</code>关键字设置。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${SUITE STATUS}</td>
<td>当前测试套件的状态，<code>PASS</code>或<code>FAIL</code>。</td>
<td>套件拆卸</td>
</tr>
<tr>
<td>${SUITE MESSAGE}</td>
<td>当前测试套件的完整消息，包括统计信息。</td>
<td>套件拆卸</td>
</tr>
<tr>
<td>${KEYWORD STATUS}</td>
<td>当前关键字的状态，<code>PASS</code>或<code>FAIL</code>。</td>
<td>用户关键字拆卸</td>
</tr>
<tr>
<td>${KEYWORD MESSAGE}</td>
<td>当前关键字可能的错误消息。</td>
<td>用户关键字拆卸</td>
</tr>
<tr>
<td>${LOG LEVEL}</td>
<td>当前日志级别。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${OUTPUT DIR}</td>
<td>输出目录的绝对路径，为字符串。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${OUTPUT FILE}</td>
<td>输出文件的绝对路径，为字符串，如果输出文件未创建，则为字符串<code>NONE</code>。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${LOG FILE}</td>
<td>日志文件的绝对路径，为字符串，如果日志文件未创建，则为字符串<code>NONE</code>。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${REPORT FILE}</td>
<td>报告文件的绝对路径，为字符串，如果报告文件未创建，则为字符串<code>NONE</code>。</td>
<td>任何地方</td>
</tr>
<tr>
<td>${DEBUG FILE}</td>
<td>调试文件的绝对路径，为字符串，如果调试文件未创建，则为字符串<code>NONE</code>。</td>
<td>任何地方</td>
</tr>
<tr>
<td>&amp;{OPTIONS}</td>
<td>一个暴露命令行选项的字典。字典的键匹配命令行选项，可以像{OPTIONS}[key]和OPTIONS[key]和{OPTIONS.key}这样访问。可用的选项有：{OPTIONS.exclude} (–exclude)、OPTIONS.exclude(−−exclude)、{OPTIONS.include} (–include)、{OPTIONS.skip} (–skip)、OPTIONS.skip(−−skip)、{OPTIONS.skip_on_failure} (–skiponfailure)。在RF 5.0中新增。以后可以暴露更多的选项。</td>
<td>任何地方</td>
</tr>
</tbody></table>
<p>套件相关的变量<code>$&#123;SUITE SOURCE&#125;</code>、<code>$&#123;SUITE NAME&#125;</code>、<code>$&#123;SUITE DOCUMENTATION&#125;</code>和<code>&amp;&#123;SUITE METADATA&#125;</code>以及与命令行选项相关的选项，如<code>$&#123;LOG FILE&#125;</code>和<code>&amp;&#123;OPTIONS&#125;</code>，在导入库和变量文件时就已经可用。然而，在导入时，这些自动变量中可能的变量还没有被解析。</p>
<h3 id="变量优先级和作用域"><a href="#变量优先级和作用域" class="headerlink" title="变量优先级和作用域"></a>变量优先级和作用域</h3><p>来自不同来源的变量有不同的优先级，并且在不同的作用域中可用。</p>
<h4 id="变量优先级"><a href="#变量优先级" class="headerlink" title="变量优先级"></a>变量优先级</h4><h5 id="命令行中的变量"><a href="#命令行中的变量" class="headerlink" title="命令行中的变量"></a>命令行中的变量</h5><p>在实际的测试执行开始之前，可以设置的所有变量中，命令行中设置的变量具有最高的优先级。它们会覆盖在测试用例文件的变量部分创建的可能的变量，以及在测试数据中导入的资源和变量文件中的变量。</p>
<p>单独设置的变量（<code>--variable</code>选项）会覆盖使用变量文件设置的变量（<code>--variablefile</code>选项）。如果多次指定同一个单独的变量，最后指定的那个将覆盖前面的。这允许在启动脚本中为变量设置默认值，并从命令行中覆盖它们。注意，如果多个变量文件有相同的变量，那么在首先指定的文件中的变量具有最高的优先级。</p>
<h5 id="测试用例文件中的变量部分"><a href="#测试用例文件中的变量部分" class="headerlink" title="测试用例文件中的变量部分"></a>测试用例文件中的变量部分</h5><p>在测试用例文件的变量部分创建的变量对该文件中的所有测试用例都可用。这些变量会覆盖在导入的资源和变量文件中具有相同名称的可能的变量。</p>
<p>在变量部分创建的变量在创建它们的文件中的所有其他部分都可用。这意味着它们也可以在设置部分中使用，例如，用于从资源和变量文件中导入更多的变量。</p>
<h5 id="导入的资源和变量文件"><a href="#导入的资源和变量文件" class="headerlink" title="导入的资源和变量文件"></a>导入的资源和变量文件</h5><p>从资源和变量文件导入的变量在测试数据中创建的所有变量中具有最低的优先级。资源文件和变量文件中的变量具有相同的优先级。如果几个资源和&#x2F;或变量文件有相同的变量，那么首先导入的文件中的变量将被使用。</p>
<p>如果一个资源文件导入资源文件或变量文件，那么它自己的变量部分中的变量具有比它导入的变量更高的优先级。所有这些变量都可用于导入此资源文件的文件。</p>
<p>注意，从资源和变量文件导入的变量在导入它们的文件的变量部分中不可用。这是因为在处理设置部分（其中导入资源文件和变量文件）之前，已经处理了变量部分。</p>
<h5 id="在测试执行期间设置的变量"><a href="#在测试执行期间设置的变量" class="headerlink" title="在测试执行期间设置的变量"></a>在测试执行期间设置的变量</h5><p>在测试执行期间设置的变量，无论是使用关键字的返回值还是使用<code>Set Test/Suite/Global Variable</code>关键字，总是覆盖在它们被设置的作用域中可能存在的变量。从某种意义上说，它们因此具有最高的优先级，但另一方面，它们不影响它们定义的作用域之外的变量。</p>
<h5 id="内置变量-1"><a href="#内置变量-1" class="headerlink" title="内置变量"></a>内置变量</h5><p>像<code>$&#123;TEMPDIR&#125;</code>和<code>$&#123;TEST_NAME&#125;</code>这样的内置变量具有所有变量中最高的优先级。它们不能使用变量部分或从命令行覆盖，但即使它们也可以在测试执行期间重置。这个规则的一个例外是数字变量，如果没有找到其他变量，它们会动态地被解析。因此，它们可以被覆盖，但这通常是一个坏主意。此外，<code>$&#123;CURDIR&#125;</code>是特殊的，因为它在测试数据处理时间就已经被替换了。</p>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>根据它们的创建位置和方式，变量可以具有全局、测试套件、测试用例或局部作用域。</p>
<h5 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h5><p>全局变量在测试数据中的任何地方都可用。这些变量通常在命令行中使用<code>--variable</code>和<code>--variablefile</code>选项设置，但也可以在测试数据的任何地方使用VAR语法或<code>Set Global Variable</code>关键字创建新的全局变量或更改现有的全局变量。此外，内置变量也是全局的。</p>
<p>建议使用大写字母表示所有全局变量。</p>
<h5 id="测试套件作用域"><a href="#测试套件作用域" class="headerlink" title="测试套件作用域"></a>测试套件作用域</h5><p>具有测试套件作用域的变量在定义或导入它们的测试套件的任何地方都可用。它们可以在变量部分中创建，从资源和变量文件中导入，或者在测试执行期间使用VAR语法或<code>Set Suite Variable</code>关键字设置。</p>
<p>测试套件作用域不是递归的，这意味着在高级测试套件中可用的变量在低级套件中不可用。如果需要，可以使用资源和变量文件共享变量。</p>
<p>由于这些变量在使用它们的测试套件中可以被认为是全局的，因此也建议使用大写字母表示它们。</p>
<h5 id="测试用例作用域"><a href="#测试用例作用域" class="headerlink" title="测试用例作用域"></a>测试用例作用域</h5><p>具有测试用例作用域的变量在测试用例和测试使用的所有用户关键字中可见。最初在这个作用域中没有变量，但是可以在测试用例的任何地方使用VAR语法或<code>Set Test Variable</code>关键字创建它们。在套件设置或套件拆卸中尝试创建测试变量会导致错误。</p>
<p>测试用例作用域中的变量也在某种程度上是全局的。因此，通常建议使用大写字母表示它们。</p>
<h5 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h5><p>测试用例和用户关键字有一个局部变量作用域，其他测试或关键字看不到。局部变量可以使用执行的关键字的返回值和VAR语法创建，用户关键字也可以将它们作为参数获取。</p>
<p>建议使用小写字母表示局部变量。</p>
<h4 id="高级变量特性"><a href="#高级变量特性" class="headerlink" title="高级变量特性"></a>高级变量特性</h4><h5 id="扩展变量语法"><a href="#扩展变量语法" class="headerlink" title="扩展变量语法"></a>扩展变量语法</h5><p>扩展变量语法允许访问分配给变量的对象的属性（例如，<code>$&#123;object.attribute&#125;</code>）甚至调用其方法（例如，<code>$&#123;obj.getName()&#125;</code>）。它既适用于标量变量，也适用于列表变量，但主要用于前者。</p>
<p>扩展变量语法是一个强大的特性，但应谨慎使用。访问属性通常不是问题，相反，因为一个包含多个属性的对象的变量通常比有多个变量更好。另一方面，调用方法，特别是当它们带有参数时，可能会使测试数据变得相当复杂。如果发生这种情况，建议将代码移动到测试库中。</p>
<p>下面的例子说明了扩展变量语法的最常见用法。首先假设有以下变量文件和测试用例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, what</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s eats %s&#x27;</span> % (self.name, what)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">OBJECT = MyObject(<span class="string">&#x27;Robot&#x27;</span>)</span><br><span class="line">DICTIONARY = &#123;<span class="number">1</span>: <span class="string">&#x27;one&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;two&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    KW <span class="number">1</span>    $&#123;OBJECT.name&#125;</span><br><span class="line">    KW <span class="number">2</span>    $&#123;OBJECT.eat(<span class="string">&#x27;Cucumber&#x27;</span>)&#125;</span><br><span class="line">    KW <span class="number">3</span>    $&#123;DICTIONARY[<span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure></div>

<p>当执行这个测试数据时，关键字得到的参数如下：</p>
<ul>
<li>KW 1得到字符串Robot</li>
<li>KW 2得到字符串Robot eats Cucumber</li>
<li>KW 3得到字符串two</li>
</ul>
<p>扩展变量语法按以下顺序进行评估：</p>
<ol>
<li>使用完整的变量名搜索变量。只有在没有找到匹配的变量时，才会评估扩展变量语法。</li>
<li>创建基变量的名称。名称的主体由打开<code>&#123;</code>后的所有字符组成，直到第一个不是字母数字字符或空格的字符出现。例如，<code>$&#123;OBJECT.name&#125;</code>和<code>$&#123;DICTIONARY[2]&#125;</code>的基变量分别是OBJECT和DICTIONARY。</li>
<li>搜索与主体匹配的变量。如果没有匹配，将引发异常并使测试用例失败。</li>
<li>将花括号内的表达式作为Python表达式进行评估，以便将基变量名替换为其值。如果评估失败，因为语法无效或查询的属性不存在，将引发异常并使测试失败。</li>
<li>将整个扩展变量替换为从评估返回的值。</li>
</ol>
<p>许多标准的Python对象，包括字符串和数字，都有可以使用扩展变量语法显式或隐式使用的方法。有时这可能非常有用，减少了设置临时变量的需要，但也很容易过度使用它，创建真正的神秘测试数据。下面的例子展示了一些相当好的用法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">String</span><br><span class="line">    $&#123;string&#125; =    Set Variable    abc</span><br><span class="line">    Log    $&#123;string.upper()&#125;      # Logs &#x27;ABC&#x27;</span><br><span class="line">    Log    $&#123;string * 2&#125;          # Logs &#x27;abcabc&#x27;</span><br><span class="line"></span><br><span class="line">Number</span><br><span class="line">    $&#123;number&#125; =    Set Variable    $&#123;-2&#125;</span><br><span class="line">    Log    $&#123;number * 10&#125;         # Logs -20</span><br><span class="line">    Log    $&#123;number.__abs__()&#125;    # Logs 2</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>尽管在正常的Python代码中推荐使用<code>abs(number)</code>而不是<code>number.__abs__()</code>，但使用<code>${abs(number)}</code>是不起作用的。这是因为变量名必须在扩展语法的开始。在测试数据中像这样使用<code>__xxx__</code>方法已经有点可疑了，通常最好将这种逻辑移动到测试库中。</p>

    </div>
  </div>

<p>扩展变量语法也适用于列表变量上下文。例如，如果一个分配给变量<code>$&#123;EXTENDED&#125;</code>的对象有一个包含列表值的属性，它可以被用作列表变量<code>@&#123;EXTENDED.attribute&#125;</code>。</p>
<h5 id="扩展变量赋值"><a href="#扩展变量赋值" class="headerlink" title="扩展变量赋值"></a>扩展变量赋值</h5><p>可以使用关键字返回值和扩展变量语法的变体，将对象的属性设置到标量变量中。假设有前面例子中的变量<code>$&#123;OBJECT&#125;</code>，可以像下面的例子那样设置它的属性。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    $&#123;OBJECT.name&#125; =    Set Variable    New name</span><br><span class="line">    $&#123;OBJECT.new_attr&#125; =    Set Variable    New attribute</span><br></pre></td></tr></table></figure></div>

<p>扩展变量赋值语法按照以下规则进行评估：</p>
<ol>
<li>被赋值的变量必须是一个标量变量，并且至少有一个点。否则，不使用扩展赋值语法，而是正常赋值变量。</li>
<li>如果存在一个与完整名称相匹配的变量（例如，上面例子中的<code>$&#123;OBJECT.name&#125;</code>），那么该变量将被赋予一个新的值，不使用扩展语法。</li>
<li>创建基变量的名称。名称的主体由打开<code>$&#123;</code>和最后一个点之间的所有字符组成，例如，<code>$&#123;OBJECT.name&#125;</code>中的<code>OBJECT</code>和<code>$&#123;foo.bar.zap&#125;</code>中的<code>foo.bar</code>。正如第二个例子所示，基名称可能包含正常的扩展变量语法。</li>
<li>通过取最后一个点和闭合<code>&#125;</code>之间的所有字符来创建要设置的属性的名称，例如，<code>$&#123;OBJECT.name&#125;</code>中的<code>name</code>。如果名称不是以字母或下划线开头，并且只包含这些字符和数字，那么该属性被认为是无效的，不使用扩展语法。而是创建一个具有完整名称的新变量。</li>
<li>搜索与基名称匹配的变量。如果没有找到变量，那么不使用扩展语法，而是使用完整的变量名称创建一个新的变量。</li>
<li>如果找到的变量是一个字符串或一个数字，那么忽略扩展语法，并使用完整的名称创建一个新的变量。这是因为不能向Python字符串或数字添加新的属性，这样新的语法也不会向后不兼容。</li>
<li>如果所有前面的规则都匹配，那么属性被设置到基变量。如果设置失败，由于任何原因，将引发异常并使测试失败。</li>
</ol>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>与通常使用关键字返回值赋值变量不同，使用扩展赋值语法对变量进行的更改不限于当前作用域。因为没有创建新的变量，而是改变了现有变量的状态，所以所有看到该变量的测试和关键字也会看到这些更改。</p>

    </div>
  </div>

<h4 id="变量内的变量"><a href="#变量内的变量" class="headerlink" title="变量内的变量"></a>变量内的变量</h4><p>变量也可以在变量内部，当使用这种语法时，变量从内到外进行解析。例如，如果有一个变量<code>$&#123;var$&#123;x&#125;&#125;</code>，那么<code>$&#123;x&#125;</code>首先被解析。如果它的值是<code>name</code>，那么最终的值就是变量<code>$&#123;varname&#125;</code>的值。可以有多个嵌套的变量，但如果它们中的任何一个不存在，解析最外层的变量就会失败。</p>
<p>在下面的例子中，<code>Do X</code>获取的值是<code>$&#123;JOHN HOME&#125;</code>或<code>$&#123;JANE HOME&#125;</code>，取决于<code>Get Name</code>返回的是<code>john</code>还是<code>jane</code>。如果它返回其他的东西，解析<code>$&#123;$&#123;name&#125; HOME&#125;</code>就会失败。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;JOHN HOME&#125;    /home/john</span><br><span class="line">$&#123;JANE HOME&#125;    /home/jane</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    $&#123;name&#125; =    Get Name</span><br><span class="line">    Do X    $&#123;$&#123;name&#125; HOME&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="内联Python评估"><a href="#内联Python评估" class="headerlink" title="内联Python评估"></a>内联Python评估</h4><p>变量语法也可以用于评估Python表达式。基本语法是<code>$&#123;&#123;expression&#125;&#125;</code>，即表达式周围有双花括号。表达式可以是任何有效的Python表达式，如<code>$&#123;&#123;1 + 2&#125;&#125;</code>或<code>$&#123;&#123;['a', 'list']&#125;&#125;</code>。允许在表达式周围有空格，所以<code>$&#123;&#123; 1 + 2 &#125;&#125;</code>和<code>$&#123;&#123; ['a', 'list'] &#125;&#125;</code>也是有效的。除了使用正常的标量变量，列表变量和字典变量也分别支持<code>@&#123;&#123;expression&#125;&#125;</code>和<code>&amp;&#123;&#123;expression&#125;&#125;</code>语法。</p>
<p>这个相当高级的功能的主要用途是：</p>
<ul>
<li>评估涉及Robot Framework的变量的Python表达式（<code>$&#123;&#123;len('$&#123;var&#125;') > 3&#125;&#125;</code>，<code>$&#123;&#123;$var[0] if $var is not None else None&#125;&#125;</code>）。</li>
<li>创建不是Python基本类型的值（<code>$&#123;&#123;decimal.Decimal('0.11')&#125;&#125;</code>，<code>$&#123;&#123;datetime.date(2019, 11, 5)&#125;&#125;</code>）。</li>
<li>动态创建值（<code>$&#123;&#123;random.randint(0, 100)&#125;&#125;</code>，<code>$&#123;&#123;datetime.date.today()&#125;&#125;</code>）。</li>
<li>构造集合，特别是嵌套的集合（<code>$&#123;&#123;[1, 2, 3, 4]&#125;&#125;</code>，<code>$&#123;&#123; &#123;'id': 1, 'name': 'Example', 'children': [7, 9]&#125; &#125;&#125;</code>）。</li>
<li>访问Python模块中的常量和其他有用的属性（<code>$&#123;&#123;math.pi&#125;&#125;</code>，<code>$&#123;&#123;platform.system()&#125;&#125;</code>）。</li>
</ul>
<p>这与前面讨论的扩展变量语法有一些类似的功能。如上面的例子所示，这种语法更强大，因为它提供了访问Python内置函数如<code>len()</code>和模块如<code>math</code>的能力。除了能够在表达式中使用像<code>$&#123;var&#125;</code>这样的变量（它们在评估之前被替换），在评估期间还可以使用特殊的<code>$var</code>语法使用变量。整个表达式语法在评估表达式附录中有解释。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>与其创建复杂的表达式，通常最好将逻辑移动到自定义库中。这样可以简化维护，使测试数据更容易理解，也可以提高执行速度。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>内联Python评估语法是在Robot Framework 3.2中新增的。</p>

    </div>
  </div>

<h3 id="创建用户关键字"><a href="#创建用户关键字" class="headerlink" title="创建用户关键字"></a>创建用户关键字</h3><p>关键字部分用于通过组合现有关键字来创建新的高级关键字。这些关键字被称为用户关键字，以区别于在测试库中实现的最低级别的库关键字。创建用户关键字的语法与创建测试用例的语法非常接近，这使得学习变得容易。</p>
<h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><p>在很多方面，用户关键字的整体语法与测试用例语法相同。用户关键字在关键字部分中创建，这与测试用例部分的区别仅在于用于标识它们的名称。用户关键字的名称与测试用例名称一样，位于第一列。此外，用户关键字也是由关键字创建的，无论是来自测试库的关键字还是其他用户关键字。关键字名称通常在第二列，但是在从关键字返回值设置变量时，它们在后续列中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Open Login Page</span><br><span class="line">    Open Browser    http://host/login.html</span><br><span class="line">    Title Should Be    Login Page</span><br><span class="line"></span><br><span class="line">Title Should Start With</span><br><span class="line">    [Arguments]    $&#123;expected&#125;</span><br><span class="line">    $&#123;title&#125; =    Get Title</span><br><span class="line">    Should Start With    $&#123;title&#125;    $&#123;expected&#125;</span><br></pre></td></tr></table></figure></div>

<p>大多数用户关键字需要一些参数。这个重要的特性已经在上面的第二个例子中使用了，它在本节后面详细解释，与用户关键字返回值类似。</p>
<p>用户关键字可以在套件文件、资源文件和套件初始化文件中创建。在资源文件中创建的关键字对使用它们的文件可用，而其他关键字只在创建它们的文件中可用。</p>
<h4 id="关键字部分中的设置"><a href="#关键字部分中的设置" class="headerlink" title="关键字部分中的设置"></a>关键字部分中的设置</h4><p>用户关键字可以有与测试用例类似的设置，它们有相同的方括号语法将它们与关键字名称分开。所有可用的设置都列在下面，并在本节后面解释。</p>
<ul>
<li>[Documentation] 用于设置用户关键字文档。</li>
<li>[Tags] 为关键字设置标签。</li>
<li>[Arguments] 指定用户关键字参数。</li>
<li>[Setup], [Teardown] 指定用户关键字的设置和拆卸。[Setup]是在Robot Framework 7.0中新增的。</li>
<li>[Timeout] 设置可能的用户关键字超时。超时在自己的部分中讨论。</li>
<li>[Return] 指定用户关键字返回值。在Robot Framework 7.0中已弃用，应使用RETURN语句。</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>上面使用的格式是推荐的，但设置名称不区分大小写，方括号和名称之间允许有空格。例如，[ TAGS ]:setting是有效的。</p>

    </div>
  </div>

<h4 id="用户关键字的名称和文档"><a href="#用户关键字的名称和文档" class="headerlink" title="用户关键字的名称和文档"></a>用户关键字的名称和文档</h4><p>用户关键字的名称在关键字部分的第一列中定义。当然，名称应该是描述性的，接受有相当长的关键字名称。实际上，当创建用例样式的测试用例时，最高级别的关键字通常被构造为句子甚至段落。</p>
<p>用户关键字可以有一个文档，通过[Documentation]设置进行设置。它支持与测试用例文档相同的格式，分割到多行，以及其他特性。这个设置在测试数据中记录了用户关键字。它也显示在更正式的关键字文档中，Libdoc工具可以从资源文件中创建这个文档。最后，文档的第一行逻辑行，直到第一个空行，显示为测试日志中的关键字文档。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">One line documentation</span><br><span class="line">    [Documentation]    One line documentation.</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Multiline documentation</span><br><span class="line">    [Documentation]    The first line creates the short doc.</span><br><span class="line">    ...</span><br><span class="line">    ...                This is the body of the documentation.</span><br><span class="line">    ...                It is not shown in Libdoc outputs but only</span><br><span class="line">    ...                the short doc is shown in logs.</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Short documentation in multiple lines</span><br><span class="line">    [Documentation]    If the short doc gets longer, it can span</span><br><span class="line">    ...                multiple physical lines.</span><br><span class="line">    ...</span><br><span class="line">    ...                The body is separated from the short doc with</span><br><span class="line">    ...                an empty line.</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<p>有时候，关键字需要被移除，替换为新的，或者由于其他原因被弃用。用户关键字可以通过在文档开始处标记<em>DEPRECATED</em>来标记为弃用，这将在使用关键字时引发警告。有关更多信息，请参见弃用关键字部分。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 3.1之前，简短的文档只包含关键字文档的第一行物理行。</p>

    </div>
  </div>

<h4 id="用户关键字标签"><a href="#用户关键字标签" class="headerlink" title="用户关键字标签"></a>用户关键字标签</h4><p>用户关键字和库关键字都可以有标签。与标记测试用例类似，有两个设置影响用户关键字标签：</p>
<ul>
<li>在设置部分的关键字标签设置 所有在此设置的文件中的关键字总是获得指定的标签。</li>
<li>每个关键字的[Tags]设置 关键字获得这些标签，除了可能使用关键字标签设置指定的标签。[Tags]设置还允许使用-tag语法删除关键字标签设置的标签。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Keyword Tags       gui    html</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">No own tags</span><br><span class="line">    [Documentation]    Keyword has tags &#x27;gui&#x27; and &#x27;html&#x27;.</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own tags</span><br><span class="line">    [Documentation]    Keyword has tags &#x27;gui&#x27;, &#x27;html&#x27;, &#x27;own&#x27; and &#x27;tags&#x27;.</span><br><span class="line">    [Tags]    own    tags</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Remove common tag</span><br><span class="line">    [Documentation]    Test has tags &#x27;gui&#x27; and &#x27;own&#x27;.</span><br><span class="line">    [Tags]    own    -html</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<p>关键字标签可以使用变量指定，-tag语法支持模式等，与测试用例标签完全一样。</p>
<p>除了使用专用设置外，关键字标签也可以在文档的最后一行使用<code>Tags:</code>前缀指定，以便用逗号分隔标签。例如，以下两个关键字获得相同的三个标签：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Settings tags using separate setting</span><br><span class="line">    [Tags]    my    fine    tags</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Settings tags using documentation</span><br><span class="line">    [Documentation]    I have documentation. And my documentation has tags.</span><br><span class="line">    ...                Tags: my, fine, tags</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<p>关键字标签显示在日志和由Libdoc生成的文档中，其中关键字也可以基于标签进行搜索。<code>--removekeywords</code>和<code>--flattenkeywords</code>命令行选项也支持通过标签选择关键字，以后可能会添加关键字标签的新用途。</p>
<p>与测试用例标签类似，用户关键字标签带有<code>robot:</code>前缀是由Robot Framework本身保留的特殊功能。因此，用户不应使用这些前缀的任何标签，除非实际激活特殊功能。从Robot Framework 6.1开始，可以使用保留的标签<code>robot:flatten</code>在执行时间内展开关键字。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>关键字标签是在Robot Framework 6.0中新增的。在早期版本中，所有关键字标签都需要使用[Tags]设置指定。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>删除常见标签的-tag语法是在Robot Framework 7.0中新增的。</p>

    </div>
  </div>     

<h4 id="用户关键字参数"><a href="#用户关键字参数" class="headerlink" title="用户关键字参数"></a>用户关键字参数</h4><p>大多数用户关键字需要接受一些参数。指定它们的语法可能是使用Robot Framework通常需要的最复杂的特性，但即使是这样，它也相对容易，特别是在最常见的情况下。参数通常使用[Arguments]设置指定，参数名称使用与变量相同的语法，例如<code>$&#123;arg&#125;</code>。</p>
<h5 id="用户关键字的位置参数"><a href="#用户关键字的位置参数" class="headerlink" title="用户关键字的位置参数"></a>用户关键字的位置参数</h5><p>指定参数的最简单方式（除了根本不需要它们）是只使用位置参数。在大多数情况下，这就是所有需要的。</p>
<p>语法是这样的，首先给出[Arguments]设置，然后在后续的单元格中定义参数名称。每个参数都在自己的单元格中，使用与变量相同的语法。关键字必须使用与其签名中的参数名称一样多的参数。实际的参数名称对框架来说并不重要，但从用户的角度来看，它们应该尽可能具有描述性。建议在变量名称中使用小写字母，无论是<code>$&#123;my_arg&#125;</code>，<code>$&#123;my arg&#125;</code>还是<code>$&#123;myArg&#125;</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">One Argument</span><br><span class="line">    [Arguments]    $&#123;arg_name&#125;</span><br><span class="line">    Log    Got argument $&#123;arg_name&#125;</span><br><span class="line"></span><br><span class="line">Three Arguments</span><br><span class="line">    [Arguments]    $&#123;arg1&#125;    $&#123;arg2&#125;    $&#123;arg3&#125;</span><br><span class="line">    Log    1st argument: $&#123;arg1&#125;</span><br><span class="line">    Log    2nd argument: $&#123;arg2&#125;</span><br><span class="line">    Log    3rd argument: $&#123;arg3&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="用户关键字的默认值"><a href="#用户关键字的默认值" class="headerlink" title="用户关键字的默认值"></a>用户关键字的默认值</h5><p>在创建用户关键字时，位置参数在大多数情况下是足够的。然而，有时候关键字对一些或所有的参数有默认值是有用的。用户关键字也支持默认值，需要的新语法并没有给已经讨论过的基本语法增加很多内容。</p>
<p>简单来说，默认值被添加到参数中，首先是等号（&#x3D;），然后是值，例如<code>$&#123;arg&#125;=default</code>。可以有许多带有默认值的参数，但它们都必须在正常的位置参数之后给出。默认值可以包含在测试、套件或全局范围内创建的变量，但不能使用关键字执行器的局部变量。默认值也可以根据关键字接受的早期参数定义。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>默认值的语法对空格敏感。等号前不允许有空格，等号后可能的空格被认为是默认值本身的一部分。</p>

    </div>
  </div> 

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">One Argument With Default Value</span><br><span class="line">    [Arguments]    $&#123;arg&#125;=default value</span><br><span class="line">    [Documentation]    This keyword takes 0-1 arguments</span><br><span class="line">    Log    Got argument $&#123;arg&#125;</span><br><span class="line"></span><br><span class="line">Two Arguments With Defaults</span><br><span class="line">    [Arguments]    $&#123;arg1&#125;=default 1    $&#123;arg2&#125;=$&#123;VARIABLE&#125;</span><br><span class="line">    [Documentation]    This keyword takes 0-2 arguments</span><br><span class="line">    Log    1st argument $&#123;arg1&#125;</span><br><span class="line">    Log    2nd argument $&#123;arg2&#125;</span><br><span class="line"></span><br><span class="line">One Required And One With Default</span><br><span class="line">    [Arguments]    $&#123;required&#125;    $&#123;optional&#125;=default</span><br><span class="line">    [Documentation]    This keyword takes 1-2 arguments</span><br><span class="line">    Log    Required: $&#123;required&#125;</span><br><span class="line">    Log    Optional: $&#123;optional&#125;</span><br><span class="line"></span><br><span class="line"> Default Based On Earlier Argument</span><br><span class="line">    [Arguments]    $&#123;a&#125;    $&#123;b&#125;=$&#123;a&#125;    $&#123;c&#125;=$&#123;a&#125; and $&#123;b&#125;</span><br><span class="line">    Should Be Equal    $&#123;a&#125;    $&#123;b&#125;</span><br><span class="line">    Should Be Equal    $&#123;c&#125;    $&#123;a&#125; and $&#123;b&#125;</span><br></pre></td></tr></table></figure></div>

<p>当一个关键字接受几个带有默认值的参数，只有其中一些需要被覆盖时，通常使用命名参数语法是方便的。当这种语法用于用户关键字时，参数被指定，而不使用<code>$&#123;&#125;</code>装饰。例如，上面的第二个关键字可以像下面这样使用，<code>$&#123;arg1&#125;</code>仍然会得到它的默认值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Two Arguments With Defaults    arg2=new value</span><br></pre></td></tr></table></figure></div>

<p>所有的Pythonistas都已经注意到，指定默认参数的语法大量借鉴了Python函数默认值的语法。</p>
<h5 id="用户关键字的可变数量参数"><a href="#用户关键字的可变数量参数" class="headerlink" title="用户关键字的可变数量参数"></a>用户关键字的可变数量参数</h5><p>有时候，即使有默认值也不够，需要一个关键字接受可变数量的参数。用户关键字也支持这个特性。所有需要的就是在关键字签名中可能的位置参数之后有一个列表变量，如<code>@&#123;varargs&#125;</code>。这个语法可以与前面描述的默认值结合使用，最后，列表变量得到所有剩余的参数，这些参数不匹配其他参数。因此，列表变量可以有任何数量的项，甚至是零。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Any Number Of Arguments</span><br><span class="line">    [Arguments]    @&#123;varargs&#125;</span><br><span class="line">    Log Many    @&#123;varargs&#125;</span><br><span class="line"></span><br><span class="line">One Or More Arguments</span><br><span class="line">    [Arguments]    $&#123;required&#125;    @&#123;rest&#125;</span><br><span class="line">    Log Many    $&#123;required&#125;    @&#123;rest&#125;</span><br><span class="line"></span><br><span class="line">Required, Default, Varargs</span><br><span class="line">    [Arguments]    $&#123;req&#125;    $&#123;opt&#125;=42    @&#123;others&#125;</span><br><span class="line">    Log    Required: $&#123;req&#125;</span><br><span class="line">    Log    Optional: $&#123;opt&#125;</span><br><span class="line">    Log    Others:</span><br><span class="line">    FOR    $&#123;item&#125;    IN    @&#123;others&#125;</span><br><span class="line">        Log    $&#123;item&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果上面的最后一个关键字用多于一个的参数使用，第二个参数<code>${opt}</code>总是得到给定的值，而不是默认值。即使给定的值是空的，也会发生这样的情况。最后一个例子也说明了用户关键字接受的可变数量的参数如何在for循环中使用。这种两个相当高级的函数的组合有时候可能非常有用。</p>

    </div>
  </div> 

<p>上面的例子中的关键字可以像这样使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Varargs with user keywords</span><br><span class="line">    Any Number Of Arguments</span><br><span class="line">    Any Number Of Arguments    arg</span><br><span class="line">    Any Number Of Arguments    arg1    arg2    arg3   arg4</span><br><span class="line">    One Or More Arguments    required</span><br><span class="line">    One Or More Arguments    arg1    arg2    arg3   arg4</span><br><span class="line">    Required, Default, Varargs    required</span><br><span class="line">    Required, Default, Varargs    required    optional</span><br><span class="line">    Required, Default, Varargs    arg1    arg2    arg3    arg4    arg5</span><br></pre></td></tr></table></figure></div>

<p>再次，Pythonistas可能注意到，可变数量的参数语法非常接近Python中的语法。</p>
<h5 id="用户关键字的自由命名参数"><a href="#用户关键字的自由命名参数" class="headerlink" title="用户关键字的自由命名参数"></a>用户关键字的自由命名参数</h5><p>用户关键字也可以通过在关键字签名中将字典变量（如<code>&amp;&#123;named&#125;</code>）作为绝对最后的参数来接受自由命名的参数。当调用关键字时，这个变量将得到所有不匹配关键字签名中的任何位置参数或仅命名参数的命名参数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Free Named Only</span><br><span class="line">    [Arguments]    &amp;&#123;named&#125;</span><br><span class="line">    Log Many    &amp;&#123;named&#125;</span><br><span class="line"></span><br><span class="line">Positional And Free Named</span><br><span class="line">    [Arguments]    $&#123;required&#125;    &amp;&#123;extra&#125;</span><br><span class="line">    Log Many    $&#123;required&#125;    &amp;&#123;extra&#125;</span><br><span class="line"></span><br><span class="line">Run Program</span><br><span class="line">    [Arguments]    @&#123;args&#125;    &amp;&#123;config&#125;</span><br><span class="line">    Run Process    program.py    @&#123;args&#125;    &amp;&#123;config&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的最后一个例子显示了如何创建一个包装关键字，它接受任何位置或命名参数，并将它们传递。参见自由命名参数示例以获取同一关键字的完整示例。</p>
<p>用户关键字的自由命名参数支持与Python中的kwargs工作方式类似。在签名中，以及在传递参数时，<code>&amp;&#123;kwargs&#125;</code>与Python的<code>**kwargs</code>几乎相同。</p>
<h5 id="用户关键字的仅命名参数"><a href="#用户关键字的仅命名参数" class="headerlink" title="用户关键字的仅命名参数"></a>用户关键字的仅命名参数</h5><p>从Robot Framework 3.1开始，用户关键字支持仅命名参数，这些参数受到Python 3关键字仅参数的启发。这种语法通常是在可变数量的参数（<code>@&#123;varargs&#125;</code>）之后有正常的参数。如果关键字不使用varargs，可以只使用<code>@&#123;&#125;</code>来表示后续的参数是仅命名的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">With Varargs</span><br><span class="line">    [Arguments]    @&#123;varargs&#125;    $&#123;named&#125;</span><br><span class="line">    Log Many    @&#123;varargs&#125;    $&#123;named&#125;</span><br><span class="line"></span><br><span class="line">Without Varargs</span><br><span class="line">    [Arguments]    @&#123;&#125;    $&#123;first&#125;    $&#123;second&#125;</span><br><span class="line">    Log Many    $&#123;first&#125;    $&#123;second&#125;</span><br></pre></td></tr></table></figure></div>

<p>仅命名参数可以与位置参数以及自由命名参数一起使用。当使用自由命名参数时，它们必须是最后的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">With Positional</span><br><span class="line">    [Arguments]    $&#123;positional&#125;    @&#123;&#125;    $&#123;named&#125;</span><br><span class="line">    Log Many    $&#123;positional&#125;    $&#123;named&#125;</span><br><span class="line"></span><br><span class="line">With Free Named</span><br><span class="line">    [Arguments]    @&#123;varargs&#125;    $&#123;named only&#125;    &amp;&#123;free named&#125;</span><br><span class="line">    Log Many    @&#123;varargs&#125;    $&#123;named only&#125;    &amp;&#123;free named&#125;</span><br></pre></td></tr></table></figure></div>

<p>当向关键字传递仅命名参数时，它们的顺序并不重要，只要它们遵循可能的位置参数。例如，上面的关键字可以像这样使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    With Varargs    named=value</span><br><span class="line">    With Varargs    positional    second positional    named=foobar</span><br><span class="line">    Without Varargs    first=1    second=2</span><br><span class="line">    Without Varargs    second=toka    first=eka</span><br><span class="line">    With Positional    foo    named=bar</span><br><span class="line">    With Positional    named=2    positional=1</span><br><span class="line">    With Free Named    positional    named only=value    x=1    y=2</span><br><span class="line">    With Free Named    foo=a    bar=b    named only=c    quux=d</span><br></pre></td></tr></table></figure></div>

<p>仅命名参数可以有默认值，与正常的用户关键字参数类似。一个小的区别是，有和没有默认值的参数的顺序并不重要。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">With Default</span><br><span class="line">    [Arguments]    @&#123;&#125;    $&#123;named&#125;=default</span><br><span class="line">    Log Many    $&#123;named&#125;</span><br><span class="line"></span><br><span class="line">With And Without Defaults</span><br><span class="line">    [Arguments]    @&#123;&#125;    $&#123;optional&#125;=default    $&#123;mandatory&#125;    $&#123;mandatory 2&#125;    $&#123;optional 2&#125;=default 2    $&#123;mandatory 3&#125;</span><br><span class="line">    Log Many    $&#123;optional&#125;    $&#123;mandatory&#125;    $&#123;mandatory 2&#125;    $&#123;optional 2&#125;    $&#123;mandatory 3&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="将参数嵌入到关键字名称中"><a href="#将参数嵌入到关键字名称中" class="headerlink" title="将参数嵌入到关键字名称中"></a>将参数嵌入到关键字名称中</h4><p>上一节解释了如何将参数传递给关键字，使它们在关键字名称后单独列出。Robot Framework还有另一种传递参数的方法，即直接将参数嵌入到关键字名称中，如下面的第二个测试所使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Normal arguments</span><br><span class="line">    Select from list    cat</span><br><span class="line"></span><br><span class="line">Embedded arguments</span><br><span class="line">    Select cat from list</span><br></pre></td></tr></table></figure></div>

<p>如上例所示，将参数嵌入到关键字名称中可以使数据更易于阅读和理解，即使对没有任何Robot Framework经验的人也是如此。</p>
<h5 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h5><p>上一个例子展示了如何使用关键字<code>Select cat from list</code>比使用<code>Select from list</code>将<code>cat</code>作为参数传递给它更流畅。显然可以将<code>Select cat from list</code>实现为一个正常的关键字，不接受任何参数，但是然后需要为其他动物实现各种其他关键字，如<code>Select dog from list</code>。嵌入式参数简化了这个问题，可以代替实现只有一个关键字，名称为<code>Select $&#123;animal&#125; from list</code>，并用任何动物使用它：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Embedded arguments</span><br><span class="line">    Select cat from list</span><br><span class="line">    Select dog from list</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Select $&#123;animal&#125; from list</span><br><span class="line">    Open Page    Pet Selection</span><br><span class="line">    Select Item From List    animal_list    $&#123;animal&#125;</span><br></pre></td></tr></table></figure></div>

<p>如上例所示，嵌入式参数只是通过在关键字名称中使用变量来指定。在名称中使用的参数自然地在关键字内部可用，并且它们的值取决于如何调用关键字。在上面的例子中，当关键字第一次使用时，<code>$&#123;animal&#125;</code>的值是<code>cat</code>，当它第二次使用时，值是<code>dog</code>。</p>
<p>从Robot Framework 6.1开始，可以创建接受嵌入式和”正常”参数的用户关键字：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Embedded and normal arguments</span><br><span class="line">    Number of cats should be    2</span><br><span class="line">    Number of dogs should be    count=3</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Number of $&#123;animals&#125; should be</span><br><span class="line">    [Arguments]    $&#123;count&#125;</span><br><span class="line">    Open Page    Pet Selection</span><br><span class="line">    Select Items From List    animal_list    $&#123;animals&#125;</span><br><span class="line">    Number of Selected List Items Should Be    $&#123;count&#125;</span><br></pre></td></tr></table></figure></div>

<p>除了特殊的名称，嵌入式参数的关键字就像其他用户关键字一样创建。它们也像其他关键字一样使用，除了在匹配关键字时，它们的名称中不忽略空格和下划线。然而，它们像其他关键字一样不区分大小写。例如，关键字<code>Select $&#123;animal&#125; from list</code>可以像<code>select cow from list</code>那样使用，但不能像<code>Select cow fromlist</code>那样使用。</p>
<p>嵌入式参数不支持像正常参数那样的默认值或可变数量的参数。如果需要这样的功能，应该使用正常参数。可以将嵌入式参数作为变量传递，但这可能会降低可读性：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;SELECT&#125;        cat</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Embedded arguments with variable</span><br><span class="line">    Select $&#123;SELECT&#125; from list</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Select $&#123;animal&#125; from list</span><br><span class="line">    Open Page    Pet Selection</span><br><span class="line">    Select Item From List    animal_list    $&#123;animal&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="嵌入参数匹配错误的值"><a href="#嵌入参数匹配错误的值" class="headerlink" title="嵌入参数匹配错误的值"></a>嵌入参数匹配错误的值</h5><p>使用嵌入参数的一个棘手部分是确保在调用关键字时使用的值匹配正确的参数。这是一个问题，特别是如果有多个参数，并且分隔它们的字符也可能出现在给定的值中。例如，在下面的例子中，<code>Select Los Angeles Lakers</code>匹配<code>Select $&#123;city&#125; $&#123;team&#125;</code>，使得<code>$&#123;city&#125;</code>包含<code>Los</code>，<code>$&#123;team&#125;</code>包含<code>Angeles Lakers</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Select Chicago Bulls</span><br><span class="line">    Select Los Angeles Lakers</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Select $&#123;city&#125; $&#123;team&#125;</span><br><span class="line">    Log    Selected $&#123;team&#125; from $&#123;city&#125;.</span><br></pre></td></tr></table></figure></div>

<p>解决这个问题的一个简单方法是用双引号或其他实际值中未使用的字符包围参数。这个修复的例子工作得很好，城市和团队匹配正确：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Select &quot;Chicago&quot; &quot;Bulls&quot;</span><br><span class="line">    Select &quot;Los Angeles&quot; &quot;Lakers&quot;</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Select &quot;$&#123;city&#125;&quot; &quot;$&#123;team&#125;&quot;</span><br><span class="line">    Log    Selected $&#123;team&#125; from $&#123;city&#125;.</span><br></pre></td></tr></table></figure></div>

<p>这种方法不能解决所有的冲突，但它在常见的情况下有所帮助，通常推荐使用。另一个好处是，它使参数从关键字的其余部分突出出来。</p>
<p>当创建忽略Behavior Driven Development (BDD)中通常使用的given&#x2F;when&#x2F;then&#x2F;and&#x2F;but前缀的关键字时，参数匹配过多的问题经常出现。例如，<code>$&#123;name&#125; goes home</code>匹配<code>Given Janne goes home</code>，使得<code>$&#123;name&#125;</code>得到<code>Given Janne</code>的值。像<code>&quot;$&#123;name&#125;&quot; goes home</code>这样的参数周围的引号，可以轻松解决这个问题。</p>
<p>限制参数匹配什么值的另一种解决方案是使用自定义正则表达式。</p>
<h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h5><p>当使用嵌入参数时，很常见的一种情况是有多个关键字实现与使用的关键字匹配。例如，在下面的例子中，<code>Execute &quot;ls&quot; with &quot;lf&quot;</code>匹配了两个关键字。它匹配<code>Execute &quot;$&#123;cmd&#125;&quot; with &quot;$&#123;opts&#125;&quot;</code>是非常明显的，也是想要的，但它也匹配<code>Execute &quot;$&#123;cmd&#125;&quot;</code>，使得<code>$&#123;cmd&#125;</code>匹配<code>ls&quot; with &quot;-lh</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library          Process</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Automatic conflict resolution</span><br><span class="line">    Execute &quot;ls&quot;</span><br><span class="line">    Execute &quot;ls&quot; with &quot;-lh&quot;</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Execute &quot;$&#123;cmd&#125;&quot;</span><br><span class="line">    Run Process    $&#123;cmd&#125;    shell=True</span><br><span class="line"></span><br><span class="line">Execute &quot;$&#123;cmd&#125;&quot; with &quot;$&#123;opts&#125;&quot;</span><br><span class="line">    Run Process    $&#123;cmd&#125; $&#123;opts&#125;    shell=True</span><br></pre></td></tr></table></figure></div>

<p>当这种冲突发生时，Robot Framework试图自动选择最佳匹配并使用它。在上面的例子中，<code>Execute &quot;$&#123;cmd&#125;&quot; with &quot;$&#123;opts&#125;&quot;</code>被认为是比更通用的<code>Execute &quot;$&#123;cmd&#125;&quot;</code>更好的匹配，因此运行示例就成功了，没有冲突。</p>
<p>并不总是可能找到一个比其他的更好的匹配。例如，下面的第二个测试失败，因为Robot Framework将两个关键字匹配得同样好。这种冲突需要手动解决，要么通过重命名关键字，要么通过使用自定义正则表达式。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">No conflict</span><br><span class="line">    Automation framework</span><br><span class="line">    Robot uprising</span><br><span class="line"></span><br><span class="line">Unresolvable conflict</span><br><span class="line">    Robot Framework</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">$&#123;type&#125; Framework</span><br><span class="line">    Should Be Equal    $&#123;type&#125;    Automation</span><br><span class="line"></span><br><span class="line">Robot $&#123;action&#125;</span><br><span class="line">    Should Be Equal    $&#123;action&#125;    uprising</span><br></pre></td></tr></table></figure></div>

<p>接受只有”正常”参数或根本没有参数的关键字被认为比接受嵌入参数的关键字匹配得更好。例如，如果将以下关键字添加到上面的例子中，Robot Framework在后面的测试中使用的关键字匹配它，测试成功：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Robot Framework</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<p>在查看哪个匹配最好之前，Robot Framework检查是否有一些匹配的关键字在调用者关键字的同一文件中实现。如果有这样的关键字，它们将优先于其他关键字。或者，可以使用库搜索顺序来控制Robot Framework在资源和库中查找关键字的顺序。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果多个带有嵌入参数的关键字匹配，自动解决冲突是Robot Framework 6.0中的新特性。在早期版本中，可以使用下面解释的自定义正则表达式代替。</p>

    </div>
  </div> 

<h5 id="使用自定义正则表达式"><a href="#使用自定义正则表达式" class="headerlink" title="使用自定义正则表达式"></a>使用自定义正则表达式</h5><p>当调用带有嵌入参数的关键字时，内部使用正则表达式（简称regexps）匹配值。默认的逻辑是，名称中的每个参数都被替换为一个模式<code>.*?</code>，该模式匹配任何字符串，并尽可能少地匹配。这个逻辑通常工作得相当好，但如上所述，有时关键字匹配错误的值，有时存在无法解决的冲突。在这些情况下，解决方案是指定一个自定义的正则表达式，确保关键字只匹配它应该在那个特定上下文中匹配的内容。要能够使用这个特性，并完全理解本节中的例子，需要至少理解正则表达式语法的基础。</p>
<p>自定义嵌入参数的正则表达式在参数的基本名称之后定义，参数和regexp用冒号分隔。例如，应该只匹配数字的参数可以定义为<code>$&#123;arg:\d+&#125;</code>。</p>
<p>使用自定义正则表达式的示例如下。注意，第一个例子显示了如何解决<code>Select $&#123;city&#125; $&#123;team&#125;</code>不正确匹配<code>Select Los Angeles Lakers</code>的早期问题，而不需要引用。这是通过实现关键字来实现的，使得<code>$&#123;team&#125;</code>只能包含非空白字符。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library          DateTime</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Do not match whitespace characters</span><br><span class="line">    Select Chicago Bulls</span><br><span class="line">    Select Los Angeles Lakers</span><br><span class="line"></span><br><span class="line">Match numbers and characters from set</span><br><span class="line">    1 + 2 = 3</span><br><span class="line">    53 - 11 = 42</span><br><span class="line"></span><br><span class="line">Match either date or literal &#x27;today&#x27;</span><br><span class="line">    Deadline is 2022-09-21</span><br><span class="line">    Deadline is today</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Select $&#123;city&#125; $&#123;team:\S+&#125;</span><br><span class="line">    Log    Selected $&#123;team&#125; from $&#123;city&#125;.</span><br><span class="line"></span><br><span class="line">$&#123;number1:\d+&#125; $&#123;operator:[+-]&#125; $&#123;number2:\d+&#125; = $&#123;expected:\d+&#125;</span><br><span class="line">    $&#123;result&#125; =    Evaluate    $&#123;number1&#125; $&#123;operator&#125; $&#123;number2&#125;</span><br><span class="line">    Should Be Equal As Integers    $&#123;result&#125;    $&#123;expected&#125;</span><br><span class="line"></span><br><span class="line">Deadline is $&#123;date:(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;|today)&#125;</span><br><span class="line">    IF    &#x27;$&#123;date&#125;&#x27; == &#x27;today&#x27;</span><br><span class="line">        $&#123;date&#125; =    Get Current Date</span><br><span class="line">    ELSE</span><br><span class="line">        $&#123;date&#125; =    Convert Date    $&#123;date&#125;</span><br><span class="line">    END</span><br><span class="line">    Log    Deadline is on $&#123;date&#125;.</span><br></pre></td></tr></table></figure></div>

<h6 id="支持的正则表达式语法"><a href="#支持的正则表达式语法" class="headerlink" title="支持的正则表达式语法"></a>支持的正则表达式语法</h6><p>由于是用Python实现的，Robot Framework自然使用Python的re模块，它有相当标准的正则表达式语法。这种语法在其他方面都得到了嵌入参数的完全支持，但不能使用格式为<code>(?...)</code>的regexp扩展。如果正则表达式语法无效，创建关键字会失败，错误可在测试执行错误中看到。</p>
<h6 id="转义特殊字符-1"><a href="#转义特殊字符-1" class="headerlink" title="转义特殊字符"></a>转义特殊字符</h6><p>正则表达式大量使用反斜杠字符（\），既用于形成特殊序列（例如<code>\d</code>），也用于转义在regexps中有特殊含义的字符（例如<code>\$</code>）。通常在Robot Framework数据中，反斜杠字符需要用另一个反斜杠转义，但在这个上下文中不需要。如果需要在模式中有一个字面反斜杠，那么反斜杠必须像<code>$&#123;path:c:\\temp\\.*&#125;</code>那样被转义。</p>
<p>在模式中可能的孤立的开放和关闭的大括号必须像<code>$&#123;open:\&#123;&#125;</code>和<code>$&#123;close:\&#125;&#125;</code>那样被转义，否则Robot Framework无法正确解析变量语法。如果有匹配的大括号，像<code>$&#123;digits:\d&#123;2&#125;&#125;</code>那样，不需要转义。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 3.2之前，必须像<code>${digits:\d{2\}}</code>那样在模式中转义所有的关闭大括号。这种语法不幸的是不被Robot Framework 3.2或更高版本支持，使用它的关键字必须在升级时更新。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 6.0之前，在模式中使用字面反斜杠需要像<code>${path:c:\\\\temp\\\\.*}</code>那样将它们双重转义。使用字面反斜杠的模式需要在升级时更新。</p>

    </div>
  </div> 

<h6 id="使用自定义嵌入参数的正则表达式"><a href="#使用自定义嵌入参数的正则表达式" class="headerlink" title="使用自定义嵌入参数的正则表达式"></a>使用自定义嵌入参数的正则表达式</h6><p>当使用自定义正则表达式的嵌入参数时，Robot Framework会自动增强指定的正则表达式，使它们匹配变量以及匹配模式的文本。例如，使用前面例子中的关键字，下面的测试用例将通过。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;DATE&#125;    2011-06-27</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Deadline is $&#123;DATE&#125;</span><br><span class="line">    $&#123;1&#125; + $&#123;2&#125; = $&#123;3&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用变量的一个限制是，它们的实际值不会与自定义正则表达式进行匹配。结果是，关键字可能会被调用，其值可能不允许其自定义正则表达式。从Robot Framework 6.0开始，这种行为已被弃用，未来将对值进行验证。有关更多信息，请参阅问题#4462。</p>
<h5 id="行为驱动开发示例"><a href="#行为驱动开发示例" class="headerlink" title="行为驱动开发示例"></a>行为驱动开发示例</h5><p>将参数作为关键字名称的一部分的一个大的好处是，当使用行为驱动风格编写测试时，它使得使用更高级别的类似句子的关键字更容易。如下面的例子所示，这种支持通常与在关键字定义中省略Given、When和Then前缀的可能性结合使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Add two numbers</span><br><span class="line">    Given I have Calculator open</span><br><span class="line">    When I add 2 and 40</span><br><span class="line">    Then result should be 42</span><br><span class="line"></span><br><span class="line">Add negative numbers</span><br><span class="line">    Given I have Calculator open</span><br><span class="line">    When I add 1 and -2</span><br><span class="line">    Then result should be -1</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">I have $&#123;program&#125; open</span><br><span class="line">    Start Program    $&#123;program&#125;</span><br><span class="line"></span><br><span class="line">I add $&#123;number 1&#125; and $&#123;number 2&#125;</span><br><span class="line">    Input Number    $&#123;number 1&#125;</span><br><span class="line">    Push Button     +</span><br><span class="line">    Input Number    $&#123;number 2&#125;</span><br><span class="line">    Push Button     =</span><br><span class="line"></span><br><span class="line">Result should be $&#123;expected&#125;</span><br><span class="line">    $&#123;result&#125; =    Get Result</span><br><span class="line">    Should Be Equal    $&#123;result&#125;    $&#123;expected&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>Robot Framework中的嵌入参数特性受到了流行的BDD工具Cucumber中创建步骤定义的启发。</p>

    </div>
  </div>             

<h4 id="用户关键字返回值"><a href="#用户关键字返回值" class="headerlink" title="用户关键字返回值"></a>用户关键字返回值</h4><p>与库关键字一样，用户关键字也可以返回值。当使用Robot Framework 5.0或更高版本时，推荐的方法是使用原生的RETURN语句。旧的[Return]设置在Robot Framework 7.0中被弃用，同时BuiltIn关键字Return From Keyword和Return From Keyword If也被认为是弃用的。</p>
<p>无论如何返回值，它们都可以在测试用例和其他用户关键字中分配给变量。</p>
<h5 id="使用RETURN语句"><a href="#使用RETURN语句" class="headerlink" title="使用RETURN语句"></a>使用RETURN语句</h5><p>返回值的推荐方法是使用RETURN语句。它接受可选的返回值，并可以与IF和内联IF结构一起使用。它的用法最容易通过例子来解释：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Return One Value</span><br><span class="line">    [Arguments]    $&#123;arg&#125;</span><br><span class="line">    [Documentation]    Return a value unconditionally.</span><br><span class="line">    ...                Notice that keywords after RETURN are not executed.</span><br><span class="line">    $&#123;value&#125; =    Convert To Upper Case    $&#123;arg&#125;</span><br><span class="line">    RETURN    $&#123;value&#125;</span><br><span class="line">    Fail    Not executed</span><br><span class="line"></span><br><span class="line">Return Three Values</span><br><span class="line">    [Documentation]    Return multiple values.</span><br><span class="line">    RETURN    a    b    c</span><br><span class="line"></span><br><span class="line">Conditional Return</span><br><span class="line">    [Arguments]    $&#123;arg&#125;</span><br><span class="line">    [Documentation]    Return conditionally.</span><br><span class="line">    Log    Before</span><br><span class="line">    IF    $&#123;arg&#125; == 1</span><br><span class="line">        Log    Returning!</span><br><span class="line">        RETURN</span><br><span class="line">    END</span><br><span class="line">    Log    After</span><br><span class="line"></span><br><span class="line">Find Index</span><br><span class="line">    [Arguments]    $&#123;test&#125;    $&#123;items&#125;</span><br><span class="line">    [Documentation]    Advanced example involving FOR loop, inline IF and @&#123;list&#125; variable syntax.</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;item&#125;    IN ENUMERATE    @&#123;items&#125;</span><br><span class="line">        IF    $item == $test    RETURN    $&#123;index&#125;</span><br><span class="line">    END</span><br><span class="line">    RETURN    $&#123;-1&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果想自己测试上面的例子，可以使用这些测试用例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library           String</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">One return value</span><br><span class="line">    $&#123;ret&#125; =    Return One Value    argument</span><br><span class="line">    Should Be Equal    $&#123;ret&#125;    ARGUMENT</span><br><span class="line"></span><br><span class="line">Multiple return values</span><br><span class="line">    $&#123;a&#125;    $&#123;b&#125;    $&#123;c&#125; =    Return Three Values</span><br><span class="line">    Should Be Equal    $&#123;a&#125;, $&#123;b&#125;, $&#123;c&#125;    a, b, c</span><br><span class="line"></span><br><span class="line">Conditional return</span><br><span class="line">    Conditional Return    1</span><br><span class="line">    Conditional Return    2</span><br><span class="line"></span><br><span class="line">Advanced</span><br><span class="line">    @&#123;list&#125; =    Create List    foo    bar    baz</span><br><span class="line">    $&#123;index&#125; =    Find Index    bar    $&#123;list&#125;</span><br><span class="line">    Should Be Equal    $&#123;index&#125;    $&#123;1&#125;</span><br><span class="line">    $&#123;index&#125; =    Find Index    non existing    $&#123;list&#125;</span><br><span class="line">    Should Be Equal    $&#123;index&#125;    $&#123;-1&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>RETURN语法是区分大小写的，就像IF和FOR一样。</p>

    </div>
  </div>             


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>RETURN是Robot Framework 5.0中的新特性。如果需要支持旧版本，请使用下面解释的方法。</p>

    </div>
  </div>                           

<h5 id="使用-Return-设置"><a href="#使用-Return-设置" class="headerlink" title="使用[Return]设置"></a>使用[Return]设置</h5><p>[Return]设置定义了关键字在执行后应返回什么。虽然推荐将它放在关键字的末尾，这在逻辑上是合理的，但它的位置并不影响它的使用方式。</p>
<p>[Return]设置的一个固有限制是它不能被条件性地使用。因此，只有前两个RETURN语句的例子可以使用它来创建。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Return One Value</span><br><span class="line">    [Arguments]    $&#123;arg&#125;</span><br><span class="line">    $&#123;value&#125; =    Convert To Upper Case    $&#123;arg&#125;</span><br><span class="line">    [Return]    $&#123;value&#125;</span><br><span class="line"></span><br><span class="line">Return Three Values</span><br><span class="line">    [Return]    a    b    c</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 7.0中，[Return]设置被弃用，应该使用RETURN语句。如果需要支持不支持RETURN的旧版本的Robot Framework，可以使用下一节讨论的特殊关键字。</p>

    </div>
  </div>

<h5 id="使用特殊关键字返回"><a href="#使用特殊关键字返回" class="headerlink" title="使用特殊关键字返回"></a>使用特殊关键字返回</h5><p>BuiltIn关键字Return From Keyword和Return From Keyword If允许在关键字的中间条件性地从用户关键字返回。它们两者也接受可选的返回值，这些返回值的处理方式与上面讨论的RETURN语句和[Return]设置完全相同。</p>
<p>引入RETURN语句使这些关键字变得多余。下面的例子包含了与早期RETURN例子相同的关键字，但这些关键字更冗长：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Return One Value</span><br><span class="line">    [Arguments]    $&#123;arg&#125;</span><br><span class="line">    $&#123;value&#125; =    Convert To Upper Case    $&#123;arg&#125;</span><br><span class="line">    Return From Keyword    $&#123;value&#125;</span><br><span class="line">    Fail    Not executed</span><br><span class="line"></span><br><span class="line">Return Three Values</span><br><span class="line">    Return From Keyword        a    b    c</span><br><span class="line"></span><br><span class="line">Conditional Return</span><br><span class="line">    [Arguments]    $&#123;arg&#125;</span><br><span class="line">    Log    Before</span><br><span class="line">    IF    $&#123;arg&#125; == 1</span><br><span class="line">        Log    Returning!</span><br><span class="line">        Return From Keyword</span><br><span class="line">    END</span><br><span class="line">    Log    After</span><br><span class="line"></span><br><span class="line">Find Index</span><br><span class="line">    [Arguments]    $&#123;test&#125;    $&#123;items&#125;</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;item&#125;    IN ENUMERATE    @&#123;items&#125;</span><br><span class="line">        Return From Keyword If    $item == $test    $&#123;index&#125;</span><br><span class="line">    END</span><br><span class="line">    Return From Keyword    $&#123;-1&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>这些关键字实际上已经被弃用，除非需要支持Robot Framework 5.0之前的版本，否则应该使用RETURN语句。使用这些关键字时还没有可见的弃用警告，但它们将在未来被大声地弃用，并最终被移除。</p>

    </div>
  </div>

<h4 id="用户关键字设置和拆卸"><a href="#用户关键字设置和拆卸" class="headerlink" title="用户关键字设置和拆卸"></a>用户关键字设置和拆卸</h4><p>用户关键字可以有一个设置和一个拆卸，就像测试一样。它们分别使用[Setup]和[Teardown]设置直接指定给拥有它们的关键字。与测试不同，无法为某个文件中的所有关键字指定一个公共的设置或拆卸。</p>
<p>设置和拆卸总是一个单独的关键字，但它们自己可以是执行多个关键字的用户关键字。可以将它们指定为变量，使用特殊的NONE值（不区分大小写）与根本没有设置或拆卸是一样的。</p>
<p>用户关键字设置与创建的用户关键字中的第一个关键字没有太大的不同。唯一的功能性差异是，设置可以被指定为一个变量，但能够明确地标记一个关键字为设置也可能是有用的。</p>
<p>用户关键字的拆卸，就像测试的拆卸一样，即使用户关键字失败也会被执行。因此，当需要在关键字结束时做一些事情，无论其状态如何，它们都非常有用。为了确保所有的清理活动都被完成，与测试拆卸一样，用户关键字拆卸默认启用了失败后继续模式。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Setup and teardown</span><br><span class="line">    [Setup]       Log    New in RF 7!</span><br><span class="line">    Do Something</span><br><span class="line">    [Teardown]    Log    Old feature.</span><br><span class="line"></span><br><span class="line">Using variables</span><br><span class="line">    [Setup]       $&#123;SETUP&#125;</span><br><span class="line">    Do Something</span><br><span class="line">    [Teardown]    $&#123;TEARDOWN&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>用户关键字设置是Robot Framework 7.0中的新特性。</p>

    </div>
  </div>

<h4 id="私有用户关键字"><a href="#私有用户关键字" class="headerlink" title="私有用户关键字"></a>私有用户关键字</h4><p>用户关键字可以被标记为一个特殊的robot:private标签，以表示它们只应该在创建它们的文件中使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Public Keyword</span><br><span class="line">    Private Keyword</span><br><span class="line"></span><br><span class="line">Private Keyword</span><br><span class="line">    [Tags]    robot:private</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<p>使用robot:private标签并不直接阻止在创建它的文件之外使用关键字，但这样的用法会引发警告。如果有一个公共的和一个私有的具有相同名称的关键字，将使用公共的，但这种情况也会引发警告。</p>
<p>私有关键字包含在Libdoc创建的规格文件中，但不包含在其HTML输出文件中。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>私有用户关键字是Robot Framework 6.0中的新特性。</p>

    </div>
  </div>

<h3 id="资源和变量文件"><a href="#资源和变量文件" class="headerlink" title="资源和变量文件"></a>资源和变量文件</h3><p>套件文件和套件初始化文件中的用户关键字和变量只能在创建它们的文件中使用，但资源文件提供了共享它们的机制。创建资源文件的高级语法与创建套件文件完全相同，支持的文件格式也相同。主要的区别是资源文件不能有测试。</p>
<p>变量文件提供了一个强大的机制来创建和共享变量。例如，它们允许除字符串之外的值，并启用动态创建变量。它们的灵活性来自于它们是使用Python或YAML创建的，这也使它们比变量部分稍微复杂一些。</p>
<h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><p>资源文件通常使用纯文本格式创建，但也支持reStructuredText格式和JSON格式。</p>
<h5 id="使用资源文件"><a href="#使用资源文件" class="headerlink" title="使用资源文件"></a>使用资源文件</h5><p>资源文件是使用Settings部分的Resource设置导入的，以便将资源文件的路径作为设置的参数给出。资源文件的推荐扩展名是.resource。出于向后兼容性的原因，.robot、.txt和.tsv也可以工作，但在未来可能会强制使用.resource。</p>
<p>如果资源文件路径是绝对的，那么直接使用它。否则，首先相对于导入文件所在的目录搜索资源文件。如果在那里没有找到文件，那么就从Python的模块搜索路径中的目录中搜索。从模块搜索路径搜索资源文件使得可以将它们打包到Python包中作为包数据，并像package&#x2F;example.resource那样导入它们。</p>
<p>资源文件路径可以包含变量，建议使用它们来使路径系统无关（例如，{RESOURCES}&#x2F;login.resource或者只是RESOURCES&#x2F;login.resource或者只是{RESOURCE_PATH}）。此外，路径中的正斜杠（&#x2F;）在Windows上自动改为反斜杠（\）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Resource    example.resource</span><br><span class="line">Resource    ../resources/login.resource</span><br><span class="line">Resource    package/example.resource</span><br><span class="line">Resource    $&#123;RESOURCES&#125;/common.resource</span><br></pre></td></tr></table></figure></div>

<p>在资源文件中定义的用户关键字和变量在使用该资源文件的文件中可用。同样可用的还有该资源文件导入的所有库、资源文件和变量文件中的所有关键字和变量。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>.resource扩展名是Robot Framework 3.1中的新特性。</p>

    </div>
  </div>              

<h5 id="资源文件结构"><a href="#资源文件结构" class="headerlink" title="资源文件结构"></a>资源文件结构</h5><p>资源文件的高级结构与套件文件的结构相同，但它们不能包含测试或任务。此外，资源文件中的Setting部分只能包含导入（Library、Resource、Variables）、Documentation和Keyword Tags。Variable部分和Keyword部分的使用方式与套件文件完全相同。</p>
<p>如果几个资源文件有一个用户关键字具有相同的名称，它们必须被使用，以便关键字名称前缀为资源文件名称而不带扩展名（例如，myresources.Some Keyword和common.Some Keyword）。此外，如果几个资源文件包含相同的变量，首先导入的那个将被使用。</p>
<h5 id="记录资源文件"><a href="#记录资源文件" class="headerlink" title="记录资源文件"></a>记录资源文件</h5><p>在资源文件中创建的关键字可以使用[Documentation]设置进行记录。资源文件本身可以在Setting部分有Documentation，就像套件一样。</p>
<p>Libdoc和各种编辑器使用这些文档，它们自然地对任何打开资源文件的人都可用。当运行关键字时，关键字的文档的第一个逻辑行，直到第一个空行，被记录下来，但在测试执行期间，资源文件文档被忽略。</p>
<h5 id="示例资源文件"><a href="#示例资源文件" class="headerlink" title="示例资源文件"></a>示例资源文件</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation     An example resource file</span><br><span class="line">Library           SeleniumLibrary</span><br><span class="line">Resource          $&#123;RESOURCES&#125;/common.resource</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;HOST&#125;           localhost:7272</span><br><span class="line">$&#123;LOGIN URL&#125;      http://$&#123;HOST&#125;/</span><br><span class="line">$&#123;WELCOME URL&#125;    http://$&#123;HOST&#125;/welcome.html</span><br><span class="line">$&#123;BROWSER&#125;        Firefox</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Open Login Page</span><br><span class="line">    [Documentation]    Opens browser to login page</span><br><span class="line">    Open Browser    $&#123;LOGIN URL&#125;    $&#123;BROWSER&#125;</span><br><span class="line">    Title Should Be    Login Page</span><br><span class="line"></span><br><span class="line">Input Name</span><br><span class="line">    [Arguments]    $&#123;name&#125;</span><br><span class="line">    Input Text    username_field    $&#123;name&#125;</span><br><span class="line"></span><br><span class="line">Input Password</span><br><span class="line">    [Arguments]    $&#123;password&#125;</span><br><span class="line">    Input Text    password_field    $&#123;password&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="使用reStructured文本格式的资源文件"><a href="#使用reStructured文本格式的资源文件" class="headerlink" title="使用reStructured文本格式的资源文件"></a>使用reStructured文本格式的资源文件</h5><p>可以使用套件文件的reStructuredText格式也适用于资源文件。这样的资源文件可以使用.rst或.rest扩展名，它们在其他方面与普通资源文件的导入方式完全相同：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Resource         example.rst</span><br></pre></td></tr></table></figure></div>

<p>当使用reStructuredText格式解析资源文件时，Robot Framework忽略所有包含Robot Framework数据的代码块之外的所有数据，就像解析reStructuredText套件文件一样。例如，下面的资源文件导入OperatingSystem库，定义${MESSAGE}变量并创建My Keyword关键字：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Resource file using reStructuredText</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">This text is outside code blocks and thus ignored.</span><br><span class="line"></span><br><span class="line">.. code:: robotframework</span><br><span class="line"></span><br><span class="line">   *** Settings ***</span><br><span class="line">   Library          OperatingSystem</span><br><span class="line"></span><br><span class="line">   *** Variables ***</span><br><span class="line">   $&#123;MESSAGE&#125;       Hello, world!</span><br><span class="line"></span><br><span class="line">Also this text is outside code blocks and ignored. Code blocks not</span><br><span class="line">containing Robot Framework data are ignored as well.</span><br><span class="line"></span><br><span class="line">.. code:: robotframework</span><br><span class="line"></span><br><span class="line">   # Both space and pipe separated formats are supported.</span><br><span class="line"></span><br><span class="line">   | *** Keywords ***  |                        |         |</span><br><span class="line">   | My Keyword        | [Arguments]            | $&#123;path&#125; |</span><br><span class="line">   |                   | Directory Should Exist | $&#123;path&#125; |</span><br></pre></td></tr></table></figure></div>

<h5 id="使用JSON格式的资源文件"><a href="#使用JSON格式的资源文件" class="headerlink" title="使用JSON格式的资源文件"></a>使用JSON格式的资源文件</h5><p>资源文件可以使用JSON创建，就像套件文件一样。这样的JSON资源文件必须使用标准的.json扩展名或自定义的.rsrc扩展名。它们在其他方面与普通资源文件的导入方式完全相同：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Resource         example.rsrc</span><br></pre></td></tr></table></figure></div>

<p>资源文件可以使用ResourceFile.to_json转换为JSON，并使用ResourceFile.from_json重新创建：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> ResourceFile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于文件系统上的数据创建资源文件。</span></span><br><span class="line">resource = ResourceFile.from_file_system(<span class="string">&#x27;example.resource&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将JSON数据保存到文件。</span></span><br><span class="line">resource.to_json(<span class="string">&#x27;example.rsrc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从JSON数据重新创建资源。</span></span><br><span class="line">resource = ResourceFile.from_json(<span class="string">&#x27;example.rsrc&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="变量文件-1"><a href="#变量文件-1" class="headerlink" title="变量文件"></a>变量文件</h4><p>变量文件包含可以在测试数据中使用的变量。变量也可以使用Variable部分创建或从命令行设置，但变量文件允许动态创建它们，并且使创建除字符串之外的其他变量值变得容易。</p>
<p>变量文件通常作为模块实现，有两种不同的方法来创建变量：</p>
<p><strong>从模块直接获取变量</strong></p>
<p>变量被指定为模块属性。在简单的情况下，语法非常简单，不需要真正的编程。例如，<code>MY_VAR = &#39;my value&#39;</code>创建一个变量<code>$&#123;MY_VAR&#125;</code>，其值为指定的文本。这种方法的一个限制是它不允许使用参数。</p>
<p><strong>从特殊函数获取变量</strong></p>
<p>变量文件可以有一个特殊的<code>get_variables</code>（或<code>getVariables</code>）方法，该方法返回变量作为映射。因为该方法可以接受参数，所以这种方法非常灵活。</p>
<p>或者，变量文件可以被实现为类，框架将实例化这些类。在这种情况下，也可以将变量创建为属性，或者从<code>get_variables</code>方法动态获取它们。变量文件也可以创建为YAML和JSON。</p>
<h5 id="使用变量文件"><a href="#使用变量文件" class="headerlink" title="使用变量文件"></a>使用变量文件</h5><h6 id="设置部分"><a href="#设置部分" class="headerlink" title="设置部分"></a>设置部分</h6><p>所有的测试数据文件都可以使用设置部分的Variables设置导入变量文件。变量文件通常使用文件的路径进行导入，就像使用Resource设置导入资源文件一样。与资源文件相似，导入的变量文件的路径被认为是相对于导入文件所在的目录的，如果没有找到，它会从模块搜索路径中的目录中搜索。路径也可以包含变量，斜杠在Windows上被转换为反斜杠。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Variables    myvariables.py</span><br><span class="line">Variables    ../data/variables.py</span><br><span class="line">Variables    $&#123;RESOURCES&#125;/common.yaml</span><br></pre></td></tr></table></figure></div>

<p>从Robot Framework 5.0开始，使用Python实现的变量文件也可以使用模块名称导入，就像库一样。使用这种方法时，模块需要在模块搜索路径中。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Variables    myvariables</span><br><span class="line">Variables    rootmodule.Variables</span><br></pre></td></tr></table></figure></div>

<p>如果一个变量文件接受参数，它们被指定为导入的变量文件的路径或名称之后：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Variables    arguments.py    arg1    $&#123;ARG2&#125;</span><br><span class="line">Variables    arguments    argument</span><br></pre></td></tr></table></figure></div>

<p>一个变量文件中的所有变量都在导入它的测试数据文件中可用。如果导入了几个变量文件，它们包含一个具有相同名称的变量，最早导入的文件中的那个将被使用。此外，在Variable部分创建的变量和从命令行设置的变量覆盖变量文件中的变量。</p>
<h6 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h6><p>使用变量文件的另一种方式是使用命令行选项<code>--variablefile</code>。变量文件是使用路径或模块名称引用的，就像使用Variables设置导入它们一样。可能的参数用冒号（:）连接到路径：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--variablefile myvariables.py</span><br><span class="line">--variablefile path/variables.py</span><br><span class="line">--variablefile /absolute/path/common.py</span><br><span class="line">--variablefile variablemodule</span><br><span class="line">--variablefile arguments.py:arg1:arg2</span><br><span class="line">--variablefile rootmodule.Variables:arg1:arg2</span><br></pre></td></tr></table></figure></div>



<p>从命令行使用的变量文件也会从模块搜索路径中搜索，就像在Setting部分导入的变量文件一样。相对路径被认为是相对于开始执行的目录的。</p>
<p>如果一个变量文件被给定为一个绝对的Windows路径，那么驱动器字母后的冒号不被认为是一个分隔符：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--variablefile C:\path\variables.py</span><br></pre></td></tr></table></figure></div>



<p>也可以使用分号（;）作为参数分隔符。这在变量文件参数本身包含冒号的情况下很有用，但在UNIX-like操作系统上需要用引号包围整个值：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--variablefile C:\path\variables.py;D:\data.xls</span><br><span class="line">--variablefile &quot;myvariables.py;argument:with:colons&quot;</span><br></pre></td></tr></table></figure></div>



<p>在命令行中使用的变量文件中的变量在所有测试数据文件中都全局可用，就像使用<code>--variable</code>选项设置的单个变量一样。如果使用了<code>--variablefile</code>和<code>--variable</code>选项，并且有相同名称的变量，那么使用<code>--variable</code>选项单独设置的那些将优先。              </p>
<h5 id="从模块直接获取变量"><a href="#从模块直接获取变量" class="headerlink" title="从模块直接获取变量"></a>从模块直接获取变量</h5><h6 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h6><p>当变量文件被使用时，它们被导入为Python模块，所有不以下划线（_）开头的模块级别属性默认被认为是变量。因为变量名是不区分大小写的，所以既可以使用小写也可以使用大写名称，但一般来说，推荐使用大写字母表示全局变量和属性。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = <span class="string">&quot;An example string&quot;</span></span><br><span class="line">ANOTHER_VARIABLE = <span class="string">&quot;This is pretty easy!&quot;</span></span><br><span class="line">INTEGER = <span class="number">42</span></span><br><span class="line">STRINGS = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;kolme&quot;</span>, <span class="string">&quot;four&quot;</span>]</span><br><span class="line">NUMBERS = [<span class="number">1</span>, INTEGER, <span class="number">3.14</span>]</span><br><span class="line">MAPPING = &#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的例子中，创建了变量<code>$&#123;VARIABLE&#125;</code>、<code>$&#123;ANOTHER VARIABLE&#125;</code>等。前两个变量是字符串，第三个是整数，然后是两个列表，最后的值是一个字典。所有这些变量都可以作为标量变量使用，列表和字典也可以作为列表变量，如<code>@&#123;STRINGS&#125;</code>（在字典的情况下，该变量只包含键），字典也可以作为字典变量，如<code>&amp;&#123;MAPPING&#125;</code>。</p>
<p>为了使创建列表变量或字典变量更明确，可以在变量名前加上<code>LIST__</code>或<code>DICT__</code>前缀：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">LIST__ANIMALS = [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>]</span><br><span class="line">DICT__FINNISH = OrderedDict([(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;kissa&quot;</span>), (<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;koira&quot;</span>)])</span><br></pre></td></tr></table></figure></div>

<p>这些前缀不会成为最终变量名的一部分，但它们会使Robot Framework验证值实际上是列表型或字典型。对于字典，实际存储的值也会转换为一个特殊的字典，这个字典也在Variable部分创建字典变量时使用。这些字典的值可以作为属性访问，如<code>$&#123;FINNISH.cat&#125;</code>。这些字典也是有序的，但保留源顺序也需要原始字典是有序的。</p>
<p>上面两个例子中的变量也可以使用下面的Variable部分创建。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;VARIABLE&#125;            An example string</span><br><span class="line">$&#123;ANOTHER VARIABLE&#125;    This is pretty easy!</span><br><span class="line">$&#123;INTEGER&#125;             $&#123;42&#125;</span><br><span class="line">@&#123;STRINGS&#125;             one          two           kolme         four</span><br><span class="line">@&#123;NUMBERS&#125;             $&#123;1&#125;         $&#123;INTEGER&#125;    $&#123;3.14&#125;</span><br><span class="line">&amp;&#123;MAPPING&#125;             one=$&#123;1&#125;     two=$&#123;2&#125;      three=$&#123;3&#125;</span><br><span class="line">@&#123;ANIMALS&#125;             cat          dog</span><br><span class="line">&amp;&#123;FINNISH&#125;             cat=kissa    dog=koira</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>从变量文件获取的字符串中不替换变量。例如，<code>VAR = &quot;an ${example}&quot;</code>将创建一个变量<code>${VAR}</code>，其值为字面字符串<code>an ${example}</code>，无论变量<code>${example}</code>是否存在。</p>

    </div>
  </div>     

<h6 id="使用对象作为值"><a href="#使用对象作为值" class="headerlink" title="使用对象作为值"></a>使用对象作为值</h6><p>变量文件中的变量不限于只有字符串或其他基本类型作为值，如Variable部分。相反，它们的变量可以包含任何对象。在下面的例子中，变量<code>$&#123;MAPPING&#125;</code>包含一个Python字典，还有两个变量是从同一文件中实现的自定义对象创建的。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAPPING = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">OBJ1 = MyObject(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">OBJ2 = MyObject(<span class="string">&#x27;Jane&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h6 id="动态创建变量"><a href="#动态创建变量" class="headerlink" title="动态创建变量"></a>动态创建变量</h6><p>因为变量文件是使用真正的编程语言创建的，所以它们可以有动态的逻辑来设置变量。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">USER = os.getlogin()                <span class="comment"># 当前登录名</span></span><br><span class="line">RANDOM_INT = random.randint(<span class="number">0</span>, <span class="number">10</span>)  <span class="comment"># 范围[0,10]内的随机整数</span></span><br><span class="line">CURRENT_TIME = time.asctime()       <span class="comment"># 时间戳，如 &#x27;Thu Apr  6 12:45:21 2006&#x27;</span></span><br><span class="line"><span class="keyword">if</span> time.localtime()[<span class="number">3</span>] &gt; <span class="number">12</span>:</span><br><span class="line">    AFTERNOON = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    AFTERNOON = <span class="literal">False</span></span><br></pre></td></tr></table></figure></div>

<p>上面的例子使用标准的Python库来设置不同的变量，但可以使用自己的代码来构造值。下面的例子说明了这个概念，但同样地，代码可以从数据库、外部文件甚至从用户那里读取数据。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_area</span>(<span class="params">diameter</span>):</span><br><span class="line">    radius = diameter / <span class="number">2</span></span><br><span class="line">    area = math.pi * radius * radius</span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line">AREA1 = get_area(<span class="number">1</span>)</span><br><span class="line">AREA2 = get_area(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<h6 id="选择要包含的变量"><a href="#选择要包含的变量" class="headerlink" title="选择要包含的变量"></a>选择要包含的变量</h6><p>当Robot Framework处理变量文件时，所有不以下划线开始的属性都被认为是变量。这意味着，即使是在变量文件中创建的函数或类，或者从其他地方导入的，也被认为是变量。例如，最后一个例子中除了<code>$&#123;AREA1&#125;</code>和<code>$&#123;AREA2&#125;</code>之外，还包含了变量<code>$&#123;math&#125;</code>和<code>$&#123;get_area&#125;</code>。</p>
<p>通常，额外的变量不会引起问题，但它们可能会覆盖一些其他变量，导致难以调试的错误。忽略其他属性的一种可能性是在它们前面加上下划线：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> _math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_area</span>(<span class="params">diameter</span>):</span><br><span class="line">    radius = diameter / <span class="number">2.0</span></span><br><span class="line">    area = _math.pi * radius * radius</span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line">AREA1 = _get_area(<span class="number">1</span>)</span><br><span class="line">AREA2 = _get_area(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果有大量的其他属性，而不是给它们所有的前缀，通常更容易使用一个特殊的属性<code>__all__</code>，并给它一个要作为变量处理的属性名列表。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;AREA1&#x27;</span>, <span class="string">&#x27;AREA2&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_area</span>(<span class="params">diameter</span>):</span><br><span class="line">    radius = diameter / <span class="number">2.0</span></span><br><span class="line">    area = math.pi * radius * radius</span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line">AREA1 = get_area(<span class="number">1</span>)</span><br><span class="line">AREA2 = get_area(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>__all__</code>属性也是，最初是由Python用来决定在使用<code>from modulename import *</code>语法时要导入哪些属性。</p>

    </div>
  </div>

<p>选择实际创建哪些变量的第三个选项是使用下面讨论的特殊<code>get_variables</code>函数。</p>
<h5 id="从特殊函数获取变量"><a href="#从特殊函数获取变量" class="headerlink" title="从特殊函数获取变量"></a>从特殊函数获取变量</h5><p>获取变量的另一种方法是在变量文件中有一个特殊的<code>get_variables</code>函数（也可以使用驼峰式语法<code>getVariables</code>）。如果存在这样的函数，Robot Framework会调用它，并期望以Python字典的形式接收变量，其中变量名作为键，变量值作为值。创建的变量可以像直接从模块获取变量一样用作标量、列表和字典，也可以使用<code>LIST__</code>和<code>DICT__</code>前缀来使创建列表和字典变量更明确。下面的例子在功能上与直接从模块获取变量的第一个例子完全相同。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_variables</span>():</span><br><span class="line">    variables = &#123;<span class="string">&quot;VARIABLE &quot;</span>: <span class="string">&quot;An example string&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;ANOTHER VARIABLE&quot;</span>: <span class="string">&quot;This is pretty easy!&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;INTEGER&quot;</span>: <span class="number">42</span>,</span><br><span class="line">                 <span class="string">&quot;STRINGS&quot;</span>: [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;kolme&quot;</span>, <span class="string">&quot;four&quot;</span>],</span><br><span class="line">                 <span class="string">&quot;NUMBERS&quot;</span>: [<span class="number">1</span>, <span class="number">42</span>, <span class="number">3.14</span>],</span><br><span class="line">                 <span class="string">&quot;MAPPING&quot;</span>: &#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> variables</span><br></pre></td></tr></table></figure></div>

<p><code>get_variables</code>也可以接受参数，这有助于改变实际创建的变量。函数的参数就像为Python函数设置的任何其他参数一样。当使用变量文件时，参数在变量文件的路径之后指定，在命令行中，它们与路径用冒号或分号分隔。</p>
<p>下面的虚拟例子展示了如何使用变量文件的参数。在一个更现实的例子中，参数可能是一个路径，指向一个要从中读取变量的外部文本文件或数据库。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">variables1 = &#123;<span class="string">&#x27;scalar&#x27;</span>: <span class="string">&#x27;Scalar variable&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;LIST__list&#x27;</span>: [<span class="string">&#x27;List&#x27;</span>,<span class="string">&#x27;variable&#x27;</span>]&#125;</span><br><span class="line">variables2 = &#123;<span class="string">&#x27;scalar&#x27;</span> : <span class="string">&#x27;Some other value&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;LIST__list&#x27;</span>: [<span class="string">&#x27;Some&#x27;</span>,<span class="string">&#x27;other&#x27;</span>,<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">              <span class="string">&#x27;extra&#x27;</span>: <span class="string">&#x27;variables1 does not have this at all&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_variables</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="keyword">if</span> arg == <span class="string">&#x27;one&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> variables1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> variables2</span><br></pre></td></tr></table></figure></div>

<p>从Robot Framework 7.0开始，变量文件的参数支持自动参数转换以及命名参数语法。例如，一个带有<code>get_variables(first: int = 0, second: str = &#39;&#39;)</code>的变量文件可以这样导入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Variables    example.py    42              # 转换为整数。</span><br><span class="line">Variables    example.py    second=value    # 命名参数语法。</span><br></pre></td></tr></table></figure></div>

<h5 id="将变量文件实现为类"><a href="#将变量文件实现为类" class="headerlink" title="将变量文件实现为类"></a>将变量文件实现为类</h5><p>也可以将变量文件实现为类。</p>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p>因为变量文件总是使用文件系统路径导入，所以类必须和它所在的模块有相同的名称。</p>
<p>框架将使用无参数创建类的实例，并从实例中获取变量。与模块一样，变量可以直接在实例中定义为属性，或者从特殊的<code>get_variables</code>方法中获取。</p>
<p>当变量直接在实例中定义时，所有包含可调用值的属性都被忽略，以避免从可能的方法中创建变量。如果实际上需要可调用的变量，需要使用其他方法来创建变量文件。</p>
<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><p>第一个示例从属性创建变量。它从类属性创建变量<code>$&#123;VARIABLE&#125;</code>和<code>@&#123;LIST&#125;</code>，从实例属性创建<code>$&#123;ANOTHER VARIABLE&#125;</code>。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticExample</span>:</span><br><span class="line">    variable = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">    LIST__list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    _not_variable = <span class="string">&#x27;starts with an underscore&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.another_variable = <span class="string">&#x27;another value&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>第二个示例利用动态方法获取变量。它只创建一个变量<code>$&#123;DYNAMIC VARIABLE&#125;</code>。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicExample</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_variables</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;dynamic variable&#x27;</span>: <span class="string">&#x27; &#x27;</span>.join(args)&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="变量文件作为YAML"><a href="#变量文件作为YAML" class="headerlink" title="变量文件作为YAML"></a>变量文件作为YAML</h5><p>变量文件也可以实现为YAML文件。YAML是一种数据序列化语言，具有简单且对人类友好的语法，但对机器来说解析起来仍然很容易。下面的例子演示了一个简单的YAML文件：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">string:</span>   <span class="string">Hello,</span> <span class="string">world!</span></span><br><span class="line"><span class="attr">integer:</span>  <span class="number">42</span></span><br><span class="line"><span class="attr">list:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">one</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">two</span></span><br><span class="line"><span class="attr">dict:</span></span><br><span class="line">  <span class="attr">one:</span> <span class="string">yksi</span></span><br><span class="line">  <span class="attr">two:</span> <span class="string">kaksi</span></span><br><span class="line">  <span class="attr">with spaces:</span> <span class="string">kolme</span></span><br></pre></td></tr></table></figure></div>

<p>YAML变量文件可以像普通的变量文件一样从命令行使用<code>--variablefile</code>选项、在Settings部分使用Variables设置，以及动态地使用Import Variables关键字。它们会被自动识别为其扩展名，必须是<code>.yaml</code>或<code>.yml</code>。如果导入了上面的YAML文件，它将创建与此Variable部分完全相同的变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;STRING&#125;     Hello, world!</span><br><span class="line">$&#123;INTEGER&#125;    $&#123;42&#125;</span><br><span class="line">@&#123;LIST&#125;       one         two</span><br><span class="line">&amp;&#123;DICT&#125;       one=yksi    two=kaksi    with spaces=kolme</span><br></pre></td></tr></table></figure></div>

<p>用作变量文件的YAML文件必须始终在顶层是映射。如上例所示，映射中的键和值分别成为变量名和值。变量值可以是YAML语法支持的任何数据类型。如果名称或值包含非ASCII字符，YAML变量文件必须是UTF-8编码的。</p>
<p>用作值的映射会自动转换为特殊的字典，这些字典也在Variable部分创建字典变量时使用。最重要的是，这些字典的值可以作为属性访问，如<code>$&#123;DICT.one&#125;</code>，假设它们的名称作为Python属性名称是有效的。如果名称包含空格或者其他不是有效属性名称的字符，总是可以使用像<code>$&#123;DICT&#125;[with spaces]</code>这样的语法访问字典值。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>使用Robot Framework的YAML文件需要安装PyYAML模块。通常可以使用pip安装它，像这样：<code>pip install pyyaml</code>。</p>

    </div>
  </div>

<h5 id="变量文件作为JSON"><a href="#变量文件作为JSON" class="headerlink" title="变量文件作为JSON"></a>变量文件作为JSON</h5><p>变量文件也可以实现为JSON文件。与上一节讨论的YAML一样，JSON是一种针对人类和机器的数据序列化格式。它基于JavaScript语法，虽然不如YAML对人类友好，但仍然相对容易理解和修改。下面的例子包含了与早期YAML例子完全相同的数据：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;string&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello, world!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;integer&quot;</span><span class="punctuation">:</span> <span class="number">42</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;one&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;two&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dict&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;one&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yksi&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;two&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kaksi&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;with spaces&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kolme&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>JSON变量文件会被自动识别为它们的<code>.json</code>扩展名，它们可以像YAML变量文件一样使用。它们对结构、编码等的要求也完全相同。与YAML不同，Python支持JSON，所以不需要安装额外的模块。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>对JSON变量文件的支持是Robot Framework 6.1中的新特性。</p>

    </div>
  </div>

<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>本节描述了可以用来控制测试执行流程的各种结构。这些结构在大多数编程语言中都很常见，它们允许条件执行，重复执行一组关键字和进行精细的错误处理。出于可读性的原因，应谨慎使用这些结构，并且更复杂的用例最好在测试库中实现。</p>
<h4 id="FOR循环"><a href="#FOR循环" class="headerlink" title="FOR循环"></a>FOR循环</h4><p>在测试自动化中，重复执行相同的操作是很常见的需求。在Robot Framework中，测试库可以有任何类型的循环结构，大多数时候应该在它们中实现循环。Robot Framework也有自己的FOR循环语法，这在需要重复执行来自不同库的关键字时非常有用。</p>
<p>FOR循环可以用于测试用例和用户关键字。除了非常简单的情况外，用户关键字更好，因为它们隐藏了FOR循环引入的复杂性。基本的FOR循环语法，FOR item IN sequence，源自Python，但其他各种编程语言也支持类似的语法。</p>
<h5 id="简单的FOR循环"><a href="#简单的FOR循环" class="headerlink" title="简单的FOR循环"></a>简单的FOR循环</h5><p>在普通的FOR循环中，一个变量根据一组值被赋值，每次迭代一个值。语法以FOR（区分大小写）作为标记开始，然后是循环变量，然后是一个必须的IN（区分大小写）作为分隔符，最后是要迭代的值。这些值可以包含变量，包括列表变量。</p>
<p>在FOR循环中使用的关键字在以下的行中，循环以END（区分大小写）在其自己的行中结束。循环内的关键字不需要缩进，但强烈建议缩进，以使语法更易于阅读。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    FOR    $&#123;animal&#125;    IN    cat    dog</span><br><span class="line">        Log    $&#123;animal&#125;</span><br><span class="line">        Log    2nd keyword</span><br><span class="line">    END</span><br><span class="line">    Log    Outside loop</span><br><span class="line"></span><br><span class="line">Second Example</span><br><span class="line">    FOR    $&#123;var&#125;    IN    one    two    $&#123;3&#125;    four    $&#123;five&#125;</span><br><span class="line">    ...    kuusi    7    eight    nine    $&#123;last&#125;</span><br><span class="line">        Log    $&#123;var&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>上面的Example中的FOR循环执行了两次，所以首先循环变量<code>$&#123;animal&#125;</code>的值是cat，然后是dog。循环由两个Log关键字组成。在第二个例子中，循环值被分成两行，循环总共运行了十次。</p>
<p>使用列表变量的FOR循环通常很方便。下面的例子说明了这一点，其中<code>@&#123;ELEMENTS&#125;</code>包含了一个任意长的元素列表，关键字Start Element被用于逐一使用所有的元素。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    FOR    $&#123;element&#125;    IN    @&#123;ELEMENTS&#125;</span><br><span class="line">        Start Element    $&#123;element&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="旧的FOR循环语法"><a href="#旧的FOR循环语法" class="headerlink" title="旧的FOR循环语法"></a>旧的FOR循环语法</h5><p>在Robot Framework 3.1之前，FOR循环的语法与现在不同。开始循环的标记是:FOR而不是FOR，循环内容需要用反斜杠明确标记，而不是使用END标记来结束循环。上面的第一个例子使用旧语法会是这样的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    :FOR    $&#123;animal&#125;    IN    cat    dog</span><br><span class="line">    \    Log    $&#123;animal&#125;</span><br><span class="line">    \    Log    2nd keyword</span><br><span class="line">    Log    Outside loop</span><br></pre></td></tr></table></figure></div>

<p>旧语法在Robot Framework 3.2中被弃用，并在Robot Framework 4.0中完全移除。</p>
<h5 id="嵌套FOR循环"><a href="#嵌套FOR循环" class="headerlink" title="嵌套FOR循环"></a>嵌套FOR循环</h5><p>从Robot Framework 4.0开始，可以通过在另一个循环内添加循环来简单地使用嵌套FOR循环：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Handle Table</span><br><span class="line">    [Arguments]    @&#123;table&#125;</span><br><span class="line">    FOR    $&#123;row&#125;    IN    @&#123;table&#125;</span><br><span class="line">        FOR    $&#123;cell&#125;    IN    @&#123;row&#125;</span><br><span class="line">            Handle Cell    $&#123;cell&#125;</span><br><span class="line">        END</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>可以有多个嵌套级别，循环也可以与其他控制结构组合：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Multiple nesting levels</span><br><span class="line">    FOR    $&#123;root&#125;    IN    r1    r2</span><br><span class="line">        FOR    $&#123;child&#125;    IN    c1   c2    c3</span><br><span class="line">            FOR    $&#123;grandchild&#125;    IN    g1    g2</span><br><span class="line">                Log Many    $&#123;root&#125;    $&#123;child&#125;    $&#123;grandchild&#125;</span><br><span class="line">            END</span><br><span class="line">        END</span><br><span class="line">        FOR    $&#123;sibling&#125;    IN    s1    s2    s3</span><br><span class="line">            IF    &#x27;$&#123;sibling&#125;&#x27; != &#x27;s2&#x27;</span><br><span class="line">                Log Many    $&#123;root&#125;    $&#123;sibling&#125;</span><br><span class="line">            END</span><br><span class="line">        END</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="使用多个循环变量"><a href="#使用多个循环变量" class="headerlink" title="使用多个循环变量"></a>使用多个循环变量</h5><p>通过在FOR和IN标记之间使用多个循环变量，可以在一次迭代中遍历多个值。可以有任意数量的循环变量，但值的数量必须能被变量的数量整除。每次迭代消耗的值的数量与变量的数量相同。</p>
<p>如果有很多值需要迭代，通常方便的做法是将它们组织在循环变量下面，如下面的例子中的第一个循环：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Multiple loop variables</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;english&#125;    $&#123;finnish&#125;    IN</span><br><span class="line">    ...    1           cat           kissa</span><br><span class="line">    ...    2           dog           koira</span><br><span class="line">    ...    3           horse         hevonen</span><br><span class="line">        Add Translation    $&#123;english&#125;    $&#123;finnish&#125;    $&#123;index&#125;</span><br><span class="line">    END</span><br><span class="line">    FOR    $&#123;name&#125;    $&#123;id&#125;    IN    @&#123;EMPLOYERS&#125;</span><br><span class="line">        Create    $&#123;name&#125;    $&#123;id&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="FOR-IN-RANGE循环"><a href="#FOR-IN-RANGE循环" class="headerlink" title="FOR-IN-RANGE循环"></a>FOR-IN-RANGE循环</h5><p>前一节中的所有FOR循环都是遍历一个序列。这是最常见的用例，但有时候需要一个循环执行特定次数。为此，Robot Framework有一个特殊的FOR index IN RANGE limit循环语法，它源自Python中使用内置的range()函数的类似习语。</p>
<p>与其他FOR循环一样，FOR-IN-RANGE循环以FOR开始，后面跟着一个循环变量。在这种格式中，只能有一个循环变量，它包含当前的循环索引。在变量之后，必须有IN RANGE标记（区分大小写），后面跟着循环限制。</p>
<p>在最简单的情况下，只指定了循环的上限。在这种情况下，循环索引从零开始，增加一直到，但不包括，限制。也可以给出开始和结束限制。然后索引从开始限制开始，但增加类似于简单情况。最后，也可以给出步长值，指定要使用的增量。如果步长是负的，它被用作递减。</p>
<p>可以使用简单的算术，如加法和减法，与范围限制一起使用。当限制用变量指定时，这特别有用。开始、结束和步长通常给出为整数，但也可以使用浮点值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Only upper limit</span><br><span class="line">    [Documentation]    Loops over values from 0 to 9.</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    10</span><br><span class="line">        Log    $&#123;index&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Start and end</span><br><span class="line">    [Documentation]    Loops over values from 1 to 10.</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    1    11</span><br><span class="line">        Log    $&#123;index&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Also step given</span><br><span class="line">    [Documentation]    Loops over values 5, 15, and 25.</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    5    26    10</span><br><span class="line">        Log    $&#123;index&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Negative step</span><br><span class="line">    [Documentation]    Loops over values 13, 3, and -7.</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    13    -13    -10</span><br><span class="line">        Log    $&#123;index&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Arithmetic</span><br><span class="line">    [Documentation]    Arithmetic with variable.</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    $&#123;var&#125; + 1</span><br><span class="line">        Log    $&#123;index&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Float parameters</span><br><span class="line">    [Documentation]    Loops over values 3.14, 4.34, and 5.54.</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    3.14    6.09    1.2</span><br><span class="line">        Log    $&#123;index&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>



<h5 id="FOR-IN-ENUMERATE循环"><a href="#FOR-IN-ENUMERATE循环" class="headerlink" title="FOR-IN-ENUMERATE循环"></a>FOR-IN-ENUMERATE循环</h5><p>有时候，遍历列表并跟踪在列表中的位置是很有用的。Robot Framework有一个特殊的FOR index … IN ENUMERATE …语法来处理这种情况。这种语法源自Python内置的enumerate()函数。</p>
<p>FOR-IN-ENUMERATE循环的语法就像常规的FOR循环语法一样，只是变量和值之间的分隔符是IN ENUMERATE（区分大小写）。通常，它们被用来在任何其他循环变量之前有一个额外的索引变量。默认情况下，索引在第一次迭代时的值为0，第二次迭代时的值为1，依此类推。</p>
<p>例如，下面的两个测试用例做了同样的事情：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">@&#123;LIST&#125;         a    b    c</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Manage index manually</span><br><span class="line">    $&#123;index&#125; =    Set Variable    -1</span><br><span class="line">    FOR    $&#123;item&#125;    IN    @&#123;LIST&#125;</span><br><span class="line">        $&#123;index&#125; =    Evaluate    $&#123;index&#125; + 1</span><br><span class="line">        My Keyword    $&#123;index&#125;    $&#123;item&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">FOR-IN-ENUMERATE</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;item&#125;    IN ENUMERATE    @&#123;LIST&#125;</span><br><span class="line">        My Keyword    $&#123;index&#125;    $&#123;item&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>从Robot Framework 4.0开始，可以通过在FOR … IN ENUMERATE …头部的最后一项使用start&#x3D;<index>语法来指定自定义的开始索引：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">@&#123;LIST&#125;         a    b    c</span><br><span class="line">$&#123;START&#125;        10</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">FOR-IN-ENUMERATE with start</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;item&#125;    IN ENUMERATE    @&#123;LIST&#125;    start=1</span><br><span class="line">        My Keyword    $&#123;index&#125;    $&#123;item&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Start as variable</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;item&#125;    IN ENUMERATE    @&#123;LIST&#125;    start=$&#123;start&#125;</span><br><span class="line">        My Keyword    $&#123;index&#125;    $&#123;item&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>start&#x3D;<index>语法必须在FOR头部明确使用，它不能自身来自变量。如果要枚举的最后一个实际项以start&#x3D;开始，需要像start&#x3D;这样进行转义。</p>
<p>就像常规的FOR循环一样，只要列表中的值的数量能被循环变量的数量（不包括索引变量）整除，就可以在每次循环迭代中遍历多个值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">FOR-IN-ENUMERATE with two values per iteration</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;en&#125;    $&#123;fi&#125;    IN ENUMERATE</span><br><span class="line">    ...    cat      kissa</span><br><span class="line">    ...    dog      koira</span><br><span class="line">    ...    horse    hevonen</span><br><span class="line">        Log    &quot;$&#123;en&#125;&quot; in English is &quot;$&#123;fi&#125;&quot; in Finnish (index: $&#123;index&#125;)</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>如果只使用一个循环变量与FOR-IN-ENUMERATE循环，那个变量将成为一个包含索引和迭代值的Python元组：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">FOR-IN-ENUMERATE with one loop variable</span><br><span class="line">    FOR    $&#123;x&#125;    IN ENUMERATE    @&#123;LIST&#125;</span><br><span class="line">        Length Should Be    $&#123;x&#125;    2</span><br><span class="line">        Log    Index is $&#123;x&#125;[0] and item is $&#123;x&#125;[1].</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>只使用一个循环变量的FOR-IN-ENUMERATE循环是Robot Framework 3.2中的新特性。</p>

    </div>
  </div>

<h5 id="FOR-IN-ZIP循环"><a href="#FOR-IN-ZIP循环" class="headerlink" title="FOR-IN-ZIP循环"></a>FOR-IN-ZIP循环</h5><p>有些测试会构建几个相关的列表，然后一起遍历它们。Robot Framework为这种情况提供了一个快捷方式：FOR … IN ZIP …，这是从Python内置的zip()函数派生出来的。</p>
<p>这可能最容易通过一个例子来展示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">@&#123;NUMBERS&#125;       $&#123;1&#125;    $&#123;2&#125;    $&#123;5&#125;</span><br><span class="line">@&#123;NAMES&#125;         one     two     five</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Iterate over two lists manually</span><br><span class="line">    $&#123;length&#125;=    Get Length    $&#123;NUMBERS&#125;</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    $&#123;length&#125;</span><br><span class="line">        Log Many    $&#123;NUMBERS&#125;[$&#123;index&#125;]    $&#123;NAMES&#125;[$&#123;index&#125;]</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">FOR-IN-ZIP</span><br><span class="line">    FOR    $&#123;number&#125;    $&#123;name&#125;    IN ZIP    $&#123;NUMBERS&#125;    $&#123;NAMES&#125;</span><br><span class="line">        Log Many    $&#123;number&#125;    $&#123;name&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>如上面的例子所示，FOR-IN-ZIP循环需要在循环变量和值之间有自己的自定义分隔符IN ZIP（区分大小写）。与FOR-IN-ZIP循环一起使用的值必须是列表或类似列表的对象。</p>
<p>要迭代的项目必须始终以标量变量（如${items}）或列表变量（如@{lists}）的形式给出，这些变量产生实际的迭代列表。前一种方法更常见，已经在上面演示过。后一种方法的工作方式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">@&#123;NUMBERS&#125;       $&#123;1&#125;    $&#123;2&#125;    $&#123;5&#125;</span><br><span class="line">@&#123;NAMES&#125;         one     two     five</span><br><span class="line">@&#123;LISTS&#125;         $&#123;NUMBERS&#125;    $&#123;NAMES&#125;</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">FOR-IN-ZIP with lists from variable</span><br><span class="line">    FOR    $&#123;number&#125;    $&#123;name&#125;    IN ZIP    @&#123;LISTS&#125;</span><br><span class="line">        Log Many    $&#123;number&#125;    $&#123;name&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>要迭代的列表的数量不受限制，但必须与循环变量的数量匹配。或者，可以只有一个循环变量，然后它变成一个Python元组，获取所有列表的项目。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">@&#123;ABC&#125;           a    b    c</span><br><span class="line">@&#123;XYZ&#125;           x    y    z</span><br><span class="line">@&#123;NUM&#125;           1    2    3</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">FOR-IN-ZIP with multiple lists</span><br><span class="line">    FOR    $&#123;a&#125;    $&#123;x&#125;    $&#123;n&#125;    IN ZIP    $&#123;ABC&#125;    $&#123;XYZ&#125;    $&#123;NUM&#125;</span><br><span class="line">        Log Many    $&#123;a&#125;    $&#123;x&#125;    $&#123;n&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">FOR-IN-ZIP with one variable</span><br><span class="line">    FOR    $&#123;items&#125;    IN ZIP    $&#123;ABC&#125;    $&#123;XYZ&#125;    $&#123;NUM&#125;</span><br><span class="line">        Length Should Be    $&#123;items&#125;    3</span><br><span class="line">        Log Many    $&#123;items&#125;[0]    $&#123;items&#125;[1]    $&#123;items&#125;[2]</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>从Robot Framework 6.1开始，可以配置如果迭代的项目的长度不同应该怎么做。默认情况下，最短的项目定义了有多少次迭代，较长的项目的末尾的值被忽略。这可以通过使用mode选项来改变，该选项有三个可能的值：</p>
<ul>
<li>STRICT：项目必须有相等的长度。如果没有，执行失败。这与使用Python的zip函数的strict&#x3D;True是一样的。</li>
<li>SHORTEST：较长的项目中的项目被忽略。只要其中一个项目被耗尽，就支持无限迭代器。这是默认行为。</li>
<li>LONGEST：最长的项目定义了有多少次迭代。较短的项目中缺失的值用fill选项指定的值填充，如果没有使用fill选项，则用None填充。这与使用Python的zip_longest函数是一样的，只是它有fillvalue参数而不是fill。</li>
</ul>
<p>以下示例说明了所有这些模式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">@&#123;CHARACTERS&#125;     a    b    c    d    f</span><br><span class="line">@&#123;NUMBERS&#125;        1    2    3</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">STRICT mode</span><br><span class="line">    [Documentation]    由于列表长度不同，此循环失败。</span><br><span class="line">    FOR    $&#123;c&#125;    $&#123;n&#125;    IN ZIP    $&#123;CHARACTERS&#125;    $&#123;NUMBERS&#125;    mode=STRICT</span><br><span class="line">        Log    $&#123;c&#125;: $&#123;n&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">SHORTEST mode</span><br><span class="line">    [Documentation]    此循环执行三次。</span><br><span class="line">    FOR    $&#123;c&#125;    $&#123;n&#125;    IN ZIP    $&#123;CHARACTERS&#125;    $&#123;NUMBERS&#125;    mode=SHORTEST</span><br><span class="line">        Log    $&#123;c&#125;: $&#123;n&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">LONGEST mode</span><br><span class="line">    [Documentation]    此循环执行五次。</span><br><span class="line">    ...                在最后两轮中，`$&#123;n&#125;`的值为`None`。</span><br><span class="line">    FOR    $&#123;c&#125;    $&#123;n&#125;    IN ZIP    $&#123;CHARACTERS&#125;    $&#123;NUMBERS&#125;    mode=LONGEST</span><br><span class="line">        Log    $&#123;c&#125;: $&#123;n&#125;</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">LONGEST mode with custom fill value</span><br><span class="line">    [Documentation]    此循环执行五次。</span><br><span class="line">    ...                在最后两轮中，`$&#123;n&#125;`的值为`0`。</span><br><span class="line">    FOR    $&#123;c&#125;    $&#123;n&#125;    IN ZIP    $&#123;CHARACTERS&#125;    $&#123;NUMBERS&#125;    mode=LONGEST    fill=0</span><br><span class="line">        Log    $&#123;c&#125;: $&#123;n&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果列表长度不同的行为将在未来改变，以便STRICT模式将成为默认。如果不希望这样，需要显式使用SHORTEST模式。</p>

    </div>
  </div>

<h5 id="字典迭代"><a href="#字典迭代" class="headerlink" title="字典迭代"></a>字典迭代</h5><p>普通的FOR循环和FOR-IN-ENUMERATE循环支持在字典中迭代键和值。这种语法要求至少有一个循环值是字典变量。可以使用多个字典变量，并以key&#x3D;value语法给出额外的项。项目按照它们定义的顺序进行迭代，如果同一个键获得多个值，将使用最后的值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">&amp;&#123;DICT&#125;          a=1    b=2    c=3</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Dictionary iteration with FOR loop</span><br><span class="line">    FOR    $&#123;key&#125;    $&#123;value&#125;    IN    &amp;&#123;DICT&#125;</span><br><span class="line">        Log    Key is &#x27;$&#123;key&#125;&#x27; and value is &#x27;$&#123;value&#125;&#x27;.</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Dictionary iteration with FOR-IN-ENUMERATE loop</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;key&#125;    $&#123;value&#125;    IN ENUMERATE    &amp;&#123;DICT&#125;</span><br><span class="line">        Log    On round $&#123;index&#125; key is &#x27;$&#123;key&#125;&#x27; and value is &#x27;$&#123;value&#125;&#x27;.</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Multiple dictionaries and extra items in &#x27;key=value&#x27; syntax</span><br><span class="line">    &amp;&#123;more&#125; =    Create Dictionary    e=5    f=6</span><br><span class="line">    FOR    $&#123;key&#125;    $&#123;value&#125;    IN    &amp;&#123;DICT&#125;    d=4    &amp;&#123;more&#125;    g=7</span><br><span class="line">        Log    Key is &#x27;$&#123;key&#125;&#x27; and value is &#x27;$&#123;value&#125;&#x27;.</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>通常，最容易使用字典迭代语法，使键和值获得单独的变量，就像上面的例子那样。对于普通的FOR循环，也可以只使用一个变量，该变量将成为一个包含键和值的元组。如果只使用一个变量与FOR-IN-ENUMERATE循环，它将成为一个包含索引、键和值的元组。FOR-IN-ENUMERATE循环中的两个变量意味着将索引赋给第一个变量，并使第二个变量成为一个包含键和值的元组。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">One loop variable</span><br><span class="line">    FOR    $&#123;item&#125;    IN    &amp;&#123;DICT&#125;</span><br><span class="line">        Log    Key is &#x27;$&#123;item&#125;[0]&#x27; and value is &#x27;$&#123;item&#125;[1]&#x27;.</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">One loop variable with FOR-IN-ENUMERATE</span><br><span class="line">    FOR    $&#123;item&#125;    IN ENUMERATE    &amp;&#123;DICT&#125;</span><br><span class="line">        Log    On round $&#123;item&#125;[0] key is &#x27;$&#123;item&#125;[1]&#x27; and value is &#x27;$&#123;item&#125;[2]&#x27;.</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Two loop variables with FOR-IN-ENUMERATE</span><br><span class="line">    FOR    $&#123;index&#125;    $&#123;item&#125;    IN ENUMERATE    &amp;&#123;DICT&#125;</span><br><span class="line">        Log    On round $&#123;index&#125; key is &#x27;$&#123;item&#125;[0]&#x27; and value is &#x27;$&#123;item&#125;[1]&#x27;.</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>除了在字典中迭代名称和值，还可以迭代键，然后可能根据键获取值。这种语法需要将字典作为列表变量使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Iterate over keys</span><br><span class="line">    FOR    $&#123;key&#125;    IN    @&#123;DICT&#125;</span><br><span class="line">        Log    Key is &#x27;$&#123;key&#125;&#x27; and value is &#x27;$&#123;DICT&#125;[$&#123;key&#125;]&#x27;.</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在字典中迭代键和值是Robot Framework 3.2中的新特性。在早期版本中，可以像上面的最后一个例子那样迭代字典键。</p>

    </div>
  </div>

<h5 id="移除不必要的关键字输出"><a href="#移除不必要的关键字输出" class="headerlink" title="移除不必要的关键字输出"></a>移除不必要的关键字输出</h5><p>具有多次迭代的FOR循环通常会产生大量的输出，并显著增加生成的输出和日志文件的大小。可以使用–removekeywords和–flattenkeywords命令行选项移除或扁平化不必要的关键字。</p>
<h5 id="重复单个关键字"><a href="#重复单个关键字" class="headerlink" title="重复单个关键字"></a>重复单个关键字</h5><p>在只需要重复一个关键字的情况下，FOR循环可能过于复杂。在这些情况下，通常更容易使用BuiltIn关键字Repeat Keyword。这个关键字接受一个关键字和重复它的次数作为参数。重复关键字的次数可以有一个可选的后缀times或x，使语法更易读。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Repeat Keyword    5    Some Keyword    arg1    arg2</span><br><span class="line">    Repeat Keyword    42 times    My Keyword</span><br><span class="line">    Repeat Keyword    $&#123;var&#125;    Another Keyword    argument</span><br></pre></td></tr></table></figure></div>

<h4 id="WHILE循环"><a href="#WHILE循环" class="headerlink" title="WHILE循环"></a>WHILE循环</h4><p>WHILE循环结合了FOR循环和IF&#x2F;ELSE结构的特性。它们指定一个条件，并在条件保持为真的情况下重复循环体。例如，可以利用这一点来重复一个非确定性序列，直到发生期望的结果，或者在某些情况下，它们可以用作FOR循环的替代品。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>WHILE循环是Robot Framework 5.0中的新特性。</p>

    </div>
  </div>

<h5 id="基本的WHILE语法"><a href="#基本的WHILE语法" class="headerlink" title="基本的WHILE语法"></a>基本的WHILE语法</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    VAR    $&#123;rc&#125;   1</span><br><span class="line">    WHILE    $&#123;rc&#125; != 0</span><br><span class="line">        $&#123;rc&#125; =    Keyword that returns zero on success</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>WHILE循环的条件在Python中进行评估，因此可以使用Python内置的如len()等函数，并自动导入模块以支持像math.pi * math.pow({radius}, 2) &lt; 10这样的用法。像上面的例子中的radius,2)&lt;10这样的用法。像上面的例子中的{rc}这样的普通变量在评估之前被替换，但变量也可以在评估命名空间中使用特殊的$rc语法。后一种方法在变量的字符串表示不能直接用于条件时很方便。例如，字符串需要引号，多行字符串和包含引号的字符串本身会引起额外的问题。有关评估语法的更多信息和示例，请参见评估表达式附录。</p>
<p>从Robot Framework 6.1开始，WHILE语句中的条件可以省略。这被解释为条件始终为真，这在使用下面描述的limit选项时可能有用。</p>
<h5 id="限制WHILE循环的迭代次数"><a href="#限制WHILE循环的迭代次数" class="headerlink" title="限制WHILE循环的迭代次数"></a>限制WHILE循环的迭代次数</h5><p>对于WHILE循环，总是有可能实现一个无限循环，无论是有意的还是无意的。这发生在循环条件永远不变为假的情况下。虽然在应用程序编程中无限循环有一些用途，但在自动化中，无限循环很少是期望的结果。如果在Robot Framework中发生这样的循环，必须强制停止执行，并且不能创建日志或报告。因此，Robot Framework中的WHILE循环默认有10 000次迭代的限制。如果超过了限制，循环就会失败。</p>
<p>可以使用limit配置参数设置限制，要么作为最大迭代次数，要么作为整个循环的最大时间。当限制是迭代次数时，可以只使用像100这样的整数，并在值后面添加times或x后缀，如100 times。当限制是超时时，可以使用像10 s或1 hour 10 minutes这样的时间字符串。也可以通过使用NONE（不区分大小写）来完全禁用限制。下面的示例说明了所有这些选项。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Limit as iteration count</span><br><span class="line">    WHILE    True    limit=100</span><br><span class="line">        Log    This is run 100 times.</span><br><span class="line">    END</span><br><span class="line">    WHILE    True    limit=10 times</span><br><span class="line">        Log    This is run 10 times.</span><br><span class="line">    END</span><br><span class="line">    WHILE    True    limit=42x</span><br><span class="line">        Log    This is run 42 times.</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Limit as time</span><br><span class="line">    WHILE    True    limit=10 seconds</span><br><span class="line">        Log    This is run 10 seconds.</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">No limit</span><br><span class="line">    WHILE    True    limit=NONE</span><br><span class="line">        Log    This runs forever.</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在Robot Framework 7.0中，使用times和x后缀与迭代次数是新特性。</p>

    </div>
  </div>

<p>如果超过了限制，循环中的关键字不会被强制停止。相反，循环将以类似于循环条件变为假的方式退出。主要的区别是，在这种情况下，循环的状态将是FAIL。</p>
<p>从Robot Framework 6.1开始，可以使用on_limit参数来配置超过限制时的行为。它支持两个值pass和fail，不区分大小写。如果值是pass，当达到限制时，执行将正常继续，WHILE循环的状态将是PASS。fail的值与默认行为类似，例如，如果超过了限制，循环和测试将失败。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Continue when iteration limit is reached</span><br><span class="line">    WHILE    True    limit=5    on_limit=pass</span><br><span class="line">        Log    Loop will be executed five times</span><br><span class="line">    END</span><br><span class="line">    Log    This will be executed normally.</span><br><span class="line"></span><br><span class="line">Continue when time limit is reached</span><br><span class="line">    WHILE    True    limit=10s    on_limit=pass</span><br><span class="line">        Log    Loop will be executed for 10 seconds.</span><br><span class="line">        Sleep   0.5s</span><br><span class="line">    END</span><br><span class="line">    Log    This will be executed normally.</span><br></pre></td></tr></table></figure></div>

<p>默认情况下，当达到限制时，会引发错误消息WHILE loop was aborted because it did not finish within the limit of 0.5 seconds. Use the ‘limit’ argument to increase or remove the limit if needed.。从Robot Framework 6.1开始，可以使用on_limit_message配置参数更改错误消息。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Limit as iteration count</span><br><span class="line">    WHILE    True    limit=0.5s    on_limit_message=Custom While loop error message</span><br><span class="line">        Log    This is run 0.5 seconds.</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>on_limit_message配置参数是Robot Framework 6.1中的新特性。</p>

    </div>
  </div>

<h5 id="嵌套WHILE循环"><a href="#嵌套WHILE循环" class="headerlink" title="嵌套WHILE循环"></a>嵌套WHILE循环</h5><p>WHILE循环可以嵌套，并且可以与其他控制结构组合：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Nesting WHILE</span><br><span class="line">    $&#123;x&#125; =   Set Variable    10</span><br><span class="line">    WHILE    $&#123;x&#125; &gt; 0</span><br><span class="line">        $&#123;y&#125; =   Set Variable    $&#123;x&#125;</span><br><span class="line">        WHILE    $&#123;y&#125; &gt; 0</span><br><span class="line">            $&#123;y&#125; =    Evaluate    $&#123;y&#125; - 1</span><br><span class="line">        END</span><br><span class="line">        IF    $&#123;x&#125; &gt; 5</span><br><span class="line">            $&#123;x&#125; =    Evaluate    $&#123;x&#125; - 1</span><br><span class="line">        ELSE</span><br><span class="line">            $&#123;x&#125; =    Evaluate    $&#123;x&#125; - 2</span><br><span class="line">        END</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="移除不必要的关键字输出-1"><a href="#移除不必要的关键字输出-1" class="headerlink" title="移除不必要的关键字输出"></a>移除不必要的关键字输出</h5><p>具有多次迭代的WHILE循环通常会产生大量的输出，并显著增加生成的输出和日志文件的大小。可以使用–removekeywords和–flattenkeywords命令行选项移除或扁平化不必要的关键字。</p>
<h4 id="使用BREAK和CONTINUE控制循环"><a href="#使用BREAK和CONTINUE控制循环" class="headerlink" title="使用BREAK和CONTINUE控制循环"></a>使用BREAK和CONTINUE控制循环</h4><p>FOR循环和WHILE循环的执行都可以用BREAK和CONTINUE语句来控制。前者提前退出整个循环，后者停止执行当前的循环迭代并继续下一个。在实践中，它们与Python、Java和许多其他编程语言中的break和continue语句具有相同的语义。</p>
<p>BREAK和CONTINUE通常在IF&#x2F;ELSE或TRY&#x2F;EXCEPT结构中有条件地使用，特别是与它们一起使用的内联IF语法通常很方便。这些语句必须在循环体中使用，可能在上述控制结构内部，并且在循环体中调用的关键字中使用它们是无效的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">BREAK with FOR</span><br><span class="line">    $&#123;text&#125; =    Set Variable    zero</span><br><span class="line">    FOR    $&#123;var&#125;    IN    one    two    three</span><br><span class="line">        IF    &#x27;$&#123;var&#125;&#x27; == &#x27;two&#x27;    BREAK</span><br><span class="line">        $&#123;text&#125; =    Set Variable    $&#123;text&#125;-$&#123;var&#125;</span><br><span class="line">    END</span><br><span class="line">    Should Be Equal    $&#123;text&#125;    zero-one</span><br><span class="line"></span><br><span class="line">CONTINUE with FOR</span><br><span class="line">    $&#123;text&#125; =    Set Variable    zero</span><br><span class="line">    FOR    $&#123;var&#125;    IN    one    two    three</span><br><span class="line">        IF    &#x27;$&#123;var&#125;&#x27; == &#x27;two&#x27;    CONTINUE</span><br><span class="line">        $&#123;text&#125; =    Set Variable    $&#123;text&#125;-$&#123;var&#125;</span><br><span class="line">    END</span><br><span class="line">    Should Be Equal    $&#123;text&#125;    zero-one-three</span><br><span class="line"></span><br><span class="line">CONTINUE and BREAK with WHILE</span><br><span class="line">    WHILE    True</span><br><span class="line">        TRY</span><br><span class="line">             $&#123;value&#125; =    Do Something</span><br><span class="line">        EXCEPT</span><br><span class="line">            CONTINUE</span><br><span class="line">        END</span><br><span class="line">        Do something with value    $&#123;value&#125;</span><br><span class="line">        BREAK</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Invalid BREAK usage</span><br><span class="line">    [Documentation]    BREAK and CONTINUE can only be used in the loop body,</span><br><span class="line">    ...                not in keywords used in the loop.</span><br><span class="line">    FOR    $&#123;var&#125;    IN    one    two    three</span><br><span class="line">        Invalid BREAK</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Invalid BREAK</span><br><span class="line">    [Documentation]    This keyword fails due to invalid syntax.</span><br><span class="line">    BREAK</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>BREAK和CONTINUE语句是Robot Framework 5.0中的新特性，与WHILE类似。早期版本支持使用BuiltIn关键字Exit For Loop、Exit For Loop If、Continue For Loop和Continue For Loop If来控制FOR循环。这些关键字仍然可以继续工作，但将来将被弃用和删除。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>也可以使用RETURN语句来退出循环。它只在循环用于用户关键字内部时才起作用。</p>

    </div>
  </div>

<h4 id="IF-ELSE语法"><a href="#IF-ELSE语法" class="headerlink" title="IF&#x2F;ELSE语法"></a>IF&#x2F;ELSE语法</h4><p>有时候，需要有条件地执行一些关键字。从Robot Framework 4.0开始，有一个单独的IF&#x2F;ELSE语法，但也有其他方式可以有条件地执行关键字。注意，如果逻辑变得复杂，通常最好将其移动到测试库中。</p>
<h5 id="基本的IF语法"><a href="#基本的IF语法" class="headerlink" title="基本的IF语法"></a>基本的IF语法</h5><p>Robot Framework的原生IF语法以IF（区分大小写）开始，并以END（区分大小写）结束。IF标记需要一个值，该值是要评估的条件。如果条件为真，则在IF和END标记之间的自己的行上执行关键字。强烈推荐在IF块中缩进关键字，但这不是强制的。</p>
<p>在下面的例子中，如果${rc}大于零，则执行关键字Some keyword和Another keyword：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">   IF    $&#123;rc&#125; &gt; 0</span><br><span class="line">       Some keyword</span><br><span class="line">       Another keyword</span><br><span class="line">   END</span><br></pre></td></tr></table></figure></div>

<p>条件在Python中进行评估，因此可以使用Python内置的如len()等函数，并自动导入模块以支持像platform.system() &#x3D;&#x3D; ‘Linux’和math.ceil({x}) &#x3D;&#x3D; 1这样的用法。像上面的例子中的x)&#x3D;&#x3D;1这样的用法。像上面的例子中的{rc}这样的普通变量在评估之前被替换，但变量也可以在评估命名空间中使用特殊的$rc语法。后一种方法在变量的字符串表示不能直接用于条件时很方便。例如，字符串需要引号，多行字符串和包含引号的字符串本身会引起额外的问题。有关评估语法的更多信息和示例，请参见评估表达式附录。</p>
<h5 id="ELSE分支"><a href="#ELSE分支" class="headerlink" title="ELSE分支"></a>ELSE分支</h5><p>像大多数其他支持条件执行的语言一样，Robot Framework的IF语法也支持ELSE分支，如果IF条件不为真，则执行ELSE分支。</p>
<p>在这个例子中，如果${rc}大于零，则执行Some keyword，否则执行Another keyword：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    IF    $&#123;rc&#125; &gt; 0</span><br><span class="line">        Some keyword</span><br><span class="line">    ELSE</span><br><span class="line">        Another keyword</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="ELSE-IF分支"><a href="#ELSE-IF分支" class="headerlink" title="ELSE IF分支"></a>ELSE IF分支</h5><p>Robot Framework还支持ELSE IF分支，它们有自己的条件，如果初始条件不为真，则评估这些条件。可以有任意数量的ELSE IF分支，它们按照指定的顺序进行。如果其中一个ELSE IF条件为真，则执行其后的块，并忽略剩余的ELSE IF分支。一个可选的ELSE分支可以跟在ELSE IF分支后面，如果所有条件都为假，则执行它。</p>
<p>在下面的例子中，根据${rc}是正数、负数、零还是其他东西（如字符串或None），执行不同的关键字：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    IF    $rc &gt; 0</span><br><span class="line">        Positive keyword</span><br><span class="line">    ELSE IF    $rc &lt; 0</span><br><span class="line">        Negative keyword</span><br><span class="line">    ELSE IF    $rc == 0</span><br><span class="line">        Zero keyword</span><br><span class="line">    ELSE</span><br><span class="line">        Fail    Unexpected rc: $&#123;rc&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>这个例子使用了特殊的rc格式的{rc}变量，以避免在它不是数字的情况下出现评估失败。有关这种语法的更多信息，请参见上述的评估表达式附录。</p>

    </div>
  </div>

<h5 id="内联IF"><a href="#内联IF" class="headerlink" title="内联IF"></a>内联IF</h5><p>如果需要执行只有一个语句的条件，那么普通的IF&#x2F;ELSE结构可能有点冗长。它的替代方案是使用内联IF语法，其中要执行的语句直接跟在IF标记和条件后面，不需要END标记。例如，下面的两个关键字是等价的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Normal IF</span><br><span class="line">    IF    $condition1</span><br><span class="line">        Keyword    argument</span><br><span class="line">    END</span><br><span class="line">    IF    $condition2</span><br><span class="line">        RETURN</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Inline IF</span><br><span class="line">    IF    $condition1    Keyword    argument</span><br><span class="line">    IF    $condition2    RETURN</span><br></pre></td></tr></table></figure></div>

<p>内联IF语法也支持ELSE和ELSE IF分支：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Inline IF/ELSE</span><br><span class="line">    IF    $condition    Keyword    argument    ELSE    Another Keyword</span><br><span class="line"></span><br><span class="line">Inline IF/ELSE IF/ELSE</span><br><span class="line">    IF    $cond1    Keyword 1    ELSE IF    $cond2    Keyword 2    ELSE IF    $cond3    Keyword 3    ELSE    Keyword 4</span><br></pre></td></tr></table></figure></div>

<p>如上面的后一个例子所示，带有几个ELSE IF和ELSE分支的内联IF开始变得难以理解。长的内联IF结构可以使用常见的…连续语法分成多行，但使用普通的IF&#x2F;ELSE结构或将逻辑移动到测试库可能是更好的主意。每个内联IF分支只能包含一个语句。如果需要更多的语句，需要使用普通的IF&#x2F;ELSE结构。</p>
<p>如果需要用内联IF进行赋值，要赋值的变量或变量必须在开始的IF之前。否则，逻辑与基于关键字返回值赋值变量的逻辑完全相同。如果使用了赋值并且没有运行任何分支，变量将获得None值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Inline IF/ELSE with assignment</span><br><span class="line">    $&#123;var&#125; =    IF    $condition    Keyword    argument    ELSE    Another Keyword</span><br><span class="line"></span><br><span class="line">Inline IF/ELSE with assignment having multiple variables</span><br><span class="line">    $&#123;host&#125;    $&#123;port&#125; =    IF    $production    Get Production Config    ELSE    Get Testing Config</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>内联IF语法是Robot Framework 5.0中的新特性。</p>

    </div>
  </div>

<h5 id="嵌套的IF结构"><a href="#嵌套的IF结构" class="headerlink" title="嵌套的IF结构"></a>嵌套的IF结构</h5><p>IF结构可以与其他IF结构和FOR循环嵌套。下面的例子使用了高级特性，如FOR-IN-ENUMERATE循环、带有用户关键字的命名只参数和内联Python评估语法 (<code>$&#123;&#123;len($&#123;items&#125;)&#125;&#125;</code>):</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Log items</span><br><span class="line">    [Arguments]    @&#123;items&#125;    $&#123;log_values&#125;=True</span><br><span class="line">    IF    not $&#123;items&#125;</span><br><span class="line">        Log to console    No items.</span><br><span class="line">    ELSE IF    len($&#123;items&#125;) == 1</span><br><span class="line">        IF    $&#123;log_values&#125;</span><br><span class="line">            Log to console    One item: $&#123;items&#125;[0]</span><br><span class="line">        ELSE</span><br><span class="line">            Log to console    One item.</span><br><span class="line">        END</span><br><span class="line">    ELSE</span><br><span class="line">        Log to console    $&#123;&#123;len($&#123;items&#125;)&#125;&#125; items.</span><br><span class="line">        IF    $&#123;log_values&#125;</span><br><span class="line">            FOR    $&#123;index&#125;    $&#123;item&#125;    IN ENUMERATE    @&#123;items&#125;    start=1</span><br><span class="line">                Log to console    Item $&#123;index&#125;: $&#123;item&#125;</span><br><span class="line">            END</span><br><span class="line">        END</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">No items</span><br><span class="line">    Log items</span><br><span class="line"></span><br><span class="line">One item without logging value</span><br><span class="line">    Log items    xxx    log_values=False</span><br><span class="line"></span><br><span class="line">Multiple items</span><br><span class="line">    Log items    a    b    c      </span><br></pre></td></tr></table></figure></div>

<h5 id="有条件地执行关键字的其他方式"><a href="#有条件地执行关键字的其他方式" class="headerlink" title="有条件地执行关键字的其他方式"></a>有条件地执行关键字的其他方式</h5><p>还有其他方法可以有条件地执行关键字：</p>
<ul>
<li>可以使用变量指定用作套件、测试和关键字的设置或拆卸的关键字的名称。这便于从命令行更改它们。</li>
<li>BuiltIn 关键字 Run Keyword 将实际执行的关键字作为参数，因此它可以是一个变量。例如，可以从早期的关键字动态获取变量的值，或者从命令行给出。</li>
<li>BuiltIn 关键字 Run Keyword If 和 Run Keyword Unless 分别只在某个表达式为真或假时执行一个命名关键字。一般推荐使用上面解释的新的 IF&#x2F;ELSE 语法。</li>
<li>另一个 BuiltIn 关键字，Set Variable If，可以根据给定的表达式动态设置变量。</li>
<li>有几个 BuiltIn 关键字允许只在测试用例或测试套件失败或通过时执行一个命名关键字。</li>
</ul>
<h4 id="TRY-EXCEPT语法"><a href="#TRY-EXCEPT语法" class="headerlink" title="TRY&#x2F;EXCEPT语法"></a>TRY&#x2F;EXCEPT语法</h4><p>当一个关键字失败时，Robot Framework的默认行为是停止当前的测试并执行可能的清理操作。然而，也可能需要在执行过程中处理这些失败。Robot Framework 5.0引入了原生的TRY&#x2F;EXCEPT语法来实现这个目的，但也有其他方式来处理错误。</p>
<p>Robot Framework的TRY&#x2F;EXCEPT语法受到Python的异常处理语法的启发。它有与Python相同的TRY、EXCEPT、ELSE和FINALLY分支，它们的工作方式也大致相同。一个区别是Python使用小写的try、except等，但在Robot Framework中，所有这种语法必须使用大写字母。更大的区别是，在Python中，异常是对象，而在Robot Framework中，处理的是字符串形式的错误消息。</p>
<h5 id="使用EXCEPT捕获异常"><a href="#使用EXCEPT捕获异常" class="headerlink" title="使用EXCEPT捕获异常"></a>使用EXCEPT捕获异常</h5><p>基本的TRY&#x2F;EXCEPT语法可以用来处理基于错误消息的失败：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">First example</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    Error message</span><br><span class="line">        Error Handler Keyword</span><br><span class="line">    END</span><br><span class="line">    Keyword Outside</span><br></pre></td></tr></table></figure></div>

<p>在上面的例子中，如果Some Keyword通过，EXCEPT分支不会运行，执行会在TRY&#x2F;EXCEPT结构之后继续。如果关键字以错误消息Error message（区分大小写）失败，那么执行EXCEPT分支。如果EXCEPT分支成功，执行会在TRY&#x2F;EXCEPT结构之后继续。如果它失败，测试失败并且剩余的关键字不会被执行。如果Some Keyword以任何其他异常失败，那么该失败不会被处理，测试失败而不执行剩余的关键字。</p>
<p>可以有多个EXCEPT分支。在这种情况下，它们会一个接一个地进行匹配，第一个匹配的分支会被执行。一个EXCEPT也可以有多个消息来匹配，如果其中任何一个消息匹配，那么这样的分支会被执行。在所有这些情况下，消息可以使用变量来指定，除了字面字符串。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Multiple EXCEPT branches</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    Error message    # Try matching this first.</span><br><span class="line">        Error Handler 1</span><br><span class="line">    EXCEPT    Another error    # Try this if above did not match.</span><br><span class="line">        Error Handler 2</span><br><span class="line">    EXCEPT    $&#123;message&#125;       # Last match attempt, this time using a variable.</span><br><span class="line">        Error Handler 3</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Multiple messages with one EXCEPT</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    Error message    Another error    $&#123;message&#125;    # Match any of these.</span><br><span class="line">        Error handler</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>也可以有一个没有消息的EXCEPT，在这种情况下，它匹配任何错误。只能有一个这样的EXCEPT，它必须在可能的其他EXCEPT分支之后：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Match any error</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT               # Match any error.</span><br><span class="line">        Error Handler</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Match any after testing more specific errors</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    Error message    # Try matching this first</span><br><span class="line">        Error Handler 1</span><br><span class="line">    EXCEPT                     # Match any that did not match the above.</span><br><span class="line">        Error Handler 2</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>无法捕获由无效语法引起的异常。</p>

    </div>
  </div>

<h5 id="使用模式匹配错误"><a href="#使用模式匹配错误" class="headerlink" title="使用模式匹配错误"></a>使用模式匹配错误</h5><p>默认情况下，使用EXCEPT匹配错误需要完全匹配。这可以通过将配置选项type&#x3D;作为except子句的参数来改变。该选项的有效值是GLOB、REGEXP或START（不区分大小写），分别用于进行全局模式匹配、正则表达式匹配或仅匹配错误的开头。使用值LITERAL具有与默认行为相同的效果。如果一个EXCEPT有多个消息，这个选项适用于所有的消息。该选项的值可以用变量来定义。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;MATCH TYPE&#125;     regexp</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Glob pattern</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    ValueError: *    type=GLOB</span><br><span class="line">        Error Handler 1</span><br><span class="line">    EXCEPT    [Ee]rror ?? occurred    $&#123;pattern&#125;    type=glob</span><br><span class="line">        Error Handler 2</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Regular expression</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    ValueError: .*    type=$&#123;MATCH TYPE&#125;</span><br><span class="line">        Error Handler 1</span><br><span class="line">    EXCEPT    [Ee]rror \\d+ occurred    type=Regexp    # Backslash needs to be escaped.</span><br><span class="line">        Error Handler 2</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Match start</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    ValueError:    $&#123;beginning&#125;    type=start</span><br><span class="line">        Error Handler</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Explicit exact match</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    ValueError: invalid literal for int() with base 10: &#x27;ooops&#x27;    type=LITERAL</span><br><span class="line">        Error Handler</span><br><span class="line">    EXCEPT    Error 13 occurred    type=LITERAL</span><br><span class="line">        Error Handler 2</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>记住，正则表达式中经常使用的反斜杠字符在Robot Framework数据中是转义字符。因此，在正则表达式中使用它时需要用另一个反斜杠来转义。</p>

    </div>
  </div>

<h5 id="捕获错误消息"><a href="#捕获错误消息" class="headerlink" title="捕获错误消息"></a>捕获错误消息</h5><p>当使用模式匹配错误，以及在没有任何消息匹配任何错误的情况下使用EXCEPT时，通常需要知道实际发生的错误。Robot Framework通过在EXCEPT语句的末尾添加AS  ${var}，使得可以将错误消息捕获到一个变量中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Capture error</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    ValueError: *    type=GLOB    AS   $&#123;error&#125;</span><br><span class="line">        Error Handler 1    $&#123;error&#125;</span><br><span class="line">    EXCEPT    [Ee]rror \\d+    (Invalid|Bad) usage    type=REGEXP    AS    $&#123;error&#125;</span><br><span class="line">        Error Handler 2    $&#123;error&#125;</span><br><span class="line">    EXCEPT    AS    $&#123;error&#125;</span><br><span class="line">        Error Handler 3    $&#123;error&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="使用ELSE在没有错误时执行关键字"><a href="#使用ELSE在没有错误时执行关键字" class="headerlink" title="使用ELSE在没有错误时执行关键字"></a>使用ELSE在没有错误时执行关键字</h5><p>可选的ELSE分支使得在没有错误的情况下可以执行关键字。只能有一个ELSE分支，并且只有在一个或多个EXCEPT分支之后才允许：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">ELSE branch</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    X</span><br><span class="line">        Log    Error &#x27;X&#x27; occurred!</span><br><span class="line">    EXCEPT    Y</span><br><span class="line">        Log    Error &#x27;Y&#x27; occurred!</span><br><span class="line">    ELSE</span><br><span class="line">        Log    No error occurred!</span><br><span class="line">    END</span><br><span class="line">    Keyword Outside</span><br></pre></td></tr></table></figure></div>

<p>在上面的例子中，如果Some Keyword通过，那么执行ELSE分支，如果它以消息X或Y失败，那么运行适当的EXCEPT分支。在所有这些情况下，执行在整个TRY&#x2F;EXCEPT&#x2F;ELSE结构之后继续。如果Some Keyword以任何其他方式失败，EXCEPT和ELSE分支不会运行，TRY&#x2F;EXCEPT&#x2F;ELSE结构失败。</p>
<p>要处理有任何错误和没有错误的情况，可以使用没有任何消息的EXCEPT与ELSE结合使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Handle everything</span><br><span class="line">    TRY</span><br><span class="line">        Some Keyword</span><br><span class="line">    EXCEPT    AS    $&#123;err&#125;</span><br><span class="line">        Log    Error occurred: $&#123;err&#125;</span><br><span class="line">    ELSE</span><br><span class="line">        Log    No error occurred!</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="使用FINALLY无论是否有错误都执行关键字"><a href="#使用FINALLY无论是否有错误都执行关键字" class="headerlink" title="使用FINALLY无论是否有错误都执行关键字"></a>使用FINALLY无论是否有错误都执行关键字</h5><p>可选的FINALLY分支使得在有错误和没有错误的情况下都可以执行关键字。因此，它们适合在关键字执行后进行清理，类似于清理操作。只能有一个FINALLY分支，它必须始终在最后。它们可以与EXCEPT和ELSE分支结合使用，也可以使用TRY&#x2F;FINALLY结构：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">TRY/EXCEPT/ELSE/FINALLY</span><br><span class="line">    TRY</span><br><span class="line">        Some keyword</span><br><span class="line">    EXCEPT</span><br><span class="line">        Log    Error occurred!</span><br><span class="line">    ELSE</span><br><span class="line">        Log    No error occurred.</span><br><span class="line">    FINALLY</span><br><span class="line">        Log    Always executed.</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">TRY/FINALLY</span><br><span class="line">    Open Connection</span><br><span class="line">    TRY</span><br><span class="line">        Use Connection</span><br><span class="line">    FINALLY</span><br><span class="line">        Close Connection</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="其他处理错误的方式"><a href="#其他处理错误的方式" class="headerlink" title="其他处理错误的方式"></a>其他处理错误的方式</h5><p>还有其他方法可以有条件地执行关键字：</p>
<ul>
<li>BuiltIn关键字Run Keyword And Expect Error执行一个命名的关键字，并期望它以指定的错误消息失败。它基本上与使用指定消息的TRY&#x2F;EXCEPT相同。指定错误消息的语法也是相同的，除了这个关键字默认使用全局模式匹配，而不是精确匹配。一般推荐使用原生的TRY&#x2F;EXCEPT功能，除非需要支持不支持它的旧版本的Robot Framework。</li>
<li>BuiltIn关键字Run Keyword And Ignore Error执行一个命名的关键字，并返回其状态作为字符串PASS或FAIL，以及可能的返回值或错误消息。它基本上与使用TRY&#x2F;EXCEPT&#x2F;ELSE相同，以便EXCEPT捕获所有错误。推荐使用原生语法，除非需要支持旧版本的Robot Framework。</li>
<li>BuiltIn关键字Run Keyword And Return Status执行一个命名的关键字，并返回其状态作为布尔值true或false。它是前述的Run Keyword And Ignore Error的包装器。现在推荐使用原生语法。</li>
<li>测试清理和关键字清理可以用于清理活动，类似于FINALLY分支。</li>
<li>当关键字在基于Python的库中实现时，所有Python的错误处理特性都是现成可用的。这是推荐的方法，特别是如果需要的逻辑变得更复杂。</li>
</ul>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="处理同名关键字"><a href="#处理同名关键字" class="headerlink" title="处理同名关键字"></a>处理同名关键字</h4><p>使用Robot Framework的关键字可以是库关键字或用户关键字。前者来自标准库或外部库，后者要么在使用它们的同一文件中创建，要么从资源文件中导入。当使用许多关键字时，它们中的一些具有相同的名称是很常见的，本节描述了如何处理这些情况下可能的冲突。</p>
<h5 id="关键字作用域"><a href="#关键字作用域" class="headerlink" title="关键字作用域"></a>关键字作用域</h5><p>当只使用关键字名称并且有几个具有该名称的关键字时，Robot Framework会尝试根据其作用域确定哪个关键字具有最高优先级。关键字的作用域是根据创建关键字的方式确定的：</p>
<ul>
<li>在当前执行的套件文件中创建为用户关键字。这些关键字具有最高优先级，即使在其他地方有其他同名关键字，它们也总是被使用。</li>
<li>在资源文件中创建并直接或间接从另一个资源文件导入。这是第二高的优先级。</li>
<li>在外部测试库中创建。如果没有同名的用户关键字，这些关键字将被使用。然而，如果在标准库中有一个同名的关键字，将显示警告。</li>
<li>在标准库中创建。这些关键字具有最低优先级。</li>
</ul>
<h5 id="明确指定关键字"><a href="#明确指定关键字" class="headerlink" title="明确指定关键字"></a>明确指定关键字</h5><p>仅凭作用域并不是一个足够的解决方案，因为在几个库或资源中可能有同名的关键字，因此，它们提供了一种机制，只使用最高优先级的关键字。在这种情况下，可以使用关键字的全名，其中关键字名称以资源或库的名称为前缀，点号作为分隔符。</p>
<p>对于库关键字，长格式只意味着使用LibraryName.Keyword Name格式。例如，可以使用OperatingSystem.Run作为OperatingSystem库中的Run关键字，即使在其他地方有另一个Run关键字。如果库在模块或包中，必须使用完整的模块或包名称（例如，com.company.Library.Some Keyword）。如果在导入库时给库指定了自定义名称，那么在完整的关键字名称中也必须使用指定的名称。</p>
<p>资源文件在完整的关键字名称中指定，类似于库名称。资源的名称是从资源文件的基本名称中派生出来的，不包括文件扩展名。例如，可以使用myresources.Example作为myresources.html资源文件中的Example关键字。注意，如果几个资源文件有相同的基本名称，这种语法将不起作用。在这种情况下，必须重命名文件或关键字。关键字的全名与普通关键字名称一样，不区分大小写、空格和下划线。</p>
<h5 id="明确指定库和资源之间的优先级"><a href="#明确指定库和资源之间的优先级" class="headerlink" title="明确指定库和资源之间的优先级"></a>明确指定库和资源之间的优先级</h5><p>如果关键字之间存在多个冲突，指定所有关键字的长格式可能会很麻烦。使用长格式也使得无法创建根据可用的库或资源的不同而工作不同的动态测试用例或用户关键字。解决这两个问题的一个方法是使用BuiltIn库中的关键字Set Library Search Order显式指定关键字优先级。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>尽管关键字在其名称中有库这个词，但它也适用于资源文件。如上所述，资源中的关键字总是比库中的关键字具有更高的优先级。</p>

    </div>
  </div>

<p>Set Library Search Order接受一个有序的库和资源列表作为参数。当测试数据中的关键字名称与多个关键字匹配时，选择包含关键字的第一个库或资源，并使用该关键字实现。如果在任何指定的库或资源中都找不到关键字，执行失败，冲突的方式与设置搜索顺序时相同。</p>
<p>有关更多信息和示例，请参阅关键字的文档。</p>
<h5 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h5><p>有时候，关键字可能需要异常长的时间来执行，或者无限期地挂起。Robot Framework允许为测试用例和用户关键字设置超时，如果一个测试或关键字在指定的时间内没有完成，当前正在执行的关键字将被强制停止。</p>
<p>以这种方式停止关键字可能会使库、测试环境或被测试系统处于不稳定状态，只有在没有更安全的选项可用时，才推荐使用超时。一般来说，库应该实现为关键字不能挂起，或者它们有自己的超时机制。</p>
<h6 id="测试用例超时"><a href="#测试用例超时" class="headerlink" title="测试用例超时"></a>测试用例超时</h6><p>测试用例的超时可以通过在设置部分使用Test Timeout设置，或者在单个测试用例中使用[Timeout]设置来设置。Test Timeout为该套件中的所有测试用例定义了默认超时，而[Timeout]应用于特定的测试用例，并覆盖可能的默认值。</p>
<p>使用空的[Timeout]意味着测试没有超时，即使使用了Test Timeout。也可以为此目的使用显式的NONE值。如果其值为零或负数，超时也会被有效地忽略。</p>
<p>无论测试超时是在哪里定义的，给它的值都包含超时的持续时间。持续时间必须以Robot Framework的时间格式给出，即直接以秒为单位，如10，或以1分钟30秒的格式。超时也可以指定为变量，使得可以例如从命令行给出它们。</p>
<p>如果有超时并且它过期，当前正在运行的关键字将被停止，测试用例失败。如果发生测试超时，作为测试清理部分执行的关键字不会被中断，但测试仍然被标记为失败。如果清理中的关键字可能挂起，可以使用用户关键字超时来停止它。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Test Timeout       2 minutes</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Default timeout</span><br><span class="line">    [Documentation]    Default timeout from Settings is used.</span><br><span class="line">    Some Keyword    argument</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line">    [Documentation]    Override default, use 10 seconds timeout.</span><br><span class="line">    [Timeout]    10</span><br><span class="line">    Some Keyword    argument</span><br><span class="line"></span><br><span class="line">Variables</span><br><span class="line">    [Documentation]    It is possible to use variables too.</span><br><span class="line">    [Timeout]    $&#123;TIMEOUT&#125;</span><br><span class="line">    Some Keyword    argument</span><br><span class="line"></span><br><span class="line">No timeout</span><br><span class="line">    [Documentation]    Empty timeout means no timeout even when Test Timeout has been used.</span><br><span class="line">    [Timeout]</span><br><span class="line">    Some Keyword    argument</span><br><span class="line"></span><br><span class="line">No timeout 2</span><br><span class="line">    [Documentation]    Disabling timeout with NONE works too and is more explicit.</span><br><span class="line">    [Timeout]    NONE</span><br><span class="line">    Some Keyword    argument</span><br></pre></td></tr></table></figure></div>

<h6 id="用户关键字超时"><a href="#用户关键字超时" class="headerlink" title="用户关键字超时"></a>用户关键字超时</h6><p>可以使用[Timeout]设置为用户关键字设置超时。语法与测试用例超时完全相同，但用户关键字超时没有任何默认值。如果使用变量指定用户关键字超时，也可以将值作为关键字参数给出。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Hardcoded</span><br><span class="line">    [Arguments]    $&#123;arg&#125;</span><br><span class="line">    [Timeout]    1 minute 42 seconds</span><br><span class="line">    Some Keyword    $&#123;arg&#125;</span><br><span class="line"></span><br><span class="line">Configurable</span><br><span class="line">    [Arguments]    $&#123;arg&#125;    $&#123;timeout&#125;</span><br><span class="line">    [Timeout]    $&#123;timeout&#125;</span><br><span class="line">    Some Keyword    $&#123;arg&#125;</span><br><span class="line"></span><br><span class="line">Run Keyword with Timeout</span><br><span class="line">    [Arguments]    $&#123;keyword&#125;    @&#123;args&#125;    &amp;&#123;kwargs&#125;    $&#123;timeout&#125;=1 minute</span><br><span class="line">    [Documentation]    Wrapper that runs another keyword with a configurable timeout.</span><br><span class="line">    [Timeout]    $&#123;timeout&#125;</span><br><span class="line">    Run Keyword    $&#123;keyword&#125;    @&#123;args&#125;    &amp;&#123;kwargs&#125;</span><br></pre></td></tr></table></figure></div>



<p>用户关键字超时在该用户关键字的执行期间适用。如果整个关键字的总时间超过超时值，当前正在执行的关键字将被停止。用户关键字超时也适用于测试用例的清理过程，而测试超时则不适用。</p>
<p>如果测试用例和其中的一些关键字（或几个嵌套关键字）都有超时，活动超时是剩余时间最少的那个。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在早期的Robot Framework版本中，可以指定一个自定义错误消息，以便在超时过期时使用。这个功能在Robot Framework 3.0.1中被弃用，并在Robot Framework 3.2中被移除。</p>

    </div>
  </div>

<h5 id="并行执行关键字"><a href="#并行执行关键字" class="headerlink" title="并行执行关键字"></a>并行执行关键字</h5><p>当需要并行执行时，必须在测试库级别实现，以便库在后台执行代码。通常，这意味着库需要一个像Start Something这样的关键字来开始执行并立即返回，以及另一个像Get Results From Something这样的关键字来等待结果可用并返回它。参见Process库关键字Start Process和Wait For Process的示例。</p>
<p>执行测试用例</p>
<p>基本使用 Robot Framework 的测试用例从命令行执行，其结果默认为 XML 格式的输出文件以及 HTML 报告和日志。执行后，可以使用 Rebot 工具合并输出文件并进行其他后处理。</p>
<h2 id="测试用例执行"><a href="#测试用例执行" class="headerlink" title="测试用例执行"></a>测试用例执行</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="开始执行测试"><a href="#开始执行测试" class="headerlink" title="开始执行测试"></a>开始执行测试</h4><h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot [options] data</span><br><span class="line">python -m robot [options] data</span><br><span class="line">python path/to/robot/ [options] data</span><br></pre></td></tr></table></figure></div>

<p>执行通常是使用安装时创建的 robot 命令开始的。或者，也可以使用选定的 Python 解释器执行已安装的 robot 模块。这在 Robot Framework 已在多个 Python 版本下安装的情况下特别方便。最后，如果知道已安装的 robot 目录在哪里，也可以使用 Python 执行它。</p>
<p>无论执行方法如何，要执行的测试数据的路径（或路径）都作为命令后的参数给出。此外，可以使用不同的命令行选项以多种方式更改测试执行或生成的输出。</p>
<h5 id="指定要执行的测试数据"><a href="#指定要执行的测试数据" class="headerlink" title="指定要执行的测试数据"></a>指定要执行的测试数据</h5><p>指定要执行的测试数据 Robot Framework 的测试用例在文件和目录中创建，通过将文件或目录的路径给到选定的运行脚本来执行它们。路径可以是绝对的，或者更常见的，相对于从其中执行测试的目录。给定的文件或目录创建顶级测试套件，该套件默认从文件或目录名获取其名称。以下示例中说明了不同的执行可能性。请注意，在这些示例中，以及在本节中的其他示例中，只使用了 robot 脚本，但其他执行方法也可以类似地使用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot tests.robot</span><br><span class="line">robot path/to/my_tests/</span><br><span class="line">robot c:\robot\tests.robot</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>执行目录时，所有以点（.）或下划线（_）开头的文件和目录都会被忽略，且默认只执行 .robot 扩展名的文件。有关更多详细信息，请参阅选择要解析的文件部分。</p>

    </div>
  </div>

<p>也可以一次给出多个测试用例文件或目录的路径，用空格分隔。在这种情况下，Robot Framework 会自动创建顶级测试套件，指定的文件和目录成为其子测试套件。创建的测试套件的名称是通过将子套件名称用和号（&amp;）和空格连接在一起得到的。例如，下面第一个示例中的顶级套件的名称是 My Tests &amp; Your Tests。这些自动创建的名称通常很长且复杂。在大多数情况下，因此最好使用 –name 选项来覆盖它，如下面的第二个示例所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot my_tests.robot your_tests.robot</span><br><span class="line">robot --name Example path/to/tests/pattern_*.robot</span><br></pre></td></tr></table></figure></div>

<p>从 Robot Framework 6.1 开始，也可以为自动创建的顶级套件定义测试套件初始化文件。给出 init 文件的路径与给出测试用例文件的方式类似：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot __init__.robot my_tests.robot other_tests.robot</span><br></pre></td></tr></table></figure></div>

<h4 id="使用命令行选项"><a href="#使用命令行选项" class="headerlink" title="使用命令行选项"></a>使用命令行选项</h4><p>Robot Framework 提供了许多命令行选项，可以用来控制如何执行测试用例以及生成哪些输出。本节将解释选项语法，以及实际存在的选项。它们如何被使用将在本章的其他部分进行讨论。</p>
<h5 id="使用选项"><a href="#使用选项" class="headerlink" title="使用选项"></a>使用选项</h5><p>当使用选项时，它们必须始终在运行脚本和数据源之间给出。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot -L debug my_tests.robot</span><br><span class="line">robot --include smoke --variable HOST:10.0.0.42 path/to/tests/</span><br></pre></td></tr></table></figure></div>

<h5 id="短选项和长选项"><a href="#短选项和长选项" class="headerlink" title="短选项和长选项"></a>短选项和长选项</h5><p>选项总是有一个长名称，如 <code>--name</code>，最常用的选项也有一个短名称，如 <code>-N</code>。除此之外，只要它们是唯一的，长选项可以被缩短。例如，<code>--logle DEBUG</code> 是有效的，而 <code>--lo log.html</code> 则不行，因为前者只匹配 <code>--loglevel</code>，但后者匹配了多个选项。在手动执行测试用例时，短选项和缩短的选项是实用的，但在启动脚本中，建议使用长选项，因为它们更容易理解。</p>
<p>长选项名称是不区分大小写和连字符的，这有助于以易于阅读的格式编写选项名称。例如，<code>--SuiteStatLevel</code> 和 <code>--suite-stat-level</code> 等同于，但比 <code>--suitestatlevel</code> 更易于阅读。</p>
<p>注意</p>
<p>Robot Framework 6.1 中新增了长选项不区分连字符。</p>
<h5 id="设置选项值"><a href="#设置选项值" class="headerlink" title="设置选项值"></a>设置选项值</h5><p>大多数选项需要一个值，该值在选项名称之后给出。短选项和长选项都接受用空格从选项名称分隔的值，如 <code>--include tag</code> 或 <code>-i tag</code>。对于长选项，分隔符也可以是等号，例如 <code>--include=tag</code>，对于短选项，分隔符可以省略，如 <code>-itag</code>。</p>
<p>有些选项可以指定多次。例如，<code>--variable VAR1:value --variable VAR2:another</code> 设置了两个变量。如果多次使用只接受一个值的选项，最后给出的值是有效的。</p>
<h5 id="禁用不接受值的选项"><a href="#禁用不接受值的选项" class="headerlink" title="禁用不接受值的选项"></a>禁用不接受值的选项</h5><p>不接受值的选项可以通过再次使用相同的选项并添加或删除无前缀来禁用。无论选项使用多少次，最后的选项都有优先权。例如，<code>--dryrun --dryrun --nodryrun --nostatusrc --statusrc</code> 将不会激活 dry-run 模式，并将返回正常的状态 rc。</p>
<h5 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h5><p>许多命令行选项接受参数作为简单模式。这些类似于全局的模式根据以下规则进行匹配：</p>
<ul>
<li><code>*</code> 匹配任何字符串，甚至是空字符串。</li>
<li><code>?</code> 匹配任何单个字符。</li>
<li><code>[abc]</code> 匹配括号中的一个字符。</li>
<li><code>[!abc]</code> 匹配不在括号中的一个字符。</li>
<li><code>[a-z]</code> 匹配括号中范围内的一个字符。</li>
<li><code>[!a-z]</code> 匹配不在括号中范围内的一个字符。</li>
</ul>
<p>与通常的全局模式不同，路径分隔符 <code>/</code> 和 <code>\</code> 以及换行符 <code>\n</code> 由上述通配符匹配。</p>
<p>除非另有说明，模式匹配对大小写、空格和下划线不敏感。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--test Example*        # 匹配以 &#x27;Example&#x27; 开头的测试名称。</span><br><span class="line">--test Example[1-2]    # 匹配 &#x27;Example1&#x27; 和 &#x27;Example2&#x27; 测试。</span><br><span class="line">--include f??          # 匹配以 &#x27;f&#x27; 开头且长度为三个字符的标签的测试。</span><br></pre></td></tr></table></figure></div>

<p>上述示例中的所有匹配对大小写、空格和下划线不敏感。例如，第二个示例也会匹配名为 example 1 的测试。</p>
<p>如果匹配的文本恰好包含一些通配符字符，并且需要将它们按字面意义匹配，那么可以通过使用 <code>[...]</code> 语法来实现。模式 <code>[*]</code> 匹配字面 <code>*</code> 字符，<code>[?]</code> 匹配 <code>?</code>，<code>[[]</code> 匹配 <code>[</code>。单独的 <code>[</code> 和 <code>]</code> 不需要转义。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>Robot Framework 3.1 中新增了像 <code>[abc]</code> 和 <code>[!a-z]</code> 这样的括号支持。</p>

    </div>
  </div>

<h5 id="标签模式"><a href="#标签模式" class="headerlink" title="标签模式"></a>标签模式</h5><p>大多数与标签相关的选项接受参数作为标签模式。它们支持与简单模式相同的通配符（例如 <code>examp??</code>，<code>ex*le</code>），但它们还支持下面解释的 AND、OR 和 NOT 运算符。这些运算符可以用于将两个或更多个独立的标签或模式组合在一起。</p>
<h6 id="AND-或"><a href="#AND-或" class="headerlink" title="AND 或 &amp;"></a>AND 或 &amp;</h6><p>如果所有的单个模式都匹配，那么整个模式就匹配。AND 和 &amp; 是等价的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--include fooANDbar     # 匹配包含标签 &#x27;foo&#x27; 和 &#x27;bar&#x27; 的测试。</span><br><span class="line">--exclude xx&amp;yy&amp;zz      # 匹配包含标签 &#x27;xx&#x27;、&#x27;yy&#x27; 和 &#x27;zz&#x27; 的测试。</span><br></pre></td></tr></table></figure></div>

<h6 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h6><p>如果任何单个模式匹配，那么整个模式就匹配：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--include fooORbar      # 匹配包含标签 &#x27;foo&#x27; 或 &#x27;bar&#x27; 的测试。</span><br><span class="line">--exclude xxORyyORzz    # 匹配包含任何标签 &#x27;xx&#x27;、&#x27;yy&#x27; 或 &#x27;zz&#x27; 的测试。</span><br></pre></td></tr></table></figure></div>

<h6 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h6><p>如果左侧的模式匹配，但右侧的模式不匹配，那么整个模式就匹配。如果多次使用，第一个 NOT 之后的所有模式都不能匹配：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--include fooNOTbar     # 匹配包含标签 &#x27;foo&#x27; 但不包含标签 &#x27;bar&#x27; 的测试。</span><br><span class="line">--exclude xxNOTyyNOTzz  # 匹配包含标签 &#x27;xx&#x27; 但不包含标签 &#x27;yy&#x27; 或 &#x27;zz&#x27; 的测试。</span><br></pre></td></tr></table></figure></div>

<p>模式也可以以 NOT 开始，在这种情况下，如果 NOT 后的模式不匹配，那么模式就匹配：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--include NOTfoo        # 匹配不包含标签 &#x27;foo&#x27; 的测试</span><br><span class="line">--include NOTfooANDbar  # 匹配不包含标签 &#x27;foo&#x27; 和 &#x27;bar&#x27; 的测试</span><br></pre></td></tr></table></figure></div>

<p>上述运算符也可以一起使用。运算符的优先级，从高到低，是 AND、OR 和 NOT：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--include xANDyORz      # 匹配包含标签 &#x27;x&#x27; 和 &#x27;y&#x27;，或标签 &#x27;z&#x27; 的测试。</span><br><span class="line">--include xORyNOTz      # 匹配包含标签 &#x27;x&#x27; 或 &#x27;y&#x27;，但不包含标签 &#x27;z&#x27; 的测试。</span><br><span class="line">--include xNOTyANDz     # 匹配包含标签 &#x27;x&#x27;，但不包含标签 &#x27;y&#x27; 和 &#x27;z&#x27; 的测试。</span><br></pre></td></tr></table></figure></div>

<p>虽然标签匹配本身是不区分大小写的，但所有运算符都是区分大小写的，必须用大写字母写。如果标签本身恰好包含大写的 AND、OR 或 NOT，它们需要使用小写字母指定，以避免意外的运算符使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--include port          # 匹配包含标签 &#x27;port&#x27; 的测试，不区分大小写</span><br><span class="line">--include PORT          # 匹配包含标签 &#x27;P&#x27; 或 &#x27;T&#x27; 的测试，不区分大小写</span><br><span class="line">--exclude handoverORportNOTnotification</span><br></pre></td></tr></table></figure></div>

<h6 id="ROBOT-OPTIONS-和-REBOT-OPTIONS-环境变量"><a href="#ROBOT-OPTIONS-和-REBOT-OPTIONS-环境变量" class="headerlink" title="ROBOT_OPTIONS 和 REBOT_OPTIONS 环境变量"></a>ROBOT_OPTIONS 和 REBOT_OPTIONS 环境变量</h6><p>环境变量 <code>ROBOT_OPTIONS</code> 和 <code>REBOT_OPTIONS</code> 可以用来分别为测试执行和结果后处理指定默认选项。选项及其值必须定义为一个空格分隔的列表，并且它们被放在命令行上的任何显式选项之前。这些环境变量的主要用途是为某些选项设置全局默认值，以避免每次运行测试或使用 Rebot 时都需要重复它们。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export ROBOT_OPTIONS=&quot;--outputdir results --tagdoc &#x27;mytag:Example doc with spaces&#x27;&quot;</span><br><span class="line">robot tests.robot</span><br><span class="line">export REBOT_OPTIONS=&quot;--reportbackground blue:red:yellow&quot;</span><br><span class="line">rebot --name example output.xml</span><br></pre></td></tr></table></figure></div>

<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><h5 id="命令行输出"><a href="#命令行输出" class="headerlink" title="命令行输出"></a>命令行输出</h5><p>测试执行的最直观的输出是在命令行中显示的输出。所有执行的测试套件和测试用例，以及它们的状态，都会实时显示在那里。下面的示例显示了执行一个只有两个测试用例的简单测试套件的输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line">示例测试套件</span><br><span class="line">==============================================================================</span><br><span class="line">第一个测试 :: 可能的测试文档                                        | 通过 |</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第二个测试                                                           | 失败 |</span><br><span class="line">这里显示错误消息</span><br><span class="line">==============================================================================</span><br><span class="line">示例测试套件                                                        | 失败 |</span><br><span class="line">2个测试，1个通过，1个失败</span><br><span class="line">==============================================================================</span><br><span class="line">输出：  /path/to/output.xml</span><br><span class="line">报告：  /path/to/report.html</span><br><span class="line">日志：  /path/to/log.html</span><br></pre></td></tr></table></figure></div>

<p>每当测试用例中的顶级关键字结束时，控制台上也会有一个通知。如果关键字通过，则使用绿色的点，如果失败，则使用红色的F。这些标记被写到行的末尾，当测试本身结束时，它们被测试状态覆盖。如果将控制台输出重定向到文件，将禁用写入标记。</p>
<h5 id="生成的输出文件"><a href="#生成的输出文件" class="headerlink" title="生成的输出文件"></a>生成的输出文件</h5><p>命令行输出非常有限，通常需要单独的输出文件来调查测试结果。如上面的示例所示，默认情况下会生成三个输出文件。第一个是XML格式的，包含了关于测试执行的所有信息。第二个是更高级别的报告，第三个是更详细的日志文件。这些文件和其他可能的输出文件在不同的输出文件部分中讨论得更详细。</p>
<h5 id="返回代码"><a href="#返回代码" class="headerlink" title="返回代码"></a>返回代码</h5><p>运行脚本使用返回代码向运行它们的系统通信总体测试执行状态。当执行成功开始并且没有测试失败时，返回代码为零。下表解释了所有可能的返回代码。</p>
<p>可能的返回代码</p>
<table>
<thead>
<tr>
<th>RC</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>所有测试通过。</td>
</tr>
<tr>
<td>1-249</td>
<td>返回失败的测试数量。</td>
</tr>
<tr>
<td>250</td>
<td>250个或更多的失败。</td>
</tr>
<tr>
<td>251</td>
<td>打印了帮助或版本信息。</td>
</tr>
<tr>
<td>252</td>
<td>无效的测试数据或命令行选项。</td>
</tr>
<tr>
<td>253</td>
<td>测试执行被用户停止。</td>
</tr>
<tr>
<td>255</td>
<td>意外的内部错误。</td>
</tr>
</tbody></table>
<p>返回代码应该在执行后始终容易获得，这使得自动确定总体执行状态变得容易。例如，在bash shell中，返回代码在特殊变量<code>$?</code>中，在Windows中，它在<code>%ERRORLEVEL%</code>变量中。如果使用一些外部工具来运行测试，查阅其文档以了解如何获取返回代码。</p>
<p>即使有失败，也可以使用<code>--NoStatusRC</code>命令行选项将返回代码设置为0。例如，在连续集成服务器中，可能需要在确定测试执行的总体状态之前对结果进行后处理，这可能很有用。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>Rebot也使用相同的返回代码。</p>

    </div>
  </div>

<h5 id="执行过程中的错误和警告"><a href="#执行过程中的错误和警告" class="headerlink" title="执行过程中的错误和警告"></a>执行过程中的错误和警告</h5><p>在测试执行过程中，可能会出现意外的问题，比如无法导入库或资源文件，或者关键字已被弃用。根据严重程度，这些问题被分类为错误或警告，并被写入控制台（使用标准错误流），在日志文件的单独 “Test Execution Errors” 部分中显示，并写入 Robot Framework 自己的系统日志。通常，这些错误和警告是由 Robot Framework 本身生成的，但库也可以记录错误和警告。下面的示例说明了日志文件中的错误和警告是什么样子的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20090322 19:58:42.528	ERROR	文件 &#x27;/home/robot/tests.robot&#x27; 中的 &#x27;Setting&#x27; 表格的第 2 行元素出错：资源文件 &#x27;resource.robot&#x27; 不存在</span><br><span class="line">20090322 19:58:43.931	WARN	关键字 &#x27;SomeLibrary.Example Keyword&#x27; 已被弃用。请使用关键字 `Other Keyword`。</span><br></pre></td></tr></table></figure></div>

<h4 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h4><p>参数文件允许将所有或部分命令行选项和参数放置在一个外部文件中进行读取。这避免了命令行中存在的问题字符。如果需要大量的选项或参数，参数文件也可以防止在命令行中使用的命令变得过长。</p>
<p>参数文件通过 <code>--argumentfile</code>（-A）选项以及可能的其他命令行选项进行使用。</p>
<p>注意</p>
<p>与其他长命令行选项不同，<code>--argumentfile</code> 不能以缩短的格式（如 <code>--argumentf</code>）给出。</p>
<h5 id="参数文件语法"><a href="#参数文件语法" class="headerlink" title="参数文件语法"></a>参数文件语法</h5><p>参数文件可以包含命令行选项和测试数据的路径，每行一个选项或数据源。支持短选项和长选项，但推荐使用后者，因为它们更容易理解。参数文件可以包含任何字符，无需转义，但行首和行尾的空格会被忽略。此外，空行和以井号（#）开头的行也会被忽略：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--doc 这是一个示例（其中&quot;特殊字符&quot;是可以的！）</span><br><span class="line">--metadata X:带空格的值</span><br><span class="line">--variable VAR:Hello, world!</span><br><span class="line"># 这是一个注释</span><br><span class="line">path/to/my/tests</span><br></pre></td></tr></table></figure></div>

<p>在上述示例中，选项和它们的值之间的分隔符是一个空格。可以使用等号（&#x3D;）或任意数量的空格。例如，以下三行是相同的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--name An Example</span><br><span class="line">--name=An Example</span><br><span class="line">--name       An Example</span><br></pre></td></tr></table></figure></div>

<p>如果参数文件包含非ASCII字符，它们必须使用UTF-8编码保存。</p>
<h5 id="使用参数文件"><a href="#使用参数文件" class="headerlink" title="使用参数文件"></a>使用参数文件</h5><p>参数文件可以单独使用，以便它们包含所有的选项和测试数据的路径，或者与其他选项和路径一起使用。当一个参数文件与其他参数一起使用时，它的内容被放置到原始参数列表的与参数文件选项相同的位置。这意味着参数文件中的选项可以覆盖它之前的选项，它的选项可以被它之后的选项覆盖。可以多次甚至递归地使用 <code>--argumentfile</code> 选项：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robot --argumentfile all_arguments.robot</span><br><span class="line">robot --name Example --argumentfile other_options_and_paths.robot</span><br><span class="line">robot --argumentfile default_options.txt --name Example my_tests.robot</span><br><span class="line">robot -A first.txt -A second.txt -A third.txt tests.robot</span><br></pre></td></tr></table></figure></div>

<h5 id="从标准输入读取参数文件"><a href="#从标准输入读取参数文件" class="headerlink" title="从标准输入读取参数文件"></a>从标准输入读取参数文件</h5><p>可以使用特殊的参数文件名 STDIN 从标准输入流而不是文件中读取参数。当使用脚本生成参数时，这可能很有用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">generate_arguments.sh | robot --argumentfile STDIN</span><br><span class="line">generate_arguments.sh | robot --name Example --argumentfile STDIN tests.robot</span><br></pre></td></tr></table></figure></div>

<h4 id="获取帮助和版本信息"><a href="#获取帮助和版本信息" class="headerlink" title="获取帮助和版本信息"></a>获取帮助和版本信息</h4><p>无论是在执行测试用例还是在后处理输出时，都可以通过 <code>--help</code>（-h）选项获取命令行帮助。这些帮助文本有一个简短的概述，并简要解释了可用的命令行选项。</p>
<p>所有的运行脚本也支持使用 <code>--version</code> 选项获取版本信息。这些信息还包含 Python 版本和平台类型：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ robot --version</span><br><span class="line">Robot Framework 7.0 (Python 3.12.1 on darwin)</span><br><span class="line"></span><br><span class="line">C:\&gt;rebot --version</span><br><span class="line">Rebot 6.1.1 (Python 3.11.0 on win32)</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h4 id="创建启动脚本"><a href="#创建启动脚本" class="headerlink" title="创建启动脚本"></a>创建启动脚本</h4><p>测试用例通常由持续集成系统或其他一些机制自动执行。在这种情况下，需要有一个脚本来启动测试执行，可能还需要以某种方式对输出进行后处理。类似的脚本在手动运行测试时也很有用，特别是当需要大量的命令行选项或设置测试环境比较复杂时。</p>
<p>在类 UNIX 环境中，shell 脚本提供了一种简单但强大的机制来创建自定义的启动脚本。Windows 批处理文件也可以使用，但它们更有限，通常也更复杂。一个平台无关的替代方案是使用 Python 或其他高级编程语言。无论使用哪种语言，都建议使用长选项名称，因为它们比短名称更容易理解。</p>
<h5 id="Shell-脚本示例"><a href="#Shell-脚本示例" class="headerlink" title="Shell 脚本示例"></a>Shell 脚本示例</h5><p>在这个示例中，登录目录中的相同网络测试在不同的浏览器上执行，并使用 Rebot 在之后合并结果。该脚本也接受命令行选项本身，并使用方便的 <code>$*</code> 变量简单地将它们转发给 robot 命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">robot --name Firefox --variable BROWSER:Firefox --output out/fx.xml --<span class="built_in">log</span> none --report none $* login</span><br><span class="line">robot --name IE --variable BROWSER:IE --output out/ie.xml --<span class="built_in">log</span> none --report none  $* login</span><br><span class="line">rebot --name Login --outputdir out --output login.xml out/fx.xml out/ie.xml</span><br></pre></td></tr></table></figure></div>

<h5 id="批处理文件示例"><a href="#批处理文件示例" class="headerlink" title="批处理文件示例"></a>批处理文件示例</h5><p>使用批处理文件实现上述 shell 脚本示例也不是很复杂。注意，批处理文件的参数可以使用 <code>%*</code> 转发给执行的命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">robot --name Firefox --variable BROWSER:Firefox --output out\fx.xml --log none --report none %* login</span><br><span class="line">robot --name IE --variable BROWSER:IE --log none --output out\ie.xml --report none %* login</span><br><span class="line">rebot --name Login --outputdir out --output login.xml out\fx.xml out\ie.xml</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 之前，robot 和 rebot 命令在 Windows 上是作为批处理文件实现的，而在另一个批处理文件中使用它们需要在整个命令前加上 call。</p>

    </div>
  </div>

<h5 id="Python-示例"><a href="#Python-示例" class="headerlink" title="Python 示例"></a>Python 示例</h5><p>当启动脚本变得更复杂时，使用 shell 脚本或批处理文件实现它们就不那么方便了。这尤其是在需要两种变体并且需要两次实现相同逻辑的情况下。在这种情况下，通常最好切换到 Python。可以使用 subprocess 模块从 Python 执行 Robot Framework，但通常使用 Robot Framework 自己的程序化 API 更方便。最容易使用的 API 是 <code>robot.run_cli</code> 和 <code>robot.rebot_cli</code>，它们接受与 robot 和 rebot 命令相同的命令行参数。</p>
<p>以下示例实现了与前面的 shell 脚本和批处理文件示例相同的逻辑。在 Python 中，脚本本身的参数可以在 <code>sys.argv</code> 中获取：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> robot <span class="keyword">import</span> run_cli, rebot_cli</span><br><span class="line"></span><br><span class="line">common = [<span class="string">&#x27;--log&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;--report&#x27;</span>, <span class="string">&#x27;none&#x27;</span>] + sys.argv[<span class="number">1</span>:] + [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">run_cli([<span class="string">&#x27;--name&#x27;</span>, <span class="string">&#x27;Firefox&#x27;</span>, <span class="string">&#x27;--variable&#x27;</span>, <span class="string">&#x27;BROWSER:Firefox&#x27;</span>, <span class="string">&#x27;--output&#x27;</span>, <span class="string">&#x27;out/fx.xml&#x27;</span>] + common, exit=<span class="literal">False</span>)</span><br><span class="line">run_cli([<span class="string">&#x27;--name&#x27;</span>, <span class="string">&#x27;IE&#x27;</span>, <span class="string">&#x27;--variable&#x27;</span>, <span class="string">&#x27;BROWSER:IE&#x27;</span>, <span class="string">&#x27;--output&#x27;</span>, <span class="string">&#x27;out/ie.xml&#x27;</span>] + common, exit=<span class="literal">False</span>)</span><br><span class="line">rebot_cli([<span class="string">&#x27;--name&#x27;</span>, <span class="string">&#x27;Login&#x27;</span>, <span class="string">&#x27;--outputdir&#x27;</span>, <span class="string">&#x27;out&#x27;</span>, <span class="string">&#x27;out/fx.xml&#x27;</span>, <span class="string">&#x27;out/ie.xml&#x27;</span>])</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>需要 <code>exit=False</code>，因为默认情况下 <code>run_cli</code> 会以正确的返回代码退出到系统。<code>rebot_cli</code> 也是如此，但在上述示例中这是可以的。</p>

    </div>
  </div>

<h4 id="使-robot-文件可执行"><a href="#使-robot-文件可执行" class="headerlink" title="使 *.robot 文件可执行"></a>使 *.robot 文件可执行</h4><p>在类 UNIX 的操作系统上，可以通过赋予它们执行权限并添加像这样的 shebang 来使 *.robot 文件可执行：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env robot</span></span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Log to console    Executing!</span><br></pre></td></tr></table></figure></div>

<p>如果上述内容位于一个名为 example.robot 的文件中，并且该文件是可执行的，那么它可以像下面这样从命令行执行。从 Robot Framework 3.2 开始，单独执行的文件可以有任何扩展名，或者根本没有扩展名，所以如果文件只是命名为 example，同样也可以工作。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./example.robot</span><br></pre></td></tr></table></figure></div>

<p>这个技巧在执行目录时不起作用，但在执行单个文件时可能很方便。在自动化任务时，这可能更常用一些，而不是在自动化测试时。</p>
<h4 id="调试问题"><a href="#调试问题" class="headerlink" title="调试问题"></a>调试问题</h4><p>测试用例可能会失败，因为被测试的系统不正常工作，在这种情况下，测试发现了一个 bug，或者因为测试本身有 bug。解释失败的错误消息显示在命令行输出和报告文件中，有时错误消息本身就足以找出问题。然而，更多的时候，需要日志文件，因为它们还有其他日志消息，并且它们显示了哪个关键字实际上失败了。</p>
<p>当失败是由被测试的应用程序引起的，错误消息和日志消息应该足以理解导致它的原因。如果不是这样，测试库没有提供足够的信息，需要进行增强。在这种情况下，如果可能，手动运行相同的测试也可能揭示有关问题的更多信息。</p>
<p>由测试用例本身或它们使用的关键字引起的失败有时可能很难调试。例如，如果错误消息告诉一个关键字使用了错误数量的参数，修复问题显然很容易，但如果一个关键字缺失或以意外的方式失败，找到根本原因可能会更难。寻找更多信息的第一个地方是日志文件中的执行错误部分。例如，关于失败的测试库导入的错误可能很好地解释了为什么由于缺少关键字而导致测试失败。</p>
<p>如果日志文件默认情况下没有提供足够的信息，可以使用较低的日志级别执行测试。例如，显示失败发生在代码中哪里的回溯是使用 DEBUG 级别记录的，当问题出在单个库关键字时，这些信息是无价的。</p>
<p>记录的回溯不包含 Robot Framework 本身内部方法的信息。如果怀疑错误是由框架的 bug 导致的，可以通过将环境变量 ROBOT_INTERNAL_TRACES 设置为任何非空值来启用显示内部跟踪。</p>
<p>如果日志文件仍然没有足够的信息，启用 syslog 并查看它提供的信息是个好主意。也可以向测试用例添加一些关键字来查看正在发生什么。特别是 BuiltIn 关键字 Log 和 Log Variables 是有用的。如果其他方法都不起作用，总是可以从邮件列表或其他地方寻求帮助。</p>
<h5 id="使用-Python-调试器-pdb"><a href="#使用-Python-调试器-pdb" class="headerlink" title="使用 Python 调试器 (pdb)"></a>使用 Python 调试器 (pdb)</h5><p>也可以使用 Python 标准库中的 pdb 模块来设置断点并交互式地调试正在运行的测试。通常通过在想要进入调试器的位置插入：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb; pdb.set_trace()</span><br></pre></td></tr></table></figure></div>

<p>这种方式调用 pdb 在 Robot Framework 中无法正确工作，因为在关键字执行期间重定向了标准输出流。相反，可以使用以下方式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, pdb; pdb.Pdb(stdout=sys.__stdout__).set_trace()</span><br></pre></td></tr></table></figure></div>

<p>在 Python 库中，或者作为替代，可以直接在测试用例中使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluate    pdb.Pdb(stdout=sys.__stdout__).set_trace()    modules=sys, pdb</span><br></pre></td></tr></table></figure></div>

<p>​            </p>
<h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><p>本节描述了如何执行从解析的测试数据创建的测试套件结构，如何确定测试状态，以及如果有失败，如何继续执行测试用例，以及如何优雅地停止整个测试执行。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><h5 id="执行的套件和测试"><a href="#执行的套件和测试" class="headerlink" title="执行的套件和测试"></a>执行的套件和测试</h5><p>测试用例总是在测试套件中执行。从套件文件创建的测试套件直接拥有测试，而从目录创建的套件拥有子测试套件，这些子套件要么拥有测试，要么拥有它们自己的子套件。默认情况下，执行的套件中的所有测试都会运行，但可以使用选项 <code>--test</code>、<code>--suite</code>、<code>--include</code> 和 <code>--exclude</code> 来选择测试。不包含测试的套件将被忽略。</p>
<p>执行从顶级测试套件开始。如果套件有测试，它们将逐一执行，如果套件有套件，它们将以深度优先的顺序递归执行。当执行单个测试用例时，它包含的关键字将按顺序运行。通常，如果任何关键字失败，当前测试的执行就会结束，但也可以在失败后继续。以下各节将讨论确切的执行顺序以及可能的设置和拆卸如何影响执行。</p>
<h5 id="设置和拆卸"><a href="#设置和拆卸" class="headerlink" title="设置和拆卸"></a>设置和拆卸</h5><p>设置和拆卸可以在测试套件、测试用例和用户关键字级别使用。</p>
<h6 id="套件设置"><a href="#套件设置" class="headerlink" title="套件设置"></a>套件设置</h6><p>如果测试套件有一个设置，它将在其测试和子套件之前执行。如果套件设置通过，测试执行将正常继续。如果失败，套件及其子套件包含的所有测试用例都将被标记为失败。子测试套件中的测试和可能的套件设置和拆卸不会被执行。</p>
<p>套件设置通常用于设置测试环境。因为如果套件设置失败，测试就不会运行，所以使用套件设置来验证环境是否处于可以执行测试的状态是很容易的。</p>
<h6 id="套件拆卸"><a href="#套件拆卸" class="headerlink" title="套件拆卸"></a>套件拆卸</h6><p>如果测试套件有一个拆卸，它将在所有测试用例和子套件之后执行。无论测试状态如何，甚至如果匹配的套件设置失败，套件拆卸都会被执行。如果套件拆卸失败，之后在报告和日志中，套件中的所有测试都将被标记为失败。</p>
<p>套件拆卸主要用于在执行后清理测试环境。为了确保所有这些任务都完成，拆卸中使用的所有关键字都会被执行，即使其中一些关键字失败。</p>
<h6 id="测试设置"><a href="#测试设置" class="headerlink" title="测试设置"></a>测试设置</h6><p>可能的测试设置在测试用例的关键字之前执行。如果设置失败，关键字将不会被执行。测试设置的主要用途是为特定的测试用例设置环境。</p>
<h6 id="测试拆卸"><a href="#测试拆卸" class="headerlink" title="测试拆卸"></a>测试拆卸</h6><p>可能的测试拆卸在测试用例执行后执行。无论测试状态如何，甚至如果测试设置失败，都会执行它。</p>
<p>与套件拆卸类似，测试拆卸主要用于清理活动。它们也会被完全执行，即使其中一些关键字失败。</p>
<h6 id="用户关键字设置"><a href="#用户关键字设置" class="headerlink" title="用户关键字设置"></a>用户关键字设置</h6><p>用户关键字设置在执行关键字主体之前执行。如果设置失败，主体将不会被执行。关键字设置和主体中的第一个关键字之间没有太大的区别。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>用户关键字设置是在 Robot Framework 7.0 中新增的。</p>

    </div>
  </div>

<h6 id="用户关键字拆卸"><a href="#用户关键字拆卸" class="headerlink" title="用户关键字拆卸"></a>用户关键字拆卸</h6><p>用户关键字拆卸在关键字以其他方式执行后运行，无论状态如何。即使其中一些关键字失败，用户关键字拆卸也会被完全执行。</p>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p>测试套件中的测试用例按照它们在测试用例文件中定义的顺序执行。高级测试套件内的测试套件按照文件或目录名的不区分大小写的字母顺序执行。如果从命令行给出了多个文件和&#x2F;或目录，它们将按照给出的顺序执行。</p>
<p>如果需要在目录内使用特定的测试套件执行顺序，可以将前缀如 01 和 02 添加到文件和目录名中。如果这些前缀与套件的基本名称用两个下划线分隔，那么在生成的测试套件名称中不会包含这些前缀：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01__my_suite.robot -&gt; My Suite</span><br><span class="line">02__another_suite.robot -&gt; Another Suite</span><br></pre></td></tr></table></figure></div>

<p>如果套件内的测试套件的字母顺序有问题，一个好的解决方法是按照所需的顺序单独给出它们。这很容易导致启动命令过长，但参数文件允许每行列出一个文件，这样很好。</p>
<p>也可以使用 <code>--randomize</code> 选项随机化执行顺序。</p>
<h4 id="测试和套件状态"><a href="#测试和套件状态" class="headerlink" title="测试和套件状态"></a>测试和套件状态</h4><p>本节解释了测试如何获得 PASS、FAIL 或 SKIP 状态，以及如何根据测试状态确定套件状态。</p>
<p>注意</p>
<p>SKIP 状态是在 Robot Framework 4.0 中新增的。</p>
<h5 id="PASS"><a href="#PASS" class="headerlink" title="PASS"></a>PASS</h5><p>如果一个测试被执行并且它包含的所有关键字都没有失败，那么它将获得 PASS 状态。</p>
<h6 id="提前通过的测试"><a href="#提前通过的测试" class="headerlink" title="提前通过的测试"></a>提前通过的测试</h6><p>通常情况下，所有的关键字都会被执行，但也可以使用 BuiltIn 关键字 Pass Execution 和 Pass Execution If 来停止执行，并且不运行剩余的关键字。</p>
<p>以下是 Pass Execution 和 Pass Execution If 在不同情况下的行为：</p>
<ul>
<li>当它们用在任何设置或拆卸（套件、测试或关键字）中时，这些关键字会使该设置或拆卸通过。可能的已启动关键字的拆卸会被执行。测试执行或状态不会受到其他影响。</li>
<li>当它们在设置或拆卸之外的测试用例中使用时，关键字会使该特定的测试用例通过。可能的测试和关键字拆卸会被执行。</li>
<li>在使用这些关键字之前发生的可能的可继续的失败，以及之后执行的拆卸中的失败，都会导致执行失败。</li>
</ul>
<p>必须给出一个解释为什么执行被中断的消息，也可以修改测试用例标签。更多的细节和使用示例，请参阅这些关键字的文档。</p>
<p>在测试、设置或拆卸的中间阶段通过执行应该谨慎使用。在最坏的情况下，它可能导致跳过所有可能实际揭示被测试应用程序问题的部分。在执行由于外部因素无法继续的情况下，通常更安全的做法是跳过测试。</p>
<h5 id="FAIL"><a href="#FAIL" class="headerlink" title="FAIL"></a>FAIL</h5><p>测试获得 FAIL 状态的最常见原因是它包含的某个关键字失败。关键字本身可以通过引发异常失败，或者关键字可以被错误地调用。其他失败的原因包括语法错误和测试为空。</p>
<p>如果套件设置失败，套件中的测试将在不运行它们的情况下被标记为失败。如果套件拆卸失败，测试将在之后被追溯性地标记为失败。</p>
<h5 id="SKIP"><a href="#SKIP" class="headerlink" title="SKIP"></a>SKIP</h5><p>从 Robot Framework 4.0 开始，测试可以获得 SKIP 状态，除了 PASS 和 FAIL。有许多不同的方式可以获得这个状态。</p>
<h6 id="执行前跳过"><a href="#执行前跳过" class="headerlink" title="执行前跳过"></a>执行前跳过</h6><p>命令行选项 <code>--skip</code> 可以用来跳过指定的测试，而不需要完全运行它们。它基于标签工作，并支持标签模式，如 <code>examp??</code> 和 <code>tagANDanother</code>。如果多次使用，所有匹配任何指定标签或标签模式的测试都会被跳过：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--skip require-network</span><br><span class="line">--skip windowsANDversion9?</span><br><span class="line">--skip python2.* --skip python3.[0-6]</span><br></pre></td></tr></table></figure></div>

<p>从 Robot Framework 5.0 开始，也可以通过给测试添加保留标签 <code>robot:skip</code> 来跳过测试用例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]    robot:skip</span><br><span class="line">    Log       This is not executed</span><br></pre></td></tr></table></figure></div>

<p><code>--skip</code> 和 <code>--exclude</code> 的区别在于，使用后者的测试将被完全排除在执行之外，它们将不会显示在日志和报告中。使用前者，它们被包含在内，但实际上并未执行，它们将在日志和报告中可见。</p>
<h6 id="执行过程中动态跳过"><a href="#执行过程中动态跳过" class="headerlink" title="执行过程中动态跳过"></a>执行过程中动态跳过</h6><p>在执行过程中，测试可以通过多种方式获得 SKIP 状态：</p>
<ul>
<li>在测试用例中的任何地方，包括设置或拆卸，使用 BuiltIn 关键字 Skip。使用 Skip 关键字有两个效果：测试获得 SKIP 状态，测试的其余部分不会被执行。然而，如果测试有一个拆卸，它将被运行。</li>
<li>使用 BuiltIn 关键字 Skip If，它接受一个条件，并在条件为真时跳过测试。</li>
<li>库关键字也可以通过使用特殊的异常来触发跳过行为。这在创建测试库章节的跳过测试部分有解释。</li>
<li>如果使用任何上述方法跳过套件设置，套件中的所有测试都会被跳过，而不执行它们。</li>
<li>如果套件拆卸被跳过，所有的测试将被追溯性地标记为跳过。</li>
</ul>
<h6 id="自动跳过失败的测试"><a href="#自动跳过失败的测试" class="headerlink" title="自动跳过失败的测试"></a>自动跳过失败的测试</h6><p>命令行选项 <code>--skiponfailure</code> 可以用来自动将失败的测试标记为跳过。它基于标签工作，并支持像上面讨论的 <code>--skip</code> 选项那样的标签模式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--skiponfailure not-ready</span><br><span class="line">--skiponfailure experimentalANDmobile</span><br></pre></td></tr></table></figure></div>

<p>从 RF 5.0 开始，可以选择使用保留标签 <code>robot:skip-on-failure</code> 来达到上述相同的效果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]    robot:skip-on-failure</span><br><span class="line">    Fail      this test will be marked as skipped instead of failed</span><br></pre></td></tr></table></figure></div>

<p>这个功能的动机是允许执行那些还没有准备好的测试，或者测试一个还没有准备好的功能。这样的测试不会失败，而是会被标记为跳过，它们的标签可以用来将它们与可能的其他跳过的测试分开。</p>
<h6 id="从关键性迁移到-SKIP"><a href="#从关键性迁移到-SKIP" class="headerlink" title="从关键性迁移到 SKIP"></a>从关键性迁移到 SKIP</h6><p>早期的 Robot Framework 版本支持关键性概念，允许将测试标记为关键或非关键。默认情况下，所有测试都是关键的，但可以使用 <code>--critical</code> 和 <code>--noncritical</code> 选项进行配置。关键测试和非关键测试的区别在于，当确定执行的测试套件或整个测试运行的最终状态时，非关键测试不会被包含。实际上，测试状态是二维的，一轴是 PASS 和 FAIL，另一轴是关键性。</p>
<p>非关键的失败测试在许多方面类似于当前的跳过测试。因为这些特性相似，同时拥有 SKIP 和关键性会创建出像非关键 SKIP 这样的奇怪测试状态，所以在 Robot Framework 4.0 中引入 SKIP 状态时，移除了关键性概念。关键性问题的详细解释在提出移除它的问题中。</p>
<p>关键性概念的主要用例是能够运行尚未准备好的测试，或者测试尚未准备好的功能。现在，这个用例由前一节讨论的 skip-on-failure 功能覆盖。</p>
<p>为了简化从关键性到跳过的迁移，旧的 <code>--noncritical</code> 选项在 Robot Framework 4.0 中作为新的 <code>--skiponfailure</code> 的别名工作，同时也保留了旧的 <code>--critical</code> 选项。这两个旧选项都已被弃用，并在 Robot Framework 5.0 中被移除。</p>
<h6 id="套件状态"><a href="#套件状态" class="headerlink" title="套件状态"></a>套件状态</h6><p>套件状态完全根据它包含的测试的状态确定：</p>
<ul>
<li>如果有任何测试失败，套件状态为 FAIL。</li>
<li>如果没有失败，但至少有一个测试通过，套件状态为 PASS。</li>
<li>如果所有测试都已跳过，或者根本没有测试，套件状态为 SKIP。</li>
</ul>
<h4 id="失败后继续"><a href="#失败后继续" class="headerlink" title="失败后继续"></a>失败后继续</h4><p>通常情况下，当测试用例中的任何关键字失败时，测试用例会立即停止。这种行为缩短了测试执行时间，并防止了如果被测试的系统处于不稳定状态时，后续的关键字挂起或者引发其他问题。然而，这有一个缺点，那就是后续的关键字通常会提供更多关于系统状态的信息，而且在某些情况下，这些后续的关键字实际上会负责进行必要的清理活动。因此，Robot Framework 提供了几个即使有失败也可以继续的特性。</p>
<h5 id="自动在拆卸后继续执行"><a href="#自动在拆卸后继续执行" class="headerlink" title="自动在拆卸后继续执行"></a>自动在拆卸后继续执行</h5><p>为了确保所有的清理活动都得到了处理，套件、测试和关键字拆卸中自动启用了继续失败模式。实际上，这意味着在拆卸中，所有级别的关键字总是会被执行。</p>
<p>如果不希望这种行为，可以使用特殊的 <code>robot:stop-on-failure</code> 和 <code>robot:recursive-stop-on-failure</code> 标签来禁用它。</p>
<h5 id="当测试有模板时，执行所有顶级关键字"><a href="#当测试有模板时，执行所有顶级关键字" class="headerlink" title="当测试有模板时，执行所有顶级关键字"></a>当测试有模板时，执行所有顶级关键字</h5><p>当使用测试模板时，所有的顶级关键字都会被执行，以确保覆盖所有不同的组合。在这种使用中，继续只限于顶级关键字，而在它们内部，如果有不可继续的失败，执行就会正常结束。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Continue with templates</span><br><span class="line">    [Template]    Should be Equal</span><br><span class="line">    this    fails</span><br><span class="line">    this    is run</span><br></pre></td></tr></table></figure></div>

<p>如果不希望这种行为，可以使用特殊的 <code>robot:stop-on-failure</code> 和 <code>robot:recursive-stop-on-failure</code> 标签来禁用它。</p>
<h5 id="来自关键字的特殊失败"><a href="#来自关键字的特殊失败" class="headerlink" title="来自关键字的特殊失败"></a>来自关键字的特殊失败</h5><p>库关键字使用异常报告失败，可以使用特殊的异常来告诉 Robot Framework，无论失败与否，执行都可以继续。如何创建这些异常在创建测试库部分的可继续失败部分中有解释。</p>
<p>当一个测试结束并且有可继续的失败时，测试将被标记为失败。如果有多于一个的失败，所有的失败都将在最终的错误消息中列举出来：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Several failures occurred:</span><br><span class="line"></span><br><span class="line">1) First error message.</span><br><span class="line"></span><br><span class="line">2) Second error message.</span><br></pre></td></tr></table></figure></div>

<p>如果在可继续的失败之后发生正常的失败，测试执行也会结束。在这种情况下，所有的失败也将在最终的错误消息中列出。</p>
<p>从失败的关键字返回的值，可能被赋值给一个变量，总是 Python 的 None。</p>
<h5 id="Run-Keyword-And-Continue-On-Failure-关键字"><a href="#Run-Keyword-And-Continue-On-Failure-关键字" class="headerlink" title="Run Keyword And Continue On Failure 关键字"></a>Run Keyword And Continue On Failure 关键字</h5><p>BuiltIn 关键字 Run Keyword And Continue On Failure 允许将任何失败转换为可继续的失败。这些失败由框架以与上述来自库关键字的可继续失败完全相同的方式处理。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Run Keyword and Continue on Failure    Should be Equal    1    2</span><br><span class="line">    Log    This is executed but test fails in the end</span><br></pre></td></tr></table></figure></div>

<h5 id="使用标签启用失败后继续"><a href="#使用标签启用失败后继续" class="headerlink" title="使用标签启用失败后继续"></a>使用标签启用失败后继续</h5><p>作为测试用例或用户关键字的一部分执行的所有关键字，如果它们被标记为 <code>robot:continue-on-failure</code> 标签，则默认认为它们是可继续的。例如，以下两个测试的行为是相同的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Test 1</span><br><span class="line">    Run Keyword and Continue on Failure    Should be Equal    1    2</span><br><span class="line">    User Keyword 1</span><br><span class="line"></span><br><span class="line">Test 2</span><br><span class="line">    [Tags]    robot:continue-on-failure</span><br><span class="line">    Should be Equal    1    2</span><br><span class="line">    User Keyword 2</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">User Keyword 1</span><br><span class="line">    Run Keyword and Continue on Failure    Should be Equal    3    4</span><br><span class="line">    Log    This is executed</span><br><span class="line"></span><br><span class="line">User Keyword 2</span><br><span class="line">    [Tags]    robot:continue-on-failure</span><br><span class="line">    Should be Equal    3    4</span><br><span class="line">    Log    This is executed</span><br></pre></td></tr></table></figure></div>

<p>这些标签也会影响不同控制结构的继续失败模式。例如，下面的测试用例将执行 Do Something 关键字十次，无论它是否成功：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]    robot:continue-on-failure</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    10</span><br><span class="line">        Do Something</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>在测试用例或用户关键字中设置 <code>robot:continue-on-failure</code> 不会将继续失败行为传播到它们调用的用户关键字。如果需要这种递归行为，可以使用 <code>robot:recursive-continue-on-failure</code> 标签。例如，以下示例中的所有关键字都被执行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]    robot:recursive-continue-on-failure</span><br><span class="line">    Should be Equal    1    2</span><br><span class="line">    User Keyword 1</span><br><span class="line">    Log    This is executed</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">User Keyword 1</span><br><span class="line">    Should be Equal    3    4</span><br><span class="line">    User Keyword 2</span><br><span class="line">    Log    This is executed</span><br><span class="line"></span><br><span class="line">User Keyword 2</span><br><span class="line">    Should be Equal    5    6</span><br><span class="line">    Log    This is executed</span><br></pre></td></tr></table></figure></div>

<p>在测试用例中设置 <code>robot:continue-on-failure</code> 或 <code>robot:recursive-continue-on-failure</code> 不会改变作为 [Setup] 的一部分执行的关键字的失败行为：测试用例被标记为失败，并且不执行任何测试用例关键字。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>robot:continue-on-failure</code> 和 <code>robot:recursive-continue-on-failure</code> 标签是在 Robot Framework 4.1 中新增的。它们在 Robot Framework 6.0 之前的 WHILE 循环中不能正常工作。</p>

    </div>
  </div>

<h5 id="使用标签禁用失败后继续"><a href="#使用标签禁用失败后继续" class="headerlink" title="使用标签禁用失败后继续"></a>使用标签禁用失败后继续</h5><p>如果需要，可以使用特殊的标签 <code>robot:stop-on-failure</code> 和 <code>robot:recursive-stop-on-failure</code> 来禁用失败后继续模式。它们在使用标签启用失败后继续以及在拆卸和模板中也起作用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Disable continue-in-failure set using tags</span><br><span class="line">    [Tags]    robot:recursive-continue-on-failure</span><br><span class="line">    Keyword</span><br><span class="line">    Keyword    # 这将被执行</span><br><span class="line"></span><br><span class="line">Disable continue-in-failure in teardown</span><br><span class="line">    No Operation</span><br><span class="line">    [Teardown]    Keyword</span><br><span class="line"></span><br><span class="line">Disable continue-in-failure with templates</span><br><span class="line">    [Tags]    robot:stop-on-failure</span><br><span class="line">    [Template]    Should be Equal</span><br><span class="line">    this    fails</span><br><span class="line">    this    is not run</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Keyword</span><br><span class="line">    [Tags]    robot:stop-on-failure</span><br><span class="line">    Should be Equal    this    fails</span><br><span class="line">    Should be Equal    this    is not run</span><br></pre></td></tr></table></figure></div>

<p><code>robot:stop-on-failure</code> 标签只影响使用它的测试用例和用户关键字，并且不会传播到它们调用的用户关键字或它们自己的拆卸。如果需要影响所有调用的用户关键字和拆卸的递归行为，可以使用 <code>robot:recursive-stop-on-failure</code> 标签代替。如果有需要，它的效果可以再次在较低级别的关键字中通过使用 <code>robot:continue-on-failure</code> 或 <code>robot:recursive-continue-on-failure</code> 标签来禁用。</p>
<p><code>robot:stop-on-failure</code> 和 <code>robot:recursive-stop-on-failure</code> 标签不会改变由库关键字或 Run Keyword And Continue On Failure 引起的可继续失败的行为。例如，尽管使用了 <code>robot:stop-on-failure</code>，但这个示例中的两个关键字都会运行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]    robot:stop-on-failure</span><br><span class="line">    Run Keyword and Continue on Failure    Should be Equal    1    2</span><br><span class="line">    Log    This is executed regardless the tag</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>robot:recursive-stop-on-failure</code> 和 <code>robot:continue-on-failure</code> 在同一个测试或关键字中一起使用，如果有失败，执行将在调用的关键字中停止，但在使用这些标签的测试或关键字中继续。如果 <code>robot:recursive-continue-on-failure</code> 和 <code>robot:stop-on-failure</code> 在同一个测试或关键字中一起使用，如果有失败，执行将在调用的关键字中继续，但在使用这些标签的测试或关键字中停止。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>robot:stop-on-failure</code> 和 <code>robot:recursive-stop-on-failure</code> 标签是在 Robot Framework 6.0 中新增的。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在同一个测试或关键字中同时使用递归和非递归标签是在 Robot Framework 7.0 中新增的。</p>

    </div>
  </div>   

<h5 id="TRY-EXCEPT"><a href="#TRY-EXCEPT" class="headerlink" title="TRY&#x2F;EXCEPT"></a>TRY&#x2F;EXCEPT</h5><p>Robot Framework 5.0 引入了原生的 TRY&#x2F;EXCEPT 语法，可以用于处理失败：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** 测试用例 ***</span><br><span class="line">示例</span><br><span class="line">    TRY</span><br><span class="line">        某个关键字</span><br><span class="line">    EXCEPT    预期的错误信息</span><br><span class="line">        错误处理关键字</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<p>更多详情请参见单独的 TRY&#x2F;EXCEPT 语法部分。</p>
<h5 id="内置关键字"><a href="#内置关键字" class="headerlink" title="内置关键字"></a>内置关键字</h5><p>有几个内置关键字可以用于执行其他关键字，以便在可能的失败后继续执行：</p>
<ul>
<li><code>Run Keyword And Expect Error</code> 执行一个关键字并期望它失败，给出指定的错误信息。现在一般推荐使用上述的 TRY&#x2F;EXCEPT 语法。</li>
<li><code>Run Keyword And Ignore Error</code> 执行一个关键字并忽略可能的错误。它返回状态以及可能的关键字返回值或错误信息。在这种情况下，TRY&#x2F;EXCEPT 语法通常效果更好。</li>
<li><code>Run Keyword And Warn On Failure</code> 是 <code>Run Keyword And Ignore Error</code> 的包装器，如果执行的关键字失败，它会自动记录警告。</li>
<li><code>Run Keyword And Return Status</code> 执行一个关键字并返回布尔值 True 或 False，取决于它是否通过。</li>
</ul>
<h4 id="优雅地停止测试执行"><a href="#优雅地停止测试执行" class="headerlink" title="优雅地停止测试执行"></a>优雅地停止测试执行</h4><p>有时候，需要在所有测试完成之前停止测试执行，但同时需要生成日志和报告。以下是实现这一目标的不同方法。在所有这些情况下，剩余的测试用例都会被标记为失败。</p>
<p>自动失败的测试会获得 <code>robot:exit</code> 标签，生成的报告将包含 <code>NOT robot:exit</code> 组合标签模式，以便轻松查看那些未被跳过的测试。请注意，发生退出的测试不会获得 <code>robot:exit</code> 标签。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 之前，特殊标签被命名为 <code>robot-exit</code>。</p>

    </div>
  </div>

<h5 id="按下-Ctrl-C"><a href="#按下-Ctrl-C" class="headerlink" title="按下 Ctrl-C"></a>按下 Ctrl-C</h5><p>当在运行测试的控制台中按下 Ctrl-C 时，执行会立即停止，但仍会生成报告和日志。</p>
<p>如果再次按下 Ctrl-C，执行会立即结束，报告和日志不会被创建。</p>
<h5 id="使用信号"><a href="#使用信号" class="headerlink" title="使用信号"></a>使用信号</h5><p>在类 UNIX 机器上，可以使用 INT 和 TERM 信号来终止测试执行。这些信号可以通过使用 kill 命令从命令行发送，发送信号也可以很容易地自动化。</p>
<h5 id="使用关键字"><a href="#使用关键字" class="headerlink" title="使用关键字"></a>使用关键字</h5><p>执行也可以通过执行的关键字来停止。有一个单独的 <code>Fatal Error</code> 内置关键字用于此目的，自定义关键字在失败时可以使用致命异常。</p>
<h5 id="当第一个测试用例失败时停止"><a href="#当第一个测试用例失败时停止" class="headerlink" title="当第一个测试用例失败时停止"></a>当第一个测试用例失败时停止</h5><p>如果使用了 <code>--exitonfailure</code>（-X）选项，如果有任何测试失败，测试执行会立即停止。剩余的测试会被标记为失败，而实际上并没有执行它们。</p>
<h5 id="在解析或执行错误时停止"><a href="#在解析或执行错误时停止" class="headerlink" title="在解析或执行错误时停止"></a>在解析或执行错误时停止</h5><p>Robot Framework 将由失败的关键字引起的失败与由例如无效设置或失败的测试库导入引起的错误分开。默认情况下，这些错误被报告为测试执行错误，但错误本身不会导致测试失败或以其他方式影响执行。然而，如果使用了 <code>--exitonerror</code> 选项，所有这样的错误都被认为是致命的，并且执行停止，以便剩余的测试被标记为失败。对于在执行开始之前就遇到的解析错误，这意味着实际上没有运行任何测试。</p>
<h5 id="处理-teardowns"><a href="#处理-teardowns" class="headerlink" title="处理 teardowns"></a>处理 teardowns</h5><p>默认情况下，即使使用上述方法之一停止了测试执行，已经开始的测试和套件的 teardowns 也会被执行。这允许无论执行如何结束，都可以运行清理活动。</p>
<p>也可以使用 <code>--skipteardownonexit</code> 选项在执行停止时跳过 teardowns。例如，如果清理任务需要很长时间，这可能会很有用。</p>
<h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>除了测试自动化之外，Robot Framework 还可以用于其他自动化目的，从 Robot Framework 3.1 开始，可以明确地创建和执行任务。任务执行和测试执行在大多数部分上工作方式相同，本节将解释其中的差异。</p>
<h4 id="通用自动化模式"><a href="#通用自动化模式" class="headerlink" title="通用自动化模式"></a>通用自动化模式</h4><p>当 Robot Framework 用于执行一个文件，并且注意到该文件有任务，而不是测试时，它会自动设置自己进入通用自动化模式。这种模式并不改变实际的执行，但是当创建日志和报告时，它们使用的是任务（task），而不是测试（test）。例如，它们的标题是 “任务日志”（Task Log）和 “任务统计”（Task Statistics），而不是 “测试日志”（Test Log）和 “测试统计”（Test Statistics）。</p>
<p>通用自动化模式也可以通过使用 <code>--rpa</code> 选项来启用。在这种情况下，执行的文件可以有测试或任务。或者，可以使用 <code>--norpa</code> 来强制测试自动化模式，即使执行的文件包含任务。如果这两个选项都没有使用，那么执行多个文件，使得一些文件有测试，其他文件有任务，将会是一个错误。</p>
<p>执行模式存储在生成的输出文件中，并由 Rebot 读取，如果输出被后处理。如果需要，也可以在使用 Rebot 时设置模式。                   </p>
<h4 id="任务相关的命令行选项"><a href="#任务相关的命令行选项" class="headerlink" title="任务相关的命令行选项"></a>任务相关的命令行选项</h4><p>执行任务时可以使用所有正常的命令行选项。如果需要选择只执行某些任务，可以使用 <code>--task</code> 代替 <code>--test</code>。此外，还可以使用前面提到的 <code>--rpa</code> 来控制执行模式。</p>
<h3 id="后处理输出"><a href="#后处理输出" class="headerlink" title="后处理输出"></a>后处理输出</h3><p>在测试执行期间生成的 XML 输出文件可以在之后由 Rebot 工具进行后处理，Rebot 是 Robot Framework 的一个组成部分。它在测试执行期间自动生成测试报告和日志，单独使用它可以创建自定义报告和日志以及合并结果。</p>
<h4 id="使用-Rebot"><a href="#使用-Rebot" class="headerlink" title="使用 Rebot"></a>使用 Rebot</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rebot [options] outputs</span><br><span class="line">python -m robot.rebot [options] outputs</span><br><span class="line">python path/to/robot/rebot.py [options] outputs</span><br></pre></td></tr></table></figure></div>

<p>使用 Rebot 的最常见方式是使用 <code>rebot</code> 命令。或者，也可以使用选定的 Python 解释器执行已安装的 <code>robot.rebot</code> 模块或 <code>robot/rebot.py</code> 文件。</p>
<h5 id="指定选项和参数"><a href="#指定选项和参数" class="headerlink" title="指定选项和参数"></a>指定选项和参数</h5><p>使用 Rebot 的基本语法与启动测试执行时完全相同，大多数命令行选项也是相同的。主要的区别是 Rebot 的参数是 XML 输出文件，而不是测试数据文件或目录。</p>
<h5 id="Rebot-的返回代码"><a href="#Rebot-的返回代码" class="headerlink" title="Rebot 的返回代码"></a>Rebot 的返回代码</h5><p>Rebot 的返回代码与运行测试时完全相同。</p>
<h5 id="控制执行模式"><a href="#控制执行模式" class="headerlink" title="控制执行模式"></a>控制执行模式</h5><p>Rebot 注意到已经运行了测试或任务，并默认保留执行模式。该模式影响日志和报告，以便在前一种情况下，它们将使用像 “Test Log” 和 “Test Statistics” 这样的测试术语，在后一种情况下，它们将使用像 “Task Log” 和 “Task Statistics” 这样的任务术语。</p>
<p>Rebot 还支持使用 <code>--rpa</code> 或 <code>--norpa</code> 选项来显式设置执行模式。如果处理多个输出文件并且它们的模式有冲突，这是必要的。</p>
<h4 id="创建报告、日志和输出文件"><a href="#创建报告、日志和输出文件" class="headerlink" title="创建报告、日志和输出文件"></a>创建报告、日志和输出文件</h4><p>可以使用 Rebot 创建在测试执行期间自动创建的相同的报告和日志。当然，创建完全相同的文件是没有意义的，但是，例如，有一个包含所有测试用例的报告和只包含一些测试子集的另一个报告可能是有用的：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rebot output.xml</span><br><span class="line">rebot path/to/output_file.xml</span><br><span class="line">rebot --include smoke --name Smoke_Tests c:\results\output.xml</span><br></pre></td></tr></table></figure></div>

<p>另一个常见的用法是在运行测试时只创建输出文件（可以使用 <code>--log NONE --report NONE</code> 禁用日志和报告生成），并稍后生成日志和报告。例如，可以在不同的环境上执行测试，将输出文件收集到一个中心位置，然后在那里创建报告和日志。</p>
<p>默认情况下，Rebot 不创建 XML 输出文件，但是可以使用 <code>--output</code>（-o）选项创建它们。默认情况下会创建日志和报告，但是如果不需要它们，可以使用值 <code>NONE</code>（不区分大小写）禁用它们：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rebot --include smoke --output smoke.xml --log none --report none original.xml          </span><br></pre></td></tr></table></figure></div>

<h4 id="合并输出"><a href="#合并输出" class="headerlink" title="合并输出"></a>合并输出</h4><p>Rebot 的一个重要特性是它能够合并来自不同测试执行轮次的输出。这种能力允许，例如，在不同的环境上运行相同的测试用例，并从所有输出中生成一个总体报告。合并输出非常容易，只需要将多个输出文件作为参数给出：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rebot output1.xml output2.xml</span><br><span class="line">rebot outputs/*.xml</span><br></pre></td></tr></table></figure></div>



<p>当输出被合并时，会创建一个新的顶级测试套件，使得给定输出文件中的测试套件成为其子套件。当执行多个测试数据文件或目录时，这种情况也是一样的，而且在这种情况下，顶级测试套件的名称是通过用 &amp; 和空格连接子套件名称来创建的。这些自动生成的名称不是那么好，通常使用 <code>--name</code> 给出更有意义的名称是一个好主意：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rebot --name Browser_Compatibility firefox.xml opera.xml safari.xml ie.xml</span><br><span class="line">rebot --include smoke --name Smoke_Tests c:\results\*.xml</span><br></pre></td></tr></table></figure></div>



<h4 id="融合输出"><a href="#融合输出" class="headerlink" title="融合输出"></a>融合输出</h4><p>如果相同的测试被重新执行或者一个单独的测试套件被分片执行，像上面讨论的那样合并结果会创建一个不必要的顶级测试套件。在这些情况下，通常更好的做法是融合结果。融合是通过使用 <code>--merge</code>（-R）选项完成的，该选项改变了 Rebot 合并两个或更多输出文件的方式。这个选项本身不需要参数，所有其他的命令行选项都可以正常地与它一起使用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rebot --merge original.xml merged.xml</span><br><span class="line">rebot --merge --name Example first.xml second.xml third.xml</span><br></pre></td></tr></table></figure></div>



<p>当套件被融合时，文档、套件设置和套件拆卸都来自最后融合的套件。所有融合并套件的套件元数据都被保留，以便后面的套件的值具有优先权。</p>
<p>如何合并测试的工作方式在以下讨论两个主要融合用例的部分中进行了解释。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>从融合套件获取套件文档和元数据是 Robot Framework 6.0 中的新功能。</p>

    </div>
  </div>

<h5 id="重新执行测试并融合结果"><a href="#重新执行测试并融合结果" class="headerlink" title="重新执行测试并融合结果"></a>重新执行测试并融合结果</h5><p>在测试过程中，经常需要重新执行一部分测试，例如在修复了被测试系统或测试本身的错误后。这可以通过按名称（<code>--test</code> 和 <code>--suite</code> 选项）、标签（<code>--include</code> 和 <code>--exclude</code>）或以前的状态（<code>--rerunfailed</code> 或 <code>--rerunfailedsuites</code>）选择测试用例来实现。</p>
<p>使用默认的输出融合方法将重新执行的结果与原始结果结合起来效果不太好。主要问题是会得到单独的测试套件，可能已经修复的失败也会显示出来。在这种情况下，最好使用 <code>--merge</code> (<code>-R</code>) 选项告诉 Rebot 合并结果。实际上，这意味着后续测试运行中的测试替换了原始测试。此规则的一个例外是，后续运行中跳过的测试被忽略，保留原始测试。</p>
<p>以下是一个实际的例子，使用 <code>--rerunfailed</code> 和 <code>--merge</code> 一起使用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot --output original.xml tests                          # 首先执行所有测试</span><br><span class="line">robot --rerunfailed original.xml --output rerun.xml tests  # 然后重新执行失败的测试</span><br><span class="line">rebot --merge original.xml rerun.xml                       # 最后合并结果</span><br></pre></td></tr></table></figure></div>

<p>融合的测试的消息包含一个注释，说明结果已被替换。消息还显示了测试的旧状态和消息。</p>
<p>融合的结果必须始终具有相同的顶级测试套件。在融合的输出中未从原始输出中找到的测试和套件被添加到结果输出中。这在实践中是如何工作的将在下一节中讨论。</p>
<p>注意：在 Robot Framework 4.1 中，新的特性是在后续运行中忽略跳过的测试。</p>
<h5 id="融合分段执行的套件"><a href="#融合分段执行的套件" class="headerlink" title="融合分段执行的套件"></a>融合分段执行的套件</h5><p><code>--merge</code> 选项的另一个重要用例是融合使用 <code>--include</code> 和 <code>--exclude</code> 选项等方式分段运行测试套件时得到的结果：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot --include smoke --output smoke.xml tests   # 首先运行一些测试</span><br><span class="line">robot --exclude smoke --output others.xml tests  # 然后运行其他测试</span><br><span class="line">rebot --merge smoke.xml others.xml               # 最后融合结果</span><br></pre></td></tr></table></figure></div>

<p>当像这样融合输出时，结果输出包含了所有给定输出文件中找到的所有测试和套件。如果某个测试在多个输出中找到，最新的结果替换早期的结果，就像在前一节中解释的那样。这种融合策略也要求所有输出中的顶级测试套件相同。</p>
<h4 id="JSON-输出文件"><a href="#JSON-输出文件" class="headerlink" title="JSON 输出文件"></a>JSON 输出文件</h4><p>Rebot 可以创建和处理 JSON 格式的输出文件。创建 JSON 输出文件是使用正常的 <code>--output</code> 选项，指定的文件有 <code>.json</code> 扩展名：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rebot --output output.json output.xml</span><br></pre></td></tr></table></figure></div>

<p>当读取输出文件时，JSON 文件会根据扩展名自动识别：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rebot output.json</span><br><span class="line">rebot output1.json output2.json</span><br></pre></td></tr></table></figure></div>

<p>当合并或合并结果时，可以混合 JSON 和 XML 文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rebot output1.xml output2.json</span><br><span class="line">rebot --merge original.xml rerun.json</span><br></pre></td></tr></table></figure></div>

<p>JSON 输出文件的结构在 result.json schema 文件中有文档。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 7.0 中，新的特性是支持 JSON 输出文件。</p>

    </div>
  </div>

<h3 id="配置执行"><a href="#配置执行" class="headerlink" title="配置执行"></a>配置执行</h3><p>本节解释了可以用于配置测试执行或后处理输出的不同命令行选项。与生成的输出文件相关的选项将在下一节中讨论。</p>
<h4 id="选择要解析的文件"><a href="#选择要解析的文件" class="headerlink" title="选择要解析的文件"></a>选择要解析的文件</h4><h5 id="执行单个文件"><a href="#执行单个文件" class="headerlink" title="执行单个文件"></a>执行单个文件</h5><p>当执行单个文件时，Robot Framework 会尝试解析并运行它们，而不考虑文件名或文件扩展名。使用哪个解析器取决于扩展名：</p>
<ul>
<li><code>.robot</code> 文件和未被识别的文件使用正常的 Robot Framework 解析器进行解析。</li>
<li><code>.rst</code> 和 <code>.rest</code> 文件使用 reStructuredText 解析器进行解析。</li>
<li><code>.rbt</code> 和 <code>.json</code> 文件使用 JSON 解析器进行解析。</li>
<li>支持自定义解析器的文件由匹配的解析器进行解析。</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robot example.robot    # 标准的 Robot Framework 解析器。</span><br><span class="line">robot example.tsv      # 必须与标准解析器兼容。</span><br><span class="line">robot example.rst      # reStructuredText 解析器。</span><br><span class="line">robot x.robot y.rst    # 使用适当的解析器解析两个文件。</span><br></pre></td></tr></table></figure></div>

<h5 id="包含和排除文件"><a href="#包含和排除文件" class="headerlink" title="包含和排除文件"></a>包含和排除文件</h5><p>当执行一个目录时，文件和目录按照以下规则进行解析：</p>
<ul>
<li>所有以点（.）或下划线（_）开头的文件和目录都被忽略。</li>
<li><code>.robot</code> 文件使用正常的 Robot Framework 解析器进行解析。</li>
<li><code>.robot.rst</code> 文件使用 reStructuredText 解析器进行解析。</li>
<li><code>.rbt</code> 文件使用 JSON 解析器进行解析。</li>
<li>支持自定义解析器的文件由匹配的解析器进行解析。</li>
<li>其他文件被忽略，除非使用 <code>--parseinclude</code> 或 <code>--extension</code> 选项启用了解析它们，这些选项将在后续部分中讨论。</li>
</ul>
<p>​              </p>
<h4 id="选择要解析的文件-1"><a href="#选择要解析的文件-1" class="headerlink" title="选择要解析的文件"></a>选择要解析的文件</h4><h5 id="根据名称或路径选择文件"><a href="#根据名称或路径选择文件" class="headerlink" title="根据名称或路径选择文件"></a>根据名称或路径选择文件</h5><p>在执行目录时，可以使用 <code>--parseinclude</code> (<code>-I</code>) 选项根据文件的名称或路径来解析特定的文件。这个选项的语义稍有不同，具体取决于它使用的值：</p>
<ul>
<li>如果值只是一个文件名，如 <code>example.robot</code>，那么所有目录中匹配该名称的文件都将被解析。</li>
<li>要匹配特定目录中的特定文件，可以将文件作为相对或绝对路径给出，如 <code>path/to/tests.robot</code>。</li>
<li>如果值是一个目录的路径，那么该目录内的所有文件都会被解析，递归地。</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robot --parseinclude example.robot tests       # 解析 `tests` 下的 `example.robot` 文件。</span><br><span class="line">robot -I example_*.robot -I ???.robot tests    # 解析 `tests` 下匹配 `example_*.robot` 或 `???.robot` 的文件。</span><br><span class="line">robot -I tests/example.robot tests             # 只解析 `tests/example.robot`。</span><br><span class="line">robot --parseinclude tests/example tests       # 递归解析 `tests/example` 目录下的文件。</span><br></pre></td></tr></table></figure></div>

<p>与 <code>--parseinclude</code> 一起使用的值不区分大小写，并支持像 <code>example_*.robot</code> 这样的 glob 模式。然而，与 Robot Framework 通常如何工作的模式相比，有两个小的不同：</p>
<ul>
<li><code>*</code> 只匹配一个路径段。例如，<code>path/*/tests.robot</code> 匹配 <code>path/to/tests.robot</code>，但不匹配 <code>path/to/nested/tests.robot</code>。</li>
<li><code>**</code> 可以用来启用递归匹配。例如，<code>path/**/tests.robot</code> 匹配 <code>path/to/tests.robot</code> 和 <code>path/to/nested/tests.robot</code>。</li>
</ul>
<p>如果模式包含一个扩展名，那么即使默认情况下不会解析具有该扩展名的文件，也会解析它。使用哪个解析器取决于使用的扩展名：</p>
<ul>
<li><code>.rst</code> 和 <code>.rest</code> 文件使用 reStructuredText 解析器进行解析。</li>
<li><code>.json</code> 文件使用 JSON 解析器进行解析。</li>
<li>其他文件使用正常的 Robot Framework 解析器进行解析。</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>当使用像 <code>*.robot</code> 这样的模式，并且在执行目录中存在匹配该模式的文件时，shell 可能会在调用 Robot Framework 之前解析该模式，传递给它的值是文件名，而不是原始模式。在这种情况下，需要引用或转义模式，如 <code>&#39;*.robot&#39;</code> 或 <code>\*.robot</code>。</p>
<p><code>--parseinclude</code> 是 Robot Framework 6.1 中的新特性。</p>

    </div>
  </div>

<h5 id="根据扩展名选择文件"><a href="#根据扩展名选择文件" class="headerlink" title="根据扩展名选择文件"></a>根据扩展名选择文件</h5><p>除了使用上一节中讨论的 <code>--parseinclude</code> 选项外，还可以使用 <code>--extension</code> (<code>-F</code>) 选项来启用解析默认情况下不解析的文件。匹配扩展名不区分大小写，可以省略前导点。如果需要解析多种类型的文件，可以使用冒号 <code>:</code> 来分隔扩展名：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --extension rst path/to/tests    # 只解析 *.rst 文件。</span><br><span class="line">robot -F robot:rst path/to/tests       # 解析 *.robot 和 *.rst 文件。</span><br></pre></td></tr></table></figure></div>

<p>以上等同于以下的 <code>--parseinclude</code> 使用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --parseinclude *.rst path/to/tests</span><br><span class="line">robot -I *.robot -I *.rst path/to/tests</span><br></pre></td></tr></table></figure></div>

<p>因为 <code>--parseinclude</code> 选项更强大，覆盖了 <code>--extension</code> 选项的所有用例，所以后者可能在未来被弃用。建议用户现在就开始使用 <code>--parseinclude</code>。</p>
<h5 id="使用自定义解析器"><a href="#使用自定义解析器" class="headerlink" title="使用自定义解析器"></a>使用自定义解析器</h5><p>外部解析器可以解析 Robot Framework 否则无法识别的文件。有关创建和使用此类解析器的更多信息，请参见解析器接口部分。</p>
<h4 id="选择测试用例"><a href="#选择测试用例" class="headerlink" title="选择测试用例"></a>选择测试用例</h4><p>Robot Framework 提供了几个命令行选项用于选择要执行的测试用例。当执行任务和后处理 Rebot 的输出时，这些选项也同样适用。</p>
<h5 id="通过测试名称"><a href="#通过测试名称" class="headerlink" title="通过测试名称"></a>通过测试名称</h5><p>选择只运行一些测试的最简单方法是使用 <code>--test</code> (<code>-t</code>) 选项。顾名思义，它可以用于通过它们的名称选择测试。给定的名称对大小写、空格和下划线不敏感，也支持简单的模式。该选项可以多次使用以匹配多个测试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--test Example                   # 只匹配名为 &#x27;Example&#x27; 的测试。</span><br><span class="line">--test example*                  # 匹配以 &#x27;example&#x27; 开头的测试。</span><br><span class="line">--test first --test second       # 匹配名为 &#x27;first&#x27; 或 &#x27;second&#x27; 的测试。</span><br></pre></td></tr></table></figure></div>



<p>为了更精确地指定一个测试，可以在测试名称前加上套件名称：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--test mysuite.mytest            # 匹配套件 &#x27;mysuite&#x27; 中的测试 &#x27;mytest&#x27;。</span><br><span class="line">--test root.sub.test             # 匹配套件 &#x27;root&#x27; 中的套件 &#x27;sub&#x27; 中的测试 &#x27;test&#x27;。</span><br><span class="line">--test *.sub.test                # 匹配任何地方的套件 &#x27;sub&#x27; 中的测试 &#x27;test&#x27;。</span><br></pre></td></tr></table></figure></div>



<p>注意，当给定的名称包含套件名称时，它必须匹配从根套件开始的整个套件名称。如上面的最后一个例子所示，使用通配符允许匹配具有父套件的测试。</p>
<p>当只需要选择几个测试时，使用 <code>--test</code> 选项很方便。一个常见的用例是只运行当前正在处理的测试。如果需要选择更多的测试，通常通过套件名称或标签名称选择它们会更容易。</p>
<p>在执行任务时，可以使用 <code>--task</code> 选项作为 <code>--test</code> 的别名。</p>
<h5 id="通过套件名称"><a href="#通过套件名称" class="headerlink" title="通过套件名称"></a>通过套件名称</h5><p>也可以使用 <code>--suite</code> (<code>-s</code>) 选项通过套件名称选择测试，该选项选择匹配套件中的所有测试。与 <code>--test</code> 类似，给定的名称对大小写、空格和下划线不敏感，并支持简单的模式。为了更精确地指定一个套件，可以在名称前加上父套件的名称：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--suite Example                  # 只匹配名为 &#x27;Example&#x27; 的套件。</span><br><span class="line">--suite example*                 # 匹配以 &#x27;example&#x27; 开头的套件。</span><br><span class="line">--suite first --suite second     # 匹配名为 &#x27;first&#x27; 或 &#x27;second&#x27; 的套件。</span><br><span class="line">--suite root.child               # 匹配根套件 &#x27;root&#x27; 中的套件 &#x27;child&#x27;。</span><br><span class="line">--suite *.parent.child           # 匹配任何地方的父套件 &#x27;parent&#x27; 下的套件 &#x27;child&#x27;。</span><br></pre></td></tr></table></figure></div>



<p>如果名称包含父套件名称，它必须以与 <code>--test</code> 相同的方式匹配整个套件名称。如上面的最后一个例子所示，使用通配符允许匹配具有父套件的套件。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 7.0 之前，带有父套件的 <code>--suite</code> 不需要匹配整个套件名称。例如，<code>parent.child</code> 会匹配任何地方的父套件 <code>parent</code> 下的套件 <code>child</code>。如果现在希望这种行为，那么名称必须以通配符为前缀。</p>

    </div>
  </div>



<p>如果同时使用 <code>--suite</code> 和 <code>--test</code> 选项，只有指定套件中的指定测试被选择：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--suite mysuite --test mytest    # 如果测试 &#x27;mytest&#x27; 在套件 &#x27;mysuite&#x27; 中，则匹配。</span><br></pre></td></tr></table></figure></div>



<p>使用 <code>--suite</code> 选项大致相当于直接执行适当的套件文件或目录。主要的区别是，如果直接运行文件或目录，可能的套件设置和拆卸在更高级别上不会被执行：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根套件是 <span class="string">&#x27;Tests&#x27;</span>，并且可能的设置和拆卸会被运行。</span></span><br><span class="line">robot --suite example path/to/tests</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根套件是 <span class="string">&#x27;Example&#x27;</span>，并且可能的更高级别的设置和拆卸会被忽略。</span></span><br><span class="line">robot path/to/tests/example.robot</span><br></pre></td></tr></table></figure></div>



<p>在 Robot Framework 6.1 之前，出于性能考虑，不符合 –suite 选项的文件根本不会被解析。然而，当测试套件获得了一个新的 Name 设置，该设置可以覆盖从文件或目录名称获取的默认测试套件名称后，这种优化就不再可能了。因此，如果需要进行这种类型的解析优化，就会新增 –parseinclude 选项，用于显式选择要解析的文件。</p>
<h5 id="通过标签名称"><a href="#通过标签名称" class="headerlink" title="通过标签名称"></a>通过标签名称</h5><p>可以使用 <code>--include</code> (<code>-i</code>) 和 <code>--exclude</code> (<code>-e</code>) 选项分别根据标签名称包含和排除测试用例。如果使用了 <code>--include</code> 选项，只有具有匹配标签的测试用例会被选中，而使用 <code>--exclude</code> 选项，具有匹配标签的测试用例将不会被选中。如果两者都使用，只有具有匹配前者选项的标签，且没有匹配后者的标签的测试会被选中：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--include example</span><br><span class="line">--exclude not_ready</span><br><span class="line">--include regression --exclude long_lasting</span><br></pre></td></tr></table></figure></div>

<p><code>--include</code> 和 <code>--exclude</code> 都可以多次使用以匹配多个标签。在这种情况下，如果一个测试具有匹配任何包含的标签，并且也没有匹配任何排除的标签，那么该测试就会被选中。</p>
<p>除了指定完全匹配的标签外，还可以使用标签模式，其中 <code>*</code> 和 <code>?</code> 是通配符，<code>AND</code>、<code>OR</code> 和 <code>NOT</code> 运算符可以用于将单个标签或模式组合在一起：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--include feature-4?</span><br><span class="line">--exclude bug*</span><br><span class="line">--include fooANDbar</span><br><span class="line">--exclude xxORyyORzz</span><br><span class="line">--include fooNOTbar</span><br></pre></td></tr></table></figure></div>

<p>从 RF 5.0 开始，也可以使用保留标签 <code>robot:exclude</code> 来达到与使用 <code>--exclude</code> 选项相同的效果：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">   [Tags]    robot:exclude</span><br><span class="line">   Fail      This is not executed</span><br></pre></td></tr></table></figure></div>

<p>通过标签选择测试用例是一种非常灵活的机制，允许许多有趣的可能性：</p>
<ul>
<li>可以用 <code>smoke</code> 标签标记要在其他测试之前执行的测试子集（通常称为烟雾测试），并使用 <code>--include smoke</code> 执行。</li>
<li>可以用 <code>not_ready</code> 等标签将未完成的测试提交到版本控制，并使用 <code>--exclude not_ready</code> 从测试执行中排除。</li>
<li>测试可以用 <code>sprint-&lt;num&gt;</code> 标签标记，其中 <code>&lt;num&gt;</code> 指定当前冲刺的编号，执行所有测试用例后，可以生成一个只包含某个冲刺的测试的单独报告（例如，<code>rebot --include sprint-42 output.xml</code>）。</li>
</ul>
<p><code>--include</code> 和 <code>--exclude</code> 选项可以与前一节中讨论的 <code>--suite</code> 和 <code>--test</code> 一起使用。它们如何一起工作的一般规则如下：</p>
<ul>
<li>如果使用了 <code>--suite</code>，测试必须在指定的套件中，除此之外还要满足其他选择条件。</li>
<li>如果 <code>--include</code> 与 <code>--test</code> 一起使用，对于一个测试来说，匹配其中任何一个就足够了。</li>
<li>如果使用了 <code>--exclude</code>，匹配它的测试永远不会被选中。</li>
</ul>
<p>以上规则在以下示例中得到了演示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--suite example --include tag    # 如果测试在套件 &#x27;example&#x27; 中并且有标签 &#x27;tag&#x27;，则匹配。</span><br><span class="line">--suite example --exclude tag    # 如果测试在套件 &#x27;example&#x27; 中并且没有标签 &#x27;tag&#x27;，则匹配。</span><br><span class="line">--test example --include tag     # 如果测试的名称是 &#x27;example&#x27; 或者它有标签 &#x27;tag&#x27;，则匹配。</span><br><span class="line">--test ex* --exclude tag         # 如果测试的名称以 &#x27;ex&#x27; 开头并且它没有标签 &#x27;tag&#x27;，则匹配。</span><br></pre></td></tr></table></figure></div>




  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 7.0 之前，使用 <code>--include</code> 和 <code>--test</code> 一起需要测试同时具有匹配的标签和匹配的名称。</p>

    </div>
  </div>            

<h5 id="重新执行失败的测试用例"><a href="#重新执行失败的测试用例" class="headerlink" title="重新执行失败的测试用例"></a>重新执行失败的测试用例</h5><p>命令行选项 <code>--rerunfailed</code> (<code>-R</code>) 可以用来从早期的输出文件中选择所有失败的测试用例进行重新执行。例如，如果运行所有测试需要很长时间，而希望迭代修复失败的测试用例，那么这个选项就很有用。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot tests                             # 首先执行所有测试</span><br><span class="line">robot --rerunfailed output.xml tests    # 然后重新执行失败的测试</span><br></pre></td></tr></table></figure></div>

<p>在幕后，这个选项选择了失败的测试，就像它们是使用 <code>--test</code> 选项单独选择的一样。可以使用 <code>--test</code>、<code>--suite</code>、<code>--include</code> 和 <code>--exclude</code> 选项进一步微调所选测试的列表。</p>
<p>如果输出中没有失败的测试，那么这是一个错误，但是可以使用下面讨论的 <code>--runemptysuite</code> 选项改变这种行为。使用一个不是来自现在运行的相同测试的输出会导致结果未定义。使用一个特殊的值 <code>NONE</code> 作为输出，就像根本没有指定这个选项一样。</p>
<p>提示：可以使用 <code>--merge</code> 命令行选项将重新执行的结果和原始结果合并在一起。</p>
<h5 id="重新执行失败的测试套件"><a href="#重新执行失败的测试套件" class="headerlink" title="重新执行失败的测试套件"></a>重新执行失败的测试套件</h5><p>命令行选项 <code>--rerunfailedsuites</code> (<code>-S</code>) 可以用来从早期的输出文件中选择所有失败的套件进行重新执行。像 <code>--rerunfailed</code> (<code>-R</code>) 一样，当完整的测试执行需要很长时间时，这个选项很有用。注意，一个失败的测试套件中的所有测试都将被重新执行，即使是通过的测试。当一个测试套件中的测试相互依赖时，这个选项很有用。</p>
<p>在幕后，这个选项选择了失败的套件，就像它们是使用 <code>--suite</code> 选项单独选择的一样。可以使用 <code>--test</code>、<code>--suite</code>、<code>--include</code> 和 <code>--exclude</code> 选项进一步微调所选测试的列表。</p>
<h5 id="当没有测试匹配选择时"><a href="#当没有测试匹配选择时" class="headerlink" title="当没有测试匹配选择时"></a>当没有测试匹配选择时</h5><p>默认情况下，当没有测试匹配选择条件时，测试执行会失败，错误如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ ERROR ] Suite &#x27;Example&#x27; with includes &#x27;xxx&#x27; contains no test cases.</span><br></pre></td></tr></table></figure></div>

<p>因为没有生成输出，所以如果测试是自动执行和处理结果的，这种行为可能会有问题。幸运的是，可以使用命令行选项 <code>--RunEmptySuite</code>（不区分大小写）强制在这种情况下也执行套件。结果是创建了正常的输出，但显示执行的测试为零。当执行一个空目录或一个不包含测试的测试用例文件时，也可以使用相同的选项来改变行为。</p>
<p>在使用 Rebot 处理输出文件时，也可能出现类似的情况。可能没有测试匹配使用的过滤条件，或者输出文件一开始就没有测试。默认情况下，执行 Rebot 在这些情况下会失败，但是它有一个单独的 <code>--ProcessEmptySuite</code> 选项，可以用来改变行为。实际上，这个选项在运行测试时的工作方式与 <code>--RunEmptySuite</code> 相同。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>使用 <code>--RunEmptySuite</code> 与 <code>--ReRunFailed</code> 或 <code>--ReRunFailedSuites</code> 需要 Robot Framework 5.0.1 或更高版本。</p>

    </div>
  </div>            

<h4 id="设置元数据"><a href="#设置元数据" class="headerlink" title="设置元数据"></a>设置元数据</h4><h5 id="设置套件名称"><a href="#设置套件名称" class="headerlink" title="设置套件名称"></a>设置套件名称</h5><p>当 Robot Framework 解析测试数据时，套件名称是从文件和目录名称创建的。然而，可以使用命令行选项 <code>--name</code> (<code>-N</code>) 覆盖顶级测试套件的名称：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot --name &quot;Custom name&quot; tests.robot</span><br></pre></td></tr></table></figure></div>

<h5 id="设置套件文档"><a href="#设置套件文档" class="headerlink" title="设置套件文档"></a>设置套件文档</h5><p>除了在测试数据中定义文档外，还可以使用选项 <code>--doc</code> (<code>-D</code>) 从命令行给出顶级套件的文档。值可以包含简单的 HTML 格式，如果包含空格，必须加引号。</p>
<p>如果给定的文档是指向现有文件的相对或绝对路径，那么实际的文档将从该文件中读取。如果外部指定的文档很长或包含多行，这特别方便。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --doc &quot;Example documentation&quot; tests.robot</span><br><span class="line">robot --doc doc.txt tests.robot    # 如果存在，文档将从 doc.txt 中读取。</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 4.1 中，从外部文件读取文档是新的特性。</p>
<p>在 Robot Framework 3.1 之前，文档中的下划线会像 <code>--name</code> 选项一样被转换为空格。</p>

    </div>
  </div>

<h5 id="设置自由套件元数据"><a href="#设置自由套件元数据" class="headerlink" title="设置自由套件元数据"></a>设置自由套件元数据</h5><p>也可以使用选项 <code>--metadata</code> (<code>-M</code>) 从命令行给出自由套件元数据。参数必须以 <code>name:value</code> 的格式给出，其中 <code>name</code> 是要设置的元数据的名称，<code>value</code> 是其值。值可以包含简单的 HTML 格式，如果整个参数包含空格，必须加引号。这个选项可以多次使用以设置多个元数据值。</p>
<p>如果给定的值是指向现有文件的相对或绝对路径，那么实际的值将从该文件中读取。如果值很长或包含多行，这特别方便。如果值应该是一个指向现有文件的路径，而不是从该文件中读取，那么值必须与 <code>name:</code> 部分用空格分隔。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robot --metadata Name:Value tests.robot</span><br><span class="line">robot --metadata &quot;Another Name:Another value, now with spaces&quot; tests.robot</span><br><span class="line">robot --metadata &quot;Read From File:meta.txt&quot; tests.robot    # 如果存在，值将从 meta.txt 中读取。</span><br><span class="line">robot --metadata &quot;Path As Value: meta.txt&quot; tests.robot    # 值始终按原样使用。</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 4.1 中，从外部文件读取元数据值是新的特性。</p>
<p>在 Robot Framework 3.1 之前，值中的下划线会像 <code>--name</code> 选项一样被转换为空格。</p>

    </div>
  </div>

<h5 id="设置测试标签"><a href="#设置测试标签" class="headerlink" title="设置测试标签"></a>设置测试标签</h5><p>命令行选项 <code>--settag</code> (<code>-G</code>) 可以用来为所有执行的测试用例设置给定的标签。这个选项可以多次使用以设置多个标签。</p>
<h4 id="配置搜索库和其他扩展的位置"><a href="#配置搜索库和其他扩展的位置" class="headerlink" title="配置搜索库和其他扩展的位置"></a>配置搜索库和其他扩展的位置</h4><p>当 Robot Framework 导入测试库、监听器或其他基于 Python 的扩展时，它使用 Python 解释器从系统中导入包含扩展的模块。查找模块的位置列表被称为模块搜索路径，可以使用本节解释的不同方法配置其内容。</p>
<p>如果指定的路径没有直接匹配任何文件，Robot Framework 也会在导入资源和变量文件时使用 Python 的模块搜索路径。</p>
<p>正确设置模块搜索路径以找到库和其他扩展是成功执行测试的要求。如果需要使用下面解释的方法自定义它，创建一个自定义的启动脚本通常是个好主意。</p>
<h5 id="自动在模块搜索路径中的位置"><a href="#自动在模块搜索路径中的位置" class="headerlink" title="自动在模块搜索路径中的位置"></a>自动在模块搜索路径中的位置</h5><p>Python 解释器有自己的标准库，以及一个第三方模块自动安装的目录，在模块搜索路径中。这意味着使用 Python 自己的打包系统打包的测试库会自动安装，以便可以导入它们，无需任何额外的配置。</p>
<h5 id="PYTHONPATH"><a href="#PYTHONPATH" class="headerlink" title="PYTHONPATH"></a>PYTHONPATH</h5><p>Python 从 PYTHONPATH 环境变量中读取要添加到模块搜索路径的额外位置。如果想在其中任何一个环境变量中指定多个位置，需要在类 UNIX 机器上用冒号分隔位置（例如，&#x2F;opt&#x2F;libs:$HOME&#x2F;testlibs），在 Windows 上用分号分隔（例如，D:\libs;%HOMEPATH%\testlibs）。</p>
<p>环境变量可以被永久地配置为系统范围，或者只影响某个用户。或者，它们可以在运行命令之前临时设置，这在自定义启动脚本中工作得非常好。</p>
<h5 id="使用-–pythonpath-选项"><a href="#使用-–pythonpath-选项" class="headerlink" title="使用 –pythonpath 选项"></a>使用 –pythonpath 选项</h5><p>Robot Framework 有一个单独的命令行选项 <code>--pythonpath</code> (<code>-P</code>)，用于向模块搜索路径添加位置。</p>
<p>可以通过用冒号（:）或分号（;）分隔它们，或者多次使用此选项来给出多个位置。如果值包含冒号和分号，那么它将从分号处分割。路径也可以是匹配多个路径的 glob 模式，但是它们通常需要在控制台上使用时进行转义。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--pythonpath libs</span><br><span class="line">--pythonpath /opt/testlibs:mylibs.zip:yourlibs</span><br><span class="line">--pythonpath /opt/testlibs --pythonpath mylibs.zip --pythonpath yourlibs</span><br><span class="line">--pythonpath c:\temp;d:\resources</span><br><span class="line">--pythonpath  lib/\*.zip    # &#x27;*&#x27; 是转义的</span><br></pre></td></tr></table></figure></div>

<p>注意：无论操作系统如何，冒号和分号都可以工作。在 Robot Framework 5.0 中，使用分号是新的。</p>
<h5 id="以编程方式配置-sys-path"><a href="#以编程方式配置-sys-path" class="headerlink" title="以编程方式配置 sys.path"></a>以编程方式配置 sys.path</h5><p>Python 解释器将它们使用的模块搜索路径存储为字符串列表在 sys.path 属性中。这个列表可以在执行过程中动态更新，下次导入某个东西时会考虑到这些更改。</p>
<h4 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h4><p>可以使用 <code>--variable</code> (<code>-v</code>) 选项从命令行单独设置变量，或者通过 <code>--variablefile</code> (<code>-V</code>) 选项通过变量文件设置变量。变量和变量文件在单独的章节中有解释，但以下示例说明了如何使用这些选项：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--variable name:value</span><br><span class="line">--variable OS:Linux --variable IP:10.0.0.42</span><br><span class="line">--variablefile path/to/variables.py</span><br><span class="line">--variablefile myvars.py:possible:arguments:here</span><br><span class="line">--variable ENVIRONMENT:Windows --variablefile c:\resources\windows.py</span><br></pre></td></tr></table></figure></div>

<h4 id="干运行"><a href="#干运行" class="headerlink" title="干运行"></a>干运行</h4><p>Robot Framework 支持所谓的干运行模式，在这种模式下，测试通常会正常运行，但来自测试库的关键字根本不会被执行。干运行模式可以用来验证测试数据；如果干运行通过，数据应该在语法上是正确的。这种模式使用选项 <code>--dryrun</code> 触发。</p>
<p>干运行执行可能会因以下原因失败：</p>
<ul>
<li>使用未找到的关键字。</li>
<li>使用参数数量错误的关键字。</li>
<li>使用语法无效的用户关键字。</li>
</ul>
<p>除了这些失败之外，还会显示正常执行错误，例如，当无法解析测试库或资源文件导入时。</p>
<p>可以通过向特定用户关键字添加一个特殊的 <code>robot:no-dry-run</code> 关键字标签来禁用干运行验证。如果一个关键字在干运行模式下由于某种原因失败，但在正常执行时工作正常，这将很有用。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>干运行模式不验证变量。</p>

    </div>
  </div>

<h4 id="随机化执行顺序"><a href="#随机化执行顺序" class="headerlink" title="随机化执行顺序"></a>随机化执行顺序</h4><p>可以使用选项 <code>--randomize &lt;what&gt;[:&lt;seed&gt;]</code> 来随机化测试执行顺序，其中 <code>&lt;what&gt;</code> 是以下之一：</p>
<ul>
<li><code>tests</code>：每个测试套件内的测试用例以随机顺序执行。</li>
<li><code>suites</code>：所有测试套件以随机顺序执行，但套件内的测试用例按照它们定义的顺序运行。</li>
<li><code>all</code>：测试用例和测试套件都以随机顺序执行。</li>
<li><code>none</code>：测试和套件的执行顺序都不会被随机化。这个值可以用来覆盖之前用 <code>--randomize</code> 设置的值。</li>
</ul>
<p>可以给出一个自定义的种子来初始化随机生成器。如果想使用和之前相同的顺序重新运行测试，这将很有用。种子作为 <code>--randomize</code> 的值的一部分给出，格式为 <code>&lt;what&gt;:&lt;seed&gt;</code>，它必须是一个整数。如果没有给出种子，它将被随机生成。执行的顶级测试套件自动获取名为 <code>Randomized</code> 的元数据，它告诉随机化了什么和使用了什么种子。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --randomize tests my_test.robot</span><br><span class="line">robot --randomize all:12345 path/to/tests</span><br></pre></td></tr></table></figure></div>



<h4 id="编程修改测试数据"><a href="#编程修改测试数据" class="headerlink" title="编程修改测试数据"></a>编程修改测试数据</h4><p>如果提供的内置功能在执行前修改测试数据还不够，Robot Framework 允许以编程方式进行自定义修改。这是通过创建一个所谓的预运行修改器并使用 <code>--prerunmodifier</code> 选项激活它来实现的。</p>
<p>预运行修改器应该作为访问者实现，可以遍历可执行的测试套件结构并根据需要修改它。访问者接口是作为 Robot Framework API 文档的一部分进行解释的，可以使用它来修改执行的测试套件、测试用例和关键字。下面的示例应该能给出如何使用预运行修改器以及这个功能有多强大的想法。</p>
<p>当在命令行上使用 <code>--prerunmodifier</code> 选项启用预运行修改器时，可以指定为修改器类的名称或修改器文件的路径。如果修改器作为类名给出，包含该类的模块必须在模块搜索路径中，如果模块名与类名不同，给定的名称必须包含两者，如 <code>module.ModifierClass</code>。如果修改器作为路径给出，类名必须与文件名相同。在大多数情况下，这与导入测试库的方式完全相同。</p>
<p>如果修改器需要参数，像下面的示例那样，它们可以在修改器名称或路径后使用冒号（:）或分号（;）作为分隔符指定。如果值中使用了两者，那么首先使用的那个被认为是实际的分隔符。从 Robot Framework 4.0 开始，参数也支持命名参数语法，以及基于类型提示和默认值的参数转换，就像关键字一样。</p>
<p>如果需要多个预运行修改器，可以通过多次使用 <code>--prerunmodifier</code> 选项来指定。如果在创建日志和报告之前需要类似的修改，可以使用 <code>--prerebotmodifier</code> 选项启用结果的编程修改。</p>
<p>预运行修改器在影响执行的测试套件和测试用例的其他配置之前执行。最重要的是，选择测试用例的选项在修改器之后处理，使得可以使用 <code>--include</code> 等选项，也可以与可能动态添加的测试一起使用。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>修改器在命令行上的使用方式与监听器完全相同。请参阅从命令行注册监听器部分以获取更多信息和示例。</p>

    </div>
  </div>

<h5 id="示例：选择每个-Xth-测试"><a href="#示例：选择每个-Xth-测试" class="headerlink" title="示例：选择每个 Xth 测试"></a>示例：选择每个 Xth 测试</h5><p>第一个示例展示了如何通过预运行修改器从执行的测试套件结构中移除测试。在此示例中，只保留每个 Xth 测试，X 是从命令行给出的，还有一个可选的起始索引。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;预运行修改器，仅选择每个 Xth 测试进行执行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">默认从第一个测试开始。每个套件选择测试。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> SuiteVisitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectEveryXthTest</span>(<span class="title class_ inherited__">SuiteVisitor</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x: <span class="built_in">int</span>, start: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.start = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">self, suite</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;修改套件的测试，只包含每个 Xth。&quot;&quot;&quot;</span></span><br><span class="line">        suite.tests = suite.tests[self.start::self.x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_suite</span>(<span class="params">self, suite</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;移除测试后为空的套件。&quot;&quot;&quot;</span></span><br><span class="line">        suite.suites = [s <span class="keyword">for</span> s <span class="keyword">in</span> suite.suites <span class="keyword">if</span> s.test_count &gt; <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_test</span>(<span class="params">self, test</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;避免访问测试及其关键字以节省一些时间。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>如果上述预运行修改器在 SelectEveryXthTest.py 文件中，并且该文件在模块搜索路径中，那么可以这样使用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定修改器为路径。运行每个第二个测试。</span></span><br><span class="line">robot --prerunmodifier path/to/SelectEveryXthTest.py:2 tests.robot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定修改器为名称。运行每个第三个测试，从第二个开始。</span></span><br><span class="line">robot --prerunmodifier SelectEveryXthTest:3:1 tests.robot</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>基于类型提示的参数转换，如上例中的 x: int，是 Robot Framework 4.0 中的新特性，需要 Python 3。</p>

    </div>
  </div>

<h5 id="示例：通过名称排除测试"><a href="#示例：通过名称排除测试" class="headerlink" title="示例：通过名称排除测试"></a>示例：通过名称排除测试</h5><p>第二个示例也移除了测试，这次是基于给定的名称模式。实际上，它的工作方式类似于内置的 –test 选项的负版本。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;预运行修改器，通过它们的名称排除测试。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">要排除的测试是通过使用模式指定的，该模式既不区分大小写也不区分空格，</span></span><br><span class="line"><span class="string">并支持 &#x27;*&#x27;（匹配任何内容）和 &#x27;?&#x27;（匹配单个字符）作为通配符。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> SuiteVisitor</span><br><span class="line"><span class="keyword">from</span> robot.utils <span class="keyword">import</span> Matcher</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExcludeTests</span>(<span class="title class_ inherited__">SuiteVisitor</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, pattern</span>):</span><br><span class="line">        self.matcher = Matcher(pattern)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">self, suite</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;移除与给定模式匹配的测试。&quot;&quot;&quot;</span></span><br><span class="line">        suite.tests = [t <span class="keyword">for</span> t <span class="keyword">in</span> suite.tests <span class="keyword">if</span> <span class="keyword">not</span> self._is_excluded(t)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_excluded</span>(<span class="params">self, test</span>):</span><br><span class="line">        <span class="keyword">return</span> self.matcher.<span class="keyword">match</span>(test.name) <span class="keyword">or</span> self.matcher.<span class="keyword">match</span>(test.longname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_suite</span>(<span class="params">self, suite</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;移除测试后为空的套件。&quot;&quot;&quot;</span></span><br><span class="line">        suite.suites = [s <span class="keyword">for</span> s <span class="keyword">in</span> suite.suites <span class="keyword">if</span> s.test_count &gt; <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_test</span>(<span class="params">self, test</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;避免访问测试及其关键字以节省一些时间。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>假设上述修改器在名为 ExcludeTests.py 的文件中，那么可以这样使用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">排除名为 <span class="string">&#x27;Example&#x27;</span> 的测试。</span></span><br><span class="line">robot --prerunmodifier path/to/ExcludeTests.py:Example tests.robot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">排除所有以 <span class="string">&#x27;something&#x27;</span> 结尾的测试。</span></span><br><span class="line">robot --prerunmodifier path/to/ExcludeTests.py:*something tests.robot</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h5 id="示例：禁用设置和拆卸"><a href="#示例：禁用设置和拆卸" class="headerlink" title="示例：禁用设置和拆卸"></a>示例：禁用设置和拆卸</h5><p>有时在调试测试时，禁用设置或拆卸可能很有用。这可以通过编辑测试数据来实现，但预运行修改器使得临时进行单次运行变得容易：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;禁用套件和测试设置和拆卸的预运行修改器。&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> SuiteVisitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuiteSetup</span>(<span class="title class_ inherited__">SuiteVisitor</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">self, suite</span>):</span><br><span class="line">        suite.setup = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuiteTeardown</span>(<span class="title class_ inherited__">SuiteVisitor</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">self, suite</span>):</span><br><span class="line">        suite.teardown = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSetup</span>(<span class="title class_ inherited__">SuiteVisitor</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_test</span>(<span class="params">self, test</span>):</span><br><span class="line">        test.setup = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTeardown</span>(<span class="title class_ inherited__">SuiteVisitor</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_test</span>(<span class="params">self, test</span>):</span><br><span class="line">        test.teardown = <span class="literal">None</span></span><br></pre></td></tr></table></figure></div>

<p>假设上述修改器都在名为 disable.py 的文件中，并且此文件在模块搜索路径中，可以按以下方式禁用设置和拆卸：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用套件拆卸。</span></span><br><span class="line">robot --prerunmodifier disable.SuiteTeardown tests.robot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过两次使用 <span class="string">&#x27;--prerunmodifier&#x27;</span> 来禁用测试设置和拆卸。</span></span><br><span class="line">robot --prerunmodifier disable.TestSetup --prerunmodifier disable.TestTeardown tests.robot</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 4.0 之前，通过中间关键字属性访问设置和拆卸，例如，套件设置被禁用像 suite.keywords.setup &#x3D; None。</p>

    </div>
  </div>

<h4 id="控制控制台输出"><a href="#控制控制台输出" class="headerlink" title="控制控制台输出"></a>控制控制台输出</h4><p>有多种命令行选项可以控制如何在控制台上报告测试执行情况。</p>
<h5 id="控制台输出类型"><a href="#控制台输出类型" class="headerlink" title="控制台输出类型"></a>控制台输出类型</h5><p>使用 –console 选项设置整体控制台输出类型。它支持以下不区分大小写的值：</p>
<ul>
<li><strong>verbose</strong>：每个测试套件和测试用例都单独报告。这是默认设置。</li>
<li><strong>dotted</strong>：只显示 . 表示通过的测试，F 表示失败的测试，s 表示跳过的测试，x 表示因测试执行退出而跳过的测试。执行后，失败的测试会单独列出。此输出类型使得即使有很多测试，也能轻松看到执行过程中是否有任何失败。</li>
<li><strong>quiet</strong>：除错误和警告外，没有任何输出。</li>
<li><strong>none</strong>：完全没有输出。在创建自定义输出时（例如，使用监听器）很有用。</li>
</ul>
<p>单独的便利选项 –dotted (-.) 和 –quiet 是 –console dotted 和 –console quiet 的快捷方式。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --console quiet tests.robot</span><br><span class="line">robot --dotted tests.robot</span><br></pre></td></tr></table></figure></div>

<h5 id="控制台宽度"><a href="#控制台宽度" class="headerlink" title="控制台宽度"></a>控制台宽度</h5><p>可以使用 –consolewidth (-W) 选项设置控制台中测试执行输出的宽度。默认宽度为78个字符。</p>
<p>提示</p>
<p>在许多类 UNIX 机器上，可以使用方便的 $COLUMNS 环境变量，如 –consolewidth $COLUMNS。</p>
<h5 id="控制台颜色"><a href="#控制台颜色" class="headerlink" title="控制台颜色"></a>控制台颜色</h5><p>–consolecolors (-C) 选项用于控制是否应在控制台输出中使用颜色。颜色使用 ANSI 颜色实现，除了在 Windows 上，默认情况下使用 Windows API。</p>
<p>此选项支持以下不区分大小写的值：</p>
<ul>
<li><strong>auto</strong>：当输出写入控制台时启用颜色，但当它们被重定向到文件或其他地方时不启用。这是默认设置。</li>
<li><strong>on</strong>：当输出被重定向时也使用颜色。在 Windows 上不起作用。</li>
<li><strong>ansi</strong>：与 on 相同，但在 Windows 上也使用 ANSI 颜色。例如，当将输出重定向到理解 ANSI 颜色的程序时很有用。</li>
<li><strong>off</strong>：禁用颜色。</li>
</ul>
<h5 id="控制台标记"><a href="#控制台标记" class="headerlink" title="控制台标记"></a>控制台标记</h5><p>当使用详细输出并在测试用例的顶级关键字结束时，控制台上会显示特殊标记 .（成功）和 F（失败）。标记允许在高级别跟踪测试执行，当测试用例结束时，它们会被擦除。</p>
<p>可以使用 –consolemarkers (-K) 选项配置何时使用标记。它支持以下不区分大小写的值：</p>
<ul>
<li><strong>auto</strong>：当标准输出写入控制台时启用标记，但当它被重定向到文件或其他地方时不启用。这是默认设置。</li>
<li><strong>on</strong>：始终使用标记。</li>
<li><strong>off</strong>：禁用标记。</li>
</ul>
<h4 id="设置监听器"><a href="#设置监听器" class="headerlink" title="设置监听器"></a>设置监听器</h4><p>监听器可以用来监视测试执行。当它们从命令行中使用时，它们是使用 –listener 命令行选项指定的。值可以是监听器的路径或监听器的名称。有关导入监听器和一般使用它们的更多详细信息，请参见监听器接口部分。</p>
<h3 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h3><p>当执行测试时，会创建多个输出文件，所有这些文件都与测试结果有关。本节讨论创建哪些输出，如何配置它们的创建位置，以及如何微调它们的内容。</p>
<h4 id="不同的输出文件"><a href="#不同的输出文件" class="headerlink" title="不同的输出文件"></a>不同的输出文件</h4><p>本节解释可以创建哪些不同的输出文件以及如何配置它们的创建位置。输出文件是使用命令行选项配置的，这些选项获取作为参数的输出文件的路径。可以使用特殊值 NONE（不区分大小写）来禁用创建某个特定的输出文件。</p>
<h5 id="输出目录"><a href="#输出目录" class="headerlink" title="输出目录"></a>输出目录</h5><p>所有输出文件都可以使用绝对路径设置，在这种情况下，它们将被创建到指定的位置，但在其他情况下，路径被认为是相对于输出目录的。默认的输出目录是开始执行的目录，但可以使用 –outputdir (-d) 选项进行更改。此选项设置的路径再次相对于执行目录，但自然也可以作为绝对路径给出。无论如何获取到单个输出文件的路径，如果其父目录尚不存在，将自动创建。</p>
<h5 id="输出文件-1"><a href="#输出文件-1" class="headerlink" title="输出文件"></a>输出文件</h5><p>输出文件包含所有以机器可读的 XML 格式的测试执行结果。日志、报告和 xUnit 文件通常基于它们生成，并且它们也可以与 Rebot 一起进行组合和其他后处理。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>在测试执行的过程中生成报告和 xUnit 文件不需要在执行后处理输出文件。因此，运行测试时禁用日志生成可以节省内存。</p>

    </div>
  </div>

<p>命令行选项 –output (-o) 确定相对于输出目录创建输出文件的路径。当运行测试时，输出文件的默认名称是 output.xml。</p>
<p>使用 Rebot 对输出进行后处理时，除非明确使用了 –output 选项，否则不会创建新的输出文件。</p>
<p>在运行测试时，可以通过给 –output 选项赋予特殊值 NONE 来禁用创建输出文件。如果不需要任何输出，那么应该使用 –output NONE –report NONE –log NONE 明确禁用所有输出。</p>
<p>XML 输出文件结构在 robot.xsd 架构文件中有文档记录。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>从 Robot Framework 7.0 开始，Rebot 可以读取和写入 JSON 输出文件。计划是在未来增强对 JSON 输出文件的支持，以便它们可以在执行期间就创建。有关更多详细信息，请参阅问题 #3423。</p>

    </div>
  </div>

<h5 id="旧版输出文件格式"><a href="#旧版输出文件格式" class="headerlink" title="旧版输出文件格式"></a>旧版输出文件格式</h5><p>在 Robot Framework 7.0 中，输出文件格式发生了一些向后不兼容的更改。为了使得可以使用新版本的 Robot Framework 与尚未更新以支持新格式的外部工具一起使用，有一个 –legacyoutput 选项，该选项生成与 Robot Framework 6.x 及更早版本兼容的输出文件。Robot Framework 本身可以处理旧格式和新格式的输出文件。</p>
<h5 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h5><p>日志文件以 HTML 格式包含有关执行的测试用例的详细信息。它们具有层次结构，显示测试套件、测试用例和关键字详细信息。几乎每次需要详细调查测试结果时，都需要日志文件。尽管日志文件也有统计信息，但报告更适合获取更高级别的概述。</p>
<p>命令行选项 <code>--log (-l)</code> 确定创建日志文件的位置。除非使用特殊值 <code>NONE</code>，否则总是会创建日志文件，其默认名称为 <code>log.html</code>。</p>
<p>示例日志文件的开始：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/51120498-1e4d-4ff1-7174-748d8e830d00/public"
                      width = "600"
                >

<p>示例日志文件，可见关键字详细信息：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7a0b8697-21e4-4e9e-b22a-3fd202cfb600/public"
                      width = "600"
                >

<p>示例日志文件，跳过和通过的测试：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/593d9fd8-0a8c-480f-d07e-f8dec216af00/public"
                      width = "600"
                >

<h5 id="报告文件"><a href="#报告文件" class="headerlink" title="报告文件"></a>报告文件</h5><p>报告文件以 HTML 格式包含测试执行结果的概述。它们基于标签和执行的测试套件有统计信息，以及所有执行的测试用例的列表。当生成报告和日志时，报告有链接到日志文件，以便轻松导航到更详细的信息。从报告中很容易看到整体的测试执行状态，因为如果所有测试都通过，其背景颜色为绿色，如果有任何测试失败，背景颜色为亮红色。背景也可以是黄色，这意味着所有测试都被跳过。</p>
<p>命令行选项 –report (-r) 确定创建报告文件的位置。与日志文件类似，除非使用 NONE 作为值，否则总是会创建报告，其默认名称为 report.html。</p>
<p>成功测试执行的示例报告文件：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7f041165-1451-418f-d454-1c4785938100/public"
                      width = "600"
                >

<p>失败测试执行的示例报告文件：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bf52e2d4-81e5-4a49-ee76-6d131c334700/public"
                      width = "600"
                >



<h5 id="XUnit-兼容结果文件"><a href="#XUnit-兼容结果文件" class="headerlink" title="XUnit 兼容结果文件"></a>XUnit 兼容结果文件</h5><p>XUnit 结果文件包含以 XUnit 兼容的 XML 格式的测试执行摘要。因此，这些文件可以作为理解 XUnit 报告的外部工具的输入。例如，Jenkins 持续集成服务器支持基于 XUnit 兼容结果生成统计信息。</p>
<p>提示</p>
<p>Jenkins 还有一个单独的 Robot Framework 插件。</p>
<p>除非明确使用命令行选项 –xunit (-x)，否则不会创建 XUnit 输出文件。此选项需要一个路径作为值，该路径是相对于输出目录的生成的 XUnit 文件。</p>
<p>在 Robot Framework 5.0 中，XUnit 输出文件发生了重大变化。它们现在包含每个套件的单独的 <testsuite> 元素，<testsuite> 元素具有时间戳属性，套件文档和元数据存储为 <property> 元素。</p>
<h5 id="调试文件"><a href="#调试文件" class="headerlink" title="调试文件"></a>调试文件</h5><p>调试文件是在测试执行期间编写的纯文本文件。所有从测试库获取的消息都写入它们，以及关于开始和结束的测试套件、测试用例和关键字的信息。调试文件可以用于监视测试执行。这可以使用，例如，一个单独的 fileviewer.py 工具，或者在类 UNIX 系统中，简单地使用 tail -f 命令。</p>
<p>除非明确使用命令行选项 –debugfile (-b)，否则不会创建调试文件。</p>
<h5 id="时间戳输出文件"><a href="#时间戳输出文件" class="headerlink" title="时间戳输出文件"></a>时间戳输出文件</h5><p>Robot Framework 本身生成的所有输出文件都可以使用选项 –timestampoutputs (-T) 自动添加时间戳。当使用此选项时，将在每个文件的扩展名和基本名称之间放置一个格式为 YYYYMMDD-hhmmss 的时间戳。例如，下面的示例将创建像 output-20080604-163225.xml 和 mylog-20080604-163225.html 这样的输出文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot --timestampoutputs --log mylog.html --report NONE tests.robot</span><br></pre></td></tr></table></figure></div>

<h5 id="设置标题"><a href="#设置标题" class="headerlink" title="设置标题"></a>设置标题</h5><p>日志和报告的默认标题是通过在顶级测试套件的名称前加上 Test Log 或 Test Report 来生成的。可以使用选项 –logtitle 和 –reporttitle 分别从命令行给出自定义标题。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot --logtitle &quot;Smoke Test Log&quot; --reporttitle &quot;Smoke Test Report&quot; --include smoke my_tests/</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 之前，给定标题中的下划线被转换为空格。现在，空格需要像上面的示例那样被转义或引用。</p>

    </div>
  </div>

<h5 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h5><p>默认情况下，如果有失败，报告文件的背景为红色，如果有通过的测试和可能跳过的一些测试，背景为绿色，如果所有测试都被跳过或没有运行任何测试，背景为黄色。可以使用 –reportbackground 命令行选项自定义这些颜色，该选项接受两个或三个用冒号分隔的颜色作为参数：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--reportbackground blue:red</span><br><span class="line">--reportbackground blue:red:orange</span><br><span class="line">--reportbackground #00E:#E00</span><br></pre></td></tr></table></figure></div>

<p>如果指定了两种颜色，第一种将替代默认的绿色（通过）颜色，第二种将替代默认的红色（失败）。这允许，例如，使用蓝色代替绿色，使得背景更容易为色盲人士分辨。</p>
<p>如果指定了三种颜色，前两种具有与以前相同的语义，最后一种替换默认的黄色（跳过）颜色。</p>
<p>指定的颜色用作 body 元素的背景 CSS 属性的值。该值按原样使用，可以是 HTML 颜色名称（例如，red）、十六进制值（例如，#f00 或 #ff0000）或 RGB 值（例如，rgb(255,0,0)）。默认的绿色、红色和黄色分别使用十六进制值 #9e9、#f66 和 #fed84f 指定。</p>
<p>​                            </p>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><h4 id="可用的日志级别"><a href="#可用的日志级别" class="headerlink" title="可用的日志级别"></a>可用的日志级别</h4><p>日志文件中的消息可以有不同的日志级别。一些消息是由 Robot Framework 本身编写的，但也可以执行关键字以使用不同级别的信息进行记录。可用的日志级别有：</p>
<ul>
<li><strong>FAIL</strong>：当关键字失败时使用。只能由 Robot Framework 本身使用。</li>
<li><strong>WARN</strong>：用于显示警告。它们也会在控制台和日志文件的测试执行错误部分中显示，但它们不会影响测试用例的状态。</li>
<li><strong>INFO</strong>：正常消息的默认级别。默认情况下，此级别以下的消息不会显示在日志文件中。</li>
<li><strong>DEBUG</strong>：用于调试目的。例如，对于记录库在内部正在做什么很有用。当关键字失败时，将自动使用此级别记录一个回溯，显示代码中失败发生的位置。</li>
<li><strong>TRACE</strong>：更详细的调试级别。关键字参数和返回值会自动使用此级别进行记录。</li>
</ul>
<h4 id="设置日志级别"><a href="#设置日志级别" class="headerlink" title="设置日志级别"></a>设置日志级别</h4><p>默认情况下，INFO 级别以下的日志消息不会被记录，但可以使用 –loglevel (-L) 选项从命令行更改此阈值。此选项接受任何可用的日志级别作为参数，该级别成为新的阈值级别。还可以使用特殊值 NONE 来完全禁用日志记录。</p>
<p>也可以在使用 Rebot 对输出进行后处理时使用 –loglevel 选项。这允许，例如，首先使用 TRACE 级别运行测试，然后使用 INFO 级别生成较小的日志文件以供正常查看。默认情况下，执行期间包含的所有消息也将包含在 Rebot 中。执行期间忽略的消息无法恢复。</p>
<p>更改日志级别的另一种可能性是在测试数据中使用 BuiltIn 关键字 Set Log Level。它接受与 –loglevel 选项相同的参数，并且它还返回旧的级别，以便稍后可以恢复，例如，在测试拆卸中。</p>
<h4 id="可见的日志级别"><a href="#可见的日志级别" class="headerlink" title="可见的日志级别"></a>可见的日志级别</h4><p>如果日志文件包含 DEBUG 或 TRACE 级别的消息，则在右上角显示一个可见的日志级别下拉菜单。这允许用户从视图中移除所选级别以下的消息。这在运行 TRACE 级别的测试时尤其有用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9cc77ea9-064a-430b-ca42-a40a32760e00/public"
                      width = "600"
                >

<p>默认情况下，下拉菜单将设置为日志文件中的最低级别，因此所有消息都会显示。可以使用 –loglevel 选项更改默认的可见日志级别，方法是在正常日志级别后面用冒号给出默认值：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--loglevel DEBUG:INFO</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中，测试使用 DEBUG 级别运行，但日志文件中的默认可见级别是 INFO。</p>
<h3 id="分割日志"><a href="#分割日志" class="headerlink" title="分割日志"></a>分割日志</h3><p>通常，日志文件只是一个单独的 HTML 文件。当测试用例的数量增加时，文件的大小可能会变得如此大，以至于在浏览器中打开它变得不便或甚至不可能。因此，可以使用 –splitlog 选项将日志的部分内容分割到需要时可以透明地加载到浏览器中的外部文件中。</p>
<p>分割日志的主要好处是，单个日志部分非常小，即使测试数据的数量非常大，也可以打开和浏览日志文件。一个小缺点是日志文件占用的总大小会增加。</p>
<p>从技术上讲，与每个测试用例相关的测试数据被保存到与主日志文件相同的文件夹中的 JavaScript 文件中。这些文件的名称如 log-42.js，其中 log 是主日志文件的基本名称，42 是递增的索引。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在复制日志文件时，需要复制所有的 log-*.js 文件，否则一些信息将会丢失。</p>

    </div>
  </div>

<h4 id="配置统计信息"><a href="#配置统计信息" class="headerlink" title="配置统计信息"></a>配置统计信息</h4><p>有几个命令行选项可以用来配置和调整不同输出文件中的“按标签统计”、“按套件统计”和“按标签详细测试”表格的内容。所有这些选项都在执行测试用例和后处理输出时起作用。</p>
<h5 id="配置显示的套件统计信息"><a href="#配置显示的套件统计信息" class="headerlink" title="配置显示的套件统计信息"></a>配置显示的套件统计信息</h5><p>当执行更深层次的套件结构时，在“按套件统计”表中显示所有测试套件级别可能会使表格有些难以阅读。默认情况下显示所有套件，但可以使用命令行选项 –suitestatlevel 控制显示的套件级别，该选项接受要显示的套件级别作为参数：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--suitestatlevel 3</span><br></pre></td></tr></table></figure></div>

<h5 id="包含和排除标签统计信息"><a href="#包含和排除标签统计信息" class="headerlink" title="包含和排除标签统计信息"></a>包含和排除标签统计信息</h5><p>当使用许多标签时，“按标签统计”表可能会变得相当拥挤。如果发生这种情况，可以使用命令行选项 –tagstatinclude 和 –tagstatexclude 来选择要显示的标签，类似于使用 –include 和 –exclude 来选择测试用例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--tagstatinclude some-tag --tagstatinclude another-tag</span><br><span class="line">--tagstatexclude owner-*</span><br><span class="line">--tagstatinclude prefix-* --tagstatexclude prefix-13</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8dd82891-bf26-465a-2f08-616832e84700/public"
                      width = "600"
                >

<h5 id="生成组合标签统计信息"><a href="#生成组合标签统计信息" class="headerlink" title="生成组合标签统计信息"></a>生成组合标签统计信息</h5><p>命令行选项 –tagstatcombine 可用于生成聚合标签，这些标签将多个标签的统计信息组合在一起。组合标签使用标签模式指定，其中 * 和 ? 作为通配符受支持，AND、OR 和 NOT 运算符可用于将单个标签或模式组合在一起。</p>
<p>以下示例说明了使用不同模式创建组合标签统计信息，下面的图表显示了生成的“按标签统计”表的一部分：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--tagstatcombine owner-*</span><br><span class="line">--tagstatcombine smokeANDmytag</span><br><span class="line">--tagstatcombine smokeNOTowner-janne*</span><br></pre></td></tr></table></figure></div>

<p>如上例所示，默认情况下，添加的组合统计的名称只是给定的模式。如果这还不够好，可以在模式后面用冒号 (:) 分隔给出自定义名称：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--tagstatcombine &quot;prio1ORprio2:High priority tests&quot;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 之前，自定义名称中的下划线被转换为空格。现在，空格需要像上面的示例那样被转义或引用。</p>

    </div>
  </div>

<h5 id="从标签名称创建链接"><a href="#从标签名称创建链接" class="headerlink" title="从标签名称创建链接"></a>从标签名称创建链接</h5><p>可以使用命令行选项 –tagstatlink 向“按标签统计”表添加外部链接。此选项的参数以 tag:link:name 的格式给出，其中 tag 指定要将链接分配给的标签，link 是要创建的链接，name 是要给链接的名称。</p>
<p>tag 可能是一个单一的标签，但更常见的是一个简单的模式，其中 * 匹配任何内容，? 匹配任何单个字符。当 tag 是一个模式时，可以使用语法 %N 在链接和标题中使用通配符的匹配，其中 “N” 是从 1 开始的匹配索引。</p>
<p>以下示例说明了此选项的使用，下面的图表显示了当使用这些选项执行示例测试数据时，生成的“按标签统计”表的一部分：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--tagstatlink mytag:http://www.google.com:Google</span><br><span class="line">--tagstatlink example-bug-*:http://example.com</span><br><span class="line">--tagstatlink owner-*:mailto:%1@domain.com?subject=Acceptance_Tests:Send_Mail</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/33f1f2de-75e4-4140-3f48-628a0cd44800/public"
                      width = "600"
                >

<h5 id="为标签添加文档"><a href="#为标签添加文档" class="headerlink" title="为标签添加文档"></a>为标签添加文档</h5><p>可以使用命令行选项 –tagdoc 给标签添加文档，该选项接受以 tag:doc 格式的参数。tag 是要分配文档的标签的名称，它也可以是匹配多个标签的简单模式。doc 是分配的文档。它可以包含简单的 HTML 格式。</p>
<p>给定的文档将在“按标签详细测试”表中与匹配的标签一起显示，并作为这些标签在“按标签统计”表中的工具提示显示。如果一个标签获得多个文档，它们将被组合在一起，并用和号分隔。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--tagdoc mytag:Example</span><br><span class="line">--tagdoc &quot;regression:*See* http://info.html&quot;</span><br><span class="line">--tagdoc &quot;owner-*:Original author&quot;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 之前，文档中的下划线被转换为空格。现在，空格需要像上面的示例那样被转义或引用。</p>

    </div>
  </div>

<h4 id="移除和展平关键字"><a href="#移除和展平关键字" class="headerlink" title="移除和展平关键字"></a>移除和展平关键字</h4><p>输出文件的大部分内容来自关键字及其日志消息。当创建更高级别的报告时，可能根本不需要日志文件，此时关键字及其消息只会无谓地占用空间。日志文件本身也可能变得过大，尤其是如果它们包含 FOR 循环或其他重复某些关键字多次的结构。</p>
<p>在这些情况下，可以使用命令行选项 –removekeywords 和 –flattenkeywords 来丢弃或展平不必要的关键字。它们可以在执行测试用例和后处理输出时使用。在执行期间使用时，它们只影响日志文件，而不影响 XML 输出文件。使用 rebot 时，它们会影响日志和可能生成的新的输出 XML 文件。</p>
<h5 id="移除关键字"><a href="#移除关键字" class="headerlink" title="移除关键字"></a>移除关键字</h5><p>–removekeywords 选项完全移除关键字及其消息。它有以下操作模式，可以多次使用以启用多个模式。包含错误或警告的关键字不会被移除，除非使用 ALL 模式。</p>
<ul>
<li><strong>ALL</strong>：无条件地从所有关键字中移除数据。</li>
<li><strong>PASSED</strong>：从通过的测试用例中移除关键字数据。在大多数情况下，使用此选项创建的日志文件包含足够的信息来调查可能的失败。</li>
<li><strong>FOR</strong>：除最后一个之外，从 FOR 循环中移除所有通过的迭代。</li>
<li><strong>WHILE</strong>：除最后一个之外，从 WHILE 循环中移除所有通过的迭代。</li>
<li><strong>WUKS</strong>：除最后一个之外，从 BuiltIn 关键字 Wait Until Keyword Succeeds 中移除所有失败的关键字。</li>
<li>**NAME:<pattern>**：无论关键字状态如何，都从与给定模式匹配的所有关键字中移除数据。该模式与关键字的全名匹配，前缀为可能的库或资源文件名称，如 MyLibrary.Keyword Name。该模式对大小写、空格和下划线不敏感，并支持使用 *, ? 和 [] 作为通配符的简单模式。</li>
<li>**TAG:<pattern>**：从标签与给定模式匹配的关键字中移除数据。标签对大小写和空格不敏感，可以使用标签模式指定，其中 *, ? 和 [] 作为通配符受支持，AND、OR 和 NOT 运算符可以用于将单个标签或模式组合在一起。可以同时使用库关键字标签和用户关键字标签。</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rebot --removekeywords all --output removed.xml output.xml</span><br><span class="line">robot --removekeywords passed --removekeywords for tests.robot</span><br><span class="line">robot --removekeywords name:HugeKeyword --removekeywords name:resource.* tests.robot</span><br><span class="line">robot --removekeywords tag:huge tests.robot</span><br></pre></td></tr></table></figure></div>

<p>移除关键字是在解析输出文件并基于它生成内部模型之后完成的。因此，它并不像展平关键字那样减少内存使用。</p>
<h5 id="展平关键字"><a href="#展平关键字" class="headerlink" title="展平关键字"></a>展平关键字</h5><p>–flattenkeywords 选项会展平匹配的关键字。实际上，这意味着匹配的关键字会递归地获取其子关键字的所有日志消息，而子关键字则被否则丢弃。展平支持以下模式：</p>
<ul>
<li><strong>FOR</strong>：完全展平 FOR 循环。</li>
<li><strong>WHILE</strong>：完全展平 WHILE 循环。</li>
<li><strong>ITERATION</strong>：展平单个 FOR 和 WHILE 循环的迭代。</li>
<li><strong>FORITEM</strong>：ITERATION 的已弃用别名。</li>
<li>**NAME:<pattern>**：展平与给定模式匹配的关键字。模式匹配规则与使用 NAME:<pattern> 模式移除关键字时相同。</li>
<li>**TAG:<pattern>**：展平标签与给定模式匹配的关键字。模式匹配规则与使用 TAG:<pattern> 模式移除关键字时相同。</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --flattenkeywords name:HugeKeyword --flattenkeywords name:resource.* tests.robot</span><br><span class="line">rebot --flattenkeywords foritem --output flattened.xml original.xml</span><br></pre></td></tr></table></figure></div>

<p>展平关键字是在最初解析输出文件并基于它生成内部模型时完成的。这可以节省大量的内存，尤其是在关键字结构深度嵌套的情况下。</p>
<h5 id="在执行时间内展平关键字"><a href="#在执行时间内展平关键字" class="headerlink" title="在执行时间内展平关键字"></a>在执行时间内展平关键字</h5><p>从 Robot Framework 6.1 开始，可以在执行时间内启用关键字展平。这只能在用户关键字级别上通过定义保留标签 robot:flatten 作为关键字标签来完成。使用此标签的工作方式与前一章中描述的命令行选项类似，例如，除日志消息外，所有内容都从具有该标签的关键字下移除。一个重要的区别是，在这种情况下，移除的内容根本不会写入输出文件，因此无法在以后的时间内访问。</p>
<p>一些示例</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Flattening affects this keyword and all it&#x27;s children</span><br><span class="line">    [Tags]    robot:flatten</span><br><span class="line">    Log    something</span><br><span class="line">    FOR     $&#123;i&#125;     IN RANGE     2</span><br><span class="line">         Log    The message is preserved but for loop iteration is not</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">*** Settings ***</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Flatten content of all uer keywords</span></span><br><span class="line">Keyword Tags    robot:flatten</span><br></pre></td></tr></table></figure></div>

<p>​           </p>
<h4 id="自动展开关键字"><a href="#自动展开关键字" class="headerlink" title="自动展开关键字"></a>自动展开关键字</h4><p>默认情况下，通过的关键字在日志文件中是关闭的。因此，除非展开它们，否则它们包含的信息不可见。如果某些关键字有重要的信息，应在打开日志文件时可见，可以使用 –expandkeywords 选项将关键字设置为在日志文件中自动展开，类似于失败的关键字。展开支持以下模式：</p>
<ul>
<li>**NAME:<pattern>**：展开与给定模式匹配的关键字。模式匹配规则与使用 NAME:<pattern> 模式移除关键字时相同。</li>
<li>**TAG:<pattern>**：展开标签与给定模式匹配的关键字。模式匹配规则与使用 TAG:<pattern> 模式移除关键字时相同。</li>
</ul>
<p>如果需要展开匹配不同名称或模式的关键字，可以多次使用 –expandkeywords。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --expandkeywords name:SeleniumLibrary.CapturePageScreenshot tests.robot</span><br><span class="line">rebot --expandkeywords tag:example --expandkeywords tag:another output.xml</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>–expandkeywords 选项是在 Robot Framework 3.2 中新增的。</p>

    </div>
  </div>

<h4 id="设置执行的开始和结束时间"><a href="#设置执行的开始和结束时间" class="headerlink" title="设置执行的开始和结束时间"></a>设置执行的开始和结束时间</h4><p>当使用 Rebot 合并输出时，可以使用选项 –starttime 和 –endtime 分别设置合并测试套件的开始和结束时间。这很方便，因为默认情况下，合并的套件没有这些值。当给出开始和结束时间时，也会根据它们计算经过的时间。否则，经过的时间是通过将子测试套件的经过时间加在一起得到的。</p>
<p>也可以使用上述选项在使用 Rebot 时为单个套件设置开始和结束时间。对单个输出使用这些选项总是会影响套件的经过时间。</p>
<p>时间必须以时间戳的格式给出，格式为 YYYY-MM-DD hh:mm:ss.mil，其中所有分隔符都是可选的，可以省略从毫秒到小时的部分。例如，2008-06-11 17:59:20.495 等同于 20080611-175920.495 和 20080611175920495，而仅仅是 20080611 也可以工作。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rebot --starttime 20080611-17:59:20.495 output1.xml output2.xml</span><br><span class="line">rebot --starttime 20080611-175920 --endtime 20080611-180242 *.xml</span><br><span class="line">rebot --starttime 20110302-1317 --endtime 20110302-11418 myoutput.xml</span><br></pre></td></tr></table></figure></div>



<h4 id="限制报告中错误消息的长度"><a href="#限制报告中错误消息的长度" class="headerlink" title="限制报告中错误消息的长度"></a>限制报告中错误消息的长度</h4><p>如果一个测试用例失败并且有一个长的错误消息，报告中显示的消息会自动从中间剪切，以保持报告更易于阅读。默认情况下，超过 40 行的消息会被剪切，但可以使用 –maxerrorlines 命令行选项进行配置。此选项的最小值为 10，也可以使用特殊值 NONE 来显示完整的消息。</p>
<p>完整的错误消息始终作为失败关键字的消息在日志文件中可见。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>–maxerrorlines 选项是在 Robot Framework 3.1 中新增的。</p>

    </div>
  </div>

<h4 id="编程修改结果"><a href="#编程修改结果" class="headerlink" title="编程修改结果"></a>编程修改结果</h4><p>如果提供的内置功能不足以修改结果，Robot Framework 使得可以通过编程方式进行自定义修改。这是通过创建一个模型修改器并使用 –prerebotmodifier 选项激活它来实现的。</p>
<p>此功能几乎完全像可以使用 –prerunmodifier 选项启用的测试数据的编程修改一样工作。明显的区别是这次修改器操作的是结果模型，而不是运行模型。例如，以下修改器将所有超过允许时间的通过测试标记为失败：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> SuiteVisitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutionTimeChecker</span>(<span class="title class_ inherited__">SuiteVisitor</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_seconds: <span class="built_in">float</span></span>):</span><br><span class="line">        self.max_milliseconds = max_seconds * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_test</span>(<span class="params">self, test</span>):</span><br><span class="line">        <span class="keyword">if</span> test.status == <span class="string">&#x27;PASS&#x27;</span> <span class="keyword">and</span> test.elapsedtime &gt; self.max_milliseconds:</span><br><span class="line">            test.status = <span class="string">&#x27;FAIL&#x27;</span></span><br><span class="line">            test.message = <span class="string">&#x27;Test execution took too long.&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>如果上述修改器位于 ExecutionTimeChecker.py 文件中，例如可以这样使用它：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在运行测试时指定修改器作为路径。最大时间是42秒。</span></span><br><span class="line">robot --prerebotmodifier path/to/ExecutionTimeChecker.py:42 tests.robot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在使用 Rebot 时以名称指定修改器。最大时间是3.14秒。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ExecutionTimeChecker.py 必须在模块搜索路径中。</span></span><br><span class="line">rebot --prerebotmodifier ExecutionTimeChecker:3.14 output.xml</span><br></pre></td></tr></table></figure></div>

<p>如果需要多个模型修改器，可以通过多次使用 –prerebotmodifier 选项来指定它们。在执行测试时，可以同时使用 –prerunmodifier 和 –prerebotmodifier 选项。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>基于类型提示（如上例中的 max_seconds: float）的参数转换是在 Robot Framework 4.0 中新增的，并且需要 Python 3。</p>

    </div>
  </div>

<h4 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h4><p>Robot Framework 有自己的纯文本系统日志，其中写入了关于以下信息：</p>
<ul>
<li>处理和跳过的测试数据文件</li>
<li>导入的测试库、资源文件和变量文件</li>
<li>执行的测试套件和测试用例</li>
<li>创建的输出</li>
</ul>
<p>通常，用户永远不需要这些信息，但在调查测试库或 Robot Framework 本身的问题时，它可能会有用。默认情况下不会创建系统日志，但可以通过设置环境变量 ROBOT_SYSLOG_FILE 以包含所选文件的路径来启用它。</p>
<p>系统日志具有与普通日志文件相同的日志级别，但除了 FAIL，它具有 ERROR 级别。可以使用 ROBOT_SYSLOG_LEVEL 环境变量更改要使用的阈值级别，如下例所示。可能的意外错误和警告除了在控制台和普通日志文件中写入外，还写入系统日志。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">export ROBOT_SYSLOG_FILE=/tmp/syslog.txt</span><br><span class="line">export ROBOT_SYSLOG_LEVEL=DEBUG</span><br><span class="line"></span><br><span class="line">robot --name Syslog_example path/to/tests</span><br></pre></td></tr></table></figure></div>

<p>​            </p>
<h2 id="扩展-Robot-Framework"><a href="#扩展-Robot-Framework" class="headerlink" title="扩展 Robot Framework"></a>扩展 Robot Framework</h2><h3 id="创建测试库"><a href="#创建测试库" class="headerlink" title="创建测试库"></a>创建测试库</h3><p>Robot Framework 的实际测试能力由测试库提供。有许多现有的库，其中一些甚至与核心框架捆绑在一起，但仍然经常需要创建新的库。这项任务并不复杂，因为如本章所示，Robot Framework 的库 API 是简单直接的。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h5 id="支持的编程语言"><a href="#支持的编程语言" class="headerlink" title="支持的编程语言"></a>支持的编程语言</h5><p>Robot Framework 本身是用 Python 编写的，自然地，扩展它的测试库可以使用相同的语言实现。也可以使用 Python C API 用 C 实现库，尽管通常使用 ctypes 模块从 Python 库与 C 代码交互更容易。</p>
<p>使用 Python 实现的库也可以作为包装器来实现使用其他编程语言实现的功能。这种方法的一个好例子是 Remote 库，另一个广泛使用的方法是作为单独的进程运行外部脚本或工具。</p>
<h5 id="不同的测试库-API"><a href="#不同的测试库-API" class="headerlink" title="不同的测试库 API"></a>不同的测试库 API</h5><p>Robot Framework 有三种不同的测试库 API。</p>
<ul>
<li><strong>静态 API</strong>：最简单的方法是拥有直接映射到关键字名称的函数&#x2F;方法的模块或类。关键字也接受与实现它们的方法相同的参数。关键字通过异常报告失败，通过写入标准输出进行日志记录，并可以使用 return 语句返回值。</li>
<li><strong>动态 API</strong>：动态库是实现一个方法以获取它们实现的关键字的名称，以及另一个方法以给定的参数执行一个命名的关键字的类。关键字的名称以及如何执行它们可以在运行时动态确定，但报告状态、日志记录和返回值的方式与静态 API 中的方式相同。</li>
<li><strong>混合 API</strong>：这是静态 API 和动态 API 之间的混合。库是具有告知它们实现了哪些关键字的方法的类，但这些关键字必须直接可用。除了发现实现了哪些关键字之外，其他所有事情都与静态 API 相似。</li>
</ul>
<p>本章将描述所有这些 API。一切都基于静态 API 的工作方式，因此首先讨论其功能。然后在各自的部分中讨论动态库 API 和混合库 API 与其的区别。</p>
<h4 id="创建测试库类或模块"><a href="#创建测试库类或模块" class="headerlink" title="创建测试库类或模块"></a>创建测试库类或模块</h4><p>测试库可以实现为 Python 模块或类。</p>
<h5 id="库名称"><a href="#库名称" class="headerlink" title="库名称"></a>库名称</h5><p>当导入库时使用的测试库的名称与实现它的模块或类的名称相同。例如，如果有一个 Python 模块 MyLibrary（即，文件 MyLibrary.py），它将创建一个名为 MyLibrary 的库。</p>
<p>Python 类总是在模块内部。如果实现库的类的名称与模块的名称相同，Robot Framework 允许在导入库时省略类名。例如，MyLib.py 文件中的类 MyLib 可以仅用名为 MyLib 的库。这也适用于子模块，因此，例如，如果 parent.MyLib 模块有类 MyLib，那么只使用 parent.MyLib 导入它就可以了。如果模块名称和类名称不同，必须使用模块和类名称来使用库，例如 mymodule.MyLibrary 或 parent.submodule.MyLib。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>如果库名称真的很长，建议使用 AS 给库一个更简单的别名。</p>

    </div>
  </div>

<h5 id="提供库的参数"><a href="#提供库的参数" class="headerlink" title="提供库的参数"></a>提供库的参数</h5><p>所有作为类实现的测试库都可以接受参数。这些参数在库名称后的 Setting 部分中指定，当 Robot Framework 创建导入库的实例时，它将它们传递给其构造函数。作为模块实现的库不能接受任何参数，因此尝试使用这些结果会出错。</p>
<p>库所需的参数数量与库的构造函数接受的参数数量相同。默认值和变量参数的数量与关键字参数的工作方式类似。传递给库的参数，以及库名称本身，可以使用变量指定，因此可以例如从命令行更改它们。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    MyLibrary     10.0.0.1    8080</span><br><span class="line">Library    AnotherLib    $&#123;VAR&#125;</span><br></pre></td></tr></table></figure></div>

<p>用于上述示例的库的示例实现：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> example <span class="keyword">import</span> Connection</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLibrary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port=<span class="number">80</span></span>):</span><br><span class="line">        self._conn = Connection(host, <span class="built_in">int</span>(port))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">self, message</span>):</span><br><span class="line">        self._conn.send(message)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherLib</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, environment</span>):</span><br><span class="line">        self.environment = environment</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.environment == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">            <span class="comment"># 在测试环境中做一些事情</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 在其他环境中做一些事情</span></span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h5 id="库范围"><a href="#库范围" class="headerlink" title="库范围"></a>库范围</h5><p>作为类实现的库可以有一个内部状态，可以通过关键字和库的构造函数的参数来改变。因为状态可以影响关键字的实际行为，所以确保一个测试用例中的更改不会意外地影响其他测试用例是很重要的。这种类型的依赖关系可能会创建难以调试的问题，例如，当添加新的测试用例并且它们不一致地使用库时。</p>
<p>Robot Framework 尝试保持测试用例彼此独立：默认情况下，它为每个测试用例创建新的测试库实例。然而，这种行为并不总是可取的，因为有时测试用例应该能够共享一个公共状态。此外，并非所有的库都有状态，创建它们的新实例根本就不需要。</p>
<p>测试库可以使用类属性 ROBOT_LIBRARY_SCOPE 控制何时创建新的库。此属性必须是一个字符串，可以有以下三个值：</p>
<ul>
<li><strong>TEST</strong>：为每个测试用例创建一个新实例。可能的套件设置和套件拆卸共享另一个实例。</li>
</ul>
<p>在 Robot Framework 3.2 之前，此值为 TEST CASE，但现在推荐使用 TEST。因为所有无法识别的值都被视为与 TEST 相同，所以两个值在所有版本中都可以工作。出于同样的原因，如果库更多地针对 RPA 使用而不是测试，也可以使用 TASK 值。如果未设置 ROBOT_LIBRARY_SCOPE 属性，TEST 也是默认值。</p>
<ul>
<li><strong>SUITE</strong>：为每个测试套件创建一个新实例。最低级别的测试套件（从测试用例文件创建并包含测试用例）有自己的实例，更高级别的套件都有自己的实例，用于可能的设置和拆卸。</li>
</ul>
<p>在 Robot Framework 3.2 之前，此值为 TEST SUITE。该值仍然有效，但推荐使用 SUITE，适用于针对 Robot Framework 3.2 及更高版本的库。</p>
<ul>
<li><strong>GLOBAL</strong>：在整个测试执行过程中只创建一个实例，并由所有测试用例和测试套件共享。从模块创建的库始终是全局的。</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果一个库被多次导入并带有不同的参数，那么无论范围如何，每次都会创建一个新实例。</p>

    </div>
  </div>

<p>当使用具有状态的库使用 SUITE 或 GLOBAL 范围时，建议库有一些特殊的关键字用于清理状态。然后，这个关键字可以在套件设置或拆卸中使用，以确保下一个测试套件中的测试用例可以从已知状态开始。例如，SeleniumLibrary 使用 GLOBAL 范围来启用在不同的测试用例中使用相同的浏览器，而无需重新打开它，它还有 Close All Browsers 关键字用于轻松关闭所有打开的浏览器。</p>
<p>使用 SUITE 范围的示例库：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleLibrary</span>:</span><br><span class="line">    ROBOT_LIBRARY_SCOPE = <span class="string">&#x27;SUITE&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        self._counter += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(self._counter)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear_counter</span>(<span class="params">self</span>):</span><br><span class="line">        self._counter = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h5 id="库版本"><a href="#库版本" class="headerlink" title="库版本"></a>库版本</h5><p>当一个测试库被使用时，Robot Framework 尝试确定其版本。然后，这些信息被写入系统日志以提供调试信息。库文档工具 Libdoc 也将这些信息写入它生成的关键字文档。</p>
<p>版本信息是从属性 ROBOT_LIBRARY_VERSION 中读取的，就像从 ROBOT_LIBRARY_SCOPE 中读取库范围一样。如果 ROBOT_LIBRARY_VERSION 不存在，将尝试从 <strong>version</strong> 属性中读取信息。这些属性必须是类或模块属性，取决于库是作为类还是模块实现的。</p>
<p>使用 <strong>version</strong> 的示例模块：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__version__ = <span class="string">&#x27;0.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h5 id="文档格式"><a href="#文档格式" class="headerlink" title="文档格式"></a>文档格式</h5><p>库文档工具 Libdoc 支持多种格式的文档。如果想使用除 Robot Framework 自己的文档格式以外的其他格式，可以在源代码中使用 ROBOT_LIBRARY_DOC_FORMAT 属性指定格式，就像使用自己的 ROBOT_LIBRARY_* 属性设置范围和版本一样。</p>
<p>文档格式的可能值（不区分大小写）为 ROBOT（默认）、HTML、TEXT（纯文本）和 reST（reStructuredText）。使用 reST 格式需要在生成文档时安装 docutils 模块。</p>
<p>以下示例说明了如何设置使用 reStructuredText 格式的文档格式。有关一般性地记录测试库的更多信息，请参见文档库部分和 Libdoc 章节。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;一个用于*文档格式*演示目的的库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此文档是使用 reStructuredText__ 创建的。这里有一个链接</span></span><br><span class="line"><span class="string">到唯一的\`Keyword\`。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__ http://docutils.sourceforge.net</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">ROBOT_LIBRARY_DOC_FORMAT = <span class="string">&#x27;reST&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;**这里什么都没有**。甚至下面的表格也没有。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    =======  =====  =====</span></span><br><span class="line"><span class="string">    Table    here   has</span></span><br><span class="line"><span class="string">    nothing  to     see.</span></span><br><span class="line"><span class="string">    =======  =====  =====</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<h5 id="库充当监听器"><a href="#库充当监听器" class="headerlink" title="库充当监听器"></a>库充当监听器</h5><p>监听器接口允许外部监听器获取关于测试执行的通知。例如，当套件、测试和关键字开始和结束时，它们会被调用。有时，获取这样的通知对于测试库也是有用的，它们可以使用 ROBOT_LIBRARY_LISTENER 属性注册一个自定义监听器。此属性的值应为要使用的监听器的实例，可能是库本身。</p>
<p>有关更多信息和示例，请参见 Libraries as listeners 部分。</p>
<h5 id="library-装饰器"><a href="#library-装饰器" class="headerlink" title="@library 装饰器"></a>@library 装饰器</h5><p>配置作为类实现的库的一种简单方法是使用 robot.api.deco.library 类装饰器。它允许使用可选参数 scope、version、converter、doc_format 和 listener 分别配置库的范围、版本、自定义参数转换器、文档格式和监听器。当使用这些参数时，它们会自动设置匹配的 ROBOT_LIBRARY_SCOPE、ROBOT_LIBRARY_VERSION、ROBOT_LIBRARY_CONVERTERS、ROBOT_LIBRARY_DOC_FORMAT 和 ROBOT_LIBRARY_LISTENER 属性：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> library</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> example <span class="keyword">import</span> Listener</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@library(<span class="params">scope=<span class="string">&#x27;GLOBAL&#x27;</span>, version=<span class="string">&#x27;3.2b1&#x27;</span>, doc_format=<span class="string">&#x27;reST&#x27;</span>, listener=Listener(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>@library 装饰器还通过默认将 ROBOT_AUTO_KEYWORDS 参数设置为 False 来禁用自动关键字发现。这意味着必须使用 @keyword 装饰器装饰方法以将它们公开为关键字。如果只需要那种行为并且不需要进一步的配置，装饰器也可以像这样不带括号使用：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> library</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@library</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>如果需要，可以使用 auto_keywords 参数启用自动关键字发现：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> library</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@library(<span class="params">scope=<span class="string">&#x27;GLOBAL&#x27;</span>, auto_keywords=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>@library 装饰器只有在使用相应的参数 scope、version、converters、doc_format 和 listener 时才设置类属性 ROBOT_LIBRARY_SCOPE、ROBOT_LIBRARY_VERSION、ROBOT_LIBRARY_CONVERTERS、ROBOT_LIBRARY_DOC_FORMAT 和 ROBOT_LIBRARY_LISTENER。ROBOT_AUTO_KEYWORDS 属性始终被设置。当设置属性时，它们会覆盖可能存在的类属性。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>@library 装饰器是在 Robot Framework 3.2 中新增的，converters 参数是在 Robot Framework 5.0 中新增的。</p>

    </div>
  </div>



<h3 id="创建关键字"><a href="#创建关键字" class="headerlink" title="创建关键字"></a>创建关键字</h3><h4 id="哪些方法被视为关键字"><a href="#哪些方法被视为关键字" class="headerlink" title="哪些方法被视为关键字"></a>哪些方法被视为关键字</h4><p>当使用静态库 API 时，Robot Framework 使用内省来找出库类或模块实现了哪些关键字。默认情况下，它排除了以下划线开头的方法和函数。所有未被忽略的方法和函数都被视为关键字。例如，下面的库实现了一个名为 My Keyword 的关键字。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLibrary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_keyword</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self._helper_method(arg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_helper_method</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> arg.upper()</span><br></pre></td></tr></table></figure></div>

<h4 id="限制公共方法成为关键字"><a href="#限制公共方法成为关键字" class="headerlink" title="限制公共方法成为关键字"></a>限制公共方法成为关键字</h4><p>通常，自动将所有公共方法和函数视为关键字工作得很好，但有些情况下这是不希望的。还有一些情况下，当没有预期时会创建关键字。例如，当以类实现库时，可能会惊讶地发现可能的基类中的方法也被视为关键字。当以模块实现库时，导入到模块命名空间的函数变成关键字可能会更令人惊讶。</p>
<p>本节解释如何防止方法和函数成为关键字。</p>
<h5 id="基于类的库"><a href="#基于类的库" class="headerlink" title="基于类的库"></a>基于类的库</h5><p>当库以类的形式实现时，可以通过将 ROBOT_AUTO_KEYWORDS 属性设置为具有 false 值的类，告诉 Robot Framework 不要自动将方法公开为关键字：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line">    ROBOT_AUTO_KEYWORDS = <span class="literal">False</span></span><br></pre></td></tr></table></figure></div>

<p>当像这样设置 ROBOT_AUTO_KEYWORDS 属性时，只有明确用 @keyword 装饰器装饰的方法或者具有 robot_name 属性的方法才会成为关键字。@keyword 装饰器也可以用于为关键字设置自定义名称、标签和参数类型。</p>
<p>尽管可以显式地将 ROBOT_AUTO_KEYWORDS 属性设置为类，但使用 @library 装饰器将其默认设置为 False 更方便：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword, library</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@library</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @keyword</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">this_is_keyword</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @keyword(<span class="params"><span class="string">&#x27;This is keyword with custom name&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">xxx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">this_is_not_keyword</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>使用 ROBOT_AUTO_KEYWORDS 属性和 @library 装饰器限制哪些方法成为关键字是在 Robot Framework 3.2 中新增的。</p>

    </div>
  </div>

<p>另一种明确指定库实现了哪些关键字的方法是使用动态或混合库 API。</p>
<h5 id="基于模块的库"><a href="#基于模块的库" class="headerlink" title="基于模块的库"></a>基于模块的库</h5><p>当以模块的形式实现库时，模块命名空间中的所有函数都会成为关键字。这也适用于导入的函数，这可能会引起令人不悦的惊喜。例如，如果下面的模块被用作库，它将包含一个预期的关键字 Example Keyword，但也会包含一个关键字 Current Thread。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Running in thread &quot;%s&quot;.&#x27;</span> % current_thread().name)</span><br></pre></td></tr></table></figure></div>

<p>避免导入的函数成为关键字的一种简单方法是只导入模块（例如，import threading）并通过模块使用函数（例如 threading.current_thread()）。或者，可以在导入时给函数一个以下划线开头的别名（例如，from threading import current_thread as _current_thread）。</p>
<p>限制哪些函数成为关键字的更明确的方法是使用 Python 本身用于类似目的的模块级别的 <strong>all</strong> 属性。如果使用它，只有列出的函数可以是关键字。例如，下面的库只实现了一个关键字 Example Keyword：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;example_keyword&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Running in thread &quot;%s&quot;.&#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">this_is_not_keyword</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>如果库很大，当添加、删除或重命名关键字时，维护 <strong>all</strong> 属性可能是一项相当大的任务。另一种明确标记哪些函数是关键字的方法是使用 ROBOT_AUTO_KEYWORDS 属性，就像它可以用于基于类的库一样。当此属性设置为 false 值时，只有明确用 @keyword 装饰器装饰的函数才会成为关键字。例如，这个库也只实现了一个关键字 Example Keyword：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ROBOT_AUTO_KEYWORDS = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Running in thread &quot;%s&quot;.&#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">this_is_not_keyword</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>使用 ROBOT_AUTO_KEYWORDS 限制哪些函数成为关键字是 Robot Framework 3.2 中的新功能。</p>

    </div>
  </div>

<h5 id="使用-not-keyword-装饰器"><a href="#使用-not-keyword-装饰器" class="headerlink" title="使用 @not_keyword 装饰器"></a>使用 @not_keyword 装饰器</h5><p>可以使用 @not_keyword 装饰器显式地将模块中的函数和类中的方法标记为“非关键字”。当库以模块的形式实现时，这个装饰器也可以用来避免导入的函数成为关键字。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> not_keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">not_keyword(current_thread)    <span class="comment"># Don&#x27;t expose `current_thread` as a keyword.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Running in thread &quot;%s&quot;.&#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="meta">@not_keyword</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">this_is_not_keyword</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>使用 @not_keyword 装饰器避免函数或方法成为关键字的方式几乎与使用 @library 装饰器禁用自动关键字发现或将 ROBOT_AUTO_KEYWORDS 设置为 false 值的方式相反。使用哪一个取决于上下文。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>@not_keyword 装饰器是 Robot Framework 3.2 中的新功能。</p>

    </div>
  </div>



<h5 id="关键字名称"><a href="#关键字名称" class="headerlink" title="关键字名称"></a>关键字名称</h5><p>在测试数据中使用的关键字名称与方法名称进行比较，以找到实现这些关键字的方法。名称比较不区分大小写，也忽略空格和下划线。例如，方法 hello 映射到关键字名称 Hello、hello 或甚至 h e l l o。同样，do_nothing 和 doNothing 方法都可以在测试数据中用作 Do Nothing 关键字。</p>
<p>以下是以模块形式实现的示例库 MyLibrary.py 文件：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, %s!&quot;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_nothing</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>下面的示例说明了如何使用上面的示例库。如果想自己试试，确保库在模块搜索路径中。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    MyLibrary</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">My Test</span><br><span class="line">    Do Nothing</span><br><span class="line">    Hello    world</span><br></pre></td></tr></table></figure></div>

<h5 id="设置自定义名称"><a href="#设置自定义名称" class="headerlink" title="设置自定义名称"></a>设置自定义名称</h5><p>可以为关键字公开一个不同的名称，而不是默认的关键字名称，该名称映射到方法名称。这可以通过将方法的 robot_name 属性设置为所需的自定义名称来实现：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">login.robot_name = <span class="string">&#x27;Login via user panel&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>*** Test Cases *** My Test Login Via User Panel    {username}username{password} 与上述示例中显式设置 robot_name 属性不同，通常最容易使用 @keyword 装饰器：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params"><span class="string">&#x27;Login via user panel&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):</span><br><span class="line">      <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>如果没有参数使用此装饰器，将对公开的关键字名称没有影响，但仍会设置 robot_name 属性。这允许标记方法以公开为关键字，而实际上不改变关键字名称。具有 robot_name 属性的方法也会创建关键字，即使方法名称本身以下划线开头。</p>
<p>设置自定义关键字名称还可以启用库关键字使用嵌入式参数语法接受参数。</p>
<h5 id="关键字标签"><a href="#关键字标签" class="headerlink" title="关键字标签"></a>关键字标签</h5><p>库关键字和用户关键字可以有标签。库关键字可以通过在方法上设置 robot_tags 属性为所需标签的列表来定义它们。与设置自定义名称一样，最容易使用 @keyword 装饰器设置此属性：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params">tags=[<span class="string">&#x27;tag1&#x27;</span>, <span class="string">&#x27;tag2&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params"><span class="string">&#x27;Custom name&#x27;</span>, [<span class="string">&#x27;tags&#x27;</span>, <span class="string">&#x27;here&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">another_example</span>():</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>设置标签的另一种选项是在关键字文档的最后一行使用 Tags: 前缀并用逗号分隔给出它们。例如：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Log user in to SUT.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Tags: tag1, tag2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>对于静态和混合 API，关键字需要多少个参数的信息直接从实现它的方法中获取。使用动态库 API 的库有其他方式来共享这些信息，因此这一部分对它们来说并不相关。</p>
<p>最常见也是最简单的情况是，关键字需要确切的参数数量。在这种情况下，方法只需接受确切的那些参数。例如，实现没有参数的关键字的方法也不接受参数，实现一个参数的关键字的方法也接受一个参数，依此类推。</p>
<p>示例关键字接受不同数量的参数：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">no_arguments</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Keyword got no arguments.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one_argument</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Keyword got one argument &#x27;%s&#x27;.&quot;</span> % arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">three_arguments</span>(<span class="params">a1, a2, a3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Keyword got three arguments &#x27;%s&#x27;, &#x27;%s&#x27; and &#x27;%s&#x27;.&quot;</span> % (a1, a2, a3))</span><br></pre></td></tr></table></figure></div>

<p>​                            </p>
<h5 id="关键字的默认值"><a href="#关键字的默认值" class="headerlink" title="关键字的默认值"></a>关键字的默认值</h5><p>关键字的某些参数具有默认值通常是很有用的。</p>
<p>在 Python 中，一个方法总是有且只有一个实现，可能的默认值在方法签名中指定。下面的语法对所有 Python 程序员来说都是熟悉的：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">one_default</span>(<span class="params">arg=<span class="string">&#x27;default&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Argument has value %s&quot;</span> % arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiple_defaults</span>(<span class="params">arg1, arg2=<span class="string">&#x27;default 1&#x27;</span>, arg3=<span class="string">&#x27;default 2&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Got arguments %s, %s and %s&quot;</span> % (arg1, arg2, arg3))</span><br></pre></td></tr></table></figure></div>

<p>上面的第一个示例关键字可以使用零个或一个参数。如果没有给出参数，arg 将获得值 default。如果有一个参数，arg 将获得该值，如果使用超过一个参数调用关键字将失败。在第二个示例中，总是需要一个参数，但第二个和第三个参数有默认值，所以可以使用一个到三个参数的关键字。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Defaults</span><br><span class="line">    One Default</span><br><span class="line">    One Default    argument</span><br><span class="line">    Multiple Defaults    required arg</span><br><span class="line">    Multiple Defaults    required arg    optional</span><br><span class="line">    Multiple Defaults    required arg    optional 1    optional 2</span><br></pre></td></tr></table></figure></div>

<h5 id="变量数量的参数（-varargs）"><a href="#变量数量的参数（-varargs）" class="headerlink" title="变量数量的参数（*varargs）"></a>变量数量的参数（*varargs）</h5><p>Robot Framework 也支持接受任意数量参数的关键字。</p>
<p>Python 支持接受任意数量参数的方法。相同的语法在库中也适用，如下面的示例所示，它还可以与指定参数的其他方式结合使用：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">any_arguments</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Got arguments:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one_required</span>(<span class="params">required, *others</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Required: %s\nOthers:&quot;</span> % required)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> others:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">also_defaults</span>(<span class="params">req, def1=<span class="string">&quot;default 1&quot;</span>, def2=<span class="string">&quot;default 2&quot;</span>, *rest</span>):</span><br><span class="line">    <span class="built_in">print</span>(req, def1, def2, rest)</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Varargs</span><br><span class="line">    <span class="type">Any</span> Arguments</span><br><span class="line">    <span class="type">Any</span> Arguments    argument</span><br><span class="line">    <span class="type">Any</span> Arguments    arg <span class="number">1</span>    arg <span class="number">2</span>    arg <span class="number">3</span>    arg <span class="number">4</span>    arg <span class="number">5</span></span><br><span class="line">    One Required     required arg</span><br><span class="line">    One Required     required arg    another arg    yet another</span><br><span class="line">    Also Defaults    required</span><br><span class="line">    Also Defaults    required    these two    have defaults</span><br><span class="line">    Also Defaults    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span>    <span class="number">5</span>    <span class="number">6</span></span><br></pre></td></tr></table></figure></div>

<h5 id="自由关键字参数（-kwargs）"><a href="#自由关键字参数（-kwargs）" class="headerlink" title="自由关键字参数（**kwargs）"></a>自由关键字参数（**kwargs）</h5><p>Robot Framework 支持 Python 的 **kwargs 语法。如何使用接受自由关键字参数（也称为自由命名参数）的关键字在创建测试用例部分进行了讨论。在这一部分，将看看如何创建这样的关键字。</p>
<p>如果已经熟悉 Python 中 kwargs 的工作方式，那么理解它们如何在 Robot Framework 测试库中工作就相当简单。下面的示例展示了基本功能：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">**stuff</span>):</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> stuff.items():</span><br><span class="line">        <span class="built_in">print</span>(name, value)</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Keyword Arguments</span><br><span class="line">    Example Keyword    hello=world        <span class="comment"># Logs &#x27;hello world&#x27;.</span></span><br><span class="line">    Example Keyword    foo=<span class="number">1</span>    bar=<span class="number">42</span>    <span class="comment"># Logs &#x27;foo 1&#x27; and &#x27;bar 42&#x27;.</span></span><br></pre></td></tr></table></figure></div>

<p>基本上，关键字调用末尾使用 name&#x3D;value 语法的所有参数，以及不匹配任何其他参数的参数，都作为 kwargs 传递给关键字。为了避免像 foo&#x3D;quux 这样的字面值作为自由关键字参数，必须像 foo&#x3D;quux 这样进行转义。</p>
<p>下面的示例说明了普通参数、varargs 和 kwargs 是如何一起工作的：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">various_args</span>(<span class="params">arg=<span class="literal">None</span>, *varargs, **kwargs</span>):</span><br><span class="line">    <span class="keyword">if</span> arg <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;arg:&#x27;</span>, arg)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> varargs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;vararg:&#x27;</span>, value)</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> <span class="built_in">sorted</span>(kwargs.items()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;kwarg:&#x27;</span>, name, value)</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Positional</span><br><span class="line">    Various Args    hello    world                <span class="comment"># Logs &#x27;arg: hello&#x27; and &#x27;vararg: world&#x27;.</span></span><br><span class="line"></span><br><span class="line">Named</span><br><span class="line">    Various Args    arg=value                     <span class="comment"># Logs &#x27;arg: value&#x27;.</span></span><br><span class="line"></span><br><span class="line">Kwargs</span><br><span class="line">    Various Args    a=<span class="number">1</span>    b=<span class="number">2</span>    c=<span class="number">3</span>             <span class="comment"># Logs &#x27;kwarg: a 1&#x27;, &#x27;kwarg: b 2&#x27; and &#x27;kwarg: c 3&#x27;.</span></span><br><span class="line">    Various Args    c=<span class="number">3</span>    a=<span class="number">1</span>    b=<span class="number">2</span>             <span class="comment"># Same as above. Order does not matter.</span></span><br><span class="line"></span><br><span class="line">Positional <span class="keyword">and</span> kwargs</span><br><span class="line">    Various Args    <span class="number">1</span>    <span class="number">2</span>    kw=<span class="number">3</span>                <span class="comment"># Logs &#x27;arg: 1&#x27;, &#x27;vararg: 2&#x27; and &#x27;kwarg: kw 3&#x27;.</span></span><br><span class="line"></span><br><span class="line">Named <span class="keyword">and</span> kwargs</span><br><span class="line">    Various Args    arg=value      hello=world    <span class="comment"># Logs &#x27;arg: value&#x27; and &#x27;kwarg: hello world&#x27;.</span></span><br><span class="line">    Various Args    hello=world    arg=value      <span class="comment"># Same as above. Order does not matter.</span></span><br></pre></td></tr></table></figure></div>

<p>有关使用与上述示例完全相同的签名的真实世界示例，请参见 Process 库中的 Run Process 和 Start Keyword 关键字。</p>
<h5 id="仅关键字参数"><a href="#仅关键字参数" class="headerlink" title="仅关键字参数"></a>仅关键字参数</h5><p>从 Robot Framework 3.1 开始，可以在不同的关键字中使用仅命名参数。这种支持是由 Python 的仅关键字参数提供的。仅关键字参数在可能的 *varargs 之后或在不需要 *varargs 时在专用的 * 标记之后指定。可能的 **kwargs 在仅关键字参数之后指定。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_words</span>(<span class="params">*words, case_sensitive=<span class="literal">False</span></span>):</span><br><span class="line">    key = <span class="built_in">str</span>.lower <span class="keyword">if</span> case_sensitive <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(words, key=key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strip_spaces</span>(<span class="params">word, *, left=<span class="literal">True</span>, right=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> left:</span><br><span class="line">        word = word.lstrip()</span><br><span class="line">    <span class="keyword">if</span> right:</span><br><span class="line">        word = word.rstrip()</span><br><span class="line">    <span class="keyword">return</span> word</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Sort Words    Foo    bar    baZ</span><br><span class="line">    Sort Words    Foo    bar    baZ    case_sensitive=<span class="literal">True</span></span><br><span class="line">    Strip Spaces    $&#123;word&#125;    left=<span class="literal">False</span></span><br></pre></td></tr></table></figure></div>

<h5 id="仅位置参数"><a href="#仅位置参数" class="headerlink" title="仅位置参数"></a>仅位置参数</h5><p>Python 支持所谓的仅位置参数，使得可以指定一个参数只能作为位置参数给出，而不能像 name&#x3D;value 那样作为命名参数给出。仅位置参数在普通参数之前指定，并且在它们之后必须使用特殊的 &#x2F; 标记：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>(<span class="params">posonly, /, normal</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Got positional-only argument <span class="subst">&#123;posonly&#125;</span> and normal argument <span class="subst">&#123;normal&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>上述关键字可以像这样使用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    # 仅位置参数和普通参数作为位置参数使用。</span><br><span class="line">    Keyword    foo    bar</span><br><span class="line">    # 普通参数也可以命名。</span><br><span class="line">    Keyword    foo    normal=bar</span><br></pre></td></tr></table></figure></div>

<p>如果一个仅位置参数使用了一个包含等号的值，如 example&#x3D;usage，即使等号前的部分与参数名称匹配，也不会被认为是命名参数语法。然而，这个规则只适用于在没有其他参数在它之前使用命名参数语法的情况下，仅位置参数在其正确位置使用。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    # 在这种情况下，仅位置参数获取字面值 `posonly=foo`。</span><br><span class="line">    Keyword    posonly=foo    normal=bar</span><br><span class="line">    # 这将失败。</span><br><span class="line">    Keyword    normal=bar    posonly=foo</span><br></pre></td></tr></table></figure></div>

<p>从 Robot Framework 4.0 开始，完全支持仅位置参数。在早期版本中，也可以将它们作为位置参数使用，但将它们作为命名参数使用会在 Python 端引发错误。</p>
<h5 id="参数转换"><a href="#参数转换" class="headerlink" title="参数转换"></a>参数转换</h5><p>默认情况下，定义在 Robot Framework 测试数据中的参数作为 Unicode 字符串传递给关键字。然而，也有几种使用非字符串值的方法：</p>
<ul>
<li>变量可以包含任何类型的对象作为值，作为参数的变量按原样传递给关键字。</li>
<li>关键字本身可以将它们接受的参数转换为其他类型。</li>
<li>可以使用函数注解或 @keyword 装饰器显式指定参数类型。在这些情况下，Robot Framework 会自动转换参数。</li>
<li>也会根据关键字默认值进行自动转换。</li>
<li>库可以注册自定义参数转换器。</li>
</ul>
<p>基于函数注解、使用 @keyword 装饰器指定的类型以及参数默认值的自动参数转换都是 Robot Framework 3.1 中的新功能。支持的转换部分指定了在这些情况下支持哪些参数转换。</p>
<p>在 Robot Framework 4.0 之前，只有当给定的参数是字符串时才进行自动转换。现在，无论参数类型如何，都会进行转换。</p>
<h6 id="手动参数转换"><a href="#手动参数转换" class="headerlink" title="手动参数转换"></a>手动参数转换</h6><p>如果没有向 Robot Framework 指定类型信息，所有未作为变量传递的参数都作为 Unicode 字符串给出。这包括以下情况：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Example Keyword    42    False</span><br></pre></td></tr></table></figure></div>

<p>关键字内部总是可以转换作为字符串传递的参数。在简单的情况下，这意味着使用 int() 或 float() 将参数转换为数字，但也可能进行其他类型的转换。在处理布尔值时，必须小心，因为所有非空字符串，包括字符串 False，都被 Python 视为真。Robot Framework 自己的 robot.utils.is_truthy() 实用程序很好地处理了这个问题，因为它将像 FALSE、NO 和 NONE（不区分大小写）这样的字符串视为假：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.utils <span class="keyword">import</span> is_truthy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">count, case_insensitive</span>):</span><br><span class="line">    count = <span class="built_in">int</span>(count)</span><br><span class="line">    <span class="keyword">if</span> is_truthy(case_insensitive):</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>关键字还可以通过 robot.api.TypeInfo 类及其 convert 方法使用 Robot Framework 的参数转换功能。如果需要的转换逻辑更复杂，或者需要比简单使用 int() 提供的更好的错误报告，这可能会很有用。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> TypeInfo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">count, case_insensitive</span>):</span><br><span class="line">    count = TypeInfo.from_type(<span class="built_in">int</span>).convert(count)</span><br><span class="line">    <span class="keyword">if</span> TypeInfo.from_type(<span class="built_in">bool</span>).convert(case_insensitive):</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>通常建议使用类型提示或其他方式指定类型，并让 Robot Framework 自动处理参数转换。只有在特殊情况下才需要手动参数转换。</p>

    </div>
  </div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>robot.api.TypeInfo 是在 Robot Framework 7.0 中新增的。</p>

    </div>
  </div>

<h6 id="使用函数注解指定参数类型"><a href="#使用函数注解指定参数类型" class="headerlink" title="使用函数注解指定参数类型"></a>使用函数注解指定参数类型</h6><p>从 Robot Framework 3.1 开始，如果可用参数类型信息并且类型被识别，传递给关键字的参数将自动转换。指定类型的最自然方式是使用 Python 函数注解。例如，前面的示例中的关键字可以如下实现，参数将自动转换：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">count: <span class="built_in">int</span>, case_insensitive: <span class="built_in">bool</span> = <span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> case_insensitive:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>请参阅下面的支持的转换部分，了解自动转换的类型列表以及这些类型接受的值。如果一个具有支持类型之一的参数给出了无法转换的值，那么这是一个错误。只注解一部分参数是可以的。</p>
<p>用其他类型注解参数不是错误，也可以使用注解进行其他类型的操作。在这些情况下不进行转换，但注解仍然显示在由 Libdoc 生成的文档中。</p>
<p>关键字也可以有返回类型注解，使用签名末尾的 -&gt; 符号指定，如 def example() -&gt; int:。这个信息在执行过程中不用于任何事情，但从 Robot Framework 7.0 开始，它由 Libdoc 显示用于文档目的。</p>
<h6 id="使用-keyword-装饰器指定参数类型"><a href="#使用-keyword-装饰器指定参数类型" class="headerlink" title="使用 @keyword 装饰器指定参数类型"></a>使用 @keyword 装饰器指定参数类型</h6><p>指定显式参数类型的另一种方式是使用 @keyword 装饰器。从 Robot Framework 3.1 开始，它接受一个可选的 types 参数，可以用来以字典的形式指定参数类型，将参数名称映射到类型，或者以列表的形式基于位置映射参数到类型。下面的示例展示了实现与前面示例中相同的关键字的这些方法：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params">types=&#123;<span class="string">&#x27;count&#x27;</span>: <span class="built_in">int</span>, <span class="string">&#x27;case_insensitive&#x27;</span>: <span class="built_in">bool</span>&#125;</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">count, case_insensitive=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> case_insensitive:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params">types=[<span class="built_in">int</span>, <span class="built_in">bool</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">count, case_insensitive=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> case_insensitive:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>无论使用哪种方法，都不必为所有参数指定类型。当以列表形式指定类型时，可以使用 None 标记某个参数没有类型信息，并且可以完全省略末尾的参数。例如，这两个关键字都只为第二个参数指定了类型：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@keyword(<span class="params">types=&#123;<span class="string">&#x27;second&#x27;</span>: <span class="built_in">float</span>&#125;</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example1</span>(<span class="params">first, second, third</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params">types=[<span class="literal">None</span>, <span class="built_in">float</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example2</span>(<span class="params">first, second, third</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>从 Robot Framework 7.0 开始，可以通过在类型字典中使用键 ‘return’ 和适当的类型来指定关键字返回类型。这个信息在执行过程中不用于任何事情，但它由 Libdoc 显示用于文档目的。</p>
<p>如果使用 @keyword 装饰器指定了任何类型，那么该关键字从注解中获取的类型信息将被忽略。像 @keyword(types&#x3D;None) 这样设置类型为 None 将完全禁用类型转换，因此也会忽略从默认值获取的类型信息。</p>
<h6 id="基于默认值的隐式参数类型"><a href="#基于默认值的隐式参数类型" class="headerlink" title="基于默认值的隐式参数类型"></a>基于默认值的隐式参数类型</h6><p>如果没有使用注解或 @keyword 装饰器显式获取类型信息，Robot Framework 3.1 及更高版本会尝试基于可能的参数默认值获取它。在这个示例中，count 和 case_insensitive 分别获取类型 int 和 bool：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">count=-<span class="number">1</span>, case_insensitive=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> case_insensitive:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>当基于默认值隐式获取类型信息时，参数转换本身并不像从显式获取的信息那样严格：</p>
<ul>
<li>转换也可能尝试到其他”相似”的类型。例如，如果转换为整数失败，将尝试浮点数转换。</li>
<li>转换失败不是错误，在这些情况下，关键字获取原始值。</li>
<li>如果一个参数有一个显式类型和一个默认值，首先尝试基于显式类型进行转换。如果失败，那么将尝试基于默认值进行转换。在这种特殊情况下，基于默认值的转换是严格的，转换失败会导致错误。</li>
</ul>
<p>如果不希望基于默认值进行参数转换，可以使用 @keyword 装饰器像 @keyword(types&#x3D;None) 这样禁用整个参数转换。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 4.0 之前，只有当参数没有显式类型时，才会根据默认值进行转换。</p>

    </div>
  </div>

<h6 id="支持的转换"><a href="#支持的转换" class="headerlink" title="支持的转换"></a>支持的转换</h6><p>下表列出了 Robot Framework 3.1 及更高版本将参数转换为的类型。这些特性适用于所有转换：</p>
<ul>
<li>类型可以使用函数注解或 @keyword 装饰器显式指定。</li>
<li>如果没有显式指定，类型可以从参数默认值隐式获取。</li>
<li>无论给定参数的类型如何，都会进行转换。如果参数类型与预期类型不兼容，转换失败。</li>
<li>如果类型已经显式指定，转换失败会导致错误。如果根据默认值获取类型，给定参数将按原样使用。</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果一个参数既有类型提示又有默认值，首先尝试基于类型提示进行转换，然后，如果失败，基于默认值类型进行转换。这种行为在未来可能会改变，以便只有在参数没有类型提示时才根据默认值进行转换。这将改变像 arg: list &#x3D; None 这样的情况的转换行为，其中不再尝试 None 转换。强烈建议库创建者像 arg: list | None &#x3D; None 这样显式指定默认值类型。</p>

    </div>
  </div>

<p>可以使用具体类型（例如，list）、使用抽象基类（ABC）（例如，Sequence）或使用这些类型的子类（例如，MutableSequence）来指定要使用的类型。也支持在 typing 模块中映射到支持的具体类型或 ABC 的类型（例如，List）。在所有这些情况下，参数都转换为具体类型。</p>
<p>除了使用实际类型（例如，int），还可以使用字符串（例如，‘int’）指定类型，一些类型也有别名（例如，‘integer’）。匹配类型到名称和别名不区分大小写。</p>
<p>“接受”列指定了哪些给定的参数类型被转换。如果给定的参数已经具有预期的类型，不会进行转换。其他类型会导致转换失败。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>ABC</th>
<th>别名</th>
<th>接受</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td></td>
<td>boolean</td>
<td>str, int, float, None</td>
<td>字符串 TRUE, YES, ON 和 1 转换为 True，空字符串以及 FALSE, NO, OFF 和 0 转换为 False，字符串 NONE 转换为 None。其他字符串和其他接受的值按原样传递，允许关键字在需要时特殊处理它们。所有字符串比较都不区分大小写。True 和 false 字符串可以本地化。参见支持的翻译的翻译附录。</td>
<td>TRUE (转换为 True) off (转换为 False) example (按原样使用)</td>
</tr>
<tr>
<td>int</td>
<td>Integral</td>
<td>integer, long</td>
<td>str, float</td>
<td>使用内置函数 int 进行转换。只有当它们可以精确表示为整数时才接受浮点数。例如，接受 1.0 而不接受 1.1。如果将字符串转换为整数失败，并且根据默认值隐式获取类型，则尝试转换为浮点数。从 Robot Framework 4.1 开始，可以通过在值前加上 0x、0o 和 0b 来使用十六进制、八进制和二进制数字。从 Robot Framework 4.1 开始，可以使用空格和下划线作为数字分组的视觉分隔符。从 Robot Framework 7.0 开始，只要它们的小数部分为零，就接受表示浮点数的字符串。这包括使用科学记数法，如 1e100。</td>
<td>42 -1 10 000 000 1e100 0xFF 0o777 0b1010 0xBAD_C0FFEE {1}1{1.0}</td>
</tr>
<tr>
<td>float</td>
<td>Real</td>
<td>double</td>
<td>str, Real</td>
<td>使用内置的 float 进行转换。从 Robot Framework 4.1 开始，可以使用空格和下划线作为数字分组的视觉分隔符。</td>
<td>3.14 2.9979e8 10 000.000 01 10_000.000_01</td>
</tr>
<tr>
<td>Decimal</td>
<td></td>
<td></td>
<td>str, int, float</td>
<td>使用 Decimal 类进行转换。当需要精确表示小数时，推荐使用 Decimal 而不是 float。从 Robot Framework 4.1 开始，可以使用空格和下划线作为数字分组的视觉分隔符。</td>
<td>3.14 10 000.000 01 10_000.000_01</td>
</tr>
<tr>
<td>str</td>
<td></td>
<td>string, unicode</td>
<td>任何</td>
<td>所有参数都转换为 Unicode 字符串。在 Robot Framework 4.0 中新增。</td>
<td></td>
</tr>
<tr>
<td>bytes</td>
<td></td>
<td></td>
<td>str, bytearray</td>
<td>字符串被转换为字节，以便每个 Unicode 码点低于 256 的直接映射到匹配的字节。不允许使用更高的码点。</td>
<td>good hyvä (转换为 hyv\xe4) \x00 (空字节)</td>
</tr>
<tr>
<td>bytearray</td>
<td></td>
<td></td>
<td>str, bytes</td>
<td>与字节的转换相同，但结果是 bytearray。</td>
<td></td>
</tr>
<tr>
<td>datetime</td>
<td></td>
<td></td>
<td>str, int, float</td>
<td>预期字符串是 ISO 8601 格式的时间戳，如 YYYY-MM-DD hh:mm:ss.mmmmmm，其中任何非数字字符都可以用作分隔符，或者可以完全省略分隔符。此外，只有日期部分是必需的，所有可能缺失的时间组件都被视为零。整数和浮点数被认为是自 Unix 纪元以来的秒数。</td>
<td>2022-02-09T16:39:43.632269 2022-02-09 16:39 2022-02-09 ${1644417583.632269} (Epoch 时间)</td>
</tr>
<tr>
<td>date</td>
<td></td>
<td></td>
<td>str</td>
<td>与 datetime 的字符串转换相同，但所有时间组件都应省略或为零。</td>
<td>2018-09-12</td>
</tr>
<tr>
<td>timedelta</td>
<td></td>
<td></td>
<td>str, int, float</td>
<td>预期字符串表示一个时间间隔，格式为 Robot Framework 支持的一种时间格式：数字时间、时间字符串或”计时器”字符串。整数和浮点数被认为是秒。</td>
<td>42 (42 秒) 1 分钟 2 秒 01:02 (与上面相同)</td>
</tr>
<tr>
<td>Path</td>
<td>PathLike</td>
<td></td>
<td>str</td>
<td>字符串被转换为 pathlib.Path 对象。在 Windows 上，&#x2F; 自动转换为 \。在 Robot Framework 6.0 中新增。</td>
<td>&#x2F;tmp&#x2F;absolute&#x2F;path relative&#x2F;path&#x2F;to&#x2F;file.ext name.txt</td>
</tr>
<tr>
<td>Enum</td>
<td></td>
<td></td>
<td>str</td>
<td>指定的类型必须是枚举（Enum 或 Flag 的子类），给定的参数必须匹配其成员名称。匹配成员名称对大小写、空格、下划线和连字符不敏感，但精确匹配优先于规范化匹配。在 Robot Framework 7.0 中新增忽略连字符。枚举文档和成员在由 Libdoc 自动生成的文档中自动显示。</td>
<td>NORTH (Direction.NORTH) north west (Direction.NORTH_WEST)</td>
</tr>
<tr>
<td>IntEnum</td>
<td></td>
<td></td>
<td>str, int</td>
<td>指定的类型必须是基于整数的枚举（IntEnum 或 IntFlag 的子类），给定的参数必须匹配其成员名称或值。匹配成员名称的方式与 Enum 相同。值可以是整数，也可以是可以转换为整数的字符串。枚举文档和成员在由 Libdoc 自动生成的文档中自动显示。在 Robot Framework 4.1 中新增。</td>
<td>OFF (PowerState.OFF) 1 (PowerState.ON)</td>
</tr>
<tr>
<td>Literal</td>
<td></td>
<td></td>
<td>任何</td>
<td>只接受指定的值。值可以是字符串、整数、字节、布尔值、枚举和 None，使用的参数使用特定于值类型的转换逻辑进行转换。字符串对大小写、空格、下划线和连字符不敏感，但精确匹配优先于规范化匹配。Literal 提供了与 Enum 类似的功能，但不支持自定义文档。在 Robot Framework 7.0 中新增。</td>
<td>OFF on</td>
</tr>
<tr>
<td>None</td>
<td></td>
<td></td>
<td>str</td>
<td>字符串 NONE（不区分大小写）被转换为 Python None 对象。其他值会导致错误。</td>
<td>None</td>
</tr>
<tr>
<td>Any</td>
<td></td>
<td></td>
<td>任何</td>
<td>接受任何值。不进行转换。在 Robot Framework 6.1 中新增。</td>
<td></td>
</tr>
<tr>
<td>list</td>
<td>Sequence</td>
<td>sequence</td>
<td>str, Sequence</td>
<td>字符串必须是 Python 列表字面量。它们使用 ast.literal_eval 函数转换为实际的列表。它们可以包含 ast.literal_eval 支持的任何值，包括列表和其他容器。如果使用的类型提示是 list（例如，arg: list），那么不是列表的序列将被转换为列表。如果类型提示是通用的 Sequence，那么序列将不经转换地使用。在 Robot Framework 7.0 中新增序列别名。</td>
<td>[‘one’, ‘two’] [(‘one’, 1), (‘two’, 2)]</td>
</tr>
<tr>
<td>tuple</td>
<td></td>
<td></td>
<td>str, Sequence</td>
<td>与 list 相同，但字符串参数必须是元组字面量。</td>
<td>(‘one’, ‘two’)</td>
</tr>
<tr>
<td>set</td>
<td>Set</td>
<td></td>
<td>str, Container</td>
<td>与 list 相同，但字符串参数必须是集合字面量或 set() 来创建一个空集合。</td>
<td>{1, 2, 3, 42} set()</td>
</tr>
<tr>
<td>frozenset</td>
<td></td>
<td></td>
<td>str, Container</td>
<td>与 set 相同，但结果是一个 frozenset。</td>
<td>{1, 2, 3, 42} frozenset()</td>
</tr>
<tr>
<td>dict</td>
<td>Mapping</td>
<td>dictionary, mapping, map</td>
<td>str, Mapping</td>
<td>与 list 相同，但字符串参数必须是字典字面量。在 Robot Framework 7.0 中新增映射别名。</td>
<td>{‘a’: 1, ‘b’: 2} {‘key’: 1, ‘nested’: {‘key’: 2}}</td>
</tr>
<tr>
<td>TypedDict</td>
<td></td>
<td></td>
<td>str, Mapping</td>
<td>与 dict 相同，但字典项也转换为指定的类型，不允许包含类型规范中未包含的项。在 Robot Framework 6.0 中新增。普通的 dict 转换在之前使用。</td>
<td>{‘width’: 1600, ‘enabled’: True}</td>
</tr>
</tbody></table>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>注意</p>
<p>从 Robot Framework 5.0 开始，已转换的类型会自动显示在 Libdoc 输出中。</p>
<p>在 Robot Framework 4.0 之前，大多数类型支持将字符串 NONE（不区分大小写）转换为 Python None。这种支持已被移除，只有当参数具有 None 作为显式类型或默认值时，才进行 None 转换。        </p>

    </div>
  </div>                

<h6 id="指定多个可能的类型"><a href="#指定多个可能的类型" class="headerlink" title="指定多个可能的类型"></a>指定多个可能的类型</h6><p>从 Robot Framework 4.0 开始，可以指定一个参数有多个可能的类型。在这种情况下，会根据每种类型尝试参数转换，如果所有这些转换都失败，那么整个转换就会失败。</p>
<p>当使用函数注解时，指定一个参数有多个可能的类型的自然语法是使用 Union：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">length: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>], padding: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>, <span class="literal">None</span>] = <span class="literal">None</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>当使用 Python 3.10 或更高版本时，可以使用原生的 type1 | type2 语法：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">length: <span class="built_in">int</span> | <span class="built_in">float</span>, padding: <span class="built_in">int</span> | <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>Robot Framework 7.0 增强了对联合语法的支持，以便也可以像 ‘type1 | type2’ 这样的”字符串类型”联合工作。这种语法也适用于旧的 Python 版本：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">length: <span class="string">&#x27;int | float&#x27;</span>, padding: <span class="string">&#x27;int | str | None&#x27;</span> = <span class="literal">None</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>另一种方法是将类型指定为元组。这在注解中不推荐使用，因为其他工具不支持这种语法，但它与 @keyword 装饰器配合使用效果很好：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params">types=&#123;<span class="string">&#x27;length&#x27;</span>: (<span class="params"><span class="built_in">int</span>, <span class="built_in">float</span></span>), <span class="string">&#x27;padding&#x27;</span>: (<span class="params"><span class="built_in">int</span>, <span class="built_in">str</span>, <span class="literal">None</span></span>)&#125;</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">length, padding=<span class="literal">None</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>在上述示例中，length 参数将首先被转换为整数，如果失败，则转换为浮点数。padding 将首先被转换为整数，然后转换为字符串，最后转换为 None。</p>
<p>如果给定的参数具有其中一个接受的类型，那么不进行转换，参数按原样使用。例如，如果 length 参数获取值 1.5 作为浮点数，它将不会被转换为整数。注意，使用非字符串值（如浮点数）作为参数需要使用变量，如这些示例给出的给 length 参数不同值所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Conversion</span><br><span class="line">    Example    10        # 参数是字符串。转换为整数。</span><br><span class="line">    Example    1.5       # 参数是字符串。转换为浮点数。</span><br><span class="line">    Example    $&#123;10&#125;     # 参数是整数。按原样接受。</span><br><span class="line">    Example    $&#123;1.5&#125;    # 参数是浮点数。按原样接受。</span><br></pre></td></tr></table></figure></div>

<p>如果接受的类型之一是字符串，那么如果给定的参数是字符串，则不进行转换。如下面的示例给出的给 padding 参数不同值所示，在这些情况下，也可以使用变量传递其他类型：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Conversion</span><br><span class="line">    Example    1    big        # 参数是字符串。按原样接受。</span><br><span class="line">    Example    1    10         # 参数是字符串。按原样接受。</span><br><span class="line">    Example    1    $&#123;10&#125;      # 参数是整数。按原样接受。</span><br><span class="line">    Example    1    $&#123;None&#125;    # 参数是 `None`。按原样接受。</span><br><span class="line">    Example    1    $&#123;1.5&#125;     # 参数是浮点数。转换为整数。</span><br></pre></td></tr></table></figure></div>

<p>如果给定的参数没有任何接受的类型，将按照类型指定的顺序尝试转换。如果任何转换成功，结果值将被使用，而不尝试剩余的转换。如果没有单个转换成功，整个转换失败。</p>
<p>如果 Robot Framework 不识别指定的类型，那么原始参数值将按原样使用。例如，对于这个关键字，首先会尝试将参数转换为整数，但如果失败，关键字将获取原始参数：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">argument: <span class="type">Union</span>[<span class="built_in">int</span>, Unrecognized]</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>从 Robot Framework 6.1 开始，如果未识别的类型列在识别的类型之前，如 Union[Unrecognized, int]，上述逻辑也适用。在这种情况下，也会尝试 int 转换，如果失败，参数将按原样传递。在早期的 Robot Framework 版本中，不会尝试 int 转换。</p>
<h6 id="泛型的类型转换"><a href="#泛型的类型转换" class="headerlink" title="泛型的类型转换"></a>泛型的类型转换</h6><p>对于泛型，也可以使用参数化语法，如 <code>list[int]</code> 或 <code>dict[str, int]</code>。当使用这种语法时，首先将给定值转换为基类型，然后将各个项目转换为嵌套类型。不同的泛型类型的转换规则如下：</p>
<ul>
<li>对于列表，只能有一种类型，如 <code>list[float]</code>。所有列表项都转换为该类型。</li>
<li>对于元组，可以有任意数量的类型，如 <code>tuple[int, int]</code> 和 <code>tuple[str, int, bool]</code>。作为参数的元组预期具有完全相同的项目数量，并且它们被转换为匹配的类型。</li>
<li>要创建同质元组，可以使用一个类型和省略号，如 <code>tuple[int, ...]</code>。在这种情况下，元组可以有任意数量的项目，它们都被转换为指定的类型。</li>
<li>对于字典，必须有两种类型，如 <code>dict[str, int]</code>。字典键使用前一种类型转换，值使用后一种类型转换。</li>
<li>对于集合，只能有一种类型，如 <code>set[float]</code>。转换逻辑与列表相同。</li>
<li>使用原生的 <code>list[int]</code> 语法需要 Python 3.9 或更高版本。如果需要支持早期的 Python 版本，可以使用来自 <code>typing</code> 模块的匹配类型，如 <code>List[int]</code>，或使用 “字符串类型” 语法，如 <code>&#39;list[int]&#39;</code>。</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 6.0 中新增了对泛型的嵌套类型转换的支持。同样的语法也适用于早期版本，但参数只转换为基类型，嵌套类型不用于任何事情。</p>
<p>在 Robot Framework 7.0 中新增了对 “字符串类型” 参数化泛型的支持。</p>

    </div>
  </div>

<h6 id="自定义参数转换器"><a href="#自定义参数转换器" class="headerlink" title="自定义参数转换器"></a>自定义参数转换器</h6><p>除了像前面的章节中解释的那样自动进行参数转换，Robot Framework 还支持自定义参数转换。这个功能有两个主要的用途：</p>
<ul>
<li>覆盖框架提供的标准参数转换器。</li>
<li>为自定义类型和其他不支持开箱即用的类型添加参数转换。</li>
</ul>
<p>参数转换器是函数或其他可调用的对象，它们获取用于数据的参数，并在参数传递给关键字之前将它们转换为所需的格式。通过将 <code>ROBOT_LIBRARY_CONVERTERS</code> 属性（区分大小写）设置为将所需类型映射到转换器的字典，为库注册转换器。当以模块的方式实现库时，这个属性必须设置在模块级别，对于基于类的库，它必须是类属性。对于以类实现的库，也可以使用 <code>@library</code> 装饰器的 <code>converters</code> 参数。下面的章节中的示例说明了这两种方法。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 5.0 中新增了自定义参数转换器。</p>

    </div>
  </div>

<h6 id="覆盖默认转换器"><a href="#覆盖默认转换器" class="headerlink" title="覆盖默认转换器"></a>覆盖默认转换器</h6><p>假设想要创建一个接受日期对象的关键字，用于芬兰的用户，其中常用的日期格式是 dd.mm.yyyy。使用方式可能如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Keyword    25.1.2022</span><br></pre></td></tr></table></figure></div>

<p>自动参数转换支持日期，但它期望它们是 yyyy-mm-dd 格式，所以它不会工作。解决方案是创建一个自定义转换器，并注册它来处理日期转换：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换器函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_fi_date</span>(<span class="params">value</span>):</span><br><span class="line">    day, month, year = value.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> date(<span class="built_in">int</span>(year), <span class="built_in">int</span>(month), <span class="built_in">int</span>(day))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为指定类型注册转换器函数。</span></span><br><span class="line">ROBOT_LIBRARY_CONVERTERS = &#123;date: parse_fi_date&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义转换器的关键字。转换器基于参数类型解析。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>(<span class="params">arg: date</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;year: <span class="subst">&#123;arg.year&#125;</span>, month: <span class="subst">&#123;arg.month&#125;</span>, day: <span class="subst">&#123;arg.day&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h6 id="转换错误"><a href="#转换错误" class="headerlink" title="转换错误"></a>转换错误</h6><p>如果尝试使用像 invalid 这样的无效参数使用上述关键字，它会失败并产生这个错误：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Argument &#x27;arg&#x27; got value &#x27;invalid&#x27; that cannot be converted to date: not enough values to unpack (expected 3, got 1)</span><br></pre></td></tr></table></figure></div>

<p>这个错误不太有信息量，也没有告诉任何关于预期格式的信息。Robot Framework 不能自动提供更多的信息，但转换器本身可以增强以验证输入。如果输入无效，转换器应该引发一个带有适当消息的 ValueError。在这种特殊情况下，有几种方法可以验证输入，但使用正则表达式可以验证输入在正确的位置有点（.）和日期部分包含正确数量的数字：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_fi_date</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="comment"># 使用正则表达式验证输入，如果无效则引发 ValueError。</span></span><br><span class="line">    <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;(\d&#123;1,2&#125;)\.(\d&#123;1,2&#125;)\.(\d&#123;4&#125;)$&#x27;</span>, value)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">match</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Expected date in format &#x27;dd.mm.yyyy&#x27;, got &#x27;<span class="subst">&#123;value&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">    day, month, year = <span class="keyword">match</span>.groups()</span><br><span class="line">    <span class="keyword">return</span> date(<span class="built_in">int</span>(year), <span class="built_in">int</span>(month), <span class="built_in">int</span>(day))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ROBOT_LIBRARY_CONVERTERS = &#123;date: parse_fi_date&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>(<span class="params">arg: date</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;year: <span class="subst">&#123;arg.year&#125;</span>, month: <span class="subst">&#123;arg.month&#125;</span>, day: <span class="subst">&#123;arg.day&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>使用上述转换器代码，使用参数 invalid 的关键字失败会有更多有用的错误消息：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Argument &#x27;arg&#x27; got value &#x27;invalid&#x27; that cannot be converted to date: Expected date in format &#x27;dd.mm.yyyy&#x27;, got &#x27;invalid&#x27;.</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h6 id="限制值类型"><a href="#限制值类型" class="headerlink" title="限制值类型"></a>限制值类型</h6><p>默认情况下，Robot Framework 会尝试使用所有给定参数的转换器，无论它们的类型如何。这意味着，如果之前的示例关键字被用于包含字符串以外的变量，转换代码将在 re.match 调用中失败。例如，尝试使用参数 ${42} 会导致以下错误：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Argument &#x27;arg&#x27; got value &#x27;42&#x27; (integer) that cannot be converted to date: TypeError: expected string or bytes-like object</span><br></pre></td></tr></table></figure></div>

<p>这种错误情况可以自然地在转换器代码中通过检查值类型来处理，但是如果转换器只接受某些类型，通常更容易直接限制值为该类型。做到这一点只需要向转换器添加适当的类型提示：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_fi_date</span>(<span class="params">value: <span class="built_in">str</span></span>):</span><br><span class="line">     <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>注意，这个类型提示不用于在调用转换器之前转换值，它用于严格限制可以使用的类型。使用上述添加后，使用 ${42} 调用关键字将导致以下错误：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Argument &#x27;arg&#x27; got value &#x27;42&#x27; (integer) that cannot be converted to date.</span><br></pre></td></tr></table></figure></div>

<p>如果转换器可以接受多种类型，可以将类型指定为 Union。例如，如果想要增强的关键字，以便也接受整数，使它们被视为自 Unix 纪元以来的秒数，可以这样改变转换器：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受字符串和整数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_fi_date</span>(<span class="params">value: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="comment"># 整数单独转换。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">return</span> date.fromtimestamp(value)</span><br><span class="line">    <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;(\d&#123;1,2&#125;)\.(\d&#123;1,2&#125;)\.(\d&#123;4&#125;)$&#x27;</span>, value)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">match</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Expected date in format &#x27;dd.mm.yyyy&#x27;, got &#x27;<span class="subst">&#123;value&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">    day, month, year = <span class="keyword">match</span>.groups()</span><br><span class="line">    <span class="keyword">return</span> date(<span class="built_in">int</span>(year), <span class="built_in">int</span>(month), <span class="built_in">int</span>(day))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ROBOT_LIBRARY_CONVERTERS = &#123;date: parse_fi_date&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>(<span class="params">arg: date</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;year: <span class="subst">&#123;arg.year&#125;</span>, month: <span class="subst">&#123;arg.month&#125;</span>, day: <span class="subst">&#123;arg.day&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h6 id="转换自定义类型"><a href="#转换自定义类型" class="headerlink" title="转换自定义类型"></a>转换自定义类型</h6><p>在之前的示例中，日期对象只能以 dd.mm.yyyy 的格式给出。如果需要支持不同格式的日期，比如下面的例子，这将无法工作：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Finnish     25.1.2022</span><br><span class="line">    US          1/25/2022</span><br><span class="line">    ISO 8601    2022-01-22</span><br></pre></td></tr></table></figure></div>

<p>解决这个问题的方法是创建自定义类型，而不是覆盖默认的日期转换：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword, library</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义类型。扩展了一个现有的类型，但这不是必需的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FiDate</span>(<span class="title class_ inherited__">date</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换器函数实现为类方法。它也可以是一个普通的函数，但这样所有的代码都在同一个类中。</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_string</span>(<span class="params">cls, value: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;(\d&#123;1,2&#125;)\.(\d&#123;1,2&#125;)\.(\d&#123;4&#125;)$&#x27;</span>, value)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">match</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Expected date in format &#x27;dd.mm.yyyy&#x27;, got &#x27;<span class="subst">&#123;value&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">        day, month, year = <span class="keyword">match</span>.groups()</span><br><span class="line">        <span class="keyword">return</span> cls(<span class="built_in">int</span>(year), <span class="built_in">int</span>(month), <span class="built_in">int</span>(day))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个自定义类型。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsDate</span>(<span class="title class_ inherited__">date</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_string</span>(<span class="params">cls, value: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;4&#125;)$&#x27;</span>, value)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">match</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Expected date in format &#x27;mm/dd/yyyy&#x27;, got &#x27;<span class="subst">&#123;value&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">        month, day, year = <span class="keyword">match</span>.groups()</span><br><span class="line">        <span class="keyword">return</span> cls(<span class="built_in">int</span>(year), <span class="built_in">int</span>(month), <span class="built_in">int</span>(day))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 &#x27;@library&#x27; 装饰器注册转换器。</span></span><br><span class="line"><span class="meta">@library(<span class="params">converters=&#123;FiDate: FiDate.from_string, UsDate: UsDate.from_string&#125;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用支持 &#x27;dd.mm.yyyy&#x27; 格式的自定义转换器。</span></span><br><span class="line"><span class="meta">    @keyword</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finnish</span>(<span class="params">self, arg: FiDate</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;year: <span class="subst">&#123;arg.year&#125;</span>, month: <span class="subst">&#123;arg.month&#125;</span>, day: <span class="subst">&#123;arg.day&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用支持 &#x27;mm/dd/yyyy&#x27; 格式的自定义转换器。</span></span><br><span class="line"><span class="meta">    @keyword</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">us</span>(<span class="params">self, arg: UsDate</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;year: <span class="subst">&#123;arg.year&#125;</span>, month: <span class="subst">&#123;arg.month&#125;</span>, day: <span class="subst">&#123;arg.day&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用与 IS0-8601 兼容的默认转换。</span></span><br><span class="line"><span class="meta">    @keyword</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iso_8601</span>(<span class="params">self, arg: date</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;year: <span class="subst">&#123;arg.year&#125;</span>, month: <span class="subst">&#123;arg.month&#125;</span>, day: <span class="subst">&#123;arg.day&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接受不同格式的日期。</span></span><br><span class="line"><span class="meta">    @keyword</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">any</span>(<span class="params">self, arg: <span class="type">Union</span>[FiDate, UsDate, date]</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;year: <span class="subst">&#123;arg.year&#125;</span>, month: <span class="subst">&#123;arg.month&#125;</span>, day: <span class="subst">&#123;arg.day&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h6 id="严格的类型验证"><a href="#严格的类型验证" class="headerlink" title="严格的类型验证"></a>严格的类型验证</h6><p>如果参数开始时就是指定的类型，那么根本不会使用转换器。因此，使用不接受任何值的自定义转换器可以轻松启用严格的类型验证。例如，Example 关键字只接受 StrictType 实例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrictType</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strict_converter</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">f&#x27;Only StrictType instances accepted, got <span class="subst">&#123;<span class="built_in">type</span>(arg).__name__&#125;</span>.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ROBOT_LIBRARY_CONVERTERS = &#123;StrictType: strict_converter&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">argument: StrictType</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(argument, StrictType)</span><br></pre></td></tr></table></figure></div>

<p>为了方便，Robot Framework 允许将转换器设置为 None 以获得相同的效果。例如，这段代码的行为与上述代码完全相同：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrictType</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ROBOT_LIBRARY_CONVERTERS = &#123;StrictType: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">argument: StrictType</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(argument, StrictType)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 6.0 中新增了使用 None 作为严格转换器。在早期版本中需要使用显式的转换器函数。</p>

    </div>
  </div>

<h6 id="从转换器访问测试库"><a href="#从转换器访问测试库" class="headerlink" title="从转换器访问测试库"></a>从转换器访问测试库</h6><p>从 Robot Framework 6.1 开始，可以从转换器函数访问库实例。这允许定义依赖于库状态的动态类型转换。例如，如果库可以配置为测试特定的区域设置，可能会使用库状态来确定如何解析日期，如下所示：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_date</span>(<span class="params">value, library</span>):</span><br><span class="line">    <span class="comment"># 使用正则表达式验证输入，如果无效则引发 ValueError。</span></span><br><span class="line">    <span class="comment"># 使用库状态中的区域设置来确定解析格式。</span></span><br><span class="line">    <span class="keyword">if</span> library.locale == <span class="string">&#x27;en_US&#x27;</span>:</span><br><span class="line">        <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;(?P&lt;month&gt;\d&#123;1,2&#125;)/(?P&lt;day&gt;\d&#123;1,2&#125;)/(?P&lt;year&gt;\d&#123;4&#125;)$&#x27;</span>, value)</span><br><span class="line">        <span class="built_in">format</span> = <span class="string">&#x27;mm/dd/yyyy&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;(?P&lt;day&gt;\d&#123;1,2&#125;)\.(?P&lt;month&gt;\d&#123;1,2&#125;)\.(?P&lt;year&gt;\d&#123;4&#125;)$&#x27;</span>, value)</span><br><span class="line">        <span class="built_in">format</span> = <span class="string">&#x27;dd.mm.yyyy&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">match</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Expected date in format &#x27;<span class="subst">&#123;<span class="built_in">format</span>&#125;</span>&#x27;, got &#x27;<span class="subst">&#123;value&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> date(<span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="string">&#x27;year&#x27;</span>)), <span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="string">&#x27;month&#x27;</span>)), <span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="string">&#x27;day&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ROBOT_LIBRARY_CONVERTERS = &#123;date: parse_date&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>(<span class="params">arg: date</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;year: <span class="subst">&#123;arg.year&#125;</span>, month: <span class="subst">&#123;arg.month&#125;</span>, day: <span class="subst">&#123;arg.day&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>转换器函数的库参数是可选的，即如果转换器函数只接受一个参数，库参数将被省略。通过使转换器函数只接受可变参数，例如 def parse_date(*varargs)，可以实现类似的结果。</p>
<h6 id="转换器文档"><a href="#转换器文档" class="headerlink" title="转换器文档"></a>转换器文档</h6><p>转换器的信息会自动添加到由 Libdoc 生成的输出中。这些信息包括类型的名称、接受的值（如果使用类型提示指定）和文档。类型信息会自动链接到使用这些类型的所有关键字。</p>
<p>默认情况下，文档是从转换器函数中获取的。如果它没有任何文档，文档就从类型中获取。因此，上一个示例中向转换器添加文档的这两种方法产生的结果是相同的：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FiDate</span>(<span class="title class_ inherited__">date</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_string</span>(<span class="params">cls, value: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;日期格式为 ``dd.mm.yyyy``。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsDate</span>(<span class="title class_ inherited__">date</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;日期格式为 ``mm/dd/yyyy``。&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_string</span>(<span class="params">cls, value: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>通常推荐添加文档，以向用户提供更多关于转换的信息。特别重要的是要记录为现有类型注册的转换器函数，因为它们自己的文档在这种情况下可能不太有用。</p>
<h5 id="keyword-装饰器"><a href="#keyword-装饰器" class="headerlink" title="@keyword 装饰器"></a>@keyword 装饰器</h5><p>尽管 Robot Framework 自动获取了关于关键字的大量信息，如它们的名称和参数，但有时需要进一步配置这些信息。这通常最容易通过使用 robot.api.deco.keyword 装饰器来完成。它有几个有用的用法，这些用法在其他地方已经详细解释，这里只列出作为参考：</p>
<ul>
<li>当使用 @library 装饰器或其他方式禁用了自动关键字发现时，将方法和函数公开为关键字。</li>
<li>为关键字设置自定义名称。当使用嵌入式参数语法时，这尤其有用。</li>
<li>设置关键字标签。</li>
<li>设置类型信息以启用自动参数类型转换。也支持完全禁用参数转换。</li>
<li>当使用动态库 API 或混合库 API 时，标记要公开为关键字的方法。</li>
</ul>
<h5 id="not-keyword-装饰器"><a href="#not-keyword-装饰器" class="headerlink" title="@not_keyword 装饰器"></a>@not_keyword 装饰器</h5><p>robot.api.deco.not_keyword 装饰器可以用于禁用函数或方法成为关键字。</p>
<h5 id="使用自定义装饰器"><a href="#使用自定义装饰器" class="headerlink" title="使用自定义装饰器"></a>使用自定义装饰器</h5><p>在实现关键字时，有时使用 Python 装饰器修改它们是有用的。然而，装饰器通常会修改函数签名，因此可能会使 Robot Framework 的内省在确定关键字接受哪些参数时感到困惑。当使用 Libdoc 创建库文档和使用像 RIDE 这样的外部工具时，这尤其有问题。避免这个问题的最简单方法是使用 functools.wraps 装饰装饰器本身。其他解决方案包括使用像 decorator 和 wrapt 这样的外部模块，它们允许创建完全保留签名的装饰器。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.2 中新增了对使用 functools.wraps 装饰的装饰器的 “解包” 支持。</p>

    </div>
  </div>

<p>​      </p>
<h5 id="嵌入参数到关键字名称"><a href="#嵌入参数到关键字名称" class="headerlink" title="嵌入参数到关键字名称"></a>嵌入参数到关键字名称</h5><p>库关键字也可以接受嵌入参数，就像用户关键字一样。这部分主要介绍创建此类关键字的 Python 语法，嵌入参数的语法本身在用户关键字文档中详细介绍。</p>
<p>具有嵌入参数的库关键字需要有一个自定义名称，通常使用 <code>@keyword</code> 装饰器设置。匹配嵌入参数的值作为位置参数传递给实现关键字的函数或方法。如果函数或方法接受更多参数，它们可以作为正常的位置或命名参数传递给关键字。参数名称不需要匹配嵌入参数名称，但这通常是一个好的约定。</p>
<p>接受嵌入参数的关键字：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params"><span class="string">&#x27;Select $&#123;animal&#125; from list&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_animal_from_list</span>(<span class="params">animal</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params"><span class="string">&#x27;Number of $&#123;animals&#125; should be&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">number_of_animals_should_be</span>(<span class="params">animals, count</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>使用上述关键字的测试：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Embedded arguments</span><br><span class="line">    Select cat from list</span><br><span class="line">    Select dog from list</span><br><span class="line"></span><br><span class="line">Embedded and normal arguments</span><br><span class="line">    Number of cats should be    2</span><br><span class="line">    Number of dogs should be    count=3</span><br></pre></td></tr></table></figure></div>

<p>如果指定了类型信息，自动参数转换也适用于嵌入参数：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@keyword(<span class="params"><span class="string">&#x27;Add $&#123;quantity&#125; copies of $&#123;item&#125; to cart&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_copies_to_cart</span>(<span class="params">quantity: <span class="built_in">int</span>, item: <span class="built_in">str</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 7.0 中，混合嵌入参数和普通参数的支持是新的。</p>

    </div>
  </div>

<h5 id="异步关键字"><a href="#异步关键字" class="headerlink" title="异步关键字"></a>异步关键字</h5><p>从 Robot Framework 6.1 开始，可以像运行普通函数一样运行原生异步函数（由 async def 创建）：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">this_keyword_waits</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></div>

<p>可以使用 <code>asyncio.get_running_loop()</code> 或 <code>asyncio.get_event_loop()</code> 获取循环的引用。在修改循环运行方式时要小心，它是全局资源。例如，永远不要调用 <code>loop.close()</code>，因为这将使得无法运行任何进一步的协程。如果有任何函数或资源需要事件循环，即使没有显式使用 await，也必须将函数定义为 async 才能使用事件循环。</p>
<p>更多功能示例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_async</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">examples</span>():</span><br><span class="line">    tasks = [task_async() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">    background_task = asyncio.create_task(task_async())</span><br><span class="line">    <span class="keyword">await</span> background_task</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If running with Python 3.10 or higher</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> asyncio.TaskGroup() <span class="keyword">as</span> tg:</span><br><span class="line">        task1 = tg.create_task(task_async())</span><br><span class="line">        task2 = tg.create_task(task_async())</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>Robot Framework 会等待函数完成。如果想要一个运行很长时间的任务，例如，使用 <code>asyncio.create_task()</code>。管理任务并保存引用以避免被垃圾回收是责任。如果事件循环关闭并且任务仍在挂起，将打印一条消息到控制台。</p>
<p>如果关键字的执行由于某种原因不能继续，例如信号停止，Robot Framework 将取消异步任务及其所有子任务。其他异步任务将正常运行。</p>

    </div>
  </div>



<h4 id="与-Robot-Framework-通信"><a href="#与-Robot-Framework-通信" class="headerlink" title="与 Robot Framework 通信"></a>与 Robot Framework 通信</h4><p>在调用实现关键字的方法后，它可以使用任何机制与被测试系统进行通信。然后，它也可以向 Robot Framework 的日志文件发送消息，返回可以保存到变量的信息，最重要的是，报告关键字是否通过。</p>
<h5 id="报告关键字状态"><a href="#报告关键字状态" class="headerlink" title="报告关键字状态"></a>报告关键字状态</h5><p>报告关键字状态只需使用异常即可完成。如果执行的方法引发异常，关键字状态为 FAIL，如果正常返回，则状态为 PASS。</p>
<p>可以使用标准异常（如 AssertionError、ValueError 和 RuntimeError）报告正常执行失败和错误。然而，在后续部分解释的一些特殊情况中，需要特殊的异常。</p>
<h6 id="错误消息-1"><a href="#错误消息-1" class="headerlink" title="错误消息"></a>错误消息</h6><p>在日志、报告和控制台中显示的错误消息是从异常类型和其消息创建的。对于通用异常（例如，AssertionError、Exception 和 RuntimeError），只使用异常消息，对于其他异常，消息以 ExceptionType: Actual message 的格式创建。</p>
<p>也可以避免在非通用异常的失败消息前添加异常类型。这是通过向异常添加一个特殊的 ROBOT_SUPPRESS_NAME 属性并赋值为 True 来完成的。</p>
<p>Python：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span>(<span class="title class_ inherited__">RuntimeError</span>):</span><br><span class="line">    ROBOT_SUPPRESS_NAME = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>

<p>在所有情况下，对用户来说，异常消息尽可能具有信息性是很重要的。</p>
<h6 id="错误消息中的-HTML"><a href="#错误消息中的-HTML" class="headerlink" title="错误消息中的 HTML"></a>错误消息中的 HTML</h6><p>也可以通过在消息开始处添加文本 <em>HTML</em> 来获得 HTML 格式的错误消息：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> AssertionError(<span class="string">&quot;*HTML* &lt;a href=&#x27;robotframework.org&#x27;&gt;Robot Framework&lt;/a&gt; rulez!!&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>这种方法既可以在库中引发异常时使用，如上例所示，也可以在用户在测试数据中提供错误消息时使用。</p>
<h6 id="自动剪切长消息"><a href="#自动剪切长消息" class="headerlink" title="自动剪切长消息"></a>自动剪切长消息</h6><p>如果错误消息超过 40 行，它将自动从中间剪切，以防止报告变得过长且难以阅读。完整的错误消息总是显示在失败关键字的日志消息中。</p>
<h6 id="跟踪回溯"><a href="#跟踪回溯" class="headerlink" title="跟踪回溯"></a>跟踪回溯</h6><p>异常的跟踪回溯也使用 DEBUG 日志级别记录。这些消息在日志文件中默认不可见，因为它们对普通用户来说很少有趣。在开发库时，通常最好使用 –loglevel DEBUG 运行测试。</p>
<h5 id="Robot-Framework-提供的异常"><a href="#Robot-Framework-提供的异常" class="headerlink" title="Robot Framework 提供的异常"></a>Robot Framework 提供的异常</h5><p>Robot Framework 提供了一些库可以用来报告失败和其他事件的异常。这些异常通过 <code>robot.api</code> 包暴露，并包含以下内容：</p>
<h6 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h6><p>报告验证失败。使用此异常与使用标准的 AssertionError 没有实际区别。使用此异常的主要好处是其名称与其他提供的异常一致。</p>
<h6 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h6><p>报告执行错误。与系统行为不符的失败通常应使用 Failure 异常或标准的 AssertionError 报告。例如，如果关键字使用不正确，可以使用此异常。除了与其他提供的异常名称一致外，使用此异常与使用标准的 RuntimeError 没有实际区别。</p>
<h6 id="ContinuableFailure"><a href="#ContinuableFailure" class="headerlink" title="ContinuableFailure"></a>ContinuableFailure</h6><p>报告验证失败但允许继续执行。有关更多信息，请参见下面的 “可继续的失败” 部分。</p>
<h6 id="SkipExecution"><a href="#SkipExecution" class="headerlink" title="SkipExecution"></a>SkipExecution</h6><p>标记已执行的测试或任务为跳过。有关更多信息，请参见下面的 “跳过测试” 部分。</p>
<h6 id="FatalError"><a href="#FatalError" class="headerlink" title="FatalError"></a>FatalError</h6><p>报告停止整个执行的错误。有关更多信息，请参见下面的 “停止测试执行” 部分。</p>
<p>注意：所有这些异常都是在 Robot Framework 4.0 中新增的。除跳过测试（这也是 Robot Framework 4.0 中的新功能）外，早期版本中的其他功能可以通过其他方式获得。</p>
<h6 id="可继续的失败"><a href="#可继续的失败" class="headerlink" title="可继续的失败"></a>可继续的失败</h6><p>即使存在失败，也可以继续测试执行。做到这一点的最简单方法是使用提供的 <code>robot.api.ContinuableFailure</code> 异常：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> ContinuableFailure</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>():</span><br><span class="line">    <span class="keyword">if</span> something_is_wrong():</span><br><span class="line">        <span class="keyword">raise</span> ContinuableFailure(<span class="string">&#x27;Something is wrong but execution can continue.&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>另一种方法是创建一个自定义异常，该异常具有设置为 True 值的特殊 <code>ROBOT_CONTINUE_ON_FAILURE</code> 属性。下面的示例进行了演示。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContinuableError</span>(<span class="title class_ inherited__">RuntimeError</span>):</span><br><span class="line">    ROBOT_CONTINUE_ON_FAILURE = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>

<h6 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h6><p>可以使用库关键字跳过测试。做到这一点的最简单方法是使用提供的 <code>robot.api.SkipExecution</code> 异常：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> SkipExecution</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>():</span><br><span class="line">    <span class="keyword">if</span> test_should_be_skipped():</span><br><span class="line">        <span class="keyword">raise</span> SkipExecution(<span class="string">&#x27;Cannot proceed, skipping test.&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>另一种方法是创建一个自定义异常，该异常具有设置为 True 值的特殊 <code>ROBOT_SKIP_EXECUTION</code> 属性。下面的示例进行了演示。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySkippingError</span>(<span class="title class_ inherited__">RuntimeError</span>):</span><br><span class="line">    ROBOT_SKIP_EXECUTION = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>

<p>​                </p>
<h6 id="停止测试执行"><a href="#停止测试执行" class="headerlink" title="停止测试执行"></a>停止测试执行</h6><p>可以使测试用例失败，从而停止整个测试执行。实现这一点的最简单方法是使用提供的 <code>robot.api.FatalError</code> 异常：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> FatalError</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>():</span><br><span class="line">    <span class="keyword">if</span> system_is_not_running():</span><br><span class="line">        <span class="keyword">raise</span> FatalError(<span class="string">&#x27;System is not running!&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>除了使用 <code>robot.api.FatalError</code> 异常外，还可以创建一个具有设置为 True 值的特殊 <code>ROBOT_EXIT_ON_FAILURE</code> 属性的自定义异常。下面的示例进行了说明。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFatalError</span>(<span class="title class_ inherited__">RuntimeError</span>):</span><br><span class="line">    ROBOT_EXIT_ON_FAILURE = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>

<h6 id="记录信息"><a href="#记录信息" class="headerlink" title="记录信息"></a>记录信息</h6><p>异常消息不是向用户提供信息的唯一方式。除此之外，方法还可以通过简单地写入标准输出流（stdout）或标准错误流（stderr）向日志文件发送消息，甚至可以使用不同的日志级别。另一个，通常更好的，记录可能性是使用编程日志 API。</p>
<p>默认情况下，方法写入标准输出的所有内容都作为单个条目写入日志文件，日志级别为 INFO。写入标准错误的消息在其他方面处理类似，但在关键字执行完成后，它们会被回显到原始 stderr。因此，如果需要在执行测试的控制台上看到一些消息，可以使用 stderr。</p>
<h6 id="使用日志级别"><a href="#使用日志级别" class="headerlink" title="使用日志级别"></a>使用日志级别</h6><p>要使用 INFO 以外的其他日志级别，或创建多个消息，可以通过在消息中明确指定日志级别来实现，格式为 <em>LEVEL</em> 实际日志消息。在这种格式中，<em>LEVEL</em> 必须在行的开头，LEVEL 必须是可用的具体日志级别 TRACE、DEBUG、INFO、WARN 或 ERROR，或伪日志级别 HTML 或 CONSOLE。伪级别可以分别用于记录 HTML 和记录到控制台。</p>
<h6 id="错误和警告"><a href="#错误和警告" class="headerlink" title="错误和警告"></a>错误和警告</h6><p>带有 ERROR 或 WARN 级别的消息会自动写入控制台和日志文件中的单独的 “Test Execution Errors” 部分。这使得这些消息比其他消息更加可见，并允许使用它们向用户报告重要但非关键的问题。</p>
<h6 id="记录-HTML"><a href="#记录-HTML" class="headerlink" title="记录 HTML"></a>记录 HTML</h6><p>库通常记录的所有内容都将转换为可以安全表示为 HTML 的格式。例如，<b>foo</b> 将在日志中完全按照该方式显示，而不是 foo。如果库想要使用格式化、链接、显示图像等，它们可以使用特殊的伪日志级别 HTML。Robot Framework 将这些消息直接以 INFO 级别写入日志，因此它们可以使用任何它们想要的 HTML 语法。注意，需要谨慎使用此功能，因为例如，一个放置不当的 </table> 标签可能会严重破坏日志文件。</p>
<p>在使用公共日志 API 时，各种日志方法有可选的 html 属性，可以设置为 True 以启用 HTML 格式的日志。</p>
<h6 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h6><p>默认情况下，通过标准输出或错误流记录的消息在执行的关键字结束时获取其时间戳。这意味着时间戳不准确，特别是对于运行时间较长的关键字的问题调试可能会有问题。</p>
<p>关键字有可能在需要时向它们记录的消息中添加准确的时间戳。时间戳必须以 Unix 纪元以来的毫秒数给出，并且必须放在日志级别后面，用冒号与其分隔：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*INFO:<span class="number">1308435758660</span>* Message <span class="keyword">with</span> timestamp</span><br><span class="line">*HTML:<span class="number">1308435758661</span>* &lt;b&gt;HTML&lt;/b&gt; message <span class="keyword">with</span> timestamp</span><br></pre></td></tr></table></figure></div>

<p>如下面的示例所示，添加时间戳很容易。然而，使用编程日志 API 获取准确的时间戳更容易。显式添加时间戳的一个大好处是，这种方法也适用于远程库接口。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;*INFO:%d* Message with timestamp&#x27;</span> % (time.time()*<span class="number">1000</span>))</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h6 id="记录到控制台"><a href="#记录到控制台" class="headerlink" title="记录到控制台"></a>记录到控制台</h6><p>库有多种选项可以将消息写入控制台。如前所述，警告和所有写入标准错误流的消息都会同时写入日志文件和控制台。这两种选项都有一个限制，即消息只有在当前执行的关键字完成后才会结束到控制台。</p>
<p>从 Robot Framework 6.1 开始，库可以使用伪日志级别 CONSOLE 将消息同时记录到日志文件和控制台：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_keyword</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;*CONSOLE* Message both to log and to console.&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>这些消息将以与 HTML 伪日志级别类似的方式使用 INFO 级别记录到日志文件。使用此方法时，消息只有在关键字执行结束后才会记录到控制台。</p>
<p>另一种选项是将消息写入 <code>sys.__stdout__</code> 或 <code>sys.__stderr__</code>。使用此方法时，消息会立即写入控制台，并且根本不会写入日志文件：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_keyword</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Message only to console.&#x27;</span>, file=sys.__stdout__)</span><br></pre></td></tr></table></figure></div>

<p>最后一个选项是使用公共日志 API。在这种方法中，消息也会立即写入控制台：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_to_console</span>(<span class="params">arg</span>):</span><br><span class="line">    logger.console(<span class="string">&#x27;Message only to console.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_to_console_and_log_file</span>(<span class="params">arg</span>):</span><br><span class="line">    logger.info(<span class="string">&#x27;Message both to log and to console.&#x27;</span>, also_console=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div>

<h6 id="日志示例"><a href="#日志示例" class="headerlink" title="日志示例"></a>日志示例</h6><p>在大多数情况下，INFO 级别就足够了。低于它的级别，DEBUG 和 TRACE，对于写入调试信息很有用。这些消息通常不会显示，但是它们可以帮助调试库本身可能存在的问题。WARN 或 ERROR 级别可以用来使消息更加可见，HTML 对于需要任何类型的格式化都很有用。当消息需要同时显示在控制台和日志文件中时，可以使用 CONSOLE 级别。</p>
<p>以下示例阐明了如何使用不同级别进行日志记录的工作方式。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello from a library.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*WARN* Warning from a library.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*ERROR* Something unexpected happen that may indicate a problem in the test.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*INFO* Hello again!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;This will be part of the previous message.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*INFO* This is a new message.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*INFO* This is &lt;b&gt;normal text&lt;/b&gt;.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*CONSOLE* This logs into console and log file.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*HTML* This is &lt;b&gt;bold&lt;/b&gt;.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*HTML* &lt;a href=&quot;http://robotframework.org&quot;&gt;Robot Framework&lt;/a&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	INFO	Hello from a library. </span><br><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	WARN	Warning from a library. </span><br><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	ERROR	Something unexpected happen that may indicate a problem <span class="keyword">in</span> the test. </span><br><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	INFO	Hello again! This will be part of the previous message. </span><br><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	INFO	This is a new message. </span><br><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	INFO	This is &lt;b&gt;normal text&lt;/b&gt;. </span><br><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	INFO	This logs into console and log file. </span><br><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	INFO	This is bold. </span><br><span class="line"><span class="number">16</span>:<span class="number">18</span>:<span class="number">42</span>.<span class="number">123</span>	INFO	Robot Framework</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h5 id="程序化日志-API"><a href="#程序化日志-API" class="headerlink" title="程序化日志 API"></a>程序化日志 API</h5><p>程序化 API 提供了比使用标准输出和错误流更清晰的方式来记录信息。</p>
<h6 id="公共日志-API"><a href="#公共日志-API" class="headerlink" title="公共日志 API"></a>公共日志 API</h6><p>Robot Framework 有一个基于 Python 的日志 API，用于将消息写入日志文件和控制台。测试库可以像 <code>logger.info(&#39;My message&#39;)</code> 这样使用这个 API，而不是像 <code>print(&#39;*INFO* My message&#39;)</code> 那样通过标准输出进行日志记录。除了程序化接口使用起来更清晰外，这个 API 还有一个好处，即日志消息具有准确的时间戳。</p>
<p>公共日志 API 在 <a class="link"   target="_blank" rel="noopener" href="https://robot-framework.readthedocs.org/" >https://robot-framework.readthedocs.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的 API 文档部分有详细的文档。下面是一个简单的使用示例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_keyword</span>(<span class="params">arg</span>):</span><br><span class="line">    logger.debug(<span class="string">&#x27;Got argument %s&#x27;</span> % arg)</span><br><span class="line">    do_something()</span><br><span class="line">    logger.info(<span class="string">&#x27;&lt;i&gt;This&lt;/i&gt; is a boring example&#x27;</span>, html=<span class="literal">True</span>)</span><br><span class="line">    logger.console(<span class="string">&#x27;Hello, console!&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>一个明显的限制是，使用这个日志 API 的测试库依赖于 Robot Framework。如果 Robot Framework 没有运行，消息会自动重定向到 Python 的标准日志模块。</p>
<h6 id="使用-Python-的标准日志模块"><a href="#使用-Python-的标准日志模块" class="headerlink" title="使用 Python 的标准日志模块"></a>使用 Python 的标准日志模块</h6><p>除了新的公共日志 API 外，Robot Framework 还提供了对 Python 的标准日志模块的内置支持。这个工作方式是，模块的根记录器接收到的所有消息都会自动传播到 Robot Framework 的日志文件。此 API 也会产生具有准确时间戳的日志消息，但不支持记录 HTML 消息或将消息写入控制台。一个很大的好处，也由下面的简单示例说明，是使用这个日志 API 不会创建对 Robot Framework 的依赖。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_keyword</span>(<span class="params">arg</span>):</span><br><span class="line">    logging.debug(<span class="string">&#x27;Got argument %s&#x27;</span> % arg)</span><br><span class="line">    do_something()</span><br><span class="line">    logging.info(<span class="string">&#x27;This is a boring example&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>日志模块的日志级别与 Robot Framework 稍有不同。它的 DEBUG、INFO、WARNING 和 ERROR 级别直接映射到匹配的 Robot Framework 日志级别，CRITICAL 映射到 ERROR。自定义日志级别映射到比自定义级别小的最接近的标准级别。例如，INFO 和 WARNING 之间的级别映射到 Robot Framework 的 INFO 级别。</p>
<h6 id="在库初始化期间进行日志记录"><a href="#在库初始化期间进行日志记录" class="headerlink" title="在库初始化期间进行日志记录"></a>在库初始化期间进行日志记录</h6><p>库也可以在测试库导入和初始化期间进行日志记录。这些消息不会像正常的日志消息那样出现在日志文件中，而是写入到系统日志中。这允许记录关于库初始化的任何类型的有用的调试信息。使用 WARN 或 ERROR 级别记录的消息也会在日志文件中的测试执行错误部分中可见。</p>
<p>在导入和初始化期间进行日志记录可以使用标准输出和错误流以及程序化日志 API。这两种方法都在下面进行了演示。</p>
<p>在导入期间使用日志 API 记录库：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;Importing library&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>():</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果在初始化期间，即在 Python 的 <code>__init__</code> 中，记录了一些东西，那么根据库的范围，消息可能会被记录多次。</p>

    </div>
  </div>

<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>关键字与核心框架进行反向通信的最后一种方式是返回从被测试系统中检索或通过其他方式生成的信息。返回的值可以赋值给测试数据中的变量，然后作为其他关键字（甚至来自不同测试库）的输入使用。</p>
<p>值是通过方法中的 return 语句返回的。通常，一个值被赋值给一个标量变量，如下例所示。此示例还说明了可以返回任何对象并使用扩展变量语法访问对象属性的可能性。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mymodule <span class="keyword">import</span> MyObject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_string</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_object</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> MyObject(name)</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Returning one value</span><br><span class="line">    $&#123;string&#125; =    Return String</span><br><span class="line">    Should Be Equal    $&#123;string&#125;    Hello, world!</span><br><span class="line">    $&#123;<span class="built_in">object</span>&#125; =    Return Object    Robot</span><br><span class="line">    Should Be Equal    $&#123;<span class="built_in">object</span>.name&#125;    Robot</span><br></pre></td></tr></table></figure></div>

<p>关键字也可以返回值，以便它们可以一次赋值给多个标量变量，赋值给一个列表变量，或赋值给标量变量和一个列表变量。所有这些用法都需要返回的值是列表或类似列表的对象。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">return_two_values</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;first value&#x27;</span>, <span class="string">&#x27;second value&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_multiple_values</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;of&#x27;</span>, <span class="string">&#x27;strings&#x27;</span>]</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Returning multiple values</span><br><span class="line">    $&#123;var1&#125;    $&#123;var2&#125; =    Return Two Values</span><br><span class="line">    Should Be Equal    $&#123;var1&#125;    first value</span><br><span class="line">    Should Be Equal    $&#123;var2&#125;    second value</span><br><span class="line"><span class="meta">    @&#123;list&#125; =    Return Two Values</span></span><br><span class="line">    Should Be Equal    @&#123;<span class="built_in">list</span>&#125;[<span class="number">0</span>]    first value</span><br><span class="line">    Should Be Equal    @&#123;<span class="built_in">list</span>&#125;[<span class="number">1</span>]    second value</span><br><span class="line">    $&#123;s1&#125;    $&#123;s2&#125;    @&#123;li&#125; =    Return Multiple Values</span><br><span class="line">    Should Be Equal    $&#123;s1&#125; $&#123;s2&#125;    a <span class="built_in">list</span></span><br><span class="line">    Should Be Equal    @&#123;li&#125;[<span class="number">0</span>] @&#123;li&#125;[<span class="number">1</span>]    of strings</span><br></pre></td></tr></table></figure></div>

<h5 id="检测-Robot-Framework-是否正在运行"><a href="#检测-Robot-Framework-是否正在运行" class="headerlink" title="检测 Robot Framework 是否正在运行"></a>检测 Robot Framework 是否正在运行</h5><p>从 Robot Framework 6.1 开始，通过使用 BuiltIn 库的 <code>robot_running</code> 和 <code>dry_run_active</code> 属性，很容易检测 Robot Framework 是否正在运行，以及 dry-run 模式是否激活。一个相对常见的用例是，库初始化器可能希望避免在执行期间不使用库但是被初始化（例如，由 Libdoc）时做一些工作：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.libraries.BuiltIn <span class="keyword">import</span> BuiltIn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLibrary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        builtin = BuiltIn()</span><br><span class="line">        <span class="keyword">if</span> builtin.robot_running <span class="keyword">and</span> <span class="keyword">not</span> builtin.dry_run_active:</span><br><span class="line">            <span class="comment"># Do some initialization that only makes sense during real execution.</span></span><br></pre></td></tr></table></figure></div>

<p>有关使用 BuiltIn 库作为程序化 API 的更多信息，包括使用 <code>robot_running</code> 的另一个示例，请参见 “使用 BuiltIn 库” 部分。</p>
<h5 id="使用线程时的通信"><a href="#使用线程时的通信" class="headerlink" title="使用线程时的通信"></a>使用线程时的通信</h5><p>如果库使用线程，它通常应该只从主线程与框架进行通信。如果工作线程有例如需要报告的失败或需要记录的东西，它应该首先将信息传递给主线程，然后主线程可以使用本节解释的异常或其他机制与框架进行通信。</p>
<p>当线程在其他关键字运行时在后台运行时，这尤其重要。在这种情况下与框架进行通信的结果是未定义的，最坏的情况可能导致崩溃或输出文件损坏。如果关键字在后台启动了一些东西，应该有另一个关键字检查工作线程的状态并相应地报告收集到的信息。</p>
<p>使用程序化日志 API 的正常日志方法记录的非主线程的消息将被静默忽略。</p>
<p>还有一个在单独的 robotbackgroundlogger 项目中的 BackgroundLogger，具有与标准 robot.api.logger 类似的 API。正常的日志方法会忽略来自非主线程的消息，但 BackgroundLogger 会保存后台消息，以便稍后可以记录到 Robot 的日志中。</p>
<h4 id="分发测试库"><a href="#分发测试库" class="headerlink" title="分发测试库"></a>分发测试库</h4><h5 id="文档化库"><a href="#文档化库" class="headerlink" title="文档化库"></a>文档化库</h5><p>没有关于其包含哪些关键字以及这些关键字的作用的文档的测试库是相当无用的。为了便于维护，强烈建议将库文档包含在源代码中并从中生成。基本上，这意味着使用 docstrings，如下例所示：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLibrary</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个带有一些文档的示例库。&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keyword_with_short_documentation</span>(<span class="params">self, argument</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这个关键字只有简短的文档&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keyword_with_longer_documentation</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;文档的第一行在这里。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        更长的文档在这里继续，它可以包含</span></span><br><span class="line"><span class="string">        多行或段落。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>Python 有创建库文档的工具，如上所述。然而，这些工具的输出对于一些用户来说可能稍微有些技术性。另一种选择是使用 Robot Framework 自己的文档工具 Libdoc。此工具可以从使用静态库 API 的库（如上所述）创建库文档，但它也处理使用动态库 API 和混合库 API 的库。</p>
<p>关键字文档的第一行逻辑行，直到第一个空行，用于特殊目的，应包含关键字的简短总体描述。它被 Libdoc 用作简短文档（例如，作为工具提示）并且也显示在测试日志中。</p>
<p>默认情况下，文档被认为遵循 Robot Framework 的文档格式规则。这种简单的格式允许经常使用的样式，如 <strong>粗体</strong> 和 <em>斜体</em>，表格，列表，链接等。也可以使用 HTML，纯文本和 reStructuredText 格式。有关如何在库源代码中设置格式的信息，请参见文档格式部分，有关格式的更多信息，请参见 Libdoc 章节。</p>
<p>注意：在 Robot Framework 3.1 之前，简短文档只包含关键字文档的第一行物理行。</p>
<h5 id="测试库"><a href="#测试库" class="headerlink" title="测试库"></a>测试库</h5><p>任何非琐碎的测试库都需要进行彻底的测试，以防止其中出现错误。当然，这种测试应该是自动化的，以便在库发生变化时重新运行测试。</p>
<p>Python 有出色的单元测试工具，它们非常适合测试库。在使用它们进行此目的的测试与使用它们进行其他测试之间没有主要的区别。熟悉这些工具的开发人员不需要学习任何新东西，而不熟悉它们的开发人员应该 anyway 学习它们。</p>
<p>也很容易使用 Robot Framework 本身来测试库，从而为它们进行实际的端到端验收测试。在 BuiltIn 库中有很多有用的关键字可以用于此目的。特别值得一提的是 Run Keyword And Expect Error，它对于测试关键字是否正确报告错误非常有用。</p>
<p>是否使用单元级别或验收级别的测试方法取决于上下文。如果需要模拟实际的被测试系统，通常在单元级别上更容易。另一方面，验收测试确保关键字通过 Robot Framework 工作。如果不能决定，当然可以使用这两种方法。</p>
<h5 id="打包库"><a href="#打包库" class="headerlink" title="打包库"></a>打包库</h5><p>在库被实现、文档化和测试后，仍然需要将其分发给用户。对于由单个文件组成的简单库，通常只需要求用户将该文件复制到某个地方并相应地设置模块搜索路径。更复杂的库应该被打包以使安装更容易。</p>
<p>由于库是正常的编程代码，它们可以使用正常的打包工具进行打包。有关打包和分发 Python 代码的信息，请参见 <a class="link"   target="_blank" rel="noopener" href="https://packaging.python.org/%E3%80%82%E5%BD%93%E4%BD%BF%E7%94%A8" >https://packaging.python.org/。当使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> pip 或其他工具安装此类包时，它会自动在模块搜索路径中。</p>
<h5 id="弃用关键字"><a href="#弃用关键字" class="headerlink" title="弃用关键字"></a>弃用关键字</h5><p>有时候，可能需要用新的关键字替换现有的关键字，或者完全删除它们。仅仅通知用户这种变化可能并不总是足够的，运行时获取警告更有效。为了支持这一点，Robot Framework 具有标记关键字已弃用的能力。这使得更容易从测试数据中找到旧的关键字并删除或替换它们。</p>
<p>关键字可以通过在其文档开始处添加文本 <em>DEPRECATED（区分大小写）并在文档的第一行也有一个关闭 * 来标记为已弃用。例如，</em>DEPRECATED<em>，</em>DEPRECATED.* 和 <em>DEPRECATED in version 1.5.</em> 都是有效的标记。</p>
<p>当执行一个已弃用的关键字时，会记录一个弃用警告，并且警告也会显示在控制台和日志文件中的测试执行错误部分。弃用警告以文本 “Keyword ‘<name>’ is deprecated.” 开始，并在弃用标记之后有剩余的简短文档（如果有的话）。例如，如果执行以下关键字，日志文件中将会有如下所示的警告。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">argument</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;*DEPRECATED!!* Use keyword `Other Keyword` instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This keyword does something to given ``argument`` and returns results.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> do_something(argument)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20080911</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">22</span>.<span class="number">650</span>	WARN	Keyword ‘SomeLibrary.Example Keyword’ is deprecated. Use keyword `Other Keyword` instead.</span><br></pre></td></tr></table></figure></div>

<p>这个弃用系统适用于大多数测试库，也适用于用户关键字。</p>
<h4 id="动态库-API"><a href="#动态库-API" class="headerlink" title="动态库 API"></a>动态库 API</h4><p>动态 API 在很多方面与静态 API 类似。例如，报告关键字状态、记录日志和返回值的工作方式完全相同。最重要的是，导入动态库和使用它们的关键字与其他库没有区别。换句话说，用户不需要知道他们的库使用的是什么 API。</p>
<p>静态库和动态库之间的唯一区别是 Robot Framework 如何发现库实现了哪些关键字，这些关键字有哪些参数和文档，以及如何实际执行这些关键字。在静态 API 中，所有这些都是通过反射完成的，但是动态库有一些特殊的方法用于这些目的。</p>
<p>动态 API 的一个好处是在组织库时有更多的灵活性。使用静态 API，必须在一个类或模块中有所有的关键字，而使用动态 API，可以例如将每个关键字实现为一个单独的类。然而，这种用例对于 Python 来说并不那么重要，因为它的动态能力和多继承已经提供了足够的灵活性，而且还有可能使用混合库 API。</p>
<p>动态 API 的另一个主要用例是实现一个库，使其可以作为可能在其他进程甚至其他机器上运行的实际库的代理。这种代理库可以非常薄，因为关键字名称和所有其他信息都是动态获取的，所以当在实际库中添加新的关键字时，无需更新代理。</p>
<p>本节解释了动态 API 如何在 Robot Framework 和动态库之间工作。对于 Robot Framework 来说，这些库是如何实际实现的（例如，如何将 <code>run_keyword</code> 方法的调用映射到正确的关键字实现）并不重要，有许多不同的方法是可能的。Python 用户也可能会发现 PythonLibCore 项目很有用。</p>
<h5 id="获取关键字名称"><a href="#获取关键字名称" class="headerlink" title="获取关键字名称"></a>获取关键字名称</h5><p>动态库通过 <code>get_keyword_names</code> 方法告诉它们实现了哪些关键字。此方法不能接受任何参数，并且必须返回一个包含库实现的关键字名称的字符串列表或数组。</p>
<p>如果返回的关键字名称包含多个单词，它们可以用空格或下划线分隔，或者以驼峰格式返回。例如，[‘first keyword’, ‘second keyword’]，[‘first_keyword’, ‘second_keyword’] 和 [‘firstKeyword’, ‘secondKeyword’] 都将被映射到关键字 First Keyword 和 Second Keyword。</p>
<p>动态库必须始终具有此方法。如果它缺失，或者由于某种原因调用它失败，库将被视为静态库。</p>
<h5 id="标记要作为关键字公开的方法"><a href="#标记要作为关键字公开的方法" class="headerlink" title="标记要作为关键字公开的方法"></a>标记要作为关键字公开的方法</h5><p>如果一个动态库应该包含既是关键字又是私有辅助方法的方法，那么标记关键字方法可能是明智的，这样在实现 <code>get_keyword_names</code> 时就更容易。<code>robot.api.deco.keyword</code> 装饰器允许轻松做到这一点，因为它在装饰的方法上创建了一个自定义的 ‘robot_name’ 属性。这允许在 <code>get_keyword_names</code> 期间只通过检查库中每个方法的 <code>robot_name</code> 属性来生成关键字列表。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicExample</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_keyword_names</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 从库中获取所有属性及其值。</span></span><br><span class="line">        attributes = [(name, <span class="built_in">getattr</span>(self, name)) <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">dir</span>(self)]</span><br><span class="line">        <span class="comment"># 过滤出没有 &#x27;robot_name&#x27; 设置的属性。</span></span><br><span class="line">        keywords = [(name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attributes</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">hasattr</span>(value, <span class="string">&#x27;robot_name&#x27;</span>)]</span><br><span class="line">        <span class="comment"># 返回 &#x27;robot_name&#x27; 的值（如果给定），否则返回原始的 &#x27;name&#x27;。</span></span><br><span class="line">        <span class="keyword">return</span> [value.robot_name <span class="keyword">or</span> name <span class="keyword">for</span> name, value <span class="keyword">in</span> keywords]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @keyword</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keyword_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<h5 id="执行关键字"><a href="#执行关键字" class="headerlink" title="执行关键字"></a>执行关键字</h5><p>动态库有一个特殊的 <code>run_keyword</code>（别名 <code>runKeyword</code>）方法用于执行它们的关键字。当在测试数据中使用来自动态库的关键字时，Robot Framework 使用 <code>run_keyword</code> 方法来执行它。此方法接受两个或三个参数。第一个参数是一个字符串，包含要执行的关键字的名称，格式与 <code>get_keyword_names</code> 返回的格式相同。第二个参数是一个列表，包含在测试数据中给关键字的位置参数，可选的第三个参数是一个包含命名参数的字典。如果缺少第三个参数，不支持自由命名参数和仅命名参数，其他命名参数映射到位置参数。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 之前，无论 <code>run_keyword</code> 是否接受两个或三个参数，普通命名参数都映射到位置参数。第三个参数只获取可能的自由命名参数。</p>

    </div>
  </div>

<p>获取关键字名称和参数后，库可以自由地执行关键字，但必须使用与静态库相同的机制与框架进行通信。这意味着使用异常来报告关键字状态，通过写入标准输出或使用提供的日志 API 进行记录，以及在 <code>run_keyword</code> 中使用 return 语句返回某些内容。</p>
<p>每个动态库必须都有 <code>get_keyword_names</code> 和 <code>run_keyword</code> 方法，但动态 API 中的其余方法是可选的。下面的示例显示了一个工作的，尽管微不足道的，动态库。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicExample</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_keyword_names</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;first keyword&#x27;</span>, <span class="string">&#x27;second keyword&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_keyword</span>(<span class="params">self, name, args, kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Running keyword &#x27;%s&#x27; with positional arguments %s and named arguments %s.&quot;</span></span><br><span class="line">              % (name, args, kwargs))</span><br></pre></td></tr></table></figure></div>

<h5 id="获取关键字参数"><a href="#获取关键字参数" class="headerlink" title="获取关键字参数"></a>获取关键字参数</h5><p>如果动态库只实现了 <code>get_keyword_names</code> 和 <code>run_keyword</code> 方法，Robot Framework 就没有关于实现的关键字接受哪些参数的任何信息。例如，在上面的示例中，First Keyword 和 Second Keyword 都可以使用任何参数。这是有问题的，因为大多数真实的关键字都期望有一定数量的关键字，在这种情况下，它们需要自己检查参数计数。</p>
<p>动态库可以通过使用 <code>get_keyword_arguments</code>（别名 <code>getKeywordArguments</code>）方法来通信它们的关键字期望什么参数。此方法获取关键字的名称作为参数，并且必须返回一个字符串列表，包含该关键字接受的参数。</p>
<p>与其他关键字一样，动态关键字可以要求任意数量的位置参数，有默认值，接受可变数量的参数，接受自由命名参数和具有仅命名参数。如何表示所有这些不同变量的语法是从 Python 中它们是如何指定的派生出来的，并在下表中进行了解释。</p>
<h5 id="参数类型及其表示方式"><a href="#参数类型及其表示方式" class="headerlink" title="参数类型及其表示方式"></a>参数类型及其表示方式</h5><table>
<thead>
<tr>
<th>参数类型</th>
<th>如何表示</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>无参数</td>
<td>空列表</td>
<td><code>[]</code></td>
</tr>
<tr>
<td>一个或多个位置参数</td>
<td>包含参数名称的字符串列表</td>
<td><code>[&#39;argument&#39;]</code><br><code>[&#39;arg1&#39;, &#39;arg2&#39;, &#39;arg3&#39;]</code></td>
</tr>
<tr>
<td>默认值</td>
<td>表示参数名称和默认值的两种方式：<br>1. 作为一个字符串，其中名称和默认值用 &#x3D; 分隔。<br>2. 作为一个元组，其中名称和默认值作为单独的项。在 Robot Framework 3.2 中新增。</td>
<td>字符串与 &#x3D; 分隔符：<br><code>[&#39;name=default&#39;]</code><br><code>[&#39;a&#39;, &#39;b=1&#39;, &#39;c=2&#39;]</code><br>元组：<br><code>[(&#39;name&#39;, &#39;default&#39;)]</code><br><code>[&#39;a&#39;, (&#39;b&#39;, 1), (&#39;c&#39;, 2)]</code></td>
</tr>
<tr>
<td>仅位置参数</td>
<td>&#x2F; 标记之前的参数。在 Robot Framework 6.1 中新增。</td>
<td><code>[&#39;posonly&#39;, &#39;/&#39;]</code><br><code>[&#39;p&#39;, &#39;q&#39;, &#39;/&#39;, &#39;normal&#39;]</code></td>
</tr>
<tr>
<td>可变数量的参数（varargs）</td>
<td>可能的位置参数之后的参数有一个 * 前缀</td>
<td><code>[&#39;*varargs&#39;]</code><br><code>[&#39;argument&#39;, &#39;*rest&#39;]</code><br><code>[&#39;a&#39;, &#39;b=42&#39;, &#39;*c&#39;]</code></td>
</tr>
<tr>
<td>仅命名参数</td>
<td>varargs 之后的参数，或者如果没有 varargs，则是一个孤立的 *。有或没有默认值。需要 <code>run_keyword</code> 支持仅命名参数。在 Robot Framework 3.1 中新增。</td>
<td><code>[&#39;*varargs&#39;, &#39;named&#39;]</code><br><code>[&#39;*&#39;, &#39;named&#39;]</code><br><code>[&#39;*&#39;, &#39;x&#39;, &#39;y=default&#39;]</code><br><code>[&#39;a&#39;, &#39;*b&#39;, (&#39;c&#39;, 42)]</code></td>
</tr>
<tr>
<td>自由命名参数（kwargs）</td>
<td>最后的参数有 ** 前缀。需要 <code>run_keyword</code> 支持自由命名参数。</td>
<td><code>[&#39;**named&#39;]</code><br><code>[&#39;a&#39;, (&#39;b&#39;, 42), &#39;**c&#39;]</code><br><code>[&#39;*varargs&#39;, &#39;**kwargs&#39;]</code><br><code>[&#39;*&#39;, &#39;kwo&#39;, &#39;**kws&#39;]</code></td>
</tr>
</tbody></table>
<p>​                        </p>
<h5 id="执行关键字-1"><a href="#执行关键字-1" class="headerlink" title="执行关键字"></a>执行关键字</h5><p>当使用 <code>get_keyword_arguments</code> 时，Robot Framework 会自动计算关键字需要多少个位置参数，以及是否支持自由命名参数。如果一个关键字使用了无效的参数，将会发生错误，甚至不会调用 <code>run_keyword</code>。</p>
<p>返回的实际参数名称和默认值也很重要。它们需要用于支持命名参数，Libdoc 工具需要它们来创建有意义的库文档。</p>
<p>如上表所述，可以通过参数名称以字符串的形式指定默认值，如 ‘name&#x3D;default’，或者以元组的形式，如 (‘name’, ‘default’)。前一种语法的主要问题是所有的默认值都被视为字符串，而后一种语法允许使用所有对象，如 (‘integer’, 1) 或 (‘boolean’, True)。当使用字符串以外的其他对象时，Robot Framework 可以根据它们进行自动参数转换。</p>
<p>出于一致性的原因，也可以将不接受默认值的参数指定为一个元素的元组。例如，[‘a’, ‘b&#x3D;c’, ‘<em>d’] 和 [(‘a’,), (‘b’, ‘c’), (‘</em>d’,)] 是等价的。</p>
<p>如果 <code>get_keyword_arguments</code> 丢失或对某个关键字返回 Python None，那么该关键字将获得一个接受所有参数的参数规范。这个自动参数规范是 [*varargs, **kwargs] 或 [*varargs]，取决于 <code>run_keyword</code> 是否支持自由命名参数。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.2 中新增了将参数指定为元组，如 (‘name’, ‘default’) 的支持。在 Robot Framework 6.1 中新增了动态库 API 对仅位置参数的支持。</p>

    </div>
  </div>



<h5 id="获取关键字参数类型"><a href="#获取关键字参数类型" class="headerlink" title="获取关键字参数类型"></a>获取关键字参数类型</h5><p>Robot Framework 3.1 引入了对自动参数转换的支持，动态库 API 也支持这一点。转换逻辑与静态库完全相同，但指定类型信息的方式自然是不同的。</p>
<p>对于动态库，可以使用可选的 <code>get_keyword_types</code> 方法（别名 <code>getKeywordTypes</code>）返回类型。它可以使用列表或字典返回类型，就像使用 <code>@keyword</code> 装饰器时可以指定类型一样。类型信息可以使用实际类型（如 int）来指定，但特别是如果动态库从外部系统获取此信息，使用字符串（如 ‘int’ 或 ‘integer’）可能更容易。有关支持的类型以及如何指定它们的更多信息，请参见 “支持的转换” 部分。</p>
<p>Robot Framework 也会根据参数默认值进行自动参数转换。此前，这在动态 API 中无法工作，因为只能将参数指定为字符串。如前一节所述，这在 Robot Framework 3.2 中发生了变化，现在像 (‘example’, True) 这样返回的默认值会自动用于此目的。</p>
<p>从 Robot Framework 7.0 开始，动态库还可以通过在返回的类型字典中使用键 ‘return’ 和适当的类型来指定关键字返回类型。这个信息在执行期间不用于任何事情，但是它会被 Libdoc 显示出来，用于文档目的。</p>
<h5 id="获取关键字标签"><a href="#获取关键字标签" class="headerlink" title="获取关键字标签"></a>获取关键字标签</h5><p>动态库可以通过使用 <code>get_keyword_tags</code> 方法（别名 <code>getKeywordTags</code>）报告关键字标签。它获取一个关键字名称作为参数，并应返回相应的标签作为字符串列表。</p>
<p>另外，也可以在由下面讨论的 <code>get_keyword_documentation</code> 方法返回的文档的最后一行上指定标签。这需要在最后一行开始时使用 Tags: 并在其后列出标签，如 Tags: first tag, second, third。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p><code>get_keyword_tags</code> 方法保证在 <code>get_keyword_documentation</code> 方法之前被调用。这使得只有在 <code>get_keyword_tags</code> 方法未被调用时，才能轻松地将标签嵌入到文档中。</p>

    </div>
  </div>

<h5 id="获取关键字文档"><a href="#获取关键字文档" class="headerlink" title="获取关键字文档"></a>获取关键字文档</h5><p>如果动态库想要提供关键字文档，它们可以实现 <code>get_keyword_documentation</code> 方法（别名 <code>getKeywordDocumentation</code>）。它接受一个关键字名称作为参数，并且，如方法名称所示，返回其文档作为字符串。</p>
<p>返回的文档与静态库中的关键字文档字符串的使用方式相同。主要的用例是将关键字的文档获取到由 Libdoc 生成的库文档中。此外，文档的第一行（直到第一个 \n）显示在测试日志中。</p>
<h5 id="获取通用库文档"><a href="#获取通用库文档" class="headerlink" title="获取通用库文档"></a>获取通用库文档</h5><p><code>get_keyword_documentation</code> 方法也可以用于指定整体库文档。这个文档在测试执行时不使用，但它可以使由 Libdoc 生成的文档更好。</p>
<p>动态库可以提供通用库文档和与使用库相关的文档。前者是通过调用 <code>get_keyword_documentation</code> 与特殊值 <code>__intro__</code> 获得的，后者是使用值 <code>__init__</code> 获得的。如何呈现文档最好在实践中使用 Libdoc 进行测试。</p>
<p>动态库还可以直接在代码中指定通用库文档，作为库类和其 <code>__init__</code> 方法的 docstring。如果直接从代码和 <code>get_keyword_documentation</code> 方法中获取了非空文档，后者优先。</p>
<h5 id="获取关键字源信息"><a href="#获取关键字源信息" class="headerlink" title="获取关键字源信息"></a>获取关键字源信息</h5><p>动态 API 遮蔽了 Robot Framework 的关键字的实际实现，因此无法看到关键字是在哪里实现的。这意味着编辑器和其他使用 Robot Framework API 的工具无法实现如 go-to-definition 等功能。这个问题可以通过实现另一个可选的动态方法 <code>get_keyword_source</code>（别名 <code>getKeywordSource</code>）来解决，该方法返回源信息。</p>
<p><code>get_keyword_source</code> 方法的返回值必须是一个字符串，或者如果没有源信息可用，则为 None。在简单的情况下，只需简单地返回实现关键字的文件的绝对路径即可。如果知道关键字实现开始的行号，可以将其嵌入到返回值中，如 <code>path:lineno</code>。只返回行号也是可能的，如 <code>:lineno</code>。</p>
<p>库本身的源信息是从导入的库类中自动获取的，与其他库 API 的方式相同。库源路径用于所有没有定义自己的源路径的关键字。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>为关键字返回源信息是 Robot Framework 3.2 中的新功能。</p>

    </div>
  </div>

<h5 id="动态库中的命名参数语法"><a href="#动态库中的命名参数语法" class="headerlink" title="动态库中的命名参数语法"></a>动态库中的命名参数语法</h5><p>动态库 API 也支持命名参数语法。使用语法是基于从库使用 <code>get_keyword_arguments</code> 方法获取的参数名称和默认值。</p>
<p>如果 <code>run_keyword</code> 方法接受三个参数，第二个参数获取所有位置参数作为列表，最后一个参数获取所有命名参数作为映射。如果它只接受两个参数，命名参数被映射到位置参数。在后一种情况下，如果一个关键字有多个带有默认值的参数，并且只给出了后面的一些参数，那么框架会根据 <code>get_keyword_arguments</code> 方法返回的默认值填充跳过的可选参数。</p>
<p>以下示例说明了如何使用动态库中的命名参数语法。所有示例都使用一个关键字 Dynamic，它有一个参数规范 [a, b&#x3D;d1, c&#x3D;d2]。每行的注释显示了在这些情况下如何调用 <code>run_keyword</code>，如果它有两个参数（即签名是 <code>name, args</code>）以及如果它有三个参数（即 <code>name, args, kwargs</code>）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** 测试用例 ***                  # args          # args, kwargs</span><br><span class="line">仅位置参数</span><br><span class="line">    Dynamic    x                    # [x]           # [x], &#123;&#125;</span><br><span class="line">    Dynamic    x      y             # [x, y]        # [x, y], &#123;&#125;</span><br><span class="line">    Dynamic    x      y      z      # [x, y, z]     # [x, y, z], &#123;&#125;</span><br><span class="line"></span><br><span class="line">仅命名参数</span><br><span class="line">    Dynamic    a=x                  # [x]           # [], &#123;a: x&#125;</span><br><span class="line">    Dynamic    c=z    a=x    b=y    # [x, y, z]     # [], &#123;a: x, b: y, c: z&#125;</span><br><span class="line"></span><br><span class="line">位置和命名参数</span><br><span class="line">    Dynamic    x      b=y           # [x, y]        # [x], &#123;b: y&#125;</span><br><span class="line">    Dynamic    x      y      c=z    # [x, y, z]     # [x, y], &#123;c: z&#125;</span><br><span class="line">    Dynamic    x      b=y    c=z    # [x, y, z]     # [x], &#123;y: b, c: z&#125;</span><br><span class="line"></span><br><span class="line">中间缺失</span><br><span class="line">    Dynamic    x      c=z           # [x, d1, z]    # [x], &#123;c: z&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 之前，所有正常的命名参数都被映射到位置参数，可选的 <code>kwargs</code> 只用于自由命名参数。在上述示例中，<code>run_keyword</code> 始终像现在如果不支持 <code>kwargs</code> 那样被调用。</p>

    </div>
  </div>

<h5 id="动态库中的自由命名参数"><a href="#动态库中的自由命名参数" class="headerlink" title="动态库中的自由命名参数"></a>动态库中的自由命名参数</h5><p>动态库也可以支持自由命名参数（**named）。这种支持的强制前提条件是 <code>run_keyword</code> 方法接受三个参数：第三个参数将获取自由命名参数以及可能的其他命名参数。这些参数作为映射传递给关键字。</p>
<p>关键字接受哪些参数取决于 <code>get_keyword_arguments</code> 为它返回什么。如果最后一个参数以 ** 开头，那么该关键字被认为接受自由命名参数。</p>
<p>以下示例说明了如何使用动态库中的自由命名参数语法。所有示例都使用一个关键字 Dynamic，它的参数规范是 [a&#x3D;d1, b&#x3D;d2, **named]。注释显示了实际调用 <code>run_keyword</code> 方法的参数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** 测试用例 ***                  # args, kwargs</span><br><span class="line">无参数</span><br><span class="line">    Dynamic                         # [], &#123;&#125;</span><br><span class="line"></span><br><span class="line">仅位置参数</span><br><span class="line">    Dynamic    x                    # [x], &#123;&#125;</span><br><span class="line">    Dynamic    x      y             # [x, y], &#123;&#125;</span><br><span class="line"></span><br><span class="line">仅自由命名参数</span><br><span class="line">    Dynamic    x=1                  # [], &#123;x: 1&#125;</span><br><span class="line">    Dynamic    x=1    y=2    z=3    # [], &#123;x: 1, y: 2, z: 3&#125;</span><br><span class="line"></span><br><span class="line">位置和自由命名参数</span><br><span class="line">    Dynamic    x      y=2           # [x], &#123;y: 2&#125;</span><br><span class="line">    Dynamic    x      y=2    z=3    # [x], &#123;y: 2, z: 3&#125;</span><br><span class="line"></span><br><span class="line">位置作为命名和自由命名参数</span><br><span class="line">    Dynamic    a=1    x=1           # [], &#123;a: 1, x: 1&#125;</span><br><span class="line">    Dynamic    b=2    x=1    a=1    # [], &#123;a: 1, b: 2, x: 1&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 之前，所有正常的命名参数都被映射到位置参数，但现在它们是 kwargs 的一部分，与自由命名参数一起。</p>

    </div>
  </div>

<h5 id="动态库中的仅命名参数"><a href="#动态库中的仅命名参数" class="headerlink" title="动态库中的仅命名参数"></a>动态库中的仅命名参数</h5><p>从 Robot Framework 3.1 开始，动态库可以有仅命名参数。这需要 <code>run_keyword</code> 方法接受三个参数：第三个参数获取仅命名参数以及其他命名参数。</p>
<p>在 <code>get_keyword_arguments</code> 方法返回的参数规范中，仅命名参数在可能的可变数量的参数（<em>varargs）之后指定，或者如果关键字不接受 varargs，则在一个孤立的星号（</em>）之后指定。仅命名参数可以有默认值，有默认值和没有默认值的参数的顺序无关紧要。</p>
<p>以下示例说明了如何使用动态库中的仅命名参数语法。所有示例都使用一个关键字 Dynamic，它被指定为具有参数规范 [positional&#x3D;default, *varargs, named, named2&#x3D;default, **free]。注释显示了实际调用 <code>run_keyword</code> 方法的参数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** 测试用例 ***                                  # args, kwargs</span><br><span class="line">仅命名参数</span><br><span class="line">    Dynamic    named=value                          # [], &#123;named: value&#125;</span><br><span class="line">    Dynamic    named=value    named2=2              # [], &#123;named: value, named2: 2&#125;</span><br><span class="line"></span><br><span class="line">命名参数与位置和 varargs</span><br><span class="line">    Dynamic    argument       named=xxx             # [argument], &#123;named: xxx&#125;</span><br><span class="line">    Dynamic    a1             a2         named=3    # [a1, a2], &#123;named: 3&#125;</span><br><span class="line"></span><br><span class="line">位置作为命名的命名参数</span><br><span class="line">    Dynamic    named=foo      positional=bar        # [], &#123;positional: bar, named: foo&#125;</span><br><span class="line"></span><br><span class="line">命名参数与自由命名参数</span><br><span class="line">    Dynamic    named=value    foo=bar               # [], &#123;named: value, foo: bar&#125;</span><br><span class="line">    Dynamic    named2=2       third=3    named=1    # [], &#123;named: 1, named2: 2, third: 3&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>下表列出了动态 API 中的所有特殊方法。方法名称以下划线格式列出，但它们的驼峰别名的工作方式完全相同。</p>
<p>动态 API 中的所有特殊方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>参数</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td><code>get_keyword_names</code></td>
<td>无</td>
<td>返回实现的关键字的名称。</td>
</tr>
<tr>
<td><code>run_keyword</code></td>
<td><code>name, arguments, kwargs</code></td>
<td>使用给定的参数执行指定的关键字。<code>kwargs</code> 是可选的。</td>
</tr>
<tr>
<td><code>get_keyword_arguments</code></td>
<td><code>name</code></td>
<td>返回关键字的参数规范。可选方法。</td>
</tr>
<tr>
<td><code>get_keyword_types</code></td>
<td><code>name</code></td>
<td>返回关键字的参数类型信息。可选方法。在 RF 3.1 中新增。</td>
</tr>
<tr>
<td><code>get_keyword_tags</code></td>
<td><code>name</code></td>
<td>返回关键字的标签。可选方法。</td>
</tr>
<tr>
<td><code>get_keyword_documentation</code></td>
<td><code>name</code></td>
<td>返回关键字和库的文档。可选方法。</td>
</tr>
<tr>
<td><code>get_keyword_source</code></td>
<td><code>name</code></td>
<td>返回关键字的源。可选方法。在 RF 3.2 中新增。</td>
</tr>
</tbody></table>
<p>使用动态 API 的一个好例子是 Robot Framework 自己的 Remote 库。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>从 Robot Framework 7.0 开始，动态库可以有它们的特殊方法的异步实现。</p>

    </div>
  </div>              

<h4 id="混合库-API"><a href="#混合库-API" class="headerlink" title="混合库 API"></a>混合库 API</h4><p>混合库 API，顾名思义，是静态 API 和动态 API 的混合。就像动态 API 一样，只使用混合 API 也可以实现一个库。</p>
<h5 id="获取关键字名称-1"><a href="#获取关键字名称-1" class="headerlink" title="获取关键字名称"></a>获取关键字名称</h5><p>获取关键字名称的方式与动态 API 完全相同。实际上，库需要有 <code>get_keyword_names</code> 或 <code>getKeywordNames</code> 方法，返回库实现的关键字名称的列表。</p>
<h5 id="运行关键字"><a href="#运行关键字" class="headerlink" title="运行关键字"></a>运行关键字</h5><p>在混合 API 中，没有 <code>run_keyword</code> 方法用于执行关键字。相反，Robot Framework 使用反射来查找实现关键字的方法，这与静态 API 类似。使用混合 API 的库可以直接实现这些方法，更重要的是，它可以动态地处理它们。</p>
<p>在 Python 中，使用 <code>__getattr__</code> 方法动态处理缺失的方法很容易。这个特殊方法可能对大多数 Python 程序员来说都很熟悉，他们可以立即理解以下示例。其他人可能会发现先查阅 Python 参考手册更容易。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> somewhere <span class="keyword">import</span> external_keyword</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HybridExample</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_keyword_names</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;my_keyword&#x27;</span>, <span class="string">&#x27;external_keyword&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_keyword</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My Keyword called with &#x27;%s&#x27;&quot;</span> % arg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;external_keyword&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> external_keyword</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Non-existing attribute &#x27;%s&#x27;&quot;</span> % name)</span><br></pre></td></tr></table></figure></div>

<p>注意，<code>__getattr__</code> 不像动态 API 中的 <code>run_keyword</code> 那样执行实际的关键字。相反，它只返回一个可调用的对象，然后由 Robot Framework 执行。</p>
<p>另一个需要注意的点是，Robot Framework 使用从 <code>get_keyword_names</code> 返回的相同名称来查找实现它们的方法。因此，类本身实现的方法的名称必须以与它们定义的相同的格式返回。例如，如果 <code>get_keyword_names</code> 返回 My Keyword 而不是 my_keyword，那么上面的库将无法正确工作。</p>
<h5 id="获取关键字参数和文档"><a href="#获取关键字参数和文档" class="headerlink" title="获取关键字参数和文档"></a>获取关键字参数和文档</h5><p>当使用此 API 时，Robot Framework 使用反射来查找实现关键字的方法，这与静态 API 类似。获取到方法的引用后，它会以与使用静态 API 相同的方式从中搜索参数和文档。因此，没有必要像动态 API 那样有获取参数和文档的特殊方法。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>在实现测试库时，混合 API 具有与实际动态 API 相同的动态能力。它的一个很大的好处是，不需要有获取关键字参数和文档的特殊方法。通常，只有真正的动态关键字需要在 <code>__getattr__</code> 中处理，其他的可以直接在主库类中实现。</p>
<p>由于明显的优势和相等的能力，混合 API 在大多数情况下都是比动态 API 更好的选择。一个值得注意的例外是将库实现为代理实际库实现的地方，因为那时实际的关键字必须在其他地方执行，代理只能向前传递关键字名称和参数。</p>
<p>使用混合 API 的一个好例子是 Robot Framework 自己的 Telnet 库。</p>
<h4 id="使用-Robot-Framework-的内部模块"><a href="#使用-Robot-Framework-的内部模块" class="headerlink" title="使用 Robot Framework 的内部模块"></a>使用 Robot Framework 的内部模块</h4><p>测试库可以使用 Robot Framework 的内部模块，例如，获取有关执行的测试和使用的设置的信息。然而，应谨慎使用这种与框架通信的强大机制，因为并非所有的 Robot Framework 的 API 都是为外部使用而设计的，它们可能会在不同的框架版本之间发生根本性的变化。</p>
<h5 id="可用的-API"><a href="#可用的-API" class="headerlink" title="可用的 API"></a>可用的 API</h5><p>API 文档在优秀的 Read the Docs 服务上单独托管。如果不确定如何使用某个 API 或者它是否具有向前兼容性，请向邮件列表发送问题。</p>
<h5 id="使用-BuiltIn-库"><a href="#使用-BuiltIn-库" class="headerlink" title="使用 BuiltIn 库"></a>使用 BuiltIn 库</h5><p>最安全的 API 是在 BuiltIn 库中实现关键字的方法。关键字的更改很少，它们总是首先弃用旧的用法。最有用的方法之一是 <code>replace_variables</code>，它允许访问当前可用的变量。下面的示例演示了如何获取 ${OUTPUT_DIR}，这是许多方便的自动变量之一。也可以使用 <code>set_test_variable</code>，<code>set_suite_variable</code> 和 <code>set_global_variable</code> 从库中设置新的变量。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">from</span> robot.libraries.BuiltIn <span class="keyword">import</span> BuiltIn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">argument</span>):</span><br><span class="line">    builtin = BuiltIn()</span><br><span class="line">    output = do_something_that_creates_a_lot_of_output(argument)</span><br><span class="line">    <span class="keyword">if</span> builtin.robot_running:</span><br><span class="line">        output_dir = builtin.replace_variables(<span class="string">&#x27;$&#123;OUTPUT_DIR&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output_dir = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(output_dir, <span class="string">&#x27;output.txt&#x27;</span>), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(output)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;*HTML* Output written to &lt;a href=&quot;output.txt&quot;&gt;output.txt&lt;/a&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>如上例所示，BuiltIn 还有一个方便的 <code>robot_running</code> 属性，用于检测 Robot Framework 是否正在运行。</p>
<p>使用 BuiltIn 的方法的唯一问题是，所有 <code>run_keyword</code> 方法的变体都必须特别处理。使用 <code>run_keyword</code> 方法的方法必须使用 BuiltIn 模块中的 <code>register_run_keyword</code> 方法将自己注册为运行关键字。这个方法的文档解释了为什么需要这样做，显然也解释了如何做。</p>
<h4 id="扩展现有的测试库"><a href="#扩展现有的测试库" class="headerlink" title="扩展现有的测试库"></a>扩展现有的测试库</h4><p>本节解释了如何向现有测试库添加新功能以及如何在自己的库中使用它们的不同方法。</p>
<h5 id="修改原始源代码"><a href="#修改原始源代码" class="headerlink" title="修改原始源代码"></a>修改原始源代码</h5><p>如果可以访问想要扩展的库的源代码，可以直接修改源代码。这种方法的最大问题是，可能很难更新原始库而不影响更改。对于用户来说，使用具有与原始库不同功能的库可能也会令人困惑。重新打包库也可能是一个大的额外任务。</p>
<p>如果增强功能是通用的，并且计划将它们提交给原始开发人员，那么这种方法将非常有效。如果的更改被应用到原始库，它们将被包含在未来的版本中，并且上述所有问题都将得到缓解。如果更改是非通用的，或者由于某种原因无法提交它们，那么可能在接下来的部分中解释的方法会更好。</p>
<h5 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h5><p>扩展现有库的另一种直接方法是使用继承。下面的示例说明了如何向 SeleniumLibrary 添加新的 Title Should Start With 关键字。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> SeleniumLibrary <span class="keyword">import</span> SeleniumLibrary</span><br><span class="line"><span class="keyword">from</span> SeleniumLibrary.base <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendedSeleniumLibrary</span>(<span class="title class_ inherited__">SeleniumLibrary</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @keyword</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">title_should_start_with</span>(<span class="params">self, expected</span>):</span><br><span class="line">        title = self.get_title()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> title.startswith(expected):</span><br><span class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">&quot;Title &#x27;%s&#x27; did not start with &#x27;%s&#x27;&quot;</span></span><br><span class="line">                                 % (title, expected))</span><br></pre></td></tr></table></figure></div>

<p>与修改原始库相比，这种方法的一个大的区别是新库的名称与原始库不同。一个好处是可以轻松地告诉正在使用一个自定义库，但一个大问题是不能轻易地使用原始库和新库。首先，新库将具有与原始库相同的关键字，这意味着总是存在冲突。另一个问题是库不共享它们的状态。</p>
<p>当开始使用一个新库并希望从一开始就向它添加自定义增强时，这种方法效果很好。否则，本节中解释的其他机制可能会更好。</p>
<h5 id="直接使用其他库"><a href="#直接使用其他库" class="headerlink" title="直接使用其他库"></a>直接使用其他库</h5><p>因为测试库在技术上只是类或模块，所以使用另一个库的简单方法是导入它并使用它的方法。当方法是静态的并且不依赖于库状态时，这种方法非常有效。这由早期使用 Robot Framework 的 BuiltIn 库的示例所说明。</p>
<p>然而，如果库有状态，事情可能不会按照希望的方式工作。在库中使用的库实例与框架使用的不是同一个，因此执行的关键字所做的更改对库不可见。下一节将解释如何获取对框架使用的同一库实例的访问权限。</p>
<h4 id="从-Robot-Framework-获取活动库实例"><a href="#从-Robot-Framework-获取活动库实例" class="headerlink" title="从 Robot Framework 获取活动库实例"></a>从 Robot Framework 获取活动库实例</h4><p>可以使用 BuiltIn 关键字 <code>Get Library Instance</code> 从框架本身获取当前活动的库实例。此关键字返回的库实例与框架本身使用的相同，因此看到正确的库状态没有问题。尽管这个功能作为关键字可用，但通常在测试库中直接通过导入 BuiltIn 库类来使用。下面的示例说明了如何实现与早期关于使用继承的示例中相同的 <code>Title Should Start With</code> 关键字。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.libraries.BuiltIn <span class="keyword">import</span> BuiltIn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">title_should_start_with</span>(<span class="params">expected</span>):</span><br><span class="line">    seleniumlib = BuiltIn().get_library_instance(<span class="string">&#x27;SeleniumLibrary&#x27;</span>)</span><br><span class="line">    title = seleniumlib.get_title()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> title.startswith(expected):</span><br><span class="line">        <span class="keyword">raise</span> AssertionError(<span class="string">&quot;Title &#x27;%s&#x27; did not start with &#x27;%s&#x27;&quot;</span></span><br><span class="line">                             % (title, expected))</span><br></pre></td></tr></table></figure></div>

<p>当库有状态时，这种方法显然比直接导入库并使用它更好。相对于继承，最大的好处是可以正常使用原始库，并在需要时使用新库。这在下面的示例中得到了证明，其中预期在新库 SeLibExtensions 中可以使用前面示例中的代码。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    SeleniumLibrary</span><br><span class="line">Library    SeLibExtensions</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Open Browser    http://example      # SeleniumLibrary</span><br><span class="line">    Title Should Start With    Example  # SeLibExtensions</span><br></pre></td></tr></table></figure></div>

<h4 id="使用动态或混合-API-的库"><a href="#使用动态或混合-API-的库" class="headerlink" title="使用动态或混合 API 的库"></a>使用动态或混合 API 的库</h4><p>使用动态或混合库 API 的测试库通常有自己的系统来扩展它们。对于这些库，需要向库开发人员询问指导，或者查阅库文档或源代码。</p>
<h3 id="远程库接口"><a href="#远程库接口" class="headerlink" title="远程库接口"></a>远程库接口</h3><p>远程库接口提供了在 Robot Framework 运行的机器上有测试库的方法，也为使用原生支持的 Python 以外的其他语言实现库提供了方法。对于测试库，用户远程库看起来几乎与任何其他测试库一样，使用远程库接口开发测试库也非常接近创建普通测试库。</p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>使用远程库 API 的两个主要原因：</p>
<ul>
<li>可以在 Robot Framework 运行的机器上有实际的库。这为分布式测试提供了有趣的可能性。</li>
<li>测试库可以使用支持 XML-RPC 协议的任何语言来实现。存在为各种语言（如 Python、Java、Ruby、.NET 等）准备的通用远程服务器。</li>
</ul>
<p>远程库接口由 Remote 库提供，这是标准库之一。这个库本身没有任何关键字，但它作为核心框架和其他地方实现的关键字之间的代理。Remote 库通过远程服务器与实际库实现进行交互，Remote 库和服务器使用 XML-RPC 通道上的简单远程协议进行通信。所有这些的高级架构在下面的图片中进行了说明：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/be820dc8-4cc1-4691-1a32-66549a58b400/public"
                      width = "600"
                >


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>远程客户端使用 Python 的标准 XML-RPC 模块。它不支持一些 XML-RPC 服务器实现的自定义 XML-RPC 扩展。</p>

    </div>
  </div>



<h4 id="使用-Remote-库"><a href="#使用-Remote-库" class="headerlink" title="使用 Remote 库"></a>使用 Remote 库</h4><h5 id="导入-Remote-库"><a href="#导入-Remote-库" class="headerlink" title="导入 Remote 库"></a>导入 Remote 库</h5><p>Remote 库需要知道远程服务器的地址，但是导入它和使用它提供的关键字与使用其他库没有什么不同。如果需要在一个套件中多次使用 Remote 库，或者只是想给它一个更具描述性的名称，可以在导入时给它一个别名。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** 设置 ***</span><br><span class="line">库    Remote    http://127.0.0.1:8270       AS    Example1</span><br><span class="line">库    Remote    http://example.com:8080/    AS    Example2</span><br><span class="line">库    Remote    http://10.0.0.2/example    1 minute    AS    Example3</span><br></pre></td></tr></table></figure></div>

<p>上面的第一个示例使用的 URL 也是 Remote 库在没有给定地址时使用的默认地址。</p>
<p>上面的最后一个示例显示了如何给 Remote 库提供一个自定义超时作为可选的第二个参数。当最初连接到服务器时以及如果连接意外关闭时，将使用超时。超时可以以 Robot Framework 时间格式给出，如 60s 或 2 分钟 10 秒。默认超时通常是几分钟，但它取决于操作系统及其配置。注意，如果设置的超时比关键字执行时间短，将中断关键字。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li>端口 8270 是远程服务器预期使用的默认端口，已由 IANA 为此目的注册。选择这个端口号是因为 82 和 70 分别是字母 R 和 F 的 ASCII 码。</li>
<li>当连接到本地机器时，建议使用 IP 地址 127.0.0.1 而不是机器名 localhost。这样可以避免地址解析，至少在 Windows 上可能非常慢。</li>
<li>如果 URI 在服务器地址后没有路径，Remote 库使用的 XML-RPC 模块将默认使用 &#x2F;RPC2 路径。实际上，使用 <a class="link"   target="_blank" rel="noopener" href="http://127.0.0.1:8270/" >http://127.0.0.1:8270 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 与使用 <a class="link"   target="_blank" rel="noopener" href="http://127.0.0.1:8270/RPC2" >http://127.0.0.1:8270/RPC2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是相同的。这可能会或可能不会成为问题，具体取决于远程服务器。如果地址有路径，即使路径只是 &#x2F;，也不会添加额外的路径。例如，<a class="link"   target="_blank" rel="noopener" href="http://127.0.0.1:8270/" >http://127.0.0.1:8270/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   target="_blank" rel="noopener" href="http://127.0.0.1:8270/my/path" >http://127.0.0.1:8270/my/path <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 都不会被修改。</li>
</ul>

    </div>
  </div>

<h5 id="启动和停止远程服务器"><a href="#启动和停止远程服务器" class="headerlink" title="启动和停止远程服务器"></a>启动和停止远程服务器</h5><p>在可以导入 Remote 库之前，必须启动提供实际关键字的远程服务器。如果在启动测试执行之前启动了服务器，那么可以像上面的示例那样使用正常的库设置。或者，其他关键字，例如来自 Process 或 SSH 库的关键字，可以启动服务器，但是可能需要使用 Import Library 关键字，因为当测试执行开始时，库不可用。</p>
<p>如何停止远程服务器取决于它是如何实现的。通常，服务器支持以下方法：</p>
<ul>
<li>无论使用哪个库，远程服务器都应提供 Stop Remote Server 关键字，以便执行的测试可以轻松使用。</li>
<li>远程服务器应在其 XML-RPC 接口中有 stop_remote_server 方法。</li>
<li>在运行服务器的控制台上按 Ctrl-C 应该可以停止服务器。</li>
<li>可以使用操作系统提供的工具终止服务器进程（例如 kill）。</li>
</ul>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>服务器可能被配置为用户不能使用 Stop Remote Server 关键字或 stop_remote_server 方法来停止它。</p>

    </div>
  </div>

<h4 id="支持的参数和返回值类型"><a href="#支持的参数和返回值类型" class="headerlink" title="支持的参数和返回值类型"></a>支持的参数和返回值类型</h4><p>由于 XML-RPC 协议不支持所有可能的对象类型，因此必须将 Remote 库和远程服务器之间传输的值转换为兼容的类型。这适用于 Remote 库传递给远程服务器的关键字参数以及服务器返回给 Remote 库的返回值。</p>
<p>Remote 库和 Python 远程服务器都按照以下规则处理 Python 值。其他远程服务器应该有类似的行为。</p>
<ul>
<li>字符串、数字和布尔值在传递时不做修改。</li>
<li>Python 的 None 被转换为一个空字符串。</li>
<li>所有列表、元组和其他可迭代对象（除字符串和字典外）都作为列表传递，以便递归地转换它们的内容。</li>
<li>字典和其他映射作为字典传递，以便将它们的键转换为字符串，递归地将值转换为支持的类型。</li>
<li>返回的字典被转换为所谓的点可访问字典，允许使用扩展变量语法像 {result.key} 这样访问键作为属性。这也适用于嵌套字典，如result.key这样访问键作为属性。这也适用于嵌套字典，如{root.child.leaf}。</li>
<li>包含不能在 XML 中表示的 ASCII 范围内的字节的字符串被发送为 Binary 对象，该对象在内部使用 XML-RPC base64 数据类型。接收到的 Binary 对象自动转换为字节字符串。</li>
<li>其他类型被转换为字符串。</li>
</ul>
<h4 id="远程协议"><a href="#远程协议" class="headerlink" title="远程协议"></a>远程协议</h4><p>本节解释了 Remote 库和远程服务器之间使用的协议。这些信息主要针对希望创建新的远程服务器的人。</p>
<p>远程协议是在 XML-RPC 之上实现的，XML-RPC 是一种使用 XML 在 HTTP 上的简单远程过程调用协议。大多数主流语言（Python、Java、C、Ruby、Perl、Javascript、PHP等）都内置或作为扩展支持 XML-RPC。</p>
<p>Python 远程服务器可以作为参考实现。</p>
<h5 id="必需的方法"><a href="#必需的方法" class="headerlink" title="必需的方法"></a>必需的方法</h5><p>远程服务器提供关于它们包含的关键字的信息有两种可能性。下面简要解释了这些方法，并在后续部分中进行了更详细的文档记录。</p>
<ul>
<li>远程服务器可以实现动态库 API 具有的相同方法。这意味着 <code>get_keyword_names</code> 方法和可选的 <code>get_keyword_arguments</code>、<code>get_keyword_types</code>、<code>get_keyword_tags</code> 和 <code>get_keyword_documentation</code> 方法。注意，像 <code>getKeywordNames</code> 这样使用 “驼峰命名” 是不可能的，就像在正常的动态 API 中一样。</li>
<li>从 Robot Framework 4.0 开始，远程服务器可以有一个 <code>get_library_information</code> 方法，该方法返回一个字典，其中包含所有库和关键字信息。如果远程服务器有这个方法，那么像 <code>get_keyword_names</code> 这样的其他 getter 方法将根本不会被使用。这种方法的好处是只需要一个 XML-RPC 调用就可以获取信息，而上面解释的方法需要每个关键字进行几次调用。对于更大的库，差异可能很大。</li>
<li>无论远程服务器如何提供关于它们的关键字的信息，它们都必须有 <code>run_keyword</code> 方法，当执行关键字时使用。实际关键字如何实现对 Remote 库来说并不重要。远程服务器可以像可用的通用远程服务器那样作为真实测试库的包装器，也可以自己实现关键字。</li>
</ul>
<p>远程服务器还应在其公共接口中有 <code>stop_remote_server</code> 方法以方便停止它们。他们还应该自动将此方法作为 Stop Remote Server 关键字暴露出来，以允许在测试数据中使用它，无论测试库是什么。允许用户停止服务器并不总是可取的，服务器可能支持以某种方式禁用此功能。该方法，以及暴露的关键字，应该根据是否允许停止返回 True 或 False。这使得外部工具可以知道是否成功停止了服务器。</p>
<h5 id="使用-get-keyword-names-和特定于关键字的-getter"><a href="#使用-get-keyword-names-和特定于关键字的-getter" class="headerlink" title="使用 get_keyword_names 和特定于关键字的 getter"></a>使用 get_keyword_names 和特定于关键字的 getter</h5><p>本节解释了当服务器实现 <code>get_keyword_names</code> 时，Remote 库如何获取关键字名称和其他信息。下一节将介绍使用较新的 <code>get_library_info</code> 方法。</p>
<p><code>get_keyword_names</code> 方法必须返回服务器包含的关键字的名称，作为字符串列表。远程服务器也可以（并且应该）实现 <code>get_keyword_arguments</code>、<code>get_keyword_types</code>、<code>get_keyword_tags</code> 和 <code>get_keyword_documentation</code> 方法，以提供有关关键字的更多信息。所有这些方法都以关键字的名称作为参数，它们必须返回的内容在下表中进行了解释。</p>
<p>关键字特定的 getter 方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>get_keyword_arguments</code></td>
<td>以与动态库相同的格式返回字符串列表形式的参数。</td>
</tr>
<tr>
<td><code>get_keyword_types</code></td>
<td>类型信息，以字符串列表或字典形式返回。详情请参见下文。</td>
</tr>
<tr>
<td><code>get_keyword_documentation</code></td>
<td>文档，以字符串形式返回。</td>
</tr>
<tr>
<td><code>get_keyword_tags</code></td>
<td>标签，以字符串列表形式返回。</td>
</tr>
</tbody></table>
<p>用于参数转换的类型信息可以以列表形式返回，基于位置将类型名称映射到参数，也可以直接以字典形式返回，将参数名称映射到类型名称。实际上，这与使用普通库中的 <code>@keyword</code> 装饰器指定类型的方式相同。区别在于，因为 XML-RPC 协议不支持任意值，所以需要使用类型名称或别名（如 ‘int’ 或 ‘integer’）来指定类型信息，而不是使用实际类型（如 int）。此外，XML-RPC 服务器可能不允许 None 或 null 值，但可以使用空字符串来表示某个参数没有类型信息。</p>
<p>也支持基于默认值的参数转换，使用与普通库相同的逻辑。为了使这个工作，具有默认值的参数必须以元组的形式返回，而不是字符串，就像动态库一样。例如，如果参数信息返回的是 [(‘count’, 1), (‘caseless’, True)]，那么参数转换就会起作用，但如果是 [‘count&#x3D;1’, ‘caseless&#x3D;True’]，则不会起作用。</p>
<p>远程服务器还可以提供通用库文档，用于使用 Libdoc 工具生成文档。通过调用 <code>get_keyword_documentation</code> 并使用特殊值 <code>__intro__</code> 和 <code>__init__</code> 来获取这些信息。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>get_keyword_types</code> 是在 Robot Framework 3.1 中新增的，基于默认值的参数转换支持是在 Robot Framework 4.0 中新增的。</p>

    </div>
  </div>

<h5 id="使用-get-library-information"><a href="#使用-get-library-information" class="headerlink" title="使用 get_library_information"></a>使用 get_library_information</h5><p><code>get_library_information</code> 方法允许在一个 XML-RPC 调用中返回整个库的信息。信息必须以字典的形式返回，其中键是关键字名称，值是包含关键字信息的嵌套字典。字典也可以包含用于通用库信息的单独条目。</p>
<p>关键字信息字典可以包含关键字参数、文档、标签和类型，相应的键是 <code>args</code>、<code>doc</code>、<code>tags</code> 和 <code>types</code>。信息必须使用与前一节中讨论的 <code>get_keyword_arguments</code>、<code>get_keyword_documentation</code>、<code>get_keyword_tags</code> 和 <code>get_keyword_types</code> 相同的语义提供。如果某些信息不可用，可以从 info 字典中完全省略。</p>
<p><code>get_library_information</code> 还支持返回用于 Libdoc 的通用库文档。这是通过在返回的库信息字典中包含特殊的 <code>__intro__</code> 和 <code>__init__</code> 条目来完成的。</p>
<p>例如，一个 Python 库如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;库文档。&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"><span class="meta">@keyword(<span class="params">tags=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">a: <span class="built_in">int</span>, b=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;关键字文档。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">another</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>可以映射到这种类型的库信息字典：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;__intro__&#x27;</span>: &#123;<span class="string">&#x27;doc&#x27;</span>: <span class="string">&#x27;库文档&#x27;</span>&#125;</span><br><span class="line">    <span class="string">&#x27;example&#x27;</span>: &#123;<span class="string">&#x27;args&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b=True&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;types&#x27;</span>: [<span class="string">&#x27;int&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;doc&#x27;</span>: <span class="string">&#x27;关键字文档。&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;tags&#x27;</span>: [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]&#125;</span><br><span class="line">    <span class="string">&#x27;another: &#123;&#x27;</span>args<span class="string">&#x27;: []&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>get_library_information</code> 是在 Robot Framework 4.0 中新增的。</p>

    </div>
  </div>

<p>​     </p>
<h5 id="执行远程关键字"><a href="#执行远程关键字" class="headerlink" title="执行远程关键字"></a>执行远程关键字</h5><p>当 Remote 库希望服务器执行某个关键字时，它会调用远程服务器的 <code>run_keyword</code> 方法，并传递关键字名称、参数列表，以及可能的自由命名参数字典。基本类型可以直接作为参数使用，但更复杂的类型需要转换为支持的类型。</p>
<p>服务器必须在结果字典（或映射，取决于术语）中返回执行的结果，该字典包含以下表格中解释的项目。注意，只有状态条目是必需的，如果其他条目不适用，可以省略。</p>
<p>远程结果字典中的条目</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>必需的执行状态。可以是 PASS 或 FAIL。</td>
</tr>
<tr>
<td><code>output</code></td>
<td>可能写入日志文件的输出。必须以单个字符串给出，但可以包含多个消息和不同的日志级别，格式为 <em>INFO</em> First message\n<em>HTML</em> <b>2nd</b>\n<em>WARN</em> Another message。也可以将时间戳嵌入到日志消息中，如 <em>INFO:1308435758660</em> Message with timestamp。</td>
</tr>
<tr>
<td><code>return</code></td>
<td>可能的返回值。必须是支持的类型之一。</td>
</tr>
<tr>
<td><code>error</code></td>
<td>可能的错误消息。仅在执行失败时使用。</td>
</tr>
<tr>
<td><code>traceback</code></td>
<td>可能的堆栈跟踪，当执行失败时，使用 DEBUG 级别写入日志文件。</td>
</tr>
<tr>
<td><code>continuable</code></td>
<td>当设置为 True，或者在 Python 中被认为是 True 的任何值，发生的失败被认为是可继续的。</td>
</tr>
<tr>
<td><code>fatal</code></td>
<td>像 continuable，但表示发生的失败是致命的。</td>
</tr>
</tbody></table>
<h5 id="不同的参数语法"><a href="#不同的参数语法" class="headerlink" title="不同的参数语法"></a>不同的参数语法</h5><p>Remote 库是一个动态库，通常，它根据与任何其他动态库相同的规则处理不同的参数语法。这包括必需的参数、默认值、varargs，以及命名参数语法。</p>
<p>自由命名参数（<code>**kwargs</code>）也大多数情况下与其他动态库的工作方式相同。首先，<code>get_keyword_arguments</code> 必须返回一个包含 <code>**kwargs</code> 的参数规范，就像任何其他动态库一样。主要的区别在于，远程服务器的 <code>run_keyword</code> 方法必须有一个可选的第三个参数，用于获取用户指定的 kwargs。第三个参数必须是可选的，因为出于向后兼容性的原因，Remote 库只有在测试数据中使用了 kwargs 时，才会将 kwargs 传递给 <code>run_keyword</code> 方法。</p>
<p>实际上，<code>run_keyword</code> 应该看起来像下面的 Python 和 Java 示例，具体取决于语言如何处理可选参数。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_keyword</span>(<span class="params">name, args, kwargs=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">public Map run_keyword(String name, <span class="type">List</span> args) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Map run_keyword(String name, <span class="type">List</span> args, Map kwargs) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​                    </p>
<h3 id="监听器接口"><a href="#监听器接口" class="headerlink" title="监听器接口"></a>监听器接口</h3><p>Robot Framework 的监听器接口提供了一个强大的机制，用于在执行过程中获取通知以及检查和修改数据和结果。例如，当套件、测试和关键字开始和结束时，当输出文件准备好时，以及最后整个执行结束时，都会调用监听器。示例用途包括与外部测试管理系统通信，当测试失败时发送消息，以及在执行过程中修改测试。</p>
<p>监听器以具有某些特殊方法的类或模块的形式实现。它们可以从命令行中使用，并由库注册。前者的监听器在整个执行过程中都是活动的，而后者只在执行注册它们的库的套件时活动。</p>
<p>有两种支持的监听器接口版本，监听器版本 2 和监听器版本 3。它们的方法大致相同，但这些方法被调用时的参数不同。新的监听器版本 3 更强大，通常推荐使用。</p>
<h4 id="监听器结构"><a href="#监听器结构" class="headerlink" title="监听器结构"></a>监听器结构</h4><p>监听器以与库类似的方式实现为模块或类。它们可以实现某些命名的钩子方法，具体取决于它们对哪些事件感兴趣。例如，如果监听器希望在测试开始时收到通知，它可以实现 <code>start_test</code> 方法。如后续部分所述，不同的监听器版本有稍微不同的可用方法集，它们也被调用时的参数不同。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用监听器 API 版本 3 实现的模块监听器。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">data, result</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Suite &#x27;<span class="subst">&#123;data.name&#125;</span>&#x27; starting.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end_test</span>(<span class="params">data, result</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Test &#x27;<span class="subst">&#123;result.name&#125;</span>&#x27; ended with status <span class="subst">&#123;result.status&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>监听器不需要实现任何显式接口，只需简单地实现所需的方法，它们将被自动识别。然而，有基类 <code>robot.api.interfaces.ListenerV2</code> 和 <code>robot.api.interfaces.ListenerV3</code> 可以用来在编辑器中获取方法名称完成、类型提示等。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与上面的示例相同，但使用了可选的基类和类型提示。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot <span class="keyword">import</span> result, running</span><br><span class="line"><span class="keyword">from</span> robot.api.interfaces <span class="keyword">import</span> ListenerV3</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>(<span class="title class_ inherited__">ListenerV3</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">self, data: running.TestSuite, result: result.TestSuite</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Suite &#x27;<span class="subst">&#123;data.name&#125;</span>&#x27; starting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_test</span>(<span class="params">self, data: running.TestCase, result: result.TestCase</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Test &#x27;<span class="subst">&#123;result.name&#125;</span>&#x27; ended with status <span class="subst">&#123;result.status&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li>可选的监听器基类是在 Robot Framework 6.1 中新增的。</li>
<li>除了使用 “蛇形命名法”（如 <code>start_test</code>）与监听器方法名称外，还可以使用 “驼峰命名法”（如 <code>startTest</code>）。当可以在 Jython 上运行 Robot Framework 并使用 Java 实现监听器时，添加了此支持。出于向后兼容性的原因，它被保留下来，但不推荐在新的监听器中使用。</li>
</ul>

    </div>
  </div>             

<h4 id="监听器接口版本"><a href="#监听器接口版本" class="headerlink" title="监听器接口版本"></a>监听器接口版本</h4><p>有两个支持的监听器接口版本，版本号分别为 2 和 3。监听器可以通过具有值 2 或 3 的 <code>ROBOT_LISTENER_API_VERSION</code> 属性来指定要使用的版本。从 Robot Framework 7.0 开始，如果未指定版本，则默认使用监听器版本 3。</p>
<p>监听器版本 2 和监听器版本 3 的方法大致相同，但传递给这些方法的参数不同。给监听器 2 方法的参数是字符串和包含执行信息的字典。可以检查和进一步发送此信息，但无法直接修改它。监听器 3 方法获取 Robot Framework 本身使用的相同模型对象，这些模型对象可以被检查和修改。</p>
<p>监听器版本 3 比较旧的监听器版本 2 更强大，通常推荐使用。</p>
<h5 id="监听器版本-2"><a href="#监听器版本-2" class="headerlink" title="监听器版本 2"></a>监听器版本 2</h5><p>使用监听器 API 版本 2 的监听器在执行过程中会收到关于各种事件的通知，但它们无法访问实际执行的测试，因此无法直接影响执行或创建的结果。</p>
<p>API 版本 2 中的监听器方法列在下面的表格和可选的 ListenerV2 基类的 API 文档中。所有与测试执行进度相关的方法都有相同的签名 <code>method(name, attributes)</code>，其中 <code>attributes</code> 是一个包含事件详细信息的字典。监听器方法可以自由地处理它们接收到的信息，但不能直接更改它。如果需要，可以使用监听器版本 3。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>文档说明描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>start_suite</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当测试套件开始时调用。包含以下属性字典内容：<br><code>id</code>: 套件id，如顶级套件为s1，第一个子套件为s1-s1，以此类推。<br><code>longname</code>: 包含父套件的套件名称。<br><code>doc</code>: 套件文档。<br><code>metadata</code>: 自由套件元数据，以字典形式。<br><code>source</code>: 套件创建来源的文件&#x2F;目录的绝对路径。<br><code>suites</code>: 此套件具有的直接子套件的名称列表。<br><code>totaltests</code>: 此套件及其所有子套件中测试的总数，以整数形式。<br><code>starttime</code>: 套件执行开始时间。</td>
</tr>
<tr>
<td><code>end_suite</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当测试套件结束时调用。包含以下属性字典内容：<br><code>id</code>: 同start_suite。<br><code>longname</code>: 同start_suite。<br><code>doc</code>: 同start_suite。<br><code>metadata</code>: 同start_suite。<br><code>source</code>: 同start_suite。<br><code>starttime</code>: 同start_suite。<br><code>endtime</code>: 套件执行结束时间。<br><code>elapsedtime</code>: 总执行时间，以毫秒为单位的整数。<br><code>status</code>: 套件状态，为字符串PASS、FAIL或SKIP。<br><code>statistics</code>: 套件的统计信息，包括通过和未通过测试的数量，以字符串形式。<br><code>message</code>: 如果套件设置或拆卸失败的错误信息，否则为空。</td>
</tr>
<tr>
<td><code>start_test</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当测试用例开始时调用。包含以下属性字典内容：<br><code>id</code>: 测试id，格式如s1-s2-t2，其中开头是父套件id，最后一部分显示该套件中的测试索引。<br><code>longname</code>: 包括父套件的测试名称。<br><code>originalname</code>: 可能未解析变量的测试名称。RF 3.2新功能。<br><code>doc</code>: 测试文档。<br><code>tags</code>: 测试标签，为字符串列表。<br><code>template</code>: 用于测试的模板名称。如果测试未模板化，则为空字符串。<br><code>source</code>: 测试用例源文件的绝对路径。RF 4.0新功能。<br><code>lineno</code>: 测试在源文件中开始的行号。RF 3.2新功能。<br><code>starttime</code>: 测试执行开始时间。</td>
</tr>
<tr>
<td><code>end_test</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当测试用例结束时调用。包含以下属性字典内容：<br><code>id</code>: 与start_test相同。<br><code>longname</code>: 与start_test相同。<br><code>originalname</code>: 与start_test相同。<br><code>doc</code>: 与start_test相同。<br><code>tags</code>: 与start_test相同。<br><code>template</code>: 与start_test相同。<br><code>source</code>: 与start_test相同。<br><code>lineno</code>: 与start_test相同。<br><code>starttime</code>: 与start_test相同。<br><code>endtime</code>: 测试执行结束时间。<br><code>elapsedtime</code>: 总执行时间，以毫秒为单位的整数。<br><code>status</code>: 测试状态，为字符串PASS、FAIL或SKIP。<br><code>message</code>: 状态消息。通常是错误消息或空字符串。</td>
</tr>
<tr>
<td><code>start_keyword</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当一个关键字或一个控制结构（如 IF&#x2F;ELSE 或 TRY&#x2F;EXCEPT）开始时调用:<br />对于关键字，<code>name</code> 是完整的关键字名称，包含可能的库或资源名称作为前缀，如 <code>MyLibrary.Example Keyword</code>。对于控制结构，<code>name</code> 包含参数的字符串表示。<br />关键字和控制结构共享大部分属性，但控制结构可以根据其类型具有额外的属性。<br />共享属性：<br /> <code>type</code>: 指定开始项类型的字符串。可能的值有：KEYWORD、SETUP、TEARDOWN、FOR、WHILE、ITERATION、IF、ELSE IF、ELSE、TRY、EXCEPT、FINALLY、VAR、RETURN、BREAK、CONTINUE 和 ERROR。所有类型值在 RF 4.0 中改变，在 RF 5.0 中 FOR ITERATION 被改为 ITERATION。 <br /><code>kwname</code>: 关键字名称，不包含库或资源前缀。控制结构的参数的字符串表示。 <br /><code>libname</code>: 关键字所属的库或资源文件的名称。在测试用例文件中的用户关键字和控制结构中为空字符串。<br /><code>doc</code>: 关键字文档。<br /><code>args</code>: 关键字的参数，以字符串列表形式。<br /><code>assign</code>: 关键字返回值被赋值的变量名称列表。<br /><code>tags</code>: 关键字标签，以字符串列表形式。<br /><code>source</code>: 使用关键字的文件的绝对路径。在 RF 4.0 中新增。<br /><code>lineno</code>: 使用关键字的行号。在 RF 4.0 中新增。<br /><code>status</code>: 初始关键字状态。如果关键字未执行（例如，由于之前的失败），则为 NOT RUN，否则为 NOT SET。在 RF 4.0 中新增。<br /><code>starttime</code>: 关键字执行开始时间。<br />FOR 类型的额外属性：<br /><code>variables</code>: 每个循环迭代的分配变量，以字符串列表形式。 <br /><code>flavor</code>: 循环类型（例如 IN RANGE）。 <br /><code>values</code>: 循环遍历的值列表，以字符串列表形式。 <br /><code>start</code>: 开始配置。仅在 IN ENUMERATE 循环中使用。在 RF 6.1 中新增。<br /><code>mode</code>: 模式配置。仅在 IN ZIP 循环中使用。在 RF 6.1 中新增。<br /><code>fill</code>: 填充值配置。仅在 IN ZIP 循环中使用。在 RF 6.1 中新增。<br />FOR 循环的 ITERATION 类型的额外属性：<br /><code>variables</code>: 一个 FOR 循环迭代的变量及其内容的字符串表示，以字典形式。<br />WHILE 类型的额外属性：<br /> <code>condition</code>: 循环条件。<br /> <code>limit</code>: 最大迭代限制。<br /> <code>on_limit</code>: 如果超过限制，该怎么做。有效值是 pass 和 fail。在 RF 7.0 中新增。<br /> <code>on_limit_message</code>: 达到 WHILE 循环的限制时引发的自定义错误。在 RF 6.1 中新增。<br />IF 和 ELSE IF 类型的额外属性：<br /><code>condition</code>: 正在评估的条件表达式。在 RF 6.1 中新增的 ELSE IF。<br />EXCEPT 类型的额外属性：<br /> <code>patterns</code>: 匹配的异常模式，以字符串列表形式。<br /> <code>pattern_type</code>: 模式匹配类型（例如 GLOB）。<br /> <code>variable</code>: 包含捕获的异常的变量。<br />RETURN 类型的额外属性：<br /><code>values</code>: 关键字的返回值，以字符串列表形式。<br />VAR 类型的额外属性：<br /> <code>name</code>: 变量名称。<br /> <code>value</code>: 变量值。标量变量为字符串，否则为列表。<br /> <code>scope</code>: 变量范围（例如 GLOBAL），以字符串形式。<br />控制结构的额外属性通常在 RF 6.0 中新增。VAR 在 RF 7.0 中新增。</td>
</tr>
<tr>
<td><code>end_keyword</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当一个关键字或一个控制结构结束时会被调用。<br /><code>name</code> 是完整的关键字名称，包含可能的库或资源名称作为前缀。例如，<code>MyLibrary.Example Keyword</code>。<br />控制结构具有额外的属性，这些属性根据 <code>type</code> 属性变化。有关所有可能属性的描述，请参见 <code>start_keyword</code> 部分。<br />属性字典的内容：<br /> <code>type</code>: 与 <code>start_keyword</code> 相同。<br /> <code>kwname</code>: 与 <code>start_keyword</code> 相同。<br /> <code>libname</code>: 与 <code>start_keyword</code> 相同。<br /> <code>doc</code>: 与 <code>start_keyword</code> 相同。<br /> <code>args</code>: 与 <code>start_keyword</code> 相同。 <br /> <code>assign</code>: 与 <code>start_keyword</code> 相同。<br /> <code>tags</code>: 与 <code>start_keyword</code> 相同。<br /> <code>source</code>: 与 <code>start_keyword</code> 相同。 <br /> <code>lineno</code>: 与 <code>start_keyword</code> 相同。<br /> <code>starttime</code>: 与 <code>start_keyword</code> 相同。<br /> <code>endtime</code>: 关键字执行结束时间。<br /> <code>elapsedtime</code>: 总执行时间，以毫秒为单位的整数。<br /> <code>status</code>: 关键字状态，字符串 PASS、FAIL、SKIP 或 NOT RUN。SKIP 和 NOT RUN 在 RF 4.0 中新增。</td>
</tr>
<tr>
<td><code>log_message</code></td>
<td><code>message</code></td>
<td>当执行的关键字写入日志消息时会被调用。<br /><code>message</code> 是一个字典，包含以下内容：<br /> <code>message</code>: 消息的内容。 <br /><code>level</code>: 用于记录消息的日志级别。 <br /><code>timestamp</code>: 消息创建时间，格式为 YYYY-MM-DD hh:mm:ss.mil。<br /><code>html</code>: 字符串 yes 或 no，表示是否应将消息解释为 HTML。<br />如果消息级别低于当前阈值级别，则不会调用此方法。</td>
</tr>
<tr>
<td><code>message</code></td>
<td><code>message</code></td>
<td>当框架本身写入系统日志消息时会被调用。<br /><code>message</code> 是一个字典，其内容与 <code>log_message</code> 方法相同。</td>
</tr>
<tr>
<td><code>library_import</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当导入一个库时会被调用。<br /><code>name</code> 是导入的库的名称。如果在使用 AS 导入库时给库指定了自定义名称，<code>name</code> 就是指定的别名。<br />属性字典的内容：<br /> <code>args</code>: 传递给库的参数，以列表形式。<br /> <code>originalname</code>: 如果使用 AS 给库指定了别名，则为原始库名称，否则与 <code>name</code> 相同。<br /> <code>source</code>: 库源的绝对路径。如果由于某种原因获取库的源失败，则为 None。<br /> <code>importer</code>: 导入库的文件的绝对路径。当导入 BuiltIn 以及使用 Import Library 关键字时为 None。</td>
</tr>
<tr>
<td><code>resource_import</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当导入资源文件时会被调用。<br /> <code>name</code> 是导入的资源文件的名称，不包含文件扩展名。<br />属性字典的内容：<br /> <code>source</code>: 导入的资源文件的绝对路径。<br /> <code>importer</code>: 导入资源文件的文件的绝对路径。使用 Import Resource 关键字时为 None。</td>
</tr>
<tr>
<td><code>variables_import</code></td>
<td><code>name</code>, <code>attributes</code></td>
<td>当导入变量文件时会被调用。<br /><code>name</code> 是导入的变量文件的名称，包含文件扩展名。<br />属性字典的内容：<br />  <code>args</code>: 传递给变量文件的参数，以列表形式。<br />  <code>source</code>: 导入的变量文件的绝对路径。<br />  <code>importer</code>: 导入资源文件的文件的绝对路径。使用 Import Variables 关键字时为 None。</td>
</tr>
<tr>
<td><code>output_file</code></td>
<td><code>path</code></td>
<td>当准备好写入输出文件时会被调用。<br /><code>path</code> 是文件的绝对路径，以字符串形式表示。</td>
</tr>
<tr>
<td><code>log_file</code></td>
<td><code>path</code></td>
<td>当准备好写入日志文件时会被调用。<br /><code>path</code> 是文件的绝对路径，以字符串形式表示。</td>
</tr>
<tr>
<td><code>report_file</code></td>
<td><code>path</code></td>
<td>当准备好写入报告文件时会被调用。<br /><code>path</code> 是文件的绝对路径，以字符串形式表示。</td>
</tr>
<tr>
<td><code>xunit_file</code></td>
<td><code>path</code></td>
<td>当准备好写入 xunit 文件时会被调用。<br /><code>path</code> 是文件的绝对路径，以字符串形式表示。</td>
</tr>
<tr>
<td><code>debug_file</code></td>
<td><code>path</code></td>
<td>当准备好写入调试文件时会被调用。<br /><code>path</code> 是文件的绝对路径，以字符串形式表示。</td>
</tr>
<tr>
<td><code>close</code></td>
<td></td>
<td>当整个测试执行结束时会被调用。<br />对于库监听器，当库超出范围时会被调用。</td>
</tr>
</tbody></table>
<h5 id="监听器版本-3"><a href="#监听器版本-3" class="headerlink" title="监听器版本 3"></a>监听器版本 3</h5><p>监听器版本 3 的方法大多与监听器版本 2 相同，但与测试执行相关的方法的参数不同。这些方法获取 Robot Framework 本身使用的实际运行和结果模型对象，监听器既可以查询它们需要的信息，也可以即时更改模型对象。</p>
<p>在 Robot Framework 7.0 中，当它获得了与关键字和控制结构相关的方法时，对监听器版本 3 进行了大量增强。它仍然没有与库、资源文件和变量文件导入相关的方法，但计划在 Robot Framework 7.1 中添加它们。</p>
<p>API 版本 3 中的监听器方法列在下面的表格和可选的 ListenerV3 基类的 API 文档中。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>文档说明描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>start_suite</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当测试套件开始时调用。<code>data</code> 和 <code>result</code> 是表示执行的测试套件及其执行结果的模型对象。</td>
</tr>
<tr>
<td><code>end_suite</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当测试套件结束时调用。参数与 <code>start_suite</code> 相同。</td>
</tr>
<tr>
<td><code>start_test</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当测试用例开始时调用。<code>data</code> 和 <code>result</code> 是表示执行的测试用例及其执行结果的模型对象。</td>
</tr>
<tr>
<td><code>end_test</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当测试用例结束时调用。参数与 <code>start_test</code> 相同。</td>
</tr>
<tr>
<td><code>start_keyword</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当关键字开始时调用。<code>data</code> 和 <code>result</code> 是表示执行的关键字调用及其执行结果的模型对象。默认情况下，当用户关键字、库关键字开始时，以及当关键字调用无效时，会调用此方法。如果实现了更具体的 <code>start_user_keyword</code>、<code>start_library_keyword</code> 或 <code>start_invalid_keyword</code> 方法，则不会调用此方法。</td>
</tr>
<tr>
<td><code>end_keyword</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当关键字开始时调用。参数和其他语义与 <code>start_keyword</code> 相同。</td>
</tr>
<tr>
<td><code>start_user_keyword</code></td>
<td><code>data</code>, <code>implementation</code>, <code>result</code></td>
<td>当用户关键字开始时调用。<code>data</code> 和 <code>result</code> 与 <code>start_keyword</code> 相同，<code>implementation</code> 是实际执行的用户关键字。如果实现了此方法，<code>start_keyword</code> 不会在用户关键字中被调用。</td>
</tr>
<tr>
<td><code>end_user_keyword</code></td>
<td><code>data</code>, <code>implementation</code>, <code>result</code></td>
<td>当用户关键字结束时调用。参数和其他语义与 <code>start_user_keyword</code> 相同。</td>
</tr>
<tr>
<td><code>start_library_keyword</code></td>
<td><code>data</code>, <code>implementation</code>, <code>result</code></td>
<td>当库关键字开始时调用。<code>data</code> 和 <code>result</code> 与 <code>start_keyword</code> 相同，<code>implementation</code> 表示执行的库关键字。如果实现了此方法，<code>start_keyword</code> 不会在库关键字中被调用。</td>
</tr>
<tr>
<td><code>end_library_keyword</code></td>
<td><code>data</code>, <code>implementation</code>, <code>result</code></td>
<td>当库关键字结束时调用。参数和其他语义与 <code>start_library_keyword</code> 相同。</td>
</tr>
<tr>
<td><code>start_invalid_keyword</code></td>
<td><code>data</code>, <code>implementation</code>, <code>result</code></td>
<td>当无效的关键字调用开始时调用。<code>data</code> 和 <code>result</code> 与 <code>start_keyword</code> 相同，<code>implementation</code> 表示无效的关键字调用。关键字可能没有被找到，可能有多个匹配，或者关键字调用本身可能无效。如果实现了此方法，<code>start_keyword</code> 不会在无效的关键字调用中被调用。</td>
</tr>
<tr>
<td><code>end_invalid_keyword</code></td>
<td><code>data</code>, <code>implementation</code>, <code>result</code></td>
<td>当无效的关键字调用结束时调用。参数和其他语义与 <code>start_invalid_keyword</code> 相同。</td>
</tr>
<tr>
<td><code>start_for</code>, <code>start_for_iteration</code>, <code>start_while</code>, <code>start_while_iteration</code>, <code>start_if</code>, <code>start_if_branch</code>, <code>start_try</code>, <code>start_try_branch</code>, <code>start_var</code>, <code>start_continue</code>, <code>start_break</code>, <code>start_return</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当控制结构开始时调用。有关更多信息，请参阅可选的 ListenerV3 基类的文档和类型提示。</td>
</tr>
<tr>
<td><code>end_for</code>, <code>end_for_iteration</code>, <code>end_while</code>, <code>end_while_iteration</code>, <code>end_if</code>, <code>end_if_branch</code>, <code>end_try</code>, <code>end_try_branch</code>, <code>end_var</code>, <code>end_continue</code>, <code>end_break</code>, <code>end_return</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当控制结构结束时调用。有关更多信息，请参阅可选的 ListenerV3 基类的文档和类型提示。</td>
</tr>
<tr>
<td><code>start_error</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当无效语法开始时调用。</td>
</tr>
<tr>
<td><code>end_error</code></td>
<td><code>data</code>, <code>result</code></td>
<td>当无效语法结束时调用。</td>
</tr>
<tr>
<td><code>log_message</code></td>
<td><code>message</code></td>
<td>当执行的关键字写入日志消息时调用。<code>message</code> 是表示记录的消息的模型对象。如果消息的级别低于当前阈值级别，此方法不会被调用。</td>
</tr>
<tr>
<td><code>message</code></td>
<td><code>message</code></td>
<td>当框架本身写入系统日志消息时调用。<code>message</code> 与 <code>log_message</code> 中的对象相同。</td>
</tr>
<tr>
<td><code>library_import</code></td>
<td>N&#x2F;A</td>
<td>目前未实现。</td>
</tr>
<tr>
<td><code>resource_import</code></td>
<td>N&#x2F;A</td>
<td>目前未实现。</td>
</tr>
<tr>
<td><code>variables_import</code></td>
<td>N&#x2F;A</td>
<td>目前未实现。</td>
</tr>
<tr>
<td><code>output_file</code></td>
<td><code>path</code></td>
<td>当准备好写入输出文件时调用。<code>path</code> 是文件的绝对路径，作为 pathlib.Path 对象。</td>
</tr>
<tr>
<td><code>log_file</code></td>
<td><code>path</code></td>
<td>当准备好写入日志文件时调用。<code>path</code> 是文件的绝对路径，作为 pathlib.Path 对象。</td>
</tr>
<tr>
<td><code>report_file</code></td>
<td><code>path</code></td>
<td>当准备好写入报告文件时调用。<code>path</code> 是文件的绝对路径，作为 pathlib.Path 对象。</td>
</tr>
<tr>
<td><code>xunit_file</code></td>
<td><code>path</code></td>
<td>当准备好写入 xunit 文件时调用。<code>path</code> 是文件的绝对路径，作为 pathlib.Path 对象。</td>
</tr>
<tr>
<td><code>debug_file</code></td>
<td><code>path</code></td>
<td>当准备好写入调试文件时调用。<code>path</code> 是文件的绝对路径，作为 pathlib.Path 对象。</td>
</tr>
<tr>
<td><code>close</code></td>
<td></td>
<td>当整个测试执行结束时调用。对于库监听器，当库超出范围时会被调用。</td>
</tr>
</tbody></table>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 7.0 之前，传递给结果文件相关的监听器版本 3 方法的路径是字符串。</p>

    </div>
  </div>

<h4 id="使用监听器"><a href="#使用监听器" class="headerlink" title="使用监听器"></a>使用监听器</h4><h5 id="从命令行注册监听器"><a href="#从命令行注册监听器" class="headerlink" title="从命令行注册监听器"></a>从命令行注册监听器</h5><p>需要在整个执行过程中保持活动的监听器必须从命令行中使用。这是通过使用 <code>--listener</code> 选项完成的，将监听器的名称作为参数给出。监听器的名称来自实现监听器的类或模块的名称，类似于库名称来自实现库的类或模块的名称。指定的监听器必须在导入它们时搜索测试库的同一模块搜索路径中。除了使用名称注册监听器外，还可以给出监听器文件的绝对路径或相对路径，类似于测试库。可以通过多次使用此选项来使用多个监听器：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot --listener MyListener tests.robot</span><br><span class="line">robot --listener path/to/MyListener.py tests.robot</span><br><span class="line">robot --listener module.Listener --listener AnotherListener tests.robot</span><br></pre></td></tr></table></figure></div>

<p>还可以从命令行给监听器类提供参数。参数在监听器名称（或路径）后使用冒号（:）作为分隔符指定。如果监听器被给出为绝对 Windows 路径，则驱动器字母后的冒号不被视为分隔符。此外，还可以使用分号（;）作为替代参数分隔符。这在监听器参数本身包含冒号时很有用，但在 UNIX-like 操作系统上需要用引号包围整个值：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot --listener listener.py:arg1:arg2 tests.robot</span><br><span class="line">robot --listener &quot;listener.py;arg:with:colons&quot; tests.robot</span><br><span class="line">robot --listener c:\path\listener.py;d:\first\arg;e:\second\arg tests.robot</span><br></pre></td></tr></table></figure></div>

<p>除了逐个传递参数作为位置参数外，还可以使用命名参数语法传递它们，类似于使用关键字时：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --listener listener.py:name=value tests.robot</span><br><span class="line">robot --listener &quot;listener.py;name=value:with:colons;second=argument&quot; tests.robot</span><br></pre></td></tr></table></figure></div>

<p>监听器参数会根据类型提示和默认值自动转换，使用与关键字相同的规则。例如，这个监听器</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Listener</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, port: <span class="built_in">int</span>, log=<span class="literal">True</span></span>):</span><br><span class="line">        self.port = post</span><br><span class="line">        self.log = log</span><br></pre></td></tr></table></figure></div>

<p>可以这样使用</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot --listener Listener:8270:false</span><br></pre></td></tr></table></figure></div>

<p>并且第一个参数将根据类型提示转换为整数，第二个参数将根据默认值转换为布尔值。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>命名参数语法和参数转换在 Robot Framework 4.0 中是新的。</p>

    </div>
  </div>

<h5 id="作为监听器的库"><a href="#作为监听器的库" class="headerlink" title="作为监听器的库"></a>作为监听器的库</h5><p>有时，对于测试库来说，获取关于测试执行的通知也是有用的。例如，这允许它们在测试套件或整个测试执行结束时自动执行某些清理活动。</p>
<h6 id="注册监听器"><a href="#注册监听器" class="headerlink" title="注册监听器"></a>注册监听器</h6><p>测试库可以通过使用 <code>ROBOT_LIBRARY_LISTENER</code> 属性来注册监听器。此属性的值应为要使用的监听器的实例。它可能是一个完全独立的监听器，或者库本身可以充当监听器。为了避免监听器方法被暴露为关键字，在后一种情况下，可以使用下划线作为前缀。例如，可以使用 <code>_end_suite</code> 而不是 <code>end_suite</code>。</p>
<p>以下示例说明了使用外部监听器以及库本身充当监听器：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> listener <span class="keyword">import</span> Listener</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryWithExternalListener</span>:</span><br><span class="line">    ROBOT_LIBRARY_SCOPE = <span class="string">&#x27;GLOBAL&#x27;</span></span><br><span class="line">    ROBOT_LIBRARY_LISTENER = Listener()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">self</span>):</span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryItselfAsListener</span>:</span><br><span class="line">    ROBOT_LIBRARY_SCOPE = <span class="string">&#x27;SUITE&#x27;</span></span><br><span class="line">    ROBOT_LISTENER_API_VERSION = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ROBOT_LIBRARY_LISTENER = self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 &#x27;_&#x27; 前缀以避免监听器方法成为关键字。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_end_suite</span>(<span class="params">self, name, attrs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Suite &#x27;<span class="subst">&#123;name&#125;</span>&#x27; ending with status <span class="subst">&#123;attrs[<span class="string">&#x27;id&#x27;</span>]&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">self</span>):</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure></div>

<p>如上面的第二个示例已经演示，库监听器可以使用 <code>ROBOT_LISTENER_API_VERSION</code> 属性指定监听器接口版本，就像任何其他监听器一样。</p>
<p>从 Robot Framework 7.0 开始，监听器也可以通过使用字符串 <code>SELF</code>（不区分大小写）作为监听器来注册自己。这在使用 <code>@library</code> 装饰器时特别方便：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api.deco <span class="keyword">import</span> keyword, library</span><br><span class="line"></span><br><span class="line"><span class="meta">@library(<span class="params">scope=<span class="string">&#x27;SUITE&#x27;</span>, listener=<span class="string">&#x27;SELF&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryItselfAsListener</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 监听器版本未指定，因此默认使用监听器版本 3。</span></span><br><span class="line">    <span class="comment"># 当使用 @library 装饰器时，关键字必须使用 @keyword 装饰器，</span></span><br><span class="line">    <span class="comment"># 因此这里无需使用 &#x27;_&#x27; 前缀。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_suite</span>(<span class="params">self, data, result</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Suite &#x27;<span class="subst">&#123;data.name&#125;</span>&#x27; ending with status <span class="subst">&#123;result.status&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @keyword</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">self</span>):</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure></div>

<p>也可以通过给 <code>ROBOT_LIBRARY_LISTENER</code> 一个列表值来为单个库指定多个监听器：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> listeners <span class="keyword">import</span> Listener1, Listener2, Listener3</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryWithMultipleListeners</span>:</span><br><span class="line">    ROBOT_LIBRARY_LISTENER = [Listener1(), Listener2(), Listener3()]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">example_keyword</span>(<span class="params">self</span>):</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure></div>

<h6 id="调用监听器方法"><a href="#调用监听器方法" class="headerlink" title="调用监听器方法"></a>调用监听器方法</h6><p>库监听器会收到在导入使用它们的库的套件中的所有事件的通知。实际上，这意味着会调用套件、测试、关键字、控制结构和日志消息相关的方法。除此之外，当库超出范围时，还会调用 <code>close</code> 方法。</p>
<p>如果库每次实例化时都创建一个新的监听器实例，那么要使用的实际监听器实例将根据库的范围而变化。</p>
<h4 id="监听器示例"><a href="#监听器示例" class="headerlink" title="监听器示例"></a>监听器示例</h4><p>本节包含使用监听器接口的示例。前面的示例说明了在执行过程中获取通知，后面的示例修改了执行的测试和创建的结果。</p>
<h5 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h5><p>第一个示例是作为 Python 模块实现的。它使用的是监听器版本 2，但同样可以使用监听器版本 3 来实现。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;如果测试失败，停止执行的监听器。&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">ROBOT_LISTENER_API_VERSION = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end_test</span>(<span class="params">name, attrs</span>):</span><br><span class="line">    <span class="keyword">if</span> attrs[<span class="string">&#x27;status&#x27;</span>] == <span class="string">&#x27;FAIL&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Test &#x27;<span class="subst">&#123;name&#125;</span>&#x27; failed: <span class="subst">&#123;attrs[<span class="string">&#x27;message&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;Press enter to continue.&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果将上述示例保存为，例如，<code>PauseExecution.py</code> 文件，那么可以像这样从命令行中使用它：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot --listener path/to/PauseExecution.py tests.robot</span><br></pre></td></tr></table></figure></div>

<p>下一个示例（仍然使用监听器版本 2）稍微复杂一些。它将获取的所有信息写入临时目录中的文本文件，没有太多格式化。文件名可以从命令行给出，但也有默认值。请注意，在实际使用中，通过命令行选项 <code>--debugfile</code> 可用的调试文件功能可能比这个示例更有用。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line">    ROBOT_LISTENER_API_VERSION = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_name=<span class="string">&#x27;listen.txt&#x27;</span></span>):</span><br><span class="line">        path = os.path.join(tempfile.gettempdir(), file_name)</span><br><span class="line">        self.file = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">self, name, attrs</span>):</span><br><span class="line">        self.file.write(<span class="string">&quot;%s &#x27;%s&#x27;\n&quot;</span> % (name, attrs[<span class="string">&#x27;doc&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_test</span>(<span class="params">self, name, attrs</span>):</span><br><span class="line">        tags = <span class="string">&#x27; &#x27;</span>.join(attrs[<span class="string">&#x27;tags&#x27;</span>])</span><br><span class="line">        self.file.write(<span class="string">&quot;- %s &#x27;%s&#x27; [ %s ] :: &quot;</span> % (name, attrs[<span class="string">&#x27;doc&#x27;</span>], tags))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_test</span>(<span class="params">self, name, attrs</span>):</span><br><span class="line">        <span class="keyword">if</span> attrs[<span class="string">&#x27;status&#x27;</span>] == <span class="string">&#x27;PASS&#x27;</span>:</span><br><span class="line">            self.file.write(<span class="string">&#x27;PASS\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.file.write(<span class="string">&#x27;FAIL: %s\n&#x27;</span> % attrs[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_suite</span>(<span class="params">self, name, attrs</span>):</span><br><span class="line">         self.file.write(<span class="string">&#x27;%s\n%s\n&#x27;</span> % (attrs[<span class="string">&#x27;status&#x27;</span>], attrs[<span class="string">&#x27;message&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">         self.file.close()</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h5 id="修改数据和结果"><a href="#修改数据和结果" class="headerlink" title="修改数据和结果"></a>修改数据和结果</h5><p>以下示例说明了如何修改执行的测试和套件以及执行结果。所有这些示例都需要使用监听器版本 3。</p>
<h6 id="修改执行的套件和测试"><a href="#修改执行的套件和测试" class="headerlink" title="修改执行的套件和测试"></a>修改执行的套件和测试</h6><p>更改执行内容就像修改传递给监听器方法的表示执行数据的模型对象一样简单。下面的示例说明了如何向每个执行的套件添加一个新的测试，并向每个测试添加一个新的关键字调用。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">data, result</span>):</span><br><span class="line">    data.tests.create(name=<span class="string">&#x27;New test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_test</span>(<span class="params">data, result</span>):</span><br><span class="line">    data.body.create_keyword(name=<span class="string">&#x27;Log&#x27;</span>, args=[<span class="string">&#x27;Keyword added by listener!&#x27;</span>])</span><br></pre></td></tr></table></figure></div>

<p>此 API 与可以用于在整个测试执行开始之前修改套件和测试的预运行修改器 API 非常相似。使用监听器 API 的主要好处是可以根据执行结果或其他方式动态地进行修改。例如，这为基于模型的测试提供了有趣的可能性。</p>
<p>尽管监听器接口并未建立在 Robot Framework 的内部访问者接口之上，就像预运行修改器 API 一样，但监听器仍然可以自己使用访问者接口。例如，可以像这样使用预运行修改器示例中使用的 SelectEveryXthTest 访问者：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> SelectEveryXthTest <span class="keyword">import</span> SelectEveryXthTest</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">suite, result</span>):</span><br><span class="line">    selector = SelectEveryXthTest(x=<span class="number">2</span>)</span><br><span class="line">    suite.visit(selector)</span><br></pre></td></tr></table></figure></div>

<h6 id="访问库或资源文件"><a href="#访问库或资源文件" class="headerlink" title="访问库或资源文件"></a>访问库或资源文件</h6><p>可以获取更多关于实际执行的关键字及其所属的库或资源文件的信息：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> Keyword <span class="keyword">as</span> KeywordData, LibraryKeyword</span><br><span class="line"><span class="keyword">from</span> robot.result <span class="keyword">import</span> Keyword <span class="keyword">as</span> KeywordResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_library_keyword</span>(<span class="params">data: KeywordData,</span></span><br><span class="line"><span class="params">                          implementation: LibraryKeyword,</span></span><br><span class="line"><span class="params">                          result: KeywordResult</span>):</span><br><span class="line">    library = implementation.owner</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Keyword &#x27;<span class="subst">&#123;implementation.name&#125;</span>&#x27; is implemented in library &quot;</span></span><br><span class="line">          <span class="string">f&quot;&#x27;<span class="subst">&#123;library.name&#125;</span>&#x27; at &#x27;<span class="subst">&#123;implementation.source&#125;</span>&#x27; on line &quot;</span></span><br><span class="line">          <span class="string">f&quot;<span class="subst">&#123;implementation.lineno&#125;</span>. The library has <span class="subst">&#123;library.scope.name&#125;</span> &quot;</span></span><br><span class="line">          <span class="string">f&quot;scope and the current instance is <span class="subst">&#123;library.instance&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>如上例所示，可以获取到实际库实例的访问权限。这意味着监听器可以检查库状态并修改它。对于用户关键字，甚至可以修改关键字本身，或者通过所有者资源文件，修改资源文件中的任何其他关键字。</p>
<p>​              </p>
<h6 id="修改结果"><a href="#修改结果" class="headerlink" title="修改结果"></a>修改结果</h6><p>可以通过修改传递给监听器方法的结果对象来改变测试执行结果。以下是一个作为类实现并使用类型提示的监听器的示例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot <span class="keyword">import</span> result, running</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResultModifier</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_seconds: <span class="built_in">float</span> = <span class="number">10.0</span></span>):</span><br><span class="line">        self.max_seconds = max_seconds</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_suite</span>(<span class="params">self, data: running.TestSuite, result: result.TestSuite</span>):</span><br><span class="line">        result.doc = <span class="string">&#x27;由监听器设置的文档。&#x27;</span></span><br><span class="line">        <span class="comment"># 关于测试的信息只能通过数据获得。</span></span><br><span class="line">        smoke_tests = [test <span class="keyword">for</span> test <span class="keyword">in</span> data.tests <span class="keyword">if</span> <span class="string">&#x27;smoke&#x27;</span> <span class="keyword">in</span> test.tags]</span><br><span class="line">        result.metadata[<span class="string">&#x27;Smoke tests&#x27;</span>] = <span class="built_in">len</span>(smoke_tests)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_test</span>(<span class="params">self, data: running.TestCase, result: result.TestCase</span>):</span><br><span class="line">        elapsed_seconds = result.elapsed_time.total_seconds()</span><br><span class="line">        <span class="keyword">if</span> result.status == <span class="string">&#x27;PASS&#x27;</span> <span class="keyword">and</span>  elapsed_seconds &gt; self.max_milliseconds:</span><br><span class="line">            result.status = <span class="string">&#x27;FAIL&#x27;</span></span><br><span class="line">            result.message = <span class="string">&#x27;测试执行时间过长。&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_message</span>(<span class="params">self, msg: result.Message</span>):</span><br><span class="line">        <span class="keyword">if</span> msg.level == <span class="string">&#x27;WARN&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> msg.html:</span><br><span class="line">            msg.message = <span class="string">f&#x27;&lt;b style=&quot;font-size: 1.5em&quot;&gt;<span class="subst">&#123;msg.message&#125;</span>&lt;/b&gt;&#x27;</span></span><br><span class="line">            msg.html = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>

<p>一个限制是，修改当前测试套件或测试用例的名称是不可能的，因为在调用监听器时，它已经被写入到 output.xml 文件中。由于同样的原因，在 <code>end_suite</code> 方法中修改已经完成的测试也没有效果。</p>
<p>请注意，尽管监听器可以改变任何执行的关键字或控制结构的状态，但这并不直接影响执行的测试的状态。一般来说，监听器不能直接使关键字失败，以便停止执行，也不能处理失败，以便继续执行。如果有需要，将来可能会添加这种功能。</p>
<p>此 API 与 pre-Rebot 修改器 API 非常相似，可以用于在生成报告和日志之前修改结果。主要的区别是，监听器也修改了创建的 output.xml 文件。</p>
<h6 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h6><p>关键字和控制结构相关的监听器版本 3 方法如此多样，以至于在用户指南中无法完全覆盖它们。有关更多示例，可以查看接受测试，这些测试以各种方式使用这些方法。</p>
<h3 id="解析器接口"><a href="#解析器接口" class="headerlink" title="解析器接口"></a>解析器接口</h3><p>Robot Framework 支持可以处理自定义数据格式甚至覆盖 Robot Framework 自己的解析器的外部解析器。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>自定义解析器在 Robot Framework 6.1 中是新的。</p>

    </div>
  </div>

<h4 id="使用解析器"><a href="#使用解析器" class="headerlink" title="使用解析器"></a>使用解析器</h4><p>解析器是从命令行使用 <code>--parser</code> 选项启用的，使用的语义与监听器完全相同。这包括指定解析器为名称或路径，给解析器类提供参数等：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robot --parser MyParser tests.custom</span><br><span class="line">robot --parser path/to/MyParser.py tests.custom</span><br><span class="line">robot --parser Parser1:arg --parser Parser2:a1:a2 path/to/tests</span><br></pre></td></tr></table></figure></div>

<h4 id="解析器-API"><a href="#解析器-API" class="headerlink" title="解析器 API"></a>解析器 API</h4><p>解析器可以作为模块和类来实现。本节解释了它们必须包含哪些属性和方法。</p>
<h5 id="EXTENSION-或-extension-属性"><a href="#EXTENSION-或-extension-属性" class="headerlink" title="EXTENSION 或 extension 属性"></a>EXTENSION 或 extension 属性</h5><p>此属性指定解析器支持的文件扩展名或扩展名。接受 <code>EXTENSION</code> 和 <code>extension</code> 名称，如果两者都存在，前者优先。该属性可以是字符串或字符串序列。扩展名不区分大小写，可以带或不带前导点。如果解析器作为类实现，可以将此属性设置为类属性或实例属性。</p>
<p>也支持包含多个部分的扩展名，如 <code>.example.ext</code> 或 <code>.robot.zip</code>。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果解析器支持 <code>.robot</code> 扩展名，它将用于解析这些文件，而不是标准解析器。</p>

    </div>
  </div>

<h5 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse 方法"></a>parse 方法</h5><p>强制性的 <code>parse</code> 方法负责解析套件文件。它被调用时，每个解析的文件都有一个解析器支持的扩展名。该方法必须返回一个 <code>TestSuite</code> 对象。</p>
<p>在简单的情况下，<code>parse</code> 可以被实现为只接受一个参数，即指向要解析的文件的 <code>pathlib.Path</code> 对象。如果解析器对在更高级别的套件初始化文件中设置的 <code>Test Setup</code>、<code>Test Teardown</code>、<code>Test Tags</code> 和 <code>Test Timeout</code> 的默认值感兴趣，<code>parse</code> 方法必须接受两个参数。在这种情况下，第二个参数是一个 <code>TestDefaults</code> 对象。</p>
<h5 id="parse-init-方法"><a href="#parse-init-方法" class="headerlink" title="parse_init 方法"></a>parse_init 方法</h5><p>可选的 <code>parse_init</code> 方法负责解析套件初始化文件，即格式为 <code>__init__.ext</code> 的文件，其中 <code>.ext</code> 是解析器支持的扩展名。该方法必须返回一个表示整个目录的 <code>TestSuite</code> 对象。从子套件文件和目录创建的套件将被添加到其子套件中。</p>
<p><code>parse_init</code> 也可以被实现为接受一个或两个参数，取决于它是否对测试相关的默认值感兴趣。如果它接受默认值，它可以操作传递的 <code>TestDefaults</code> 对象，并在解析子套件文件时看到更改。</p>
<p>只有当解析器需要支持套件初始化文件时，才需要此方法。</p>
<h5 id="可选的基类"><a href="#可选的基类" class="headerlink" title="可选的基类"></a>可选的基类</h5><p>解析器不需要实现任何显式的接口，但扩展可选的 <code>Parser</code> 基类可能会有所帮助。主要的好处是基类有文档和类型提示。它也作为更正式的 API 规范。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><h5 id="作为模块实现的解析器"><a href="#作为模块实现的解析器" class="headerlink" title="作为模块实现的解析器"></a>作为模块实现的解析器</h5><p>第一个示例演示了一个作为模块实现的简单解析器，支持一个硬编码的扩展名。它只创建一个虚拟套件，并不实际解析任何内容。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> TestSuite</span><br><span class="line"></span><br><span class="line">EXTENSION = <span class="string">&#x27;.example&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">source</span>):</span><br><span class="line">    suite = TestSuite(name=<span class="string">&#x27;Example&#x27;</span>, source=source)</span><br><span class="line">    test = suite.tests.create(name=<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line">    test.body.create_keyword(name=<span class="string">&#x27;Log&#x27;</span>, args=[<span class="string">&#x27;Hello!&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> suite</span><br></pre></td></tr></table></figure></div>

<h5 id="作为类实现的解析器"><a href="#作为类实现的解析器" class="headerlink" title="作为类实现的解析器"></a>作为类实现的解析器</h5><p>第二个解析器作为一个类实现，接受要使用的扩展名作为参数。解析器读取给定的源文件，并从其中的每一行创建虚拟测试。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> TestSuite</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleParser</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, extension: <span class="built_in">str</span></span>):</span><br><span class="line">        self.extension = extension</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, source: Path</span>) -&gt; TestSuite:</span><br><span class="line">        name = TestSuite.name_from_source(source, self.extension)</span><br><span class="line">        suite = TestSuite(name, source=source)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> source.read_text().splitlines():</span><br><span class="line">            test = suite.tests.create(name=line)</span><br><span class="line">            test.body.create_keyword(name=<span class="string">&#x27;Log&#x27;</span>, args=[<span class="string">&#x27;Hello!&#x27;</span>])</span><br><span class="line">        <span class="keyword">return</span> suite</span><br></pre></td></tr></table></figure></div>

<h5 id="扩展可选基类的解析器"><a href="#扩展可选基类的解析器" class="headerlink" title="扩展可选基类的解析器"></a>扩展可选基类的解析器</h5><p>这个解析器扩展了可选的 <code>Parser</code> 基类。它支持解析套件初始化文件，使用 <code>TestDefaults</code> 并注册多个扩展名。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> TestSuite</span><br><span class="line"><span class="keyword">from</span> robot.api.interfaces <span class="keyword">import</span> Parser, TestDefaults</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleParser</span>(<span class="title class_ inherited__">Parser</span>):</span><br><span class="line">    extension = (<span class="string">&#x27;example&#x27;</span>, <span class="string">&#x27;another&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, source: Path, defaults: TestDefaults</span>) -&gt; TestSuite:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建一个套件并将可能的默认值从 init 文件设置到测试中。&quot;&quot;&quot;</span></span><br><span class="line">        suite = TestSuite(TestSuite.name_from_source(source), source=source)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> source.read_text().splitlines():</span><br><span class="line">            test = suite.tests.create(name=line, doc=<span class="string">&#x27;Example&#x27;</span>)</span><br><span class="line">            test.body.create_keyword(name=<span class="string">&#x27;Log&#x27;</span>, args=[<span class="string">&#x27;Hello!&#x27;</span>])</span><br><span class="line">            defaults.set_to(test)</span><br><span class="line">        <span class="keyword">return</span> suite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_init</span>(<span class="params">self, source: Path, defaults: TestDefaults</span>) -&gt; TestSuite:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建一个虚拟套件并设置一些默认值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        只有在有一个支持的扩展名的初始化文件时，才会调用此方法。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        defaults.tags = (<span class="string">&#x27;tags&#x27;</span>, <span class="string">&#x27;from init&#x27;</span>)</span><br><span class="line">        defaults.setup = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Log&#x27;</span>, <span class="string">&#x27;args&#x27;</span>: [<span class="string">&#x27;Hello from init!&#x27;</span>]&#125;</span><br><span class="line">        <span class="keyword">return</span> TestSuite(TestSuite.name_from_source(source.parent), doc=<span class="string">&#x27;Example&#x27;</span>,</span><br><span class="line">                         source=source, metadata=&#123;<span class="string">&#x27;Example&#x27;</span>: <span class="string">&#x27;Value&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></div>

<h5 id="作为预处理器的解析器"><a href="#作为预处理器的解析器" class="headerlink" title="作为预处理器的解析器"></a>作为预处理器的解析器</h5><p>最后一个示例解析器充当 Robot Framework 数据文件的预处理器，支持格式为 <code>=== Test Cases ===</code> 的标题，除了 <code>*** Test Cases ***</code>。在这种使用情况下，使用 <code>TestSuite.from_string</code>、<code>TestSuite.from_model</code> 和 <code>TestSuite.from_file_system</code> 工厂方法构造返回的套件是方便的。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> TestDefaults, TestSuite</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RobotPreprocessor</span>:</span><br><span class="line">    extension = <span class="string">&#x27;.robot&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, source: Path, defaults: TestDefaults</span>) -&gt; TestSuite:</span><br><span class="line">        data = source.read_text()</span><br><span class="line">        <span class="keyword">for</span> header <span class="keyword">in</span> <span class="string">&#x27;Settings&#x27;</span>, <span class="string">&#x27;Variables&#x27;</span>, <span class="string">&#x27;Test Cases&#x27;</span>, <span class="string">&#x27;Keywords&#x27;</span>:</span><br><span class="line">            data = data.replace(<span class="string">f&#x27;=== <span class="subst">&#123;header&#125;</span> ===&#x27;</span>, <span class="string">f&#x27;*** <span class="subst">&#123;header&#125;</span> ***&#x27;</span>)</span><br><span class="line">        suite = TestSuite.from_string(data, defaults=defaults)</span><br><span class="line">        <span class="keyword">return</span> suite.config(name=TestSuite.name_from_source(source), source=source)</span><br></pre></td></tr></table></figure></div>

<p>​                       </p>
<h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><h3 id="库文档工具（Libdoc）"><a href="#库文档工具（Libdoc）" class="headerlink" title="库文档工具（Libdoc）"></a>库文档工具（Libdoc）</h3><p>Libdoc 是 Robot Framework 的内置工具，可以为 Robot Framework 库和资源文件生成文档。它可以为人类生成 HTML 文档，也可以生成 XML 和 JSON 格式的机器可读规范文件。Libdoc 还有一些特殊命令可以在控制台上显示库或资源信息。</p>
<p>可以为以下内容创建文档：</p>
<ul>
<li>使用普通静态库 API 实现的库，</li>
<li>使用动态 API 的库，包括远程库，</li>
<li>资源文件，</li>
<li>套件文件，以及</li>
<li>套件初始化文件。</li>
</ul>
<p>此外，还可以使用 Libdoc 之前创建的 XML 和 JSON 规范文件作为输入。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 6.0 中，新增了为套件文件和套件初始化文件生成文档的支持。</p>
<p>在 Robot Framework 4.0 中，新增了对 JSON 规范文件的支持。</p>

    </div>
  </div>

<h4 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h4><h5 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h5><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libdoc [options] library_or_resource output_file</span><br><span class="line">libdoc [options] library_or_resource list|show|version [names]</span><br></pre></td></tr></table></figure></div>

<h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><ul>
<li><code>-f, --format &lt;html|xml|json|libspec&gt;</code>：指定是否为人类生成 HTML 输出，或者以 XML 或 JSON 格式生成机器可读的规范文件。<code>libspec</code> 格式意味着将文档转换为 HTML 的 XML 规范。默认格式从输出文件扩展名中获取。</li>
<li><code>-s, --specdocformat &lt;raw|html&gt;</code>：指定用于 XML 和 JSON 规范文件的文档格式。<code>raw</code> 表示保留原始文档格式，<code>html</code> 表示将文档转换为 HTML。默认值是 XML 规范文件的 <code>raw</code> 和 JSON 规范以及使用特殊 <code>libspec</code> 格式时的 <code>html</code>。这是 Robot Framework 4.0 中的新功能。</li>
<li><code>-F, --docformat &lt;robot|html|text|rest&gt;</code>：指定源文档格式。可能的值是 Robot Framework 的文档格式、HTML、纯文本和 reStructuredText。默认值可以在测试库源代码中指定，初始默认值是 <code>robot</code>。</li>
<li><code>--theme &lt;dark|light|none&gt;</code>：使用深色或浅色 HTML 主题。如果未使用此选项，或者值为 <code>none</code>，则根据浏览器颜色方案选择主题。仅适用于 HTML 输出。这是 Robot Framework 6.0 中的新功能。</li>
<li><code>-N, --name &lt;newname&gt;</code>：设置文档化库或资源的名称。</li>
<li><code>-V, --version &lt;newversion&gt;</code>：设置文档化库或资源的版本。测试库的默认值在源代码中定义。</li>
<li><code>-P, --pythonpath &lt;path&gt;</code>：搜索库和资源的额外位置，类似于运行测试时的情况。</li>
<li><code>--quiet</code>：不将生成的输出文件的路径打印到控制台。这是 Robot Framework 4.0 中的新功能。</li>
<li><code>-h, --help</code>：打印此帮助。</li>
</ul>
<h4 id="执行-Libdoc"><a href="#执行-Libdoc" class="headerlink" title="执行 Libdoc"></a>执行 Libdoc</h4><p>运行 Libdoc 的最简单方法是使用作为正常安装的一部分创建的 <code>libdoc</code> 命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libdoc ExampleLibrary ExampleLibrary.html</span><br></pre></td></tr></table></figure></div>

<p>另一种可能性是直接执行 <code>robot.libdoc</code> 模块。如果使用多个 Python 版本安装了 Robot Framework，并希望使用 Libdoc 的特定版本，这种方法特别有用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m robot.libdoc ExampleLibrary ExampleLibrary.html</span><br><span class="line">python3.9 -m robot.libdoc ExampleLibrary ExampleLibrary.html</span><br></pre></td></tr></table></figure></div>

<p>还有另一种选择是作为脚本运行 <code>robot.libdoc</code> 模块：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python path/to/robot/libdoc.py ExampleLibrary ExampleLibrary.html</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>单独的 <code>libdoc</code> 命令是 Robot Framework 4.0 中的新功能。</p>

    </div>
  </div>

<h4 id="指定库或资源文件"><a href="#指定库或资源文件" class="headerlink" title="指定库或资源文件"></a>指定库或资源文件</h4><h5 id="Python-库和动态库的名称或路径"><a href="#Python-库和动态库的名称或路径" class="headerlink" title="Python 库和动态库的名称或路径"></a>Python 库和动态库的名称或路径</h5><p>在为使用 Python 或使用动态库 API 实现的库编写文档时，可以通过仅使用库名称或库源代码的路径来指定库：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libdoc ExampleLibrary ExampleLibrary.html</span><br><span class="line">libdoc src/ExampleLibrary.py docs/ExampleLibrary.html</span><br></pre></td></tr></table></figure></div>

<p>在前一种情况下，将使用模块搜索路径搜索库，其名称必须与在 Robot Framework 测试数据中导入库时的格式相同。</p>
<p>如果这些库在导入时需要参数，则必须使用两个冒号将参数与库名称或路径连接，如 <code>MyLibrary::arg1::arg2</code>。如果参数更改了库提供的关键字或以其他方式更改了其文档，那么使用 <code>--name</code> 选项也更改库名称可能是个好主意。</p>
<h5 id="资源文件的路径"><a href="#资源文件的路径" class="headerlink" title="资源文件的路径"></a>资源文件的路径</h5><p>资源文件必须始终使用路径指定：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libdoc example.resource example.html</span><br></pre></td></tr></table></figure></div>

<p>如果路径不存在，资源文件也会从执行测试用例时的所有目录的模块搜索路径中搜索。</p>
<h4 id="Libdoc-规范文件"><a href="#Libdoc-规范文件" class="headerlink" title="Libdoc 规范文件"></a>Libdoc 规范文件</h4><p>也可以使用先前生成的 Libdoc XML 或 JSON 规范文件作为输入。如果规范文件使用 <code>*.xml</code>、<code>*.libspec</code> 或 <code>*.json</code> 扩展名，这将起作用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libdoc Example.xml Example.html</span><br><span class="line">libdoc Example.libspec Example.html</span><br><span class="line">libdoc Example.json Example.html</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>对 <code>*.libspec</code> 扩展名的支持是 Robot Framework 3.2 中的新功能。</p>
<p>对 <code>*.json</code> 扩展名的支持是 Robot Framework 4.0 中的新功能。</p>

    </div>
  </div>

<h4 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h4><p>Libdoc 可以生成 HTML（供人类阅读）以及 XML 或 JSON（供工具使用）格式的文档。写入文档的文件是在库&#x2F;资源名称或路径之后作为第二个参数指定的，输出格式默认从输出文件扩展名中获取。</p>
<h5 id="Libdoc-HTML-文档"><a href="#Libdoc-HTML-文档" class="headerlink" title="Libdoc HTML 文档"></a>Libdoc HTML 文档</h5><p>大多数 Robot Framework 库使用 Libdoc 生成 HTML 格式的库文档。因此，这种格式对于使用过 Robot Framework 的大多数人来说都很熟悉。下面可以看到一个简单的示例，它是基于本节稍后找到的示例生成的。</p>
<p>HTML 文档从库的一般介绍开始，然后是关于导入库时的配置（如果适用），最后是所有关键字的快捷方式和关键字本身。右下角的放大镜图标打开关键字搜索对话框，也可以通过简单地按 s 键打开。</p>
<p>如果输出文件扩展名为 <code>*.html</code>，Libdoc 会自动创建 HTML 文档。如果需要使用其他扩展名，可以使用 <code>--format</code> 选项显式指定格式。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libdoc OperatingSystem OperatingSystem.html</span><br><span class="line">libdoc --name MyLibrary Remote::http://10.0.0.42:8270 MyLibrary.html</span><br><span class="line">libdoc --format HTML test/resource.robot doc/resource.htm</span><br></pre></td></tr></table></figure></div>

<h5 id="Libdoc-XML-规范文件"><a href="#Libdoc-XML-规范文件" class="headerlink" title="Libdoc XML 规范文件"></a>Libdoc XML 规范文件</h5><p>Libdoc 也可以生成适合外部工具（如编辑器）使用的 XML 格式的文档。它包含与 HTML 格式相同的所有信息，但以机器可读的格式提供。</p>
<p>XML 规范文件还包含库和关键字源信息，因此库和每个关键字可以有源路径（source 属性）和行号（lineno 属性）。源路径相对于生成规范文件的目录，因此如果规范被移动，它不会引用正确的文件。如果关键字的源路径与库的源路径相同，则省略关键字的源路径，如果由于任何原因从库获取源路径和行号失败，则省略源路径和行号。</p>
<p>如果输出文件扩展名为 <code>*.xml</code> 或 <code>*.libspec</code>，Libdoc 会自动使用 XML 格式。当使用特殊的 <code>*.libspec</code> 扩展名时，Libdoc 会自动启用选项 <code>-f XML -s HTML</code>，这意味着创建一个 XML 输出文件，其中关键字文档被转换为 HTML。如果需要，可以使用 <code>--format</code> 选项显式设置格式。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libdoc OperatingSystem OperatingSystem.xml</span><br><span class="line">libdoc test/resource.robot doc/resource.libspec</span><br><span class="line">libdoc --format xml MyLibrary MyLibrary.spec</span><br><span class="line">libdoc --format xml -s html MyLibrary MyLibrary.xml</span><br></pre></td></tr></table></figure></div>

<p>准确的 Libdoc 规范文件格式在 <a class="link"   target="_blank" rel="noopener" href="https://github.com/robotframework/robotframework/tree/master/doc/schema" >https://github.com/robotframework/robotframework/tree/master/doc/schema <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 上有一个 XML 架构（XSD）进行了文档化。规范文件格式可能会在 Robot Framework 的主要版本之间发生变化。</p>
<p>为了让外部工具更容易知道如何解析某个规范文件，规范文件的根元素有一个专用的 <code>specversion</code> 属性。它在 Robot Framework 3.2 中添加，值为 2，早期的规范文件可以认为版本为 1。如果有变化，将来会增加规范版本。Robot Framework 4.0 引入了新的规范版本 3，与早期版本不兼容。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.2 中引入的 XML:HTML 格式已被 LIBSPEC 格式或选项组合 <code>--format XML --specdocformat HTML</code> 替代。</p>
<p>在 Robot Framework 3.2 中新增了包含源信息和规范版本。</p>

    </div>
  </div>

<h5 id="Libdoc-JSON-规范文件"><a href="#Libdoc-JSON-规范文件" class="headerlink" title="Libdoc JSON 规范文件"></a>Libdoc JSON 规范文件</h5><p>自 Robot Framework 4.0 起，Libdoc 也可以生成适合外部工具（如编辑器或网页）使用的 JSON 格式的文档。它包含与 HTML 格式相同的所有信息，但以机器可读的格式提供。</p>
<p>与 XML 规范文件类似，JSON 规范文件包含所有信息，也可以作为 Libdoc 的输入。从该格式可以创建任何其他输出格式。默认情况下，库文档字符串在 JSON 输出文件中被转换为 HTML 格式。</p>
<p>JSON 规范文件的确切格式在 <a class="link"   target="_blank" rel="noopener" href="https://github.com/robotframework/robotframework/tree/master/doc/schema" >https://github.com/robotframework/robotframework/tree/master/doc/schema <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 上有一个 JSON 架构进行了文档化。规范文件格式可能会在 Robot Framework 的主要版本之间发生变化。</p>
<h4 id="在控制台查看信息"><a href="#在控制台查看信息" class="headerlink" title="在控制台查看信息"></a>在控制台查看信息</h4><p>Libdoc 有三个特殊的命令可以在控制台上显示信息。这些命令用于替代输出文件的名称，它们也可以接受额外的参数。</p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>列出库&#x2F;资源包含的关键字的名称。可以通过传递可选的模式作为参数来限制只显示某些关键字。如果关键字的名称包含给定的模式，则列出关键字。</p>
<h5 id="show"><a href="#show" class="headerlink" title="show"></a>show</h5><p>显示库&#x2F;资源的文档。可以通过传递名称作为参数来限制只显示某些关键字。如果关键字的名称与任何给定的名称匹配，则显示关键字。特殊参数 <code>intro</code> 将只显示库的介绍和导入部分。</p>
<h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>显示库版本</p>
<p>给 <code>list</code> 和 <code>show</code> 提供的可选模式不区分大小写和空格。两者都接受 <code>*</code> 和 <code>?</code> 作为通配符。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libdoc Dialogs list</span><br><span class="line">libdoc SeleniumLibrary list browser</span><br><span class="line">libdoc Remote::10.0.0.42:8270 show</span><br><span class="line">libdoc Dialogs show PauseExecution execute*</span><br><span class="line">libdoc SeleniumLibrary show intro</span><br><span class="line">libdoc SeleniumLibrary version</span><br></pre></td></tr></table></figure></div>

<h4 id="编写文档"><a href="#编写文档" class="headerlink" title="编写文档"></a>编写文档</h4><p>本节讨论为使用静态库 API 的基于 Python 的测试库以及动态库和资源文件编写文档。在用户指南的其他地方详细描述了创建测试库和资源文件。</p>
<h5 id="Python-库"><a href="#Python-库" class="headerlink" title="Python 库"></a>Python 库</h5><p>使用静态库 API 的 Python 库的文档简单地写为库类或模块以及实现关键字的方法的文档字符串。方法文档的第一行被视为关键字的简短文档（例如，用作生成的 HTML 文档中链接的工具提示），因此它应尽可能描述，但不应过长。</p>
<p>下面的简单示例说明了如何一般地编写文档。可以看到基于此示例生成的 HTML 文档是什么样子，本章末尾还有一个稍长的示例。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleLibrary</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用于演示目的的库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这个库只用于一个示例，它没有做任何有用的事情。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_keyword</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;什么都不做。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">your_keyword</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;接受一个参数并且*不对其做任何事情*。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        示例：</span></span><br><span class="line"><span class="string">        | Your Keyword | xxx |</span></span><br><span class="line"><span class="string">        | Your Keyword | yyy |</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>如果库做了一些初始化工作，那么在使用 Libdoc 时不应该做，可以轻松地检测 Robot Framework 是否正在运行</p>
<p>有关 Python 文档字符串的更多信息，请参阅 PEP-257。</p>

    </div>
  </div>

<h5 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h5><p>为了能够为动态库生成有意义的文档，库必须使用 <code>get_keyword_arguments</code> 和 <code>get_keyword_documentation</code> 方法（或使用它们的驼峰命名变体 <code>getKeywordArguments</code> 和 <code>getKeywordDocumentation</code>）返回关键字参数名称和文档。库还可以通过特殊的 <code>__intro__</code> 和 <code>__init__</code> 值支持一般的库文档。</p>
<p>有关如何创建这些方法的更多信息，请参阅动态库 API 部分。</p>
<h5 id="导入部分"><a href="#导入部分" class="headerlink" title="导入部分"></a>导入部分</h5><p>根据其初始化方法，创建了关于如何导入库的单独部分。如果库有一个 <code>__init__</code> 方法，除了 <code>self</code> 之外还需要参数，那么将显示其文档和参数。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestLibrary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mode=<span class="string">&#x27;default&#x27;</span></span>)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建新的 TestLibrary。`mode` 参数用于确定模式。&quot;&quot;&quot;</span></span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_keyword</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据给定的 `arg` 做一些事情。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        所做的事情取决于在 `importing` 库时指定的 `mode`。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;secret&#x27;</span>:</span><br><span class="line">             <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<h5 id="资源文件文档"><a href="#资源文件文档" class="headerlink" title="资源文件文档"></a>资源文件文档</h5><p>资源文件中的关键字可以使用 <code>[Documentation]</code> 设置进行文档化，Libdoc 也使用此文档。文档的第一行（直到第一个隐式换行符或显式 <code>\n</code>）被视为与测试库类似的简短文档。</p>
<p>资源文件本身也可以在设置部分有文档，用于记录整个资源文件。</p>
<p>资源文件中的可能变量不能被文档化。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation    用于演示目的的资源文件。</span><br><span class="line">...              这个资源只用于一个示例，它没有做任何有用的事情。</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">My Keyword</span><br><span class="line">    [Documentation]   什么都不做</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Your Keyword</span><br><span class="line">    [Arguments]  $&#123;arg&#125;</span><br><span class="line">    [Documentation]   接受一个参数并且*不对其做任何事情*。</span><br><span class="line">    ...</span><br><span class="line">    ...    示例：</span><br><span class="line">    ...    | Your Keyword | xxx |</span><br><span class="line">    ...    | Your Keyword | yyy |</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div>

<p>​                                        </p>
<h5 id="文档语法"><a href="#文档语法" class="headerlink" title="文档语法"></a>文档语法</h5><p>Libdoc 支持 Robot Framework 自己的文档语法、HTML、纯文本和 reStructuredText。可以在库源代码中使用 <code>ROBOT_LIBRARY_DOC_FORMAT</code> 属性或使用 <code>--docformat (-F)</code> 选项从命令行给出要使用的格式。在这两种情况下，可能的不区分大小写的值是 <code>ROBOT</code>（默认）、<code>HTML</code>、<code>TEXT</code> 和 <code>reST</code>。</p>
<p>Robot Framework 自己的文档格式是默认的，通常推荐的格式。其他格式在使用现有代码和现有文档的测试库中特别有用。</p>
<h6 id="Robot-Framework-文档语法"><a href="#Robot-Framework-文档语法" class="headerlink" title="Robot Framework 文档语法"></a>Robot Framework 文档语法</h6><p>Robot Framework 的文档语法中最重要的特性是使用 <code>*bold*</code> 和 <code>_italic_</code> 进行格式化，自定义链接和自动将 URL 转换为链接，以及使用管道字符简单地创建表格和预格式化文本块（对于示例很有用）。如果文档变得更长，支持章节标题也可能很方便。</p>
<p>下面的示例说明了一些最重要的格式化特性。注意，由于这是默认格式，因此无需使用 <code>ROBOT_LIBRARY_DOC_FORMAT</code> 属性，也无需从命令行给出格式。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Robot Framework 格式的示例库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 使用 *bold* 和 _italic_ 进行格式化。</span></span><br><span class="line"><span class="string">- URLs 如 http://example.com 会被转换为链接。</span></span><br><span class="line"><span class="string">- 支持自定义链接，如 [http://robotframework.org|Robot Framework]。</span></span><br><span class="line"><span class="string">- 可以链接到 `My Keyword`。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_keyword</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这里没有更多内容。&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<h6 id="自动创建目录"><a href="#自动创建目录" class="headerlink" title="自动创建目录"></a>自动创建目录</h6><p>对于较大的库，通常有必要在库介绍中添加目录。当使用 Robot Framework 文档格式时，可以通过在自己的一行中添加一个特殊的 <code>%TOC%</code> 标记来自动完成此操作。目录是根据介绍中使用的顶级章节标题（例如 <code>= Section =</code>）创建的。除此之外，TOC 还获取到自动创建的快捷方式和关键字以及适用时的导入和标签部分的链接。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;演示 TOC 生成的示例库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%TOC% 标记只创建实际的目录，可能的</span></span><br><span class="line"><span class="string">标题或其他解释需要像下面这样单独添加。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 目录 ==</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%TOC%</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">= 章节标题 =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">顶级章节标题会自动添加到 TOC。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">= 第二章节 =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">== 子章节 ==</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">子章节标题不会添加到 TOC。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_keyword</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这里没有更多内容。&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.2 中，自动 TOC 生成是新功能。</p>

    </div>
  </div>

<h6 id="HTML-文档语法"><a href="#HTML-文档语法" class="headerlink" title="HTML 文档语法"></a>HTML 文档语法</h6><p>当使用 HTML 格式时，可以使用任何语法自由地创建文档。主要的缺点是 HTML 标记不是那么人性化，这可能使源代码中的文档难以维护和阅读。HTML 格式的文档由 Libdoc 直接使用，无需任何转换或转义。然而，支持使用像 <code>My Keyword</code> 这样的语法链接到关键字的特殊语法。</p>
<p>下面的示例包含与前一个示例相同的格式化示例。现在必须使用 <code>ROBOT_LIBRARY_DOC_FORMAT</code> 属性或在命令行上像 <code>--docformat HTML</code> 这样给出格式。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;HTML 格式的示例库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;使用 &lt;b&gt;bold&lt;/b&gt; 和 &lt;i&gt;italic&lt;/i&gt; 进行格式化。</span></span><br><span class="line"><span class="string">  &lt;li&gt;URL 不会自动转换为链接。</span></span><br><span class="line"><span class="string">  &lt;li&gt;支持自定义链接，如 &lt;a href=&quot;http://www.w3.org/html&quot;&gt;HTML&lt;/a&gt;。</span></span><br><span class="line"><span class="string">  &lt;li&gt;可以链接到 `My Keyword`。</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">ROBOT_LIBRARY_DOC_FORMAT = <span class="string">&#x27;HTML&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_keyword</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这里没有更多内容。&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h4 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h4><p>Libdoc 支持在文档中对关键字和不同章节进行内部链接。链接是通过将目标名称用反引号字符（如 <code>target</code>）包围来完成的。目标名称不区分大小写，可能的目标在后续章节中有解释。</p>
<p>如果找不到链接目标，不会有错误或警告，而是 Libdoc 只将其中的文本格式化为斜体。早期，当引用关键字参数时，推荐使用这种格式，但这可能会意外地创建内部链接。现在，推荐使用双反引号（如 <code>argument</code>）代替内联代码样式。未来可能会删除旧的单反引号格式，以便在找不到链接目标时给出错误。</p>
<p>除了以下章节中的示例外，还在本章末尾的较长示例中显示了内部链接和参数格式化。</p>
<h5 id="链接到关键字"><a href="#链接到关键字" class="headerlink" title="链接到关键字"></a>链接到关键字</h5><p>库中的所有关键字都会自动创建链接目标，可以使用 <code>Keyword Name</code> 语法进行链接。下面的示例说明了两个关键字都有链接到对方。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>(<span class="params">log_level=<span class="string">&quot;INFO&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;做一些事情并使用给定的级别记录输出。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `log level` 的有效值是 &quot;INFO&quot;（默认）&quot;DEBUG&quot; 和 &quot;TRACE&quot;。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    另请参见 `Another Keyword`。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">another_keyword</span>(<span class="params">argument, log_level=<span class="string">&quot;INFO&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对给定的参数做一些事情并记录输出。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    有关有效日志级别的信息，请参见 `Keyword`。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></div>

<p>注意</p>
<p>当使用 reStructuredText 文档语法时，必须像 <code>Keyword Name</code> 这样转义反引号。</p>
<h5 id="链接到自动章节"><a href="#链接到自动章节" class="headerlink" title="链接到自动章节"></a>链接到自动章节</h5><p>Libdoc 生成的文档总是包含库的整体介绍和关键字的章节。如果库本身需要参数，还有一个单独的导入章节。如果任何关键字有标签，概览中也会显示它们的单独选择器。</p>
<p>所有章节都充当可以链接的目标，可能的目标名称列在下表中。在下一节的示例中显示了如何使用这些目标。</p>
<table>
<thead>
<tr>
<th>章节</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>介绍</td>
<td><code>introduction</code> 和 <code>library introduction</code></td>
</tr>
<tr>
<td>导入</td>
<td><code>importing</code> 和 <code>library importing</code></td>
</tr>
<tr>
<td>关键字</td>
<td><code>keywords</code></td>
</tr>
</tbody></table>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 4.0 之前，还有标签和快捷方式的章节。在 Robot Framework 4.0 中，这些已被概览菜单取代。这意味着之前链接到快捷方式或标签章节的链接不再工作。</p>

    </div>
  </div>

<h5 id="链接到自定义章节"><a href="#链接到自定义章节" class="headerlink" title="链接到自定义章节"></a>链接到自定义章节</h5><p>Robot Framework 的文档语法支持自定义章节标题，库或资源文件介绍中使用的标题会自动创建链接目标。下面的示例说明了如何链接到自动和自定义章节：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;用于 Libdoc 演示目的的库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这个库没有做任何有用的事情。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">= 我的章节  =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们确实在文档中有一个自定义章节。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyword</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;什么都不做。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    有关更多信息，请参见 `introduction`，并参见 `My section` 以测试如何</span></span><br><span class="line"><span class="string">    链接到自定义章节。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>只有在使用 Robot Framework 文档语法时，才能链接到自定义章节。</p>

    </div>
  </div>

<h4 id="表示参数"><a href="#表示参数" class="headerlink" title="表示参数"></a>表示参数</h4><p>Libdoc 会自动显示关键字参数的信息。</p>
<p>包含的信息 以下信息将显示所有关键字，无论它们是在库中实现还是在资源文件中实现：</p>
<ul>
<li>参数名称。用户关键字参数显示时不带 <code>$&#123;&#125;</code> 装饰，使得无论关键字来自何处，参数看起来都是一样的。</li>
<li>标记告诉参数是仅位置、仅命名、自由位置、自由命名，还是可以通过位置或名称给出的普通参数。</li>
<li>可能的默认值。显示为 <code>= 42</code>。</li>
<li>可能的类型。显示为 <code>&lt;int&gt;</code>。可以是链接到下一节解释的类型文档。</li>
</ul>
<p>在关键字文档中引用参数时，建议使用内联代码样式，如 <code>argument</code>。</p>
<h5 id="自动列出类型文档"><a href="#自动列出类型文档" class="headerlink" title="自动列出类型文档"></a>自动列出类型文档</h5><p>如上所述，Libdoc 在列出参数时会自动显示可能的类型信息。如果类型是基于 Enum 或 TypedDict 的自定义类型，类型会被自动转换，或者类型有自定义转换器，那么类型本身也会单独列出以显示更多关于它的信息。当这些类型用于参数时，类型名称也会变成链接到类型信息的链接。</p>
<p>所有列出的数据类型都显示可能的类型文档以及支持的参数类型。此外，基于 Enum 的类型列出可用的成员，基于 TypedDict 的类型显示字典结构。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 4.0 中，基于 Enum 和 TypedDict 的类型的自动列出是新功能。在 Robot Framework 5.0 中，列出其他类型是新功能。</p>

    </div>
  </div>

<h4 id="Libdoc-示例"><a href="#Libdoc-示例" class="headerlink" title="Libdoc 示例"></a>Libdoc 示例</h4><p>以下示例说明了如何使用最重要的文档格式化可能性、内部链接等。点击这里查看生成的文档是什么样子。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingLibrary</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用于记录消息的库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    = 目录 =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    %TOC%</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    = 使用 =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这个库有几个关键字，例如 `Log Message`，用于记录消息。实际上，这个库只用于 _Libdoc_ 演示目的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    = 有效的日志级别 =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    有效的日志级别是 ``INFO``，``DEBUG`` 和 ``TRACE``。默认的日志级别可以在 `importing` 时设置。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    = 示例 =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意示例中的关键字是如何链接的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    | `Log Message`      | My message    |                |               |</span></span><br><span class="line"><span class="string">    | `Log Two Messages` | My message    | Second message | level=DEBUG   |</span></span><br><span class="line"><span class="string">    | `Log Messages`     | First message | Second message | Third message |</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ROBOT_LIBRARY_VERSION = <span class="string">&#x27;0.1&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, default_level=<span class="string">&#x27;INFO&#x27;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;可以在库导入时给出默认的日志级别。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        有关可用日志级别的信息，请参见 `Valid log levels` 章节。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        示例：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        | =Setting= |     =Value=    | =Value= |          =Comment=         |</span></span><br><span class="line"><span class="string">        | Library   | LoggingLibrary |         | # 使用默认级别 (INFO) |</span></span><br><span class="line"><span class="string">        | Library   | LoggingLibrary | DEBUG   | # 使用给定的级别      |</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.default_level = self._verify_level(default_level)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_verify_level</span>(<span class="params">self, level</span>):</span><br><span class="line">        level = level.upper()</span><br><span class="line">        <span class="keyword">if</span> level <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;INFO&#x27;</span>, <span class="string">&#x27;DEBUG&#x27;</span>, <span class="string">&#x27;TRACE&#x27;</span>]:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;无效的日志级别&#x27;%s&#x27;。有效的级别是 &quot;</span></span><br><span class="line">                               <span class="string">&quot;&#x27;INFO&#x27;, &#x27;DEBUG&#x27;, 和 &#x27;TRACE&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_message</span>(<span class="params">self, message, level=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用指定的日志级别将给定的消息写入日志文件。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        要记录的消息和要使用的日志级别分别由</span></span><br><span class="line"><span class="string">        ``message`` 和 ``level`` 参数定义。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        如果没有给出日志级别，则使用在 `library</span></span><br><span class="line"><span class="string">        importing` 时给出的默认级别。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        level = self._verify_level(level) <span class="keyword">if</span> level <span class="keyword">else</span> self.default_level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*%s* %s&quot;</span> % (level, message))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_two_messages</span>(<span class="params">self, message1, message2, level=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用指定的日志级别将给定的消息写入日志文件。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        有关更多信息，请参见 `Log Message` 关键字。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.log_message(message1, level)</span><br><span class="line">        self.log_message(message2, level)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_messages</span>(<span class="params">self, *messages</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用在 `importing` 时设置的日志级别记录给定的消息。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        另请参见 `Log Message` 和 `Log Two Messages`。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> msg <span class="keyword">in</span> messages:</span><br><span class="line">            self.log_message(msg)</span><br></pre></td></tr></table></figure></div>

<p>所有标准库都有由 Libdoc 生成的文档，它们的文档（和源代码）作为更现实的示例。</p>
<h3 id="测试数据文档工具（Testdoc）"><a href="#测试数据文档工具（Testdoc）" class="headerlink" title="测试数据文档工具（Testdoc）"></a>测试数据文档工具（Testdoc）</h3><p>Testdoc 是 Robot Framework 的内置工具，用于基于测试用例生成高级文档。创建的文档是 HTML 格式，包括每个测试套件和测试用例的名称、文档和其他元数据，以及顶级关键字及其参数。</p>
<h4 id="一般使用-1"><a href="#一般使用-1" class="headerlink" title="一般使用"></a>一般使用</h4><h5 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h5><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m robot.testdoc [options] data_sources output_file</span><br></pre></td></tr></table></figure></div>

<h5 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h5><ul>
<li><code>-T, --title &lt;title&gt;</code> 设置生成的文档的标题。标题中的下划线会被转换为空格。默认标题是顶级套件的名称。</li>
<li><code>-N, --name &lt;name&gt;</code> 覆盖顶级测试套件的名称。</li>
<li><code>-D, --doc &lt;doc&gt;</code> 覆盖顶级测试套件的文档。</li>
<li><code>-M, --metadata &lt;name:value&gt;</code> 设置&#x2F;覆盖顶级测试套件的自由元数据。</li>
<li><code>-G, --settag &lt;tag&gt;</code> 将给定的标签设置到所有测试用例。</li>
<li><code>-t, --test &lt;name&gt;</code> 通过名称包含测试。</li>
<li><code>-s, --suite &lt;name&gt;</code> 通过名称包含套件。</li>
<li><code>-i, --include &lt;tag&gt;</code> 通过标签包含测试。</li>
<li><code>-e, --exclude &lt;tag&gt;</code> 通过标签排除测试。</li>
<li><code>-A, --argumentfile &lt;path&gt;</code> 文本文件，从中读取更多参数。与运行测试时的参数文件工作方式完全相同。</li>
<li><code>-h, --help</code> 在控制台打印此帮助。</li>
</ul>
<p>除了 <code>--title</code> 之外，所有选项的语义与执行测试用例时的相同选项完全相同。</p>
<h4 id="生成文档-1"><a href="#生成文档-1" class="headerlink" title="生成文档"></a>生成文档</h4><p>数据可以作为单个文件、目录或多个文件和目录给出。在所有这些情况下，最后一个参数必须是要写入输出的文件。</p>
<p>Testdoc 可以作为已安装的模块执行，如 <code>python -m robot.testdoc</code>，或作为脚本执行，如 <code>python path/robot/testdoc.py</code>。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m robot.testdoc my_test.robot testdoc.html</span><br><span class="line">python path/to/robot/testdoc.py --name &quot;Smoke tests&quot; --include smoke path/to/tests smoke.html</span><br></pre></td></tr></table></figure></div>

<h4 id="测试数据清理工具（Tidy）"><a href="#测试数据清理工具（Tidy）" class="headerlink" title="测试数据清理工具（Tidy）"></a>测试数据清理工具（Tidy）</h4><p>内置的 Tidy 工具在 Robot Framework 4.1 中被弃用，取而代之的是新的和增强的外部 Robotidy 工具。它在 Robot Framework 5.0 中被完全移除。</p>
<h4 id="外部工具"><a href="#外部工具" class="headerlink" title="外部工具"></a>外部工具</h4><p>有许多外部工具可以与 Robot Framework 一起使用。这些工具包括各种 IDE 和文本编辑器的插件，用于并行执行和数据驱动测试的工具，用于持续集成系统的插件等。</p>
<p>这些工具作为与 Robot Framework 本身独立的单独项目进行开发。有关可用工具的列表，请参见 <a class="link"   target="_blank" rel="noopener" href="http://robotframework.org/%E3%80%82" >http://robotframework.org/。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="可用设置"><a href="#可用设置" class="headerlink" title="可用设置"></a>可用设置</h3><p>此附录列出了可以在不同部分使用的所有设置。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>设置可以本地化。请参阅支持的翻译附录以获取更多信息。 </p>

    </div>
  </div>

<h4 id="设置部分-1"><a href="#设置部分-1" class="headerlink" title="设置部分"></a>设置部分</h4><p>设置部分用于导入库、资源文件和变量文件，并为测试套件和测试用例定义元数据。它可以包含在测试用例文件和资源文件中。请注意，在资源文件中，设置部分只能包含导入库、资源和变量的设置。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Library</td>
<td>用于导入库</td>
</tr>
<tr>
<td>Resource</td>
<td>用于使用资源文件</td>
</tr>
<tr>
<td>Variables</td>
<td>用于使用变量文件</td>
</tr>
<tr>
<td>Name</td>
<td>用于设置自定义套件名称</td>
</tr>
<tr>
<td>Documentation</td>
<td>用于指定套件或资源文件文档</td>
</tr>
<tr>
<td>Metadata</td>
<td>用于设置自由套件元数据</td>
</tr>
<tr>
<td>Suite Setup</td>
<td>用于指定套件设置</td>
</tr>
<tr>
<td>Suite Teardown</td>
<td>用于指定套件拆卸</td>
</tr>
<tr>
<td>Test Tags</td>
<td>用于为套件中的所有测试指定测试用例标签</td>
</tr>
<tr>
<td>Force Tags, Default Tags</td>
<td>已弃用的设置，用于指定测试用例标签</td>
</tr>
<tr>
<td>Keyword Tags</td>
<td>用于为某个文件中的所有用户关键字指定用户关键字标签</td>
</tr>
<tr>
<td>Test Setup</td>
<td>用于指定默认测试设置</td>
</tr>
<tr>
<td>Test Teardown</td>
<td>用于指定默认测试拆卸</td>
</tr>
<tr>
<td>Test Template</td>
<td>用于指定测试用例的默认模板关键字</td>
</tr>
<tr>
<td>Test Timeout</td>
<td>用于指定默认测试用例超时</td>
</tr>
<tr>
<td>Task Setup, Task Teardown, Task Template, Task Timeout</td>
<td>分别是 Test Setup, Test Teardown, Test Template 和 Test Timeout 的别名，可以在创建任务时使用</td>
</tr>
</tbody></table>
<h4 id="测试用例部分"><a href="#测试用例部分" class="headerlink" title="测试用例部分"></a>测试用例部分</h4><p>测试用例部分的设置始终特定于为其定义的测试用例。这些设置中的一些会覆盖在设置部分定义的默认值。</p>
<p>在任务部分创建任务时，可以使用完全相同的设置。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[Documentation]</td>
<td>用于指定测试用例文档</td>
</tr>
<tr>
<td>[Tags]</td>
<td>用于标记测试用例</td>
</tr>
<tr>
<td>[Setup]</td>
<td>用于指定测试设置</td>
</tr>
<tr>
<td>[Teardown]</td>
<td>用于指定测试拆解</td>
</tr>
<tr>
<td>[Template]</td>
<td>用于指定模板关键字</td>
</tr>
<tr>
<td>[Timeout]</td>
<td>用于指定测试用例超时</td>
</tr>
</tbody></table>
<h4 id="关键字部分"><a href="#关键字部分" class="headerlink" title="关键字部分"></a>关键字部分</h4><p>关键字部分中的设置特定于为其定义的用户关键字。</p>
<table>
<thead>
<tr>
<th>原文</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[Documentation]</td>
<td>用于指定用户关键字文档</td>
</tr>
<tr>
<td>[Tags]</td>
<td>用于指定用户关键字标签</td>
</tr>
<tr>
<td>[Arguments]</td>
<td>用于指定用户关键字参数</td>
</tr>
<tr>
<td>[Setup]</td>
<td>用于指定用户关键字设置，Robot Framework 7.0中的新功能</td>
</tr>
<tr>
<td>[Teardown]</td>
<td>用于指定用户关键字拆解</td>
</tr>
<tr>
<td>[Timeout]</td>
<td>用于指定用户关键字超时</td>
</tr>
<tr>
<td>[Return]</td>
<td>用于指定用户关键字返回值，已在Robot Framework 7.0中弃用，建议使用RETURN语句代替</td>
</tr>
</tbody></table>
<p>​              </p>
<h4 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h4><p>此附录列出了执行测试用例和后处理输出时可用的所有命令行选项。还列出了影响执行和后处理的环境变量。</p>
<h5 id="测试执行的命令行选项"><a href="#测试执行的命令行选项" class="headerlink" title="测试执行的命令行选项"></a>测试执行的命令行选项</h5><ul>
<li><code>--rpa</code>：开启通用自动化模式。</li>
<li><code>--language &lt;lang&gt;</code>：激活本地化。<code>lang</code> 可以是内置语言的名称或代码，或者是自定义语言文件的路径或模块名称。</li>
<li><code>-F, --extension &lt;value&gt;</code>：执行目录时，只解析这些文件。</li>
<li><code>-I, --parseinclude &lt;pattern&gt;</code>：执行目录时，只解析匹配的文件。</li>
<li><code>-N, --name &lt;name&gt;</code>：设置顶级测试套件的名称。</li>
<li><code>-D, --doc &lt;document&gt;</code>：设置顶级测试套件的文档。</li>
<li><code>-M, --metadata &lt;name:value&gt;</code>：为顶级测试套件设置自由元数据。</li>
<li><code>-G, --settag &lt;tag&gt;</code>：为所有执行的测试用例设置标签。</li>
<li><code>-t, --test &lt;name&gt;</code>：通过名称选择测试用例。</li>
<li><code>--task &lt;name&gt;</code>：执行任务时可以使用的 <code>--test</code> 的别名。</li>
<li><code>-s, --suite &lt;name&gt;</code>：通过名称选择测试套件。</li>
<li><code>-R, --rerunfailed &lt;file&gt;</code>：选择从早期输出文件中重新执行的失败测试。</li>
<li><code>-S, --rerunfailedsuites &lt;file&gt;</code>：选择从早期输出文件中重新执行的失败测试套件。</li>
<li><code>-i, --include &lt;tag&gt;</code>：通过标签选择测试用例。</li>
<li><code>-e, --exclude &lt;tag&gt;</code>：通过标签选择测试用例。</li>
<li><code>--skip &lt;tag&gt;</code>：具有给定标签的测试将被跳过。标签可以是模式。</li>
<li><code>--skiponfailure &lt;tag&gt;</code>：如果失败，具有给定标签的测试将被跳过。</li>
<li><code>-v, --variable &lt;name:value&gt;</code>：设置单个变量。</li>
<li><code>-V, --variablefile &lt;path:args&gt;</code>：使用变量文件设置变量。</li>
<li><code>-d, --outputdir &lt;dir&gt;</code>：定义创建输出文件的位置。</li>
<li><code>-o, --output &lt;file&gt;</code>：设置生成的输出文件的路径。</li>
<li><code>--legacyoutput</code>：以 Robot Framework 6.x 兼容格式创建输出文件。</li>
<li><code>-l, --log &lt;file&gt;</code>：设置生成的日志文件的路径。</li>
<li><code>-r, --report &lt;file&gt;</code>：设置生成的报告文件的路径。</li>
<li><code>-x, --xunit &lt;file&gt;</code>：设置生成的 xUnit 兼容结果文件的路径。</li>
<li><code>-b, --debugfile &lt;file&gt;</code>：在执行期间编写的调试文件。</li>
<li><code>-T, --timestampoutputs</code>：在上述输出文件中添加时间戳。</li>
<li><code>--splitlog</code>：将日志文件分割成较小的部分，可以在浏览器中透明地打开。</li>
<li><code>--logtitle &lt;title&gt;</code>：为生成的测试日志设置标题。</li>
<li><code>--reporttitle &lt;title&gt;</code>：为生成的测试报告设置标题。</li>
<li><code>--reportbackground &lt;colors&gt;</code>：设置生成的报告的背景颜色。</li>
<li><code>--maxerrorlines &lt;lines&gt;</code>：设置测试失败时报告中显示的错误行数。</li>
<li><code>--maxassignlength &lt;characters&gt;</code>：设置在日志中显示的变量分配的字符数。</li>
<li><code>-L, --loglevel &lt;level&gt;</code>：设置日志的阈值级别。可以选择性地给出默认可见日志级别，用冒号（:）分隔。</li>
<li><code>--suitestatlevel &lt;level&gt;</code>：定义在输出中的套件统计表中显示的级别数。</li>
<li><code>--tagstatinclude &lt;tag&gt;</code>：只在标签统计表中包含这些标签。</li>
<li><code>--tagstatexclude &lt;tag&gt;</code>：从标签统计表中排除这些标签。</li>
<li><code>--tagstatcombine &lt;tags:title&gt;</code>：基于标签创建组合统计。</li>
<li><code>--tagdoc &lt;pattern:doc&gt;</code>：为指定的标签添加文档。</li>
<li><code>--tagstatlink &lt;pattern:link:title&gt;</code>：在标签统计表中添加外部链接。</li>
<li><code>--expandkeywords &lt;name:pattern|tag:pattern&gt;</code>：在生成的日志文件中自动展开关键字。</li>
<li><code>--removekeywords &lt;all|passed|name:pattern|tag:pattern|for|while|wuks&gt;</code>：从生成的日志文件中删除关键字数据。</li>
<li><code>--flattenkeywords &lt;for|while|iteration|name:pattern|tag:pattern&gt;</code>：在生成的日志文件中展平关键字。</li>
<li><code>--listener &lt;name:args&gt;</code>：设置一个监听器以监视测试执行。</li>
<li><code>--nostatusrc</code>：无论测试用例是否失败，都将返回代码设置为零。错误代码正常返回。</li>
<li><code>--runemptysuite</code>：即使选择的测试套件为空，也执行测试。</li>
<li><code>--dryrun</code>：在干运行模式下，测试将在不执行来自测试库的关键字的情况下运行。对于验证测试数据语法很有用。</li>
<li><code>-X, --exitonfailure</code>：如果有任何测试失败，停止测试执行。</li>
<li><code>--exitonerror</code>：如果在解析测试数据、导入库等过程中发生任何错误，停止测试执行。</li>
<li><code>--skipteardownonexit</code>：如果测试执行提前停止，跳过拆卸。</li>
<li><code>--prerunmodifier &lt;name:args&gt;</code>：激活测试数据的程序化修改。</li>
<li><code>--prerebotmodifier &lt;name:args&gt;</code>：激活结果的程序化修改。</li>
<li><code>--randomize &lt;all|suites|tests|none&gt;</code>：随机化测试执行顺序。</li>
<li><code>--console &lt;verbose|dotted|quiet|none&gt;</code>：控制台输出类型。</li>
<li><code>--dotted</code>：<code>--console dotted</code>的快捷方式。</li>
<li><code>--quiet</code>：<code>--console quiet</code>的快捷方式。</li>
<li><code>-W, --consolewidth &lt;width&gt;</code>：设置控制台输出的宽度。</li>
<li><code>-C, --consolecolors &lt;auto|on|ansi|off&gt;</code>：指定控制台上使用的颜色。</li>
<li><code>-K, --consolemarkers &lt;auto|on|off&gt;</code>：当测试用例中的顶级关键字结束时，在控制台上显示标记。</li>
<li><code>-P, --pythonpath &lt;path&gt;</code>：添加到模块搜索路径的额外位置。</li>
<li><code>-A, --argumentfile &lt;path&gt;</code>：从中读取更多参数的文本文件。</li>
<li><code>-h, --help</code>：打印使用说明。</li>
<li><code>--version</code>：打印版本信息。</li>
</ul>
<h5 id="后处理输出的命令行选项"><a href="#后处理输出的命令行选项" class="headerlink" title="后处理输出的命令行选项"></a>后处理输出的命令行选项</h5><ul>
<li><code>--rpa</code>：开启通用自动化模式。</li>
<li><code>-R, --merge</code>：更改结果组合行为为合并。</li>
<li><code>-N, --name &lt;name&gt;</code>：设置顶级测试套件的名称。</li>
<li><code>-D, --doc &lt;document&gt;</code>：设置顶级测试套件的文档。</li>
<li><code>-M, --metadata &lt;name:value&gt;</code>：为顶级测试套件设置自由元数据。</li>
<li><code>-G, --settag &lt;tag&gt;</code>：为所有处理的测试用例设置标签。</li>
<li><code>-t, --test &lt;name&gt;</code>：通过名称选择测试用例。</li>
<li><code>--task &lt;name&gt;</code>：执行任务时可以使用的 <code>--test</code> 的别名。</li>
<li><code>-s, --suite &lt;name&gt;</code>：通过名称选择测试套件。</li>
<li><code>-i, --include &lt;tag&gt;</code>：通过标签选择测试用例。</li>
<li><code>-e, --exclude &lt;tag&gt;</code>：通过标签选择测试用例。</li>
<li><code>-d, --outputdir &lt;dir&gt;</code>：定义创建输出文件的位置。</li>
<li><code>-o, --output &lt;file&gt;</code>：设置生成的输出文件的路径。</li>
<li><code>--legacyoutput</code>：以 Robot Framework 6.x 兼容格式创建输出文件。</li>
<li><code>-l, --log &lt;file&gt;</code>：设置生成的日志文件的路径。</li>
<li><code>-r, --report &lt;file&gt;</code>：设置生成的报告文件的路径。</li>
<li><code>-x, --xunit &lt;file&gt;</code>：设置生成的 xUnit 兼容结果文件的路径。</li>
<li><code>-T, --timestampoutputs</code>：在上述输出文件中添加时间戳。</li>
<li><code>--splitlog</code>：将日志文件分割成较小的部分，可以在浏览器中透明地打开。</li>
<li><code>--logtitle &lt;title&gt;</code>：为生成的测试日志设置标题。</li>
<li><code>--reporttitle &lt;title&gt;</code>：为生成的测试报告设置标题。</li>
<li><code>--reportbackground &lt;colors&gt;</code>：设置生成的报告的背景颜色。</li>
<li><code>-L, --loglevel &lt;level&gt;</code>：设置选择日志消息的阈值级别。可以选择性地给出默认可见日志级别，用冒号（:）分隔。</li>
<li><code>--suitestatlevel &lt;level&gt;</code>：定义在输出中的套件统计表中显示的级别数。</li>
<li><code>--tagstatinclude &lt;tag&gt;</code>：只在标签统计表中包含这些标签。</li>
<li><code>--tagstatexclude &lt;tag&gt;</code>：从标签统计表中排除这些标签。</li>
<li><code>--tagstatcombine &lt;tags:title&gt;</code>：基于标签创建组合统计。</li>
<li><code>--tagdoc &lt;pattern:doc&gt;</code>：为指定的标签添加文档。</li>
<li><code>--tagstatlink &lt;pattern:link:title&gt;</code>：在标签统计表中添加外部链接。</li>
<li><code>--expandkeywords &lt;name:pattern|tag:pattern&gt;</code>：在生成的日志文件中自动展开关键字。</li>
<li><code>--removekeywords &lt;all|passed|name:pattern|tag:pattern|for|wuks&gt;</code>：从生成的输出中删除关键字数据。</li>
<li><code>--flattenkeywords &lt;for|foritem|name:pattern|tag:pattern&gt;</code>：在生成的输出中展平关键字。</li>
<li><code>--starttime &lt;timestamp&gt;</code>：创建报告时设置测试执行的开始时间。</li>
<li><code>--endtime &lt;timestamp&gt;</code>：创建报告时设置测试执行的结束时间。</li>
<li><code>--nostatusrc</code>：无论测试用例是否失败，都将返回代码设置为零。错误代码正常返回。</li>
<li><code>--processemptysuite</code>：即使文件包含空测试套件，也处理输出文件。</li>
<li><code>--prerebotmodifier &lt;name:args&gt;</code>：激活结果的程序化修改。</li>
<li><code>-C, --consolecolors &lt;auto|on|ansi|off&gt;</code>：指定控制台上使用的颜色。</li>
<li><code>-P, --pythonpath &lt;path&gt;</code>：添加到模块搜索路径的额外位置。</li>
<li><code>-A, --argumentfile &lt;path&gt;</code>：从中读取更多参数的文本文件。</li>
<li><code>-h, --help</code>：打印使用说明。</li>
<li><code>--version</code>：打印版本信息。</li>
</ul>
<h4 id="执行和后处理的环境变量"><a href="#执行和后处理的环境变量" class="headerlink" title="执行和后处理的环境变量"></a>执行和后处理的环境变量</h4><ul>
<li><code>ROBOT_OPTIONS</code> 和 <code>REBOT_OPTIONS</code>：默认选项的空格分隔列表，这些选项将放在命令行的任何显式选项前面。</li>
<li><code>ROBOT_SYSLOG_FILE</code>：Robot Framework 将解析测试用例文件和运行测试的内部信息写入的系统日志文件的路径。</li>
<li><code>ROBOT_SYSLOG_LEVEL</code>：写入系统日志文件时使用的日志级别。</li>
<li><code>ROBOT_INTERNAL_TRACES</code>：当设置为任何非空值时，Robot Framework 的内部方法将包含在错误跟踪中。</li>
</ul>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>Robot Framework 支持翻译部分标题、设置、在行为驱动开发（BDD）中使用的 Given&#x2F;When&#x2F;Then 前缀，以及在自动布尔参数转换中使用的 true 和 false 字符串。本附录列出了 Robot Framework 开箱即用支持的所有语言（不包括英语）的所有翻译。</p>
<p>如何实际激活翻译在本地化部分有解释。该部分还解释了如何创建自定义语言定义以及如何贡献新的翻译。</p>
<h4 id="简体中文-zh-CN"><a href="#简体中文-zh-CN" class="headerlink" title="简体中文 (zh-CN)"></a>简体中文 (zh-CN)</h4><h5 id="部分标题"><a href="#部分标题" class="headerlink" title="部分标题"></a>部分标题</h5><table>
<thead>
<tr>
<th>标题</th>
<th>翻译</th>
</tr>
</thead>
<tbody><tr>
<td>Settings</td>
<td>设置</td>
</tr>
<tr>
<td>Variables</td>
<td>变量</td>
</tr>
<tr>
<td>Test Cases</td>
<td>用例</td>
</tr>
<tr>
<td>Tasks</td>
<td>任务</td>
</tr>
<tr>
<td>Keywords</td>
<td>关键字</td>
</tr>
<tr>
<td>Comments</td>
<td>备注</td>
</tr>
</tbody></table>
<h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><table>
<thead>
<tr>
<th>设置</th>
<th>翻译</th>
</tr>
</thead>
<tbody><tr>
<td>Library</td>
<td>程序库</td>
</tr>
<tr>
<td>Resource</td>
<td>资源文件</td>
</tr>
<tr>
<td>Variables</td>
<td>变量文件</td>
</tr>
<tr>
<td>Name</td>
<td></td>
</tr>
<tr>
<td>Documentation</td>
<td>说明</td>
</tr>
<tr>
<td>Metadata</td>
<td>元数据</td>
</tr>
<tr>
<td>Suite Setup</td>
<td>用例集启程</td>
</tr>
<tr>
<td>Suite Teardown</td>
<td>用例集终程</td>
</tr>
<tr>
<td>Test Setup</td>
<td>用例启程</td>
</tr>
<tr>
<td>Task Setup</td>
<td>任务启程</td>
</tr>
<tr>
<td>Test Teardown</td>
<td>用例终程</td>
</tr>
<tr>
<td>Task Teardown</td>
<td>任务终程</td>
</tr>
<tr>
<td>Test Template</td>
<td>用例模板</td>
</tr>
<tr>
<td>Task Template</td>
<td>任务模板</td>
</tr>
<tr>
<td>Test Timeout</td>
<td>用例超时</td>
</tr>
<tr>
<td>Task Timeout</td>
<td>任务超时</td>
</tr>
<tr>
<td>Test Tags</td>
<td>用例标签</td>
</tr>
<tr>
<td>Task Tags</td>
<td>任务标签</td>
</tr>
<tr>
<td>Keyword Tags</td>
<td>关键字标签</td>
</tr>
<tr>
<td>Tags</td>
<td>标签</td>
</tr>
<tr>
<td>Setup</td>
<td>启程</td>
</tr>
<tr>
<td>Teardown</td>
<td>终程</td>
</tr>
<tr>
<td>Template</td>
<td>模板</td>
</tr>
<tr>
<td>Timeout</td>
<td>超时</td>
</tr>
<tr>
<td>Arguments</td>
<td>参数</td>
</tr>
</tbody></table>
<h5 id="BDD-前缀"><a href="#BDD-前缀" class="headerlink" title="BDD 前缀"></a>BDD 前缀</h5><table>
<thead>
<tr>
<th>前缀</th>
<th>翻译</th>
</tr>
</thead>
<tbody><tr>
<td>Given</td>
<td>假定</td>
</tr>
<tr>
<td>When</td>
<td>当</td>
</tr>
<tr>
<td>Then</td>
<td>那么</td>
</tr>
<tr>
<td>And</td>
<td>并且</td>
</tr>
<tr>
<td>But</td>
<td>但是</td>
</tr>
</tbody></table>
<h5 id="布尔字符串"><a href="#布尔字符串" class="headerlink" title="布尔字符串"></a>布尔字符串</h5><table>
<thead>
<tr>
<th>True&#x2F;False</th>
<th>Values</th>
</tr>
</thead>
<tbody><tr>
<td>True</td>
<td>真, 是, 开</td>
</tr>
<tr>
<td>False</td>
<td>假, 否, 关, 空</td>
</tr>
</tbody></table>
<p>​              </p>
<h4 id="文档格式化"><a href="#文档格式化" class="headerlink" title="文档格式化"></a>文档格式化</h4><p>在测试数据中，可以使用简单的 HTML 格式化对测试套件、测试用例和用户关键字文档以及自由套件元数据进行文档化，以及在文档化测试库时。这种格式化类似于大多数 wiki 中使用的样式，旨在使其既可以作为纯文本理解，也可以在 HTML 转换后理解。</p>
<h5 id="处理测试数据中的空白"><a href="#处理测试数据中的空白" class="headerlink" title="处理测试数据中的空白"></a>处理测试数据中的空白</h5><h5 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h5><p>在文档化测试套件、测试用例和用户关键字或向测试套件添加元数据时，可以使用 <code>\n</code> 转义序列手动添加换行符。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation    First line.\n\nSecond paragraph. This time\nwith multiple lines.</span><br><span class="line">Metadata         Example list    - first item\n- second item\n- third</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>如下面的段落部分所解释的，<code>Second paragraph, this time\nwith multiple lines.</code> 中的单个换行符实际上并不影响该段落的渲染。然而，创建列表或其他此类结构时需要换行符。</p>

    </div>
  </div>

<p>手动向长文档添加换行符需要一些努力，额外的字符也使文档更难阅读。不过，可以避免这种情况，因为在连续的文档和元数据行之间会自动插入换行符。实际上，这意味着上面的示例也可以按以下方式编写。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation</span><br><span class="line">...    First line.</span><br><span class="line">...</span><br><span class="line">...    Second paragraph. This time</span><br><span class="line">...    with multiple lines.</span><br><span class="line">Metadata</span><br><span class="line">...    Example list</span><br><span class="line">...    - first item</span><br><span class="line">...    - second item</span><br><span class="line">...    - third</span><br></pre></td></tr></table></figure></div>

<p>如果一行已经以字面换行符结束，或者以转义反斜杠结束，则不会添加自动换行符：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Ends with newline</span><br><span class="line">    [Documentation]    Ends with a newline and\n</span><br><span class="line">    ...                automatic newline is not added.</span><br><span class="line"></span><br><span class="line">Ends with backslash</span><br><span class="line">    [Documentation]    Ends with a backslash and \</span><br><span class="line">    ...                no newline is added.</span><br></pre></td></tr></table></figure></div>

<h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h5><p>与 Robot Framework 数据的其他地方不同，文档和元数据中保留了前导空格和连续的内部空格。例如，这使得可以将列表项分割到多行，并具有带空格的预格式化文本：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Long list item</span><br><span class="line">    [Documentation]</span><br><span class="line">    ...    List:</span><br><span class="line">    ...    - Short item.</span><br><span class="line">    ...    - Second item is pretty long and it is split to</span><br><span class="line">    ...      multiple rows. Leading spaces are preserved.</span><br><span class="line">    ...    - Another short item.</span><br><span class="line"></span><br><span class="line">Preformatted text</span><br><span class="line">    [Documentation]</span><br><span class="line">    ...    Example with consecutive internal spaces:</span><br><span class="line">    ...</span><br><span class="line">    ...    | *** Test Cases ***</span><br><span class="line">    ...    | Example</span><br><span class="line">    ...    |     Keyword</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 6.1 中，文档和元数据中保留空格是新的。在早期版本中，需要使用反斜杠转义空格。</p>

    </div>
  </div>

<h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>在格式化的 HTML 文档中，所有常规文本都表示为段落。实际上，无论换行符是手动添加的还是自动添加的，单个换行符分隔的行将被组合成一个段落。可以使用空行（即两个换行符）分隔多个段落，而且在后续部分讨论的表格、列表和其他特殊格式化块也会结束一个段落。</p>
<p>例如，以下测试套件或资源文件文档：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation</span><br><span class="line">...    First paragraph has only one line.</span><br><span class="line">...</span><br><span class="line">...    Second paragraph, this time created</span><br><span class="line">...    with multiple lines.</span><br></pre></td></tr></table></figure></div>

<p>将被格式化为 HTML：</p>
<p>第一段只有一行。</p>
<p>第二段，这次创建了多行。</p>
<h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>文档语法支持粗体、斜体和代码的内联样式。可以通过在选定的单词或单词前后添加一个星号来创建粗体文本，例如 <em>这是粗体</em>。斜体样式类似，但要使用的特殊字符是下划线，例如，<em>斜体</em>。也可以使用 <strong>粗斜体</strong> 的语法来创建粗斜体。</p>
<p>代码样式是使用双反引号创建的，如 <code>code</code>。结果是带有浅灰色背景的等宽文本。</p>
<p>单独的星号、下划线或双反引号，或者在单词中间，不会开始格式化，但在它们前后的标点字符是允许的。当多行形成一个段落时，所有内联样式都可以跨多行。</p>
<p>内联样式示例：</p>
<table>
<thead>
<tr>
<th>未格式化</th>
<th>格式化</th>
</tr>
</thead>
<tbody><tr>
<td><em>bold</em></td>
<td><strong>bold</strong></td>
</tr>
<tr>
<td><em>italic</em></td>
<td><em>italic</em></td>
</tr>
<tr>
<td><strong>bold italic</strong></td>
<td><em><strong>bold italic</strong></em></td>
</tr>
<tr>
<td><code>code</code></td>
<td><code>code</code></td>
</tr>
<tr>
<td><em>bold</em>, then <em>italic</em> and finally <code>some code</code></td>
<td><strong>bold</strong>, then <em>italic</em> and finally <code>some code</code></td>
</tr>
<tr>
<td>This is <em>bold\non multiple\nlines</em>.</td>
<td>This is <strong>bold on multiple lines</strong>.</td>
</tr>
</tbody></table>
<h4 id="URLs"><a href="#URLs" class="headerlink" title="URLs"></a>URLs</h4><p>所有看起来像 URL 的字符串都会自动转换为可点击的链接。此外，以 .jpg、.jpeg、.png、.gif、.bmp 或 .svg（不区分大小写）结尾的 URL 将自动创建图像。例如，像 <a class="link"   target="_blank" rel="noopener" href="http://example.com/" >http://example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 这样的 URL 会变成链接，而 http:&#x2F;&#x2F;&#x2F;host&#x2F;image.jpg 和 file:&#x2F;&#x2F;&#x2F;path&#x2F;chart.png 会变成图像。</p>
<p>URL 自动转换为链接的功能适用于日志和报告中的所有数据，但只有在测试套件、测试用例和关键字文档以及测试套件元数据中才会创建图像。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>.svg 图像支持是 Robot Framework 3.2 中的新功能。</p>

    </div>
  </div>

<h4 id="自定义链接和图像"><a href="#自定义链接和图像" class="headerlink" title="自定义链接和图像"></a>自定义链接和图像</h4><p>可以使用特殊语法 [link|content] 创建自定义链接和嵌入图像。这将创建一个链接或图像，取决于链接和内容图像。如果它们具有与 URL 特殊的相同的图像扩展名，或者以 data:image&#x2F; 开头，那么它们就被认为是图像。在所有情况下，部分之间的周围方括号和管道字符都是必需的。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>对 data:image&#x2F; 前缀的支持是 Robot Framework 3.2 中的新功能。</p>

    </div>
  </div>

<h5 id="带有文本内容的链接"><a href="#带有文本内容的链接" class="headerlink" title="带有文本内容的链接"></a>带有文本内容的链接</h5><p>如果链接和内容都不是图像，最后的结果是一个普通的链接，其中链接是链接目标，内容是可见的文本：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[file.html|this file] -&gt; <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;file.html&quot;</span>&gt;</span>this file<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">[http://host|that host] -&gt; <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://host&quot;</span>&gt;</span>that host<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<h5 id="带有图像内容的链接"><a href="#带有图像内容的链接" class="headerlink" title="带有图像内容的链接"></a>带有图像内容的链接</h5><p>如果内容是图像，会得到一个链接，其中链接内容是图像。链接目标由链接创建，它可以是文本或图像：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[robot.html|robot.png] -&gt; <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;robot.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;robot.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">[robot.html|data:image/png;base64,oooxxx=] -&gt; <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;robot.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,oooxxx=&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">[image.jpg|thumb.jpg] -&gt; <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;image.jpg&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;thumb.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h5 id="带有标题文本的图像"><a href="#带有标题文本的图像" class="headerlink" title="带有标题文本的图像"></a>带有标题文本的图像</h5><p>如果链接是图像但内容不是，语法创建一个图像，其中内容是鼠标悬停在图像上时显示的标题文本：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[robot.jpeg|Robot rocks!] -&gt; <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;robot.jpeg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Robot rocks!&quot;</span>&gt;</span></span><br><span class="line">[data:image/png;base64,oooxxx=|Robot rocks!] -&gt; <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,oooxxx=&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Robot rocks!&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="节标题"><a href="#节标题" class="headerlink" title="节标题"></a>节标题</h4><p>如果文档变得较长，通常最好将其分割成几个部分。可以使用 <code>= 我的标题 =</code> 的语法来用标题分隔各个部分，其中等号的数量表示标题的级别：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">= First section =</span><br><span class="line"></span><br><span class="line">== Subsection ==</span><br><span class="line"></span><br><span class="line">Some text.</span><br><span class="line"></span><br><span class="line">== Second subsection ==</span><br><span class="line"></span><br><span class="line">More text.</span><br><span class="line"></span><br><span class="line">= Second section =</span><br><span class="line"></span><br><span class="line">You probably got the idea.</span><br></pre></td></tr></table></figure></div>

<p>注意，只支持三个标题级别，并且等号与标题文本之间的空格是必需的。</p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>表格是使用管道字符（带有周围空格）作为列分隔符和换行符作为行分隔符创建的。可以通过用等号（和可选的空格）包围单元格内容来创建标题单元格，如 <code>= 标题 =</code> 或 <code>=标题=</code>。表格单元格还可以包含链接和格式化内容，如粗体和斜体：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| =A= |  =B=  | = C =  |</span><br><span class="line">| <span class="emphasis">_1_</span> | Hello | world! |</span><br><span class="line">| <span class="emphasis">_2_</span> | Hi    |</span><br></pre></td></tr></table></figure></div>

<p>创建的表格总是有一个细边框，普通文本是左对齐的。标题单元格中的文本是粗体和居中的。空单元格会自动添加，使行长度相等。例如，上面的示例在 HTML 中的格式化如下：</p>
<table>
<thead>
<tr>
<th>&#x3D;A&#x3D;</th>
<th>&#x3D;B&#x3D;</th>
<th>&#x3D; C &#x3D;</th>
</tr>
</thead>
<tbody><tr>
<td>_1_</td>
<td>Hello</td>
<td>world!</td>
</tr>
<tr>
<td>_2_</td>
<td>Hi</td>
<td></td>
</tr>
</tbody></table>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表是通过以连字符和空格（’- ‘）开始一行来创建的。可以通过用一个或多个空格缩进连续的行来将列表项分割成多行。不以 ‘- ’ 开头且未缩进的行结束了列表：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"><span class="bullet">-</span> a list item</span><br><span class="line"><span class="bullet">-</span> second list item</span><br><span class="line">  is continued</span><br><span class="line"></span><br><span class="line">This is outside the list.</span><br></pre></td></tr></table></figure></div>

<p>上述文档在 HTML 中的格式化如下：</p>
<p>Example:</p>
<p>a list item second list item is continued This is outside the list.</p>
<p>​                            </p>
<h4 id="预格式化文本"><a href="#预格式化文本" class="headerlink" title="预格式化文本"></a>预格式化文本</h4><p>在文档中，可以嵌入预格式化文本块。预格式化块是通过以 ‘| ’ 开始行来创建的，除非在否则为空的行上，否则在管道字符后面的一个空格是必需的。开始的 ‘| ’ 序列将从结果的 HTML 中删除，但所有其他空白都将保留。</p>
<p>在以下文档中，当转换为 HTML 时，两个中间行形成一个预格式化块：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Doc before block:</span><br><span class="line">| inside block</span><br><span class="line">|    some   additional whitespace</span><br><span class="line">After block.</span><br></pre></td></tr></table></figure></div>

<p>上述文档格式化如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Doc before block:</span><br><span class="line"></span><br><span class="line">inside block</span><br><span class="line">  some   additional whitespace</span><br><span class="line">After block.</span><br></pre></td></tr></table></figure></div>

<h4 id="水平尺"><a href="#水平尺" class="headerlink" title="水平尺"></a>水平尺</h4><p>水平尺（<code>&lt;hr&gt;</code> 标签）使得可以将较大的部分彼此分开，可以通过在一行中单独放置三个或更多的连字符来创建它们：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Some text here.</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">More text...</span><br></pre></td></tr></table></figure></div>

<p>上述文档格式化如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Some text here.</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">More text...</span><br></pre></td></tr></table></figure></div>

<p>​              </p>
<h4 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h4><p>Robot Framework 有自己的时间格式，既灵活易用，又易于理解。它被几个关键字（例如，BuiltIn 关键字 Sleep 和 Wait Until Keyword Succeeds）、DateTime 库和超时使用。</p>
<h5 id="作为数字的时间"><a href="#作为数字的时间" class="headerlink" title="作为数字的时间"></a>作为数字的时间</h5><p>时间总是可以作为一个纯数字给出，在这种情况下，它被解释为秒。整数和浮点数都可以工作，可以使用实数或包含数值的字符串。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>注意</p>

    </div>
  </div>

<p>在某些上下文中，纯数字可以被解释为其他时间。例如，对于 WHILE 循环限制，整数表示最大迭代次数。</p>
<h5 id="作为时间字符串的时间"><a href="#作为时间字符串的时间" class="headerlink" title="作为时间字符串的时间"></a>作为时间字符串的时间</h5><p>将时间表示为时间字符串意味着使用诸如 2 分钟 42 秒这样的格式，这通常比仅将值作为秒更容易理解。例如，不太容易理解 4200 秒是多长时间，但 1 小时 10 分钟立即就清楚了。</p>
<p>这种格式的基本思想是首先有一个数字，然后有一个文本指定该数字代表的时间。数字可以是整数或浮点数，整个格式对大小写和空格不敏感，可以添加 - 前缀来指定负时间。可用的时间说明符有：</p>
<ul>
<li>days, day, d </li>
<li>hours, hour, h </li>
<li>minutes, minute, mins, min, m </li>
<li>seconds, second, secs, sec, s </li>
<li>milliseconds, millisecond, millis, ms </li>
<li>microseconds, microsecond, us, μs </li>
<li>nanoseconds, nanosecond, ns</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> min <span class="number">30</span> secs </span><br><span class="line"><span class="number">1</span>.<span class="number">5</span> minutes </span><br><span class="line"><span class="number">90</span> s </span><br><span class="line"><span class="number">1</span> day <span class="number">2</span> hours <span class="number">3</span> minutes <span class="number">4</span> seconds <span class="number">5</span> milliseconds <span class="number">6</span> microseconds <span class="number">7</span> nanoseconds </span><br><span class="line"><span class="number">1</span>d <span class="number">2</span>h <span class="number">3</span>m <span class="number">4</span>s <span class="number">5</span>ms <span class="number">6</span>μs <span class="number">7</span> ns</span><br><span class="line">- <span class="number">10</span> seconds</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 6.0 中，对微秒和纳秒的支持是新的。</p>

    </div>
  </div>

<h5 id="作为-“计时器”-字符串的时间"><a href="#作为-“计时器”-字符串的时间" class="headerlink" title="作为 “计时器” 字符串的时间"></a>作为 “计时器” 字符串的时间</h5><p>时间也可以以计时器格式 hh:mm:ss.mil 给出。在这种格式中，小时和毫秒部分都是可选的，当它们不重要时，可以省略前导和尾随的零，负时间可以通过添加 - 前缀来表示。例如，以下计时器和时间字符串值是相同的：</p>
<p>计时器和时间字符串示例</p>
<table>
<thead>
<tr>
<th>计时器</th>
<th>时间字符串</th>
</tr>
</thead>
<tbody><tr>
<td>00:00:01</td>
<td>1 秒</td>
</tr>
<tr>
<td>01:02:03</td>
<td>1 小时 2 分钟 3 秒</td>
</tr>
<tr>
<td>1:00:00</td>
<td>1 小时</td>
</tr>
<tr>
<td>100:00:00</td>
<td>100 小时</td>
</tr>
<tr>
<td>00:02</td>
<td>2 秒</td>
</tr>
<tr>
<td>42:00</td>
<td>42 分钟</td>
</tr>
<tr>
<td>00:01:02.003</td>
<td>1 分钟 2 秒 3 毫秒</td>
</tr>
<tr>
<td>00:01.5</td>
<td>1.5 秒</td>
</tr>
<tr>
<td>-01:02.345</td>
<td>- 1 分钟 2 秒 345 毫秒</td>
</tr>
</tbody></table>
<p>​              </p>
<h4 id="布尔参数"><a href="#布尔参数" class="headerlink" title="布尔参数"></a>布尔参数</h4><p>Robot Framework 标准库中的许多关键字接受作为布尔值 true 或 false 处理的参数。如果这样的参数作为字符串给出，那么如果它是一个空字符串或等于 FALSE、NONE、NO、OFF 或 0（不区分大小写），则被认为是 false。除非关键字文档明确说明否则，其他字符串被认为是 true，其他参数类型使用与 Python 相同的规则进行测试。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">True examples</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=True         # 字符串通常为 true。</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=yes          # 与上面相同。</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=$&#123;TRUE&#125;      # Python 的 `True` 是 true。</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=$&#123;42&#125;        # 除 0 之外的数字为 true。</span><br><span class="line"></span><br><span class="line">False examples</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=False        # 字符串 `false` 是 false。</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=no           # 字符串 `no` 也是 false。</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=$&#123;EMPTY&#125;     # 空字符串是 false。</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=$&#123;FALSE&#125;     # Python 的 `False` 是 false。</span><br><span class="line">    Should Be Equal    $&#123;x&#125;    $&#123;y&#125;    Custom error    values=no values    # 这个关键字的特殊 false 字符串。</span><br></pre></td></tr></table></figure></div>


  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在 Robot Framework 3.1 中，将 OFF 和 0 视为 false 是新的。</p>

    </div>
  </div>

<h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>本附录解释了在不同上下文中如何使用 Python 求值表达式，以及如何处理表达式中的变量。</p>
<h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>诸如 IF&#x2F;ELSE 结构、WHILE 循环和内联 Python 求值以及几个 BuiltIn 关键字都接受一个在 Python 中求值的表达式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">IF/ELSE</span><br><span class="line">    IF    $&#123;x&#125; &gt; 0</span><br><span class="line">        Log to console   $&#123;x&#125; is positive</span><br><span class="line">    ELSE</span><br><span class="line">        Log to console   $&#123;x&#125; is negative</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Inline Python evaluation</span><br><span class="line">    Log to console    $&#123;x&#125; is $&#123;&#123;&#x27;positive&#x27; if $&#123;x&#125; &gt; 0 else &#x27;negative&#x27;&#125;&#125;</span><br><span class="line"></span><br><span class="line">Evaluate keyword</span><br><span class="line">    $&#123;type&#125; =    Evaluate    &#x27;positive&#x27; if $&#123;x&#125; &gt; 0 else &#x27;negative&#x27;</span><br><span class="line">    Log to console    $&#123;x&#125; is $&#123;type&#125;</span><br><span class="line"></span><br><span class="line">Should Be True keyword</span><br><span class="line">    Should Be True    $&#123;x&#125; &gt; 0</span><br></pre></td></tr></table></figure></div>

<p>注意，与其创建复杂的表达式，通常最好将逻辑移动到测试库中。这通常可以简化维护，并提高执行速度。</p>
<h5 id="求值命名空间"><a href="#求值命名空间" class="headerlink" title="求值命名空间"></a>求值命名空间</h5><p>表达式使用 Python 的 eval 函数进行求值，因此可以使用正常的 Python 构造，如 ‘{x}’ &#x3D;&#x3D; ‘expected’、x′&#x3D;&#x3D;′expected′、{x} &gt; 0 和 ‘${x}’.upper() not in (‘FAIL’, ‘BAD’)，并且所有内置函数，如 len() 和 int() 都可用。此外，所有未识别的 Python 变量都被认为是自动导入的模块。可以使用所有可用的 Python 模块，包括标准模块和已安装的第三方模块。</p>
<p>以下示例演示了使用 Python 内置函数以及使用内联 Python 求值语法的模块，但相同的表达式也可以与 IF&#x2F;ELSE 结构和 BuiltIn 关键字一起工作，无需在表达式周围使用 <code>$&#123;&#123;&#125;&#125;</code> 装饰：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;VAR&#125;           123</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Python syntax</span><br><span class="line">    Should Be True       $&#123;&#123;&#x27;$&#123;VAR&#125;&#x27; == &#x27;123&#x27;&#125;&#125;</span><br><span class="line">    Should Be True       $&#123;&#123;&#x27;$&#123;VAR&#125;&#x27;.startswith(&#x27;x&#x27;) or &#x27;$&#123;VAR&#125;&#x27; in &#x27;012345&#x27;&#125;&#125;</span><br><span class="line"></span><br><span class="line">Python builtins</span><br><span class="line">    Should Be Equal      $&#123;&#123;len(&#x27;$&#123;VAR&#125;&#x27;)&#125;&#125;        $&#123;3&#125;</span><br><span class="line">    Should Be Equal      $&#123;&#123;int(&#x27;$&#123;VAR&#125;&#x27;)&#125;&#125;        $&#123;123&#125;</span><br><span class="line"></span><br><span class="line">Access modules</span><br><span class="line">    Should Be Equal      $&#123;&#123;os.sep&#125;&#125;               $&#123;/&#125;</span><br><span class="line">    Should Be Equal      $&#123;&#123;round(math.pi, 2)&#125;&#125;    $&#123;3.14&#125;</span><br><span class="line">    Should Start With    $&#123;&#123;robot.__version__&#125;&#125;    4.</span><br></pre></td></tr></table></figure></div>

<p>使用模块的一个限制是，只有当根模块自动导入子模块时，才能使用像 rootmod.submod 这样的嵌套模块。这并不总是这样，使用这样的模块是不可能的。一个相关的具体示例是 selenium 模块，至少在撰写本文时，仅导入 selenium 并不导入 selenium.webdriver 子模块。另一个限制是，当使用 Python 3 时，模块不能在列表推导的表达式部分使用。这两个问题的解决方法是使用接受模块作为参数进行导入并添加到求值命名空间的 BuiltIn 关键字 Evaluate：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Does not work due to nested module structure</span><br><span class="line">    Log    $&#123;&#123;selenium.webdriver.ChromeOptions()&#125;&#125;</span><br><span class="line"></span><br><span class="line">Evaluate keyword with nested module</span><br><span class="line">    $&#123;options&#125; =    Evaluate    selenium.webdriver.ChromeOptions()    modules=selenium.webdriver</span><br><span class="line">    Log    $&#123;options&#125;</span><br><span class="line"></span><br><span class="line">Does not work due to list comprehension</span><br><span class="line">    Log    $&#123;&#123;[json.loads(item) for item in (&#x27;1&#x27;, &#x27;&quot;b&quot;&#x27;)]&#125;&#125;</span><br><span class="line"></span><br><span class="line">Evaluate keyword with list comprehension</span><br><span class="line">    $&#123;items&#125; =    Evaluate    [json.loads(item) for item in (&#x27;1&#x27;, &#x27;&quot;b&quot;&#x27;)]    modules=json</span><br><span class="line">    Log    $&#123;items&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果需要进一步的定制，Evaluate 关键字还支持自定义求值命名空间。有关更多详细信息，请参阅 BuiltIn 库中的文档。</p>
<p>​              </p>
<h4 id="使用变量-1"><a href="#使用变量-1" class="headerlink" title="使用变量"></a>使用变量</h4><h5 id="正常的-variable-语法"><a href="#正常的-variable-语法" class="headerlink" title="正常的 ${variable} 语法"></a>正常的 ${variable} 语法</h5><p>当在表达式中使用正常的 {variable} 语法使用变量时，其值会在表达式求值之前被替换。这意味着在表达式中使用的值将是变量值的字符串表示，而不是变量值本身。对于数字和其他可以直接求值的对象的字符串表示，这不是问题。例如，如果有一个作为整数的返回码在变量variable语法使用变量时，其值会在表达式求值之前被替换。这意味着在表达式中使用的值将是变量值的字符串表示，而不是变量值本身。对于数字和其他可以直接求值的对象的字符串表示，这不是问题。例如，如果有一个作为整数的返回码在变量{rc} 中，使用像 ${rc} &gt; 0 这样的东西是可以的。</p>
<p>对于其他对象，行为取决于字符串表示。最重要的是，字符串必须始终用单引号或双引号引起来，如 ‘{x}’，如果它们可以包含换行符，它们必须用三引号引起来，如 ‘’’x′，如果它们可以包含换行符，它们必须用三引号引起来，如′′′{x}’‘’。包含引号本身的字符串会导致额外的问题，但通常可以通过三引号来处理。另外，反斜杠字符 \ 是有问题的，但可以通过使用 Python 的原始字符串表示法，如 r’${path}’ 来处理。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Using normal variable syntax</span><br><span class="line">    Should Be True    $&#123;rc&#125; &gt; 0</span><br><span class="line">    IF    &#x27;$&#123;status&#125;&#x27;.upper() == &#x27;PASS&#x27;</span><br><span class="line">        Log    Passed</span><br><span class="line">    END</span><br><span class="line">    IF    &#x27;FAIL&#x27; in r&#x27;&#x27;&#x27;$&#123;output&#125;&#x27;&#x27;&#x27;</span><br><span class="line">        Log    Output contains FAIL</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div>

<h5 id="特殊的-variable-语法"><a href="#特殊的-variable-语法" class="headerlink" title="特殊的 $variable 语法"></a>特殊的 $variable 语法</h5><p>引用字符串并不那么方便，但有些情况下，将变量替换为其字符串表示会导致更大的问题。例如，如果变量值可以是字符串或 Python None，需要像 ‘${var}’ 这样引用，否则字符串就不起作用，但那么 None 就被解释为字符串了。幸运的是，这个部分讨论的这些问题有一个简单的解决方案。</p>
<p>实际的变量值在求值命名空间中可用，并可以使用没有花括号的特殊变量语法，如 $variable 来访问。这样的变量永远不应该被引用，即使它们包含字符串。</p>
<p>将这些示例与上一节的示例进行比较：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Using special variable syntax</span><br><span class="line">    Should Be True    $rc &gt; 0</span><br><span class="line">    IF    $status.upper() == &#x27;PASS&#x27;</span><br><span class="line">        Log    Passed</span><br><span class="line">    END</span><br><span class="line">    IF    &#x27;FAIL&#x27; in $output</span><br><span class="line">        Log    Output contains FAIL</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Only possible using special variable syntax</span><br><span class="line">    Should Be True    $example is not None</span><br><span class="line">    Should Be True    len($result) &gt; 1 and $result[1] == &#x27;OK&#x27;</span><br></pre></td></tr></table></figure></div>

<p>使用 $variable 语法会稍微减慢表达式求值的速度。这通常不应该有问题，但如果经常求值复杂的表达式，并且有严格的时间限制，应该考虑到这一点。无论如何，将这样的逻辑移动到测试库通常是一个好主意。</p>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>由于技术原因，这些特殊变量在求值期间作为局部变量可用。这使得它们在非局部范围内不可用，例如在列表推导的表达式部分和在 lambda 内部。</p>

    </div>
  </div>     

<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>本附录列出了与 Robot Framework 关联的文件扩展名、媒体类型等。</p>
<h4 id="套件文件扩展名"><a href="#套件文件扩展名" class="headerlink" title="套件文件扩展名"></a>套件文件扩展名</h4><p>以下扩展名的套件文件会被自动解析：</p>
<p>.robot 使用纯文本格式的套件文件。 .robot.rst 使用 reStructuredText 格式的套件文件。 .rbt 使用 JSON 格式的套件文件。 使用其他扩展名是可能的，但需要单独配置。</p>
<h4 id="资源文件扩展名"><a href="#资源文件扩展名" class="headerlink" title="资源文件扩展名"></a>资源文件扩展名</h4><p>资源文件可以使用以下扩展名：</p>
<p>.resource 推荐在使用纯文本格式时使用。 .robot, .txt 和 .tsv 出于向后兼容性原因，支持在纯文本格式中使用。推荐使用 .resource，将来可能会强制使用。 .rst 和 .rest 使用 reStructuredText 格式的资源文件。 .rsrc 和 .json 使用 JSON 格式的资源文件。</p>
<h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><p>使用 Robot Framework 数据的媒体类型是 text&#x2F;robotframework。</p>
<h4 id="远程服务器端口"><a href="#远程服务器端口" class="headerlink" title="远程服务器端口"></a>远程服务器端口</h4><p>默认的远程服务器端口是 8270。该端口已由 IANA 注册。</p>
<p>​                                     </p>

        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Robot Framework教程</li>
        <li><strong>作者:</strong> Yiuhang Chan</li>
        <li><strong>创建于
                :</strong> 2024-04-19 11:17:08</li>
        
            <li>
                <strong>更新于
                    :</strong> 2024-04-25 16:44:46
            </li>
        
        <li>
            <strong>链接:</strong> https://www.yiuhangblog.com/2024/04/19/20240419RobotFramework教程/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/%E5%9F%BA%E7%A1%80/">#基础</a>&nbsp;
                    </li>
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/%E7%90%86%E8%AE%BA/">#理论</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2024/04/18/20240418TagUI%E6%95%99%E7%A8%8B/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">TagUI教程</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        评论
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://comment.yiuhangblog.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">Robot Framework教程</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Robot-Framework-%E7%AE%80%E4%BB%8B"><span class="nav-text">Robot Framework 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-Robot-Framework%EF%BC%9F"><span class="nav-text">为什么选择 Robot Framework？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%9E%B6%E6%9E%84"><span class="nav-text">高级架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%AA%E5%B1%8F"><span class="nav-text">截屏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-text">获取更多信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E9%A1%B5%E9%9D%A2"><span class="nav-text">项目页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8"><span class="nav-text">邮件列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%88%E6%9D%83%E5%92%8C%E8%AE%B8%E5%8F%AF%E8%AF%81"><span class="nav-text">版权和许可证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97"><span class="nav-text">安装指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-%E5%AE%89%E8%A3%85"><span class="nav-text">Python 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Linux-%E4%B8%8A%E5%AE%89%E8%A3%85-Python"><span class="nav-text">在 Linux 上安装 Python</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-%E4%B8%8A%E7%9A%84-Python-%E5%AE%89%E8%A3%85"><span class="nav-text">Windows 上的 Python 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#macOS-%E4%B8%8A%E7%9A%84-Python-%E5%AE%89%E8%A3%85"><span class="nav-text">macOS 上的 Python 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PyPy-%E5%AE%89%E8%A3%85"><span class="nav-text">PyPy 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-PATH"><span class="nav-text">配置 PATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-pip-%E5%AE%89%E8%A3%85"><span class="nav-text">使用 pip 安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pip-%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="nav-text">pip 命令的运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81-pip-%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8"><span class="nav-text">验证 pip 是否可用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD-Robot-Framework"><span class="nav-text">安装与卸载 Robot Framework</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%89%E8%A3%85"><span class="nav-text">从源代码安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85"><span class="nav-text">验证安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83"><span class="nav-text">虚拟环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-text">设置集成开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IDE"><span class="nav-text">IDE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85IDE%E5%92%8C%E6%89%A9%E5%B1%95"><span class="nav-text">安装IDE和扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Visual-Studio-Code"><span class="nav-text">Visual Studio Code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85Visual-Studio-Code"><span class="nav-text">安装Visual Studio Code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Visual-Studio-Code%E6%89%A9%E5%B1%95"><span class="nav-text">Visual Studio Code扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PyCharm"><span class="nav-text">PyCharm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85PyCharm"><span class="nav-text">安装PyCharm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PyCharm%E6%89%A9%E5%B1%95"><span class="nav-text">PyCharm扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95Robot-Framework%E6%B5%8B%E8%AF%95"><span class="nav-text">运行和调试Robot Framework测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Visual-Studio-Code%E5%92%8CRobotCode"><span class="nav-text">使用Visual Studio Code和RobotCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8PyCharm%E5%92%8CRobot-Framework-Language-Server"><span class="nav-text">使用PyCharm和Robot Framework Language Server</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Poetry%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96"><span class="nav-text">使用Poetry管理依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-text">虚拟环境文件夹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B0%E9%A1%B9%E7%9B%AE"><span class="nav-text">初始化新项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-text">添加依赖项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-text">在虚拟环境中运行命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA"><span class="nav-text">演示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="nav-text">创建测试数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E8%AF%AD%E6%B3%95"><span class="nav-text">测试数据语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="nav-text">文件和目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E9%83%A8%E5%88%86"><span class="nav-text">测试数据部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">支持的文件格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%A0%BC%E5%88%86%E9%9A%94%E6%A0%BC%E5%BC%8F"><span class="nav-text">空格分隔格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%88%86%E9%9A%94%E6%A0%BC%E5%BC%8F"><span class="nav-text">管道分隔格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reStructuredText-%E6%A0%BC%E5%BC%8F"><span class="nav-text">reStructuredText 格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#reStructuredText-%E7%A4%BA%E4%BE%8B"><span class="nav-text">reStructuredText 示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-%E6%A0%BC%E5%BC%8F"><span class="nav-text">JSON 格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E5%A5%97%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA-JSON"><span class="nav-text">将套件转换为 JSON</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E-JSON-%E5%88%9B%E5%BB%BA%E5%A5%97%E4%BB%B6"><span class="nav-text">从 JSON 创建套件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-JSON-%E6%96%87%E4%BB%B6"><span class="nav-text">执行 JSON 文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%A5%97%E4%BB%B6%E6%BA%90"><span class="nav-text">调整套件源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSON-%E7%BB%93%E6%9E%84"><span class="nav-text">JSON 结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99"><span class="nav-text">数据解析规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">忽略的数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89"><span class="nav-text">转义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="nav-text">转义特殊字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%A2%E6%88%90%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="nav-text">形成转义序列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC"><span class="nav-text">处理空值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%A9%BA%E6%A0%BC"><span class="nav-text">处理空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%88%86%E5%89%B2%E5%88%B0%E5%A4%9A%E8%A1%8C"><span class="nav-text">将数据分割到多行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="nav-text">本地化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E8%AF%AD%E8%A8%80"><span class="nav-text">启用语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6"><span class="nav-text">自定义语言文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">创建测试用例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AF%AD%E6%B3%95"><span class="nav-text">测试用例语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E9%83%A8%E5%88%86%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">在测试用例部分的设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E8%AE%BE%E7%BD%AE%E9%83%A8%E5%88%86%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE"><span class="nav-text">在设置部分的测试用例相关设置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-text">使用参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-text">位置参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E9%87%8F%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">可变数量的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">命名参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="nav-text">命名参数与变量</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E8%AF%AD%E6%B3%95"><span class="nav-text">转义命名参数语法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E6%94%AF%E6%8C%81%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">命名参数支持的位置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="nav-text">命名参数示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">自由命名参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%85%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">仅命名参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%88%B0%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8D%E7%A7%B0%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">嵌入到关键字名称中的参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B1%E8%B4%A5"><span class="nav-text">失败</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%A4%B1%E8%B4%A5%E6%97%B6"><span class="nav-text">测试用例失败时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF"><span class="nav-text">错误消息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%90%8D%E7%A7%B0%E5%92%8C%E6%96%87%E6%A1%A3"><span class="nav-text">测试用例名称和文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">标记测试用例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%83%E7%94%A8-Force-Tags-%E5%92%8C-Default-Tags"><span class="nav-text">弃用 Force Tags 和 Default Tags</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E7%95%99%E6%A0%87%E7%AD%BE"><span class="nav-text">保留标签</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%9D%BF"><span class="nav-text">测试模板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%8F%82%E6%95%B0%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-text">嵌入参数的模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8FOR%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-text">使用FOR循环的模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8IF-ELSE%E7%BB%93%E6%9E%84%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-text">使用IF&#x2F;ELSE结构的模板</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E9%A3%8E%E6%A0%BC"><span class="nav-text">不同的测试用例风格</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E9%A9%B1%E5%8A%A8%E9%A3%8E%E6%A0%BC"><span class="nav-text">关键字驱动风格</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E9%A3%8E%E6%A0%BC"><span class="nav-text">数据驱动风格</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E9%A3%8E%E6%A0%BC"><span class="nav-text">行为驱动风格</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5Given-When-Then-And-But%E5%89%8D%E7%BC%80"><span class="nav-text">忽略Given&#x2F;When&#x2F;Then&#x2F;And&#x2F;But前缀</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">嵌入数据到关键字</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="nav-text">创建任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%AF%AD%E6%B3%95"><span class="nav-text">任务语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E4%BB%BB%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">与任务相关的设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E5%A5%97%E4%BB%B6"><span class="nav-text">创建测试套件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E6%96%87%E4%BB%B6"><span class="nav-text">套件文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="nav-text">套件目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6"><span class="nav-text">套件初始化文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E5%90%8D%E7%A7%B0"><span class="nav-text">套件名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E6%96%87%E6%A1%A3"><span class="nav-text">套件文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E5%A5%97%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">自由套件元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%8B%86%E8%A7%A3"><span class="nav-text">套件设置和拆解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95%E5%BA%93"><span class="nav-text">使用测试库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%BA%93"><span class="nav-text">导入库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Library%E8%AE%BE%E7%BD%AE"><span class="nav-text">使用Library设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Import-Library%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">使用Import Library关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E8%A6%81%E5%AF%BC%E5%85%A5%E7%9A%84%E5%BA%93"><span class="nav-text">指定要导入的库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%93%E5%90%8D%E7%A7%B0"><span class="nav-text">使用库名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%93%E7%9A%84%E7%89%A9%E7%90%86%E8%B7%AF%E5%BE%84"><span class="nav-text">使用库的物理路径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%BA%93%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0"><span class="nav-text">设置库的自定义名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">普通标准库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%BA%93"><span class="nav-text">远程库</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%BA%93"><span class="nav-text">外部库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="nav-text">使用变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E9%87%8F%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">标量变量语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">列表变量语法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE"><span class="nav-text">使用列表变量与其他数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E8%AE%BE%E7%BD%AE"><span class="nav-text">使用列表变量与设置</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">字典变量语法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE"><span class="nav-text">使用字典变量与其他数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E5%8F%98%E9%87%8F%E4%B8%8E%E8%AE%BE%E7%BD%AE"><span class="nav-text">使用字典变量与设置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%88%97%E8%A1%A8%E5%92%8C%E5%AD%97%E5%85%B8%E9%A1%B9"><span class="nav-text">访问列表和字典项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%BA%8F%E5%88%97%E9%A1%B9"><span class="nav-text">访问序列项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%8D%95%E4%B8%AA%E5%AD%97%E5%85%B8%E9%A1%B9"><span class="nav-text">访问单个字典项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E9%A1%B9%E8%AE%BF%E9%97%AE"><span class="nav-text">嵌套项访问</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="nav-text">创建变量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E9%83%A8%E5%88%86"><span class="nav-text">变量部分</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E9%87%8F%E5%8F%98%E9%87%8F"><span class="nav-text">创建标量变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%97%E8%A1%A8%E5%8F%98%E9%87%8F"><span class="nav-text">创建列表变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8%E5%8F%98%E9%87%8F"><span class="nav-text">创建字典变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E5%90%8D"><span class="nav-text">基于另一个变量创建变量名</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6"><span class="nav-text">变量文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="nav-text">在命令行中设置变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">关键字的返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%A0%87%E9%87%8F%E5%8F%98%E9%87%8F"><span class="nav-text">分配标量变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%B8%A6%E6%9C%89%E9%A1%B9%E5%80%BC%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">分配带有项值的变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E5%90%8D-1"><span class="nav-text">基于另一个变量创建变量名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%88%97%E8%A1%A8%E5%8F%98%E9%87%8F"><span class="nav-text">分配列表变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%AD%97%E5%85%B8%E5%8F%98%E9%87%8F"><span class="nav-text">分配字典变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="nav-text">分配多个变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%AE%B0%E5%BD%95%E5%88%86%E9%85%8D%E7%9A%84%E5%8F%98%E9%87%8F%E5%80%BC"><span class="nav-text">自动记录分配的变量值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#VAR%E8%AF%AD%E6%B3%95"><span class="nav-text">VAR语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E9%87%8F%E5%8F%98%E9%87%8F-1"><span class="nav-text">创建标量变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AD%97%E5%85%B8%E5%8F%98%E9%87%8F"><span class="nav-text">创建列表和字典变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="nav-text">条件创建变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E5%90%8D-2"><span class="nav-text">基于另一个变量创建变量名</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Set-Test-Suite-Global-Variable%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">使用Set Test&#x2F;Suite&#x2F;Global Variable关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="nav-text">内置变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="nav-text">操作系统变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%8F%98%E9%87%8F"><span class="nav-text">数字变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%92%8CNone-null%E5%8F%98%E9%87%8F"><span class="nav-text">布尔和None&#x2F;null变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%A0%BC%E5%92%8C%E7%A9%BA%E5%8F%98%E9%87%8F"><span class="nav-text">空格和空变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="nav-text">自动变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">变量优先级和作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">变量优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">命令行中的变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E9%83%A8%E5%88%86"><span class="nav-text">测试用例文件中的变量部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E7%9A%84%E8%B5%84%E6%BA%90%E5%92%8C%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6"><span class="nav-text">导入的资源和变量文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%9C%9F%E9%97%B4%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">在测试执行期间设置的变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F-1"><span class="nav-text">内置变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">变量作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">全局作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%A5%97%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">测试套件作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">测试用例作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">局部作用域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%89%B9%E6%80%A7"><span class="nav-text">高级变量特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">扩展变量语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="nav-text">扩展变量赋值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%86%85%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">变量内的变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94Python%E8%AF%84%E4%BC%B0"><span class="nav-text">内联Python评估</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">创建用户关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E9%83%A8%E5%88%86%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">关键字部分中的设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E6%96%87%E6%A1%A3"><span class="nav-text">用户关键字的名称和文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E6%A0%87%E7%AD%BE"><span class="nav-text">用户关键字标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="nav-text">用户关键字参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-text">用户关键字的位置参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">用户关键字的默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8F%AF%E5%8F%98%E6%95%B0%E9%87%8F%E5%8F%82%E6%95%B0"><span class="nav-text">用户关键字的可变数量参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E8%87%AA%E7%94%B1%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">用户关键字的自由命名参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BB%85%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">用户关键字的仅命名参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%8F%82%E6%95%B0%E5%B5%8C%E5%85%A5%E5%88%B0%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8D%E7%A7%B0%E4%B8%AD"><span class="nav-text">将参数嵌入到关键字名称中</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E9%94%99%E8%AF%AF%E7%9A%84%E5%80%BC"><span class="nav-text">嵌入参数匹配错误的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="nav-text">解决冲突</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">使用自定义正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">支持的正则表达式语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6-1"><span class="nav-text">转义特殊字符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%85%A5%E5%8F%82%E6%95%B0%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">使用自定义嵌入参数的正则表达式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B"><span class="nav-text">行为驱动开发示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">用户关键字返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8RETURN%E8%AF%AD%E5%8F%A5"><span class="nav-text">使用RETURN语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Return-%E8%AE%BE%E7%BD%AE"><span class="nav-text">使用[Return]设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%89%B9%E6%AE%8A%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%94%E5%9B%9E"><span class="nav-text">使用特殊关键字返回</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%8B%86%E5%8D%B8"><span class="nav-text">用户关键字设置和拆卸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">私有用户关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%92%8C%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6"><span class="nav-text">资源和变量文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text">资源文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text">使用资源文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-text">资源文件结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text">记录资源文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text">示例资源文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8reStructured%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text">使用reStructured文本格式的资源文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JSON%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text">使用JSON格式的资源文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6-1"><span class="nav-text">变量文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6"><span class="nav-text">使用变量文件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%83%A8%E5%88%86"><span class="nav-text">设置部分</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-text">命令行</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E6%A8%A1%E5%9D%97%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F"><span class="nav-text">从模块直接获取变量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%80%BC"><span class="nav-text">使用对象作为值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="nav-text">动态创建变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%A6%81%E5%8C%85%E5%90%AB%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">选择要包含的变量</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F"><span class="nav-text">从特殊函数获取变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%B8%BA%E7%B1%BB"><span class="nav-text">将变量文件实现为类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BAYAML"><span class="nav-text">变量文件作为YAML</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BAJSON"><span class="nav-text">变量文件作为JSON</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FOR%E5%BE%AA%E7%8E%AF"><span class="nav-text">FOR循环</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84FOR%E5%BE%AA%E7%8E%AF"><span class="nav-text">简单的FOR循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A7%E7%9A%84FOR%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95"><span class="nav-text">旧的FOR循环语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97FOR%E5%BE%AA%E7%8E%AF"><span class="nav-text">嵌套FOR循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F"><span class="nav-text">使用多个循环变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FOR-IN-RANGE%E5%BE%AA%E7%8E%AF"><span class="nav-text">FOR-IN-RANGE循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FOR-IN-ENUMERATE%E5%BE%AA%E7%8E%AF"><span class="nav-text">FOR-IN-ENUMERATE循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FOR-IN-ZIP%E5%BE%AA%E7%8E%AF"><span class="nav-text">FOR-IN-ZIP循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E8%BF%AD%E4%BB%A3"><span class="nav-text">字典迭代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E8%BE%93%E5%87%BA"><span class="nav-text">移除不必要的关键字输出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%8D%95%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">重复单个关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WHILE%E5%BE%AA%E7%8E%AF"><span class="nav-text">WHILE循环</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84WHILE%E8%AF%AD%E6%B3%95"><span class="nav-text">基本的WHILE语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6WHILE%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%AC%A1%E6%95%B0"><span class="nav-text">限制WHILE循环的迭代次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97WHILE%E5%BE%AA%E7%8E%AF"><span class="nav-text">嵌套WHILE循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E8%BE%93%E5%87%BA-1"><span class="nav-text">移除不必要的关键字输出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8BREAK%E5%92%8CCONTINUE%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF"><span class="nav-text">使用BREAK和CONTINUE控制循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IF-ELSE%E8%AF%AD%E6%B3%95"><span class="nav-text">IF&#x2F;ELSE语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84IF%E8%AF%AD%E6%B3%95"><span class="nav-text">基本的IF语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ELSE%E5%88%86%E6%94%AF"><span class="nav-text">ELSE分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ELSE-IF%E5%88%86%E6%94%AF"><span class="nav-text">ELSE IF分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E8%81%94IF"><span class="nav-text">内联IF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84IF%E7%BB%93%E6%9E%84"><span class="nav-text">嵌套的IF结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F"><span class="nav-text">有条件地执行关键字的其他方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TRY-EXCEPT%E8%AF%AD%E6%B3%95"><span class="nav-text">TRY&#x2F;EXCEPT语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8EXCEPT%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-text">使用EXCEPT捕获异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E9%94%99%E8%AF%AF"><span class="nav-text">使用模式匹配错误</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF"><span class="nav-text">捕获错误消息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ELSE%E5%9C%A8%E6%B2%A1%E6%9C%89%E9%94%99%E8%AF%AF%E6%97%B6%E6%89%A7%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">使用ELSE在没有错误时执行关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8FINALLY%E6%97%A0%E8%AE%BA%E6%98%AF%E5%90%A6%E6%9C%89%E9%94%99%E8%AF%AF%E9%83%BD%E6%89%A7%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">使用FINALLY无论是否有错误都执行关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">其他处理错误的方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%90%8C%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">处理同名关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">关键字作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E6%8C%87%E5%AE%9A%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">明确指定关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E6%8C%87%E5%AE%9A%E5%BA%93%E5%92%8C%E8%B5%84%E6%BA%90%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">明确指定库和资源之间的优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E6%97%B6"><span class="nav-text">超时</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%B6%85%E6%97%B6"><span class="nav-text">测试用例超时</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E8%B6%85%E6%97%B6"><span class="nav-text">用户关键字超时</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">并行执行关键字</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">测试用例执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-text">开始执行测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E8%A6%81"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="nav-text">指定要执行的测试数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="nav-text">使用命令行选项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%89%E9%A1%B9"><span class="nav-text">使用选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%AD%E9%80%89%E9%A1%B9%E5%92%8C%E9%95%BF%E9%80%89%E9%A1%B9"><span class="nav-text">短选项和长选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%80%89%E9%A1%B9%E5%80%BC"><span class="nav-text">设置选项值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A6%81%E7%94%A8%E4%B8%8D%E6%8E%A5%E5%8F%97%E5%80%BC%E7%9A%84%E9%80%89%E9%A1%B9"><span class="nav-text">禁用不接受值的选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="nav-text">简单模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E6%A8%A1%E5%BC%8F"><span class="nav-text">标签模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AND-%E6%88%96"><span class="nav-text">AND 或 &amp;</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#OR"><span class="nav-text">OR</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#NOT"><span class="nav-text">NOT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ROBOT-OPTIONS-%E5%92%8C-REBOT-OPTIONS-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">ROBOT_OPTIONS 和 REBOT_OPTIONS 环境变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-text">测试结果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA"><span class="nav-text">命令行输出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%9A%84%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-text">生成的输出文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E4%BB%A3%E7%A0%81"><span class="nav-text">返回代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E8%AD%A6%E5%91%8A"><span class="nav-text">执行过程中的错误和警告</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6"><span class="nav-text">参数文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95"><span class="nav-text">参数文件语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6"><span class="nav-text">使用参数文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6"><span class="nav-text">从标准输入读取参数文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9%E5%92%8C%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-text">获取帮助和版本信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="nav-text">创建启动脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Shell-%E8%84%9A%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="nav-text">Shell 脚本示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="nav-text">批处理文件示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Python-%E7%A4%BA%E4%BE%8B"><span class="nav-text">Python 示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF-robot-%E6%96%87%E4%BB%B6%E5%8F%AF%E6%89%A7%E8%A1%8C"><span class="nav-text">使 *.robot 文件可执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98"><span class="nav-text">调试问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Python-%E8%B0%83%E8%AF%95%E5%99%A8-pdb"><span class="nav-text">使用 Python 调试器 (pdb)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C"><span class="nav-text">测试执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A5%97%E4%BB%B6%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="nav-text">执行的套件和测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%8B%86%E5%8D%B8"><span class="nav-text">设置和拆卸</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E8%AE%BE%E7%BD%AE"><span class="nav-text">套件设置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E6%8B%86%E5%8D%B8"><span class="nav-text">套件拆卸</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%AE%BE%E7%BD%AE"><span class="nav-text">测试设置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%8B%86%E5%8D%B8"><span class="nav-text">测试拆卸</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E8%AE%BE%E7%BD%AE"><span class="nav-text">用户关键字设置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%85%B3%E9%94%AE%E5%AD%97%E6%8B%86%E5%8D%B8"><span class="nav-text">用户关键字拆卸</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">执行顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%92%8C%E5%A5%97%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="nav-text">测试和套件状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PASS"><span class="nav-text">PASS</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%90%E5%89%8D%E9%80%9A%E8%BF%87%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">提前通过的测试</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FAIL"><span class="nav-text">FAIL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SKIP"><span class="nav-text">SKIP</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%89%8D%E8%B7%B3%E8%BF%87"><span class="nav-text">执行前跳过</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8A%A8%E6%80%81%E8%B7%B3%E8%BF%87"><span class="nav-text">执行过程中动态跳过</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BF%87%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">自动跳过失败的测试</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%8E%E5%85%B3%E9%94%AE%E6%80%A7%E8%BF%81%E7%A7%BB%E5%88%B0-SKIP"><span class="nav-text">从关键性迁移到 SKIP</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="nav-text">套件状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B1%E8%B4%A5%E5%90%8E%E7%BB%A7%E7%BB%AD"><span class="nav-text">失败后继续</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%9C%A8%E6%8B%86%E5%8D%B8%E5%90%8E%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C"><span class="nav-text">自动在拆卸后继续执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%93%E6%B5%8B%E8%AF%95%E6%9C%89%E6%A8%A1%E6%9D%BF%E6%97%B6%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%89%80%E6%9C%89%E9%A1%B6%E7%BA%A7%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">当测试有模板时，执行所有顶级关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A5%E8%87%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%B1%E8%B4%A5"><span class="nav-text">来自关键字的特殊失败</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Run-Keyword-And-Continue-On-Failure-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">Run Keyword And Continue On Failure 关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E7%AD%BE%E5%90%AF%E7%94%A8%E5%A4%B1%E8%B4%A5%E5%90%8E%E7%BB%A7%E7%BB%AD"><span class="nav-text">使用标签启用失败后继续</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E7%AD%BE%E7%A6%81%E7%94%A8%E5%A4%B1%E8%B4%A5%E5%90%8E%E7%BB%A7%E7%BB%AD"><span class="nav-text">使用标签禁用失败后继续</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TRY-EXCEPT"><span class="nav-text">TRY&#x2F;EXCEPT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">内置关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E5%9C%B0%E5%81%9C%E6%AD%A2%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C"><span class="nav-text">优雅地停止测试执行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E4%B8%8B-Ctrl-C"><span class="nav-text">按下 Ctrl-C</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7"><span class="nav-text">使用信号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">使用关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%93%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%A4%B1%E8%B4%A5%E6%97%B6%E5%81%9C%E6%AD%A2"><span class="nav-text">当第一个测试用例失败时停止</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E8%A7%A3%E6%9E%90%E6%88%96%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E6%97%B6%E5%81%9C%E6%AD%A2"><span class="nav-text">在解析或执行错误时停止</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86-teardowns"><span class="nav-text">处理 teardowns</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="nav-text">任务执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="nav-text">通用自动化模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="nav-text">任务相关的命令行选项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BA"><span class="nav-text">后处理输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Rebot"><span class="nav-text">使用 Rebot</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E9%80%89%E9%A1%B9%E5%92%8C%E5%8F%82%E6%95%B0"><span class="nav-text">指定选项和参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Rebot-%E7%9A%84%E8%BF%94%E5%9B%9E%E4%BB%A3%E7%A0%81"><span class="nav-text">Rebot 的返回代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-text">控制执行模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8A%A5%E5%91%8A%E3%80%81%E6%97%A5%E5%BF%97%E5%92%8C%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-text">创建报告、日志和输出文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E8%BE%93%E5%87%BA"><span class="nav-text">合并输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%9E%8D%E5%90%88%E8%BE%93%E5%87%BA"><span class="nav-text">融合输出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E5%B9%B6%E8%9E%8D%E5%90%88%E7%BB%93%E6%9E%9C"><span class="nav-text">重新执行测试并融合结果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%9E%8D%E5%90%88%E5%88%86%E6%AE%B5%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A5%97%E4%BB%B6"><span class="nav-text">融合分段执行的套件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-text">JSON 输出文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%89%A7%E8%A1%8C"><span class="nav-text">配置执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%A6%81%E8%A7%A3%E6%9E%90%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-text">选择要解析的文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-text">执行单个文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E5%92%8C%E6%8E%92%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-text">包含和排除文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%A6%81%E8%A7%A3%E6%9E%90%E7%9A%84%E6%96%87%E4%BB%B6-1"><span class="nav-text">选择要解析的文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%90%8D%E7%A7%B0%E6%88%96%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6"><span class="nav-text">根据名称或路径选择文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E6%89%A9%E5%B1%95%E5%90%8D%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6"><span class="nav-text">根据扩展名选择文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">使用自定义解析器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">选择测试用例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%B5%8B%E8%AF%95%E5%90%8D%E7%A7%B0"><span class="nav-text">通过测试名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%A5%97%E4%BB%B6%E5%90%8D%E7%A7%B0"><span class="nav-text">通过套件名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%A0%87%E7%AD%BE%E5%90%8D%E7%A7%B0"><span class="nav-text">通过标签名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">重新执行失败的测试用例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B5%8B%E8%AF%95%E5%A5%97%E4%BB%B6"><span class="nav-text">重新执行失败的测试套件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%93%E6%B2%A1%E6%9C%89%E6%B5%8B%E8%AF%95%E5%8C%B9%E9%85%8D%E9%80%89%E6%8B%A9%E6%97%B6"><span class="nav-text">当没有测试匹配选择时</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">设置元数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A5%97%E4%BB%B6%E5%90%8D%E7%A7%B0"><span class="nav-text">设置套件名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A5%97%E4%BB%B6%E6%96%87%E6%A1%A3"><span class="nav-text">设置套件文档</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%87%AA%E7%94%B1%E5%A5%97%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">设置自由套件元数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE"><span class="nav-text">设置测试标签</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%90%9C%E7%B4%A2%E5%BA%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%89%A9%E5%B1%95%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">配置搜索库和其他扩展的位置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%9C%A8%E6%A8%A1%E5%9D%97%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">自动在模块搜索路径中的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PYTHONPATH"><span class="nav-text">PYTHONPATH</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-%E2%80%93pythonpath-%E9%80%89%E9%A1%B9"><span class="nav-text">使用 –pythonpath 选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE-sys-path"><span class="nav-text">以编程方式配置 sys.path</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="nav-text">设置变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B2%E8%BF%90%E8%A1%8C"><span class="nav-text">干运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">随机化执行顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E4%BF%AE%E6%94%B9%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="nav-text">编程修改测试数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%80%89%E6%8B%A9%E6%AF%8F%E4%B8%AA-Xth-%E6%B5%8B%E8%AF%95"><span class="nav-text">示例：选择每个 Xth 测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%80%9A%E8%BF%87%E5%90%8D%E7%A7%B0%E6%8E%92%E9%99%A4%E6%B5%8B%E8%AF%95"><span class="nav-text">示例：通过名称排除测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%A6%81%E7%94%A8%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%8B%86%E5%8D%B8"><span class="nav-text">示例：禁用设置和拆卸</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"><span class="nav-text">控制控制台输出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E7%B1%BB%E5%9E%8B"><span class="nav-text">控制台输出类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%BD%E5%BA%A6"><span class="nav-text">控制台宽度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E9%A2%9C%E8%89%B2"><span class="nav-text">控制台颜色</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A0%87%E8%AE%B0"><span class="nav-text">控制台标记</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">设置监听器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-text">输出文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-text">不同的输出文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%9B%AE%E5%BD%95"><span class="nav-text">输出目录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6-1"><span class="nav-text">输出文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A7%E7%89%88%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">旧版输出文件格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-text">日志文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%A5%E5%91%8A%E6%96%87%E4%BB%B6"><span class="nav-text">报告文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#XUnit-%E5%85%BC%E5%AE%B9%E7%BB%93%E6%9E%9C%E6%96%87%E4%BB%B6"><span class="nav-text">XUnit 兼容结果文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%96%87%E4%BB%B6"><span class="nav-text">调试文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-text">时间戳输出文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%A0%87%E9%A2%98"><span class="nav-text">设置标题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2"><span class="nav-text">设置背景颜色</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="nav-text">日志级别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E7%94%A8%E7%9A%84%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="nav-text">可用的日志级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="nav-text">设置日志级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E7%9A%84%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="nav-text">可见的日志级别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E6%97%A5%E5%BF%97"><span class="nav-text">分割日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="nav-text">配置统计信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%98%BE%E7%A4%BA%E7%9A%84%E5%A5%97%E4%BB%B6%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="nav-text">配置显示的套件统计信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E5%92%8C%E6%8E%92%E9%99%A4%E6%A0%87%E7%AD%BE%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="nav-text">包含和排除标签统计信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%BB%84%E5%90%88%E6%A0%87%E7%AD%BE%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="nav-text">生成组合标签统计信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E6%A0%87%E7%AD%BE%E5%90%8D%E7%A7%B0%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5"><span class="nav-text">从标签名称创建链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E6%A0%87%E7%AD%BE%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3"><span class="nav-text">为标签添加文档</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E5%92%8C%E5%B1%95%E5%B9%B3%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">移除和展平关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">移除关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%95%E5%B9%B3%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">展平关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E5%86%85%E5%B1%95%E5%B9%B3%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">在执行时间内展平关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">自动展开关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E6%97%B6%E9%97%B4"><span class="nav-text">设置执行的开始和结束时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%8A%A5%E5%91%8A%E4%B8%AD%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-text">限制报告中错误消息的长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C"><span class="nav-text">编程修改结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="nav-text">系统日志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-Robot-Framework"><span class="nav-text">扩展 Robot Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E5%BA%93"><span class="nav-text">创建测试库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-text">支持的编程语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B5%8B%E8%AF%95%E5%BA%93-API"><span class="nav-text">不同的测试库 API</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E5%BA%93%E7%B1%BB%E6%88%96%E6%A8%A1%E5%9D%97"><span class="nav-text">创建测试库类或模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%93%E5%90%8D%E7%A7%B0"><span class="nav-text">库名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E5%BA%93%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">提供库的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%93%E8%8C%83%E5%9B%B4"><span class="nav-text">库范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%93%E7%89%88%E6%9C%AC"><span class="nav-text">库版本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F"><span class="nav-text">文档格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%93%E5%85%85%E5%BD%93%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">库充当监听器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#library-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">@library 装饰器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">创建关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E8%A2%AB%E8%A7%86%E4%B8%BA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">哪些方法被视为关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%E6%88%90%E4%B8%BA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">限制公共方法成为关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%BA%93"><span class="nav-text">基于类的库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BA%93"><span class="nav-text">基于模块的库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-not-keyword-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">使用 @not_keyword 装饰器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8D%E7%A7%B0"><span class="nav-text">关键字名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0"><span class="nav-text">设置自定义名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E6%A0%87%E7%AD%BE"><span class="nav-text">关键字标签</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="nav-text">关键字参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">关键字的默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%95%B0%E9%87%8F%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88-varargs%EF%BC%89"><span class="nav-text">变量数量的参数（*varargs）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%EF%BC%88-kwargs%EF%BC%89"><span class="nav-text">自由关键字参数（**kwargs）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%85%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="nav-text">仅关键字参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%85%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-text">仅位置参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2"><span class="nav-text">参数转换</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2"><span class="nav-text">手动参数转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">使用函数注解指定参数类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-keyword-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">使用 @keyword 装饰器指定参数类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">基于默认值的隐式参数类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">支持的转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%8F%AF%E8%83%BD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">指定多个可能的类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">泛型的类型转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="nav-text">自定义参数转换器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E9%BB%98%E8%AE%A4%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="nav-text">覆盖默认转换器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E9%94%99%E8%AF%AF"><span class="nav-text">转换错误</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-text">限制值类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-text">转换自定义类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%AA%8C%E8%AF%81"><span class="nav-text">严格的类型验证</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%8E%E8%BD%AC%E6%8D%A2%E5%99%A8%E8%AE%BF%E9%97%AE%E6%B5%8B%E8%AF%95%E5%BA%93"><span class="nav-text">从转换器访问测试库</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E5%99%A8%E6%96%87%E6%A1%A3"><span class="nav-text">转换器文档</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#keyword-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">@keyword 装饰器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#not-keyword-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">@not_keyword 装饰器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">使用自定义装饰器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%8F%82%E6%95%B0%E5%88%B0%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8D%E7%A7%B0"><span class="nav-text">嵌入参数到关键字名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">异步关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E-Robot-Framework-%E9%80%9A%E4%BF%A1"><span class="nav-text">与 Robot Framework 通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E5%AD%97%E7%8A%B6%E6%80%81"><span class="nav-text">报告关键字状态</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF-1"><span class="nav-text">错误消息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E7%9A%84-HTML"><span class="nav-text">错误消息中的 HTML</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%89%AA%E5%88%87%E9%95%BF%E6%B6%88%E6%81%AF"><span class="nav-text">自动剪切长消息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E5%9B%9E%E6%BA%AF"><span class="nav-text">跟踪回溯</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Robot-Framework-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-text">Robot Framework 提供的异常</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Failure"><span class="nav-text">Failure</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Error"><span class="nav-text">Error</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ContinuableFailure"><span class="nav-text">ContinuableFailure</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SkipExecution"><span class="nav-text">SkipExecution</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FatalError"><span class="nav-text">FatalError</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%AF%E7%BB%A7%E7%BB%AD%E7%9A%84%E5%A4%B1%E8%B4%A5"><span class="nav-text">可继续的失败</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B7%B3%E8%BF%87%E6%B5%8B%E8%AF%95"><span class="nav-text">跳过测试</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C"><span class="nav-text">停止测试执行</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E4%BF%A1%E6%81%AF"><span class="nav-text">记录信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="nav-text">使用日志级别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%92%8C%E8%AD%A6%E5%91%8A"><span class="nav-text">错误和警告</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95-HTML"><span class="nav-text">记录 HTML</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-text">时间戳</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="nav-text">记录到控制台</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%A4%BA%E4%BE%8B"><span class="nav-text">日志示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%96%E6%97%A5%E5%BF%97-API"><span class="nav-text">程序化日志 API</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%AC%E5%85%B1%E6%97%A5%E5%BF%97-API"><span class="nav-text">公共日志 API</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Python-%E7%9A%84%E6%A0%87%E5%87%86%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97"><span class="nav-text">使用 Python 的标准日志模块</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%9F%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-text">在库初始化期间进行日志记录</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B-Robot-Framework-%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C"><span class="nav-text">检测 Robot Framework 是否正在运行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%97%B6%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-text">使用线程时的通信</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E6%B5%8B%E8%AF%95%E5%BA%93"><span class="nav-text">分发测试库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%8C%96%E5%BA%93"><span class="nav-text">文档化库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%BA%93"><span class="nav-text">测试库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%8C%85%E5%BA%93"><span class="nav-text">打包库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%83%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">弃用关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93-API"><span class="nav-text">动态库 API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8D%E7%A7%B0"><span class="nav-text">获取关键字名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E8%A6%81%E4%BD%9C%E4%B8%BA%E5%85%B3%E9%94%AE%E5%AD%97%E5%85%AC%E5%BC%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">标记要作为关键字公开的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">执行关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="nav-text">获取关键字参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="nav-text">参数类型及其表示方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97-1"><span class="nav-text">执行关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">获取关键字参数类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97%E6%A0%87%E7%AD%BE"><span class="nav-text">获取关键字标签</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97%E6%96%87%E6%A1%A3"><span class="nav-text">获取关键字文档</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%80%9A%E7%94%A8%E5%BA%93%E6%96%87%E6%A1%A3"><span class="nav-text">获取通用库文档</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97%E6%BA%90%E4%BF%A1%E6%81%AF"><span class="nav-text">获取关键字源信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E8%AF%AD%E6%B3%95"><span class="nav-text">动态库中的命名参数语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%AD%E7%9A%84%E8%87%AA%E7%94%B1%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">动态库中的自由命名参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%AD%E7%9A%84%E4%BB%85%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">动态库中的仅命名参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%BA%93-API"><span class="nav-text">混合库 API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8D%E7%A7%B0-1"><span class="nav-text">获取关键字名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">运行关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E5%92%8C%E6%96%87%E6%A1%A3"><span class="nav-text">获取关键字参数和文档</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Robot-Framework-%E7%9A%84%E5%86%85%E9%83%A8%E6%A8%A1%E5%9D%97"><span class="nav-text">使用 Robot Framework 的内部模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E7%94%A8%E7%9A%84-API"><span class="nav-text">可用的 API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-BuiltIn-%E5%BA%93"><span class="nav-text">使用 BuiltIn 库</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%8E%B0%E6%9C%89%E7%9A%84%E6%B5%8B%E8%AF%95%E5%BA%93"><span class="nav-text">扩展现有的测试库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%A7%8B%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-text">修改原始源代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="nav-text">使用继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%BA%93"><span class="nav-text">直接使用其他库</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E-Robot-Framework-%E8%8E%B7%E5%8F%96%E6%B4%BB%E5%8A%A8%E5%BA%93%E5%AE%9E%E4%BE%8B"><span class="nav-text">从 Robot Framework 获取活动库实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E6%88%96%E6%B7%B7%E5%90%88-API-%E7%9A%84%E5%BA%93"><span class="nav-text">使用动态或混合 API 的库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%BA%93%E6%8E%A5%E5%8F%A3"><span class="nav-text">远程库接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Remote-%E5%BA%93"><span class="nav-text">使用 Remote 库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5-Remote-%E5%BA%93"><span class="nav-text">导入 Remote 库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">启动和停止远程服务器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-text">支持的参数和返回值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%8D%8F%E8%AE%AE"><span class="nav-text">远程协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%85%E9%9C%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">必需的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-get-keyword-names-%E5%92%8C%E7%89%B9%E5%AE%9A%E4%BA%8E%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84-getter"><span class="nav-text">使用 get_keyword_names 和特定于关键字的 getter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-get-library-information"><span class="nav-text">使用 get_library_information</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">执行远程关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8F%82%E6%95%B0%E8%AF%AD%E6%B3%95"><span class="nav-text">不同的参数语法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">监听器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E7%BB%93%E6%9E%84"><span class="nav-text">监听器结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC"><span class="nav-text">监听器接口版本</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E7%89%88%E6%9C%AC-2"><span class="nav-text">监听器版本 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E7%89%88%E6%9C%AC-3"><span class="nav-text">监听器版本 3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">使用监听器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">从命令行注册监听器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%BA%93"><span class="nav-text">作为监听器的库</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">注册监听器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%9B%91%E5%90%AC%E5%99%A8%E6%96%B9%E6%B3%95"><span class="nav-text">调用监听器方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">监听器示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF"><span class="nav-text">获取信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%92%8C%E7%BB%93%E6%9E%9C"><span class="nav-text">修改数据和结果</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A5%97%E4%BB%B6%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="nav-text">修改执行的套件和测试</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%BA%93%E6%88%96%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text">访问库或资源文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C"><span class="nav-text">修改结果</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%A4%BA%E4%BE%8B"><span class="nav-text">更多示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">解析器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">使用解析器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8-API"><span class="nav-text">解析器 API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#EXTENSION-%E6%88%96-extension-%E5%B1%9E%E6%80%A7"><span class="nav-text">EXTENSION 或 extension 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#parse-%E6%96%B9%E6%B3%95"><span class="nav-text">parse 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#parse-init-%E6%96%B9%E6%B3%95"><span class="nav-text">parse_init 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="nav-text">可选的基类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">作为模块实现的解析器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">作为类实现的解析器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%8F%AF%E9%80%89%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">扩展可选基类的解析器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">作为预处理器的解析器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7"><span class="nav-text">辅助工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%93%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%EF%BC%88Libdoc%EF%BC%89"><span class="nav-text">库文档工具（Libdoc）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">一般使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E8%A6%81-1"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E9%A1%B9"><span class="nav-text">选项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-Libdoc"><span class="nav-text">执行 Libdoc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%BA%93%E6%88%96%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text">指定库或资源文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Python-%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%90%8D%E7%A7%B0%E6%88%96%E8%B7%AF%E5%BE%84"><span class="nav-text">Python 库和动态库的名称或路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">资源文件的路径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Libdoc-%E8%A7%84%E8%8C%83%E6%96%87%E4%BB%B6"><span class="nav-text">Libdoc 规范文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3"><span class="nav-text">生成文档</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Libdoc-HTML-%E6%96%87%E6%A1%A3"><span class="nav-text">Libdoc HTML 文档</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Libdoc-XML-%E8%A7%84%E8%8C%83%E6%96%87%E4%BB%B6"><span class="nav-text">Libdoc XML 规范文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Libdoc-JSON-%E8%A7%84%E8%8C%83%E6%96%87%E4%BB%B6"><span class="nav-text">Libdoc JSON 规范文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E4%BF%A1%E6%81%AF"><span class="nav-text">在控制台查看信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#list"><span class="nav-text">list</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#show"><span class="nav-text">show</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#version"><span class="nav-text">version</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3"><span class="nav-text">编写文档</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Python-%E5%BA%93"><span class="nav-text">Python 库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-text">动态库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E9%83%A8%E5%88%86"><span class="nav-text">导入部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E6%96%87%E6%A1%A3"><span class="nav-text">资源文件文档</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E8%AF%AD%E6%B3%95"><span class="nav-text">文档语法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Robot-Framework-%E6%96%87%E6%A1%A3%E8%AF%AD%E6%B3%95"><span class="nav-text">Robot Framework 文档语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="nav-text">自动创建目录</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HTML-%E6%96%87%E6%A1%A3%E8%AF%AD%E6%B3%95"><span class="nav-text">HTML 文档语法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="nav-text">内部链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%88%B0%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">链接到关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%88%B0%E8%87%AA%E5%8A%A8%E7%AB%A0%E8%8A%82"><span class="nav-text">链接到自动章节</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%A0%E8%8A%82"><span class="nav-text">链接到自定义章节</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E5%8F%82%E6%95%B0"><span class="nav-text">表示参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%88%97%E5%87%BA%E7%B1%BB%E5%9E%8B%E6%96%87%E6%A1%A3"><span class="nav-text">自动列出类型文档</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Libdoc-%E7%A4%BA%E4%BE%8B"><span class="nav-text">Libdoc 示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%EF%BC%88Testdoc%EF%BC%89"><span class="nav-text">测试数据文档工具（Testdoc）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8-1"><span class="nav-text">一般使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E8%A6%81-2"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E9%A1%B9-1"><span class="nav-text">选项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3-1"><span class="nav-text">生成文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%88Tidy%EF%BC%89"><span class="nav-text">测试数据清理工具（Tidy）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7"><span class="nav-text">外部工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E7%94%A8%E8%AE%BE%E7%BD%AE"><span class="nav-text">可用设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%83%A8%E5%88%86-1"><span class="nav-text">设置部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E9%83%A8%E5%88%86"><span class="nav-text">测试用例部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E9%83%A8%E5%88%86"><span class="nav-text">关键字部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="nav-text">命令行选项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="nav-text">测试执行的命令行选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BA%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="nav-text">后处理输出的命令行选项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">执行和后处理的环境变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91"><span class="nav-text">翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87-zh-CN"><span class="nav-text">简体中文 (zh-CN)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%A0%87%E9%A2%98"><span class="nav-text">部分标题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE"><span class="nav-text">设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BDD-%E5%89%8D%E7%BC%80"><span class="nav-text">BDD 前缀</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">布尔字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text">文档格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD"><span class="nav-text">处理测试数据中的空白</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8D%A2%E8%A1%8C%E7%AC%A6"><span class="nav-text">换行符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E6%A0%BC"><span class="nav-text">空格</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E8%90%BD"><span class="nav-text">段落</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="nav-text">内联样式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URLs"><span class="nav-text">URLs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5%E5%92%8C%E5%9B%BE%E5%83%8F"><span class="nav-text">自定义链接和图像</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="nav-text">带有文本内容的链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="nav-text">带有图像内容的链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E6%A0%87%E9%A2%98%E6%96%87%E6%9C%AC%E7%9A%84%E5%9B%BE%E5%83%8F"><span class="nav-text">带有标题文本的图像</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E6%A0%87%E9%A2%98"><span class="nav-text">节标题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E6%A0%BC"><span class="nav-text">表格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-text">列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC"><span class="nav-text">预格式化文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%B0%BA"><span class="nav-text">水平尺</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F"><span class="nav-text">时间格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-text">作为数字的时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-text">作为时间字符串的时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA-%E2%80%9C%E8%AE%A1%E6%97%B6%E5%99%A8%E2%80%9D-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-text">作为 “计时器” 字符串的时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%8F%82%E6%95%B0"><span class="nav-text">布尔参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text">表达式求值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%82%E5%80%BC%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">求值命名空间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F-1"><span class="nav-text">使用变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E7%9A%84-variable-%E8%AF%AD%E6%B3%95"><span class="nav-text">正常的 ${variable} 语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84-variable-%E8%AF%AD%E6%B3%95"><span class="nav-text">特殊的 $variable 语法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C"><span class="nav-text">注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E4%BB%B6%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><span class="nav-text">套件文件扩展名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><span class="nav-text">资源文件扩展名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-text">媒体类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3"><span class="nav-text">远程服务器端口</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2018</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-cog fa-spin" style="--fa-animation-duration: 5s"></i>&nbsp;&nbsp;<a href="/">Yiuhang Chan</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共 41 篇文章
                    </span>
                    
                        <span>
                            共 453.8k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="right-bottom-tools rss flex justify-center items-center">
                <a class="flex justify-center items-center"
                   href="/atom.xml"
                   target="_blank"
                >
                <i class="fa-regular fa-rss"></i>
                </a>
            </li>
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>




    
<script src="/js/libs/mermaid.min.js"></script>

    
<script src="/js/plugins/mermaid.js"></script>







<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
