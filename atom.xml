<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>角灯随笔</title>
  
  <subtitle>全栈也不是不行</subtitle>
  <link href="https://www.yiuhangblog.com/atom.xml" rel="self"/>
  
  <link href="https://www.yiuhangblog.com/"/>
  <updated>2024-04-22T09:37:30.681Z</updated>
  <id>https://www.yiuhangblog.com/</id>
  
  <author>
    <name>Yiuhang Chan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Robot Framework教程</title>
    <link href="https://www.yiuhangblog.com/2024/04/19/20240419RobotFramework%E6%95%99%E7%A8%8B/"/>
    <id>https://www.yiuhangblog.com/2024/04/19/20240419RobotFramework%E6%95%99%E7%A8%8B/</id>
    <published>2024-04-19T03:17:08.000Z</published>
    <updated>2024-04-22T09:37:30.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Robot-Framework-简介"><a href="#Robot-Framework-简介" class="headerlink" title="Robot Framework 简介"></a>Robot Framework 简介</h2><p>Robot Framework是一个通用的开源自动化框架。它可用于测试自动化和机器人流程自动化（RPA）。</p><p>Robot Framework受Robot Framework基金会支持。许多行业领先的公司在其软件开发中使用该工具。</p><p>Robot Framework是开放且可扩展的。Robot Framework可以与几乎任何其他工具集成，以创建强大且灵活的自动化解决方案。Robot Framework可以免费使用，无需许可费用。</p><p>Robot Framework具有易于理解的语法，利用人类可读的关键字。其功能可以通过使用Python、Java或许多其他编程语言实现的库来扩展。Robot Framework周围有一个丰富的生态系统，包括作为单独项目开发的库和工具。</p><p>Robot Framework的开发由非营利性的Robot Framework基金会资助。它由希望确保Robot Framework现在和将来持续发展的公司和组织组成。Robot Framework仍然完全免费使用，并且在积极进行维护和开发。基金会还覆盖其他相关费用，如开发此网站和组织各种聚会。</p><p>基金会成员：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/30f9c15e-c904-4a47-6cde-d1cb3ba19900/public"                      width = "600"                ><h3 id="为什么选择-Robot-Framework？"><a href="#为什么选择-Robot-Framework？" class="headerlink" title="为什么选择 Robot Framework？"></a>为什么选择 Robot Framework？</h3><ul><li>提供了易于使用的表格语法，以统一的方式创建测试用例。</li><li>允许从现有关键字创建可重用的高级关键字。</li><li>提供易于阅读的以 HTML 格式的结果报告和日志。</li><li>平台和应用程序无关。</li><li>提供了一个简单的库 API，用于创建可以使用 Python 原生实现的定制测试库。</li><li>提供了命令行界面和基于 XML 的输出文件，用于集成到现有的构建基础设施（连续集成系统）中。</li><li>支持测试 Web 应用程序、REST API、移动应用程序、运行的进程、通过 Telnet 或 SSH 连接到远程系统等。</li><li>支持创建数据驱动的测试用例。</li><li>具有内置的变量支持，特别适用于在不同环境中进行测试。</li><li>提供标记以对测试用例进行分类和选择执行。</li><li>可以与源代码控制轻松集成：测试套件只是可以与生产代码一起进行版本控制的文件和目录。</li><li>提供了测试用例和测试套件级别的设置和拆卸。</li><li>模块化架构支持为具有多个不同接口的应用程序创建测试。</li></ul><h3 id="高级架构"><a href="#高级架构" class="headerlink" title="高级架构"></a>高级架构</h3><p>Robot Framework 是一个通用的、与应用程序和技术无关的框架。它具有高度模块化的架构，如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a8f424da-9faa-40fb-2adf-d3cb9b462100/public"                      width = "600"                ><p>测试数据以简单、易于编辑的表格格式存在。当启动 Robot Framework 时，它会处理数据，执行测试用例，并生成日志和报告。核心框架对被测试对象一无所知，与其交互由库处理。库可以直接使用应用程序接口，也可以使用较低级别的测试工具作为驱动程序。</p><h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><p>以下截屏展示了测试数据以及生成的报告和日志的示例。</p><p><strong>测试用例文件：</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c917360e-1817-4962-de2f-0a68254a0b00/public"                      width = "600"                ><p><strong>报告和日志：</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d84105c8-19e3-445a-ce35-66360e9a1700/public"                      width = "600"                ><h3 id="获取更多信息"><a href="#获取更多信息" class="headerlink" title="获取更多信息"></a>获取更多信息</h3><h4 id="项目页面"><a href="#项目页面" class="headerlink" title="项目页面"></a>项目页面</h4><p>有关 Robot Framework 及其丰富生态系统的更多信息，首要去处是 <a class="link"   href="http://robotframework.org/" >http://robotframework.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。Robot Framework 本身托管在 GitHub 上。</p><h4 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h4><p>有几个 Robot Framework 邮件列表可供询问和搜索更多信息。邮件列表存档对所有人（包括搜索引擎）开放，每个人也可以自由加入这些列表。但只有列表成员才能发送邮件，为了防止垃圾邮件，新用户需要经过审核，这意味着的第一条消息可能需要一些时间才能通过。不要害怕向邮件列表发送问题，但请记住如何聪明地提问。</p><ul><li><strong>robotframework-users（Robot Framework 用户）</strong>：关于所有与 Robot Framework 相关问题的一般讨论。可以将问题和问题发送到此列表。也用于向所有用户共享信息。</li><li><strong>robotframework-announce（Robot Framework 公告）</strong>：仅供公告的邮件列表，只有管理员才能发送消息。所有公告也发送到 robotframework-users 邮件列表，因此没有必要加入两个列表。</li><li><strong>robotframework-devel（Robot Framework 开发）</strong>：关于 Robot Framework 开发的讨论。</li></ul><h4 id="版权和许可证"><a href="#版权和许可证" class="headerlink" title="版权和许可证"></a>版权和许可证</h4><p>Robot Framework 是一款开源软件，采用 Apache License 2.0 提供。Robot Framework 的文档，例如本用户指南，使用 Creative Commons Attribution 3.0 Unported 许可证。围绕该框架的更大生态系统中的大多数库和工具也是开源的，但它们可能使用不同的许可证。</p><p>完整的 Robot Framework 版权声明如下：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2008-2015 Nokia Networks</span><br><span class="line">Copyright 2016-     Robot Framework Foundation</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure></div><p>根据 Apache 许可证第 2.0 版（“许可证”）许可；除非符合许可证的规定，否则不得使用此文件。可以在以下网址获取许可证的副本：<a class="link"   href="http://www.apache.org/licenses/LICENSE-2.0" >http://www.apache.org/licenses/LICENSE-2.0 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>除非适用法律要求或书面同意，否则根据许可证分发的软件以“原样”分发，不附带任何明示或暗示的保证或条件。请参阅许可证以了解特定语言下的权限和限制。</p><h2 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h2><p>这些指南涵盖了在不同操作系统上安装Robot Framework及其前置条件的步骤。如果已经安装了Python，可以使用标准的软件包管理器pip来安装Robot Framework：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install robotframework</span><br></pre></td></tr></table></figure></div><h3 id="Python-安装"><a href="#Python-安装" class="headerlink" title="Python 安装"></a>Python 安装</h3><p><strong>Robot Framework</strong> 是使用 <strong>Python</strong> 实现的，安装它的前提条件是已经安装了 <strong>Python</strong> 或其替代实现 <strong>PyPy</strong>。另一个推荐的前提条件是有 <strong>pip</strong> 包管理器可用。</p><p><strong>Robot Framework</strong> 需要 <strong>Python 3.8</strong> 或更新版本。支持 <strong>Python 3.6</strong> 和 <strong>3.7</strong> 的最新版本是 <strong>Robot Framework 6.1.1</strong>。如果需要使用 <strong>Python 2</strong>，<strong>Jython</strong> 或 <strong>IronPython</strong>，可以使用 <strong>Robot Framework 4.1.3</strong>。</p><h3 id="在-Linux-上安装-Python"><a href="#在-Linux-上安装-Python" class="headerlink" title="在 Linux 上安装 Python"></a>在 Linux 上安装 Python</h3><p>在 Linux 上，默认应该已经安装了适合的 Python 版本和 pip。如果没有，需要查阅发行版的文档来了解如何安装它们。如果想使用默认提供的 Python 版本之外的其他版本，这同样适用。</p><p>要检查已安装的 Python 版本，可以在终端运行 <code>python --version</code> 命令：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python --version</span></span><br><span class="line">Python 3.10.13</span><br></pre></td></tr></table></figure></div><p>注意，如果的发行版也提供了较旧的 Python 2，运行 <code>python</code> 可能会使用那个。要使用 Python 3，可以使用 <code>python3</code> 命令，或者更具体的版本命令，如 <code>python3.8</code>。如果安装了多个 Python 3 版本，也需要使用这些具体版本的变体来确定使用哪一个：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.11 --version</span></span><br><span class="line">Python 3.11.7</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.12 --version</span></span><br><span class="line">Python 3.12.1</span><br></pre></td></tr></table></figure></div><p>直接在系统提供的 Python 下安装 Robot Framework 存在风险，可能的问题会影响到操作系统本身也在使用的整个 Python 安装。现在的 Linux 发行版通常默认使用用户安装来避免此类问题，但用户也可以自己决定使用虚拟环境。</p><h3 id="Windows-上的-Python-安装"><a href="#Windows-上的-Python-安装" class="headerlink" title="Windows 上的 Python 安装"></a>Windows 上的 Python 安装</h3><ul><li>Windows 默认不提供 Python，但安装起来很简单。推荐使用官方 Windows 安装程序，可在 <a class="link"   href="http://python.org/" >http://python.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 获取。</li><li>安装 Python 时，建议将 Python 添加到 PATH，以便从命令行更容易执行 Python 及其工具，如 pip 和 Robot Framework。使用官方安装程序时，只需在第一个对话框中选择 Add Python 3.x to PATH 复选框。</li></ul><p>验证 Python 安装是否成功并已添加到 PATH：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;python --version</span><br><span class="line">Python 3.10.9</span><br></pre></td></tr></table></figure></div><ul><li>如果在 Windows 上安装了多个 Python 版本，执行 python 时使用的是 PATH 中排在首位的版本。要使用其他版本，最简单的方法是使用 py 启动器：</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;py --version</span><br><span class="line">Python 3.10.9</span><br><span class="line">C:\&gt;py -3.12 --version</span><br><span class="line">Python 3.12.1</span><br></pre></td></tr></table></figure></div><h3 id="macOS-上的-Python-安装"><a href="#macOS-上的-Python-安装" class="headerlink" title="macOS 上的 Python 安装"></a>macOS 上的 Python 安装</h3><ul><li>macOS 默认不提供与 Python 3 兼容的 Python 版本，需要单独安装。推荐使用官方 macOS 安装程序，可在 <a class="link"   href="http://python.org/" >http://python.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 获取。如果使用包管理器如 Homebrew，也可以通过它安装 Python。</li></ul><h3 id="PyPy-安装"><a href="#PyPy-安装" class="headerlink" title="PyPy 安装"></a>PyPy 安装</h3><ul><li>PyPy 是 Python 的替代实现。与标准 Python 实现相比，其主要优势是可能更快且使用更少内存，但这取决于使用的上下文。如果执行速度重要，至少测试 PyPy 是个好主意。</li></ul><p>PyPy 安装是一个简单的过程，可以在 <a class="link"   href="http://pypy.org/" >http://pypy.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 找到安装程序和安装说明。验证 PyPy 安装是否成功：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pypy --version</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pypy3 --version</span></span><br></pre></td></tr></table></figure></div><p>注意：仅在 Linux 上官方支持使用 PyPy 的 Robot Framework。</p><h3 id="配置-PATH"><a href="#配置-PATH" class="headerlink" title="配置 PATH"></a>配置 PATH</h3><ul><li>PATH 环境变量列出了系统中执行命令时搜索的目录。为了便于从命令行使用 Python、pip 和 Robot Framework，建议将 Python 安装目录以及 pip 和 robot 等命令安装的目录添加到 PATH。</li><li>在 Linux 或 macOS 上使用 Python 时，Python 及其安装的工具应自动在 PATH 中。如果仍需更新 PATH，则通常需要编辑某些系统范围或用户特定的配置文件。具体编辑哪个文件以及如何编辑取决于操作系统，需要查阅其文档了解更多详情。</li><li>在 Windows 上，确保 PATH 配置正确的最简单方法是在运行安装程序时勾选 Add Python 3.x to PATH 复选框。手动修改 Windows 上的 PATH，请按照以下步骤操作：</li></ul><ol><li>在设置中找到环境变量。有影响整个系统的变量和仅影响当前用户的变量。修改前者将需要管理员权限，但通常只需修改后者。</li><li>选择 PATH（通常写作 Path）并点击编辑。如果正在编辑用户变量且 PATH 不存在，则点击新建。</li><li>将 Python 安装目录和安装目录下的 Scripts 目录都添加到 PATH 中。</li><li>点击确定退出对话框以保存更改。</li><li>启动新的命令提示符以使更改生效。</li></ol><h3 id="使用-pip-安装"><a href="#使用-pip-安装" class="headerlink" title="使用 pip 安装"></a>使用 pip 安装</h3><h4 id="pip-命令的运行"><a href="#pip-命令的运行" class="headerlink" title="pip 命令的运行"></a>pip 命令的运行</h4><ul><li>在 Linux 上，可能需要使用 <code>pip3</code> 或更具体的 Python 版本命令，如 <code>pip3.8</code>。</li><li>在 Windows 上，当执行 <code>python</code> 时，PATH 中首先找到的版本将被使用。如果需要使用其他版本，可以运行 <code>py</code> 启动器。</li></ul><h4 id="验证-pip-是否可用"><a href="#验证-pip-是否可用" class="headerlink" title="验证 pip 是否可用"></a>验证 pip 是否可用</h4><ul><li>Linux 示例：</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip --version</span></span><br><span class="line">pip 23.2.1 from ... (python 3.10)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.12 -m pip --version</span></span><br><span class="line">pip 23.3.1 from ... (python 3.12)</span><br></pre></td></tr></table></figure></div><ul><li>Windows 示例：</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; pip --version</span><br><span class="line">pip 23.2.1 from ... (python 3.10)</span><br><span class="line">C:\&gt; py -m 3.12 -m pip --version</span><br><span class="line">pip 23.3.2 from ... (python 3.12)</span><br></pre></td></tr></table></figure></div><h4 id="安装与卸载-Robot-Framework"><a href="#安装与卸载-Robot-Framework" class="headerlink" title="安装与卸载 Robot Framework"></a>安装与卸载 Robot Framework</h4><ul><li>从 Python 包索引 (PyPI) 安装和下载包是 pip 的常用方法。</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装最新版本（不升级）</span></span><br><span class="line">pip install robotframework</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级到最新稳定版本</span></span><br><span class="line">pip install --upgrade robotframework</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级到最新版本，即使它是预发布版本</span></span><br><span class="line">pip install --upgrade --pre robotframework</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装特定版本</span></span><br><span class="line">pip install robotframework==7.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装单独下载的包（无需网络连接）</span></span><br><span class="line">pip install robotframework-7.0-py3-none-any.whl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接从 GitHub 安装最新（可能未发布）的代码</span></span><br><span class="line">pip install https://github.com/robotframework/robotframework/archive/master.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载</span></span><br><span class="line">pip uninstall robotframework</span><br></pre></td></tr></table></figure></div><h3 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h3><p>如果没有pip可用，可以通过下载PyPI上的zip包并解压，或者克隆GitHub仓库并检出所需的发布标签来获取Robot Framework源代码。</p><p>安装源代码的命令如下：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></div><p><code>setup.py</code> 脚本接受多个参数，例如允许安装到不需要管理员权限的非默认位置。此外，该脚本也用于创建不同的发行包。运行 <code>python setup.py --help</code> 可以获取更多详情。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>为了确保安装了正确版本的Robot Framework，可以运行以下命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ robot --version</span><br></pre></td></tr></table></figure></div><p>如果出现命令未找到或无法识别的消息，首先应该检查PATH配置。</p><p>如果在多个Python版本下安装了Robot Framework，运行 <code>robot</code> 将执行PATH中的第一个。要显式选择，可以运行 <code>python -m robot</code> 并用正确的Python版本替换 <code>python</code>。</p><p>例如：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3.12 -m robot --version</span><br></pre></td></tr></table></figure></div><p>或在Windows上：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;py -3.11 -m robot --version</span><br></pre></td></tr></table></figure></div><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>Python虚拟环境允许将Python包安装在特定系统或应用程序的隔离位置，而不是将所有包安装在同一全局位置。主要有两个用途：</p><ul><li>为不同项目将所需包安装在各自的环境中，避免如果项目需要不同版本的同一包时发生冲突。</li><li>避免在全局Python安装下安装所有内容。这在Linux上尤其重要，因为全局Python安装可能被发行版本身使用，搞乱它可能会导致严重问题。</li></ul><h2 id="设置集成开发环境"><a href="#设置集成开发环境" class="headerlink" title="设置集成开发环境"></a>设置集成开发环境</h2><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul><li><strong>Visual Studio Code</strong><ul><li>代码编辑。重新定义。免费。基于开源。无处不在。</li></ul></li><li><strong>PyCharm</strong><ul><li>专业开发人员的Python集成开发环境</li></ul></li></ul><h3 id="安装IDE和扩展"><a href="#安装IDE和扩展" class="headerlink" title="安装IDE和扩展"></a>安装IDE和扩展</h3><p>许多IDE和代码编辑器支持开发Robot Framework测试。</p><p>支持范围从简单的代码高亮、代码完成到测试执行和调试。</p><p>我们在这里列出了几个IDE和扩展，但还有很多其他的选择。</p><h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p>由Microsoft开发的开源轻量级代码编辑器。它提供了许多不同语言和技术的扩展。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6a381063-0304-4e9b-6da7-5312ec6f5600/public"                      width = "600"                ><p><strong>VS Code</strong></p><p>针对Robot Framework的常用扩展：</p><ul><li>Robot Code</li><li>Robot Framework Language Server</li></ul><h4 id="安装Visual-Studio-Code"><a href="#安装Visual-Studio-Code" class="headerlink" title="安装Visual Studio Code"></a>安装Visual Studio Code</h4><p>查看VS Code设置指南以获取更多信息。</p><ol><li>从Visual Studio Code下载Windows安装程序</li><li>使用默认设置运行安装程序</li><li>启动Visual Studio Code，方式有：<ul><li>按下 <code>Windows键 + R</code>，键入 <code>code</code>，然后按 <code>Enter</code></li><li>打开开始菜单，搜索 <code>Visual Studio Code</code>并单击打开</li></ul></li></ol><h4 id="Visual-Studio-Code扩展"><a href="#Visual-Studio-Code扩展" class="headerlink" title="Visual Studio Code扩展"></a>Visual Studio Code扩展</h4>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>确保仅安装了一个Robot Framework扩展。</p>    </div>  </div><p><strong>RobotCode</strong>是Visual Studio Code的一个Robot Framework扩展。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/709fba20-2801-4012-0612-4d57cbc43200/public"                      width = "600"                ><ol><li>打开Visual Studio Code</li><li>点击扩展图标或按 <code>Ctrl + Shift + X</code></li><li>搜索 <code>RobotCode</code>并点击安装</li><li>点击安装</li></ol><p><strong>Robot Framework Language Server</strong>是Visual Studio Code的一个Robot Framework扩展。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1ac9b381-8f71-4466-9681-368a1e69a800/public"                      width = "600"                ><ol><li>打开Visual Studio Code</li><li>点击扩展图标或按 <code>Ctrl + Shift + X</code></li><li>搜索 <code>Robot Framework Language Server</code>并点击安装</li><li>点击安装</li></ol><h4 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h4><p>PyCharm是一个免费开源的Python集成开发环境。</p><p>针对Robot Framework的常用扩展：</p><ul><li>Robot Framework Language Server</li></ul><h4 id="安装PyCharm"><a href="#安装PyCharm" class="headerlink" title="安装PyCharm"></a>安装PyCharm</h4><p>查看PyCharm安装指南以获取更多信息。</p><p>有两种安装方法：</p><ol><li>推荐使用JetBrains的Toolbox App。</li><li>替代的独立安装方法</li></ol><h4 id="PyCharm扩展"><a href="#PyCharm扩展" class="headerlink" title="PyCharm扩展"></a>PyCharm扩展</h4>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>确保仅安装了一个Robot Framework扩展。</p>    </div>  </div><p><strong>Robot Framework Language Server</strong></p><ol><li>按 <code>Ctrl + Alt + S</code>打开设置对话框</li><li>选择 <code>插件</code></li><li>选择 <code>市场</code>选项卡</li><li>搜索 <code>Robot Framework Language Server</code>并点击安装</li><li>为Robot Framework添加调试配置以运行当前测试套件</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93ca4a58-a443-4027-9294-03ca806b6b00/public"                      width = "600"                ><ol start="6"><li>为Robot Framework添加调试配置以运行当前测试用例（通过选择的文本）</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/34c91105-04f3-434f-f33a-6e3a158b1200/public"                      width = "600"                >  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>如果控制台输出问号或者乱码则在环境变量(Environment variables) 添加编码变量PYTHONIOENCODING&#x3D;UTF-8</p>    </div>  </div><h3 id="运行和调试Robot-Framework测试"><a href="#运行和调试Robot-Framework测试" class="headerlink" title="运行和调试Robot Framework测试"></a>运行和调试Robot Framework测试</h3><h4 id="使用Visual-Studio-Code和RobotCode"><a href="#使用Visual-Studio-Code和RobotCode" class="headerlink" title="使用Visual Studio Code和RobotCode"></a>使用Visual Studio Code和RobotCode</h4><p><strong>运行</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/35893b31-67ea-4ca1-09bd-cab884e15e00/public"                      width = "600"                ><p><strong>调试</strong></p><ul><li>在测试套件或资源文件中点击行的左侧添加断点。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8a97fa57-b2c6-4d5e-4435-7d21045fcc00/public"                      width = "600"                ><ul><li>右键单击播放按钮</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3d3a5186-3154-42c0-f5b0-3c9475e82200/public"                      width = "600"                ><ul><li>从上下文菜单中选择“调试测试”，测试执行将开始，并在断点处停止。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2fd623f9-0666-45a3-153e-59b80a81a900/public"                      width = "600"                ><ul><li>使用调试工具栏选择操作，如单步执行、进入、跳出、继续、暂停等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2fd623f9-0666-45a3-153e-59b80a81a900/public"                      width = "600"                ><ul><li>在调试控制台中调试时运行Robot Framework命令。</li><li>命令需要以！开头。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2d991a9f-4459-460d-bd01-e4f43e7faf00/public"                      width = "600"                ><h4 id="使用PyCharm和Robot-Framework-Language-Server"><a href="#使用PyCharm和Robot-Framework-Language-Server" class="headerlink" title="使用PyCharm和Robot Framework Language Server"></a>使用PyCharm和Robot Framework Language Server</h4><p><strong>运行</strong></p><ul><li>运行当前测试套件</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a40df1c6-4ecb-4437-8dc2-939499e0c900/public"                      width = "600"                ><ul><li>运行当前测试用例（通过选择的文本）</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/069aff0f-278c-4451-ad5c-d1cebb8f0900/public"                      width = "600"                ><p><strong>调试</strong></p><ul><li>调试测试</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b59df1e5-797c-4079-0589-fbe885be5300/public"                      width = "600"                ><h3 id="使用Poetry管理依赖"><a href="#使用Poetry管理依赖" class="headerlink" title="使用Poetry管理依赖"></a>使用Poetry管理依赖</h3><p>Poetry是Python的一个依赖管理和打包工具。</p><p>它允许声明项目所依赖的库，并会为管理（安装&#x2F;更新）它们。在开始任何新的Python或Robot Framework项目时，都可以使用它。</p><p>按照官方指南安装Poetry。</p><p>在PowerShell中运行以下命令：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -</span><br></pre></td></tr></table></figure></div><p>如果通过Microsoft Store安装了Python，将上述命令中的py替换为python。</p><p>运行一次poetry以检查是否已安装。</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry --version</span><br></pre></td></tr></table></figure></div><h4 id="虚拟环境文件夹"><a href="#虚拟环境文件夹" class="headerlink" title="虚拟环境文件夹"></a>虚拟环境文件夹</h4><p>Poetry会在 <code>.poetry/envs</code>文件夹中保存虚拟环境。可以更改该设置，并通过运行以下命令将虚拟环境存储在项目文件夹中：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry config virtualenvs.in-project true</span><br></pre></td></tr></table></figure></div><h4 id="初始化新项目"><a href="#初始化新项目" class="headerlink" title="初始化新项目"></a>初始化新项目</h4><p>要初始化新项目，在终端中运行以下命令：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry init</span><br></pre></td></tr></table></figure></div><p>Poetry会询问一些关于项目的问题。可以通过按Enter键留下默认值，或者输入自己的值。</p><p>示例：</p><p>此命令将引导创建 <code>pyproject.toml</code>配置。</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Package name [your-project-name]:</span><br><span class="line">Version [0.1.0]:</span><br><span class="line">Description []:</span><br><span class="line">Author [Your Name &lt;your.email@example.com&gt;, n to skip]:</span><br><span class="line">License []:</span><br><span class="line">Compatible Python versions [^3.10]:</span><br><span class="line"></span><br><span class="line">Would you like to define your main dependencies interactively? (yes/no) [yes] no</span><br><span class="line">Would you like to define your development dependencies interactively? (yes/no) [yes] no</span><br></pre></td></tr></table></figure></div><p>初始化后，会在项目文件夹中看到一个名为 <code>pyproject.toml</code>的新文件。此文件包含有关项目和依赖项的所有信息。</p><h4 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h4><p>要添加依赖项，在终端中运行以下命令：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add robotframework</span><br></pre></td></tr></table></figure></div><p>也可以一次添加多个依赖项：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add robotframework robotframework-browser robotframework-requests</span><br></pre></td></tr></table></figure></div><p>在首次运行时，poetry将为项目创建一个虚拟环境并安装依赖项。</p><h4 id="在虚拟环境中运行命令"><a href="#在虚拟环境中运行命令" class="headerlink" title="在虚拟环境中运行命令"></a>在虚拟环境中运行命令</h4><p>要在虚拟环境中运行命令，可以使用 <code>poetry run</code>命令。</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run robot --version</span><br></pre></td></tr></table></figure></div><p>例如，要安装 <code>robotframework-browser</code>的playwright依赖项，可以运行以下命令：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run rfbrowser init</span><br></pre></td></tr></table></figure></div><p>还可以使用 <code>poetry shell</code>命令在虚拟环境中打开一个shell。 在此shell中运行的所有命令都将在虚拟环境中执行。</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poetry shell</span><br><span class="line">(.venv) robot --version</span><br></pre></td></tr></table></figure></div><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>有几个演示项目介绍了Robot Framework并帮助开始使用它：</p><ul><li>快速入门指南：介绍Robot Framework最重要的特性，并作为可执行演示。<ul><li><a class="link"   href="https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst" >https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul></li><li>Robot Framework演示：简单的示例测试用例。还演示了如何创建自定义测试库。<ul><li><a class="link"   href="https://github.com/robotframework/RobotDemo" >https://github.com/robotframework/RobotDemo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul></li><li>网页测试演示：演示如何创建测试和更高级别的关键字。测试的系统是一个简单的网页，使用SeleniumLibrary进行测试。<ul><li><a class="link"   href="https://github.com/robotframework/WebDemo" >https://github.com/robotframework/WebDemo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul></li><li>使用Robot Framework进行ATDD：演示如何在遵循接受测试驱动开发（ATDD）过程时使用Robot Framework。<ul><li><a class="link"   href="https://code.google.com/p/atdd-with-robot-framework" >https://code.google.com/p/atdd-with-robot-framework <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul></li></ul><h2 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h2><h3 id="测试数据语法"><a href="#测试数据语法" class="headerlink" title="测试数据语法"></a>测试数据语法</h3><p>此部分涵盖Robot Framework的整体测试数据语法。以下各节将解释如何实际创建测试用例、测试套件等。尽管本节主要使用测试一词，但创建任务时也适用相同规则。</p><h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h4><p>安排测试用例的层次结构建立如下：</p><ul><li>测试用例在套件文件中创建。</li><li>测试用例文件自动创建一个包含该文件中测试用例的测试套件。</li><li>包含测试用例文件的目录形成一个更高级别的测试套件。这样的套件目录拥有从测试用例文件创建的子测试套件。</li><li>测试套件目录也可以包含其他测试套件目录，这种层次结构可以根据需要深入嵌套。</li><li>测试套件目录可以有一个特殊的初始化文件，用于配置创建的测试套件。</li></ul><p>此外，还包括：</p><ul><li>包含最低级关键字的测试库。</li><li>带有变量和更高级用户关键字的资源文件。</li><li>提供比资源文件更灵活的创建变量方式的变量文件。</li></ul><p>测试用例文件、测试套件初始化文件和资源文件都使用Robot Framework测试数据语法创建。测试库和变量文件使用“真实”编程语言创建，通常是Python。</p><h4 id="测试数据部分"><a href="#测试数据部分" class="headerlink" title="测试数据部分"></a>测试数据部分</h4><p>Robot Framework数据在不同部分定义，这些部分通常也称为表格，如下所列：</p><table><thead><tr><th align="left">部分</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">Settings</td><td align="left">1) 导入测试库、资源文件和变量文件。<br />2) 定义测试套件和测试用例的元数据。</td></tr><tr><td align="left">Variables</td><td align="left">定义可以在测试数据中其他地方使用的变量。</td></tr><tr><td align="left">Test Cases</td><td align="left">从可用关键字创建测试用例。</td></tr><tr><td align="left">Tasks</td><td align="left">使用可用关键字创建任务。单个文件只能包含测试或任务。</td></tr><tr><td align="left">Keywords</td><td align="left">从现有的低级关键字创建用户关键字。</td></tr><tr><td align="left">Comments</td><td align="left">额外的评论或数据。被Robot Framework忽略。</td></tr></tbody></table><p>不同部分通过其标题行被识别。推荐的标题格式是 <code>*** Settings***</code>，但标题不区分大小写，周围的空格是可选的，星号字符的数量可以变化，只要开头至少有一个星号。例如，<code>*Settings</code>也会被识别为部分标题。</p><p>Robot Framework也支持单数标题，如 <code>*** Setting***</code>，但该支持在Robot Framework 6.0中已被弃用。从Robot Framework 7.0开始会有可见的弃用警告，最终单数标题将完全不被支持。</p><p>标题行也可以包含实际部分标题以外的其他数据。额外的数据必须使用数据格式依赖的分隔符与部分标题分开，通常是两个或更多空格。这些额外的标题在解析时会被忽略，但它们可以用于文档记录目的。在使用数据驱动风格创建测试用例时，这特别有用。</p><p>第一部分之前的可能数据被忽略。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>部分标题可以本地化。有关支持的翻译，请参阅翻译。</p>    </div>  </div><h4 id="支持的文件格式"><a href="#支持的文件格式" class="headerlink" title="支持的文件格式"></a>支持的文件格式</h4><p>创建Robot Framework数据的最常见方法是使用空格分隔的格式，其中数据的各个部分，例如关键字及其参数，用两个或更多空格分隔。</p><p>另一种方法是使用管道分隔的格式，其中分隔符是用空格括起来的管道字符 <code>|</code>。</p><p>套件文件通常使用 <code>.robot</code>扩展名，但可以配置解析哪些文件。资源文件也可以使用 <code>.robot</code>扩展名，但建议使用专用的 <code>.resource</code>扩展名，并且在将来可能会被强制执行。</p><p>包含非ASCII字符的文件必须使用UTF-8编码保存。</p><p>Robot Framework还支持reStructuredText文件，以便将普通的Robot Framework数据嵌入到代码块中。默认情况下，仅解析具有 <code>.robot.rst</code>扩展名的文件。如果更喜欢使用 <code>.rst</code>或 <code>.rest</code>扩展名，那么需要单独配置。</p><p>Robot Framework数据还可以以JSON格式创建，该格式更针对工具开发人员而不是普通的Robot Framework用户。默认情况下，仅解析具有自定义 <code>.rbt</code>扩展名的JSON文件。</p><p>较早的Robot Framework版本还支持HTML和TSV格式的数据。如果数据与空格分隔格式兼容，则TSV格式仍然有效，但完全删除了对HTML格式的支持。如果遇到此类数据文件，需要将其转换为纯文本格式，以便在Robot Framework 3.2或更新版本中使用。最简单的方法是使用Tidy工具，但必须使用Robot Framework 3.1附带的版本，因为更新版本根本不理解HTML格式。</p><h4 id="空格分隔格式"><a href="#空格分隔格式" class="headerlink" title="空格分隔格式"></a>空格分隔格式</h4><p>当Robot Framework解析数据时，它首先将数据拆分为行，然后将行拆分为诸如关键字和参数之类的标记。在使用空格分隔格式时，标记之间的分隔符是两个或更多空格，或者是一个或多个制表符。除了正常的ASCII空格之外，任何被视为空格的Unicode字符（例如不间断空格）都可以作为分隔符。分隔标记所使用的空格数量可以变化，只要至少有两个，这样在设置和其他地方对齐数据时就可以使数据更易于理解。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation     使用空格分隔格式的示例。</span><br><span class="line">Library           OperatingSystem</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;MESSAGE&#125;        好，世界！</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">我的测试</span><br><span class="line">    [Documentation]    示例测试。</span><br><span class="line">    Log    $&#123;MESSAGE&#125;</span><br><span class="line">    My Keyword    $&#123;CURDIR&#125;</span><br><span class="line"></span><br><span class="line">另一个测试</span><br><span class="line">    Should Be Equal    $&#123;MESSAGE&#125;    好，世界！</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">My Keyword</span><br><span class="line">    [Arguments]    $&#123;path&#125;</span><br><span class="line">    Directory Should Exist    $&#123;path&#125;</span><br></pre></td></tr></table></figure></div><p>在这个示例中：</p><ul><li><code>*** Settings ***</code>：定义了测试或任务的设置。</li><li><code>Documentation</code>：提供了对测试或任务的描述。</li><li><code>Library</code>：指定了测试或任务中将使用的库。</li><li><code>*** Variables ***</code>：声明了在测试中使用的变量。</li><li><code>$&#123;MESSAGE&#125;</code>：变量的名称，其值为“好，世界！”。</li><li><code>*** Test Cases ***</code>：标记了测试用例的开始。</li><li><code>我的测试</code>和 <code>另一个测试</code>：测试用例的名称。</li><li><code>[Documentation]</code>：为测试用例提供了额外的描述。</li><li><code>Log</code>：一个关键字，用于记录信息。</li><li><code>My Keyword</code>：自定义关键字的名称。</li><li><code>Should Be Equal</code>：一个内置关键字，用于断言两个值是否相等。</li><li><code>*** Keywords ***</code>：标记了自定义关键字的开始。</li><li><code>[Arguments]</code>：定义了关键字的参数。</li><li><code>Directory Should Exist</code>：一个内置关键字，用于验证指定路径的目录是否存在。</li></ul><p>因为制表符和连续的空格被视为分隔符，所以如果在关键字参数或实际数据的其他位置需要它们，则必须对它们进行转义。可以使用特殊的转义语法，如 <code>\t</code>表示制表符，<code>\xA0</code>表示不间断空格，以及内置变量 <code>$&#123;SPACE&#125;</code>和 <code>$&#123;EMPTY&#125;</code>。详情请参阅转义部分。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/566a2630-666b-4bec-05a3-8eba7d2b8100/public"                      width = "600"                >  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>虽然使用两个空格作为分隔符就足够了，但建议使用四个空格，以便更容易识别分隔符。</p>    </div>  </div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在Robot Framework 3.2之前，数据中使用的非ASCII空格在解析过程中会被转换为ASCII空格。现在所有数据都保持原样。</p>    </div>  </div><h4 id="管道分隔格式"><a href="#管道分隔格式" class="headerlink" title="管道分隔格式"></a>管道分隔格式</h4><p>空格分隔格式的最大问题是在视觉上将关键字与参数分开可能会很棘手。这个问题特别突出，特别是如果关键字需要很多参数和&#x2F;或参数包含空格的情况下。在这种情况下，管道分隔的变体可能会更好，因为它使分隔符更加明显可见。</p><p>一个文件可以同时包含空格分隔和管道分隔的行。管道分隔的行通过强制性的前导管道字符进行识别，但行尾的管道是可选的。除了在行的开头和结尾，管道的两侧始终必须至少有一个空格或制表符。不需要对齐管道，但通常这样做会使数据更易于阅读。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">| *** Settings ***   |</span><br><span class="line">| Documentation      | 使用管道分隔格式的示例。</span><br><span class="line">| Library            | OperatingSystem</span><br><span class="line"></span><br><span class="line">| *** Variables ***  |</span><br><span class="line">| $&#123;MESSAGE&#125;         | 好，世界！</span><br><span class="line"></span><br><span class="line">| *** Test Cases *** |                 |               |</span><br><span class="line">| My Test            | [Documentation] | 示例测试。    |</span><br><span class="line">|                    | Log             | $&#123;MESSAGE&#125;    |</span><br><span class="line">|                    | My Keyword      | $&#123;CURDIR&#125;     |</span><br><span class="line">| Another Test       | Should Be Equal | $&#123;MESSAGE&#125;    | 好，世界！</span><br><span class="line"></span><br><span class="line">| *** Keywords ***   |                        |         |</span><br><span class="line">| My Keyword         | [Arguments]            | $&#123;path&#125; |</span><br><span class="line">|                    | Directory Should Exist | $&#123;path&#125; |</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/13ab6da9-18d2-4f79-09c7-b6696b2b1600/public"                      width = "600"                ><p>在使用管道分隔格式时，参数内部的连续空格或制表符不需要转义。同样，空列不需要转义，除非它们位于末尾。然而，在实际测试数据中可能被空格包围的管道必须使用反斜杠进行转义：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| *** Test Cases *** |                 |                 |                      |</span><br><span class="line">| Escaping Pipe      | $&#123;file count&#125; = | Execute Command | ls -1 *.txt \| wc -l |</span><br><span class="line">|                    | Should Be Equal | $&#123;file count&#125;   | 42                   |</span><br></pre></td></tr></table></figure></div><ol><li><code>Execute Command</code> 关键字执行了 <code>ls -1 *.txt | wc -l</code> 命令。</li><li><code>ls -1 *.txt</code> 列出了当前目录中所有以 <code>.txt</code> 结尾的文件。</li><li><code>wc -l</code> 统计了文件的行数。</li></ol><p>最终，验证了文件的行数是否等于 42。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>保留参数中的连续空格和制表符是Robot Framework 3.2的新功能。在此之前，数据中使用的非ASCII空格也会被转换为ASCII空格。</p>    </div>  </div><h4 id="reStructuredText-格式"><a href="#reStructuredText-格式" class="headerlink" title="reStructuredText 格式"></a>reStructuredText 格式</h4><p>reStructuredText（reST）是一种易于阅读的纯文本标记语法，通常用于Python项目的文档，包括Python本身以及本用户指南。reST文档最常编译为HTML，但也支持其他输出格式。使用reST与Robot Framework结合使用，允许在简洁的文本格式中混合富格式文档和测试数据，这样就可以使用简单的文本编辑器、差异工具和源代码控制系统轻松地处理。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>使用reStructuredText文件与Robot Framework需要安装Python docutils模块。</p><p>当使用Robot Framework与reStructuredText文件时，普通的Robot Framework数据被嵌入到所谓的代码块中。在标准reST中，代码块使用代码指令进行标记，但Robot Framework还支持Sphinx工具使用的code-block或sourcecode指令。</p>    </div>  </div><h5 id="reStructuredText-示例"><a href="#reStructuredText-示例" class="headerlink" title="reStructuredText 示例"></a>reStructuredText 示例</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.. code:: robotframework</span><br><span class="line"></span><br><span class="line">   *** Settings ***</span><br><span class="line">   Documentation    使用reStructuredText格式的示例。</span><br><span class="line">   Library          OperatingSystem</span><br><span class="line"></span><br><span class="line">   *** Variables ***</span><br><span class="line">   $&#123;MESSAGE&#125;       好，世界！</span><br><span class="line"></span><br><span class="line">   *** Test Cases ***</span><br><span class="line">   My Test</span><br><span class="line">       [Documentation]    示例测试。</span><br><span class="line">       Log    $&#123;MESSAGE&#125;</span><br><span class="line">       My Keyword    $&#123;CURDIR&#125;</span><br><span class="line"></span><br><span class="line">   Another Test</span><br><span class="line">       Should Be Equal    $&#123;MESSAGE&#125;    好，世界！</span><br><span class="line"></span><br><span class="line">另外，这段文字也位于代码块之外，会被忽略。不包含Robot Framework数据的代码块也会被忽略。</span><br><span class="line"></span><br><span class="line">.. code:: robotframework</span><br><span class="line"></span><br><span class="line">   # 支持空格和管道分隔格式。</span><br><span class="line"></span><br><span class="line">   | *** Keywords ***  |                        |         |</span><br><span class="line">   | My Keyword        | [Arguments]            | $&#123;path&#125; |</span><br><span class="line">   |                   | Directory Should Exist | $&#123;path&#125; |</span><br><span class="line"></span><br><span class="line">.. code:: python</span><br><span class="line"></span><br><span class="line">   # 此代码块被忽略。</span><br><span class="line">   def example():</span><br><span class="line">       print(&#x27;Hello, world!&#x27;)</span><br></pre></td></tr></table></figure></div><p>Robot Framework支持使用 <code>.robot.rst</code>、<code>.rst</code>和 <code>.rest</code>扩展名的reStructuredText文件。为了避免解析不相关的reStructuredText文件，当执行目录时，默认情况下仅解析具有 <code>.robot.rst</code>扩展名的文件。可以通过使用 <code>--parseinclude</code>或 <code>--extension</code>选项来启用解析具有其他扩展名的文件。</p><p>当Robot Framework解析reStructuredText文件时，忽略严重级别以下的错误，以避免可能的非标准指令和其他标记的噪音。这也可能隐藏了真正的错误，但在通常使用reStructuredText工具处理文件时可以看到它们。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>自动解析 <code>.robot.rst</code>文件是Robot Framework 6.1的新功能。</p>    </div>  </div><h4 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h4><p>Robot Framework 支持 JSON 格式的数据。这种格式主要为工具开发者设计，而不是为常规的 Robot Framework 用户设计，因此不建议手动编辑。它的主要用途包括：</p><ul><li>在进程和机器之间传输数据。可以在一台机器上将套件转换为 JSON，然后在其他地方重新创建。</li><li>将可能是嵌套套件的套件，从常规的 Robot Framework 数据构建成单个的 JSON 文件，这样解析起来更快。</li><li>为生成测试或任务的外部工具提供替代的数据格式。</li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>JSON 数据支持是在 Robot Framework 6.1 中新增的，未来的 Robot Framework 版本中可能会进行增强。</p>    </div>  </div><h5 id="将套件转换为-JSON"><a href="#将套件转换为-JSON" class="headerlink" title="将套件转换为 JSON"></a>将套件转换为 JSON</h5><p>可以使用 <code>TestSuite.to_json</code> 方法将套件结构序列化为 JSON。如果没有参数，它会返回 JSON 数据作为字符串，但它也接受一个路径或一个打开的文件，以及与 JSON 格式相关的配置选项：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> TestSuite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于文件系统上的数据创建套件。</span></span><br><span class="line">suite = TestSuite.from_file_system(<span class="string">&#x27;/path/to/data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 JSON 数据作为字符串。</span></span><br><span class="line">data = suite.to_json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 JSON 数据保存到文件中，自定义缩进。</span></span><br><span class="line">suite.to_json(<span class="string">&#x27;data.rbt&#x27;</span>, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><p>如果更愿意使用 Python 数据，然后自己将其转换为 JSON 或其他格式，可以使用 <code>TestSuite.to_dict</code>。</p><h5 id="从-JSON-创建套件"><a href="#从-JSON-创建套件" class="headerlink" title="从 JSON 创建套件"></a>从 JSON 创建套件</h5><p>可以使用 <code>TestSuite.from_json</code> 方法从 JSON 数据构建套件。它既可以处理 JSON 字符串，也可以处理 JSON 文件的路径：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> TestSuite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中的 JSON 数据创建套件。</span></span><br><span class="line">suite = TestSuite.from_json(<span class="string">&#x27;data.rbt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 JSON 字符串创建套件。</span></span><br><span class="line">suite = TestSuite.from_json(<span class="string">&#x27;&#123;&quot;name&quot;: &quot;Suite&quot;, &quot;tests&quot;: [&#123;&quot;name&quot;: &quot;Test&quot;&#125;]&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行套件。注意，日志和报告需要单独创建。</span></span><br><span class="line">suite.run(output=<span class="string">&#x27;example.xml&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p>如果有一个 Python 字典的数据，可以使用 <code>TestSuite.from_dict</code>。无论套件是如何重新创建的，它只存在于内存中，原始的数据文件在文件系统上不会被重新创建。</p><p>如上例所示，可以使用 <code>TestSuite.run</code> 方法执行创建的套件。然而，直接执行 JSON 文件可能更容易，如下一节所述。</p><h5 id="执行-JSON-文件"><a href="#执行-JSON-文件" class="headerlink" title="执行 JSON 文件"></a>执行 JSON 文件</h5><p>当使用 <code>robot</code> 命令执行测试或任务时，带有自定义 <code>.rbt</code> 扩展名的 JSON 文件会被自动解析。这包括运行像 <code>robot tests.rbt</code> 这样的单个 JSON 文件，以及运行包含 <code>.rbt</code> 文件的目录。如果更愿意使用标准的 <code>.json</code> 扩展名，需要配置哪些文件需要解析。</p><h5 id="调整套件源"><a href="#调整套件源" class="headerlink" title="调整套件源"></a>调整套件源</h5><p>从 <code>TestSuite.to_json</code> 和 <code>TestSuite.to_dict</code> 获取的数据中的套件源是绝对格式的。如果稍后在不同的机器上重新创建套件，源可能不匹配该机器上的目录结构。为了避免这种情况，可以使用 <code>TestSuite.adjust_source</code> 方法在获取数据之前使套件源相对化，并在套件重新创建后添加正确的根目录：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.running <span class="keyword">import</span> TestSuite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建套件，调整源并转换为 JSON。</span></span><br><span class="line">suite = TestSuite.from_file_system(<span class="string">&#x27;/path/to/data&#x27;</span>)</span><br><span class="line">suite.adjust_source(relative_to=<span class="string">&#x27;/path/to&#x27;</span>)</span><br><span class="line">suite.to_json(<span class="string">&#x27;data.rbt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在其他地方重新创建套件并相应地调整源。</span></span><br><span class="line">suite = TestSuite.from_json(<span class="string">&#x27;data.rbt&#x27;</span>)</span><br><span class="line">suite.adjust_source(root=<span class="string">&#x27;/new/path/to&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h5 id="JSON-结构"><a href="#JSON-结构" class="headerlink" title="JSON 结构"></a>JSON 结构</h5><p>在套件文件中创建的导入项、变量和关键字都包含在生成的 JSON 中，以及测试和任务。具体的 JSON 结构在 <code>running.json</code> 架构文件中有文档说明。</p><h4 id="数据解析规则"><a href="#数据解析规则" class="headerlink" title="数据解析规则"></a>数据解析规则</h4><h5 id="忽略的数据"><a href="#忽略的数据" class="headerlink" title="忽略的数据"></a>忽略的数据</h5><p>当 Robot Framework 解析测试数据文件时，它会忽略：</p><ul><li>第一个测试数据部分之前的所有数据。</li><li>评论部分中的数据。</li><li>所有空行。</li><li>当使用管道分隔格式时，行尾的所有空单元格。</li><li>当不用于转义时，所有的单个反斜杠（\）。</li><li>当它是单元格的第一个字符时，井号（#）后面的所有字符。这意味着可以使用井号在测试数据中输入注释。</li></ul><p>当 Robot Framework 忽略一些数据时，这些数据在任何生成的报告中都不可用，此外，大多数与 Robot Framework 一起使用的工具也会忽略它们。要添加在 Robot Framework 输出中可见的信息，请将其放在测试用例或套件的文档或其他元数据中，或使用 BuiltIn 关键字 Log 或 Comment 进行记录。</p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>Robot Framework 测试数据中的转义字符是反斜杠 <code>\</code>，此外，内置变量 EMPTY和{SPACE} 通常也可以用于转义。下面的各节将讨论不同的转义机制。</p><h5 id="转义特殊字符"><a href="#转义特殊字符" class="headerlink" title="转义特殊字符"></a>转义特殊字符</h5><p>反斜杠字符可以用来转义特殊字符，以便使用它们的字面值:</p><table><thead><tr><th align="left">字符</th><th align="left">含义</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">美元符号，不会开始标量变量。</td><td align="left">${notvar}</td></tr><tr><td align="left">@</td><td align="left">电子邮件符号，不会开始列表变量。</td><td align="left">@{notvar}</td></tr><tr><td align="left">&amp;</td><td align="left">和号，不会开始字典变量。</td><td align="left">&amp;{notvar}</td></tr><tr><td align="left">%</td><td align="left">百分号，不会开始环境变量。</td><td align="left">%{notvar}</td></tr><tr><td align="left">#</td><td align="left">井号，不会开始注释。</td><td align="left"># not comment</td></tr><tr><td align="left">=</td><td align="left">等号，不会成为命名参数语法的一部分。</td><td align="left">not=named</td></tr><tr><td align="left">|</td><td align="left">管道字符，不是管道分隔格式的分隔符。</td><td align="left">ls -1 *.txt| wc -l</td></tr><tr><td align="left">\</td><td align="left">反斜杠字符，不会转义任何东西。</td><td align="left">c:\temp, \${var}</td></tr></tbody></table><h5 id="形成转义序列"><a href="#形成转义序列" class="headerlink" title="形成转义序列"></a>形成转义序列</h5><p>反斜杠字符也允许创建特殊的转义序列，这些序列被识别为在测试数据中难以或无法创建的字符:</p><p>转义序列：</p><table><thead><tr><th align="left">序列</th><th align="left">含义</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行符</td><td align="left">first line\n2nd line</td></tr><tr><td align="left">\r</td><td align="left">回车符</td><td align="left">text\rmore text</td></tr><tr><td align="left">\t</td><td align="left">制表符</td><td align="left">text\tmore text</td></tr><tr><td align="left">\xhh</td><td align="left">十六进制值为 hh 的字符</td><td align="left">空字节：\x00，ä：\xE4</td></tr><tr><td align="left">\uhhhh</td><td align="left">十六进制值为 hhhh 的字符</td><td align="left">雪人：\u2603</td></tr><tr><td align="left">\Uhhhhhhhh</td><td align="left">十六进制值为 hhhhhhhh 的字符</td><td align="left">爱情旅馆：\U0001f3e9</td></tr></tbody></table>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在测试数据中创建的所有字符串，包括像 <code>\x02</code> 这样的字符，都是 Unicode，如果需要，必须显式地转换为字节字符串。这可以通过使用 BuiltIn 和 String 库中的 <code>Convert To Bytes</code> 或 <code>Encode String To Bytes</code> 关键字来完成，或者在 Python 代码中使用类似于 <code>value.encode(&#39;UTF-8&#39;)</code> 的语句来完成。</p>    </div>  </div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>如果在 <code>\x</code>、<code>\u</code> 或 <code>\U</code> 转义中使用了无效的十六进制值，最终的结果是原始值，但没有反斜杠字符。例如，<code>\xAX</code>（不是十六进制）和 <code>\U00110000</code>（值过大）分别会得到 <code>xAX</code> 和 <code>U00110000</code>。尽管如此，这种行为在未来可能会改变。</p>    </div>  </div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>如果需要操作系统依赖的行终止符，可以使用内置变量 <code>${\n}</code>（在 Windows 上是 <code>\r\n</code>，在其他地方是 <code>\n</code>）。</p>    </div>  </div><h4 id="处理空值"><a href="#处理空值" class="headerlink" title="处理空值"></a>处理空值</h4><p>当使用空格分隔格式时，用作分隔符的空格数量可以变化，因此除非进行转义，否则无法识别空值。空单元格可以用反斜杠字符或内置变量 <code>$&#123;EMPTY&#125;</code> 进行转义。通常推荐使用后者，因为它更容易理解。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">使用反斜杠</span><br><span class="line">    Do Something    first arg    \</span><br><span class="line">    Do Something    \            second arg</span><br><span class="line"></span><br><span class="line">使用 $&#123;EMPTY&#125;</span><br><span class="line">    Do Something    first arg    $&#123;EMPTY&#125;</span><br><span class="line">    Do Something    $&#123;EMPTY&#125;     second arg</span><br></pre></td></tr></table></figure></div><p>当使用管道分隔格式时，只有当空值位于行尾时，才需要对空值进行转义：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| *** Test Cases *** |              |           |            |</span><br><span class="line">| 使用反斜杠         | Do Something | first arg | \          |</span><br><span class="line">|                    | Do Something |           | second arg |</span><br><span class="line">|                    |              |           |            |</span><br><span class="line">| 使用 $&#123;EMPTY&#125;      | Do Something | first arg | $&#123;EMPTY&#125;   |</span><br><span class="line">|                    | Do Something |           | second arg |</span><br></pre></td></tr></table></figure></div><h4 id="处理空格"><a href="#处理空格" class="headerlink" title="处理空格"></a>处理空格</h4><p>空格，尤其是连续的空格，作为关键字的参数或者其他需要的一部分，会有两个问题：</p><ul><li>当使用空格分隔格式时，两个或更多连续的空格被视为分隔符。</li><li>当使用管道分隔格式时，忽略前导和尾随空格。</li></ul><p>在这些情况下，需要对空格进行转义。与转义空值类似，可以通过使用反斜杠字符或使用内置变量 <code>$&#123;SPACE&#125;</code> 来实现。</p><p>转义空格示例：</p><table><thead><tr><th>使用反斜杠转义</th><th>使用 <code>$&#123;SPACE&#125;</code> 转义</th><th>注释</th></tr></thead><tbody><tr><td>\ leading space</td><td><code>$&#123;SPACE&#125;</code>leading space</td><td></td></tr><tr><td>trailing space \</td><td>trailing space <code>$&#123;SPACE&#125;</code></td><td>反斜杠必须在空格后面。</td></tr><tr><td>\ \</td><td><code>$&#123;SPACE&#125;</code></td><td>两边都需要反斜杠。</td></tr><tr><td>consecutive \ \ spaces</td><td>consecutive <code>$&#123;SPACE * 3&#125;</code>spaces</td><td>使用扩展变量语法。</td></tr></tbody></table><p>如上例所示，使用 <code>$&#123;SPACE&#125;</code> 变量通常使测试数据更容易理解。当需要多个空格时，它与扩展变量语法结合使用特别方便。</p><h4 id="将数据分割到多行"><a href="#将数据分割到多行" class="headerlink" title="将数据分割到多行"></a>将数据分割到多行</h4><p>如果一行的数据过多，可以将其分割，并使用省略号（…）开始连续的行。省略号可以缩进以匹配起始行的缩进，并且必须始终跟随正常的测试数据分隔符。</p><p>在大多数地方，分割的行与未分割的行具有完全相同的语义。此规则的例外是套件、测试和关键字文档以及套件元数据。对于它们，分割的值会自动用换行符连接在一起，以便创建多行值。</p><p><code>...</code> 语法也允许在变量部分分割变量。当长标量变量（例如 <code>$&#123;STRING&#125;</code>）被分割到多行时，最终的值是通过将行连接在一起得到的。默认的分隔符是空格，但可以通过以 <code>SEPARATOR=&lt;sep&gt;</code> 开始值来更改。</p><p>以下两个示例说明了分割行，它们包含了完全相同的数据，但一个没有分割，一个进行了分割:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation      这里是这个套件的文档。\n文档通常很长。\n\n它也可以包含多个段落。</span><br><span class="line">Default Tags       默认标签 1    默认标签 2    默认标签 3    默认标签 4    默认标签 5</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;STRING&#125;          这是一个长字符串。它有多个句子。它没有换行符。</span><br><span class="line">$&#123;MULTILINE&#125;       这是一个长的多行字符串。\n这是第二行。\n这是第三行，也是最后一行。</span><br><span class="line">@&#123;LIST&#125;            这     列表     是    相当    长     并且    列表中的项目也可能很长</span><br><span class="line">&amp;&#123;DICT&#125;            first=这个值相当长。    second=这个值甚至更长。它有两个句子。</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]        可能    不    会    在    真实    生活中    有    这么    多    标签</span><br><span class="line">    Do X    第一个参数    第二个参数    第三个参数    第四个参数    第五个参数    第六个参数</span><br><span class="line">    $&#123;var&#125; =    Get X    传递给这个关键字的第一个参数相当长    传递给这个关键字的第二个参数也很长</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation      这里是这个套件的文档。</span><br><span class="line">...                文档通常很长。</span><br><span class="line">...</span><br><span class="line">...                它也可以包含多个段落。</span><br><span class="line">Default Tags       默认标签 1    默认标签 2    默认标签 3</span><br><span class="line">...                默认标签 4    默认标签 5</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;STRING&#125;          这是一个长字符串。</span><br><span class="line">...                它有多个句子。</span><br><span class="line">...                它没有换行符。</span><br><span class="line">$&#123;MULTILINE&#125;       SEPARATOR=\n</span><br><span class="line">...                这是一个长的多行字符串。</span><br><span class="line">...                这是第二行。</span><br><span class="line">...                这是第三行，也是最后一行。</span><br><span class="line">@&#123;LIST&#125;            这     列表     是      相当    长     并且</span><br><span class="line">...                列表中的项目也可能很长</span><br><span class="line">&amp;&#123;DICT&#125;            first=这个值相当长。</span><br><span class="line">...                second=这个值甚至更长。它有两个句子。</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    [Tags]        可能    不    会    在    真实    生活中    有    这么    多</span><br><span class="line">    ...       标签    在    真实    生活中</span><br><span class="line">    Do X    第一个参数    第二个参数    第三个参数</span><br><span class="line">    ...    第四个参数    第五个参数    第六个参数</span><br><span class="line">    $&#123;var&#125; =    Get X</span><br><span class="line">    ...    传递给这个关键字的第一个参数相当长</span><br><span class="line">    ...    传递给这个关键字的第二个参数也很长</span><br></pre></td></tr></table></figure></div><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>Robot Framework 的本地化工作始于 Robot Framework 6.0，它允许翻译部分标题、设置、在行为驱动开发（BDD）中使用的 Given&#x2F;When&#x2F;Then 前缀，以及在自动布尔参数转换中使用的 true 和 false 字符串。未来计划扩展本地化支持，例如，到日志和报告，甚至可能也包括控制结构。</p><p>本节解释如何激活语言，支持哪些内置语言，如何创建自定义语言文件，以及如何贡献新的翻译。</p><h5 id="启用语言"><a href="#启用语言" class="headerlink" title="启用语言"></a>启用语言</h5><p>使用命令行选项 激活语言的主要机制是使用 <code>--language</code> 选项从命令行指定它们。当启用内置语言时，可以使用语言名称（如 Chinese Simplified）或语言代码（如 fi）。名称和代码都不区分大小写和空格，也忽略连字符（-）。要启用多种语言，需要多次使用 <code>--language</code> 选项：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --language Chinese Simplified testit.robot</span><br><span class="line">robot --language pt --language ptbr testes.robot</span><br></pre></td></tr></table></figure></div><p>当激活自定义语言文件时，也使用相同的 <code>--language</code> 选项。对于它们，值可以是文件的路径，或者，如果文件在模块搜索路径中，可以是模块名称：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">robot --language Custom.py tests.robot</span><br><span class="line">robot --language MyLang tests.robot</span><br></pre></td></tr></table></figure></div><p>出于向后兼容性的原因，以及为了支持部分翻译，英语总是自动激活的。未来的版本可能允许禁用它。</p><p>预文件配置 也可以直接在数据文件中启用语言，方法是在任何部分标题之前有一行 <code>Language: &lt;value&gt;</code>（不区分大小写）。冒号后的值与 <code>--language</code> 选项的解释方式相同：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Language: Chinese Simplified</span><br><span class="line"></span><br><span class="line">*** Asetukset ***</span><br><span class="line">Dokumentaatio        Example using Chinese Simplified.</span><br></pre></td></tr></table></figure></div><p>如果需要启用多种语言，可以重复 <code>Language:</code> 行。这些配置行不能在注释中，所以像 <code># Language: Chinese Simplified</code> 这样的内容没有效果。</p><p>由于技术限制，每个文件的语言配置也会影响后续文件的解析以及整个执行。这种行为可能在未来会改变，因此不应依赖它。如果使用每个文件的配置，应该在所有文件中使用它，或者使用 <code>--language</code> 选项全局启用语言。</p><h5 id="自定义语言文件"><a href="#自定义语言文件" class="headerlink" title="自定义语言文件"></a>自定义语言文件</h5><p>如果需要的语言不是内置语言，或者想为某些特定需求创建一个完全自定义的语言，可以轻松地创建一个自定义语言文件。语言文件是 Python 文件，包含一个或多个语言定义，当语言文件被使用时，所有的语言定义都会被加载。语言定义是通过扩展 <code>robot.api.Language</code> 基类并根据需要覆盖类属性来创建的：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> Language</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>(<span class="title class_ inherited__">Language</span>):</span><br><span class="line">    test_cases_header = <span class="string">&#x27;Validations&#x27;</span></span><br><span class="line">    tags_setting = <span class="string">&#x27;Labels&#x27;</span></span><br><span class="line">    given_prefixes = [<span class="string">&#x27;Assuming&#x27;</span>]</span><br><span class="line">    true_strings = [<span class="string">&#x27;OK&#x27;</span>, <span class="string">&#x27;\N&#123;THUMBS UP SIGN&#125;&#x27;</span>]</span><br></pre></td></tr></table></figure></div><p>假设上述代码位于 <code>example.py</code> 文件中，当激活语言文件时，可以使用该文件的路径或仅使用模块名称 <code>example</code>。</p><p>上述示例只添加了一些可能的翻译。这是可以的，因为英语总是会自动启用。大多数值必须指定为字符串，但 BDD 前缀和 true&#x2F;false 字符串允许多个值，并且必须给出列表。有关更多示例，请参见 Robot Framework 的内部语言模块，该模块包含 <code>Language</code> 类以及所有内置语言定义。</p><h3 id="创建测试用例"><a href="#创建测试用例" class="headerlink" title="创建测试用例"></a>创建测试用例</h3><p>当创建测试用例时，通常会采用以下的测试用例语法。将测试用例组织成测试套件，可以使用套件文件和套件目录，具体内容请参阅下一节。</p><p>当在使用机器人框架进行除了测试自动化以外的其他自动化任务时，建议创建任务而不是测试。任务的语法在大部分情况下与测试的语法相同，不同之处将在创建任务部分进行解释。</p><h4 id="测试用例语法"><a href="#测试用例语法" class="headerlink" title="测试用例语法"></a>测试用例语法</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>测试用例是在测试用例部分中从可用关键字构建的。关键字可以从测试库或资源文件导入，或者在测试用例文件本身的关键字部分中创建。</p><p>测试用例部分的第一列包含测试用例名称。测试用例从此列中有内容的行开始，并继续到下一个测试用例名称或部分的结束。在部分标题和第一个测试之间有内容是错误的。</p><p>第二列通常有关键字名称。此规则的一个例外是从关键字返回值设置变量，当第二列和可能的后续列包含变量名称，并且关键字名称位于它们之后。在任一情况下，关键字名称后的列包含指定关键字的可能参数。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Valid Login</span><br><span class="line">    Open Login Page</span><br><span class="line">    Input Username    demo</span><br><span class="line">    Input Password    mode</span><br><span class="line">    Submit Credentials</span><br><span class="line">    Welcome Page Should Be Open</span><br><span class="line"></span><br><span class="line">Setting Variables</span><br><span class="line">    Do Something    first argument    second argument</span><br><span class="line">    $&#123;value&#125; =    Get Some Value</span><br><span class="line">    Should Be Equal    $&#123;value&#125;    Expected value</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>虽然测试用例名称可以包含任何字符，但通常不建议使用 ? 和尤其是 *，因为它们在选择测试用例时被视为通配符。例如，尝试只运行名为 Example * 的测试，如 <code>--test &#39;Example *&#39;</code>，实际上会运行以 Example 开头的任何测试。</p>    </div>  </div><h5 id="在测试用例部分的设置"><a href="#在测试用例部分的设置" class="headerlink" title="在测试用例部分的设置"></a>在测试用例部分的设置</h5><p>测试用例也可以有自己的设置。设置名称总是在第二列，通常是关键字的位置，它们的值在后续的列中。设置名称周围有方括号，以便将它们与关键字区分开来。下面列出了可用的设置，并在本节后面进行了解释。</p><p><em>[Documentation]</em></p><pre><code>[文档] 用于指定测试用例文档。</code></pre><p><em>[Setup]</em>, <em>[Teardown]</em></p><pre><code>[设置], [拆卸] 指定测试设置和拆卸。</code></pre><p><em>[Tags]</em></p><pre><code>[标签] 用于标记测试用例。</code></pre><p> <em>[Template]</em></p><pre><code>[模板] 指定要使用的模板关键字。测试本身将只包含用作该关键字参数的数据。</code></pre><p><em>[Timeout]</em></p><pre><code>[超时] 用于设置测试用例超时。超时在其自己的部分中进行了讨论。</code></pre>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>设置名称不区分大小写，但推荐使用上述格式。设置曾经也不区分空格，但在 Robot Framework 3.1 中已被弃用，尝试使用像 [T a g s] 这样的东西会在 Robot Framework 3.2 中引发错误。仍然允许在括号和名称之间可能存在的空格（例如 [ 标签 ]）。</p>    </div>  </div><p>带有设置的测试用例示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Test With Settings</span><br><span class="line">    [Documentation]    Another dummy test</span><br><span class="line">    [Tags]    dummy    owner-johndoe</span><br><span class="line">    Log    Hello, world!</span><br></pre></td></tr></table></figure></div><h5 id="在设置部分的测试用例相关设置"><a href="#在设置部分的测试用例相关设置" class="headerlink" title="在设置部分的测试用例相关设置"></a>在设置部分的测试用例相关设置</h5><p>设置部分可以有以下与测试用例相关的设置。这些设置主要是前面列出的特定于测试用例的设置的默认值。</p><p>测试设置，测试拆卸 测试设置和拆卸的默认值。 测试标签 套件中所有测试将获得的标签，除了它们可能自己的标签。 测试模板 要使用的默认模板关键字。 测试超时 测试用例超时的默认值。超时在其自己的部分中进行了讨论。</p><p>[<em>Test Setup</em>, <em>Test Teardown</em>]</p><pre><code>[测试设置，测试拆卸] 默认值为测试设置和拆卸。</code></pre><p>[<em>Test Tags</em>]</p><pre><code>[测试标签] 套件中所有测试将获得的标签，除了它们可能自己的标签。</code></pre><p>[<em>Test Template</em>]</p><pre><code>[测试模板] 要使用的默认模板关键字。</code></pre><p>[<em>Test Timeout</em>]</p><pre><code>[测试超时] 测试用例超时的默认值。超时在其自己的部分中进行了讨论。</code></pre><h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p>前面的例子已经展示了关键字如何接受不同的参数，本节将更全面地讨论这一重要功能。如何实际实现带有不同参数的用户定义关键字和库关键字将在后续章节中讨论。</p><p>关键字可以接受零个或多个参数，某些参数可能具有默认值。关键字接受哪些参数取决于其实现，通常最好的信息来源是关键字的文档。在本节的例子中，文档预期是使用Libdoc工具生成的，但相同的信息也可在使用通用文档工具如pydoc生成的文档中找到。</p><h5 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h5><p>大多数关键字都有一定数量的参数，必须始终给出。在关键字文档中，这通过指定用逗号分隔的参数名表示，如 <code>first, second, third</code>。在这种情况下，参数名实际上并不重要，除了它们应该解释参数的作用，但重要的是必须有与文档中指定的完全相同数量的参数。使用的参数太少或太多都会导致错误。</p><p>下面的测试使用了来自<a class="link"   href="https://robotframework.org/robotframework/latest/libraries/OperatingSystem.html" >OperatingSystem <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>库的关键字 <code>Create Directory</code> 和 <code>Copy File</code>。它们的参数分别指定为 <code>path</code> 和 <code>source, destination</code>，这意味着它们分别接受一个和两个参数。最后一个关键字，来自BuiltIn的 No Operation，不接受任何参数。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library         OperatingSystem</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Create Directory    \$&#123;TEMPDIR&#125;/stuff</span><br><span class="line">    Copy File    \$&#123;CURDIR&#125;/file.txt    \$&#123;TEMPDIR&#125;/stuff</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>参数通常具有默认值，可以给出或不给出。在文档中，默认值通常与参数名称用等号分隔，如 <code>name=default value</code>。所有参数都有默认值是可能的，但在具有默认值的参数之后不能有任何位置参数。</p><p>使用默认值的示例如下所示，其中使用了 <code>Create File</code> 关键字，其参数为 <code>path</code>、<code>content=</code> 和 <code>encoding=UTF-8</code>。尝试在没有任何参数或多于三个参数的情况下使用它将无法正常工作。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Create File    $&#123;TEMPDIR&#125;/empty.txt</span><br><span class="line">    Create File    $&#123;TEMPDIR&#125;/utf-8.txt         Hyvä esimerkki</span><br><span class="line">    Create File    $&#123;TEMPDIR&#125;/iso-8859-1.txt    Hyvä esimerkki    ISO-8859-1</span><br></pre></td></tr></table></figure></div><h5 id="可变数量的参数"><a href="#可变数量的参数" class="headerlink" title="可变数量的参数"></a>可变数量的参数</h5><p>也有可能某个关键字接受任意数量的参数。这些所谓的变长参数可以与必需参数和具有默认值的参数组合使用，但它们始终在它们之后给出。在文档中，它们的参数名称前面有一个星号，如 *varargs。</p><p>例如，操作系统库中的 <code>Remove Files</code> 和 <code>Join Paths</code> 关键字具有参数 <em>paths 和 base、</em>parts，分别。前者可以接受任意数量的参数，但后者至少需要一个参数。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Remove Files    $&#123;TEMPDIR&#125;/f1.txt    $&#123;TEMPDIR&#125;/f2.txt    $&#123;TEMPDIR&#125;/f3.txt</span><br><span class="line">    @&#123;paths&#125; =    Join Paths    $&#123;TEMPDIR&#125;    f1.txt    f2.txt    f3.txt    f4.txt</span><br></pre></td></tr></table></figure></div><p>在这个示例中：</p><ul><li><code>*** Test Cases ***</code>：定义了测试用例的开始。</li><li><code>Example</code>：测试用例的名称。</li><li><code>Remove Files    $&#123;TEMPDIR&#125;/f1.txt    $&#123;TEMPDIR&#125;/f2.txt    $&#123;TEMPDIR&#125;/f3.txt</code>：执行了一个关键字，删除了指定的文件。</li><li><code>@&#123;paths&#125; =    Join Paths    $&#123;TEMPDIR&#125;    f1.txt    f2.txt    f3.txt    f4.txt</code>：执行了另一个关键字，将路径组合在一起。</li></ul><h5 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h5><p>命名参数语法使得使用具有默认值的参数更加灵活，并允许明确标记某个参数值的含义。从技术上讲，命名参数的工作方式与Python中的关键字参数完全相同。</p><h6 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h6><p>可以通过在值前加上参数名（如 <code>arg=value</code>）来命名给关键字的参数。当多个参数具有默认值时，这特别有用，因为可以只命名一些参数，让其他参数使用其默认值。例如，如果一个关键字接受参数 <code>arg1=a</code>，<code>arg2=b</code>，<code>arg3=c</code>，并且它被调用时只有一个参数 <code>arg3=override</code>，那么参数 <code>arg1</code> 和 <code>arg2</code> 将获得其默认值，但 <code>arg3</code> 将获得值 <code>override</code>。如果这听起来很复杂，下面的命名参数示例应该会使其更清晰。</p><p>命名参数语法对大小写和空格都很敏感。前者意味着，如果有一个参数 <code>arg</code>，必须像 <code>arg=value</code> 这样使用它，而 <code>Arg=value</code> 或 <code>ARG=value</code> 都不行。后者意味着，在 <code>=</code> 符号前不允许有空格，可能在其后的空格将被视为给定值的一部分。</p><p>当命名参数语法与用户关键字一起使用时，必须在不带 <code>$&#123;&#125;</code> 装饰的情况下给出参数名。例如，带有参数 <code>$&#123;arg1&#125;=first</code>，<code>$&#123;arg2&#125;=second</code> 的用户关键字必须像 <code>arg2=override</code> 这样使用。</p><p>在命名参数之后使用普通位置参数，例如 <code>| Keyword | arg=value | positional |</code>，是不行的。命名参数的相对顺序并不重要。</p><h6 id="命名参数与变量"><a href="#命名参数与变量" class="headerlink" title="命名参数与变量"></a>命名参数与变量</h6><p>在命名参数的名称和值中都可以使用变量。如果值是单个标量变量，它将按原样传递给关键字。这允许在使用命名参数语法时，也可以使用任何对象，而不仅仅是字符串，作为值。例如，调用像 <code>arg=$&#123;object&#125;</code> 这样的关键字将把变量 <code>$&#123;object&#125;</code> 传递给关键字，而不会将其转换为字符串。</p><p>如果在命名参数名称中使用变量，变量在与参数名称匹配之前就会被解析。</p><p>命名参数语法要求在关键字调用中直接写入等号。这意味着，即使变量具有像 <code>foo=bar</code> 这样的值，单独的变量也永远不会触发命名参数语法。这一点在将关键字包装到其他关键字中时尤其需要记住。例如，如果一个关键字接受像 <code>@&#123;args&#125;</code> 这样的变量数量的参数，并使用相同的 <code>@&#123;args&#125;</code> 语法将所有参数传递给另一个关键字，那么在调用端使用的可能的 <code>named=arg</code> 语法将不会被识别。下面的示例进行了说明。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Run Program    shell=True    # 这将不会作为一个命名参数传递给 Run Process</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Run Program</span><br><span class="line">    [Arguments]    @&#123;args&#125;</span><br><span class="line">    Run Process    program.py    @&#123;args&#125;    # 在 @&#123;args&#125; 内部不会识别命名参数</span><br></pre></td></tr></table></figure></div><p>如果关键字需要接受并传递任何命名参数，它必须被改变以接受自由命名参数。参见自由命名参数示例，了解一个可以传递位置参数和命名参数的包装关键字版本。</p><h5 id="转义命名参数语法"><a href="#转义命名参数语法" class="headerlink" title="转义命名参数语法"></a>转义命名参数语法</h5><p>命名参数语法仅在等号前的参数部分与关键字的某个参数匹配时使用。可能存在一个位置参数，其字面值如 <code>foo=quux</code>，并且还有一个名为 <code>foo</code> 的无关参数。在这种情况下，参数 <code>foo</code> 可能错误地获取值 <code>quux</code>，或者更可能的是，出现语法错误。</p><p>在这些偶尔出现的匹配错误的情况下，可以使用反斜杠字符来转义语法，如 <code>foo\=quux</code>。现在，参数将获得字面值 <code>foo=quux</code>。请注意，如果没有名为 <code>foo</code> 的参数，那么不需要转义，但是因为它使情况更加明确，所以可能仍然是个好主意。</p><h6 id="命名参数支持的位置"><a href="#命名参数支持的位置" class="headerlink" title="命名参数支持的位置"></a>命名参数支持的位置</h6><p>如前所述，命名参数语法适用于关键字。除此之外，它还适用于导入库时。</p><p>用户关键字和大多数测试库都支持命名参数。唯一的例外是明确使用位置参数的Python关键字。</p><h6 id="命名参数示例"><a href="#命名参数示例" class="headerlink" title="命名参数示例"></a>命名参数示例</h6><p>以下示例演示了如何在库关键字、用户关键字以及导入 Telnet 测试库时使用命名参数语法。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    Telnet    prompt=$    default_log_level=DEBUG</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Open connection    10.0.0.42    port=$&#123;PORT&#125;    alias=example</span><br><span class="line">    List files    options=-lh</span><br><span class="line">    List files    path=/tmp    options=-l</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">List files</span><br><span class="line">    [Arguments]    $&#123;path&#125;=.    $&#123;options&#125;=</span><br><span class="line">    Execute command    ls $&#123;options&#125; $&#123;path&#125;</span><br></pre></td></tr></table></figure></div><h5 id="自由命名参数"><a href="#自由命名参数" class="headerlink" title="自由命名参数"></a>自由命名参数</h5><p>Robot Framework支持自由命名参数，通常也被称为自由关键字参数或kwargs，类似于Python支持的**kwargs。这意味着一个关键字可以接收所有使用命名参数语法（<code>name=value</code>）的参数，并且不匹配关键字签名中指定的任何参数。</p><p>自由命名参数由与普通命名参数相同的关键字类型支持。关键字如何指定它们接受自由命名参数取决于关键字类型。例如，基于Python的关键字简单地使用**kwargs，用户关键字使用 <code>&amp;&#123;kwargs&#125;</code>。</p><p>自由命名参数支持变量，就像命名参数一样。在实践中，这意味着变量可以同时用在名称和值中，但是转义符必须始终直接可见。例如，只要使用的变量存在，<code>foo=$&#123;bar&#125;</code>和 <code>$&#123;foo&#125;=$&#123;bar&#125;</code>都是有效的。额外的限制是自由参数名称必须始终是字符串。</p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>作为使用自由命名参数的第一个示例，让我们看一下Process库中的Run Process关键字。它有一个签名 <code>command</code>，<code>*arguments</code>，<code>**configuration</code>，这意味着它接收要执行的命令（<code>command</code>），其参数作为可变数量的参数（<code>*arguments</code>）以及最后的可选配置参数作为自由命名参数（<code>**configuration</code>）。下面的示例还显示了变量与自由关键字参数一起工作的方式，就像使用命名参数语法时一样。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Free Named Arguments</span><br><span class="line">    Run Process    program.py    arg1    arg2    cwd=/home/user</span><br><span class="line">    Run Process    program.py    argument    shell=True    env=$&#123;ENVIRON&#125;</span><br></pre></td></tr></table></figure></div><p>请参阅创建测试库下的自由关键字参数（**kwargs）部分，以获取有关在自定义测试库中使用自由命名参数语法的更多信息。</p><p>作为第二个示例，让我们创建一个包装用户关键字，用于运行上述示例中的program.py。包装关键字Run Program接受所有位置和命名参数，并将它们连同要执行的命令名称一起传递给Run Process。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Free Named Arguments</span><br><span class="line">    Run Program    arg1    arg2    cwd=/home/user</span><br><span class="line">    Run Program    argument    shell=True    env=$&#123;ENVIRON&#125;</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Run Program</span><br><span class="line">    [Arguments]    @&#123;args&#125;    &amp;&#123;config&#125;</span><br><span class="line">    Run Process    program.py    @&#123;args&#125;    &amp;&#123;config&#125;</span><br></pre></td></tr></table></figure></div><h5 id="仅命名参数"><a href="#仅命名参数" class="headerlink" title="仅命名参数"></a>仅命名参数</h5><p>从Robot Framework 3.1开始，关键字可以接受必须始终使用命名参数语法进行命名的参数。例如，如果一个关键字接受一个仅命名参数 <code>example</code>，那么它必须始终像 <code>example=value</code> 这样使用，而不能仅使用 <code>value</code>。这种语法受到了Python 3支持的仅关键字参数语法的启发。</p><p>在大多数情况下，仅命名参数的工作方式与命名参数相同。主要的区别是，使用静态库API实现的Python 2库不支持此语法。</p><p>作为使用用户关键字的仅命名参数的一个示例，下面是上述自由命名参数示例中的Run Program的一个变体，它只支持配置shell：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Named-only Arguments</span><br><span class="line">    Run Program    arg1    arg2              # &#x27;shell&#x27; 是 False (默认)</span><br><span class="line">    Run Program    argument    shell=True    # &#x27;shell&#x27; 是 True</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Run Program</span><br><span class="line">    [Arguments]    @&#123;args&#125;    $&#123;shell&#125;=False</span><br><span class="line">    Run Process    program.py    @&#123;args&#125;    shell=$&#123;shell&#125;</span><br></pre></td></tr></table></figure></div><h6 id="嵌入到关键字名称中的参数"><a href="#嵌入到关键字名称中的参数" class="headerlink" title="嵌入到关键字名称中的参数"></a>嵌入到关键字名称中的参数</h6><p>指定参数的一种完全不同的方法是将参数嵌入到关键字名称中。这种语法由测试库关键字和用户关键字都支持。</p><h4 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h4><h5 id="测试用例失败时"><a href="#测试用例失败时" class="headerlink" title="测试用例失败时"></a>测试用例失败时</h5><p>如果测试用例使用的任何关键字失败，测试用例就会失败。通常，这意味着该测试用例的执行将停止，可能执行测试拆解，然后从下一个测试用例继续执行。如果不希望停止测试执行，也可以使用特殊的可继续失败。</p><h5 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h5><p>分配给失败的测试用例的错误消息直接来自失败的关键字。通常，错误消息是由关键字本身创建的，但是一些关键字允许配置它们。</p><p>在某些情况下，例如当使用可继续失败时，一个测试用例可能会失败多次。在这种情况下，最终的错误消息是通过组合各个错误得到的。非常长的错误消息会自动从中间切断，以使报告更易于阅读，但完整的错误消息始终作为失败关键字的消息在日志文件中可见。</p><p>默认情况下，错误消息是普通文本，但它们可以包含HTML格式。这通过在错误消息开始处使用标记字符串 <em>HTML</em> 来启用。这个标记将从报告和日志中显示的最终错误消息中删除。下面的第二个示例显示了在自定义消息中使用HTML。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Normal Error</span><br><span class="line">    Fail    这是一个相当无聊的例子...</span><br><span class="line"></span><br><span class="line">HTML Error</span><br><span class="line">    $&#123;number&#125; =    Get Number</span><br><span class="line">    Should Be Equal    $&#123;number&#125;    42    *HTML* 数字不是我的&lt;b&gt;魔法&lt;/b&gt;数字。</span><br></pre></td></tr></table></figure></div><h4 id="测试用例名称和文档"><a href="#测试用例名称和文档" class="headerlink" title="测试用例名称和文档"></a>测试用例名称和文档</h4><p>测试用例名称直接来自测试用例部分：它就是输入到测试用例列中的内容。一个测试套件中的测试用例应该有唯一的名称。关于这一点，也可以在测试本身中使用自动变量 <code>$&#123;TEST_NAME&#125;</code> 来引用测试名称。无论何时执行测试，包括所有用户关键字，以及测试设置和测试拆解，它都是可用的。</p><p>从Robot Framework 3.2开始，测试用例名称中可能的变量会被解析，以便最终名称将包含变量值。如果变量不存在，其名称将保持不变。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;MAX AMOUNT&#125;      $&#123;5000000&#125;</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Amount cannot be larger than $&#123;MAX AMOUNT&#125;</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure></div><p>[Documentation] 设置允许为测试用例设置自由形式的文档。该文本将显示在命令行输出和生成的日志和报告中。如果文档过长，可以将其分割成多行。可以使用简单的HTML格式，并且可以使用变量使文档动态化。可能不存在的变量将保持不变。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Simple</span><br><span class="line">    [Documentation]    简单且短小的文档。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Multiple lines</span><br><span class="line">    [Documentation]    文档的第一行。</span><br><span class="line">    ...</span><br><span class="line">    ...                文档在这里继续。这些行在HTML输出中形成</span><br><span class="line">    ...                一个段落。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Formatting</span><br><span class="line">    [Documentation]</span><br><span class="line">    ...    这个列表有：</span><br><span class="line">    ...    - *粗体*</span><br><span class="line">    ...    - _斜体_</span><br><span class="line">    ...    - 链接: http://robotframework.org</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Variables</span><br><span class="line">    [Documentation]    在 $&#123;HOST&#125; 上由 $&#123;USER&#125; 执行</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div><p>测试用例有清晰和描述性的名称是很重要的，而在这种情况下，它们通常不需要任何文档。如果测试用例的逻辑需要文档化，这通常是一个信号，表示测试用例中的关键字需要更好的名称，它们需要被增强，而不是添加额外的文档。最后，元数据，如上述最后一个示例中的环境和用户信息，通常最好使用标签来指定。</p><h4 id="标记测试用例"><a href="#标记测试用例" class="headerlink" title="标记测试用例"></a>标记测试用例</h4><p>在Robot Framework中使用标签是一种简单而强大的机制，用于分类测试用例和用户关键字。标签是自由文本，Robot Framework本身对它们没有特殊的含义，除了下面讨论的保留标签。标签至少可以用于以下目的：</p><ul><li>它们显示在测试报告、日志以及测试数据中，因此它们为测试用例提供元数据。</li><li>基于它们自动收集关于测试用例（总数、通过、失败和跳过）的统计信息。</li><li>它们可以用于包含和排除以及跳过测试用例。</li></ul><p>有多种方式可以为测试用例指定标签，如下所述：</p><ul><li>在设置部分中的测试标签设置<ul><li>具有此设置的测试用例文件中的所有测试始终获得指定的标签。如果在套件初始化文件中使用此设置，所有子套件中的测试都会获得这些标签。</li></ul></li><li>每个测试用例的[Tags]设置<ul><li>测试将获得这些标签，除了使用测试标签设置指定的标签。[Tags]设置还允许使用-tag语法删除使用测试标签设置的标签。</li></ul></li><li>–settag命令行选项<ul><li>所有测试都会获得此选项设置的标签，除了它们在其他地方获得的标签。</li></ul></li><li>Set Tags，Remove Tags，Fail和Pass Execution关键字<ul><li>这些BuiltIn关键字可以用于在测试执行期间动态操作标签。</li></ul></li></ul><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***git fetch origin</span><br><span class="line">Test Tags       requirement: 42    smoke</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;HOST&#125;         10.0.1.42</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">No own tags</span><br><span class="line">    [Documentation]    测试有标签 &#x27;requirement: 42&#x27; 和 &#x27;smoke&#x27;。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own tags</span><br><span class="line">    [Documentation]    测试有标签 &#x27;requirement: 42&#x27;，&#x27;smoke&#x27; 和 &#x27;not ready&#x27;。</span><br><span class="line">    [Tags]    not ready</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own tags with variable</span><br><span class="line">    [Documentation]    测试有标签 &#x27;requirement: 42&#x27;，&#x27;smoke&#x27; 和 &#x27;host: 10.0.1.42&#x27;。</span><br><span class="line">    [Tags]    host: $&#123;HOST&#125;</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Remove common tag</span><br><span class="line">    [Documentation]    测试只有标签 &#x27;requirement: 42&#x27;。</span><br><span class="line">    [Tags]    -smoke</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Remove common tag using a pattern</span><br><span class="line">    [Documentation]    测试只有标签 &#x27;smoke&#x27;。</span><br><span class="line">    [Tags]    -requirement: *</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Set Tags and Remove Tags keywords</span><br><span class="line">    [Documentation]    这个测试有标签 &#x27;smoke&#x27;，&#x27;example&#x27; 和 &#x27;another&#x27;。</span><br><span class="line">    Set Tags    example    another</span><br><span class="line">    Remove Tags    requirement: *</span><br></pre></td></tr></table></figure></div><p>如示例所示，可以使用变量创建标签，但否则它们保留数据中使用的确切名称。当比较标签时，例如，收集统计信息，选择要执行的测试，或者删除重复项，比较是大小写、空格和下划线不敏感的。</p><p>如上述示例所示，使用-tag语法删除标签支持简单的模式，如-requirement: *。以连字符开头的标签除了在[Tags]设置中没有其他特殊含义。如果需要使用[Tags]设置一个以连字符开头的标签，可以使用转义格式，如-tag。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>测试标签设置是在Robot Framework 6.0中新增的。早期版本支持Force Tags和Default Tags设置，这将在下一节中讨论。</p>    </div>  </div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>删除常见标签的-tag语法是在Robot Framework 7.0中新增的。</p>    </div>  </div><h5 id="弃用-Force-Tags-和-Default-Tags"><a href="#弃用-Force-Tags-和-Default-Tags" class="headerlink" title="弃用 Force Tags 和 Default Tags"></a>弃用 Force Tags 和 Default Tags</h5><p>在Robot Framework 6.0之前，可以使用两种不同的设置在设置部分为测试指定标签：</p><p>Force Tags 所有测试无条件地获得这些标签。这与现在的Test Tags完全相同。 Default Tags 所有测试默认获得这些标签。如果测试有[Tags]，它将不会获得这些标签。 这两种设置仍然可以工作，但它们被认为是已弃用的。将来会添加一个可见的弃用警告，最可能在Robot Framework 8.0中，最终这些设置将被删除。可以使用像Tidy这样的工具来简化过渡。</p><p>更新Force Tags只需要将其重命名为Test Tags。Default Tags设置将被完全删除，但在Robot Framework 7.0中引入的-tag功能提供了相同的基础功能。下面的示例演示了所需的更改。</p><p>旧语法：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Force Tags      all</span><br><span class="line">Default Tags    default</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Common only</span><br><span class="line">    [Documentation]    测试有标签 &#x27;all&#x27; 和 &#x27;default&#x27;。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">No default</span><br><span class="line">    [Documentation]    测试只有标签 &#x27;all&#x27;。</span><br><span class="line">    [Tags]</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own and no default</span><br><span class="line">    [Documentation]    测试有标签 &#x27;all&#x27; 和 &#x27;own&#x27;。</span><br><span class="line">    [Tags]    own</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div><p>新语法：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Test Tags      all    default</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Common only</span><br><span class="line">    [Documentation]    测试有标签 &#x27;all&#x27; 和 &#x27;default&#x27;。</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">No default</span><br><span class="line">    [Documentation]    测试只有标签 &#x27;all&#x27;。</span><br><span class="line">    [Tags]    -default</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Own and no default</span><br><span class="line">    [Documentation]    测试有标签 &#x27;all&#x27; 和 &#x27;own&#x27;。</span><br><span class="line">    [Tags]    own    -default</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div><h5 id="保留标签"><a href="#保留标签" class="headerlink" title="保留标签"></a>保留标签</h5><p>用户通常可以自由地使用在他们的上下文中工作的任何标签。然而，有一些标签对于Robot Framework本身有预定义的含义，用它们来做其他用途可能会有意想不到的结果。Robot Framework现在和将来所有的特殊标签都有 <code>robot:</code> 前缀。为了避免问题，用户因此不应该使用任何带有这个前缀的标签，除非实际激活特殊功能。当前的保留标签列在下面，但是未来可能会添加更多这样的标签。</p><ul><li><pre><code>robot:continue-on-failure<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>robot:recursive-continue-on-failure<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 用于启用继续失败模式。</span><br><span class="line">- ```</span><br><span class="line">  robot:stop-on-failure</span><br></pre></td></tr></table></figure></div>和<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot:recursive-stop-on-failure</span><br></pre></td></tr></table></figure></div>- 用于禁用继续失败模式。</code></pre></li><li><pre><code>robot:skip-on-failure<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 如果测试失败，则标记为跳过。</span><br><span class="line">- ```</span><br><span class="line">  robot:skip</span><br></pre></td></tr></table></figure></div>- 无条件跳过测试。</code></pre></li><li><pre><code>robot:exclude<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 无条件排除测试。</span><br><span class="line">- ```</span><br><span class="line">  robot:private</span><br></pre></td></tr></table></figure></div>- 标记关键字为私有。</code></pre></li><li><pre><code>robot:no-dry-run<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 标记关键字在干运行模式下不执行。</span><br><span class="line">- ```</span><br><span class="line">  robot:exit</span><br></pre></td></tr></table></figure></div>- 当执行停止时，自动添加到测试中。</code></pre></li><li><pre><code>robot:flatten<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在执行时间启用平铺关键字。</span><br><span class="line"></span><br><span class="line">从RobotFramework 4.1开始，默认情况下在标签统计中抑制保留标签。当它们通过 `--tagstatinclude robot:*` 命令行选项明确包含时，它们将被显示。</span><br><span class="line"></span><br><span class="line">#### 测试设置和拆解</span><br><span class="line"></span><br><span class="line">Robot Framework具有与许多其他测试自动化框架类似的测试设置和拆解功能。简单来说，测试设置是在测试用例之前执行的操作，而测试拆解是在测试用例之后执行的操作。在Robot Framework中，设置和拆解只是具有可能参数的普通关键字。</span><br><span class="line"></span><br><span class="line">设置和拆解总是单个关键字。如果它们需要处理多个独立的任务，可以创建高级用户关键字来实现。另一种解决方案是使用BuiltIn关键字Run Keywords执行多个关键字。</span><br><span class="line"></span><br><span class="line">测试拆解在两个方面特殊。首先，即使测试用例失败，它也会被执行，所以它可以用于必须完成的清理活动，无论测试用例的状态如何。此外，即使其中一个关键字失败，拆解中的所有关键字也会被执行。这种继续失败的功能也可以用于普通关键字，但在拆解中它默认是开启的。</span><br><span class="line"></span><br><span class="line">在测试用例文件中为测试用例指定设置或拆解的最简单方法是使用设置部分中的Test Setup和Test Teardown设置。单个测试用例也可以有自己的设置或拆解。它们是在测试用例部分的[Setup]或[Teardown]设置中定义的，并且它们会覆盖可能的Test Setup和Test Teardown设置。在[Setup]或[Teardown]设置后没有关键字意味着没有设置或拆解。也可以使用值NONE来表示测试没有设置/拆解。</span><br><span class="line"></span><br><span class="line">```robotframework</span><br><span class="line">*** Settings ***</span><br><span class="line">Test Setup       Open Application    App A</span><br><span class="line">Test Teardown    Close Application</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Default values</span><br><span class="line">    [Documentation]    设置和拆解来自设置部分</span><br><span class="line">    Do Something</span><br><span class="line"></span><br><span class="line">Overridden setup</span><br><span class="line">    [Documentation]    自己的设置，拆解来自设置部分</span><br><span class="line">    [Setup]    Open Application    App B</span><br><span class="line">    Do Something</span><br><span class="line"></span><br><span class="line">No teardown</span><br><span class="line">    [Documentation]    默认设置，完全没有拆解</span><br><span class="line">    Do Something</span><br><span class="line">    [Teardown]</span><br><span class="line"></span><br><span class="line">No teardown 2</span><br><span class="line">    [Documentation]    设置和拆解也可以通过特殊值NONE禁用</span><br><span class="line">    Do Something</span><br><span class="line">    [Teardown]    NONE</span><br><span class="line"></span><br><span class="line">Using variables</span><br><span class="line">    [Documentation]    使用变量指定设置和拆解</span><br><span class="line">    [Setup]    $&#123;SETUP&#125;</span><br><span class="line">    Do Something</span><br><span class="line">    [Teardown]    $&#123;TEARDOWN&#125;</span><br></pre></td></tr></table></figure></div></code></pre></li></ul><p>作为设置或拆解执行的关键字的名称可以是一个变量。这通过从命令行给出关键字名称作为变量，便于在不同环境中有不同的设置或拆解。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>测试套件可以有自己的设置和拆解。套件设置在该测试套件中的任何测试用例或子测试套件之前执行，同样，套件拆解在它们之后执行。</p>    </div>  </div><h4 id="测试模板"><a href="#测试模板" class="headerlink" title="测试模板"></a>测试模板</h4><p>测试模板将普通的关键字驱动测试用例转换为数据驱动的测试。关键字驱动的测试用例的主体是由关键字和它们可能的参数构成的，而带有模板的测试用例只包含模板关键字的参数。与其在每个测试和&#x2F;或文件中的所有测试中多次重复相同的关键字，不如只在每个测试或文件中使用一次。</p><p>模板关键字可以接受正常的位置参数和命名参数，以及嵌入到关键字名称中的参数。与其他设置不同，不能使用变量定义模板。</p><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>以下示例测试用例说明了如何将接受正常位置参数的关键字用作模板。这两个测试在功能上完全相同。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Normal test case</span><br><span class="line">    Example keyword    first argument    second argument</span><br><span class="line"></span><br><span class="line">Templated test case</span><br><span class="line">    [Template]    Example keyword</span><br><span class="line">    first argument    second argument</span><br></pre></td></tr></table></figure></div><p>如示例所示，可以使用 [Template] 设置为单个测试用例指定模板。另一种方法是在设置部分使用 Test Template 设置，在这种情况下，模板将应用于该测试用例文件中的所有测试用例。[Template] 设置会覆盖设置部分设置的可能的模板，而 [Template] 的空值意味着测试没有模板，即使使用了 Test Template。也可以使用值 NONE 来表示测试没有模板。</p><p>如果一个带模板的测试用例在其主体中有多个数据行，那么模板将逐行应用于所有行。这意味着相同的关键字会被执行多次，每行数据执行一次。模板化的测试也是特殊的，因为即使其中一个或多个失败，所有的轮次也会被执行。这种继续失败模式也可以用于普通测试，但在模板化的测试中，该模式是自动开启的。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Test Template    Example keyword</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Templated test case</span><br><span class="line">    first round 1     first round 2</span><br><span class="line">    second round 1    second round 2</span><br><span class="line">    third round 1     third round 2</span><br></pre></td></tr></table></figure></div><p>使用具有默认值或接受可变数量参数的关键字，以及使用命名参数和自由命名参数，与模板的工作方式完全相同。在参数中使用变量也是正常支持的。</p><h5 id="嵌入参数的模板"><a href="#嵌入参数的模板" class="headerlink" title="嵌入参数的模板"></a>嵌入参数的模板</h5><p>模板支持嵌入参数语法的变体。使用模板时，此语法的工作方式是，如果模板关键字的名称中有变量，它们被视为参数的占位符，并用模板使用的实际参数替换。然后使用结果关键字，而不使用位置参数。这最好通过一个例子来说明：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">带嵌入参数的普通测试用例</span><br><span class="line">    1 + 1 的结果应该是 2</span><br><span class="line">    1 + 2 的结果应该是 3</span><br><span class="line"></span><br><span class="line">带嵌入参数的模板</span><br><span class="line">    [Template]    $&#123;calculation&#125; 的结果应该是 $&#123;expected&#125;</span><br><span class="line">    1 + 1    2</span><br><span class="line">    1 + 2    3</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">$&#123;calculation&#125; 的结果应该是 $&#123;expected&#125;</span><br><span class="line">    $&#123;result&#125; =    计算    $&#123;calculation&#125;</span><br><span class="line">    应该相等    $&#123;result&#125;     $&#123;expected&#125;</span><br></pre></td></tr></table></figure></div><p>当使用模板的嵌入参数时，模板关键字名称中的参数数量必须与其使用的参数数量匹配。尽管参数名称不需要匹配原始关键字的参数，也可以完全使用不同的参数：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">不同的参数名称</span><br><span class="line">    [Template]    $&#123;foo&#125; 的结果应该是 $&#123;bar&#125;</span><br><span class="line">    1 + 1    2</span><br><span class="line">    1 + 2    3</span><br><span class="line"></span><br><span class="line">只有一些参数</span><br><span class="line">    [Template]    $&#123;calculation&#125; 的结果应该是 3</span><br><span class="line">    1 + 2</span><br><span class="line">    4 - 1</span><br><span class="line"></span><br><span class="line">新的参数</span><br><span class="line">    [Template]    $&#123;life&#125; 的 $&#123;meaning&#125; 应该是 42</span><br><span class="line">    result    21 * 2</span><br></pre></td></tr></table></figure></div><p>使用模板的嵌入参数的主要好处是参数名称被明确指定。当使用普通参数时，可以通过命名包含参数的列来达到相同的效果。这在下一节的数据驱动样式示例中有所说明。</p><h5 id="使用FOR循环的模板"><a href="#使用FOR循环的模板" class="headerlink" title="使用FOR循环的模板"></a>使用FOR循环的模板</h5><p>如果模板与FOR循环一起使用，模板将应用于循环内的所有步骤。在这种情况下，也会使用继续失败模式，这意味着即使有失败，所有的步骤也会与所有的循环元素一起执行。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">带FOR循环的模板</span><br><span class="line">    [Template]    Example keyword</span><br><span class="line">    FOR    $&#123;item&#125;    IN    @&#123;ITEMS&#125;</span><br><span class="line">        $&#123;item&#125;    2nd arg</span><br><span class="line">    END</span><br><span class="line">    FOR    $&#123;index&#125;    IN RANGE    42</span><br><span class="line">        1st arg    $&#123;index&#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div><h5 id="使用IF-ELSE结构的模板"><a href="#使用IF-ELSE结构的模板" class="headerlink" title="使用IF&#x2F;ELSE结构的模板"></a>使用IF&#x2F;ELSE结构的模板</h5><p>IF&#x2F;ELSE结构也可以与模板一起使用。例如，当与FOR循环一起使用时，这可以用于过滤执行的参数，这可能很有用。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">带FOR和IF的模板</span><br><span class="line">    [Template]    Example keyword</span><br><span class="line">    FOR    $&#123;item&#125;    IN    @&#123;ITEMS&#125;</span><br><span class="line">        IF  $&#123;item&#125; &lt; 5</span><br><span class="line">            $&#123;item&#125;    2nd arg</span><br><span class="line">        END</span><br><span class="line">    END</span><br></pre></td></tr></table></figure></div><h4 id="不同的测试用例风格"><a href="#不同的测试用例风格" class="headerlink" title="不同的测试用例风格"></a>不同的测试用例风格</h4><p>测试用例可以以多种不同的方式编写。描述某种工作流的测试用例可以以关键字驱动或行为驱动的风格编写。数据驱动的风格可以用于测试具有不同输入数据的相同工作流。</p><h5 id="关键字驱动风格"><a href="#关键字驱动风格" class="headerlink" title="关键字驱动风格"></a>关键字驱动风格</h5><p>工作流测试，如前面描述的有效登录测试，是由几个关键字及其可能的参数构建的。它们的正常结构是首先将系统置于初始状态（在有效登录示例中打开登录页面），然后对系统进行一些操作（输入名称，输入密码，提交凭据），最后验证系统的行为是否符合预期（应打开欢迎页面）。</p><h5 id="数据驱动风格"><a href="#数据驱动风格" class="headerlink" title="数据驱动风格"></a>数据驱动风格</h5><p>编写测试用例的另一种风格是数据驱动的方法，其中测试用例只使用一个高级关键字（通常作为用户关键字创建），该关键字隐藏了实际的测试工作流。当需要使用不同的输入和&#x2F;或输出数据测试相同的场景时，这些测试非常有用。可以在每个测试中重复相同的关键字，但是测试模板功能允许只指定一次要使用的关键字。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Test Template    Login with invalid credentials should fail</span><br><span class="line"></span><br><span class="line">*** Test Cases ***                USERNAME         PASSWORD</span><br><span class="line">Invalid User Name                 invalid          $&#123;VALID PASSWORD&#125;</span><br><span class="line">Invalid Password                  $&#123;VALID USER&#125;    invalid</span><br><span class="line">Invalid User Name and Password    invalid          invalid</span><br><span class="line">Empty User Name                   $&#123;EMPTY&#125;         $&#123;VALID PASSWORD&#125;</span><br><span class="line">Empty Password                    $&#123;VALID USER&#125;    $&#123;EMPTY&#125;</span><br><span class="line">Empty User Name and Password      $&#123;EMPTY&#125;         $&#123;EMPTY&#125;</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>像上面的例子那样命名列可以使测试更易于理解。这是可能的，因为在标题行中，除第一个单元格外的其他单元格都被忽略。</p>    </div>  </div><p>上面的示例有六个独立的测试，每个无效的用户&#x2F;密码组合一个，下面的示例说明了如何只有一个测试包含所有的组合。使用测试模板时，即使有失败，测试中的所有轮次也会被执行，所以这两种风格之间没有真正的功能差异。在上面的示例中，单独的组合被命名，所以更容易看出它们测试了什么，但是可能有大量的这些测试可能会混乱统计数据。使用哪种风格取决于上下文和个人偏好。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Invalid Password</span><br><span class="line">    [Template]    Login with invalid credentials should fail</span><br><span class="line">    invalid          $&#123;VALID PASSWORD&#125;</span><br><span class="line">    $&#123;VALID USER&#125;    invalid</span><br><span class="line">    invalid          whatever</span><br><span class="line">    $&#123;EMPTY&#125;         $&#123;VALID PASSWORD&#125;</span><br><span class="line">    $&#123;VALID USER&#125;    $&#123;EMPTY&#125;</span><br><span class="line">    $&#123;EMPTY&#125;         $&#123;EMPTY&#125;</span><br></pre></td></tr></table></figure></div><h5 id="行为驱动风格"><a href="#行为驱动风格" class="headerlink" title="行为驱动风格"></a>行为驱动风格</h5><p>也可以将测试用例编写为非技术项目利益相关者也必须理解的需求。这些可执行的需求是通常被称为接受测试驱动开发（ATDD）或示例规范化的过程的基石。</p><p>编写这些需求&#x2F;测试的一种方式是由行为驱动开发（BDD）普及的Given-When-Then风格。在这种风格的测试用例中，初始状态通常用以Given开头的关键字表示，动作用以When开头的关键字描述，预期用以Then开头的关键字表示。如果一个步骤有多个动作，可以使用以And或But开头的关键字。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Valid Login</span><br><span class="line">    Given 登录页面已打开</span><br><span class="line">    When 插入有效的用户名和密码</span><br><span class="line">    and 提交凭据</span><br><span class="line">    Then 应该打开欢迎页面</span><br></pre></td></tr></table></figure></div><h6 id="忽略Given-When-Then-And-But前缀"><a href="#忽略Given-When-Then-And-But前缀" class="headerlink" title="忽略Given&#x2F;When&#x2F;Then&#x2F;And&#x2F;But前缀"></a>忽略Given&#x2F;When&#x2F;Then&#x2F;And&#x2F;But前缀</h6><p>当搜索匹配的关键字时，如果没有找到全名匹配，将丢弃前缀Given、When、Then、And和But。这对于用户关键字和库关键字都有效。例如，在上面的示例中，Given登录页面已打开可以实现为用户关键字，无论是否带有单词Given。忽略前缀还允许使用不同的前缀使用相同的关键字。例如，欢迎页面应该打开也可以用作And欢迎页面应该打开。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>这些前缀可以本地化。请参阅翻译附录以获取支持的翻译。</p>    </div>  </div><h6 id="嵌入数据到关键字"><a href="#嵌入数据到关键字" class="headerlink" title="嵌入数据到关键字"></a>嵌入数据到关键字</h6><p>在编写具体示例时，能够将实际数据传递给关键字实现是很有用的。用户关键字通过允许将参数嵌入到关键字名称中来支持这一点。</p><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>除了测试自动化，Robot Framework还可以用于其他自动化目的，包括机器人流程自动化（RPA）。这一直是可能的，但Robot Framework 3.1添加了对自动化任务的官方支持，而不仅仅是测试。在大多数情况下，创建任务的工作方式与创建测试相同，唯一的实质区别在于术语。任务也可以像测试用例一样组织成套件。</p><h4 id="任务语法"><a href="#任务语法" class="headerlink" title="任务语法"></a>任务语法</h4><p>任务是基于可用关键字创建的，就像测试用例一样，任务语法通常与测试用例语法相同。主要区别在于，任务是在任务部分创建的，而不是在测试用例部分：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Tasks ***</span><br><span class="line">Process invoice</span><br><span class="line">    Read information from PDF</span><br><span class="line">    Validate information</span><br><span class="line">    Submit information to backend system</span><br><span class="line">    Validate information is visible in web UI</span><br></pre></td></tr></table></figure></div><p>在同一文件中同时有测试和任务是错误的。</p><h4 id="与任务相关的设置"><a href="#与任务相关的设置" class="headerlink" title="与任务相关的设置"></a>与任务相关的设置</h4><p>可以在任务部分使用的设置与测试用例部分中可以使用的设置完全相同。在设置部分，可以使用任务设置、任务拆解、任务模板和任务超时，而不是它们的测试变体。</p><h3 id="创建测试套件"><a href="#创建测试套件" class="headerlink" title="创建测试套件"></a>创建测试套件</h3><p>Robot Framework的测试用例是在测试用例文件中创建的，这些文件可以组织成目录。这些文件和目录创建了一个分层的测试套件结构。创建任务时也适用相同的概念，但术语有所不同。</p><h4 id="套件文件"><a href="#套件文件" class="headerlink" title="套件文件"></a>套件文件</h4><p>Robot Framework的测试用例是在套件文件（也称为测试用例文件）中的测试用例部分创建的。这样的文件会自动从它包含的所有测试用例创建一个测试套件。测试用例的数量没有上限，但建议少于十个，除非使用数据驱动的方法，其中一个测试用例只包含一个高级关键字。</p><p>在设置部分，可以使用以下设置来自定义套件：</p><ul><li>Name<ul><li>用于设置自定义套件名称。默认名称是根据文件或目录名称创建的。</li></ul></li><li>Documentation<ul><li>用于指定套件文档。</li></ul></li><li>Metadata<ul><li>用于设置自由套件元数据作为名称-值对。</li></ul></li><li>Suite Setup, Suite Teardown<ul><li>指定套件设置和拆解。</li></ul></li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>设置名称是不区分大小写的，但推荐使用上述格式。</p>    </div>  </div><h4 id="套件目录"><a href="#套件目录" class="headerlink" title="套件目录"></a>套件目录</h4><p>测试用例文件可以组织成目录，这些目录创建了更高级别的测试套件。从目录创建的测试套件不能直接包含任何测试用例，而是包含其他包含测试用例的测试套件。然后，这些目录可以放置到其他目录中，创建更高级别的套件。结构没有限制，所以可以根据需要组织测试用例。</p><p>当执行一个测试目录时，它包含的文件和目录会被递归处理，如下所示：</p><ul><li>以点（.）或下划线（_）开头的文件和目录名会被忽略。</li><li>名称为CVS的目录会被忽略（区分大小写）。</li><li>支持的文件格式的文件会被处理。</li><li>其他文件会被忽略。</li><li>如果处理的文件或目录不包含任何测试用例，它会被静默忽略（向系统日志写入一条消息），并继续处理。</li></ul><h4 id="套件初始化文件"><a href="#套件初始化文件" class="headerlink" title="套件初始化文件"></a>套件初始化文件</h4><p>从目录创建的测试套件可以有与从测试用例文件创建的套件相似的设置。因为目录本身不能包含这种信息，所以必须将其放入一个特殊的测试套件初始化文件中。初始化文件的名称必须始终采用<code>__init__.ext</code>的格式，其中扩展名必须是支持的文件格式之一（通常是<code>__init__.robot</code>）。这种命名格式借鉴自Python，其中以这种方式命名的文件表示目录是一个模块。</p><p>从Robot Framework 6.1开始，也可以为通过给出多个路径启动测试执行时自动创建的套件定义套件初始化文件。</p><p>初始化文件的结构和语法与测试用例文件相同，只是它们不能有测试用例部分，而且不是所有的设置都被支持。在初始化文件中创建或导入的变量和关键字在较低级别的测试套件中不可用。如果需要共享变量或关键字，可以将它们放入资源文件中，这些文件可以由初始化和测试用例文件导入。</p><p>初始化文件的主要用途是指定与套件文件类似的测试套件相关设置，但也可以设置一些与测试用例相关的设置。如何在初始化文件中使用不同的设置在下面解释。</p><ul><li>Name, Documentation, Metadata, Suite Setup, Suite Teardown<ul><li>这些套件特定的设置在套件初始化文件中的工作方式与套件文件中的工作方式相同。</li></ul></li><li>Test Tags<ul><li>指定的标签无条件地设置为此目录包含的所有套件文件中的所有测试，递归地。新的在Robot Framework 6.1。需要使用旧版本的Force Tags。</li></ul></li><li>Test Setup, Test Teardown, Test Timeout<ul><li>将测试设置&#x2F;拆解或测试超时的默认值设置为此目录包含的所有测试用例。可以在较低级别覆盖。注意，用作设置和拆解的关键字必须在使用它们的测试的测试用例文件中可用。在初始化文件本身中定义关键字是不够的。</li></ul></li><li>Task Setup, Task Teardown, Task Tags, Task Timeout<ul><li>分别是Test Setup, Test Teardown, Test Tags和Test Timeout的别名，可以在创建任务，而不是测试时使用。</li></ul></li><li>Default Tags, Test Template<ul><li>在初始化文件中不支持。</li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation    示例套件</span><br><span class="line">Suite Setup      Do Something    $&#123;MESSAGE&#125;</span><br><span class="line">Test Tags        example</span><br><span class="line">Library          SomeLibrary</span><br><span class="line"></span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;MESSAGE&#125;       Hello, world!</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Do Something</span><br><span class="line">    [Arguments]    $&#123;args&#125;</span><br><span class="line">    Some Keyword    $&#123;arg&#125;</span><br><span class="line">    Another Keyword</span><br></pre></td></tr></table></figure></div><h4 id="套件名称"><a href="#套件名称" class="headerlink" title="套件名称"></a>套件名称</h4><p>测试套件的名称默认由文件或目录名称构造。创建名称时，将忽略扩展名，可能的下划线被替换为空格，全小写的名称被转换为标题大小写。例如，<code>some_tests.robot</code>变成<code>Some Tests</code>，<code>My_test_directory</code>变成<code>My test directory</code>。</p><p>文件或目录名称可以包含一个前缀来控制套件的执行顺序。前缀与基本名称之间用两个下划线分隔，当构造实际的测试套件名称时，前缀和下划线都被删除。例如，文件<code>01__some_tests.robot</code>和<code>02__more_tests.robot</code>分别创建测试套件<code>Some Tests</code>和<code>More Tests</code>，前者在后者之前执行。</p><p>从Robot Framework 6.1开始，也可以通过在设置部分使用<code>Name</code>设置为套件指定一个自定义名称：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Name            Custom suite name</span><br></pre></td></tr></table></figure></div><p>可以使用<code>--name</code>选项从命令行覆盖顶级套件的名称。</p><h4 id="套件文档"><a href="#套件文档" class="headerlink" title="套件文档"></a>套件文档</h4><p>使用设置部分中的<code>Documentation</code>设置设置测试套件的文档。它可以在套件文件和套件初始化文件中使用。套件文档与测试用例文档在显示位置和创建方式上具有完全相同的特性。有关语法的详细信息，请参阅文档格式化附录。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Documentation    An example suite documentation with *some* _formatting_.</span><br><span class="line">...              Long documentation can be split into multiple lines.</span><br></pre></td></tr></table></figure></div><p>可以使用<code>--doc</code>选项从命令行覆盖顶级套件的文档。</p><h4 id="自由套件元数据"><a href="#自由套件元数据" class="headerlink" title="自由套件元数据"></a>自由套件元数据</h4><p>除了文档外，套件还可以有自由元数据。这些元数据以名称-值对的形式在设置部分使用<code>Metadata</code>设置定义。它在报告和日志中的显示方式与文档类似。</p><p>元数据的名称是给<code>Metadata</code>设置的第一个参数，剩余的参数指定其值。值的处理方式与文档相同，这意味着它支持HTML格式和变量，而且较长的值可以分成多行。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Metadata        Version            2.0</span><br><span class="line">Metadata        Robot Framework    http://robotframework.org</span><br><span class="line">Metadata        Platform           $&#123;PLATFORM&#125;</span><br><span class="line">Metadata        Longer Value</span><br><span class="line">...             Longer metadata values can be split into multiple</span><br><span class="line">...             rows. Also *simple* _formatting_ is supported.</span><br></pre></td></tr></table></figure></div><p>可以使用<code>--metadata</code>选项从命令行设置顶级套件的自由元数据。</p><h4 id="套件设置和拆解"><a href="#套件设置和拆解" class="headerlink" title="套件设置和拆解"></a>套件设置和拆解</h4><p>不仅测试用例，而且测试套件也可以有一个设置和一个拆解。套件设置在运行任何套件的测试用例或子测试套件之前执行，套件拆解在它们之后执行。所有的测试套件都可以有一个设置和一个拆解；对于从目录创建的套件，它们必须在套件初始化文件中指定。</p><p>与测试用例类似，套件设置和拆解是可能带有参数的关键字。它们在设置部分中使用<code>Suite Setup</code>和<code>Suite Teardown</code>设置定义，分别。关键字名称和可能的参数位于设置名称后的列中。</p><p>如果套件设置失败，那么它和其子测试套件中的所有测试用例都会立即被分配一个失败状态，并且它们实际上不会被执行。这使得套件设置成为在可能运行测试用例之前必须满足的预条件的理想选择。</p><p>套件拆解通常用于在所有测试用例执行完毕后进行清理。即使同一套件的设置失败，它也会被执行。如果套件拆解失败，那么套件中的所有测试用例都会被标记为失败，无论它们的原始执行状态如何。注意，即使其中一个失败，套件拆解中的所有关键字也会被执行。</p><p>作为设置或拆解执行的关键字的名称可以是一个变量。这通过从命令行给出关键字名称作为变量，便于在不同环境中有不同的设置或拆解。</p><h3 id="使用测试库"><a href="#使用测试库" class="headerlink" title="使用测试库"></a>使用测试库</h3><p>测试库包含那些最低级别的关键字，通常被称为库关键字，它们实际上与被测试的系统进行交互。所有的测试用例总是使用来自某个库的关键字，通常通过高级用户关键字。本节解释如何使用测试库以及如何使用它们提供的关键字。创建测试库在另一节中描述。</p><h4 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h4><p>测试库通常使用<code>Library</code>设置导入，但也可以使用<code>Import Library</code>关键字。</p><h5 id="使用Library设置"><a href="#使用Library设置" class="headerlink" title="使用Library设置"></a>使用<code>Library</code>设置</h5><p>测试库通常使用设置部分中的<code>Library</code>设置导入，并在后续列中有库名称。与大多数其他数据不同，库名称既区分大小写又区分空格。如果库在一个包中，必须使用包括包名在内的全名。</p><p>在那些库需要参数的情况下，它们列在库名称后的列中。在测试库导入中可以像关键字的参数一样使用默认值、可变数量的参数和命名参数。库名称和参数都可以使用变量设置。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    OperatingSystem</span><br><span class="line">Library    my.package.TestLibrary</span><br><span class="line">Library    MyLibrary    arg1    arg2</span><br><span class="line">Library    $&#123;LIBRARY&#125;</span><br></pre></td></tr></table></figure></div><p>可以在套件文件、资源文件和套件初始化文件中导入测试库。在所有这些情况下，导入的库中的所有关键字都在该文件中可用。对于资源文件，这些关键字也在使用它们的其他文件中可用。</p><h5 id="使用Import-Library关键字"><a href="#使用Import-Library关键字" class="headerlink" title="使用Import Library关键字"></a>使用<code>Import Library</code>关键字</h5><p>另一种使用测试库的可能性是使用<code>BuiltIn</code>库中的关键字<code>Import Library</code>。这个关键字接受库名称和可能的参数，就像<code>Library</code>设置一样。导入的库中的关键字在使用<code>Import Library</code>关键字的测试套件中可用。这种方法在库在测试执行开始时不可用，只有其他一些关键字使其可用的情况下很有用。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Do Something</span><br><span class="line">    Import Library    MyLibrary    arg1    arg2</span><br><span class="line">    KW From MyLibrary</span><br></pre></td></tr></table></figure></div><h4 id="指定要导入的库"><a href="#指定要导入的库" class="headerlink" title="指定要导入的库"></a>指定要导入的库</h4><p>要导入的库可以通过使用库名称或库路径来指定。无论是使用<code>Library</code>设置还是<code>Import Library</code>关键字导入库，这些方法的工作方式都是相同的。</p><h5 id="使用库名称"><a href="#使用库名称" class="headerlink" title="使用库名称"></a>使用库名称</h5><p>指定要导入的测试库的最常见方法是使用其名称，就像本节中的所有示例所做的那样。在这些情况下，Robot Framework试图从模块搜索路径中找到实现库的类或模块。以某种方式安装的库应该自动在模块搜索路径中，但对于其他库，可能需要单独配置搜索路径。</p><p>这种方法的最大好处是，当配置了模块搜索路径（通常使用自定义的启动脚本）后，普通用户不需要考虑库实际上安装在哪里。缺点是，将你自己的（可能非常简单的）库放入搜索路径可能需要一些额外的配置。</p><h5 id="使用库的物理路径"><a href="#使用库的物理路径" class="headerlink" title="使用库的物理路径"></a>使用库的物理路径</h5><p>指定要导入的库的另一种机制是使用文件系统中的路径。这个路径被认为是相对于当前测试数据文件所在的目录的，就像资源和变量文件的路径一样。这种方法的主要好处是不需要配置模块搜索路径。</p><p>如果库是一个文件，那么它的路径必须包含扩展名，即.py。如果库是作为目录实现的，那么如果路径是相对的，它的路径必须有一个尾随的正斜杠（&#x2F;）。对于绝对路径，尾随的斜杠是可选的。以下示例演示了这些不同的用法。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    PythonLibrary.py</span><br><span class="line">Library    relative/path/PythonDirLib/    possible    arguments</span><br><span class="line">Library    $&#123;RESOURCES&#125;/Example.class</span><br></pre></td></tr></table></figure></div><p>这种方法的一个限制是，作为Python类实现的库必须在与类同名的模块中。</p><h4 id="设置库的自定义名称"><a href="#设置库的自定义名称" class="headerlink" title="设置库的自定义名称"></a>设置库的自定义名称</h4><p>库名称在关键字名称之前显示在测试日志中，如果多个关键字有相同的名称，它们必须使用关键字名称前缀为库名称。库名称通常从实现它的模块或类名称中获取，但在某些情况下，更改它是可取的：</p><ul><li>需要多次导入相同的库，但参数不同。否则这是不可能的。</li><li>库名称过长不便。</li><li>您希望使用变量在不同的环境中导入不同的库，但用相同的名称引用它们。</li><li>库名称误导或其他贫穷。在这种情况下，更改实际名称当然是更好的解决方案。</li></ul><p>指定新名称的基本语法是在库名称后面有文本<code>AS</code>（区分大小写），然后在其后面有新名称。指定的名称显示在日志中，并且在使用关键字的全名（<code>LibraryName.Keyword Name</code>）时必须在测试数据中使用。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    packagename.TestLib    AS    TestLib</span><br><span class="line">Library    $&#123;LIBRARY&#125;    AS    MyName</span><br></pre></td></tr></table></figure></div><p>库的可能参数放在原始库名称和<code>AS</code>标记之间。以下示例说明了如何使用不同的参数多次导入相同的库：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    SomeLibrary    localhost        1234    AS    LocalLib</span><br><span class="line">Library    SomeLibrary    server.domain    8080    AS    RemoteLib</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    LocalLib.Some Keyword     some arg       second arg</span><br><span class="line">    RemoteLib.Some Keyword    another arg    whatever</span><br><span class="line">    LocalLib.Another Keyword</span><br></pre></td></tr></table></figure></div><p>在设置部分导入库和使用<code>Import Library</code>关键字时，都可以为测试库设置自定义名称。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在Robot Framework 6.0之前，给库指定自定义名称时使用的标记是<code>WITH NAME</code>，而不是<code>AS</code>。旧的语法继续工作，但它被认为是已弃用的，最终将被删除。</p>    </div>  </div><h4 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h4><p>有些测试库是与Robot Framework一起分发的，这些库被称为标准库。<code>BuiltIn</code>库是特殊的，因为它是自动使用的，因此它的关键字总是可用的。其他标准库需要像任何其他库一样导入，但是不需要安装它们。</p><h5 id="普通标准库"><a href="#普通标准库" class="headerlink" title="普通标准库"></a>普通标准库</h5><p>下面列出了可用的普通标准库，并附有链接到它们的文档：</p><ul><li>BuiltIn</li><li>Collections</li><li>DateTime</li><li>Dialogs</li><li>OperatingSystem</li><li>Process</li><li>Screenshot</li><li>String</li><li>Telnet</li><li>XML</li></ul><h5 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h5><p>除了上面列出的普通标准库，还有一个远程库，它与其他标准库完全不同。它本身没有任何关键字，但它作为Robot Framework和实际测试库实现之间的代理。这些库可以在核心框架之外的其他机器上运行，甚至可以使用Robot Framework原生不支持的语言实现。</p><p>有关此概念的更多信息，请参阅单独的远程库接口部分。</p><h4 id="外部库"><a href="#外部库" class="headerlink" title="外部库"></a>外部库</h4><p>任何不是标准库的测试库，按定义，都是外部库。Robot Framework的开源社区已经实现了几个通用库，如<code>SeleniumLibrary</code>和<code>SwingLibrary</code>，这些库没有与核心框架一起打包。可以从<a class="link"   href="http://robotframework.org找到公开可用的库列表./" >http://robotframework.org找到公开可用的库列表。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>显然，使用Robot Framework的团队也可以实现通用和自定义库。有关该主题的更多信息，请参阅创建测试库部分。</p><p>不同的外部库可能有完全不同的安装和使用机制。有时，它们可能还需要单独安装一些其他依赖项。所有的库都应该有清晰的安装和使用文档，最好能自动化安装过程。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>变量是Robot Framework的一个重要特性，它们可以在测试数据的大多数地方使用。最常见的是在测试用例和关键字部分的关键字参数中使用，但所有设置也允许在其值中使用变量。普通的关键字名称不能用变量指定，但可以使用<code>BuiltIn</code>关键字<code>Run Keyword</code>来达到同样的效果。</p><p>Robot Framework有自己的变量，可以分别使用语法<code>$&#123;SCALAR&#125;</code>、<code>@&#123;LIST&#125;</code>和<code>&amp;&#123;DICT&#125;</code>作为标量、列表或字典使用。除此之外，还可以直接使用语法<code>%&#123;ENV_VAR&#125;</code>使用环境变量。</p><p>变量在以下情况下很有用：</p><ul><li>当测试数据中的字符串经常变化时。使用变量，你只需要在一个地方做这些更改。</li><li>当创建系统独立和操作系统独立的测试数据时。使用变量而不是硬编码的字符串可以大大简化这个过程（例如，使用<code>$&#123;RESOURCES&#125;</code>代替<code>c:\resources</code>，或者使用<code>$&#123;HOST&#125;</code>代替<code>10.0.0.1:8080</code>）。因为变量可以在启动测试时从命令行设置，所以更改系统特定的变量很容易（例如，<code>--variable HOST:10.0.0.2:1234 --variable RESOURCES:/opt/resources</code>）。这也有助于本地化测试，这通常涉及使用不同的字符串运行相同的测试。</li><li>当需要将除字符串以外的对象作为关键字的参数时。没有变量，这是不可能的。</li><li>当不同的关键字，甚至在不同的测试库中，需要通信时。你可以将一个关键字的返回值分配给一个变量，并将它作为另一个的参数传递。</li><li>当测试数据中的值很长或者复杂时。例如，<code>$&#123;URL&#125;</code>比<code>http://long.domain.name:8080/path/to/service?foo=1&amp;bar=2&amp;zap=42</code>短。</li><li>如果在测试数据中使用了不存在的变量，使用它的关键字会失败。如果需要将用于变量的相同语法作为字面字符串，必须使用反斜杠转义，如<code>\$&#123;NAME&#125;</code>。</li></ul><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>本节解释如何使用变量，包括常规标量变量语法<code>$&#123;var&#125;</code>，如何在列表和字典上下文中使用变量，如<code>@&#123;var&#125;</code>和<code>&amp;&#123;var&#125;</code>，以及如何使用环境变量，如<code>%&#123;var&#125;</code>。后续部分将讨论创建变量的不同方式。</p><p>Robot Framework的变量，类似于关键字，是不区分大小写的，而且也忽略空格和下划线。然而，建议使用大写字母表示全局变量（例如，<code>$&#123;PATH&#125;</code>或<code>$&#123;TWO WORDS&#125;</code>），使用小写字母表示只在某些测试用例或用户关键字中可用的局部变量（例如，<code>$&#123;my var&#125;</code>）。更重要的是，应该一致地使用大小写。</p><p>变量名由变量类型标识符（$，@，&amp;，%），花括号（{，}）和花括号之间的实际变量名组成。与使用类似变量语法的某些编程语言不同，花括号总是必需的。变量名基本上可以在花括号之间有任何字符。然而，建议只使用从a到z的字母、数字、下划线和空格，这甚至是使用扩展变量语法的要求。</p><h4 id="标量变量语法"><a href="#标量变量语法" class="headerlink" title="标量变量语法"></a>标量变量语法</h4><p>在Robot Framework测试数据中使用变量的最常见方式是使用标量变量语法，如<code>$&#123;var&#125;</code>。当使用这种语法时，变量名被其值替换。大多数时候，变量值是字符串，但变量可以包含任何对象，包括数字、列表、字典，甚至自定义对象。</p><p>下面的例子说明了标量变量的使用。假设变量<code>$&#123;GREET&#125;</code>和<code>$&#123;NAME&#125;</code>可用，并分别赋值为字符串Hello和world，那么下面的示例测试用例是等价的。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Constants</span><br><span class="line">    Log    Hello</span><br><span class="line">    Log    Hello, world!!</span><br><span class="line"></span><br><span class="line">Variables</span><br><span class="line">    Log    $&#123;GREET&#125;</span><br><span class="line">    Log    $&#123;GREET&#125;, $&#123;NAME&#125;!!</span><br></pre></td></tr></table></figure></div><p>当一个标量变量单独使用，没有其他文本或变量围绕它，就像上面的<code>$&#123;GREET&#125;</code>，变量被其值替换，值可以是任何对象。如果变量不是单独使用，就像上面的<code>$&#123;GREER&#125;, $&#123;NAME&#125;!!</code>，它的值首先被转换为字符串，然后与其他数据连接。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>当使用命名参数语法向关键字传递参数时，也会按原样使用变量值，如<code>argname=${var}</code>。</p>    </div>  </div><p>下面的例子演示了变量单独使用和与其他内容一起使用的区别。首先，假设我们有一个变量<code>$&#123;STR&#125;</code>设置为字符串Hello, world!和<code>$&#123;OBJ&#125;</code>设置为以下Python对象的实例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObj</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hi, terra!&quot;</span></span><br></pre></td></tr></table></figure></div><p>设置了这两个变量后，我们有以下测试数据：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Objects</span><br><span class="line">    KW 1    $&#123;STR&#125;</span><br><span class="line">    KW 2    $&#123;OBJ&#125;</span><br><span class="line">    KW 3    I said &quot;$&#123;STR&#125;&quot;</span><br><span class="line">    KW 4    You said &quot;$&#123;OBJ&#125;&quot;</span><br></pre></td></tr></table></figure></div><p>最后，当执行这个测试数据时，不同的关键字接收到的参数如下所示：</p><ul><li>KW 1得到一个字符串Hello, world!</li><li>KW 2得到存储在变量<code>$&#123;OBJ&#125;</code>中的对象</li><li>KW 3得到一个字符串I said “Hello, world!”</li><li>KW 4得到一个字符串You said “Hi, terra!”</li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>如果变量不能表示为Unicode，那么将变量转换为Unicode显然会失败。例如，如果你试图使用字节序列作为关键字的参数，那么你将值连接在一起，如<code>${byte1}${byte2}</code>。一个解决方法是创建一个包含整个值的变量，并在单元格中单独使用它（例如，<code>${bytes}</code>），因为这样值就会按原样使用。</p>    </div>  </div><h4 id="列表变量语法"><a href="#列表变量语法" class="headerlink" title="列表变量语法"></a>列表变量语法</h4><p>当一个变量像<code>$&#123;EXAMPLE&#125;</code>那样作为标量使用时，它的值会被原样使用。如果一个变量的值是一个列表或类似列表，那么也可以像<code>@&#123;EXAMPLE&#125;</code>那样将它作为一个列表变量使用。在这种情况下，列表会被展开，单个项会作为单独的参数传入。这最容易通过一个例子来解释。假设一个变量<code>@&#123;USER&#125;</code>的值是<code>[&#39;robot&#39;, &#39;secret&#39;]</code>，那么下面的两个测试用例是等价的：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Constants</span><br><span class="line">    Login    robot    secret</span><br><span class="line"></span><br><span class="line">List Variable</span><br><span class="line">    Login    @&#123;USER&#125;</span><br></pre></td></tr></table></figure></div><p>Robot Framework将其自己的变量存储在一个内部存储中，并允许将它们作为标量、列表或字典使用。将一个变量作为列表使用需要它的值是一个Python列表或类似列表的对象。Robot Framework不允许将字符串用作列表，但接受其他可迭代的对象，如元组或字典。</p><p>从Robot Framework 4.0开始，可以将列表扩展与列表项访问结合使用，使得以下用法成为可能：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Nested container</span><br><span class="line">    $&#123;nested&#125; =    Evaluate    [[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#123;&#x27;key&#x27;: [&#x27;x&#x27;, &#x27;y&#x27;]&#125;]</span><br><span class="line">    Log Many    @&#123;nested&#125;[0]         # Logs &#x27;a&#x27;, &#x27;b&#x27; and &#x27;c&#x27;.</span><br><span class="line">    Log Many    @&#123;nested&#125;[1][key]    # Logs &#x27;x&#x27; and &#x27;y&#x27;.</span><br><span class="line"></span><br><span class="line">Slice</span><br><span class="line">    $&#123;items&#125; =    Create List    first    second    third</span><br><span class="line">    Log Many    @&#123;items&#125;[1:]         # Logs &#x27;second&#x27; and  &#x27;third&#x27;.</span><br></pre></td></tr></table></figure></div><h5 id="使用列表变量与其他数据"><a href="#使用列表变量与其他数据" class="headerlink" title="使用列表变量与其他数据"></a>使用列表变量与其他数据</h5><p>可以将列表变量与其他参数一起使用，包括其他列表变量。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Keyword    @&#123;LIST&#125;    more    args</span><br><span class="line">    Keyword    $&#123;SCALAR&#125;    @&#123;LIST&#125;    constant</span><br><span class="line">    Keyword    @&#123;LIST&#125;    @&#123;ANOTHER&#125;    @&#123;ONE MORE&#125;</span><br></pre></td></tr></table></figure></div><h5 id="使用列表变量与设置"><a href="#使用列表变量与设置" class="headerlink" title="使用列表变量与设置"></a>使用列表变量与设置</h5><p>列表变量只能与一些设置一起使用。它们可以用作导入的库和变量文件的参数，但库和变量文件的名称本身不能是列表变量。也可以在设置和拆解中使用列表变量作为关键字的参数，但不能用作关键字的名称。对于与标签相关的设置，它们可以自由地使用。在不支持列表变量的地方，可以使用标量变量。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library         ExampleLibrary      @&#123;LIB ARGS&#125;    # This works</span><br><span class="line">Library         $&#123;LIBRARY&#125;          @&#123;LIB ARGS&#125;    # This works</span><br><span class="line">Library         @&#123;LIBRARY AND ARGS&#125;                # This does not work</span><br><span class="line">Suite Setup     Some Keyword        @&#123;KW ARGS&#125;     # This works</span><br><span class="line">Suite Setup     $&#123;KEYWORD&#125;          @&#123;KW ARGS&#125;     # This works</span><br><span class="line">Suite Setup     @&#123;KEYWORD AND ARGS&#125;                # This does not work</span><br><span class="line">Default Tags    @&#123;TAGS&#125;                            # This works</span><br></pre></td></tr></table></figure></div><h4 id="字典变量语法"><a href="#字典变量语法" class="headerlink" title="字典变量语法"></a>字典变量语法</h4><p>如上所述，包含列表的变量可以作为列表变量使用，将列表项作为单独的参数传递给关键字。类似地，包含Python字典或类似字典的对象的变量可以像<code>&amp;&#123;EXAMPLE&#125;</code>那样作为字典变量使用。实际上，这意味着字典被展开，单个项作为命名参数传递给关键字。假设一个变量<code>&amp;&#123;USER&#125;</code>的值是<code>&#123;&#39;name&#39;: &#39;robot&#39;, &#39;password&#39;: &#39;secret&#39;&#125;</code>，那么下面的两个测试用例是等价的。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Constants</span><br><span class="line">    Login    name=robot    password=secret</span><br><span class="line"></span><br><span class="line">Dict Variable</span><br><span class="line">    Login    &amp;&#123;USER&#125;</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>从Robot Framework 4.0开始，可以将字典扩展与字典项访问结合使用，使得像<code>&amp;{nested}[key]</code>这样的用法成为可能。</p>    </div>  </div><h5 id="使用字典变量与其他数据"><a href="#使用字典变量与其他数据" class="headerlink" title="使用字典变量与其他数据"></a>使用字典变量与其他数据</h5><p>可以将字典变量与其他参数一起使用，包括其他字典变量。因为命名参数语法要求位置参数在命名参数之前，所以字典只能跟在命名参数或其他字典后面。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Keyword    &amp;&#123;DICT&#125;    named=arg</span><br><span class="line">    Keyword    positional    @&#123;LIST&#125;    &amp;&#123;DICT&#125;</span><br><span class="line">    Keyword    &amp;&#123;DICT&#125;    &amp;&#123;ANOTHER&#125;    &amp;&#123;ONE MORE&#125;</span><br></pre></td></tr></table></figure></div><h5 id="使用字典变量与设置"><a href="#使用字典变量与设置" class="headerlink" title="使用字典变量与设置"></a>使用字典变量与设置</h5><p>字典变量通常不能与设置一起使用。唯一的例外是导入、设置和拆解，其中字典可以作为参数使用。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library        ExampleLibrary    &amp;&#123;LIB ARGS&#125;</span><br><span class="line">Suite Setup    Some Keyword      &amp;&#123;KW ARGS&#125;     named=arg</span><br></pre></td></tr></table></figure></div><h5 id="访问列表和字典项"><a href="#访问列表和字典项" class="headerlink" title="访问列表和字典项"></a>访问列表和字典项</h5><p>可以使用特殊语法<code>$&#123;var&#125;[item]</code>或<code>$&#123;var&#125;[nested][item]</code>访问可下标的变量（例如，列表和字典）的项。从Robot Framework 4.0开始，也可以通过使用语法<code>@&#123;var&#125;[item]</code>和<code>&amp;&#123;var&#125;[item]</code>将项访问与列表扩展和字典扩展一起使用。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在Robot Framework 3.1之前，正常的项访问语法是列表的<code>@{var}[item]</code>和字典的<code>&amp;{var}[item]</code>。Robot Framework 3.1引入了通用的<code>${var}[item]</code>语法以及一些其他的好的增强，旧的项访问语法在Robot Framework 3.2中被弃用。</p>    </div>  </div><h5 id="访问序列项"><a href="#访问序列项" class="headerlink" title="访问序列项"></a>访问序列项</h5><p>可以使用语法<code>$&#123;var&#125;[index]</code>访问包含序列（例如，列表、字符串或字节）的变量的某个项，其中<code>index</code>是所选值的索引。索引从零开始，可以使用负索引从末尾访问项，尝试访问索引过大的项会导致错误。索引会自动转换为整数，也可以使用变量作为索引。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Positive index</span><br><span class="line">    Login    $&#123;USER&#125;[0]    $&#123;USER&#125;[1]</span><br><span class="line">    Title Should Be    Welcome $&#123;USER&#125;[0]!</span><br><span class="line"></span><br><span class="line">Negative index</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[-1]</span><br><span class="line"></span><br><span class="line">Index defined as variable</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[$&#123;INDEX&#125;]</span><br></pre></td></tr></table></figure></div><p>序列项访问也支持Python的相同的”切片”功能，语法如<code>$&#123;var&#125;[1:]</code>。使用这种语法，你不会得到一个单独的项，而是得到原始序列的一个切片。与Python一样，你可以指定开始索引、结束索引和步长：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Start index</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[1:]</span><br><span class="line"></span><br><span class="line">End index</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[:4]</span><br><span class="line"></span><br><span class="line">Start and end</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[2:-1]</span><br><span class="line"></span><br><span class="line">Step</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[::2]</span><br><span class="line">    Keyword    $&#123;SEQUENCE&#125;[1:-1:10]</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>切片语法在Robot Framework 3.1中是新的。它在Robot Framework 4.0中被扩展，可以与列表扩展像<code>@{var}[1:]</code>这样一起工作。</p>    </div>  </div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在Robot Framework 3.2之前，只有包含列表、元组或其他被认为是类似列表的对象的变量支持项和切片访问。现在，所有的序列，包括字符串和字节，都被支持。</p>    </div>  </div><h5 id="访问单个字典项"><a href="#访问单个字典项" class="headerlink" title="访问单个字典项"></a>访问单个字典项</h5><p>可以使用语法<code>$&#123;NAME&#125;[key]</code>访问字典变量的某个值，其中<code>key</code>是所选值的名称。键被认为是字符串，但非字符串键可以作为变量使用。以这种方式访问的字典值可以像标量变量一样使用。</p><p>如果一个键是一个字符串，也可以使用属性访问语法<code>$&#123;NAME.key&#125;</code>访问它的值。有关此语法的更多详细信息，请参阅创建字典变量。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Dictionary variable item</span><br><span class="line">    Login    $&#123;USER&#125;[name]    $&#123;USER&#125;[password]</span><br><span class="line">    Title Should Be    Welcome $&#123;USER&#125;[name]!</span><br><span class="line"></span><br><span class="line">Key defined as variable</span><br><span class="line">    Log Many    $&#123;DICT&#125;[$&#123;KEY&#125;]    $&#123;DICT&#125;[$&#123;42&#125;]</span><br><span class="line"></span><br><span class="line">Attribute access</span><br><span class="line">    Login    $&#123;USER.name&#125;    $&#123;USER.password&#125;</span><br><span class="line">    Title Should Be    Welcome $&#123;USER.name&#125;!</span><br></pre></td></tr></table></figure></div><h5 id="嵌套项访问"><a href="#嵌套项访问" class="headerlink" title="嵌套项访问"></a>嵌套项访问</h5><p>也可以使用相同的项访问语法<code>$&#123;var&#125;[item1][item2]</code>访问嵌套的可下标变量。这在处理经常由REST服务返回的JSON数据时特别有用。例如，如果一个变量<code>$&#123;DATA&#125;</code>包含<code>[&#123;&#39;id&#39;: 1, &#39;name&#39;: &#39;Robot&#39;&#125;, &#123;&#39;id&#39;: 2, &#39;name&#39;: &#39;Mr. X&#39;&#125;]</code>，这个测试将通过：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Nested item access</span><br><span class="line">    Should Be Equal    $&#123;DATA&#125;[0][name]    Robot</span><br><span class="line">    Should Be Equal    $&#123;DATA&#125;[1][id]      $&#123;2&#125;</span><br></pre></td></tr></table></figure></div><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>Robot Framework允许在测试数据中使用环境变量，语法为<code>%&#123;ENV_VAR_NAME&#125;</code>。它们限制为字符串值。可以通过将变量名和默认值用等号分隔，如<code>%&#123;ENV_VAR_NAME=default value&#125;</code>，来指定一个默认值，如果环境变量不存在，则使用该默认值。</p><p>在测试执行之前在操作系统中设置的环境变量在执行期间是可用的，可以使用<code>OperatingSystem</code>库中的关键字<code>Set Environment Variable</code>创建新的环境变量，或者使用关键字<code>Delete Environment Variable</code>删除现有的环境变量。因为环境变量是全局的，所以在一个测试用例中设置的环境变量可以在执行后的其他测试用例中使用。然而，对环境变量的更改在测试执行后不会生效。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Environment variables</span><br><span class="line">    Log    Current user: %&#123;USER&#125;</span><br><span class="line">    Run    %&#123;JAVA_HOME&#125;$&#123;/&#125;javac</span><br><span class="line"></span><br><span class="line">Environment variables with defaults</span><br><span class="line">    Set port    %&#123;APPLICATION_PORT=8080&#125;</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在Robot Framework 3.2中，新增了指定默认值的支持。</p>    </div>  </div><h4 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h4><p>变量可以从不同的来源产生。</p><h5 id="变量部分"><a href="#变量部分" class="headerlink" title="变量部分"></a>变量部分</h5><p>变量最常见的来源是套件文件和资源文件中的变量部分。变量部分很方便，因为它们允许在与其他测试数据相同的地方创建变量，而且所需的语法非常简单。它们的主要缺点是值总是字符串，而且不能动态创建。如果这两者中的任何一个是问题，可以使用变量文件代替。</p><h5 id="创建标量变量"><a href="#创建标量变量" class="headerlink" title="创建标量变量"></a>创建标量变量</h5><p>最简单的变量赋值就是将一个字符串设置为一个标量变量。这是通过在变量部分的第一列给出变量名（包括<code>$&#123;&#125;</code>），在第二列给出值来完成的。如果第二列为空，则设置一个空字符串作为值。也可以在值中使用已定义的变量。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;NAME&#125;         Robot Framework</span><br><span class="line">$&#123;VERSION&#125;      2.0</span><br><span class="line">$&#123;ROBOT&#125;        $&#123;NAME&#125; $&#123;VERSION&#125;</span><br></pre></td></tr></table></figure></div><p>也可以（但不是必须）在变量名后面使用等号<code>=</code>，使变量赋值稍微明确一些。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;NAME&#125; =       Robot Framework</span><br><span class="line">$&#123;VERSION&#125; =    2.0</span><br></pre></td></tr></table></figure></div><p>如果一个标量变量有一个长值，可以使用<code>...</code>语法将它分割成多行。默认情况下，行是用一个空格连接在一起的，但是可以通过在最后一个值后面使用一个分隔符配置选项来改变这一点：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;EXAMPLE&#125;      This value is joined</span><br><span class="line">...             together with a space.</span><br><span class="line">$&#123;MULTILINE&#125;    First line.</span><br><span class="line">...             Second line.</span><br><span class="line">...             Third line.</span><br><span class="line">...             separator=\n</span><br></pre></td></tr></table></figure></div><p>分隔符选项在Robot Framework 7.0中是新的，但也支持旧版本的分隔符配置。在它们中，第一个值可以包含一个特殊的<code>SEPARATOR</code>标记：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;MULTILINE&#125;    SEPARATOR=\n</span><br><span class="line">...             First line.</span><br><span class="line">...             Second line.</span><br><span class="line">...             Third line.</span><br></pre></td></tr></table></figure></div><p>分隔符选项和<code>SEPARATOR</code>标记都是区分大小写的。建议使用分隔符选项，除非需要支持旧版本。</p><h5 id="创建列表变量"><a href="#创建列表变量" class="headerlink" title="创建列表变量"></a>创建列表变量</h5><p>创建列表变量和创建标量变量一样容易。同样，变量名在变量部分的第一列，值在后续的列中。一个列表变量可以有任意数量的值，从零开始，如果需要多个值，它们可以分割成几行。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">@&#123;NAMES&#125;        Matti       Teppo</span><br><span class="line">@&#123;NAMES2&#125;       @&#123;NAMES&#125;    Seppo</span><br><span class="line">@&#123;NOTHING&#125;</span><br><span class="line">@&#123;MANY&#125;         one         two      three      four</span><br><span class="line">...             five        six      seven</span><br></pre></td></tr></table></figure></div><h5 id="创建字典变量"><a href="#创建字典变量" class="headerlink" title="创建字典变量"></a>创建字典变量</h5><p>在变量部分创建字典变量与创建列表变量类似。区别在于，项需要使用<code>name=value</code>语法或现有的字典变量创建。如果有多个具有相同名称的项，最后一个值具有优先权。如果名称包含一个字面等号，可以使用反斜杠<code>\=</code>进行转义。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">&amp;&#123;USER 1&#125;       name=Matti    address=xxx         phone=123</span><br><span class="line">&amp;&#123;USER 2&#125;       name=Teppo    address=yyy         phone=456</span><br><span class="line">&amp;&#123;MANY&#125;         first=1       second=$&#123;2&#125;         $&#123;3&#125;=third</span><br><span class="line">&amp;&#123;EVEN MORE&#125;    &amp;&#123;MANY&#125;       first=override      empty=</span><br><span class="line">...             =empty        key\=here=value</span><br></pre></td></tr></table></figure></div><p>字典变量与普通Python字典相比有两个额外的属性。首先，这些字典的值可以像属性一样访问，这意味着可以使用扩展变量语法，如<code>$&#123;VAR.key&#125;</code>。这只有在键是一个有效的属性名称，并且不匹配Python字典有的任何正常属性时才有效。例如，单个值<code>&amp;&#123;USER&#125;[name]</code>也可以像<code>$&#123;USER.name&#125;</code>（注意在这种情况下需要<code>$</code>）那样访问，但是使用<code>$&#123;MANY.3&#125;</code>是不可能的。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>对于嵌套的字典变量，键可以像<code>${VAR.nested.key}</code>那样访问。这简化了处理嵌套数据结构的工作。</p>    </div>  </div><p>字典变量的另一个特殊属性是它们是有序的。这意味着，如果遍历这些字典，它们的项总是按照它们定义的顺序出现。如果字典被用作列表变量与FOR循环或其他方式一起使用，这可能很有用。当一个字典被用作一个列表变量时，实际的值包含字典键。例如，<code>@&#123;MANY&#125;</code>变量将具有值<code>[&#39;first&#39;, &#39;second&#39;, 3]</code>。</p><h5 id="基于另一个变量创建变量名"><a href="#基于另一个变量创建变量名" class="headerlink" title="基于另一个变量创建变量名"></a>基于另一个变量创建变量名</h5><p>从Robot Framework 7.0开始，可以根据另一个变量动态创建变量名：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;X&#125;        Y</span><br><span class="line">$&#123;$&#123;X&#125;&#125;     Z    # Name is created based on &#x27;$&#123;X&#125;&#x27;.</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Dynamically created name</span><br><span class="line">    Should Be Equal    $&#123;Y&#125;    Z</span><br></pre></td></tr></table></figure></div><h4 id="变量文件"><a href="#变量文件" class="headerlink" title="变量文件"></a>变量文件</h4><p>变量文件是创建不同类型变量的最强大的机制。使用它们，可以将变量赋值给任何对象，并且它们还支持动态创建变量。变量文件的语法和如何使用变量文件在资源和变量文件部分有解释。</p><h5 id="在命令行中设置变量"><a href="#在命令行中设置变量" class="headerlink" title="在命令行中设置变量"></a>在命令行中设置变量</h5><p>可以在命令行中单独使用<code>--variable</code>（-v）选项或使用变量文件与<code>--variablefile</code>（-V）选项来设置变量。从命令行设置的变量对所有执行的测试数据文件全局可用，并且它们还会覆盖变量部分和测试数据中导入的变量文件中具有相同名称的可能变量。</p><p>设置单个变量的语法是<code>--variable name:value</code>，其中<code>name</code>是变量的名称（不包括<code>$&#123;&#125;</code>），<code>value</code>是它的值。可以通过多次使用此选项来设置多个变量。只有标量变量可以使用此语法设置，它们只能获取字符串值。</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--variable EXAMPLE:value</span><br><span class="line">--variable HOST:localhost:7272 --variable USER:robot</span><br></pre></td></tr></table></figure></div><p>在上面的例子中，设置了变量，使得</p><ul><li><code>$&#123;EXAMPLE&#125;</code>得到值<code>value</code></li><li><code>$&#123;HOST&#125;</code>和<code>$&#123;USER&#125;</code>得到值<code>localhost:7272</code>和<code>robot</code></li></ul><p>从命令行使用变量文件的基本语法是<code>--variablefile path/to/variables.py</code>，在使用变量文件部分有更多的细节。实际创建的变量取决于引用的变量文件中有哪些变量。</p><p>如果从命令行给出了变量文件和单个变量，那么后者具有更高的优先级。</p><h4 id="关键字的返回值"><a href="#关键字的返回值" class="headerlink" title="关键字的返回值"></a>关键字的返回值</h4><p>关键字的返回值也可以设置为变量。这允许在不同的测试库中的不同关键字之间进行通信。</p><p>以这种方式设置的变量与其他任何变量在其他方面是相似的，但它们只在创建它们的局部范围内可用。因此，例如，不可能在一个测试用例中设置一个变量，然后在另一个测试用例中使用它。这是因为，一般来说，自动化测试用例不应该相互依赖，而且意外地设置一个在其他地方使用的变量可能会导致难以调试的错误。如果真正需要在一个测试用例中设置一个变量，并在另一个测试用例中使用它，可以使用<code>BuiltIn</code>关键字，如下一节所解释的。</p><h5 id="分配标量变量"><a href="#分配标量变量" class="headerlink" title="分配标量变量"></a>分配标量变量</h5><p>任何由关键字返回的值都可以分配给一个标量变量。如下例所示，所需的语法非常简单：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Returning</span><br><span class="line">    $&#123;x&#125; =    Get X    an argument</span><br><span class="line">    Log    We got $&#123;x&#125;!</span><br></pre></td></tr></table></figure></div><p>在上述例子中，<code>Get X</code>关键字返回的值首先被设置到变量<code>$&#123;x&#125;</code>中，然后被<code>Log</code>关键字使用。在变量名后面有等号<code>=</code>不是必须的，但它使赋值更明确。像这样在测试用例和用户关键字级别创建局部变量都可以工作。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>虽然一个值被赋值给一个标量变量，但如果它有一个类似列表的值，它可以作为一个列表变量使用，如果它有一个类似字典的值，它可以作为一个字典变量使用。</p>    </div>  </div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    $&#123;list&#125; =    Create List    first    second    third</span><br><span class="line">    Length Should Be    $&#123;list&#125;    3</span><br><span class="line">    Log Many    @&#123;list&#125;</span><br></pre></td></tr></table></figure></div><h5 id="分配带有项值的变量"><a href="#分配带有项值的变量" class="headerlink" title="分配带有项值的变量"></a>分配带有项值的变量</h5><p>从Robot Framework 6.1开始，当使用支持项赋值的变量，如列表或字典，可以通过使用语法<code>$&#123;var&#125;[item]</code>指定项的索引或键来设置它们的值，其中<code>item</code>部分本身可以包含一个变量：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Item assignment to list</span><br><span class="line">    $&#123;list&#125; =          Create List      one    two    three    four</span><br><span class="line">    $&#123;list&#125;[0] =       Set Variable     first</span><br><span class="line">    $&#123;list&#125;[$&#123;1&#125;] =    Set Variable     second</span><br><span class="line">    $&#123;list&#125;[2:3] =     Evaluate         [&#x27;third&#x27;]</span><br><span class="line">    $&#123;list&#125;[-1] =      Set Variable     last</span><br><span class="line">    Log Many           @&#123;list&#125;          # Logs &#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27; and &#x27;last&#x27;</span><br><span class="line"></span><br><span class="line">Item assignment to dictionary</span><br><span class="line">    $&#123;dict&#125; =                Create Dictionary    first_name=unknown</span><br><span class="line">    $&#123;dict&#125;[first_name] =    Set Variable         John</span><br><span class="line">    $&#123;dict&#125;[last_name] =     Set Variable         Doe</span><br><span class="line">    Log                      $&#123;dictionary&#125;        # Logs &#123;&#x27;first_name&#x27;: &#x27;John&#x27;, &#x27;last_name&#x27;: &#x27;Doe&#x27;&#125;</span><br></pre></td></tr></table></figure></div><h5 id="基于另一个变量创建变量名-1"><a href="#基于另一个变量创建变量名-1" class="headerlink" title="基于另一个变量创建变量名"></a>基于另一个变量创建变量名</h5><p>从Robot Framework 7.0开始，可以根据另一个变量动态创建被赋值变量的名称：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Dynamically created name</span><br><span class="line">    $&#123;x&#125; =    Set Variable    y</span><br><span class="line">    $&#123;$&#123;x&#125;&#125; =    Set Variable    z    # Name is created based on &#x27;$&#123;x&#125;&#x27;.</span><br><span class="line">    Should Be Equal    $&#123;y&#125;    z</span><br></pre></td></tr></table></figure></div><h5 id="分配列表变量"><a href="#分配列表变量" class="headerlink" title="分配列表变量"></a>分配列表变量</h5><p>如果一个关键字返回一个列表或任何类似列表的对象，可以将其分配给一个列表变量：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    @&#123;list&#125; =    Create List    first    second    third</span><br><span class="line">    Length Should Be    $&#123;list&#125;    3</span><br><span class="line">    Log Many    @&#123;list&#125;</span><br></pre></td></tr></table></figure></div><p>因为所有的Robot Framework变量都存储在同一个命名空间中，所以将一个值分配给一个标量变量或一个列表变量之间没有太大的区别。这可以通过比较上面的最后两个例子来看出。主要的区别是，当创建一个列表变量时，Robot Framework会自动验证该值是否是一个列表或类似列表，存储的变量值将是从返回值创建的一个新列表。当分配给一个标量变量时，返回值不会被验证，存储的值将是返回的完全相同的对象。</p><h5 id="分配字典变量"><a href="#分配字典变量" class="headerlink" title="分配字典变量"></a>分配字典变量</h5><p>如果一个关键字返回一个字典或任何类似字典的对象，可以将其分配给一个字典变量：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    &amp;&#123;dict&#125; =    Create Dictionary    first=1    second=$&#123;2&#125;    $&#123;3&#125;=third</span><br><span class="line">    Length Should Be    $&#123;dict&#125;    3</span><br><span class="line">    Do Something    &amp;&#123;dict&#125;</span><br><span class="line">    Log    $&#123;dict.first&#125;</span><br></pre></td></tr></table></figure></div><p>因为所有的Robot Framework变量都存储在同一个命名空间中，也可以将一个字典分配给一个标量变量，然后在需要的时候将其作为一个字典使用。然而，显式创建一个字典变量有一些实际的好处。首先，Robot Framework验证返回的值是否是一个字典或类似字典，就像它验证列表变量只能得到一个类似列表的值一样。</p><p>一个更大的好处是，该值被转换为一个特殊的字典，它也在创建变量部分中创建字典变量时使用。这些字典中的值可以使用属性访问，如上例中的<code>$&#123;dict.first&#125;</code>。这些字典也是有序的，但如果原始字典不是有序的，结果的顺序是任意的。</p><h5 id="分配多个变量"><a href="#分配多个变量" class="headerlink" title="分配多个变量"></a>分配多个变量</h5><p>如果一个关键字返回一个列表或一个类似列表的对象，可以将单个值分配给多个标量变量或标量变量和一个列表变量。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Assign multiple</span><br><span class="line">    $&#123;a&#125;    $&#123;b&#125;    $&#123;c&#125; =    Get Three</span><br><span class="line">    $&#123;first&#125;    @&#123;rest&#125; =    Get Three</span><br><span class="line">    @&#123;before&#125;    $&#123;last&#125; =    Get Three</span><br><span class="line">    $&#123;begin&#125;    @&#123;middle&#125;    $&#123;end&#125; =    Get Three</span><br></pre></td></tr></table></figure></div><p>假设关键字<code>Get Three</code>返回一个列表<code>[1, 2, 3]</code>，则创建以下变量：</p><ul><li><code>$&#123;a&#125;</code>、<code>$&#123;b&#125;</code>和<code>$&#123;c&#125;</code>的值分别为1、2和3。</li><li><code>$&#123;first&#125;</code>的值为1，<code>@&#123;rest&#125;</code>的值为<code>[2, 3]</code>。</li><li><code>@&#123;before&#125;</code>的值为<code>[1, 2]</code>，<code>$&#123;last&#125;</code>的值为3。</li><li><code>$&#123;begin&#125;</code>的值为1，<code>@&#123;middle&#125;</code>的值为<code>[2]</code>，<code>$&#123;end&#125;</code>的值为3。</li></ul><p>如果返回的列表的值多于或少于要分配的标量变量的数量，那么这是一个错误。此外，只允许一个列表变量，字典变量只能单独分配。</p><h5 id="自动记录分配的变量值"><a href="#自动记录分配的变量值" class="headerlink" title="自动记录分配的变量值"></a>自动记录分配的变量值</h5><p>为了更容易理解执行过程中发生了什么，分配的值的开始部分会被自动记录。默认情况下，显示前200个字符，但可以通过在运行测试时使用<code>--maxassignlength</code>命令行选项来改变这个值。如果值为零或负数，整个分配的值将被隐藏。</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--maxassignlength 1000</span><br><span class="line">--maxassignlength 0</span><br></pre></td></tr></table></figure></div><p>不完全记录值的原因是，它可能非常大。如果你总是想完全看到某个值，可以使用<code>BuiltIn Log</code>关键字在分配后记录它。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p><code>--maxassignlength</code>选项在Robot Framework 5.0中是新的。</p>    </div>  </div><h5 id="VAR语法"><a href="#VAR语法" class="headerlink" title="VAR语法"></a>VAR语法</h5><p>从Robot Framework 7.0开始，可以使用VAR语法在测试和用户关键字内部创建变量。VAR标记是区分大小写的，必须跟着一个变量名和值。除了必须的VAR，整体语法大多与在变量部分创建变量时的语法相同。</p><p>新的语法旨在使创建变量更简单、更统一。它特别用于替代<code>BuiltIn</code>关键字<code>Set Variable</code>、<code>Set Test Variable</code>、<code>Set Suite Variable</code>和<code>Set Global Variable</code>，但也可以用来替代<code>Catenate</code>、<code>Create List</code>和<code>Create Dictionary</code>。</p><h5 id="创建标量变量-1"><a href="#创建标量变量-1" class="headerlink" title="创建标量变量"></a>创建标量变量</h5><p>在简单的情况下，通过给出一个变量名和它的值来创建标量变量。值可以是一个硬编码的字符串，也可以包含一个变量。如果值很长，可以将其分割成多个列和行。在这种情况下，默认情况下，部分会用一个空格连接在一起，但可以使用分隔符配置选项来指定要使用的分隔符。在创建基于关键字的返回值的变量和在变量部分中的变量时，变量名后面可以有一个可选的<code>=</code>。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Scalar examples</span><br><span class="line">     VAR    $&#123;simple&#125;       variable</span><br><span class="line">     VAR    $&#123;equals&#125; =     this works too</span><br><span class="line">     VAR    $&#123;variable&#125;     value contains $&#123;simple&#125;</span><br><span class="line">     VAR    $&#123;sentence&#125;     This is a bit longer variable value</span><br><span class="line">     ...                    that is split into multiple rows.</span><br><span class="line">     ...                    These parts are joined with a space.</span><br><span class="line">     VAR    $&#123;multiline&#125;    This is another longer value.</span><br><span class="line">     ...                    This time there is a custom separator.</span><br><span class="line">     ...                    As the result this becomes a multiline string.</span><br><span class="line">     ...                    separator=\n</span><br></pre></td></tr></table></figure></div><h5 id="创建列表和字典变量"><a href="#创建列表和字典变量" class="headerlink" title="创建列表和字典变量"></a>创建列表和字典变量</h5><p>列表和字典变量的创建与标量变量类似。创建字典时，必须使用<code>name=value</code>语法指定项。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">List examples</span><br><span class="line">     VAR    @&#123;two items&#125;     Robot    Framework</span><br><span class="line">     VAR    @&#123;empty list&#125;</span><br><span class="line">     VAR    @&#123;lot of stuff&#125;</span><br><span class="line">     ...    first item</span><br><span class="line">     ...    second item</span><br><span class="line">     ...    third item</span><br><span class="line">     ...    fourth item</span><br><span class="line">     ...    last item</span><br><span class="line"></span><br><span class="line">Dictionary examples</span><br><span class="line">     VAR    &amp;&#123;two items&#125;     name=Robot Framework    url=http://robotframework.org</span><br><span class="line">     VAR    &amp;&#123;empty dict&#125;</span><br><span class="line">     VAR    &amp;&#123;lot of stuff&#125;</span><br><span class="line">     ...    first=1</span><br><span class="line">     ...    second=2</span><br><span class="line">     ...    third=3</span><br><span class="line">     ...    fourth=4</span><br><span class="line">     ...    last=5        </span><br></pre></td></tr></table></figure></div><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>使用VAR语法创建的变量只在创建它们的测试或用户关键字内部可用。然而，可以通过使用作用域配置选项来改变这一点。支持的值有LOCAL（默认）、TEST（在当前测试中可用）、TASK（TEST的别名）、SUITE（在当前套件中可用）和GLOBAL（全局可用）。尽管Robot Framework变量是不区分大小写的，但建议使用大写字母表示非局部变量名。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;SUITE&#125;         this value is overridden</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Scope example</span><br><span class="line">    VAR    $&#123;local&#125;     local value</span><br><span class="line">    VAR    $&#123;TEST&#125;      test value      scope=TEST</span><br><span class="line">    VAR    $&#123;SUITE&#125;     suite value     scope=SUITE</span><br><span class="line">    VAR    $&#123;GLOBAL&#125;    global value    scope=GLOBAL</span><br><span class="line">    Should Be Equal    $&#123;local&#125;     local value</span><br><span class="line">    Should Be Equal    $&#123;TEST&#125;      test value</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    global value</span><br><span class="line">    Keyword</span><br><span class="line">    Should Be Equal    $&#123;TEST&#125;      new test value</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     new suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    new global value</span><br><span class="line"></span><br><span class="line">Scope example, part 2</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     new suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    new global value</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">Keyword</span><br><span class="line">    Should Be Equal    $&#123;TEST&#125;      test value</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    global value</span><br><span class="line">    VAR    $&#123;TEST&#125;      new $&#123;TEST&#125;      scope=TEST</span><br><span class="line">    VAR    $&#123;SUITE&#125;     new $&#123;SUITE&#125;     scope=SUITE</span><br><span class="line">    VAR    $&#123;GLOBAL&#125;    new $&#123;GLOBAL&#125;    scope=GLOBAL</span><br><span class="line">    Should Be Equal    $&#123;TEST&#125;      new test value</span><br><span class="line">    Should Be Equal    $&#123;SUITE&#125;     new suite value</span><br><span class="line">    Should Be Equal    $&#123;GLOBAL&#125;    new global value</span><br></pre></td></tr></table></figure></div><h5 id="条件创建变量"><a href="#条件创建变量" class="headerlink" title="条件创建变量"></a>条件创建变量</h5><p>VAR语法可以与IF&#x2F;ELSE结构一起工作，这使得条件创建变量变得容易。在简单的情况下，使用内联IF可能很方便。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">IF/ELSE example</span><br><span class="line">    IF    &quot;$&#123;ENV&#125;&quot; == &quot;devel&quot;</span><br><span class="line">        VAR    $&#123;address&#125;    127.0.0.1</span><br><span class="line">        VAR    $&#123;name&#125;       demo</span><br><span class="line">    ELSE</span><br><span class="line">        VAR    $&#123;address&#125;    192.168.1.42</span><br><span class="line">        VAR    $&#123;name&#125;       robot</span><br><span class="line">    END</span><br><span class="line"></span><br><span class="line">Inline IF</span><br><span class="line">    IF    &quot;$&#123;ENV&#125;&quot; == &quot;devel&quot;    VAR    $&#123;name&#125;    demo    ELSE    VAR    $&#123;name&#125;    robot</span><br></pre></td></tr></table></figure></div><h5 id="基于另一个变量创建变量名-2"><a href="#基于另一个变量创建变量名-2" class="headerlink" title="基于另一个变量创建变量名"></a>基于另一个变量创建变量名</h5><p>如果有需要，也可以根据另一个变量动态创建变量名。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Dynamic name</span><br><span class="line">    VAR    $&#123;x&#125;       y    # Normal assignment.</span><br><span class="line">    VAR    $&#123;$&#123;x&#125;&#125;    z    # Name created dynamically.</span><br><span class="line">    Should Be Equal    $&#123;y&#125;    z</span><br></pre></td></tr></table></figure></div><h4 id="使用Set-Test-Suite-Global-Variable关键字"><a href="#使用Set-Test-Suite-Global-Variable关键字" class="headerlink" title="使用Set Test&#x2F;Suite&#x2F;Global Variable关键字"></a>使用Set Test&#x2F;Suite&#x2F;Global Variable关键字</h4>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在使用Robot Framework 7.0或更高版本时，推荐使用VAR语法而不是这些关键字。</p>    </div>  </div><p><code>BuiltIn</code>库有<code>Set Test Variable</code>、<code>Set Suite Variable</code>和<code>Set Global Variable</code>关键字，可以用于在测试执行期间动态设置变量。如果一个变量已经存在于新的作用域中，其值将被覆盖，否则将创建一个新的变量。</p><p>使用<code>Set Test Variable</code>关键字设置的变量在当前执行的测试用例的作用域内处处可用。例如，如果你在一个用户关键字中设置了一个变量，它既可以在测试用例级别使用，也可以在当前测试中使用的所有其他用户关键字中使用。其他的测试用例将不会看到用这个关键字设置的变量。在测试的作用域之外调用<code>Set Test Variable</code>（例如，在套件设置或拆卸中）是一个错误。</p><p>使用<code>Set Suite Variable</code>关键字设置的变量在当前执行的测试套件的作用域内处处可用。因此，使用这个关键字设置变量具有与在测试数据文件中使用变量部分创建它们或从变量文件中导入它们相同的效果。其他的测试套件，包括可能的子测试套件，将不会看到用这个关键字设置的变量。</p><p>使用<code>Set Global Variable</code>关键字设置的变量在设置它们后执行的所有测试用例和套件中全局可用。因此，使用这个关键字设置变量具有与使用<code>--variable</code>或<code>--variablefile</code>选项从命令行创建它们相同的效果。因为这个关键字可以在任何地方改变变量，所以应该小心使用。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p><code>Set Test/Suite/Global Variable</code>关键字直接将命名变量设置到测试、套件或全局变量作用域，并且不返回任何东西。另一方面，另一个<code>BuiltIn</code>关键字<code>Set Variable</code>使用返回值设置局部变量。</p>    </div>  </div><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p>Robot Framework自动提供了一些内置变量。</p><h4 id="操作系统变量"><a href="#操作系统变量" class="headerlink" title="操作系统变量"></a>操作系统变量</h4><p>与操作系统相关的内置变量使得测试数据对操作系统无关。</p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td><code>$&#123;CURDIR&#125;</code></td><td>测试数据文件所在目录的绝对路径。此变量区分大小写。</td></tr><tr><td><code>$&#123;TEMPDIR&#125;</code></td><td>系统临时目录的绝对路径。在类 UNIX 系统中通常是 <code>/tmp</code>，在 Windows 中是 <code>c:\Documents and Settings\&lt;user&gt;\Local Settings\Temp</code>。</td></tr><tr><td><code>$&#123;EXECDIR&#125;</code></td><td>测试执行开始的目录的绝对路径。</td></tr><tr><td><code>$&#123;/&#125;</code></td><td>系统目录路径分隔符。在类 UNIX 系统中是 <code>/</code>，在 Windows 中是 <code>\</code>。</td></tr><tr><td><code>$&#123;:&#125;</code></td><td>系统路径元素分隔符。在类 UNIX 系统中是 <code>:</code>，在 Windows 中是 <code>;</code>。</td></tr><tr><td><code>$&#123;\n&#125;</code></td><td>系统行分隔符。在类 UNIX 系统中是 <code>\n</code>，在 Windows 中是 <code>\r\n</code>。</td></tr></tbody></table><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Create Binary File    $&#123;CURDIR&#125;$&#123;/&#125;input.data    Some text here$&#123;\n&#125;on two lines</span><br><span class="line">    Set Environment Variable    CLASSPATH    $&#123;TEMPDIR&#125;$&#123;:&#125;$&#123;CURDIR&#125;$&#123;/&#125;foo.jar</span><br></pre></td></tr></table></figure></div><h4 id="数字变量"><a href="#数字变量" class="headerlink" title="数字变量"></a>数字变量</h4><p>变量语法可以用于创建整数和浮点数，如下例所示。当一个关键字期望得到一个实际的数字，而不是一个看起来像数字的字符串作为参数时，这是有用的。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example 1A</span><br><span class="line">    Connect    example.com    80       # Connect gets two strings as arguments</span><br><span class="line"></span><br><span class="line">Example 1B</span><br><span class="line">    Connect    example.com    $&#123;80&#125;    # Connect gets a string and an integer</span><br><span class="line"></span><br><span class="line">Example 2</span><br><span class="line">    Do X    $&#123;3.14&#125;    $&#123;-1e-4&#125;        # Do X gets floating point numbers 3.14 and -0.0001</span><br></pre></td></tr></table></figure></div><p>也可以使用0b、0o和0x前缀分别从二进制、八进制和十六进制值创建整数。语法不区分大小写。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    Should Be Equal    $&#123;0b1011&#125;    $&#123;11&#125;</span><br><span class="line">    Should Be Equal    $&#123;0o10&#125;      $&#123;8&#125;</span><br><span class="line">    Should Be Equal    $&#123;0xff&#125;      $&#123;255&#125;</span><br><span class="line">    Should Be Equal    $&#123;0B1010&#125;    $&#123;0XA&#125;</span><br></pre></td></tr></table></figure></div><h4 id="布尔和None-null变量"><a href="#布尔和None-null变量" class="headerlink" title="布尔和None&#x2F;null变量"></a>布尔和None&#x2F;null变量</h4><p>也可以使用变量语法创建布尔值和Python的None，就像创建数字一样。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Boolean</span><br><span class="line">    Set Status    $&#123;true&#125;               # Set Status gets Boolean true as an argument</span><br><span class="line">    Create Y    something   $&#123;false&#125;    # Create Y gets a string and Boolean false</span><br><span class="line"></span><br><span class="line">None</span><br><span class="line">    Do XYZ    $&#123;None&#125;                   # Do XYZ gets Python None as an argument</span><br></pre></td></tr></table></figure></div><p>这些变量是不区分大小写的，所以例如<code>$&#123;True&#125;</code>和<code>$&#123;true&#125;</code>是等价的。</p><h4 id="空格和空变量"><a href="#空格和空变量" class="headerlink" title="空格和空变量"></a>空格和空变量</h4><p>可以使用变量<code>$&#123;SPACE&#125;</code>和<code>$&#123;EMPTY&#125;</code>分别创建空格和空字符串。这些变量在需要转义空格或空单元格时很有用。如果需要多个空格，可以使用扩展变量语法，如<code>$&#123;SPACE * 5&#125;</code>。在下面的例子中，<code>Should Be Equal</code>关键字得到相同的参数，但使用变量的那些比使用反斜杠的更容易理解。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">One space</span><br><span class="line">    Should Be Equal    $&#123;SPACE&#125;          \ \</span><br><span class="line"></span><br><span class="line">Four spaces</span><br><span class="line">    Should Be Equal    $&#123;SPACE * 4&#125;      \ \ \ \ \</span><br><span class="line"></span><br><span class="line">Ten spaces</span><br><span class="line">    Should Be Equal    $&#123;SPACE * 10&#125;     \ \ \ \ \ \ \ \ \ \ \</span><br><span class="line"></span><br><span class="line">Quoted space</span><br><span class="line">    Should Be Equal    &quot;$&#123;SPACE&#125;&quot;        &quot; &quot;</span><br><span class="line"></span><br><span class="line">Quoted spaces</span><br><span class="line">    Should Be Equal    &quot;$&#123;SPACE * 2&#125;&quot;    &quot; \ &quot;</span><br><span class="line"></span><br><span class="line">Empty</span><br><span class="line">    Should Be Equal    $&#123;EMPTY&#125;          \</span><br></pre></td></tr></table></figure></div><p>还有一个空列表变量<code>@&#123;EMPTY&#125;</code>和一个空字典变量<code>&amp;&#123;EMPTY&#125;</code>。因为它们没有内容，所以当它们在测试数据中被使用时，基本上就消失了。它们在测试模板中很有用，例如当模板关键字没有参数时，或者在不同的作用域中覆盖列表或字典变量时。不能修改<code>@&#123;EMPTY&#125;</code>或<code>&amp;&#123;EMPTY&#125;</code>的值。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Template</span><br><span class="line">    [Template]    Some keyword</span><br><span class="line">    @&#123;EMPTY&#125;</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line">    Set Global Variable    @&#123;LIST&#125;    @&#123;EMPTY&#125;</span><br><span class="line">    Set Suite Variable     &amp;&#123;DICT&#125;    &amp;&#123;EMPTY&#125;</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><code>${SPACE}</code>表示ASCII空格（<code>\x20</code>），其他空格应使用转义序列指定，如<code>\xA0</code>（NO-BREAK SPACE）和<code>\u3000</code>（IDEOGRAPHIC SPACE）。</p>    </div>  </div><h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><p>在测试数据中也可以使用一些自动变量。这些变量在测试执行期间可以有不同的值，有些甚至不是一直可用。改变这些变量的值不会影响原始值，但是一些值可以使用<code>BuiltIn</code>库的关键字动态改变。</p><p>可用的自动变量如下：</p><table><thead><tr><th>变量</th><th>解释</th><th>可用性</th></tr></thead><tbody><tr><td>${TEST NAME}</td><td>当前测试用例的名称。</td><td>测试用例</td></tr><tr><td>@{TEST TAGS}</td><td>包含当前测试用例的标签，按字母顺序排列。可以使用<code>Set Tags</code>和<code>Remove Tags</code>关键字动态修改。</td><td>测试用例</td></tr><tr><td>${TEST DOCUMENTATION}</td><td>当前测试用例的文档。可以使用<code>Set Test Documentation</code>关键字动态设置。</td><td>测试用例</td></tr><tr><td>${TEST STATUS}</td><td>当前测试用例的状态，<code>PASS</code>或<code>FAIL</code>。</td><td>测试拆卸</td></tr><tr><td>${TEST MESSAGE}</td><td>当前测试用例的消息。</td><td>测试拆卸</td></tr><tr><td>${PREV TEST NAME}</td><td>上一个测试用例的名称，如果没有执行过测试，则为空字符串。</td><td>任何地方</td></tr><tr><td>${PREV TEST STATUS}</td><td>上一个测试用例的状态：<code>PASS</code>、<code>FAIL</code>，或者当没有执行过测试时为空字符串。</td><td>任何地方</td></tr><tr><td>${PREV TEST MESSAGE}</td><td>上一个测试用例可能的错误消息。</td><td>任何地方</td></tr><tr><td>${SUITE NAME}</td><td>当前测试套件的全名。</td><td>任何地方</td></tr><tr><td>${SUITE SOURCE}</td><td>套件文件或目录的绝对路径。</td><td>任何地方</td></tr><tr><td>${SUITE DOCUMENTATION}</td><td>当前测试套件的文档。可以使用<code>Set Suite Documentation</code>关键字动态设置。</td><td>任何地方</td></tr><tr><td>&amp;{SUITE METADATA}</td><td>当前测试套件的自由元数据。可以使用<code>Set Suite Metadata</code>关键字设置。</td><td>任何地方</td></tr><tr><td>${SUITE STATUS}</td><td>当前测试套件的状态，<code>PASS</code>或<code>FAIL</code>。</td><td>套件拆卸</td></tr><tr><td>${SUITE MESSAGE}</td><td>当前测试套件的完整消息，包括统计信息。</td><td>套件拆卸</td></tr><tr><td>${KEYWORD STATUS}</td><td>当前关键字的状态，<code>PASS</code>或<code>FAIL</code>。</td><td>用户关键字拆卸</td></tr><tr><td>${KEYWORD MESSAGE}</td><td>当前关键字可能的错误消息。</td><td>用户关键字拆卸</td></tr><tr><td>${LOG LEVEL}</td><td>当前日志级别。</td><td>任何地方</td></tr><tr><td>${OUTPUT DIR}</td><td>输出目录的绝对路径，为字符串。</td><td>任何地方</td></tr><tr><td>${OUTPUT FILE}</td><td>输出文件的绝对路径，为字符串，如果输出文件未创建，则为字符串<code>NONE</code>。</td><td>任何地方</td></tr><tr><td>${LOG FILE}</td><td>日志文件的绝对路径，为字符串，如果日志文件未创建，则为字符串<code>NONE</code>。</td><td>任何地方</td></tr><tr><td>${REPORT FILE}</td><td>报告文件的绝对路径，为字符串，如果报告文件未创建，则为字符串<code>NONE</code>。</td><td>任何地方</td></tr><tr><td>${DEBUG FILE}</td><td>调试文件的绝对路径，为字符串，如果调试文件未创建，则为字符串<code>NONE</code>。</td><td>任何地方</td></tr><tr><td>&amp;{OPTIONS}</td><td>一个暴露命令行选项的字典。字典的键匹配命令行选项，可以像{OPTIONS}[key]和OPTIONS[key]和{OPTIONS.key}这样访问。可用的选项有：{OPTIONS.exclude} (–exclude)、OPTIONS.exclude(−−exclude)、{OPTIONS.include} (–include)、{OPTIONS.skip} (–skip)、OPTIONS.skip(−−skip)、{OPTIONS.skip_on_failure} (–skiponfailure)。在RF 5.0中新增。以后可以暴露更多的选项。</td><td>任何地方</td></tr></tbody></table><p>套件相关的变量<code>$&#123;SUITE SOURCE&#125;</code>、<code>$&#123;SUITE NAME&#125;</code>、<code>$&#123;SUITE DOCUMENTATION&#125;</code>和<code>&amp;&#123;SUITE METADATA&#125;</code>以及与命令行选项相关的选项，如<code>$&#123;LOG FILE&#125;</code>和<code>&amp;&#123;OPTIONS&#125;</code>，在导入库和变量文件时就已经可用。然而，在导入时，这些自动变量中可能的变量还没有被解析。</p><h3 id="变量优先级和作用域"><a href="#变量优先级和作用域" class="headerlink" title="变量优先级和作用域"></a>变量优先级和作用域</h3><p>来自不同来源的变量有不同的优先级，并且在不同的作用域中可用。</p><h4 id="变量优先级"><a href="#变量优先级" class="headerlink" title="变量优先级"></a>变量优先级</h4><h5 id="命令行中的变量"><a href="#命令行中的变量" class="headerlink" title="命令行中的变量"></a>命令行中的变量</h5><p>在实际的测试执行开始之前，可以设置的所有变量中，命令行中设置的变量具有最高的优先级。它们会覆盖在测试用例文件的变量部分创建的可能的变量，以及在测试数据中导入的资源和变量文件中的变量。</p><p>单独设置的变量（<code>--variable</code>选项）会覆盖使用变量文件设置的变量（<code>--variablefile</code>选项）。如果你多次指定同一个单独的变量，最后指定的那个将覆盖前面的。这允许在启动脚本中为变量设置默认值，并从命令行中覆盖它们。注意，如果多个变量文件有相同的变量，那么在首先指定的文件中的变量具有最高的优先级。</p><h5 id="测试用例文件中的变量部分"><a href="#测试用例文件中的变量部分" class="headerlink" title="测试用例文件中的变量部分"></a>测试用例文件中的变量部分</h5><p>在测试用例文件的变量部分创建的变量对该文件中的所有测试用例都可用。这些变量会覆盖在导入的资源和变量文件中具有相同名称的可能的变量。</p><p>在变量部分创建的变量在创建它们的文件中的所有其他部分都可用。这意味着它们也可以在设置部分中使用，例如，用于从资源和变量文件中导入更多的变量。</p><h5 id="导入的资源和变量文件"><a href="#导入的资源和变量文件" class="headerlink" title="导入的资源和变量文件"></a>导入的资源和变量文件</h5><p>从资源和变量文件导入的变量在测试数据中创建的所有变量中具有最低的优先级。资源文件和变量文件中的变量具有相同的优先级。如果几个资源和&#x2F;或变量文件有相同的变量，那么首先导入的文件中的变量将被使用。</p><p>如果一个资源文件导入资源文件或变量文件，那么它自己的变量部分中的变量具有比它导入的变量更高的优先级。所有这些变量都可用于导入此资源文件的文件。</p><p>注意，从资源和变量文件导入的变量在导入它们的文件的变量部分中不可用。这是因为在处理设置部分（其中导入资源文件和变量文件）之前，已经处理了变量部分。</p><h5 id="在测试执行期间设置的变量"><a href="#在测试执行期间设置的变量" class="headerlink" title="在测试执行期间设置的变量"></a>在测试执行期间设置的变量</h5><p>在测试执行期间设置的变量，无论是使用关键字的返回值还是使用<code>Set Test/Suite/Global Variable</code>关键字，总是覆盖在它们被设置的作用域中可能存在的变量。从某种意义上说，它们因此具有最高的优先级，但另一方面，它们不影响它们定义的作用域之外的变量。</p><h5 id="内置变量-1"><a href="#内置变量-1" class="headerlink" title="内置变量"></a>内置变量</h5><p>像<code>$&#123;TEMPDIR&#125;</code>和<code>$&#123;TEST_NAME&#125;</code>这样的内置变量具有所有变量中最高的优先级。它们不能使用变量部分或从命令行覆盖，但即使它们也可以在测试执行期间重置。这个规则的一个例外是数字变量，如果没有找到其他变量，它们会动态地被解析。因此，它们可以被覆盖，但这通常是一个坏主意。此外，<code>$&#123;CURDIR&#125;</code>是特殊的，因为它在测试数据处理时间就已经被替换了。</p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>根据它们的创建位置和方式，变量可以具有全局、测试套件、测试用例或局部作用域。</p><h5 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h5><p>全局变量在测试数据中的任何地方都可用。这些变量通常在命令行中使用<code>--variable</code>和<code>--variablefile</code>选项设置，但也可以在测试数据的任何地方使用VAR语法或<code>Set Global Variable</code>关键字创建新的全局变量或更改现有的全局变量。此外，内置变量也是全局的。</p><p>建议使用大写字母表示所有全局变量。</p><h5 id="测试套件作用域"><a href="#测试套件作用域" class="headerlink" title="测试套件作用域"></a>测试套件作用域</h5><p>具有测试套件作用域的变量在定义或导入它们的测试套件的任何地方都可用。它们可以在变量部分中创建，从资源和变量文件中导入，或者在测试执行期间使用VAR语法或<code>Set Suite Variable</code>关键字设置。</p><p>测试套件作用域不是递归的，这意味着在高级测试套件中可用的变量在低级套件中不可用。如果需要，可以使用资源和变量文件共享变量。</p><p>由于这些变量在使用它们的测试套件中可以被认为是全局的，因此也建议使用大写字母表示它们。</p><h5 id="测试用例作用域"><a href="#测试用例作用域" class="headerlink" title="测试用例作用域"></a>测试用例作用域</h5><p>具有测试用例作用域的变量在测试用例和测试使用的所有用户关键字中可见。最初在这个作用域中没有变量，但是可以在测试用例的任何地方使用VAR语法或<code>Set Test Variable</code>关键字创建它们。在套件设置或套件拆卸中尝试创建测试变量会导致错误。</p><p>测试用例作用域中的变量也在某种程度上是全局的。因此，通常建议使用大写字母表示它们。</p><h5 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h5><p>测试用例和用户关键字有一个局部变量作用域，其他测试或关键字看不到。局部变量可以使用执行的关键字的返回值和VAR语法创建，用户关键字也可以将它们作为参数获取。</p><p>建议使用小写字母表示局部变量。</p><h4 id="高级变量特性"><a href="#高级变量特性" class="headerlink" title="高级变量特性"></a>高级变量特性</h4><h5 id="扩展变量语法"><a href="#扩展变量语法" class="headerlink" title="扩展变量语法"></a>扩展变量语法</h5><p>扩展变量语法允许访问分配给变量的对象的属性（例如，<code>$&#123;object.attribute&#125;</code>）甚至调用其方法（例如，<code>$&#123;obj.getName()&#125;</code>）。它既适用于标量变量，也适用于列表变量，但主要用于前者。</p><p>扩展变量语法是一个强大的特性，但应谨慎使用。访问属性通常不是问题，相反，因为一个包含多个属性的对象的变量通常比有多个变量更好。另一方面，调用方法，特别是当它们带有参数时，可能会使测试数据变得相当复杂。如果发生这种情况，建议将代码移动到测试库中。</p><p>下面的例子说明了扩展变量语法的最常见用法。首先假设我们有以下变量文件和测试用例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, what</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s eats %s&#x27;</span> % (self.name, what)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">OBJECT = MyObject(<span class="string">&#x27;Robot&#x27;</span>)</span><br><span class="line">DICTIONARY = &#123;<span class="number">1</span>: <span class="string">&#x27;one&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;two&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    KW <span class="number">1</span>    $&#123;OBJECT.name&#125;</span><br><span class="line">    KW <span class="number">2</span>    $&#123;OBJECT.eat(<span class="string">&#x27;Cucumber&#x27;</span>)&#125;</span><br><span class="line">    KW <span class="number">3</span>    $&#123;DICTIONARY[<span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure></div><p>当执行这个测试数据时，关键字得到的参数如下：</p><ul><li>KW 1得到字符串Robot</li><li>KW 2得到字符串Robot eats Cucumber</li><li>KW 3得到字符串two</li></ul><p>扩展变量语法按以下顺序进行评估：</p><ol><li>使用完整的变量名搜索变量。只有在没有找到匹配的变量时，才会评估扩展变量语法。</li><li>创建基变量的名称。名称的主体由打开<code>&#123;</code>后的所有字符组成，直到第一个不是字母数字字符或空格的字符出现。例如，<code>$&#123;OBJECT.name&#125;</code>和<code>$&#123;DICTIONARY[2]&#125;</code>的基变量分别是OBJECT和DICTIONARY。</li><li>搜索与主体匹配的变量。如果没有匹配，将引发异常并使测试用例失败。</li><li>将花括号内的表达式作为Python表达式进行评估，以便将基变量名替换为其值。如果评估失败，因为语法无效或查询的属性不存在，将引发异常并使测试失败。</li><li>将整个扩展变量替换为从评估返回的值。</li></ol><p>许多标准的Python对象，包括字符串和数字，都有可以使用扩展变量语法显式或隐式使用的方法。有时这可能非常有用，减少了设置临时变量的需要，但也很容易过度使用它，创建真正的神秘测试数据。下面的例子展示了一些相当好的用法。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">String</span><br><span class="line">    $&#123;string&#125; =    Set Variable    abc</span><br><span class="line">    Log    $&#123;string.upper()&#125;      # Logs &#x27;ABC&#x27;</span><br><span class="line">    Log    $&#123;string * 2&#125;          # Logs &#x27;abcabc&#x27;</span><br><span class="line"></span><br><span class="line">Number</span><br><span class="line">    $&#123;number&#125; =    Set Variable    $&#123;-2&#125;</span><br><span class="line">    Log    $&#123;number * 10&#125;         # Logs -20</span><br><span class="line">    Log    $&#123;number.__abs__()&#125;    # Logs 2</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>尽管在正常的Python代码中推荐使用<code>abs(number)</code>而不是<code>number.__abs__()</code>，但使用<code>${abs(number)}</code>是不起作用的。这是因为变量名必须在扩展语法的开始。在测试数据中像这样使用<code>__xxx__</code>方法已经有点可疑了，通常最好将这种逻辑移动到测试库中。</p>    </div>  </div><p>扩展变量语法也适用于列表变量上下文。例如，如果一个分配给变量<code>$&#123;EXTENDED&#125;</code>的对象有一个包含列表值的属性，它可以被用作列表变量<code>@&#123;EXTENDED.attribute&#125;</code>。</p><h5 id="扩展变量赋值"><a href="#扩展变量赋值" class="headerlink" title="扩展变量赋值"></a>扩展变量赋值</h5><p>可以使用关键字返回值和扩展变量语法的变体，将对象的属性设置到标量变量中。假设我们有前面例子中的变量<code>$&#123;OBJECT&#125;</code>，可以像下面的例子那样设置它的属性。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    $&#123;OBJECT.name&#125; =    Set Variable    New name</span><br><span class="line">    $&#123;OBJECT.new_attr&#125; =    Set Variable    New attribute</span><br></pre></td></tr></table></figure></div><p>扩展变量赋值语法按照以下规则进行评估：</p><ol><li>被赋值的变量必须是一个标量变量，并且至少有一个点。否则，不使用扩展赋值语法，而是正常赋值变量。</li><li>如果存在一个与完整名称相匹配的变量（例如，上面例子中的<code>$&#123;OBJECT.name&#125;</code>），那么该变量将被赋予一个新的值，不使用扩展语法。</li><li>创建基变量的名称。名称的主体由打开<code>$&#123;</code>和最后一个点之间的所有字符组成，例如，<code>$&#123;OBJECT.name&#125;</code>中的<code>OBJECT</code>和<code>$&#123;foo.bar.zap&#125;</code>中的<code>foo.bar</code>。正如第二个例子所示，基名称可能包含正常的扩展变量语法。</li><li>通过取最后一个点和闭合<code>&#125;</code>之间的所有字符来创建要设置的属性的名称，例如，<code>$&#123;OBJECT.name&#125;</code>中的<code>name</code>。如果名称不是以字母或下划线开头，并且只包含这些字符和数字，那么该属性被认为是无效的，不使用扩展语法。而是创建一个具有完整名称的新变量。</li><li>搜索与基名称匹配的变量。如果没有找到变量，那么不使用扩展语法，而是使用完整的变量名称创建一个新的变量。</li><li>如果找到的变量是一个字符串或一个数字，那么忽略扩展语法，并使用完整的名称创建一个新的变量。这是因为你不能向Python字符串或数字添加新的属性，这样新的语法也不会向后不兼容。</li><li>如果所有前面的规则都匹配，那么属性被设置到基变量。如果设置失败，由于任何原因，将引发异常并使测试失败。</li></ol>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>与通常使用关键字返回值赋值变量不同，使用扩展赋值语法对变量进行的更改不限于当前作用域。因为没有创建新的变量，而是改变了现有变量的状态，所以所有看到该变量的测试和关键字也会看到这些更改。</p>    </div>  </div><h4 id="变量内的变量"><a href="#变量内的变量" class="headerlink" title="变量内的变量"></a>变量内的变量</h4><p>变量也可以在变量内部，当使用这种语法时，变量从内到外进行解析。例如，如果你有一个变量<code>$&#123;var$&#123;x&#125;&#125;</code>，那么<code>$&#123;x&#125;</code>首先被解析。如果它的值是<code>name</code>，那么最终的值就是变量<code>$&#123;varname&#125;</code>的值。可以有多个嵌套的变量，但如果它们中的任何一个不存在，解析最外层的变量就会失败。</p><p>在下面的例子中，<code>Do X</code>获取的值是<code>$&#123;JOHN HOME&#125;</code>或<code>$&#123;JANE HOME&#125;</code>，取决于<code>Get Name</code>返回的是<code>john</code>还是<code>jane</code>。如果它返回其他的东西，解析<code>$&#123;$&#123;name&#125; HOME&#125;</code>就会失败。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Variables ***</span><br><span class="line">$&#123;JOHN HOME&#125;    /home/john</span><br><span class="line">$&#123;JANE HOME&#125;    /home/jane</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">Example</span><br><span class="line">    $&#123;name&#125; =    Get Name</span><br><span class="line">    Do X    $&#123;$&#123;name&#125; HOME&#125;</span><br></pre></td></tr></table></figure></div><h4 id="内联Python评估"><a href="#内联Python评估" class="headerlink" title="内联Python评估"></a>内联Python评估</h4><p>变量语法也可以用于评估Python表达式。基本语法是<code>$&#123;&#123;expression&#125;&#125;</code>，即表达式周围有双花括号。表达式可以是任何有效的Python表达式，如<code>$&#123;&#123;1 + 2&#125;&#125;</code>或<code>$&#123;&#123;['a', 'list']&#125;&#125;</code>。允许在表达式周围有空格，所以<code>$&#123;&#123; 1 + 2 &#125;&#125;</code>和<code>$&#123;&#123; ['a', 'list'] &#125;&#125;</code>也是有效的。除了使用正常的标量变量，列表变量和字典变量也分别支持<code>@&#123;&#123;expression&#125;&#125;</code>和<code>&amp;&#123;&#123;expression&#125;&#125;</code>语法。</p><p>这个相当高级的功能的主要用途是：</p><ul><li>评估涉及Robot Framework的变量的Python表达式（<code>$&#123;&#123;len('$&#123;var&#125;') > 3&#125;&#125;</code>，<code>$&#123;&#123;$var[0] if $var is not None else None&#125;&#125;</code>）。</li><li>创建不是Python基本类型的值（<code>$&#123;&#123;decimal.Decimal('0.11')&#125;&#125;</code>，<code>$&#123;&#123;datetime.date(2019, 11, 5)&#125;&#125;</code>）。</li><li>动态创建值（<code>$&#123;&#123;random.randint(0, 100)&#125;&#125;</code>，<code>$&#123;&#123;datetime.date.today()&#125;&#125;</code>）。</li><li>构造集合，特别是嵌套的集合（<code>$&#123;&#123;[1, 2, 3, 4]&#125;&#125;</code>，<code>$&#123;&#123; &#123;'id': 1, 'name': 'Example', 'children': [7, 9]&#125; &#125;&#125;</code>）。</li><li>访问Python模块中的常量和其他有用的属性（<code>$&#123;&#123;math.pi&#125;&#125;</code>，<code>$&#123;&#123;platform.system()&#125;&#125;</code>）。</li></ul><p>这与前面讨论的扩展变量语法有一些类似的功能。如上面的例子所示，这种语法更强大，因为它提供了访问Python内置函数如<code>len()</code>和模块如<code>math</code>的能力。除了能够在表达式中使用像<code>$&#123;var&#125;</code>这样的变量（它们在评估之前被替换），在评估期间还可以使用特殊的<code>$var</code>语法使用变量。整个表达式语法在评估表达式附录中有解释。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>与其创建复杂的表达式，通常最好将逻辑移动到自定义库中。这样可以简化维护，使测试数据更容易理解，也可以提高执行速度。</p>    </div>  </div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>内联Python评估语法是在Robot Framework 3.2中新增的。</p>    </div>  </div><h3 id="创建用户关键字"><a href="#创建用户关键字" class="headerlink" title="创建用户关键字"></a>创建用户关键字</h3><p>关键字部分用于通过组合现有关键字来创建新的高级关键字。这些关键字被称为用户关键字，以区别于在测试库中实现的最低级别的库关键字。创建用户关键字的语法与创建测试用例的语法非常接近，这使得学习变得容易。</p><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><p>在很多方面，用户关键字的整体语法与测试用例语法相同。用户关键字在关键字部分中创建，这与测试用例部分的区别仅在于用于标识它们的名称。用户关键字的名称与测试用例名称一样，位于第一列。此外，用户关键字也是由关键字创建的，无论是来自测试库的关键字还是其他用户关键字。关键字名称通常在第二列，但是在从关键字返回值设置变量时，它们在后续列中。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">Open Login Page</span><br><span class="line">    Open Browser    http://host/login.html</span><br><span class="line">    Title Should Be    Login Page</span><br><span class="line"></span><br><span class="line">Title Should Start With</span><br><span class="line">    [Arguments]    $&#123;expected&#125;</span><br><span class="line">    $&#123;title&#125; =    Get Title</span><br><span class="line">    Should Start With    $&#123;title&#125;    $&#123;expected&#125;</span><br></pre></td></tr></table></figure></div><p>大多数用户关键字需要一些参数。这个重要的特性已经在上面的第二个例子中使用了，它在本节后面详细解释，与用户关键字返回值类似。</p><p>用户关键字可以在套件文件、资源文件和套件初始化文件中创建。在资源文件中创建的关键字对使用它们的文件可用，而其他关键字只在创建它们的文件中可用。</p><h4 id="关键字部分中的设置"><a href="#关键字部分中的设置" class="headerlink" title="关键字部分中的设置"></a>关键字部分中的设置</h4><p>用户关键字可以有与测试用例类似的设置，它们有相同的方括号语法将它们与关键字名称分开。所有可用的设置都列在下面，并在本节后面解释。</p><ul><li>[Documentation] 用于设置用户关键字文档。</li><li>[Tags] 为关键字设置标签。</li><li>[Arguments] 指定用户关键字参数。</li><li>[Setup], [Teardown] 指定用户关键字的设置和拆卸。[Setup]是在Robot Framework 7.0中新增的。</li><li>[Timeout] 设置可能的用户关键字超时。超时在自己的部分中讨论。</li><li>[Return] 指定用户关键字返回值。在Robot Framework 7.0中已弃用，应使用RETURN语句。</li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>上面使用的格式是推荐的，但设置名称不区分大小写，方括号和名称之间允许有空格。例如，[ TAGS ]:setting是有效的。</p>    </div>  </div><h3 id="用户关键字的名称和文档"><a href="#用户关键字的名称和文档" class="headerlink" title="用户关键字的名称和文档"></a>用户关键字的名称和文档</h3><p>用户关键字的名称在关键字部分的第一列中定义。当然，名称应该是描述性的，接受有相当长的关键字名称。实际上，当创建用例样式的测试用例时，最高级别的关键字通常被构造为句子甚至段落。</p><p>用户关键字可以有一个文档，通过[Documentation]设置进行设置。它支持与测试用例文档相同的格式，分割到多行，以及其他特性。这个设置在测试数据中记录了用户关键字。它也显示在更正式的关键字文档中，Libdoc工具可以从资源文件中创建这个文档。最后，文档的第一行逻辑行，直到第一个空行，显示为测试日志中的关键字文档。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*** Keywords ***</span><br><span class="line">One line documentation</span><br><span class="line">    [Documentation]    One line documentation.</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Multiline documentation</span><br><span class="line">    [Documentation]    The first line creates the short doc.</span><br><span class="line">    ...</span><br><span class="line">    ...                This is the body of the documentation.</span><br><span class="line">    ...                It is not shown in Libdoc outputs but only</span><br><span class="line">    ...                the short doc is shown in logs.</span><br><span class="line">    No Operation</span><br><span class="line"></span><br><span class="line">Short documentation in multiple lines</span><br><span class="line">    [Documentation]    If the short doc gets longer, it can span</span><br><span class="line">    ...                multiple physical lines.</span><br><span class="line">    ...</span><br><span class="line">    ...                The body is separated from the short doc with</span><br><span class="line">    ...                an empty line.</span><br><span class="line">    No Operation</span><br></pre></td></tr></table></figure></div><p>有时候，关键字需要被移除，替换为新的，或者由于其他原因被弃用。用户关键字可以通过在文档开始处标记<em>DEPRECATED</em>来标记为弃用，这将在使用关键字时引发警告。有关更多信息，请参见弃用关键字部分。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在Robot Framework 3.1之前，简短的文档只包含关键字文档的第一行物理行。</p>    </div>  </div>]]></content>
    
    
    <summary type="html">Robot Framewor教程</summary>
    
    
    
    <category term="RPA" scheme="https://www.yiuhangblog.com/categories/RPA/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>TagUI教程</title>
    <link href="https://www.yiuhangblog.com/2024/04/18/20240418TagUI%E6%95%99%E7%A8%8B/"/>
    <id>https://www.yiuhangblog.com/2024/04/18/20240418TagUI%E6%95%99%E7%A8%8B/</id>
    <published>2024-04-18T03:39:15.000Z</published>
    <updated>2024-04-19T02:52:06.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源网址"><a href="#资源网址" class="headerlink" title="资源网址"></a>资源网址</h2><p>GitHub开源地址：<a class="link"   href="https://github.com/aisingapore/TagUI" >https://github.com/aisingapore/TagUI <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>中文技术文档：<a class="link"   href="http://www.tagui.com.cn/setup.html" >http://www.tagui.com.cn/setup.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>原技术文档：<a class="link"   href="https://tagui.readthedocs.io/en/latest/index.html" >https://tagui.readthedocs.io/en/latest/index.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h4><p>各类TagUI安装&#x2F;插件&#x2F;资源 国内下载，请访问：</p><p>链接：<a class="link"   href="https://pan.baidu.com/s/1GrkOxmu9fTBpwzO1JzaNUw?pwd=tagu" >https://pan.baidu.com/s/1GrkOxmu9fTBpwzO1JzaNUw?pwd=tagu <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p><p>各类TagUI安装&#x2F;插件&#x2F;资源 原下载，请访问：</p><p>TagUI v6.110 zip 文件: <a class="link"   href="https://github.com/kelaberetiv/TagUI/releases/download/v6.110.0/TagUI_Windows.zip" >https://github.com/kelaberetiv/TagUI/releases/download/v6.110.0/TagUI_Windows.zip <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li>[MS Word 插件安装程序](<a class="link"   href="https://storage.googleapis.com/tagui-dependencies/TagUI" >https://storage.googleapis.com/tagui-dependencies/TagUI <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> WordAddIn&#x2F;TagUIWordAddInSetupV3.18.zip)（一个使 RPA 变得非常简单的全功能应用程序）</li><li><a class="link"   href="https://www.youtube.com/watch?v=mtiuzU6e4XE" >RPA 学习者提供的 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>有关安装和运行第一个 MS Word RPA 机器人的视频。</li><li><a class="link"   href="https://github.com/kelaberetiv/TagUI/releases/download/v6.64.0/TagUIExcelAddInSetupv3.06.zip" >MS Excel 插件安装程序 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> (Excel 中定义 RPA 数据参数并从 Excel 运行 TagUI)</li><li><a class="link"   href="https://www.youtube.com/watch?v=YsA9hpveROs" >RPA 学习者提供的 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>有关使用 Excel 插件安装和创建可视化的视频。</li></ul><h4 id="简易自动安装方式-不建议"><a href="#简易自动安装方式-不建议" class="headerlink" title="简易自动安装方式 (不建议)"></a>简易自动安装方式 (不建议)</h4><p><a class="link"   href="https://github.com/kelaberetiv/TagUI/releases/download/v6.46.0/TagUI_Windows.exe" >TagUI v6.46 Windows 安装包 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，下载安装即可。</p><h4 id="手动配置安装方式"><a href="#手动配置安装方式" class="headerlink" title="手动配置安装方式"></a>手动配置安装方式</h4><ol><li>下载 TugUI zip 压缩包，下载点击： <a class="link"   href="https://github.com/kelaberetiv/TagUI/archive/master.zip" >TagUI v6.109 for Windows <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>解压到硬盘，例如： <code>D:\</code>，不建议解压在文件夹内</li><li>安装 OpenJDK for Windows（已经安装可跳过）</li><li>安装 Python （已经安装可跳过）</li><li>安装 Chrome 浏览器（已经安装可跳过）</li><li>安装 Microsoft Visual C++ Redistributable 2012 X86 版本（已经安装可跳过）</li><li>环境变量Path增加TagUI路径，注意需要<code>scr</code>目录，不是根目录，例如： <code>D:\tagui\src</code></li><li>按 <strong>Win + R</strong>，输入<code>cmd</code>，进入CMD命令行模式。</li><li>复制下面这行命令，粘贴到CMD运行展示样例：（路径改为安装的实际路径）</li></ol><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui D:\tagui\flows\samples\8_chineseflow.tag</span><br></pre></td></tr></table></figure></div><h4 id="系统编码设置"><a href="#系统编码设置" class="headerlink" title="系统编码设置"></a>系统编码设置</h4><p>中文Windows系统的CMD默认编码是GBK，流程执行中的中文会显示乱码，改成UTF-8编码:</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d374c9e6-4a53-4e5d-d6ae-406ac41dee00/public"                      width = "600"                ><ol><li>首先，<strong>管理员身份</strong>打开命令提示符窗口。在窗口顶部右击选择属性，选中选项后会看到默认编码为GBK。（OEM一样乱码）</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/00378a81-5b77-4315-c312-b074a32f4b00/public"                      width = "600"                ><ol start="2"><li><strong>Win + R</strong> 打开运行窗口后输入<code>regedit</code>，点击确定按钮，打开注册表窗口，按照图中的路径打开<code>command processor</code>项</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fd2c1247-9365-4d4c-734a-ada5ca4b6700/public"                      width = "600"                ><ol start="3"><li>右键新建字符串值，设置完名称后右击打开窗口后输入数值数据<code>chcp 65001</code>，点击确定保存，即可完成设置了</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4109df34-da60-49eb-1acc-db8dde905d00/public"                      width = "600"                ><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>TagUI通过运行 <strong>流程文件</strong> <code>flows</code> 自动执行操作，流程文件扩展名是 <code>.tag</code>。</p><p>可以在CMD命令提示符&#x2F;终端中运行流程： <strong>命令使用</strong>格式：</p><p>当前目录：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui my_flow.tag</span><br></pre></td></tr></table></figure></div><p>绝对路径：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui c:\tagui\samples\1_google.tag</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a53676d2-d7bb-4132-77a7-2562e9f35000/public"                      width = "600"                ><p>也可以设定按固定计划运行流程，按固定计划自动运行流程通常很有用：每月、每周、每天甚至每 5 分钟一次。例如在 Windows 上，使用任务计划程序：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/58ca9007-0872-4669-e310-d3316c655500/public"                      width = "600"                ><h3 id="快捷执行"><a href="#快捷执行" class="headerlink" title="快捷执行"></a>快捷执行</h3><p>可以使用以下命令创建快捷方式文件 <code>-deploy</code>：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui my_flow.tag -deploy</span><br></pre></td></tr></table></figure></div><p>或者使缩写方式 <code>-d</code>：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui my_flow.tag -d</span><br></pre></td></tr></table></figure></div><p>这将创建一个快捷方式 (my_flow.cmd)，只需双击快捷方式即可运行流程。该快捷方式与流程位于同一文件夹中，但可以将其移动到桌面或其他任何位置。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ff6d3171-0012-49e1-d65c-9d42b775e300/public"                      width = "600"                ><p>如果想增加更多参数，例如 <code>-headless</code> (<code>-h</code>)，可以这样写命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui my_flow.tag -h -d</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>原.tag文件路径被移动，相关的.cmd快捷文件会失效。</p>    </div>  </div><h3 id="运行云端-tag"><a href="#运行云端-tag" class="headerlink" title="运行云端.tag"></a>运行云端.tag</h3><p>可以把<code>.tag</code>文件放在服务器，并用下面命令运行：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui https://raw.githubusercontent.com/kelaberetiv/TagUI/master/flows/samples/1_google.tag</span><br></pre></td></tr></table></figure></div><h3 id="隐藏浏览器运行"><a href="#隐藏浏览器运行" class="headerlink" title="隐藏浏览器运行"></a>隐藏浏览器运行</h3><p>可以不显示Web浏览器来运行Web流程，使用 <code>-headless</code> 参数</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui my_flow.tag -headless</span><br></pre></td></tr></table></figure></div><p>或使用快捷方式<code>-h</code>：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui my_flow.tag -h</span><br></pre></td></tr></table></figure></div><p>这允许在流程运行时正常使用电脑，但如果流程中使用可视自动化（例如OCR、图像识别等），则无法正常运行，因为流程需要读取并单击屏幕上的内容</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7333175d-893d-4eeb-a593-93f4cea6d600/public"                      width = "600"                ><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>自动化RPA流程是由基础命令组成的，以下是一些常见命令。</p><h3 id="click-鼠标左键单击"><a href="#click-鼠标左键单击" class="headerlink" title="click 鼠标左键单击"></a>click 鼠标左键单击</h3><p>点击命令，可以使用它来单击Web元素：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click Getting started</span><br></pre></td></tr></table></figure></div><p>此命令单击WEB元素，点击定位可以用“ID”，“name”，“class”或“title”属性，这里有个使用 <a href="https://www.yiuhangblog.com/2021/02/23/20210223%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7/">XPath</a>的例子：</p><p>XPath是一种强大的定位元素方式，例如：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click //a[@class=<span class="string">&quot;icon icon-home&quot;</span>]</span><br></pre></td></tr></table></figure></div><p>还可以单击屏幕上的某个坐标点：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click (500,300)</span><br></pre></td></tr></table></figure></div><p>命令里的500和300是X-Y坐标。此命令点击距离屏幕左侧为500像素，距离屏幕顶部300像素的位置。可以在TagUI Live模式下使用 <code>mouse_xy()</code> 辅助函数寻找XY坐标点，当然更推荐使用一些小工具更方便的知道XY坐标。</p><p><code>click</code>还可以使用图像识别(Visual Automation)单击先前保存的图像所匹配的位置。下面这条命令会在屏幕范围寻找类似 button.png 的位置，然后单击它。注意：TagUI只识别桌面区域，浏览器区域不一定识别。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click button.png</span><br></pre></td></tr></table></figure></div><p>当然，好的编程习惯，是把图片都放在 <code>image</code> 目录下：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click image/button.png</span><br></pre></td></tr></table></figure></div><h3 id="WEB访问"><a href="#WEB访问" class="headerlink" title="WEB访问"></a>WEB访问</h3><p>直接输入网址，TagUI就会在Chrome里打开：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://somewebsite.com</span><br></pre></td></tr></table></figure></div><h3 id="type-文本输入"><a href="#type-文本输入" class="headerlink" title="type 文本输入"></a>type 文本输入</h3><p>可以在网络输入中输入内容。此命令以与<strong>单击</strong>步骤相同的方式查找元素<code>some-input</code>（元素定位），并在其中键入<code>some-text</code>（文本内容）：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> some-input as some-text</span><br></pre></td></tr></table></figure></div><p>可以用 <code>[clear]</code> 来清除元素文本，用 <code>[enter]</code> 来按回车：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> some-input as [clear]some-text[enter]</span><br></pre></td></tr></table></figure></div><p>也可以用图片进行输入定位, 类似 <code>click</code> 一样：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> some-input.png as some-text</span><br></pre></td></tr></table></figure></div><h3 id="read-读取元素，可读取文本-或某些属性值"><a href="#read-读取元素，可读取文本-或某些属性值" class="headerlink" title="read 读取元素，可读取文本 或某些属性值"></a>read 读取元素，可读取文本 或某些属性值</h3><p>用 <strong>read</strong> 命令读取元素的文本，并且赋值给变量。</p><p>下面命令里的 <code>some-element </code>是元素， <code>some-variable</code> 是变量：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read some-element to some-variable</span><br></pre></td></tr></table></figure></div><p><strong>read</strong> 还可以使用Visual Automation和OCR功能从屏幕区域读取文本。依赖于OCR的读取可能不完全准确。</p><p>此命令读取在点（300,400）和（500,550）之间形成的矩形中的所有文本：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read (300,400)-(500,550) to some-variable</span><br></pre></td></tr></table></figure></div><p>还可以使用XPath读取Web元素的某些属性值。此命令从元素中读取ID属性：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read //some-element/@some-attribute to some-variable</span><br></pre></td></tr></table></figure></div><h3 id="assign-赋值"><a href="#assign-赋值" class="headerlink" title="assign 赋值"></a>assign 赋值</h3><p>对变量进行赋值：</p><p>此示例使用<code>count()</code> 辅助函数，计算在 id&#x2F;name&#x2F;text 中找到的包含“row”的元素数量，并将其分配给一个变量<code>row_count</code>以供以后使用：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row_count = count(<span class="string">&#x27;row&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><p>DOM 和 XPath 标识符仅适用于 Chrome&#x2F;Edge。要自动化其他浏览器，请使用点&#x2F;区域和图像标识符。</p><h3 id="DOM-元素属性定位"><a href="#DOM-元素属性定位" class="headerlink" title="DOM 元素属性定位"></a>DOM 元素属性定位</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click Getting started</span><br></pre></td></tr></table></figure></div><p>DOM (Document Object Model) 方式用元素属性进行定位匹配，可以用 id, name, class attributes 或元素本身的文本内容定位元素。注意：这种方式可能因为同名造成定位不准确。</p><h3 id="XPath-页面路径定位"><a href="#XPath-页面路径定位" class="headerlink" title="XPath 页面路径定位"></a>XPath 页面路径定位</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click //body/div[1]/nav/div/div[1]/a</span><br></pre></td></tr></table></figure></div><p><a class="link"   href="http://www.tagui.com.cn/faq.html#find-xpath" >XPath <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（XML Path Language）用树状结构来定位元素，表达方式可以理解成“某小区66号楼601室书房里桌子左边的第一个抽屉”。</p><p>这是针对 Web 元素的最准确的定位方式，推荐使用 XPath 进行元素定位描述。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>可以使用 CSS selectors 代替XPath，但XPath是首选。</p>    </div>  </div><h3 id="Point-坐标点定位"><a href="#Point-坐标点定位" class="headerlink" title="Point 坐标点定位"></a>Point 坐标点定位</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click (200,500)</span><br></pre></td></tr></table></figure></div><p>坐标原点是在屏幕左上角，横向称为X坐标，竖向称为Y坐标，Y坐标100表示从上往下100个像素的位置。本条命令会到距离屏幕左侧200像素，距离屏幕顶部500像素的位置 进行点击。</p><h3 id="Region-屏幕区域定位"><a href="#Region-屏幕区域定位" class="headerlink" title="Region 屏幕区域定位"></a>Region 屏幕区域定位</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> (300,400)-(500,550) to some-variable</span><br></pre></td></tr></table></figure></div><p>这与两点（300,400）和（500,550）之间形成的矩形匹配坐标点。</p><h3 id="Image-图像定位"><a href="#Image-图像定位" class="headerlink" title="Image 图像定位"></a>Image 图像定位</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click button.png</span><br></pre></td></tr></table></figure></div><p>在全屏范围寻找类似图像文件 <code>button.png</code> 的位置进行点击。首先需要截图保存为 &#96;button.png。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click image/button.png</span><br></pre></td></tr></table></figure></div><p>可以使用图片的绝对路径，同时好的编程习惯，是把图片都放到 <code>image</code> 目录下。并且使用容易理解的文件名，例如：<code>button.png</code>。</p><h2 id="Live-mode-用于调试的Live模式"><a href="#Live-mode-用于调试的Live模式" class="headerlink" title="Live mode 用于调试的Live模式"></a>Live mode 用于调试的Live模式</h2><p>在流程开发中，经常需要测试下一步的操作代码，建议使用Live Mode。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui live</span><br></pre></td></tr></table></figure></div><p>启动 Live 模式后，可以输入一行才执行一行，这样调试起来很方便。下面这张图展示了这个操作。进入 Live Mode 时，TagUI 会自动打开Chrome。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/070ba1ce-0e84-4c34-e1e2-4d03c36dbd00/public"                      width = "600"                ><h2 id="If-条件语句"><a href="#If-条件语句" class="headerlink" title="If 条件语句"></a>If 条件语句</h2><p>if 就是“如果”怎样就怎样 的条件逻辑语言，例如：如果出现“登录按钮”就进行点击。</p><p>代码举例： 如果 URL网址包含 “success”, 就点击 buttons1 和 buttons2</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> url() contains <span class="string">&quot;success&quot;</span></span><br><span class="line">  click button1.png</span><br><span class="line">  click button2.png</span><br></pre></td></tr></table></figure></div><p><code>url()</code> 是一个辅助函数，用于获取当前网页的网址URL。注意，需要 <code>if</code> 执行的命令，需要在前面缩进空格（或Tab），这表示它们在<code>if</code>块 中。如果满足条件，就执行<code>if</code>块 中的命令。</p><p>另一个常见的情况是判断某元素是否存在。在这里，“如果在等待超时后未出现某些元素，则访问此网页”。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !exist(<span class="string">&#x27;some-element&#x27;</span>)</span><br><span class="line">  https://tagui.readthedocs.io/</span><br></pre></td></tr></table></figure></div><p>这 <code>!</code>否定条件来自 JavaScript，TagUI 代码最终会翻译成 JavaScript。</p><p>在下面的示例中，检查变量row_count，是否等于5：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> row_count equals to 5</span><br><span class="line">  some steps</span><br></pre></td></tr></table></figure></div><p>以下是 大于more than 和 小于 less than 的命令方式：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> row_count more than 5</span><br><span class="line">  some steps</span><br><span class="line"><span class="keyword">if</span> row_count less than 5</span><br><span class="line">  some steps</span><br></pre></td></tr></table></figure></div><h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h2><p>可以在同一流程中使用循环执行多次同样的流程。为了使用不同变量多次运行一个流程，标准方式是使用 DataTables (高级命令).</p><p>在此示例中，我们重复块内的流程总共20次：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n from 1 to 20</span><br><span class="line">  some step to take</span><br><span class="line">  some other step</span><br><span class="line">  some more step</span><br></pre></td></tr></table></figure></div><h2 id="functions-函数"><a href="#functions-函数" class="headerlink" title="functions 函数"></a>functions 函数</h2><p>函数功能是调用 JavaScript 函数，并且返回需要的值。</p><p>每个函数后跟小括号 <code>()</code>，小括号内可以填写函数的参数。</p><h3 id="csv-row"><a href="#csv-row" class="headerlink" title="csv_row()"></a>csv_row()</h3><p>将一些变量转换为CSV文本以写入CSV文件。它将变量作为参数输入，包含在方括号内 <code>[]</code> (实际上是一个数组 array).</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> name_element to name</span><br><span class="line"><span class="built_in">read</span> price_element to price</span><br><span class="line"><span class="built_in">read</span> details_element to details</span><br><span class="line">write `csv_row([name, price, details])` to product_list.csv</span><br></pre></td></tr></table></figure></div><h3 id="clipboard-剪贴板"><a href="#clipboard-剪贴板" class="headerlink" title="clipboard() 剪贴板"></a>clipboard() 剪贴板</h3><p>从剪贴板读取文本：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dclick pdf_document.png</span><br><span class="line"><span class="built_in">wait</span> 3 seconds</span><br><span class="line">keyboard [ctrl]a</span><br><span class="line">keyboard [ctrl]c</span><br><span class="line">text_contents = clipboard()</span><br></pre></td></tr></table></figure></div><p>对于大量文本内容输入，建议将文本先放到剪贴板，在用 Ctrl+V 粘贴，这比用 <strong>type</strong> 快很多：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long_text = <span class="string">&quot;This is a very long text which takes a long time to type&quot;</span></span><br><span class="line">clipboard(long_text)</span><br><span class="line">click text_input</span><br><span class="line">keyboard [ctrl]v</span><br><span class="line">keyboard [enter]</span><br></pre></td></tr></table></figure></div><h3 id="mouse-x-mouse-y-获得坐标点当前位置"><a href="#mouse-x-mouse-y-获得坐标点当前位置" class="headerlink" title="mouse_x(), mouse_y() 获得坐标点当前位置"></a>mouse_x(), mouse_y() 获得坐标点当前位置</h3><p>获取鼠标的x或y坐标。</p><p>在偏移点击目标时，需要先获得 x 或 y 坐标，以下代码示例表示，鼠标先移动到 <code>element.png</code> ，再获得偏移的 x 和 y ，然后单击元素右侧的200像素：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hover element.png</span><br><span class="line">x = mouse_x() + 200</span><br><span class="line">y = mouse_y()</span><br><span class="line">click (`x`,`y`)</span><br></pre></td></tr></table></figure></div><h3 id="mouse-xy"><a href="#mouse-xy" class="headerlink" title="mouse_xy()"></a>mouse_xy()</h3><p>在Live模式下，可以使用 <strong>echo `mouse_xy()&#96;</strong>  找到鼠标的坐标。</p><p>注意，这里用的不是单引号</p><p><strong>‘</strong></p><p>而是键盘数字1左边按键的 </p><p><strong>&#96;</strong></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `mouse_xy()`</span><br></pre></td></tr></table></figure></div><h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h2><h3 id="保存流程运行结果"><a href="#保存流程运行结果" class="headerlink" title="保存流程运行结果"></a>保存流程运行结果</h3><p><code>tagui/src/tagui_report.csv</code> 可以使用<code>-report</code>选项（快捷方式）保存运行的 html 日志和流程运行结果<code>-r</code>。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui my_flow.tag -report</span><br></pre></td></tr></table></figure></div><p>CSV 文件将显示每次运行的一行、开始时间、完成时间、运行期间的任何错误消息、该运行日志文件的链接以及用户的工作组\用户 ID。</p><h3 id="处理异常和错误"><a href="#处理异常和错误" class="headerlink" title="处理异常和错误"></a>处理异常和错误</h3><p>当流程没按预期进行时，有3种方法可以在Tagui中处理。</p><p>第一种方式是针对<strong>单条指令错误处理</strong>，可以增加 if 判断来预防。例如，检查是否缺少某些UI元素，然后执行XYZ步骤。使用这种方式。</p><p>第二种方式是对针对<strong>某个流程的错误处理</strong>。类似下面的语法，当 Flow.tag 成功运行时才运行。当它检测到丢失（缺少截图文件）或其他一些未知错误时，Tagui将自动抛出错误。</p><p>Windows 代码例子：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call tagui flow.tag || tagui error.tag</span><br><span class="line">call tagui flow.tag &amp;&amp; tagui success.tag</span><br></pre></td></tr></table></figure></div><p>第三种方式是<strong>全局错误处理</strong>。可以对 TagUI 进行配置，以便在每次运行后，进行特殊处理，将报告选项生成的数据或文件发送到某个目标文件夹或 API 端点，以进行错误&#x2F;成功处理。例如，将所有自动化运行同步到中央存储以进行审计。特殊处理适用于所有运行的 TagUI 流。</p><h3 id="DataTables数据表格批量自动化"><a href="#DataTables数据表格批量自动化" class="headerlink" title="DataTables数据表格批量自动化"></a>DataTables数据表格批量自动化</h3><p>DataTables是 csv 文件，可以把数据表格作为变化，多次循环运行流程。</p><p>Datatable数据文件 (<code>trade_data.csv</code>) 类似下面格式:</p><table><thead><tr><th>#</th><th>trade</th><th>username</th><th>password</th><th>pair</th><th>size</th><th>direction</th></tr></thead><tbody><tr><td>1</td><td>Trade USDSGD</td><td>test_account</td><td>12345678</td><td>USDSGD</td><td>10000</td><td>BUY</td></tr><tr><td>2</td><td>Trade USDSGD</td><td>test_account</td><td>12345678</td><td>USDJPY</td><td>1000</td><td>SELL</td></tr><tr><td>3</td><td>Trade EURUSD</td><td>test_account</td><td>12345678</td><td>EURUSD</td><td>100000</td><td>BUY</td></tr></tbody></table><p>要使用它，可以使用 运行流程。 TagUI 将为数据表中的每一行运行一次（标题除外）。<code>tagui my_flow.tag trade_data.csv``my_flow.tag</code></p><p>在流程中，TagUI 可以使用变量<code>trade</code>、<code>username</code>、<code>password</code>等，就好像它们位于本地对象存储库中一样，并且值将来自该运行的行。</p><p>要知道的流程处于哪个迭代中，可以使用该<code>iteration</code>变量：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> current iteration: `iteration`</span><br><span class="line"><span class="keyword">if</span> iteration equals to 1</span><br><span class="line">  // go to login URL and <span class="keyword">do</span> the login steps</span><br><span class="line">  www.xero.com</span><br><span class="line"></span><br><span class="line">// <span class="keyword">do</span> rest of the steps <span class="keyword">for</span> every iteration</span><br></pre></td></tr></table></figure></div><h3 id="可重用性的对象存储库"><a href="#可重用性的对象存储库" class="headerlink" title="可重用性的对象存储库"></a>可重用性的对象存储库</h3><p>对象存储库是可选的csv 文件，可以存储在流中使用的变量。它们有助于将流与个人数据（例如 Web 流的登录信息）分开，并允许在多个流之间共享通用信息以便于更新。</p><p>每个流都有一个<strong>本地对象存储库</strong>，所有流共享<strong>全局对象存储库</strong>。本地对象存储库<code>tagui_local.csv</code>与流位于同一文件夹中。全局对象存储库位于<code>tagui_global.csv</code>该<code>tagui/src/</code>文件夹中。</p><p>对象存储库可能如下所示：</p><table><thead><tr><th>object</th><th>definition</th></tr></thead><tbody><tr><td>email</td><td>user-email-textbox</td></tr><tr><td>create account</td><td>btn btn–green btn-xl signup-btn</td></tr></tbody></table><p>在流程中，TagUI 可以使用对象<code>email</code>,作为变量，并且在运行之前它们将直接被定义替换。局部定义优先于全局定义。<code>create account</code></p><p>如果<code>user-email-textbox</code>是某些 Web 文本输入的标识符，那么可以在流程中使用以下内容：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> `email` as my_email@email.com</span><br></pre></td></tr></table></figure></div><h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>可以通过将大型工作流程文件分解为许多子流程文件来模块化 RPA 工作流程。对于更复杂的 RPA 场景，甚至可以让一个子流程运行其他子流程。</p><p>这样做的一些常见原因包括方便在其他流程中重用相同的子流程、通过在子流程中保留步骤顺序来执行更容易组织的特定操作，或者将 Python 或 JavaScript 代码和函数存储在单独的子流程中（使用例如 <code>py begin</code> 和 <code>py finish</code> 代码块）。</p><p>在一个流程内调用另一个流程，命令如下：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui login_crm.tag</span><br></pre></td></tr></table></figure></div><p>被调用流程也可以存储在子文件夹中：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Windows example</span><br><span class="line">tagui CRM\login.tag</span><br><span class="line"></span><br><span class="line">// Mac/Linux example</span><br><span class="line">tagui CRM/login.tag</span><br></pre></td></tr></table></figure></div><p>变量可以在父流程和子流程之间使用：（可以理解成变量是全局的）</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// username 和 password 变量可以被使用在 login.tag</span><br><span class="line">username = <span class="string">&#x27;jennifer&#x27;</span>; password = <span class="string">&#x27;12345678&#x27;</span>;</span><br><span class="line">tagui login.tag</span><br><span class="line"></span><br><span class="line">// 也可以把变量分行来写，这样更清晰</span><br><span class="line">username = <span class="string">&#x27;jennifer&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;12345678&#x27;</span></span><br><span class="line">tagui login.tag</span><br><span class="line"></span><br><span class="line">// 在子流程 login.tag 里，也可以定义和返回变量，给父流程使用</span><br><span class="line"><span class="built_in">echo</span> `login_result`</span><br></pre></td></tr></table></figure></div><p>可以在父子流中赋值变量 <code>action = &#39;login&#39;</code>，配合 <code>if</code> 来控制具体执行哪个子流程：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// crm_steps.tag</span><br><span class="line"><span class="keyword">if</span> action equals to <span class="string">&#x27;login&#x27;</span></span><br><span class="line">  <span class="keyword">do</span> some steps</span><br><span class="line">  <span class="keyword">do</span> some more steps</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> action equals to <span class="string">&#x27;report&#x27;</span></span><br><span class="line">  <span class="keyword">do</span> some steps</span><br><span class="line">  <span class="keyword">do</span> some more steps</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> action equals to <span class="string">&#x27;logout&#x27;</span></span><br><span class="line">  <span class="keyword">do</span> some steps</span><br><span class="line">  <span class="keyword">do</span> some more steps</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> ERROR - action undefined</span><br></pre></td></tr></table></figure></div><h3 id="Turbo-mode-极速模式，10倍速运行"><a href="#Turbo-mode-极速模式，10倍速运行" class="headerlink" title="Turbo mode 极速模式，10倍速运行"></a>Turbo mode 极速模式，10倍速运行</h3><p>运行流产时，可使用 turbo 参数开启极速模式（谨慎使用）：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tagui flow.tag -turbo</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">tagui flow.tag -t</span><br></pre></td></tr></table></figure></div><p>大多数网站和桌面应用程序都无法适应TagUI的极速模式。如果RPA以超出这些网站的速度运行，经常会报错。报错的点可能是字段和数据未正确填写，表单缺少数据等。</p><p>极速模式下问题可能会随机发生，包括在PC上工作，但由于CPU速度的差异而无法在另一台PC上工作。因此，不建议使用Turbo极速模式。实际应用中，如果用极速模式造成某些数据错误，可能最终需要花费更多时间来排除或修复错误造成的后果。</p><p>但是，极速模式对某些特定场景的某些用户非常有用。例如，从应用程序中获取数据，超越人类速度的Web端数据输入等。</p><h3 id="视觉自动化-OCR"><a href="#视觉自动化-OCR" class="headerlink" title="视觉自动化 OCR"></a>视觉自动化 OCR</h3><p>对于许多步骤，可以使用或来结束步骤，告诉 TagUI 使用 OCR（光学字符识别）与屏幕上的某些 UI 元素进行交互。请参阅下面的示例。可以执行此操作的步骤：单击、rclick、dclick、悬停、键入、选择、读取、捕捉、exist()、present()。<code>using ocr``using OCR</code></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">click Submit using ocr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&#x27;Special Offer using ocr&#x27;</span>)</span><br><span class="line">  click Add To Cart using OCR</span><br><span class="line"></span><br><span class="line">// various usage combinations <span class="keyword">for</span> <span class="keyword">select</span> step</span><br><span class="line"><span class="keyword">select</span> Dress Color using OCR as Dark Blue using OCR</span><br><span class="line"><span class="keyword">select</span> dress_color.png as Bright Pink using ocr</span><br><span class="line"><span class="keyword">select</span> Dress Color using OCR as dark_black.png</span><br><span class="line"><span class="keyword">select</span> dress_color.png as bright_white.png</span><br></pre></td></tr></table></figure></div><p>如果使用图像编辑器将文件中 UI 元素的背景设置为<code>.png</code>100% 透明，则 TagUI 将能够定位该元素，无论其背景如何。</p><p>相反，还可以删除某些锚元素（例如框架）附近的前景内容，以便可以使用<strong>读取</strong>步骤对空白区域中的不同内容进行 OCR。</p><h3 id="在流程中编写Python"><a href="#在流程中编写Python" class="headerlink" title="在流程中编写Python"></a>在流程中编写Python</h3><p>可以在 TagUI 流程中编写 Python 代码。Python 开发环境需要单独安装。</p><p>使用 <code>py</code> 命令告诉 TagUI 调用 <code>python</code> 运行python命令。可以将字符串值传递回 TagUI 然后在Python里 print()。 Python 运行结果将存放到 TagUI 变量 <code>py_result</code> 里。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">py a=1</span><br><span class="line">py b=2</span><br><span class="line">py c=a+b</span><br><span class="line">py <span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">echo</span> `py_result`</span><br></pre></td></tr></table></figure></div><p>也可以使用 <code>py begin</code> 和 <code>py finish</code> 来告诉 TagUI 这部分是 Python 语言：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">py begin</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=a+b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">py finish</span><br><span class="line"><span class="built_in">echo</span> `py_result`</span><br></pre></td></tr></table></figure></div><p>可以这样将变量传递给Python：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phone = 1234567</span><br><span class="line">py_step(<span class="string">&#x27;phone = &#x27;</span> + phone)</span><br><span class="line">py <span class="built_in">print</span>(phone)</span><br><span class="line"><span class="built_in">echo</span> `py_result`</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;Donald&#x27;</span></span><br><span class="line">py_step(<span class="string">&#x27;name = &quot;&#x27;</span> + name + <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">py <span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">echo</span> `py_result`</span><br></pre></td></tr></table></figure></div><p>要传递并返回更复杂的数据，例如多个变量，可以使用 JavaScript 和 Python JSON 库来发送和接收 JSON 字符串。传递2个变量，执行一些处理，并返回2个变量：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = &#123;<span class="string">&quot;a&quot;</span>:a, <span class="string">&quot;b&quot;</span>:b&#125;</span><br><span class="line">json_c = JSON.stringify(c)</span><br><span class="line">echo `json_c`</span><br><span class="line">py_step(<span class="string">&quot;json_c = &#x27;&quot;</span> + json_c + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">py begin</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">c = json.loads(json_c)</span><br><span class="line">d = c[<span class="string">&quot;a&quot;</span>] * <span class="number">10</span></span><br><span class="line">e = c[<span class="string">&quot;b&quot;</span>] * <span class="number">10</span></span><br><span class="line">f = &#123;<span class="string">&quot;d&quot;</span>:d, <span class="string">&quot;e&quot;</span>:e&#125;</span><br><span class="line">json_f = json.dumps(f)</span><br><span class="line"><span class="built_in">print</span>(json_f)</span><br><span class="line">py finish</span><br><span class="line"></span><br><span class="line">echo `py_result`</span><br><span class="line">f = JSON.parse(py_result)</span><br><span class="line">echo `f.d`</span><br><span class="line">echo `f.e`</span><br></pre></td></tr></table></figure></div><p>上面将 2 个变量从 TagUI 传递到 Python，进行修改，返回 2 个变量，并显示下面的 <code>e</code> 和 <code>f</code> ：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure></div><h3 id="创建运行Log日志便于调试"><a href="#创建运行Log日志便于调试" class="headerlink" title="创建运行Log日志便于调试"></a>创建运行Log日志便于调试</h3><p>要执行高级调试，可以通过在 <code>tagui/src/</code>中创建一个空的<code>tagui_logging</code>文件，在运行流程时记录运行日志。</p><ul><li><code>my_flow.log</code> 存储一步步的执行记录。</li><li><code>my_flow.js</code> 是已运行的生成的JavaScript文件。</li><li><code>my_flow.raw</code> is the expanded flow after parsing modules.</li></ul><h3 id="运行云端-TagUI"><a href="#运行云端-TagUI" class="headerlink" title="运行云端 TagUI"></a>运行云端 TagUI</h3><p>可以使用 <a class="link"   href="https://github.com/kelaberetiv/TagUI/issues/913" >免费 Google 服务器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>运行Web浏览器或手机上的 Tagui。可以在浏览器的不同选项卡上同时运行最多5个会话。</p><p>为了对在云上运行的更多控制，可以在首选的云供应商上运行此<a class="link"   href="https://hub.docker.com/r/openiap/nodered-tagui" >Docker 映像 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（使用边缘标签获取最新版本）或<a class="link"   href="https://github.com/open-rpa/openflow/blob/master/OpenFlowNodeRED/Dockerfiletagui" >Docker 文件。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>或者在 OpenFlow 上的<a class="link"   href="https://app.openiap.io/" >免费 Node-RED 实例 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上运行。 Docker 镜像、Docker 文件和 OpenFlow 云由<a class="link"   href="https://www.linkedin.com/in/skadefro/" >Allan Zimmermann <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>维护和赞助。</p><h2 id="命令手册"><a href="#命令手册" class="headerlink" title="命令手册"></a>命令手册</h2><p>在这里查询各种命令、辅助功能和运行选项</p><h3 id="流程命令"><a href="#流程命令" class="headerlink" title="流程命令"></a>流程命令</h3><h4 id="鼠标和键盘命令"><a href="#鼠标和键盘命令" class="headerlink" title="鼠标和键盘命令"></a>鼠标和键盘命令</h4><h5 id="click-单击"><a href="#click-单击" class="headerlink" title="click 单击"></a>click 单击</h5><p>鼠标左键点击目标</p><p>可以使用 DOM, XPath Point, Image进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click [DOM/XPath/Point/Image]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">click Main concepts</span><br><span class="line">click //nav/div/div[2]/ul/li[4]/ul/li[1]/a</span><br><span class="line">click (500,200)</span><br><span class="line">click button.png</span><br></pre></td></tr></table></figure></div><h5 id="rclick-右键单击"><a href="#rclick-右键单击" class="headerlink" title="rclick 右键单击"></a>rclick 右键单击</h5><p>鼠标右键单击目标</p><p>可以使用 DOM, XPath Point, Image进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rclick [DOM/XPath/Point/Image]</span><br></pre></td></tr></table></figure></div><p>参考 click 例子。</p><h5 id="dclick-双击"><a href="#dclick-双击" class="headerlink" title="dclick 双击"></a>dclick 双击</h5><p>鼠标左键双击目标</p><p>可以使用 DOM, XPath Point, Image进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dclick [DOM/XPath/Point/Image]</span><br></pre></td></tr></table></figure></div><h5 id="hover-鼠标移动"><a href="#hover-鼠标移动" class="headerlink" title="hover 鼠标移动"></a>hover 鼠标移动</h5><p>鼠标移动到目标位置</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hover [DOM/XPath/Point/Image]</span><br></pre></td></tr></table></figure></div><h5 id="type-输入"><a href="#type-输入" class="headerlink" title="type 输入"></a>type 输入</h5><p>Web输入命令，可以使用 [clear] 清除字段和 [enter] 来点击ENTER键。</p><p>可以使用 DOM, XPath Point, Image进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> [DOM/XPath/Point/Image] as [text to <span class="built_in">type</span>]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> search-term as John Wick</span><br><span class="line"><span class="built_in">type</span> //input[@name=<span class="string">&quot;search&quot;</span>] as John Wick</span><br><span class="line"><span class="built_in">type</span> (500,200) as John Wick</span><br><span class="line"><span class="built_in">type</span> input_field.png as John Wick</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> search-term as [clear]John Wick[enter]</span><br><span class="line"><span class="built_in">type</span> //input[@name=<span class="string">&quot;search&quot;</span>] as [clear]John Wick[enter]</span><br><span class="line"><span class="built_in">type</span> (500,200) as [clear]John Wick[enter]</span><br><span class="line"><span class="built_in">type</span> input_field.png as [clear]John Wick[enter]</span><br></pre></td></tr></table></figure></div><h5 id="keyboard-按键-按组合键"><a href="#keyboard-按键-按组合键" class="headerlink" title="keyboard 按键&#x2F;按组合键"></a>keyboard 按键&#x2F;按组合键</h5><p>模拟键盘按键</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyboard [keys]</span><br></pre></td></tr></table></figure></div><p>可以使用以下这些功能按键：</p><ul><li>[shift] [ctrl] [alt] [win] [cmd] [enter]</li><li>[space] [tab] [esc] [backspace] [delete] [clear]</li><li>[up] [down] [left] [right] [pageup] [pagedown]</li><li>[home] [end] [insert] [f1] .. [f15]</li><li>[printscreen] [scrolllock] [pause] [capslock] [numlock]</li></ul><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keyboard [win]run[enter]</span><br><span class="line">keyboard [printscreen]</span><br><span class="line">keyboard [ctrl]c</span><br><span class="line">keyboard [tab][tab][tab][enter]</span><br><span class="line"></span><br><span class="line">keyboard [cmd][space]</span><br><span class="line">keyboard safari[enter]</span><br><span class="line">keyboard []c</span><br></pre></td></tr></table></figure></div><h5 id="mouse-鼠标"><a href="#mouse-鼠标" class="headerlink" title="mouse 鼠标"></a>mouse 鼠标</h5><p>在当前鼠标位置，按下鼠标左键&#x2F;弹起鼠标左键。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mouse down</span><br><span class="line">mouse up</span><br></pre></td></tr></table></figure></div><h4 id="Web-网页端命令"><a href="#Web-网页端命令" class="headerlink" title="Web 网页端命令"></a>Web 网页端命令</h4><h5 id="visit-打开网站-url"><a href="#visit-打开网站-url" class="headerlink" title="visit 打开网站&#x2F;url"></a>visit 打开网站&#x2F;url</h5><p>直接输入网址url（带上 http），TagUI 就会在 Chrome 打开这个 URL。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[URL]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://google.com</span><br></pre></td></tr></table></figure></div><h5 id="select-下拉选择"><a href="#select-下拉选择" class="headerlink" title="select 下拉选择"></a>select 下拉选择</h5><p>修改下拉选择框，注意 as 后面是区分大小写的。</p><p>可以用 <a class="link"   href="http://www.tagui.com.cn/main_concepts.html#dom" >DOM <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, <a class="link"   href="http://www.tagui.com.cn/main_concepts.html#xpath" >XPath <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> [DOM/XPath of <span class="keyword">select</span> input element] as [option value or text]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select variant as blue</span><br></pre></td></tr></table></figure></div><h5 id="table-保存表格数据"><a href="#table-保存表格数据" class="headerlink" title="table 保存表格数据"></a>table 保存表格数据</h5><p>将Table表格数据保存到CSV文件，基于网页的Table编号或其<a class="link"   href="http://www.tagui.com.cn/main_concepts.html#xpath" >XPath <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table [table number] to [filename.csv]</span><br><span class="line">table [XPath] to [filename.csv]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table 1 to regional_exchange_rates.csv</span><br><span class="line">table (//table)[2] to global_exchange_rates.csv</span><br><span class="line">table //table[@name=<span class="string">&#x27;report&#x27;</span>] to report.csv</span><br></pre></td></tr></table></figure></div><h5 id="popup-把下一步操作放到新标签页"><a href="#popup-把下一步操作放到新标签页" class="headerlink" title="popup 把下一步操作放到新标签页"></a>popup 把下一步操作放到新标签页</h5><p>把下一步操作放到新标签页里进行。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popup [新标签页URL的特征部分]</span><br><span class="line">  [steps]</span><br></pre></td></tr></table></figure></div><p><em>例子：popup board 这里也可以使用 popup top.baidu.com&#x2F;board 效果是一样的。</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://baidu.com</span><br><span class="line">click 百度热搜</span><br><span class="line">popup board</span><br><span class="line">  click 电影榜</span><br><span class="line">  // some other steps</span><br></pre></td></tr></table></figure></div><h5 id="frame-针对某些框架操作"><a href="#frame-针对某些框架操作" class="headerlink" title="frame 针对某些框架操作"></a>frame 针对某些框架操作</h5><p>指定下一步操作的目标框架范围。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame [frame name]</span><br><span class="line">  [steps]</span><br><span class="line"></span><br><span class="line">frame [frame name] | [subframe name]</span><br><span class="line">  [steps]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame navigation</span><br><span class="line">  click Products</span><br><span class="line"></span><br><span class="line">frame main | register</span><br><span class="line">  click Register</span><br></pre></td></tr></table></figure></div><h5 id="download-to"><a href="#download-to" class="headerlink" title="download to"></a>download to</h5><p>指定 Chrome 下载文件的存储位置。默认位置是当前TagUI流程的文件夹。Specifies a location to store file downloads. The default location is the folder of the TagUI flow.</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download to [folder location]</span><br></pre></td></tr></table></figure></div><p>默认情况下 TagUI 启动后 Chrome 不询问下载存放路径，可以在.tag 文件里增加下面这句，让 Chrome 在下载是询问下载文件存放目录。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js chrome_step(<span class="string">&#x27;Page.setDownloadBehavior&#x27;</span>,&#123;behavior: <span class="string">&#x27;default&#x27;</span>, downloadPath: location&#125;)</span><br></pre></td></tr></table></figure></div><h5 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h5><p>上传文件到网站。</p><p>仅支持 DOM 目标定位方式。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload [DOM of upload element] as [filename]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload <span class="comment">#element_id as report.csv</span></span><br></pre></td></tr></table></figure></div><h5 id="api"><a href="#api" class="headerlink" title="api"></a>api</h5><p>调用Web API,并将返回内容保存到变量 <code>api_result</code>。</p><p>如果 API 返回的是JSON数据格式，将自动创建 <code>api_json</code>。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api https://some-api-url</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">api https://api.github.com/repos/kelaberetiv/TagUI/releases</span><br><span class="line"><span class="built_in">echo</span> `api_result`</span><br><span class="line">author = api_json[0].author.login</span><br></pre></td></tr></table></figure></div><h4 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h4><h5 id="读取中文配置"><a href="#读取中文配置" class="headerlink" title="读取中文配置"></a>读取中文配置</h5><p>控制面板 &gt; 语言 &gt; 管理语言设置 &gt; 更改系统区域设置 &gt; 使用utf-8 提供全球语言支持</p><p>对 Excel 执行读取，写入，复制，删除 等操作，比如 <code>[workbook]sheet!range</code> 范围。 本功能适用于 Windows 和 Mac 的 Excel 程序。对于部分需要密码的Excel处理，需要用到 <code>excel_password = &#39;password&#39;</code>：</p><h5 id="variables-变量"><a href="#variables-变量" class="headerlink" title="variables 变量"></a>variables 变量</h5><p>可以在Excel语法中使用变量，例如范围或表格 <code>range</code> or <code>sheet</code>。TagUI 支持各种版本的 Excel 文件，必须把文件的.扩展名 作为语法的一部分，以便 TagUI 可以识别指令是Excel命令而不是一些JavaScript 代码。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[`workbook`.xlsx]`sheet`!`range` = 123</span><br><span class="line">data = [`workbook`.xlsx]`sheet`!`range`</span><br></pre></td></tr></table></figure></div><h5 id="visibility-是否让Excel操作可见"><a href="#visibility-是否让Excel操作可见" class="headerlink" title="visibility 是否让Excel操作可见"></a>visibility 是否让Excel操作可见</h5><p>默认情况下，Excel 操作将在后台打开并运行，看不到后台的 Excel 操作。如果希望在 Excel 显示状态下操作，可以在流程中使用 <code>excel_focus = true</code>。使用 <code>excel_focus = false</code> 在工作流程中再次将其设置为OFF。</p><p>对于某些使用场景，甚至可能不希望 Excel 应用程序在后台可见。在这种情况下，可以在工作流程中设置以不可见方式运行 Excel。用于使 Excel 在 RPA 工作流程中再次可见。<code>excel_visible = false``excel_visible = true</code></p><h5 id="读取Excel"><a href="#读取Excel" class="headerlink" title="读取Excel"></a>读取Excel</h5><p>从Excel文件读取数据，支持的相对路径和绝对文件路径。如果指定的文件或工作表不存在，则会显示错误。接着，可以指定单元格或某个范围。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = [workbook]sheet!range</span><br></pre></td></tr></table></figure></div><p>读取 列column 和 行row 可以使用标准Excel语法范围描述方式，例如： A:A (column A), B:D (columns B to D), 2:2 (row 2), 3:5 (rows 3 to 5)。如果不指定范围，则默认对全部范围进行操作。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top_profit = [Monthly Report.xlsx]August!E10</span><br><span class="line">top_salesman = [Monthly Report.xlsx]August!E11</span><br><span class="line">data_array = [Quarterly Metrics.xlsx]Main!B3:G100</span><br><span class="line">data_array = [C:\Reports\June.xls]Sheet1!A1:C2</span><br><span class="line"></span><br><span class="line">data_array = [C:\Reports\June.xls]Sheet1!A:A</span><br><span class="line">data_array = [C:\Reports\June.xls]Sheet1!B:D</span><br><span class="line">data_array = [C:\Reports\June.xls]Sheet1!2:2</span><br><span class="line">data_array = [C:\Reports\June.xls]Sheet1!3:5</span><br></pre></td></tr></table></figure></div><p>Tagui 的后端语言是JavaScript，因此 Data_array 可以像 JavaScript 数组一样使用。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// to work on data <span class="keyword">in</span> data_array cell by cell</span><br><span class="line"><span class="keyword">for</span> row from 0 to data_array.length-1</span><br><span class="line">  <span class="keyword">for</span> col from 0 to data_array[row].length-1</span><br><span class="line">    <span class="built_in">echo</span> `data_array[row][col]`</span><br></pre></td></tr></table></figure></div><p>注意 - 读取多行和列有一个限制，举例： B:D and 3:5 (data array returned will be a 1 x N array instead of the correct row x column array)。这个问题在 v6.87 中已经修复。使用 <code>tagui update</code> 命令升级，或者用 MS Word Plug-in <code>Update TagUI</code> 按钮升级。</p><h5 id="写入Excel"><a href="#写入Excel" class="headerlink" title="写入Excel"></a>写入Excel</h5><p>使用 Write 命令往Excel内写数据。支持相对和绝对文件路径。如果指定的文件不存在，将创建一个新文件。如果表单不存在，将创建新表。 If the data is an array, the given cell will be used as the top-left cell to write the range of cells.</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[workbook]sheet!cell = variable</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Monthly Report.xlsx]August!E10 = 12345</span><br><span class="line">[Monthly Report.xlsx]August!E11 = <span class="string">&quot;Alan&quot;</span></span><br><span class="line">[Monthly Report.xlsx]August!E12 = variable</span><br><span class="line">[Quarterly Metrics.xlsx]Main!B3 = data_array</span><br></pre></td></tr></table></figure></div><p>Tagui 的后端语言是JavaScript，因此 Data_array 可以像 JavaScript 数组一样使用。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// to assign a <span class="built_in">set</span> of range data with 2 rows of 3 columns</span><br><span class="line">[C:\Reports\June.xls]Sheet1!A1 = [[1, 2, 3], [4, 5, 6]]</span><br><span class="line">[C:\Reports\June.xls]Sheet1!A1 = [[variable_1, variable_2, variable_3], [4, 5, 6]]</span><br><span class="line"></span><br><span class="line">// example spreadsheet data with <span class="comment">#, name and country</span></span><br><span class="line">[Participants.xlsx]Sheet1!A1 = [[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>], [2, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;Russia&#x27;</span>], [3, <span class="string">&#x27;Javier&#x27;</span>, <span class="string">&#x27;Serbia&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">// get the next row count <span class="keyword">for</span> the example spreadsheet</span><br><span class="line">column_A = [Participants.xlsx]Sheet1!A:A</span><br><span class="line">next_row = column_A.length + 1</span><br><span class="line"></span><br><span class="line">// write a new row accordingly to example spreadsheet</span><br><span class="line">[Participants.xlsx]Sheet1!A`next_row` = [[next_row, <span class="string">&#x27;Janice&#x27;</span>, <span class="string">&#x27;Brazil&#x27;</span>]]</span><br></pre></td></tr></table></figure></div><h5 id="copy-复制"><a href="#copy-复制" class="headerlink" title="copy 复制"></a>copy 复制</h5><p>在Excel文件中复制数据。支持相对和绝对文件路径。如果指定的目标文件不存在，将创建一个新文件。如果目标工作表不存在，将创建一个新工作表。如果数据是数组，则给定单元格将用作左上角单元格来写入单元格范围。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[workbook]sheet!cell = [workbook]sheet!range</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Monthly Report.xlsx]August!A1 = [Jennifer Report.xlsx]August!A1</span><br><span class="line">[Monthly Report.xlsx]August!A1 = [Jennifer Report.xlsx]August!A1:E200</span><br></pre></td></tr></table></figure></div><h5 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete 删除"></a>delete 删除</h5><p>删除 Excel 内的数据。支持相对和绝对文件路径。如果指定的文件或工作表不存在，将显示错误。Delete a range of cells by assigning an empty array to it.</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[workbook]sheet!cell = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Monthly Report.xlsx]August!E10 = <span class="string">&quot;&quot;</span></span><br><span class="line">[Quarterly Metrics.xlsx]Main!A1 = [[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>], [<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>]]</span><br></pre></td></tr></table></figure></div><h4 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h4><p>只需将 Microsoft Word 文档的文件名分配给变量即可读取其文本内容，如下所示。 TagUI 将自动 Microsoft Word 复制文本内容并分配给变量。此功能适用于 Windows 和 Mac。</p><p><em>Windows 设置word文件路径举例：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word_text = [Research Report.docx]</span><br><span class="line">word_text = [C:\Users\Jennifer\Desktop\Report.docx]</span><br><span class="line">word_text = [FY2021 Reports\Research Report.docx]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;C:\\Users\\Jennifer\\Desktop\\Report&#x27;</span></span><br><span class="line">word_text = [`filename`.docx]</span><br><span class="line">filename = <span class="string">&#x27;Research Report&#x27;</span></span><br><span class="line">word_text = [`filename`.docx]</span><br></pre></td></tr></table></figure></div><p><em>Mac 设置word文件路径举例：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word_text = [Research Report.docx]</span><br><span class="line">word_text = [/Users/jennifer/Desktop/Report.docx]</span><br><span class="line">word_text = [FY2021 Reports/Research Report.docx]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;/Users/jennifer/Desktop/Report&#x27;</span></span><br><span class="line">word_text = [`filename`.docx]</span><br><span class="line">filename = <span class="string">&#x27;Research Report&#x27;</span></span><br><span class="line">word_text = [`filename`.docx]</span><br></pre></td></tr></table></figure></div><p>将文本内容读入变量后，可以使用Tagui的函数来处理它，例如 get_text() 和 del_chars()，以获得RPA流程所需的特定信息。标准JavaScript函数也可用于进行字符串处理，可以 Google 搜索 <code>javascript how to xxxx</code>。 从 Word 读取文本内容后，TagUI 将关闭 Microsoft Word 并继续执行接下去的流程。</p><h4 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h4><p>只需要将文件名分配给变量，就可以将PDF文件的文本内容赋值给变量。TagUI 将自动执行 PDF Viewer 应用程序以复制文本内容并分配给变量。在 Windows 系统, 需要安装 Adobe Acrobat Reader，并且设置为打开pdf的默认程序。在Mac 系统, TagUI 使用可以查看PDF文件的默认预览应用程序。</p><p><em>Windows 设置pdf文件路径举例：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pdf_text = [Research Report.pdf]</span><br><span class="line">pdf_text = [C:\Users\Jennifer\Desktop\Report.pdf]</span><br><span class="line">pdf_text = [FY2021 Reports\Research Report.pdf]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;C:\\Users\\Jennifer\\Desktop\\Report&#x27;</span></span><br><span class="line">pdf_text = [`filename`.pdf]</span><br><span class="line">filename = <span class="string">&#x27;Research Report&#x27;</span></span><br><span class="line">pdf_text = [`filename`.pdf]</span><br></pre></td></tr></table></figure></div><p><em>Mac 设置pdf文件路径举例：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pdf_text = [Research Report.pdf]</span><br><span class="line">pdf_text = [/Users/jennifer/Desktop/Report.pdf]</span><br><span class="line">pdf_text = [FY2021 Reports/Research Report.pdf]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;/Users/jennifer/Desktop/Report&#x27;</span></span><br><span class="line">pdf_text = [`filename`.pdf]</span><br><span class="line">filename = <span class="string">&#x27;Research Report&#x27;</span></span><br><span class="line">pdf_text = [`filename`.pdf]</span><br></pre></td></tr></table></figure></div><p>将文本内容读入变量后，可以使用 Tagui 的函数 get_text() 和 del_chars() 来获得RPA流程所需的特定信息。标准JavaScript函数也可用于进行字符串处理，具体可以 Google 搜索<code>javascript how to xxxx</code>。从PDF文件读取文本内容后，TagUI将关闭PDF查看器并继续使用其余自动化步骤。</p><h4 id="Using-variables-使用变量"><a href="#Using-variables-使用变量" class="headerlink" title="Using variables 使用变量"></a>Using variables 使用变量</h4><h5 id="read-读取目标内容放入变量"><a href="#read-读取目标内容放入变量" class="headerlink" title="read 读取目标内容放入变量"></a>read 读取目标内容放入变量</h5><p>获取一些文本或值并将其存储在变量中。</p><p>可以使用 DOM, XPath, Region, Image 进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [DOM/XPath/Region/Image] to [variable]</span><br></pre></td></tr></table></figure></div><p>当提供区域Region 或 图像Image 元素特征时，Tagui 会使用OCR从屏幕中读取字符。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> //p[@<span class="built_in">id</span>=<span class="string">&quot;address&quot;</span>] to address</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> //p[@<span class="built_in">id</span>=<span class="string">&quot;address&quot;</span>]/@class to address-class</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> (500,200)-(600,400) to id-number</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> frame.png to email</span><br></pre></td></tr></table></figure></div><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p>将文本保存到变量。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[variable] = [value]</span><br></pre></td></tr></table></figure></div><p>在值中使用文本时，请围绕引号中的文本，如 “某些文本”。这使用 JavaScript 的规则，因此可以将数字分配给变量或使用其他 JavaScript 函数。变量名称需要是一个单词，不能以数字开头。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count = 5</span><br><span class="line">username = <span class="string">&quot;johncleese&quot;</span></span><br><span class="line">fullname = firstname + lastname</span><br></pre></td></tr></table></figure></div><h4 id="File-saving-loading-文件保存和读取"><a href="#File-saving-loading-文件保存和读取" class="headerlink" title="File saving&#x2F;loading 文件保存和读取"></a>File saving&#x2F;loading 文件保存和读取</h4><h5 id="dump-文本保存到文件"><a href="#dump-文本保存到文件" class="headerlink" title="dump 文本保存到文件"></a>dump 文本保存到文件</h5><p>将文本保存到新文件，例如把一个文本变量，保存到一个txt里。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dump [text] to [filename]</span><br><span class="line">dump [`variable`] to [filename]</span><br><span class="line">// creates blank CSV file with header</span><br><span class="line">dump First Name,Last Name to names.csv</span><br></pre></td></tr></table></figure></div><h5 id="write-追加写入"><a href="#write-追加写入" class="headerlink" title="write 追加写入"></a>write 追加写入</h5><p>将新的文本保存到现有文件中。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write [text] to [filename]</span><br><span class="line">write [`variable`] to [filename]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write firstname,lastname to names.csv</span><br><span class="line">write `fullreport` to report.txt</span><br></pre></td></tr></table></figure></div><h5 id="load-读取"><a href="#load-读取" class="headerlink" title="load 读取"></a>load 读取</h5><p>将文件内容加载到变量。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load [filename] to [variable]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load report.txt to report</span><br></pre></td></tr></table></figure></div><h5 id="snap-截屏"><a href="#snap-截屏" class="headerlink" title="snap 截屏"></a>snap 截屏</h5><p>屏幕截图功能，可以是全屏、某个元素或区域。</p><p>可以使用 DOM, XPath, Region, Image 进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap [DOM/XPath/Region/Image/page] to [filename]</span><br></pre></td></tr></table></figure></div><p>如果使用 <code>page</code> 定位目标，会把整个网页进行截图。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">snap logo to logo.png</span><br><span class="line"></span><br><span class="line">snap page to webpage.png</span><br></pre></td></tr></table></figure></div><h4 id="显示输出"><a href="#显示输出" class="headerlink" title="显示输出"></a>显示输出</h4><h5 id="echo-信息输出"><a href="#echo-信息输出" class="headerlink" title="echo 信息输出"></a>echo 信息输出</h5><p>在命令行上显示输出内容，比如显示变量。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [text]</span><br><span class="line"><span class="built_in">echo</span> [`variable`]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo Flow has started</span><br><span class="line">echo The user is `username`</span><br></pre></td></tr></table></figure></div><h5 id="show-显示元素文本"><a href="#show-显示元素文本" class="headerlink" title="show 显示元素文本"></a>show 显示元素文本</h5><p>在命令行上直接显示元素文本。</p><p>可以用 DOM, XPath 进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show [DOM/XPath]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show review-text</span><br></pre></td></tr></table></figure></div><h5 id="check-根据条件显示文本"><a href="#check-根据条件显示文本" class="headerlink" title="check 根据条件显示文本"></a>check 根据条件显示文本</h5><p>基于条件显示不同文本信息。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check [条件] | [结果为 <span class="literal">true</span> 的文本] | [结果为 <span class="literal">false</span> 的文本]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check header_home_text equals to <span class="string">&quot;Home&quot;</span> | <span class="string">&quot;header text is correct&quot;</span> | <span class="string">&quot;header text is wrong&quot;</span></span><br></pre></td></tr></table></figure></div><h4 id="Custom-code-自定义代码"><a href="#Custom-code-自定义代码" class="headerlink" title="Custom code 自定义代码"></a>Custom code 自定义代码</h4><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><p>运行 JavaScript 代码。TagUI 直接访问 JavaScript 变量。</p><p>TagUI 可以“智能”判断以下 3 种情况使用，无需使用js或js begin&#x2F; js finish：</p><ol><li>分配或改变变量 分配变量时，TagUI 可以检测&#x3D;符号并自动将该行视为 JavaScript 代码。</li><li>以 ; 结尾：如果一行以 ; 字符结尾，并且该行无法匹配任何已知的 TagUI 命令，则将其视为 JavaScript 代码。</li><li>常见的JavaScript关键字开头：如果一行无法匹配任何已知的 TagUI 命令，并且该行以常见的JavaScript 关键字（例如 if、for、switch、else、while、case、break、continue 等）开头，它将自动被视为 JavaScript 代码。</li></ol><p><code>js</code>，<code>js begin</code>和<code>js finish</code>方式使用 -</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js 1-line JavaScript code</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">js begin</span><br><span class="line">JavaScript code line 1</span><br><span class="line">JavaScript code line 2</span><br><span class="line">JavaScript code line 3</span><br><span class="line">js finish</span><br></pre></td></tr></table></figure></div><p>每当有一些 JavaScript 代码（除了 TagUI 步骤或辅助函数之外的任何代码）时，都需要上面的代码。然而，TagUI 可以“智能”地检测到以下 3 种使用 JavaScript 但<code>js</code>不需要的情况。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">js [JavaScript statement]</span><br><span class="line"></span><br><span class="line">js begin</span><br><span class="line">[JavaScript statements]</span><br><span class="line">js finish</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">js obj = JSON.parse(api_result)</span><br><span class="line">dump `obj` to result.json</span><br><span class="line"></span><br><span class="line">js begin</span><br><span class="line">obj = JSON.parse(api_result)</span><br><span class="line">randomInteger = Math.floor(Math.random() * Math.floor(5)) + 1</span><br><span class="line">js finish</span><br><span class="line">dump `obj` to result.json</span><br><span class="line"></span><br><span class="line">// <span class="built_in">declare</span> and initilise variable to use it inside/outside js code block</span><br><span class="line">a = <span class="string">&quot;&quot;</span></span><br><span class="line">js begin</span><br><span class="line">a = <span class="string">&quot;some string&quot;</span></span><br><span class="line">js finish</span><br><span class="line"><span class="built_in">echo</span> `a`</span><br></pre></td></tr></table></figure></div><p><strong>1. 分配或更改变量</strong></p><p>当分配变量时，TagUI 可以检测符号<code>=</code>并自动将该行视为 JavaScript 代码，而无需用户显式使用<code>js</code>或<code>js begin</code>&#x2F; <code>js finish</code>。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Johnny&quot;</span></span><br></pre></td></tr></table></figure></div><p><strong>2. 以 ; 结尾的行特点</strong></p><p>如果一行以<code>;</code>字符结尾，并且该行无法匹配任何已知的 TagUI 步骤，则将其视为 JavaScript 代码。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// below line quit TagUI</span><br><span class="line">this.exit();</span><br></pre></td></tr></table></figure></div><p><strong>3. 常用JavaScript关键字</strong></p><p>如果一行无法匹配任何已知的 TagUI 步骤，并且该行以常见的 JavaScript 关键字（例如 if、for、switch、else、while、case、break、continue 等）开头，它将自动被视为 JavaScript 代码，而无需使用<code>js</code>.</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n from 1 to 10</span><br><span class="line">    <span class="built_in">echo</span> `n`</span><br><span class="line">    <span class="keyword">if</span> n equals to 5</span><br><span class="line">        <span class="built_in">break</span></span><br></pre></td></tr></table></figure></div><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><p>运行Python代码并将stdout 保存到变量 <code>py_result</code> 作为字符串。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">py [Python statement]</span><br><span class="line"></span><br><span class="line">py begin</span><br><span class="line">[Python statements]</span><br><span class="line">py finish</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">py result = 2 + 3</span><br><span class="line">py <span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">echo</span> `py_result`</span><br><span class="line"></span><br><span class="line">py begin</span><br><span class="line">import random</span><br><span class="line">random_integer = random.randint(1,6)</span><br><span class="line"><span class="built_in">print</span>(random_integer)</span><br><span class="line">py finish</span><br><span class="line"><span class="built_in">echo</span> `py_result`</span><br></pre></td></tr></table></figure></div><p>有关运行Python代码的更多示例和使用模式查看高级命令</p><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>在命令提示符或终端中运行命令，并将 stdout 保存到变量 <code>run_result</code>。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run [shell <span class="built_in">command</span>]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run cmd /c <span class="built_in">mkdir</span> new_directory</span><br></pre></td></tr></table></figure></div><h5 id="Sikuli"><a href="#Sikuli" class="headerlink" title="Sikuli"></a>Sikuli</h5><p>运行 Sikuli 代码，例如需要把OCR设置成中文</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vision begin</span><br><span class="line">import org.sikuli.script.TextRecognizer as TR</span><br><span class="line">Settings.OcrReadText = True</span><br><span class="line">Settings.OcrLanguage = <span class="string">&quot;chi_sim&quot;</span></span><br><span class="line">TR.reset()</span><br><span class="line">vision finish</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vision click(<span class="string">&quot;button1.png&quot;</span>)</span><br></pre></td></tr></table></figure></div><h5 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h5><p>在浏览器 DOM 中运行代码并将返回值保存到变量 <code>dom_result</code>。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dom [JavaScript statement to run <span class="keyword">in</span> the DOM]</span><br><span class="line"></span><br><span class="line">dom begin</span><br><span class="line">[JavaScript statements to run <span class="keyword">in</span> the DOM]</span><br><span class="line">dom finish</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// goes back to previous page</span><br><span class="line">dom window.history.back()</span><br><span class="line"></span><br><span class="line">// returns text of an element</span><br><span class="line">dom <span class="built_in">return</span> document.querySelector(<span class="string">&#x27;#some_id&#x27;</span>).textContent</span><br></pre></td></tr></table></figure></div><h5 id="R"><a href="#R" class="headerlink" title="R"></a>R</h5><p>运行 R 语句并将 stdout 保存到变量 <code>r_result</code>。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r [R statement]</span><br><span class="line"></span><br><span class="line">r begin</span><br><span class="line">[R statements]</span><br><span class="line">r finish</span><br></pre></td></tr></table></figure></div><h4 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h4><h5 id="wait-等待"><a href="#wait-等待" class="headerlink" title="wait 等待"></a>wait 等待</h5><p>等待一段时间，默认时间单位：秒。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span> [seconds to <span class="built_in">wait</span>]</span><br><span class="line"><span class="built_in">wait</span> [seconds to <span class="built_in">wait</span>] s</span><br><span class="line"><span class="built_in">wait</span> [seconds to <span class="built_in">wait</span>] seconds</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span> 5.5</span><br><span class="line"><span class="built_in">wait</span> 10 s</span><br><span class="line"><span class="built_in">wait</span> 20 seconds</span><br></pre></td></tr></table></figure></div><h5 id="timeout-设置等待超时"><a href="#timeout-设置等待超时" class="headerlink" title="timeout 设置等待超时"></a>timeout 设置等待超时</h5><p>等待 Web 元素出现时，设置自动等待超时（默认为10秒）。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">timeout</span> [seconds to <span class="built_in">wait</span> before <span class="built_in">timeout</span>]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></div><h5 id="ask"><a href="#ask" class="headerlink" title="ask"></a>ask</h5><p>提示用户输入，并将用户输入内容保存为变量 <code>ask_result</code>。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ask [prompt]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ask What is the <span class="built_in">date</span> of the receipt? (<span class="keyword">in</span> DD-MM-YYYY)</span><br><span class="line"><span class="built_in">type</span> search as `ask_result`</span><br></pre></td></tr></table></figure></div><h5 id="live"><a href="#live" class="headerlink" title="live"></a>live</h5><p>一步步执行命令并立即看到输出。输入 “done” 退出Live模式。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">live</span><br></pre></td></tr></table></figure></div><h5 id="tagui-调用流程"><a href="#tagui-调用流程" class="headerlink" title="tagui 调用流程"></a>tagui 调用流程</h5><p>调用另一个 TagUI 流程，注意文件路径别写错。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tagui [flow file]</span><br><span class="line">tagui [folder/flow file]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tagui update-forex.tag</span><br><span class="line">tagui flows/update-forex.tag</span><br></pre></td></tr></table></figure></div><h4 id="添加注释"><a href="#添加注释" class="headerlink" title="&#x2F;&#x2F; 添加注释"></a>&#x2F;&#x2F; 添加注释</h4><p>添加代码注释。在使用条件或循环命令是，注释也要相应缩进，以便在转换为JavaScript代码后正确运行。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这里写注释，不会被程序运行</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 点击登录按钮</span><br></pre></td></tr></table></figure></div><h4 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a>Telegram</h4><p>Telegram 是国外的一款聊天软件，中国使用人数极少。TagUI 通过发送 telegram 消息，及时获得机器人的工作结果或报错状态信息。国内一般都用 企业微信、钉钉等。</p><p>首先要获得 <a class="link"   href="https://t.me/taguibot" >@taguibot <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 发消息授权，然后再用 TagUI 下面的命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telegram [<span class="built_in">id</span>] [message]</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// this line sends message to Telegram user with ID 1234567890, \n means a new line</span><br><span class="line">telegram 1234567890 Hello Alena,\n\nYour HR onboarding bot has completed successfully.</span><br><span class="line"></span><br><span class="line">// show telegram_result variable - <span class="string">&#x27;success&#x27;</span> means sent, <span class="string">&#x27;fail&#x27;</span> means sending failed</span><br><span class="line"><span class="built_in">echo</span> Telegram message - `telegram_result`</span><br><span class="line"></span><br><span class="line">// <span class="keyword">if</span> condition to check telegram_result <span class="string">&#x27;success&#x27;</span> or <span class="string">&#x27;fail&#x27;</span> and handle accordingly</span><br><span class="line"><span class="keyword">if</span> telegram_result equals to <span class="string">&#x27;success&#x27;</span></span><br><span class="line">  <span class="built_in">echo</span> Message sent successfully.</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> Message sending failed.</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>电报步骤需要互联网连接。此功能托管在<a class="link"   href="https://tebel.org/" >https://tebel.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上，但如果希望在自己的云或服务器上托管此功能，则<a class="link"   href="https://github.com/kelaberetiv/TagUI/tree/master/src/telegram" >源代码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>位于 GitHub 上。该实现是在纯 PHP 中实现的，没有任何依赖项。</p><p>记录的唯一信息是 chat_id、消息长度、日期时间戳（以防止滥用）。如果希望自行托管，请首先阅读此链接以了解有关 Telegram Bot API、创建的 bot API 令牌并设置 webhook 的更多信息 - <a class="link"   href="https://core.telegram.org/bots" >https://core.telegram.org/bots <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>    </div>  </div><h4 id="Run-options-运行流程选项"><a href="#Run-options-运行流程选项" class="headerlink" title="Run options 运行流程选项"></a>Run options 运行流程选项</h4><p>可以使用 <code>tagui</code> 命令，查看选项说明。</p><p>举例：这条命令运行 <code>my_flow.tag</code> 而隐藏Web浏览器，同时把流程运行结果存储到 <code>tagui_report.csv</code> 中。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui my_flow.tag -headless -report</span><br></pre></td></tr></table></figure></div><h5 id="deploy-or-d-生产CMD快捷方式"><a href="#deploy-or-d-生产CMD快捷方式" class="headerlink" title="-deploy or -d 生产CMD快捷方式"></a>-deploy or -d 生产CMD快捷方式</h5><p>创建一个可以双击运行流程的快捷方式。如果移动文件，则必须创建一个新的快捷方式。流程将在创建快捷方式时使用的所有选项运行。</p><h5 id="headless-or-h-隐藏浏览器"><a href="#headless-or-h-隐藏浏览器" class="headerlink" title="-headless or -h 隐藏浏览器"></a>-headless or -h 隐藏浏览器</h5><p>运行时，隐藏 Chrome Web浏览器（隐藏浏览器就无法使用 Visual Automation）。</p><h5 id="nobrowser-or-n-不使用Web浏览器"><a href="#nobrowser-or-n-不使用Web浏览器" class="headerlink" title="-nobrowser or -n 不使用Web浏览器"></a>-nobrowser or -n 不使用Web浏览器</h5><p>不使用Web浏览器，例如仅使用可视自动化执行自动化。</p><h5 id="report-or-r-保存HTML日志"><a href="#report-or-r-保存HTML日志" class="headerlink" title="-report or -r 保存HTML日志"></a>-report or -r 保存HTML日志</h5><p>追踪流程运行结果，记录在<code>tagui/src/tagui_report.csv</code> 中，并保存流量执行的HTML日志。</p><h5 id="turbo-or-t-十倍速运行"><a href="#turbo-or-t-十倍速运行" class="headerlink" title="-turbo or -t 十倍速运行"></a>-turbo or -t 十倍速运行</h5><p>在10倍的速度下运行流程。谨慎使用！</p><h5 id="quiet-or-q-减少非主动信息输出"><a href="#quiet-or-q-减少非主动信息输出" class="headerlink" title="-quiet or -q 减少非主动信息输出"></a>-quiet or -q 减少非主动信息输出</h5><p>除了 echo, show, check steps and errors etc 之外，不显示其他输出。在执行期间显示和隐藏输出的细粒度控制（例如，隐藏密码显示出来）, 可以在流处里使用 <code>quiet_mode = true</code> 和 <code>quiet_mode = false</code> 进行控制。</p><h5 id="edge-or-e-使用Edge浏览器"><a href="#edge-or-e-使用Edge浏览器" class="headerlink" title="-edge or -e 使用Edge浏览器"></a>-edge or -e 使用Edge浏览器</h5><p>使用 Microsoft Edge浏览器而不是Chrome运行（可与-headless选项一起使用）。</p><h5 id="my-datatable-csv"><a href="#my-datatable-csv" class="headerlink" title="my_datatable.csv"></a>my_datatable.csv</h5><p>使用指定的CSV文件作为批量自动化的DataTable。查看 <a class="link"   href="http://www.tagui.com.cn/advanced.html#datatables" >datatables <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><h5 id="input-s-流程参数"><a href="#input-s-流程参数" class="headerlink" title="input(s) 流程参数"></a>input(s) 流程参数</h5><p>添加自己的流程参数，在的流程中做为变量P1至P8使用。</p><p>例如在CMD里,运行 <code>register_attendence.tag</code> 流程，需要用 Edge 浏览器，同时向该流程输入4个变量（4个人名）。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui register_attendence.tag -edge Jenny Jason John Joanne</span><br></pre></td></tr></table></figure></div><p>在流程里, 4个人名会自动分配给4个变量 <code>p1</code>, <code>p2</code>, <code>p3</code>, <code>p4</code> 。例如在需要输入不同数据时，就特别方便，下面的命令会显示出这4个变量，可以试试。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `p1`</span><br><span class="line"><span class="built_in">echo</span> `p2`</span><br><span class="line"><span class="built_in">echo</span> `p3`</span><br><span class="line"><span class="built_in">echo</span> `p4`</span><br></pre></td></tr></table></figure></div><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><h4 id="csv-row-1"><a href="#csv-row-1" class="headerlink" title="csv_row()"></a>csv_row()</h4><p>以数组方式写入CSV文件。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> name_element to name</span><br><span class="line"><span class="built_in">read</span> price_element to price</span><br><span class="line"><span class="built_in">read</span> details_element to details</span><br><span class="line">write `csv_row([name, price, details])` to product_list.csv</span><br></pre></td></tr></table></figure></div><h4 id="count-数量计算"><a href="#count-数量计算" class="headerlink" title="count() 数量计算"></a>count() 数量计算</h4><p>获取符合指定元素特征的元素数，例如计算有多少个新闻标题，然后用for读取它们。请注意，元素特征需要单引号 <code>&#39;&#39;</code>。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows = count(<span class="string">&#x27;table-rows&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="clipboard-剪贴板-1"><a href="#clipboard-剪贴板-1" class="headerlink" title="clipboard() 剪贴板"></a>clipboard() 剪贴板</h4><p>将文本放在剪贴板上，或获取剪贴板文本。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clipboard(<span class="string">&#x27;some text&#x27;</span>)</span><br><span class="line">keyboard [ctrl]v</span><br><span class="line"></span><br><span class="line">keyboard [ctrl]c</span><br><span class="line">contents = clipboard()</span><br></pre></td></tr></table></figure></div><h4 id="url-获取当前URL"><a href="#url-获取当前URL" class="headerlink" title="url() 获取当前URL"></a>url() 获取当前URL</h4><p>获取当前网页的URL。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> url() contains <span class="string">&#x27;success&#x27;</span></span><br><span class="line">  click button1</span><br></pre></td></tr></table></figure></div><h4 id="title-获取当前网页标题。"><a href="#title-获取当前网页标题。" class="headerlink" title="title() 获取当前网页标题。"></a>title() 获取当前网页标题。</h4><p>获取当前网页的标题title。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> title() contains <span class="string">&#x27;Confirmation&#x27;</span></span><br><span class="line">  click button1</span><br></pre></td></tr></table></figure></div><h4 id="text"><a href="#text" class="headerlink" title="text()"></a>text()</h4><p>获取当前网页的所有文本内容。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> text() contains <span class="string">&#x27;success&#x27;</span></span><br><span class="line">  click button1</span><br></pre></td></tr></table></figure></div><h4 id="timer"><a href="#timer" class="headerlink" title="timer()"></a>timer()</h4><p>获得一段命令执行的时间周期，时间单位：秒。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timer()</span><br><span class="line">click button1</span><br><span class="line">click button2</span><br><span class="line">click button3</span><br><span class="line"><span class="built_in">echo</span> `timer()`</span><br></pre></td></tr></table></figure></div><h4 id="exist-等待元素出现"><a href="#exist-等待元素出现" class="headerlink" title="exist() 等待元素出现"></a>exist() 等待元素出现</h4><p>等待元素出现，如果元素出现返回<code>true</code> ，如果元素等待时间超时，元素还没有出现，就返回 <code>false</code>，通常在网页搜索、查询等流程时使用本命令，以确定查询结果已经出现后，才继续下面的流程。请注意，元素特征包含在引号 ‘’ 内。</p><p>可以使用 DOM, XPath, Image 进行目标定位。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exist(<span class="string">&#x27;[DOM/XPath/Image]&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> exist(<span class="string">&#x27;//table&#x27;</span>)</span><br><span class="line">  click button1</span><br></pre></td></tr></table></figure></div><h4 id="present-判断元素是否存在"><a href="#present-判断元素是否存在" class="headerlink" title="present() 判断元素是否存在"></a>present() 判断元素是否存在</h4><p>判断元素是否存在，并且直接返回 <code>true</code> 或 <code>false</code>。</p><p>请注意，元素特征包含在单引号 <code>&#39;</code> 内。</p><p>可以使用DOM, XPath, Image 进行目标定位。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> present(<span class="string">&#x27;//table&#x27;</span>)</span><br><span class="line">  click button1</span><br></pre></td></tr></table></figure></div><h4 id="mouse-xy-1"><a href="#mouse-xy-1" class="headerlink" title="mouse_xy()"></a>mouse_xy()</h4><p>获取当前鼠标位置的x，y坐标。</p><p>适合用在 live mode。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `mouse_xy()`</span><br></pre></td></tr></table></figure></div><h4 id="mouse-x"><a href="#mouse-x" class="headerlink" title="mouse_x()"></a>mouse_x()</h4><p>获取当前鼠标位置的 x 坐标。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hover element.png</span><br><span class="line">x = mouse_x() + 200</span><br><span class="line">y = mouse_y()</span><br><span class="line">click (`x`,`y`)</span><br></pre></td></tr></table></figure></div><h4 id="mouse-y"><a href="#mouse-y" class="headerlink" title="mouse_y()"></a>mouse_y()</h4><p>获取当前鼠标位置的 y 坐标。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hover element.png</span><br><span class="line">x = mouse_x() + 200</span><br><span class="line">y = mouse_y()</span><br><span class="line">click (`x`,`y`)</span><br></pre></td></tr></table></figure></div><h4 id="get-files"><a href="#get-files" class="headerlink" title="get_files()"></a>get_files()</h4><p>获取文件或文件夹列表，支持相对和绝对路径。Returns an array of files and folders in a given folder. Both relative and absolute paths supported.</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// list of files <span class="keyword">in</span> the same folder as the flow file</span><br><span class="line">list = get_files(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">// list of files <span class="keyword">in</span> the Desktop folder of user Alan</span><br><span class="line">// note double backslash because of JavaScript string</span><br><span class="line">list = get_files(<span class="string">&#x27;C:\\Users\\Alan\\Desktop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">// alternatively, use single forward slash instead</span><br><span class="line">list = get_files(<span class="string">&#x27;C:/Users/Alan/Desktop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">// showing the list of files after retrieving it</span><br><span class="line">// JavaScript array start from 0 <span class="keyword">for</span> 1st element</span><br><span class="line"><span class="keyword">for</span> n from 0 to list.length-1</span><br><span class="line">  <span class="built_in">echo</span> `list[n]`</span><br><span class="line"></span><br><span class="line">// checking to process a specific file extension</span><br><span class="line"><span class="keyword">for</span> n from 0 to list.length-1</span><br><span class="line">  <span class="keyword">if</span> list[n] contains <span class="string">&#x27;.XLSX&#x27;</span></span><br><span class="line">    <span class="built_in">echo</span> `list[n]`</span><br></pre></td></tr></table></figure></div><h4 id="get-text-截取文本"><a href="#get-text-截取文本" class="headerlink" title="get_text() 截取文本"></a>get_text() 截取文本</h4><p>从文本中提取2的锚点之间的文本。当有多个匹配结果时的可选第4参数（例如，3判断函数返回找到的第3匹配）。</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pdf_text = <span class="string">&#x27;Name: John State: Texas City: Plano Contact: ...&#x27;</span></span><br><span class="line"></span><br><span class="line">name = get_text(pdf_text, <span class="string">&#x27;Name:&#x27;</span>, <span class="string">&#x27;State:&#x27;</span>)</span><br><span class="line">state = get_text(pdf_text, <span class="string">&#x27;State:&#x27;</span>, <span class="string">&#x27;City:&#x27;</span>)</span><br><span class="line">city = get_text(pdf_text, <span class="string">&#x27;City:&#x27;</span>, <span class="string">&#x27;Contact:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> `name`, `state`, `city`</span><br></pre></td></tr></table></figure></div><h4 id="del-chars-删除文本"><a href="#del-chars-删除文本" class="headerlink" title="del_chars() 删除文本"></a>del_chars() 删除文本</h4><p>删除特征字符后的文本，并返回结果来清除数据。Cleans data by removing provided character(s) from given text and returning the result.</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pdf_text = <span class="string">&#x27;Name: John\n State: Texas\t City: Plano\n Contact: ...&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> `del_chars(pdf_text, <span class="string">&#x27;\n\t:&#x27;</span>)`</span><br></pre></td></tr></table></figure></div><h4 id="get-env-获得当前用户环境变量"><a href="#get-env-获得当前用户环境变量" class="headerlink" title="get_env() 获得当前用户环境变量"></a>get_env() 获得当前用户环境变量</h4><p>从操作系统返回给定环境变量的值。例如：C:\Users\Administrator</p><p><em>例子：</em></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// getting %USERPROFILE% variable <span class="keyword">for</span> Windows</span><br><span class="line"><span class="built_in">echo</span> `get_env(<span class="string">&#x27;USERPROFILE&#x27;</span>)`</span><br><span class="line">home_dir = get_env(<span class="string">&#x27;USERPROFILE&#x27;</span>)</span><br><span class="line"></span><br><span class="line">// getting <span class="variable">$HOME</span> variable <span class="keyword">for</span> Mac or Linux</span><br><span class="line"><span class="built_in">echo</span> `get_env(<span class="string">&#x27;HOME&#x27;</span>)`</span><br><span class="line">home_dir = get_env(<span class="string">&#x27;HOME&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h2 id="RPA-for-Python-TagUI-在-Python-里使用"><a href="#RPA-for-Python-TagUI-在-Python-里使用" class="headerlink" title="RPA for Python (TagUI 在 Python 里使用)"></a>RPA for Python (TagUI 在 Python 里使用)</h2><p>RPA for Python 是一个 Python 库 (安装方式：<code>pip install rpa</code>) 这个库可以使用 Python API 来调用 TagUI 执行自动化RPA操作。查看<a class="link"   href="https://github.com/tebelorg/RPA-Python" > 这里  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>， RPA for Python 由 TagUI’s creator Ken Soh <a class="link"   href="https://github.com/kensoh" >@kensoh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 创建和维护。</p><h2 id="TagUI-源代码的和依赖库"><a href="#TagUI-源代码的和依赖库" class="headerlink" title="TagUI 源代码的和依赖库"></a>TagUI 源代码的和依赖库</h2><p>可以查看这些源代码，帮助这些项目的迭代及Bug修复，因为这些项目都有大量用户在使用。</p><ul><li>TagUI - <a class="link"   href="javascript:if(confirm(https://github.com/kelaberetiv/TagUI" >https://github.com/kelaberetiv/TagUI <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>SikuliX - <a class="link"   href="https://github.com/RaiMan/SikuliX1" >https://github.com/casperjs/casperjs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>PhantomJS - <a class="link"   href="https://github.com/ariya/phantomjs" >https://github.com/ariya/phantomjs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>SlimerJS - <a class="link"   href="https://github.com/laurentj/slimerjs" >https://github.com/laurentj/slimerjs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>Python - <a class="link"   href="https://github.com/python/cpython" >https://github.com/python/cpython <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>R - <a class="link"   href="https://github.com/wch/r-source" >https://github.com/wch/r-source <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>PHP - <a class="link"   href="https://github.com/php/php-src" >https://github.com/php/php-src <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h2 id="示例代码块"><a href="#示例代码块" class="headerlink" title="示例代码块"></a>示例代码块</h2><h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><p>TagUI 支持运行服务器上的.tag文件，试试直接输入下面命令，会打开百度进行简单点击操作。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagui http://www.TagUI.com.cn/baidu.tag</span><br></pre></td></tr></table></figure></div><h3 id="把cmd设置成UTF-8"><a href="#把cmd设置成UTF-8" class="headerlink" title="把cmd设置成UTF-8"></a>把cmd设置成UTF-8</h3><p>这样在CMD环境里，echo输出就可以正常显示简体中文。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 把cmd设置成UTF-8</span><br><span class="line">run cmd /c chcp 65001</span><br></pre></td></tr></table></figure></div><h3 id="字符串查找替换"><a href="#字符串查找替换" class="headerlink" title="字符串查找替换"></a>字符串查找替换</h3><p>字符串替换命令，TagUI字符串处理，请参考 JS 语法</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//字符串查找替换</span><br><span class="line">txt=<span class="string">&quot;http://baidu.com&quot;</span></span><br><span class="line">txt=txt.replace(<span class="string">&quot;baidu&quot;</span>,<span class="string">&quot;kkyyww&quot;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="查找字符串目标文字位置"><a href="#查找字符串目标文字位置" class="headerlink" title="查找字符串目标文字位置"></a>查找字符串目标文字位置</h3><p>，参考JS语法</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//查找字符串目标文字位置</span><br><span class="line">字符位置=txt.lastIndexOf(<span class="string">&quot;du.&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> `字符位置`</span><br></pre></td></tr></table></figure></div><h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><p>下载图片需要用curl.exe这个命令，百度 curl 具体了解。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 下载图片</span><br><span class="line">run curl -k -s -L -o c:/aaa.png http://www.bbb.com/ccc.jpg</span><br></pre></td></tr></table></figure></div><h3 id="download-命令的使用例子"><a href="#download-命令的使用例子" class="headerlink" title="download 命令的使用例子"></a>download 命令的使用例子</h3><p>download命令下载视频</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://www.videvo.net/video/apollo-command-and-service-module-separation/8/</span><br><span class="line">download to C:\Users\Administrator\Documents\TagUI\TCvideo\v</span><br><span class="line">click //*[@<span class="built_in">id</span>=<span class="string">&quot;download-button&quot;</span>]</span><br><span class="line"><span class="built_in">wait</span> 10</span><br></pre></td></tr></table></figure></div><h3 id="API-例子"><a href="#API-例子" class="headerlink" title="API 例子"></a>API 例子</h3><p>调用有道API翻译，初学者可以看看这里的数组处理方式</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 用API翻译</span><br><span class="line">api http://fanyi.youdao.com/translate?&amp;doctype=json&amp;<span class="built_in">type</span>=AUTO&amp;i=i love you</span><br><span class="line">中文词 = JSON.parse(api_result)</span><br><span class="line">中文词 = 中文词[<span class="string">&quot;translateResult&quot;</span>][0][0][<span class="string">&quot;tgt&quot;</span>]</span><br><span class="line"><span class="built_in">echo</span> `中文词`</span><br></pre></td></tr></table></figure></div><h3 id="抓取百度首页新闻标题"><a href="#抓取百度首页新闻标题" class="headerlink" title="抓取百度首页新闻标题"></a>抓取百度首页新闻标题</h3><p>循环抓取 XPATH 的例子</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 抓取百度首页新闻标题</span><br><span class="line">http://baidu.com</span><br><span class="line">新闻总数量 = count(<span class="string">&#x27;/html/body/div[1]/div[1]/div[5]/div/div/div[3]/ul/li[*]/a/span[2]&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> `新闻总数量`</span><br><span class="line"><span class="keyword">for</span> i from 1 to 新闻总数量</span><br><span class="line">  <span class="built_in">read</span> /html/body/div[1]/div[1]/div[5]/div/div/div[3]/ul/li[`i`]/a/span[2] to 标题</span><br><span class="line">  <span class="built_in">echo</span> `标题`</span><br></pre></td></tr></table></figure></div><h3 id="判断目录内是否包含指定扩展名文件"><a href="#判断目录内是否包含指定扩展名文件" class="headerlink" title="判断目录内是否包含指定扩展名文件"></a>判断目录内是否包含指定扩展名文件</h3><p>判断目录内是否包含指定扩展名文件，可用于判断下载是否完成</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 判断目录内是否包含指定扩展名文件，可用于判断下载是否完成</span><br><span class="line">list = get_files(<span class="string">&#x27;C:\\Users\\Administrator\\Documents\\TagUI\\TCvideo\\v\\视频翻译\\&#x27;</span>)</span><br><span class="line">指定扩展名=<span class="string">&quot;mp4&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `list[1].indexOf(指定扩展名)`</span><br><span class="line"><span class="built_in">echo</span> `字符位置`</span><br></pre></td></tr></table></figure></div><h3 id="判断chrome是否下载完成"><a href="#判断chrome是否下载完成" class="headerlink" title="判断chrome是否下载完成"></a>判断chrome是否下载完成</h3><p>判断chrome是否下载完成</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 判断chrome是否下载完成</span><br><span class="line">https://www.videvo.net/video/8//</span><br><span class="line"><span class="built_in">wait</span> 3</span><br><span class="line">click download-button</span><br><span class="line"><span class="built_in">wait</span> 3</span><br><span class="line"><span class="keyword">for</span> n from 1 to 100</span><br><span class="line">  <span class="built_in">echo</span> `present(<span class="string">&#x27;mb.png&#x27;</span>)`</span><br><span class="line">  <span class="keyword">if</span> present(<span class="string">&#x27;mb.png&#x27;</span>)</span><br><span class="line">    <span class="built_in">wait</span> 3</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> 下载完成</span><br><span class="line">    <span class="built_in">break</span></span><br></pre></td></tr></table></figure></div><h3 id="读取excel，写入txt"><a href="#读取excel，写入txt" class="headerlink" title="读取excel，写入txt"></a>读取excel，写入txt</h3><p>读取excel，写入txt</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//读excel</span><br><span class="line">data_array = [1.xlsx]sheet1!A1:B3</span><br><span class="line"><span class="built_in">echo</span> `data_array`</span><br><span class="line">dump `data_array` to 0.txt</span><br><span class="line"><span class="built_in">wait</span> 5</span><br></pre></td></tr></table></figure></div><h3 id="打开变量里的URL"><a href="#打开变量里的URL" class="headerlink" title="打开变量里的URL"></a>打开变量里的URL</h3><p>下面2种方法都可以，推荐用第二种</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//打开变量里的URL</span><br><span class="line">url = <span class="string">&#x27;https://baidu.com&#x27;</span></span><br><span class="line">https://`url.split(<span class="string">&#x27;//&#x27;</span>)[1]`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//打开变量里的URL，推荐用这种方式，简单点</span><br><span class="line">url = <span class="string">&#x27;baidu.com&#x27;</span></span><br><span class="line">https://`url`</span><br></pre></td></tr></table></figure></div><h3 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h3><p>杀死TagUI相关进程，包括chrome，避免上一个tag没完成或卡主，影响当前tag运行</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 环境初始化，杀死TagUI相关进程，包括chrome</span><br><span class="line">run cmd /c  d:/tagui/src/end_processes.cmd</span><br></pre></td></tr></table></figure></div><h3 id="获得本机名"><a href="#获得本机名" class="headerlink" title="获得本机名"></a>获得本机名</h3><p>获得本地Windows计算机名</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获得本机名</span><br><span class="line">run cmd /c hostname</span><br><span class="line">pcname=run_result</span><br><span class="line"><span class="built_in">echo</span> `pcname`</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">TagUI教程</summary>
    
    
    
    <category term="RPA" scheme="https://www.yiuhangblog.com/categories/RPA/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CUDA安装</title>
    <link href="https://www.yiuhangblog.com/2024/04/02/20240402CUDA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://www.yiuhangblog.com/2024/04/02/20240402CUDA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2024-04-02T01:35:05.000Z</published>
    <updated>2024-04-18T03:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h2><h3 id="确定版本"><a href="#确定版本" class="headerlink" title="确定版本"></a>确定版本</h3><p>打开NVIDA Control Panel（桌面右键）-&gt;选择左下角的系统信息-&gt;组件 查看后前往<a class="link"   href="https://developer.nvidia.com/cuda-toolkit-archive" >kCUDA Toolkit Archive | NVIDIA Developer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/17b86aed-7c0a-446e-3fa6-d5a3239fcf00/public"                      width = "600"                ><h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><ol><li><p><strong>下载 CUDA Toolkit:</strong></p><ul><li>双击下载的 exe 文件开始安装，建议选择默认下载路径以避免后续配置复杂性。</li></ul></li><li><p><strong>安装前的选择:</strong></p><ul><li>如果这是第一次安装 CUDA，建议选择全选以安装所有组件。</li><li>如果之前已安装过 CUDA，建议只选择必要的组件以避免潜在的冲突，通常至少需要选择 Toolkit。</li></ul></li><li><p><strong>临时解压目录:</strong></p><ul><li>安装程序会首先要求设置临时解压目录，建议使用默认设置。安装结束后，该目录会自动删除。</li></ul></li><li><p><strong>安装目录:</strong></p><ul><li>接下来会要求设置安装目录，也建议保持默认。</li><li><strong>注意：</strong> 临时解压目录不应该与 CUDA 的安装路径设置成一样，以避免安装完成后找不到安装目录的问题。</li></ul></li><li><p><strong>环境变量配置:</strong></p><ul><li><p>安装完成后，需要配置 CUDA 的环境变量以便于命令行工具的使用。</p></li><li><p>打开“控制面板” &gt; “系统和安全” &gt; “系统” &gt; “高级系统设置” &gt; “环境变量”。</p></li><li><p>在“系统变量”中找到 Path 变量，点击“编辑”。</p></li><li><p>添加 CUDA Toolkit 的 bin 目录和 libnvvp 目录到 Path 变量中。通常这些目录位于 <code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vX.X\bin</code> 和 <code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vX.X\libnvvp</code>。</p><p><strong>注意：</strong> <code>X.X</code> 应替换为您安装的 CUDA 版本号。</p></li></ul></li><li><p><strong>验证安装:</strong></p><ul><li>打开命令提示符窗口。</li><li>输入 <code>nvcc --version</code> 检查 CUDA 编译器的版本，确认安装成功。</li><li>输入 <code>set cuda</code> 查看 CUDA 设置的环境变量，确保它们被正确设置。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">CUDA安装</summary>
    
    
    
    <category term="人工智能" scheme="https://www.yiuhangblog.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="CUDA" scheme="https://www.yiuhangblog.com/tags/CUDA/"/>
    
    <category term="机器学习" scheme="https://www.yiuhangblog.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>弘玑 Cyclone RPA</title>
    <link href="https://www.yiuhangblog.com/2024/04/01/20240401%E5%BC%98%E7%8E%91Cyclone%20RPA/"/>
    <id>https://www.yiuhangblog.com/2024/04/01/20240401%E5%BC%98%E7%8E%91Cyclone%20RPA/</id>
    <published>2024-04-01T03:44:05.000Z</published>
    <updated>2024-04-02T00:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="弘玑-Cyclone-RPA"><a href="#弘玑-Cyclone-RPA" class="headerlink" title="弘玑 Cyclone RPA"></a>弘玑 Cyclone RPA</h2><h3 id="RPA的特征与业务价值"><a href="#RPA的特征与业务价值" class="headerlink" title="RPA的特征与业务价值"></a>RPA的特征与业务价值</h3><h4 id="什么是RPA"><a href="#什么是RPA" class="headerlink" title="什么是RPA"></a>什么是RPA</h4><p>RPA，全称 “机器人流程自动化” (Robotic Process Automation), 它的核心技术是从自动化测试工具和桌面自动化技术中发展而来的。</p><p>RPA是近些年新兴的一个IT领域，其本质是基于软件的机器人，结合包括AI在内的各项技术，为企业实现业务流程自动化的产品&#x2F;解决方案。</p><h4 id="PRA的特征汇总"><a href="#PRA的特征汇总" class="headerlink" title="PRA的特征汇总"></a>PRA的特征汇总</h4><ul><li>软件机器人</li><li>模拟和替代人工的操作<ul><li>核心能力，比如键盘，鼠标，登录，切换页面和粘贴数据等操作</li></ul></li><li>非侵入式串接不同的系统<ul><li>PRA实现了无缝跨系统的集成</li><li>界面捕捉对象，内容和数据等</li><li>无需改动后端程序，无接口，无需调整数据库结构，表层集成</li></ul></li><li>一组技术的组合<ul><li>屏幕抓取，工作流，流程控制和拖拽等易用性特征</li></ul></li><li>类似工作流的执行能力</li><li>执行的是具有固定规则、工作量大的任务</li><li>快速实施</li></ul><h4 id="RPA客户目标"><a href="#RPA客户目标" class="headerlink" title="RPA客户目标"></a>RPA客户目标</h4><h5 id="节省成本"><a href="#节省成本" class="headerlink" title="节省成本"></a>节省成本</h5><p>结合流程标准化的机会引入机器人工具自动化流程可以至少节省30%-50%</p><h5 id="生产性"><a href="#生产性" class="headerlink" title="生产性"></a>生产性</h5><ul><li>自动化工具最高可提升到人力的5倍工作</li><li>24x7</li><li>人们可以专注更重要的任务</li></ul><h5 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h5><p>通过机器人工具消除人工干预能让处理正确性达到100%</p><h5 id="扩展性-灵活性"><a href="#扩展性-灵活性" class="headerlink" title="扩展性&#x2F;灵活性"></a>扩展性&#x2F;灵活性</h5><ul><li>数字员工可适用于不同地点和流程</li><li>提供可扩展及可协作性</li><li>可通过扩展适应业务的迅速变化</li></ul><h5 id="合规"><a href="#合规" class="headerlink" title="合规"></a>合规</h5><ul><li>可适应区域性数据存储需求</li><li>规则驱动的交易处理可以持续满足财务需求</li><li>全程可追溯，全生命周期日志</li></ul><h5 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h5><ul><li>不会有因为人工干预丢失数据的风险</li><li>全程无人干预，可以进行</li><li>保密数据的传输可按需设定安全权限</li></ul><h2 id="Cyclone-RPA-三件套协同工作"><a href="#Cyclone-RPA-三件套协同工作" class="headerlink" title="Cyclone RPA 三件套协同工作"></a>Cyclone RPA 三件套协同工作</h2><h3 id="数字员工执行器"><a href="#数字员工执行器" class="headerlink" title="数字员工执行器"></a>数字员工执行器</h3><ul><li>根据脚本自动完成所需的业务处理</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1f7fcb60-e068-4bd2-ab10-085acc8a0a00/public"                      width = "600"                ><h3 id="数字员工设计器"><a href="#数字员工设计器" class="headerlink" title="数字员工设计器"></a>数字员工设计器</h3><ul><li>设计开发自动化流程文件</li><li>脚本文件</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/74955dfa-75fb-45a0-a45e-667ab7fd8b00/public"                      width = "600"                ><h3 id="数字员工中央控制台"><a href="#数字员工中央控制台" class="headerlink" title="数字员工中央控制台"></a>数字员工中央控制台</h3><ul><li>管理流程的运行</li><li>监控任务的完成和记录相关的数据等</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/20edd193-4423-446c-0e1c-530b2a343c00/public"                      width = "600"                ><h3 id="组件流程"><a href="#组件流程" class="headerlink" title="组件流程"></a>组件流程</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ca75090e-7d97-4130-6987-79a19a6f3400/public"                      width = "600"                ><h3 id="无人值守自动化"><a href="#无人值守自动化" class="headerlink" title="无人值守自动化"></a>无人值守自动化</h3><p>无需人工参与的自动化</p><p>如绝大多数重复性文本核对工作</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/81ca24b4-678a-4d08-bd4d-f20663a6f000/public"                      width = "600"                ><h3 id="有人值守自动化"><a href="#有人值守自动化" class="headerlink" title="有人值守自动化"></a>有人值守自动化</h3><p>人与机器人协同工作</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e9c80cfb-f00f-49e9-bd16-262c866ae600/public"                      width = "600"                ><h3 id="Cyclone-RPA-应用场景"><a href="#Cyclone-RPA-应用场景" class="headerlink" title="Cyclone RPA 应用场景"></a>Cyclone RPA 应用场景</h3><h4 id="财务"><a href="#财务" class="headerlink" title="财务"></a>财务</h4><ul><li>财务录入</li><li>报告生成</li><li>财务核对</li><li>银行对账</li><li>账户查询提醒</li><li>应收账款处理</li><li>应付账款</li><li>账户结算</li><li>纳税申报</li><li>费用报销</li></ul><h4 id="人力资源"><a href="#人力资源" class="headerlink" title="人力资源"></a>人力资源</h4><ul><li>招聘管理</li><li>简历收集及筛选</li><li>入职及离职</li><li>考勤管理</li><li>员工数据管理</li><li>报告生成</li><li>薪酬管理</li><li>培训管理</li></ul><h4 id="供应链"><a href="#供应链" class="headerlink" title="供应链"></a>供应链</h4><ul><li>订单处理</li><li>供应商对账</li><li>主数据管理</li><li>第三方平台对账</li><li>内部对账</li><li>货单处理</li><li>库存管理</li><li>采购管理</li><li>凭证录入</li><li>关账与报表合并</li></ul><h4 id="IT"><a href="#IT" class="headerlink" title="IT"></a>IT</h4><ul><li>用户权限管理</li><li>密码重置&#x2F;解锁系统监控</li><li>系统运维|信息抓取</li><li>工单处理|邮件分发</li><li>网络信息抓取</li><li>数据清洗</li><li>数据导入批处理</li><li>数据备份与恢复</li><li>Helpdesk热线</li></ul><h4 id="银行"><a href="#银行" class="headerlink" title="银行"></a>银行</h4><ul><li>账单核对</li><li>征信查询</li><li>信用卡积分管理</li><li>对公账户信息录入</li><li>资质审核|信用凭证自动化</li><li>经销商发票勾兑</li><li>业务对账</li><li>验证贷款申请</li></ul><h4 id="保险"><a href="#保险" class="headerlink" title="保险"></a>保险</h4><ul><li>录入业务账单</li><li>客户服务</li><li>承保合规性</li><li>优化客户理赔体验</li><li>账单处理</li><li>收益分析及计算</li><li>每日战报</li></ul><h3 id="经典落地场景"><a href="#经典落地场景" class="headerlink" title="经典落地场景"></a>经典落地场景</h3><h4 id="账单录入"><a href="#账单录入" class="headerlink" title="账单录入"></a>账单录入</h4><ul><li>客户类型：某保险公司</li><li>适用部门:账单部门</li><li>业务内容:根据账单部门收到的格式不一的账单，整理并录入业务核心系统，并发送邮件报告</li><li>工作量:1000~2000 张账单&#x2F;月</li><li>使用效果:月末账单录入时间大大减少，提升50%账单录入速度，零错误率</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8bce5f54-b990-4413-dc75-67bca7e47300/public"                      width = "600"                ><h2 id="设计器安装"><a href="#设计器安装" class="headerlink" title="设计器安装"></a>设计器安装</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/65e354e9-a0df-463d-68a0-2322e5225e00/public"                      width = "100"                ><p>Cyclone Log Viewerd 当流程使用 Cyclone Server运行时，选择了输出日志，此时Cyclone Server 会输出日志文件，Cyclone Log Viewerd查看日志文件内容。</p><p>Cyclone Server用来执行流程，添加触发器以及查看流程运行记录。</p><p>Cyclone Starter流程设计器，RPA流程的开发，设计都可以在此程序中完成，同时，支持自定义组件可以更好的支持定制化流程。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>安装完成后，双击Cyclone Starter启动设计器。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>注意以管理员身份运行</p>    </div>  </div><h3 id="流程版本管理与发布"><a href="#流程版本管理与发布" class="headerlink" title="流程版本管理与发布"></a>流程版本管理与发布</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6efd27ed-6e08-4afc-b968-5ad8a8daca00/public"                      width = "600"                ><h3 id="流程mrpax文件的命名"><a href="#流程mrpax文件的命名" class="headerlink" title="流程mrpax文件的命名"></a>流程mrpax文件的命名</h3><ul><li>发布后的流程mrpax文件的命名模式并不唯一但至少应当考虑明确其环境信息。</li><li>推荐使用类似的命名方式:【客户名称简写】【环境简称】【流程业务简称】.mrpax<ul><li>如:中石化云南 UAT 企业账户费用核销.mrpax格力珠海 Prod 客户应收应付日报 20210702.mrpax</li></ul></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>流程是应用的组成单元，一个流程包含一系列顺序执行的指令。流程之间可以相互调用。在应用运行时，会从主流程开始执行，并顺序执行主流程中包含的指令和调用的子流程。主流程不可被删除。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是指一个变量存在或可被使用的范围。如全局变量的可被使用范围是整个应用，而在循环中插入的变量，可被使用的范围仅是当前循环中。在变量所在域之外，变量会被回收。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>指令&#x2F;组件是流程的组成单元，也是RPA最基本的组成单元。每一个指令对应一个具体的计算机操作动作。如“打开Excel文件”、“获取元素文本内容”，“条件判断”等。<br>指令分为内置指令、外置指令和市场指令三种。内置指令随客户端版本一一起更新，外置指令可以在切换应用时动态加载不同的版本，也可以在指令管理面板手动切换版本。市场指令是从指令市场获取的指令，可以在指令管理面切换版本或删除。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>内存中的一块空间存储某个值，空间中存储的值是可以改变的，这个空间就是变量。简单的说，就是给应用和流程中用到的数据取一个名字，在流程中可以通过名字使用这个数据。变量中可以储存数字、字符串、列表等类型的数据，也可以储存数据表格、excel、页面元素等具有复杂结构的数据。变量分为全局变量和局部变量，全局变量可以在整个应用范围内被引用。而局部变量可在流程中任意位置插入，在插入位置之后，在当前变量的所在域中，可以被使用。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数是一种特殊的变量，是数据传递的介质。应用输入参数是在应用运行前，需要用户输入的数据。参数也可以用来在应用与应用之间，或流程与流程之间进行数据传递。不过，在流程之间传递数据也可以通过全局变量来实现。</p><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><p>元素（或界面元素）是一种特殊的变量类型。在工作易RPA中，元素特指通过UI自动化（捕获）的方式，从浏览器或桌面软件中指定的一个目标，获取其特征和截图，以对其进行后续的查找和操作。</p><h2 id="设计器特性"><a href="#设计器特性" class="headerlink" title="设计器特性"></a>设计器特性</h2><h3 id="设计器的产品目标与特性"><a href="#设计器的产品目标与特性" class="headerlink" title="设计器的产品目标与特性"></a>设计器的产品目标与特性</h3><p>让用户更轻松、更快速地在不需要编写代码的情况下完成RPA流程的开发设计，并为机器人赋予更强大的自动化能力。</p><h4 id="图形化开发"><a href="#图形化开发" class="headerlink" title="图形化开发"></a>图形化开发</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b8b7605b-67ed-4a59-1ff8-2e71f6256900/public"                      width = "600"                ><p>设计器提供了图形化界面，所有的节点都通过节选或者配置参数的方式完成设计，同时它的调试模式提供断点，单步调试，变量值显示，实时语法检查等辅助功能，帮助用户加速开发，设计器界面自动化支持跨平台跨系统，自动化操作各种架构的第三方产品和文档，且支持开发导入自定义组件，以供流程开发调用</p><h3 id="设计器工程模式简介"><a href="#设计器工程模式简介" class="headerlink" title="设计器工程模式简介"></a>设计器工程模式简介</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/90344080-957b-4130-29bf-60d797cc5000/public"                      width = "600"                ><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>将会创建一个<code>json</code>包文件和<code>flow</code>流程文件</p><h4 id="打开项目"><a href="#打开项目" class="headerlink" title="打开项目"></a>打开项目</h4><p>可以打开<code>json</code>包文件和<code>flow</code>流程文件，将跳转到设计器设计界面</p><h4 id="升级旧流程"><a href="#升级旧流程" class="headerlink" title="升级旧流程"></a>升级旧流程</h4><p>可以将旧版本的<code>mrpa</code>文件升级成<code>flow</code>文件，若出现<code>cyclone-upgrader-errs.json</code>则说明有需要修改的地方</p><h3 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h3><h4 id="标题栏"><a href="#标题栏" class="headerlink" title="标题栏"></a>标题栏</h4><ol><li>标题栏主要用于展示项目名称，当项目打开后会显示当前项目的名称。</li><li>如果是初始状态，标题栏展示为开始。</li></ol><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>首页</td><td>回到首页</td></tr><tr><td>工程</td><td>回到当前工程</td></tr><tr><td>调试</td><td>调试当前流程。详细信息参见：<a class="link"   href="http://commutity-rk1daf-1307453084.cos.ap-shanghai.myqcloud.com/ae93d1ff-f5b7-4026-8842-942fc434d85f_" >调试 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 说明。</td></tr><tr><td>设置选项</td><td>个性化系统设置</td></tr><tr><td>收起</td><td>收起&#x2F;展开工程资源栏</td></tr><tr><td>连接中心</td><td>与控制中心，应用市场，卓越中心连接</td></tr></tbody></table><h4 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h4><p> 工具栏主要集成想项目开发中所用的工具。</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td><strong>新建</strong></td><td>新建RPA项目</td></tr><tr><td><strong>保存</strong></td><td>保存更改后的流程。</td></tr><tr><td><strong>发布</strong></td><td>RPA项目发布，打包。详细信息参见：<a class="link"   href="http://commutity-rk1daf-1307453084.cos.ap-shanghai.myqcloud.com/e7974945-c78a-47e6-8677-af816a97ecd0_" >发布 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 说明。</td></tr><tr><td><strong>运行</strong></td><td>运行流程。</td></tr><tr><td><strong>调试</strong></td><td>对流程进行调试修改。</td></tr><tr><td><strong>撤销</strong></td><td>回退上一步操作。</td></tr><tr><td><strong>重做</strong></td><td>恢复上一步操作。</td></tr><tr><td><strong>清空</strong></td><td>清空画布中所有组件</td></tr><tr><td><strong>组件管理</strong></td><td>安装、卸载、更新等管理外部组件，同时支持用户自定义组件。</td></tr><tr><td><strong>安装扩展</strong></td><td>安装一些辅助类的插件，如浏览器扩展，键盘驱动等。</td></tr><tr><td><strong>录屏</strong></td><td>通过记录用户在界面的操作记录，并将这些记录生成流程</td></tr><tr><td><strong>数据抓取</strong></td><td>批量抓取结构化数据与表格数据。详细信息参见：数据抓取 说明。</td></tr><tr><td><strong>Cyclone 浏览器</strong></td><td>设计器自带的浏览器，若开发时没有浏览器可以选择此浏览器作为支持。</td></tr><tr><td><strong>UI解析器</strong></td><td>捕获到的元素的详细信息展示和修改。详细信息参见：UI解析器 说明。</td></tr></tbody></table><h4 id="下边栏"><a href="#下边栏" class="headerlink" title="下边栏"></a>下边栏</h4><p>下边栏主要包含三个选项卡</p><p>变量管理：方便的统一管理变量、如创建、修改、删除、筛选变量，查看异常提示、引用信息。详细信息参见：<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=36434cd4-7e52-4728-9b55-96e8c7b5b78b" >变量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 说明。</p><p>运行日志：通过此窗口查看流程运行的重要节点信息。</p><p>参数管理：管理参数的传递方向，类型，默认值等。 详细信息参见：<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=93ec83fa-b3d0-4ad8-8e66-e45a466ce8b6" >参数 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 说明。</p><h4 id="属性面板"><a href="#属性面板" class="headerlink" title="属性面板"></a>属性面板</h4><p>用户可以在属性面板区域编辑画布对应节点的输入输出信息。<br>属性面板展示内容如下：</p><ol><li>节点名称（用户可以自定义）；</li><li>节点编号（节点的唯一标识）；</li><li>节点描述；</li><li>节点输入；</li><li>节点输出；</li><li>节点设置（部分节点有）</li></ol><p>对于属性面板的输入框，点击如所示EXP按钮可以切换表达式模式和值模式：</p><ol><li>表达式模式：支持引用变量，支持语法糖，支持表达式；</li><li>值模式：支持直接输入字符，不用转义。（举例：输入姓名的字符串，如为表达式模式，应输入”张三“，如为值模式，应输入张三）</li></ol><h4 id="导入流程"><a href="#导入流程" class="headerlink" title="导入流程"></a>导入流程</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9810d33d-5ce9-4891-f853-17f64e4c9c00/public"                      width = "600"                ><p>项目之外的流程文件</p><h4 id="导入资源文件"><a href="#导入资源文件" class="headerlink" title="导入资源文件"></a>导入资源文件</h4><p>Excel，图片等资源文件</p><h4 id="组件管理"><a href="#组件管理" class="headerlink" title="组件管理"></a>组件管理</h4><p>额外拓展自定义等</p><h4 id="自动化流程演示"><a href="#自动化流程演示" class="headerlink" title="自动化流程演示"></a>自动化流程演示</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c609b024-19b3-4747-0d1f-015ed9a75b00/public"                      width = "600"                ><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul><li>可自动获取外部参数、局部变量的当前值。</li><li>支持编辑变量的当前值</li><li>修改后的变量值对还未调试的节点生效。</li><li>支持可视化编辑日期时间、数组、对象变量的当前值。</li></ul><h2 id="完整搭建一个流程"><a href="#完整搭建一个流程" class="headerlink" title="完整搭建一个流程"></a>完整搭建一个流程</h2><h3 id="新建流程"><a href="#新建流程" class="headerlink" title="新建流程"></a>新建流程</h3><ol><li><p>在设计器界面中点击“新建项目”按钮，开始创建项目。</p></li><li><p>在 <strong>创建项目</strong> 面板中，填写项目名称和存放目录，点击“确定”按钮。</p><ul><li>项目名称* - 输入项目名称，项目名称不能为空。</li><li>项目存放目录* - 将在项目存放的目录下自动创建与项目同名的文件夹。</li></ul><blockquote><p>*代表必填项</p></blockquote></li><li><p>点击“打开主流程”按钮①，在主流程中添加组件；或点击“新建流程”按钮②，新建子流程，在子流程中可以添加组件。以打开主流程为例。</p></li><li><p>在主流程的面板中点击“添加组件”按钮①，打开组件库；或在面板左侧点击“组件库”②，切换到组件库。以点击“添加组件”按钮为例。</p></li><li><p>在组件库中展开需要的模块来添加组件，组件库中的组件模块包括界面自动化、Excel、数据处理、逻辑处理、系统功能、应用自动化、数据库、人机交互、网络协议、其他组件、中控、集成模块。也可以在搜索框中搜索特定的组件。</p><blockquote><p>注意：<br>在面板左侧组件库中右键后点击“加入收藏”的组件，会被收入 <strong>我的收藏</strong> 模块。<br>最近使用过的组件，会被收入 <strong>最近使用</strong> 模块。</p></blockquote></li><li><p>找到需要的组件，点击组件加入流程。以 <strong>打开浏览器</strong>、<strong>输入文本</strong>为例。</p></li><li><p>点击组件面板，填写组件属性。例如在 <strong>打开浏览器</strong> 组件中，选择浏览器类型，填写网页路径、进程号等。</p></li><li><p>部分组件可能需要捕获元素，例如在 <strong>输入文本</strong> 组件中，点击目标元素的坐标按钮，进入常规捕获模式。</p></li><li><p>将鼠标移至需要捕获元素的位置，使用Ctrl+鼠标左键组合确认捕获，捕获目标元素后在组件属性中可以回显。</p></li></ol><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><ol><li><p>填写完所有组件的属性后，点击“运行”按钮，运行流程。</p><p>默认为运行全流程。下拉可以选择以下三项：</p><ul><li>运行当前流程，快捷键为Ctrl+F6</li><li>运行全流程，快捷键为Ctrl+F5</li><li>画中画运行全流程</li></ul></li><li><p>运行成功时系统会显示 “Cyclone Starter 运行成功”。</p></li></ol><h3 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h3><ol><li><p>在设计器界面中点击“调试”按钮，开始调试流程。</p><p>默认为调试全流程。下拉可以选择以下二项：</p><ul><li>调试当前流程，快捷键为F8</li><li>调试全流程，快捷键为F7</li></ul></li><li><p>在调试界面中，可进行详细操作。在左侧蓝色导航栏可切换到主页或设计界面。</p><ul><li><p>开始 - 开始调试流程，快捷键为F8</p></li><li><p>停止 - 调试过程中点击“停止”，停止调试，关闭调试界面，快捷键为Ctrl+F12</p></li><li><p>单步调试 - 点击后调试单个组件，调试后暂停，再点击调试下一个组件，快捷键为F11</p></li><li><p>运行日志 - 点击后跳转到运行日志所在文件夹</p></li><li><p>调速 - 可选择以下四种速度，默认为快速</p><table><thead><tr><th>速度</th><th>延时时间</th></tr></thead><tbody><tr><td>慢速</td><td>1000ms</td></tr><tr><td>正常</td><td>500ms</td></tr><tr><td>快速</td><td>0ms</td></tr><tr><td>自定义</td><td>可填写</td></tr></tbody></table></li></ul></li></ol><h3 id="保存流程"><a href="#保存流程" class="headerlink" title="保存流程"></a>保存流程</h3><ol><li><p>如果需要保存流程，在面板中点击“保存”按钮。</p><p>默认为保存当前文件。下拉可以选择以下二项：</p><ul><li>保存当前文件 - 保存当前界面中的流程文件</li><li>保存全部 - 保存打开的全部流程文件</li></ul></li></ol><h3 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h3><ol><li><p>在设计器界面中点击“发布”按钮，开始发布流程。</p></li><li><p>在发布项目界面中，可以进行多项内容的填写与修改。</p><p>其中项目信息①和发布者身份②，需点击按钮进行子页面填写。</p></li><li><p>在项目信息界面中，可进行项目名称、项目简介、使用说明的填写。</p><ul><li>项目名称* - 默认为新建项目时填写的项目名称</li><li>项目简介* - 输入项目简介</li><li>使用说明* - 输入使用说明</li></ul></li><li><p>在 <strong>导出</strong> 模块中，可进行是否导出至本地的选择、存储路径的选取。</p><ul><li>导出至本地 - 是否导出至本地，可选择启用或不启用，默认为启用</li><li>存储路径 - 可点击按钮后进行选取</li></ul></li><li><p>在 <strong>发布</strong> 模块中，可进行发布者身份、是否发布至中控的修改。</p><ul><li>发布者身份 - 点击 <strong>连接中心</strong> 或修改按钮，进入 <strong>Designer Pro 连接中心</strong> 界面</li><li>发布至中控 - 是否发布至中控，可选择启用或不启用，默认为不启用</li></ul></li><li><p>在 <strong>版本信息</strong> 模块中，可进行发布版本的选择、发布说明的填写。</p><ul><li><p>发布版本 - 可以根据当前版本号，选择以下四种版本号（以当前版本1.0.0为例）：</p><table><thead><tr><th>发布版本</th><th>版本号</th><th>备注</th></tr></thead><tbody><tr><td>当前版本</td><td>1.0.0</td><td>默认选择项</td></tr><tr><td>修订版</td><td>1.0.1</td><td>修复问题，且兼容上一版本时，建议选择此版本</td></tr><tr><td>次版本</td><td>1.1.0</td><td>新增功能，且兼容上一版本时，建议选择此版本</td></tr><tr><td>主版本</td><td>2.0.0</td><td>产生不兼容的修改时，建议选择此版本</td></tr></tbody></table></li><li><p>发布说明* - 输入发布说明</p></li></ul></li><li><p>填写完发布项目的信息后，点击“更新项目信息并发布”按钮。</p></li><li><p>流程发布成功后，会反馈发布结果，点击“完成”按钮，完成发布流程。</p></li></ol><h2 id="如何录制一个流程"><a href="#如何录制一个流程" class="headerlink" title="如何录制一个流程"></a>如何录制一个流程</h2><ol><li>在流程面板中点击“录制”按钮，开启智能录制。</li><li>在智能录制面板中，点击“开始”按钮，开始录制。</li><li>开始智能录制后，进行需要录制的操作，操作动作会被记录，自动生成流程。能在智能录制的面板中看到记录的操作动作。</li><li>在智能录制面板中，点击“暂停”按钮或使用Esc键暂停录制①；点击“确定”按钮完成录制②；点击“取消”按钮取消录制③.</li><li>完成智能录制后，能在面板中看到 <strong>录屏流程</strong> 组件。</li><li>可展开 <strong>录屏流程</strong> 组件，双击查看其中的子流程。</li><li>在子流程面板中可以对录制的子流程进行修改，也可以点击“主流程”按钮返回 <strong>录制流程</strong> 组件所在的主流程。</li></ol><h2 id="从模板新建流程"><a href="#从模板新建流程" class="headerlink" title="从模板新建流程"></a>从模板新建流程</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>越来越复杂的业务场景，需要更完善的企业级流程架构应对，企业级流程模板是从复杂项目中总结出的最佳实践，它有：</p><ol><li>更完善的异常处理机制，增强流程稳定性</li><li>更统一的业务逻辑流程，易于后期运维</li></ol><h3 id="功能入口"><a href="#功能入口" class="headerlink" title="功能入口"></a>功能入口</h3><p>首页-从模板新建-企业级流程模板</p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ol><li>从模板中新建项目中选择“企业级流程模板”，写好项目名称等信息 即可基于模板建立一个新的项目</li><li>进入新建好的项目，可以看到模板中已有的流程框架，可按需继续编辑流程</li><li>也支持导入一个本地流程作为自定义模板</li><li>可以从官方市场中获取更多流程作为模板，点击“浏览更多模板”将在默认浏览器中前往官方市场</li></ol><h3 id="已知限制"><a href="#已知限制" class="headerlink" title="已知限制"></a>已知限制</h3><ol><li>自定义模板功能不支持导入 使用低于该版本的设计器写的流程 作为模板（比如用4.0写的流程文件不能导入到4.3的设计器作为自定义模板），建议您先升级您的流程后再导入</li></ol><h2 id="流程模式"><a href="#流程模式" class="headerlink" title="流程模式"></a>流程模式</h2><h3 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h3><p>序列图分为流程模式和行模式，流程模式以图形的方式展示节点，能直观的看到画布上的节点信息，且部分节点支持在画布上操作，而行模式同样大小的画布能够容纳更多的节点信息，双方各有优劣。</p><h4 id="流程模式-1"><a href="#流程模式-1" class="headerlink" title="流程模式"></a>流程模式</h4><h5 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h5><p>流程模式以图形化，可视化的方式展示画布上的节点，能够直观的看到节点与节点之前间的逻辑关系和层级。</p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>任何需要用到序列图画布的场景</p><h4 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h4><h5 id="1-插入节点"><a href="#1-插入节点" class="headerlink" title="1. 插入节点"></a>1. 插入节点</h5><p>现插入节点有2种方式：从画布中插入和拖动组件库节点至画布，具体场景如下：</p><ol><li>从组件库插入：拖动插入或双击插入即可。</li><li>在画布上点击加号插入：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/aa26d620-e041-43b4-7c99-ba7660271d00/public"                      width = "600"                ><h5 id="2-插入注释"><a href="#2-插入注释" class="headerlink" title="2. 插入注释"></a>2. 插入注释</h5><p>支持选中节点后右键插入注释</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4c655023-742f-4f84-dddc-086026e5cd00/public"                      width = "600"                ><h3 id="行模式"><a href="#行模式" class="headerlink" title="行模式"></a>行模式</h3><h4 id="功能描述-1"><a href="#功能描述-1" class="headerlink" title="功能描述"></a>功能描述</h4><p>行模式画布类似大纲，将节画布中的节点信息按行展示，这样可以在一屏中展示更多的信息。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>任何需要用到序列图画布的场景</p><h4 id="使用说明-2"><a href="#使用说明-2" class="headerlink" title="使用说明"></a>使用说明</h4><h5 id="1-功能入口"><a href="#1-功能入口" class="headerlink" title="1. 功能入口"></a>1. 功能入口</h5><p>开启行模式画布，点击如图所示按钮即可开启</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9237e317-a7fe-4268-f7df-6c7f2ebd6300/public"                      width = "600"                ><h5 id="2-插入节点："><a href="#2-插入节点：" class="headerlink" title="2. 插入节点："></a>2. 插入节点：</h5><p>现插入节点有2种方式：从画布中插入和拖动组件库节点至画布，具体场景如下：</p><ol><li>从组件库插入：拖动插入即可。</li><li>在画布上同层级插入：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7a65114c-a0f9-4e45-159c-b40b6be0a400/public"                      width = "600"                ><ol start="3"><li>IF中插入更多条件：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6d312bce-c338-47ad-2f3c-cae17e66b800/public"                      width = "600"                ><ol start="4"><li>从画布末尾插入</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/35023249-3e58-409a-210a-c071c9671000/public"                      width = "600"                ><h5 id="3-画布视图调整："><a href="#3-画布视图调整：" class="headerlink" title="3. 画布视图调整："></a>3. 画布视图调整：</h5><ol><li>支持调整百分比；</li><li>支持收起或展开有层级的节点；</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3a5fa475-64dd-4db1-bed0-fd64dcb28600/public"                      width = "600"                ><ol><li>其他功能与序列图流程模式一致。</li></ol><h5 id="3-插入批注："><a href="#3-插入批注：" class="headerlink" title="3. 插入批注："></a>3. 插入批注：</h5><p>可通过选中节点右键添加批注</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8a8f95af-f936-416d-e892-dc33a1e71c00/public"                      width = "600"                ><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="功能描述-2"><a href="#功能描述-2" class="headerlink" title="功能描述"></a>功能描述</h3><p>用流程图画布，绘制流程图，并通过序列画布实现流程图中的流程节点，从而完成项目的开发。</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>流程图画布适用于较为复杂的多个节点按序重试、多判断、多分支的流程。</p><h3 id="使用说明-3"><a href="#使用说明-3" class="headerlink" title="使用说明"></a>使用说明</h3><h4 id="1-开启实验室功能"><a href="#1-开启实验室功能" class="headerlink" title="1. 开启实验室功能"></a>1. 开启实验室功能</h4><p>因流程图画布属于实验室功能，故应先开启功能，开启路径为 设置-实验室功能-启用实验功能。</p><h4 id="2-创建流程图画布"><a href="#2-创建流程图画布" class="headerlink" title="2. 创建流程图画布"></a>2. 创建流程图画布</h4><p>现流程图画布有2个入口：<br>1） 新建空白项目后如画布未添加任何组件，可在画布区域右上角切换为流程图画布；<br>2）新建文件可新建流程图文件。</p><h4 id="3-绘制流程图"><a href="#3-绘制流程图" class="headerlink" title="3. 绘制流程图"></a>3. 绘制流程图</h4><p>1） 绘制节点，可在左侧功能栏-组件库中选择相应节点拖拽至画布即可完成节点绘制（现仅支持流程块，流程判断及流程决策节点）；<br>2） 绘制连线：点击流程节点出口连接处，鼠标左键按下并拖拽至其他流程节点入口连接处即可完成连线绘制；</p><h4 id="4-流程节点实现"><a href="#4-流程节点实现" class="headerlink" title="4. 流程节点实现"></a>4. 流程节点实现</h4><p>双击流程块，可进入序列画布页面，使用流程序列完成流程节点实现。</p><h4 id="5-运行与调试"><a href="#5-运行与调试" class="headerlink" title="5. 运行与调试"></a>5. 运行与调试</h4><p>流程图的调试运行功能与序列流程基本一致，支持运行当前流程&#x2F;全流程、调试当前流程&#x2F;全流程，流程图组件暂不支持【调试当前节点】或【从当前节点开始调试】</p><h2 id="代码模式"><a href="#代码模式" class="headerlink" title="代码模式"></a>代码模式</h2><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>对于有代码基础的用户，为了提高开发效率，许多场景可通过写代码的方式实现，如</p><ol><li>流程中有很多数据处理任务，使用组件开发比较麻烦，效率较低</li><li>一些需要调用三方包的功能，如Excel、pdf接口调用等</li><li>编写爬虫等脚本文件</li><li>调用已有的代码文件</li></ol><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><ol><li>设计器在安装时，会自动内置代码运行环境，与电脑中的python&#x2F;js环境无关</li><li>设计器中内置的python环境为：python 3.8.10，js环境为：node-v12</li></ol><p><strong>详细内容参照：<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=7af1eac5-dac5-4342-b3b8-6d2ad45e091e" >代码模式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p><h2 id="流程编辑"><a href="#流程编辑" class="headerlink" title="流程编辑"></a>流程编辑</h2><h3 id="工程模式"><a href="#工程模式" class="headerlink" title="工程模式"></a>工程模式</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>工程模式，就是把一个项目当成一个project（相当于现在的一个mrpa）</p><ul><li>项目相关资源组织成文件夹，包括流程文件、资源文件、package.json等</li><li>将大流程拆分成若干子文件，在需要时进行调用</li></ul><h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p><strong>子流程复用，联调</strong></p><ul><li>建议将大的流程拆分成多个流程文件，进行单独调试、运行。规避变量过多，解决难于阅读和调试的问题，同时增强文件的复用性。</li></ul><h4 id="主流程结构更加清晰"><a href="#主流程结构更加清晰" class="headerlink" title="主流程结构更加清晰"></a>主流程结构更加清晰</h4><ul><li>主流程结构不再受线性条件的限制，可以在条件判断、循环中使用</li><li>建议大家把整体的流程逻辑放在主流程中，然后用不同的流程文件进行组合。未来会推出模版，配合流程图模式，规范大家的流程结构，增强可读性。</li></ul><h4 id="资源文件管理"><a href="#资源文件管理" class="headerlink" title="资源文件管理"></a>资源文件管理</h4><ul><li><p>一些在项目中使用到的文件，比如“图片”，“excel文件“等，如果希望未来该文件可以随着项目一起发布，可将其作为项目需要的资源文件，加入到项目中。</p></li><li><p>对于已捕获的组件，重新捕获后，之前捕获的图片如果不再使用，可以进行删除</p></li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol><li>可被复用的节点片段建议拆成单个流程，每个流程单独编写、单独调试通过。</li><li>建议每个流程文件不超过100个节点</li><li>每个流程文件的功能尽量单一，清晰</li></ol><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><h5 id="入口流程"><a href="#入口流程" class="headerlink" title="入口流程"></a>入口流程</h5><p>项目文件默认从main.flow开始执行</p><h5 id="将流程文件加入到流程中"><a href="#将流程文件加入到流程中" class="headerlink" title="将流程文件加入到流程中"></a>将流程文件加入到流程中</h5><p>请在流程中使用“引入流程文件”节点。</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>注：该节点只能引用项目文件夹内部的流程（如果需要引入项目外的流程文件，需要先将其导入）</p>    </div>  </div><h5 id="导入外部流程文件"><a href="#导入外部流程文件" class="headerlink" title="导入外部流程文件"></a>导入外部流程文件</h5><p>如果需要使用来自外部的流程文件，需要先将其进行导入，再在流程中使用“引入流程文件”节点。</p><ul><li>支持导入.flow格式的流程文件</li></ul><h5 id="导入含有依赖的流程文件的处理方式"><a href="#导入含有依赖的流程文件的处理方式" class="headerlink" title="导入含有依赖的流程文件的处理方式"></a>导入含有依赖的流程文件的处理方式</h5><p>如果从外部导入了流程1，然后流程1中又使用了”引入流程文件“，引入了流程2，在导入流程1时，需要做如下操作：</p><p>1、将其依赖的”流程2“也导入到本项目中</p><p>2、将流程1中”引入流程文件“的节点进行修改，重新引入一下流程2</p><p>一些在项目中使用到的文件，比如“图片”，“excel文件“等，如果希望未来该文件可以随着项目一起发布，可将其作为项目需要的资源文件，加入到项目中。</p><p>1、导入资源文件</p><p>在“+”号处，选择“导入资源文件”</p><p>2、使用资源文件</p><p>1）在画布中，使用“引入资源文件节点”，选择该资源文件，将文件路径输出为一个变量</p><p>2）在需要用到文件路径的地方，使用该变量</p><p>3、查看和编辑资源文件(使用当前系统中默认的打开方式打开该文件)</p><h3 id="代码模式-1"><a href="#代码模式-1" class="headerlink" title="代码模式"></a>代码模式</h3><h4 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h4><h5 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h5><p>对于有代码基础的用户，为了提高开发效率，许多场景可通过写代码的方式实现，如</p><ol><li>流程中有很多数据处理任务，使用组件开发比较麻烦，效率较低</li><li>一些需要调用三方包的功能，如Excel、pdf接口调用等</li><li>编写爬虫等脚本文件</li><li>调用已有的代码文件</li></ol><h5 id="环境介绍-1"><a href="#环境介绍-1" class="headerlink" title="环境介绍"></a>环境介绍</h5><ol><li>设计器在安装时，会自动内置代码运行环境，与电脑中的python&#x2F;js环境无关</li><li>设计器中内置的python环境为：python 3.8.10，js环境为：node-v12</li></ol><h5 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h5><h6 id="创建代码文件"><a href="#创建代码文件" class="headerlink" title="创建代码文件"></a>创建代码文件</h6><ol><li>支持创建py文件、js文件、Mjs文件（会比javaScript更加规范的一种语言）</li><li>两个入口可以新建代码文件，项目面板和标签栏</li></ol><p>创建完成后，项目面版会新增一个代码文件，并且会在标签页中自动打开</p><h5 id="定义输入输出参数"><a href="#定义输入输出参数" class="headerlink" title="定义输入输出参数"></a>定义输入输出参数</h5><h6 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h6><p>当代码文件需要和其他流程文件进行数据交互时，需要定义输入输出参数</p><p>定义完成后，当使用“调用代码块”进行调用时，需要传递相应的出入参数</p><h6 id="功能描述："><a href="#功能描述：" class="headerlink" title="功能描述："></a>功能描述：</h6><ul><li>支持多个输入参数和一个输出参数</li><li>不同语言的定义方法不同，示例如下：</li></ul><p>一个函数需要两个数字类型入参a,b和一个数字类型的出参，不同语言的写法如下：</p><ul><li><p>python文件</p><ul><li>支持的数据类型：float、bool、str、dict</li></ul></li><li><p>js文件</p><ul><li>支持的数据类型：js语言支持的所有类型</li></ul></li><li><p>Mjs文件</p><ul><li>支持的数据类型：Mjs语言支持的所有类型</li></ul></li></ul><h5 id="编写代码文件"><a href="#编写代码文件" class="headerlink" title="编写代码文件"></a>编写代码文件</h5><p>设计器提供了内置代码编辑器</p><p>代码编辑器功能：</p><p>python:支持语法着色、自动补全、语法提示等功能；</p><p>JS&#x2F;MJS：支持错误提示、语法着色、自动补全、语法提示等</p><h5 id="调用代码文件"><a href="#调用代码文件" class="headerlink" title="调用代码文件"></a>调用代码文件</h5><p>在流程文件中调用：使用组件”调用代码块”</p><p>使用提醒：当选择脚本路径后，需要点击“刷新文件”，再选择方法名称</p><p>在代码块中调用：直接使用import，和写代码一致</p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>若在代码编辑中有需要用到外部包，请在包管理工具中导入。请参考<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=03a55330-eaf8-40af-920d-70fda0b04e23" >代码包管理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>    </div>  </div><h3 id="参数管理"><a href="#参数管理" class="headerlink" title="参数管理"></a>参数管理</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>参数：是用于流程被调用或者执行时与外部进行数据传递，比如<ul><li>在设计器的主流程中引用其他flow流程时，通过输入输出参数进行数据传递</li><li>在执行器或中控上执行流程时，通过输入输出参数进行数据传递</li></ul></li></ul><h4 id="新建参数"><a href="#新建参数" class="headerlink" title="新建参数"></a>新建参数</h4><ol><li>新建输入&#x2F;输出参数：</li></ol><ul><li>右键点击输入&#x2F;输出参数，在右键菜单中选择“新建参数”</li><li>选中输入或输出参数下的其中一个参数后，点击“+”按钮</li></ul><h4 id="编辑参数"><a href="#编辑参数" class="headerlink" title="编辑参数"></a>编辑参数</h4><ol><li>有两种方式可以编辑您的参数</li></ol><ul><li>悬停在某个参数时，会出现一个编辑图标按钮，点击按钮即可打开编辑页面</li><li>右键点击某参数，右键菜单中选择“编辑参数”</li></ul><ol><li>可设置参数的名称、参数类型、初始值、参数描述</li><li>注意输出参数不支持设置初始值，因为输出参数应当是在流程中对它进行赋值，而不该是固定默认值</li></ol><h4 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h4><p>设计器支持众多参数类型，这些参数类型均与变量类型一致。因此，您可以创建泛型值、字符串、布尔值、对象、数组或数据表参数，与创建<a class="link"   href="http://localhost:9399/help_CN/%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86.md" >变量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>时相同。</p><p>主要有：</p><table><thead><tr><th>参数类型</th><th>详细类型</th></tr></thead><tbody><tr><td>字符串</td><td>string</td></tr><tr><td>数字</td><td>number</td></tr><tr><td>布尔</td><td>boolean</td></tr><tr><td>数组</td><td>array</td></tr><tr><td>对象</td><td>object</td></tr><tr><td>密码</td><td>cyclone.Password</td></tr><tr><td>日期时间</td><td>cyclone.DateTime</td></tr><tr><td>数据表</td><td>cyclone.Datatable</td></tr><tr><td>自定义类型</td><td>例如array,object,string 表示array<object></td></tr><tr><td>Cyclone内部变量类型</td><td>cyclone.xxx，是弘玑定义的一些固定的数据结构</td></tr></tbody></table>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>注意：</p><ol><li>参数类型中，布尔类型默认值为true。</li><li>数组类型在使用时，要选择数组中数据的类型，同时只能选择字符串、数字、布尔类型。</li><li>对象类型在使用时，要选择数组中数据的类型，同时只能选择字符串、数字、布尔类型。</li><li>密码类型不支持作为输出参数，密码的默认加密类型AES加密，实际上是加密的字符串类型。</li></ol>    </div>  </div><h4 id="输入参数如何改为输出参数"><a href="#输入参数如何改为输出参数" class="headerlink" title="输入参数如何改为输出参数"></a>输入参数如何改为输出参数</h4><ol><li>可将输入参数拖拽至输出参数的节点下面，反之亦可</li><li>按下{ctrl}或{shift}可实现批量拖拽参数</li></ol><h4 id="删除参数"><a href="#删除参数" class="headerlink" title="删除参数"></a>删除参数</h4><ol><li>右键菜单中选择“删除参数”</li><li>选中参数后按下{Del}键，支持按下{Ctrl}或{Shift}选中多个参数后进行批量删除</li></ol><h4 id="批量复制粘贴变量"><a href="#批量复制粘贴变量" class="headerlink" title="批量复制粘贴变量"></a>批量复制粘贴变量</h4><ol><li>选中一个参数，如参数1，按下Ctrl+C进行复制；按下Ctrl+V进行粘贴，生成【参数1的副本1】</li><li>按下{ctrl}支持选中多个参数进行批量复制粘贴</li><li>按下{shift}支持连选多个参数进行批量复制粘贴</li></ol><h4 id="搜索-筛选变量"><a href="#搜索-筛选变量" class="headerlink" title="搜索&amp;筛选变量"></a>搜索&amp;筛选变量</h4><ol><li>点击参数旁的筛选图标小按钮，支持筛选参数类型</li><li>支持输入参数名称进行模糊搜索</li></ol><h4 id="查看引用信息"><a href="#查看引用信息" class="headerlink" title="查看引用信息"></a>查看引用信息</h4><ol><li>鼠标悬停在某个参数时，会显示参数的详细信息</li><li>点击“显示详情”可以查看该参数被引用情况，点击引用信息下的某作用域可以实现快速跳转</li></ol><h4 id="参数一键转换为变量"><a href="#参数一键转换为变量" class="headerlink" title="参数一键转换为变量"></a>参数一键转换为变量</h4><p>右键点击变量，在菜单中可以选择转换为输入或输出参数</p><h3 id="变量管理"><a href="#变量管理" class="headerlink" title="变量管理"></a>变量管理</h3><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>变量：是用于存储流程设计中需要流转使用的数据</li></ul><h4 id="新建变量"><a href="#新建变量" class="headerlink" title="新建变量"></a>新建变量</h4><p>新建全局变量：点击变量面板中的“+”按钮，即可快速创建新变量。节点中输出一个新变量时，需要同时按键Shift + Enter, 快速创建一个变量。</p><p>新建局部变量：有两种方法</p><ul><li>右键点击想要新建局部变量的目标作用域，在右键菜单中选择“新建变量”</li><li>选中目标作用域下的其中一个变量后，点击“+”按钮</li></ul><h4 id="编辑变量"><a href="#编辑变量" class="headerlink" title="编辑变量"></a>编辑变量</h4><p>有两种方式可以编辑您的变量</p><ul><li><ol><li>悬停在某个变量时，会出现一个编辑图标按钮，点击按钮即可打开编辑页面</li></ol></li><li><ol><li>右键点击某变量，右键菜单中选择“编辑变量”</li></ol></li></ul><p>可设置变量的名称、变量类型、初始值、变量描述</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>设计器支持众多变量类型。您可以创建泛型值、字符串、布尔值、对象、数组或数据表变量<br>主要有：<br>主要有：</p><table><thead><tr><th>变量类型</th><th>详细类型</th></tr></thead><tbody><tr><td>字符串</td><td>string</td></tr><tr><td>数字</td><td>number</td></tr><tr><td>布尔</td><td>boolean</td></tr><tr><td>数组</td><td>array</td></tr><tr><td>对象</td><td>object</td></tr><tr><td>密码</td><td>cyclone.Password</td></tr><tr><td>日期时间</td><td>cyclone.DateTime</td></tr><tr><td>数据表格</td><td>cyclone.Sqltable</td></tr><tr><td>自定义类型</td><td>例如array,object,string 表示array<object></td></tr><tr><td>Cyclone内部变量类型</td><td>cyclone.xxx，是弘玑定义的一些固定的数据结构</td></tr></tbody></table>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>注意：</p><ol><li>变量类型中，布尔类型默认值为true。</li><li>数组类型在使用时，要选择数组中数据的类型，同时只能选择字符串、数字、布尔类型。</li><li>对象类型在使用时，要选择数组中数据的类型，同时只能选择字符串、数字、布尔类型。</li><li>密码类型在使用时，默认加密类型AES加密。</li></ol>    </div>  </div><h4 id="变量范围"><a href="#变量范围" class="headerlink" title="变量范围"></a>变量范围</h4><table><thead><tr><th>变量范围</th><th>是否会创建自变量</th></tr></thead><tbody><tr><td>当前流程</td><td>否</td></tr><tr><td>流程块</td><td>否</td></tr><tr><td>TryCatch异常处理&gt;try</td><td>否</td></tr><tr><td>TryCatch异常处理&gt;finally</td><td>否</td></tr><tr><td>捕获异常</td><td>否</td></tr><tr><td>While循环</td><td>否</td></tr><tr><td>数组遍历</td><td>是（①_array_index、②_array_element）</td></tr><tr><td>对象遍历</td><td>是（①_object_key、②_object_value）</td></tr><tr><td>For循环</td><td>是（i）</td></tr><tr><td>If条件判断&gt;如果</td><td>否</td></tr><tr><td>If条件判断&gt;否则</td><td>否</td></tr></tbody></table><h4 id="修改变量作用域"><a href="#修改变量作用域" class="headerlink" title="修改变量作用域"></a>修改变量作用域</h4><ol><li>可通过拖拽修改变量的作用域，比如将主流程下的全局变量拖至for循环作用域下面</li><li>按下{ctrl}或{shift}可实现批量拖拽变量，批量修改变量的作用域</li></ol><h4 id="删除变量（可批量）"><a href="#删除变量（可批量）" class="headerlink" title="删除变量（可批量）"></a>删除变量（可批量）</h4><ol><li>右键菜单中选择“删除变量”</li><li>选中变量后按下{Del}键，支持按下{Ctrl}或{Shift}选中多个变量后进行批量删除</li></ol><h4 id="复制粘贴变量（可批量）"><a href="#复制粘贴变量（可批量）" class="headerlink" title="复制粘贴变量（可批量）"></a>复制粘贴变量（可批量）</h4><ol><li>选中一个变量，如变量1，按下Ctrl+C进行复制；按下Ctrl+V进行粘贴，生成【变量1的副本1】</li><li>按下{ctrl}支持选中多个变量进行批量复制粘贴</li><li>按下{shift}支持连选多个变量进行批量复制粘贴</li></ol><h4 id="搜索-筛选变量-1"><a href="#搜索-筛选变量-1" class="headerlink" title="搜索&amp;筛选变量"></a>搜索&amp;筛选变量</h4><ol><li><p>点击变量旁的筛选图标小按钮，支持筛选变量类型</p></li><li><p>支持输入变量名称进行模糊搜索</p></li></ol><h4 id="去除未引用变量"><a href="#去除未引用变量" class="headerlink" title="去除未引用变量"></a>去除未引用变量</h4><ol><li>当变量未被其他组件引用时，通过“去除未引用变量”功能，可以快速去除所有未引用的变量</li><li>⚠注意：如果您的节点被&#x2F;&#x2F;禁用了，这些节点里面引用的变量也会被一并删除掉</li></ol><h4 id="查看引用信息-1"><a href="#查看引用信息-1" class="headerlink" title="查看引用信息"></a>查看引用信息</h4><ol><li>鼠标悬停在某个变量时，会显示变量的详细信息</li><li>点击“显示详情”可以查看该变量被引用情况，点击引用信息下的某作用域可以实现快速跳转</li></ol><h4 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h4><ol><li>跟随用户在画布上选中节点所属的作用域，展示该节点所有可用的变量</li><li>如果在主流程中不选中任何节点，展示主流程可使用的全局变量</li></ol><h4 id="异常提示"><a href="#异常提示" class="headerlink" title="异常提示"></a>异常提示</h4><p>当变量类型不匹配，或引用变量不正确，或变量名称重复时会进行异常提醒</p><h4 id="变量一键转换为参数"><a href="#变量一键转换为参数" class="headerlink" title="变量一键转换为参数"></a>变量一键转换为参数</h4><p>右键点击变量，在菜单中可以选择转换为输入或输出参数</p><h2 id="元素捕获"><a href="#元素捕获" class="headerlink" title="元素捕获"></a>元素捕获</h2><h3 id="捕获模式"><a href="#捕获模式" class="headerlink" title="捕获模式"></a>捕获模式</h3><p>捕获元素目前为5种，常规捕获模式、CV捕获模式、图片捕获模式、表格捕获模式、UIA捕获模式：</p><table><thead><tr><th><strong>模式</strong></th><th><strong>快捷键</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>常规捕获模式</td><td>F1</td><td>用于捕获大部分软件，基于GUI元素属性定位目标元素</td></tr><tr><td>CV捕获模式</td><td>F2</td><td>用于其他捕获模式无法捕获的情况，基于屏幕图像理解，记录元素特征定位目标元素</td></tr><tr><td>图片捕获模式</td><td>F3</td><td>用于其他捕获模式无法捕获的情况，基于图片定位目标元素</td></tr><tr><td>表格捕获模式</td><td>F4</td><td>用于捕获表格中的行列信息，定位单元格</td></tr><tr><td>UIA捕获模式</td><td>F5</td><td>用于捕获使用UIA框架编写的客户端软件</td></tr></tbody></table><ul><li>点击捕获元素按钮，进入普通捕获模式。</li><li>{F1}常规捕获模式</li><li>{F2}切换到CV捕获模式，若F2无法切换模式，尝试alt+F2</li><li>{F3}切换到图片捕获模式，若F3无法切换模式，尝试alt+F3</li><li>{F4}切换到表格捕获模式，若F4无法切换模式，尝试alt+F4</li><li>{F5}切换到UIA捕获模式，若F5无法切换模式，尝试alt+F5</li><li>{Esc}退出捕获模式<br>在捕获元素时，会有捕获节点推荐提示：根据用户捕获的元素，自动判断应当适用哪个功能节点，弹窗提示用户“建议您使用XX功能”。</li></ul><h4 id="1-常规捕获模式"><a href="#1-常规捕获模式" class="headerlink" title="1. 常规捕获模式"></a>1. 常规捕获模式</h4><ul><li>用于捕获大部分软件，基于GUI元素属性定位目标元素</li><li>Cyclone旧版捕获和其他大部分竞品的捕获元素操作，是会冻结当前界面，此时点击目标元素即完成捕获，但如果当前桌面最上层的应用不是您想要的应用，通常还需要配合延迟捕获等额外功能才能方便使用</li><li>Cyclone新版捕获优化了用户体验，需要按下{Ctrl}+点击（左键右键均可）完成元素捕获，未按下Ctrl键之前的所有鼠标键盘操作均可正常使用</li><li>有的输入框的表面有一层浮层，因此捕获输入框，建议用户输入文本后再捕获</li><li>相比于大部分竞品，Cyclone捕获元素无需做抓取模式的切换，可以智能识别当前是什么类型的应用，无需做Java模式&#x2F;IE模式&#x2F;CS模式等切换</li><li>可识别的元素显示红框高亮</li><li>支持通过F12禁用鼠标事件（如悬停）</li></ul><h4 id="2-CV捕获模式"><a href="#2-CV捕获模式" class="headerlink" title="2. CV捕获模式"></a>2. CV捕获模式</h4><p>用于其他捕获模式无法捕获的情况，基于屏幕图像理解，记录元素特征定位目标元素<br>元素捕获时，按下快捷键F2进入CV捕获模式<br><strong>a.机器配置</strong></p><ul><li>推荐8g内存，i7CPU</li><li>最低4g内存，i5CPU</li></ul><p><strong>b.升级须知</strong></p><ul><li>CV识别功能在3.2进行了全面升级，使用的是新的识别模型，提高了识别速度和准确率。</li><li>此功能优化后不兼容老版本的CV模型，所以如果流程中使用了之前的CV功能，升级后需要重写CV识别相关的节点</li><li>支持通过F12禁用鼠标事件（如悬停）</li></ul><p><strong>c.具体操作</strong></p><ul><li>元素捕获时，快捷键F3可切换捕获模式至CV识别；</li><li>用户需要先选中一个目标窗口，未选择窗口前，用户可快捷键切换至F1属性定位或F2图片匹配</li><li>此时需等待CV返回识别结果</li><li>正在识别时，不要进行其他的鼠标键盘操作</li><li>识别后，用户鼠标移动到可识别元素的高亮框时，按下Ctrl+点击，完成CV捕获</li></ul><h4 id="3-图片捕获模式"><a href="#3-图片捕获模式" class="headerlink" title="3. 图片捕获模式"></a>3. 图片捕获模式</h4><ul><li>用于其他捕获模式无法捕获的情况，基于图片定位目标元素</li><li>元素捕获时，按下快捷键F3切换至图片匹配；</li><li>用户点击屏幕任意位置后，进入截图模式，自动隐藏左上角面板提示，此时不可再使用快捷键进行模式切换。</li><li>示例链接:<a class="link"   href="http://bang.dangdang.com/books/bestsellers/01.00.00.00.00.00-recent7-0-0-1-1" >当当网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>截取购物车的图片，点击完成完成图片捕获</li><li>支持通过F12禁用鼠标事件（如悬停）</li></ul><h4 id="4-表格捕获模式"><a href="#4-表格捕获模式" class="headerlink" title="4. 表格捕获模式"></a>4. 表格捕获模式</h4><p>用于捕获复杂表格中的单个元素</p><h4 id="5-UIA捕获模式"><a href="#5-UIA捕获模式" class="headerlink" title="5. UIA捕获模式"></a>5. UIA捕获模式</h4><p>用于捕获使用UIA框架编写的客户端软件</p><h4 id="6-CV表格捕获模式"><a href="#6-CV表格捕获模式" class="headerlink" title="6. CV表格捕获模式"></a>6. CV表格捕获模式</h4><p><strong>功能说明：</strong><br>使用CV(Computer Vision)技术捕获表格中的行列信息，定位单元格<br><strong>具体操作：</strong></p><ol><li>点击画布节点上的【CV抓取表格数据】按钮，打开向导，点击【捕获元素】按钮，进入【元素捕获】模式</li><li>选择需要识别的表格所在的范围，等待识别运算</li><li>解析表格结构失败，或未解析出表格结构，返回设计器，在设计器中toast提示用户：“未识别表格结构，请重新捕获”</li></ol><h4 id="7-禁用鼠标事件开关"><a href="#7-禁用鼠标事件开关" class="headerlink" title="7. 禁用鼠标事件开关"></a>7. 禁用鼠标事件开关</h4><p>按下F12可以开启禁用鼠标事件的开关，开启后，目标界面不会响应用户的鼠标悬停事件，主要应对的使用场景是：鼠标移上去时目标元素会变，无法捕获变化前的元素</p><h4 id="8-功能组件的捕获模式"><a href="#8-功能组件的捕获模式" class="headerlink" title="8. 功能组件的捕获模式"></a>8. 功能组件的捕获模式</h4><table><thead><tr><th><strong>二级目录</strong></th><th><strong>名称</strong></th><th><strong>描述</strong></th><th>**支持的捕获模式 **</th></tr></thead><tbody><tr><td>应用和浏览器</td><td>启动应用程序</td><td>打开指定的应用程序</td><td>窗口</td></tr><tr><td></td><td>关闭应用程序</td><td>录制一段关闭应用的界面操作，或强行关闭一个应用程序</td><td>窗口</td></tr><tr><td></td><td>打开浏览器</td><td>打开浏览器，并加载指定网页</td><td>不需捕获</td></tr><tr><td></td><td>打开新标签页</td><td>打开新标签页，并前往指定的网址</td><td>不需捕获</td></tr><tr><td></td><td>激活标签页</td><td>激活目标浏览器中的一个标签页，让后续相关的操作在正确的目标上执行</td><td>不需捕获</td></tr><tr><td></td><td>关闭标签页</td><td>关闭已打开的标签页</td><td>不需捕获</td></tr><tr><td></td><td>刷新&#x2F;前进&#x2F;后退</td><td>对指定网页进行刷新、前进、回退操作</td><td>不需捕获</td></tr><tr><td></td><td>执行JS脚本</td><td>向目标网页中的iframe注入并执行JavaScript脚本</td><td>不需捕获</td></tr><tr><td></td><td>获取网页URL</td><td>获取当前页面的网址URL</td><td>不需捕获</td></tr><tr><td></td><td>获取网页Cookie</td><td>获取网页的Cookie数据</td><td>不需捕获</td></tr><tr><td></td><td>设置网页Cookie</td><td>设置网页的Cookie数据</td><td>不需捕获</td></tr><tr><td></td><td>输入文本</td><td>在指定的输入框中输入文本(自动清空后输入、输入后校验）</td><td>常规,CV,图片,表格,UIA,CV表格</td></tr><tr><td></td><td>发送热键</td><td>对当前激活窗口或有焦点的元素，模拟发送键盘按键</td><td>常规</td></tr><tr><td></td><td>选择选项</td><td>在下拉列表、列表框中选择一个选项</td><td>常规,表格</td></tr><tr><td></td><td>勾选&#x2F;取消勾选</td><td>将单选框、复选框元素的勾选状态设置为勾选或取消勾选</td><td>常规,表格</td></tr><tr><td></td><td>鼠标悬停</td><td>移动鼠标至指定目标位置并悬停</td><td>常规,CV,图片,表格,UIA,坐标,CV表格</td></tr><tr><td></td><td>鼠标拖拽</td><td>模拟鼠标将元素拖拽至指定位置</td><td>录制,坐标</td></tr><tr><td></td><td>鼠标滚动</td><td>在当前激活窗口滚动鼠标滚轮</td><td>不需捕获</td></tr><tr><td></td><td>获取鼠标位置</td><td>获取当前鼠标光标所在位置</td><td>不需捕获</td></tr><tr><td>表格&#x2F;列表</td><td>抓取表格数据</td><td>批量抓取标准表格和列表（相似元素）数据，可自动翻页</td><td>表格</td></tr><tr><td></td><td>抓取结构化数据</td><td>在网页中批量抓取相似元素数据，如列表页</td><td>常规</td></tr><tr><td></td><td>CV抓取表格数据</td><td></td><td>CV表格</td></tr><tr><td></td><td>抓取下拉列表数据</td><td>抓取下拉列表、列表框中 所有&#x2F;选中 选项的内容和数量</td><td>常规,表格</td></tr><tr><td></td><td>查找相似元素</td><td>在网页上查找多个相似元素，将元素列表输出到数组</td><td>常规</td></tr><tr><td>文本</td><td>点击文本</td><td>还没有这个节点</td><td>常规</td></tr><tr><td></td><td>获取文本</td><td>获取元素的文本内容（Value属性)</td><td>常规,表格</td></tr><tr><td></td><td>读取可见文本</td><td>采用系统注入的方式获取可见文本，目前仅支持常见的证券软件（如同花顺）</td><td>常规,区域</td></tr><tr><td></td><td>按文本查找元素</td><td>在网页上查找指定文本的元素</td><td>常规</td></tr><tr><td></td><td>获取树子节点</td><td>在客户端软件的目录树中，获取指定目录下的所有子节点的名称</td><td>常规,表格</td></tr><tr><td>元素</td><td>判断元素是否存在</td><td>判断元素是否存在，返回布尔值true&#x2F;false</td><td>常规,CV,图片,表格,UIA,CV表格</td></tr><tr><td></td><td>等待元素出现</td><td>进行元素操作前最好等待元素出现</td><td>常规,CV,图片,表格,UIA,CV表格</td></tr><tr><td></td><td>编辑元素属性</td><td>编辑或删除网页元素的指定属性</td><td>常规</td></tr><tr><td></td><td>获取元素属性</td><td>获取界面中指定元素的属性信息</td><td>常规,表格</td></tr><tr><td></td><td>获取元素颜色</td><td>获取界面中指定元素的颜色信息</td><td>常规,坐标</td></tr><tr><td></td><td>获取元素位置</td><td>获取界面中指定元素的位置信息</td><td>常规,表格</td></tr><tr><td></td><td>元素截图</td><td>对界面元素进行截图，并将结果保存至指定文件夹</td><td>常规,表格</td></tr><tr><td></td><td>滚动截图</td><td>垂直或水平滚动后截图，并拼接成完整的长截图</td><td>常规</td></tr><tr><td></td><td>查找子元素</td><td>获取目标元素下的所有子元素，返回获取到的子元素，仅支持网页元素</td><td>常规</td></tr><tr><td></td><td>查找父元素</td><td>获取目标元素向上一级的父元素，返回获取到的父元素，仅支持网页元素</td><td>常规</td></tr><tr><td></td><td>Xpath查找元素</td><td>通过目标元素的XPath路径，获取目标元素并保存到对象</td><td>不需捕获</td></tr><tr><td></td><td>锚点查找元素</td><td>在网页上基于固定的锚点查找目标元素</td><td>常规</td></tr><tr><td>窗口</td><td>激活窗口</td><td>将目标窗口置顶，便于后续的前台操作</td><td>不需捕获</td></tr><tr><td></td><td>关闭窗口</td><td>使用后台的方式关闭目标窗口</td><td>不需捕获</td></tr><tr><td></td><td>设置窗口状态</td><td>使用后台的方式最大化、最小化目标窗口</td><td>不需捕获</td></tr><tr><td>高级功能</td><td>查找OCR文本位置</td><td>使用OCR技术在目标范围内查找文本，输出目标文本所在的坐标位置</td><td>常规</td></tr><tr><td></td><td>OCR通用文本识别</td><td>自研OCR通用文本识别模型，可识别单行文本</td><td>常规,区域</td></tr><tr><td></td><td>OCR验证码识别</td><td>自研OCR验证码识别模型，可识别4-6位数字英文验证码</td><td>常规,区域</td></tr><tr><td></td><td>第三方服务商OCR</td><td>使用第三方服务商OCR识别，需申请特殊license</td><td>不需捕获</td></tr><tr><td></td><td>获取个人微信聊天记录</td><td>捕获聊天对话框里的任意一条对话，执行时将获取当前激活的微信对话框里可见的聊天记录（不支持企业微信）</td><td>常规</td></tr></tbody></table><h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><p><strong>什么是元素属性？</strong><br>可以简单理解为这个元素的特征，机器人需要定位一个元素，需要基于元素的特征来查找。就像一个人的特征，姓名是张三，性别是男…<br>元素的特征有很多，比如宽是200，长是100，类型是按钮，文字是确定…<br>为了找到正确的元素，正确的元素特征非常重要。</p><h4 id="窗口属性"><a href="#窗口属性" class="headerlink" title="窗口属性"></a>窗口属性</h4><ul><li>目标元素所在窗口的相关属性</li><li>一般只需关注name属性，代表窗口标题</li><li>某些业务场景下窗口标题是容易变化的，比如登录后窗口标题带有登录名信息，比如翻页后窗口标题带有页码信息</li></ul><h4 id="元素属性-1"><a href="#元素属性-1" class="headerlink" title="元素属性"></a>元素属性</h4><ul><li><p>目标元素自身的属性特征</p><ul><li>有info图标：用户最直观的感受是，这类属性勾选或不勾选好像都会生效，这是为什么呢？这一类属性我们称之为查找属性，为了增强元素捕获的稳定性，底层会进行多轮查找，分别使用不同的特征组合进行查找，找不到时会自动降权，舍弃不重要的特征，所以，哪怕这些属性值变化了，理论上也不会影响找到正确的元素</li><li>没有info图标：这类属性的勾选状态是完全生效的，我们称之为匹配属性，在用不同特征进行查找之后，有可能查找到多个元素，将找的元素与被勾选上的匹配属性进行匹配，看是否是正确的</li></ul></li><li><p>在界面上众多的元素中找到正确的目标元素，就像我们想在淘宝网站中找到心意的商品，比如商品的特征是：北欧、花瓶、白色、雕花，第一次我们用四个特征去搜索商品，可能会有3种结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①找到了多个商品（类比找到多个元素）</span><br><span class="line">②找到了1个商品（类比找到1个元素）</span><br><span class="line">③没找到任何商品（类比没有找到元素）</span><br></pre></td></tr></table></figure></div><p>结果③，会走向”降权查找“：</p><ul><li>第二轮查找，我们用三个特征“北欧、花瓶、白色”再找一次</li><li>如果第二轮还是没找到任何商品，第三轮我们用两个特征“花瓶、白色”再找一次</li><li>以此类推</li></ul><p>结果①和②，会走向”匹配属性“：</p><ul><li><p>“匹配属性”，就类似再加了一条过滤器，比如我就想要XX淘宝店的花瓶，这样再筛选一下，可能会有3种结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①找到了多个商品，这时第一条商品就会被认为是心意商品（类比正确的目标元素）</span><br><span class="line">②找到了1个商品，它被认为是心意商品（类比正确的目标元素）</span><br><span class="line">③没找到任何商品（类比报错：找不到目标元素）</span><br></pre></td></tr></table></figure></div></li></ul></li></ul><h4 id="匹配方式"><a href="#匹配方式" class="headerlink" title="匹配方式"></a>匹配方式</h4><p>【精准匹配】基于固定值或变量值，可在输入框中输入固定值，或@引用变量</p><p>【通配匹配】支持通配符“*”和“？”</p><ul><li>*：代替零个、单个或多个字符</li><li>？：代替一个字符</li></ul><p>【正则匹配】</p><ul><li>支持Perl正则表达式，详见链接：<a class="link"   href="https://www.runoob.com/perl/perl-regular-expressions.html" >https://www.runoob.com/perl/perl-regular-expressions.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>实现的是regex_search功能，实现部分匹配而不是完全匹配，举例来说，如果目标元素是“百度一下，你就知道“，如果选择了正则匹配，匹配值为”百度“，是可以匹配上的</li></ul><h4 id="属性列表"><a href="#属性列表" class="headerlink" title="属性列表"></a>属性列表</h4><table><thead><tr><th><strong>元素类型</strong></th><th><strong>属性名</strong></th><th><strong>描述</strong></th><th><strong>是否支持通配匹配</strong></th><th><strong>是否支持正则匹配</strong></th><th>**是否区分大小写 **</th></tr></thead><tbody><tr><td>Windows元素</td><td>category</td><td>元素类别，WINCONRTROL代表是CS结构的应用</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>Windows元素</td><td>winClass</td><td>Windows元素的具体类型，比如输入框、按钮</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>Windows元素</td><td>name</td><td>Windows元素的文本属性</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Windows元素</td><td>role</td><td>Windows元素类型</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Windows元素</td><td>width</td><td>Windows元素宽度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Windows元素</td><td>height</td><td>Windows元素高度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Windows元素</td><td>left</td><td>Windows元素距离所在窗口左侧边缘的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Windows元素</td><td>top</td><td>Windows元素距离所在窗口上方边缘的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Windows元素</td><td>index</td><td>Windows元素的顺序</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Windows元素</td><td>value</td><td>Windows元素输入的文本</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Java元素</td><td>category</td><td>元素类别，JAVACONRTROL代表是Java应用</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>Java元素</td><td>name</td><td>Java元素文本属性</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Java元素</td><td>role</td><td>Java元素类型</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Java元素</td><td>width</td><td>Java元素宽度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Java元素</td><td>height</td><td>Java元素高度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Java元素</td><td>left</td><td>Java元素距离所在窗口左侧边缘的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Java元素</td><td>top</td><td>Java元素距离所在窗口上方边缘的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Java元素</td><td>index</td><td>Java元素的顺序</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Java元素</td><td>value</td><td>Java元素输入的文本</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>IE元素</td><td>category</td><td>元素类别，IECONRTROL代表是IE浏览器</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>tagName</td><td>IE元素的标签属性，如HTML、DIV、LI等</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>type</td><td>IE元素类型，如text、rec等</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>name</td><td>IE元素的name属性</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>IE元素</td><td>offsetWidth</td><td>IE元素宽度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>offsetHeight</td><td>IE元素高度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>offsetLeft</td><td>IE元素距离父元素左上角的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>offsetTop</td><td>IE元素距离父元素上端的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>special</td><td>IE元素special属性，非关键属性</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>id</td><td>IE元素HTML中的核心属性：唯一标识符id</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>index</td><td>IE元素的顺序</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>parentId</td><td>IE元素的父元素的唯一标识符id</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>toParent</td><td>IE层级树中第几个父元素有id</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>frameURL</td><td>IE元素所在的网址链接</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>IE元素</td><td>className</td><td>IE元素的class属性，用来对网页元素进行分类。如果不同元素的class属性值相同，就表示它们是一类的</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>IE元素</td><td>value</td><td>IE元素的value属性</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>IE元素</td><td>link</td><td>IE元素的link属性，为点击该元素后跳转到的链接</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>IE元素</td><td>readOnly</td><td>IE元素的只读属性，代表该字段不可编辑</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>innerText</td><td>IE元素中包含的所有文本内容</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>IE元素</td><td>outerText</td><td>IE元素中包含的所有文本内容，除了作用范围扩大到了包含调用它的节点之外，outerText与innerText基本上没区别</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>IE元素</td><td>styleBackgroundImage</td><td>网页背景图片的url</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>IE元素</td><td>styleVisibility</td><td>是否可见，1代表可见，0代表不可见</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>category</td><td>元素类别，CHROMECONRTROL代表是Chrome浏览器</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>tagName</td><td>Chrome元素的标签属性，如HTML、DIV、LI等</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>type</td><td>Chrome元素类型，如text、rec等</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>name</td><td>Chrome元素的name属性</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Chrome元素</td><td>offsetWidth</td><td>Chrome元素宽度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>offsetHeight</td><td>Chrome元素高度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>offsetLeft</td><td>Chrome元素距屏幕左侧边缘的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>offsetTop</td><td>Chrome元素距屏幕上方边缘的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>special</td><td>Chrome元素special属性，非关键属性</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>id</td><td>Chrome元素的id属性，是元素在网页内的唯一标识</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>index</td><td>Chrome元素的顺序</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>parentId</td><td>Chrome元素的父元素的唯一标识符id</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>toParent</td><td>Chrome层级树中第几个父元素有id</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>frameURL</td><td>Chrome元素所在的网页URL</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Chrome元素</td><td>className</td><td>Chrome元素的class属性，用来对网页元素进行分类。如果不同元素的class属性值相同，就表示它们是一类的</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Chrome元素</td><td>value</td><td>Chrome元素的value属性</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Chrome元素</td><td>link</td><td>Chrome元素的link属性，为点击该元素后跳转到的链接</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Chrome元素</td><td>readOnly</td><td>Chrome元素的只读属性，代表该字段不可编辑</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>innerText</td><td>Chrome元素中包含的所有文本内容</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Chrome元素</td><td>outerText</td><td>Chrome元素中包含的所有文本内容，除了作用范围扩大到了包含调用它的节点之外，outerText与innerText基本上没区别</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Chrome元素</td><td>styleBackgroundImage</td><td>网页背景图片的url</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Chrome元素</td><td>styleVisibility</td><td>是否可见，1代表可见，0代表不可见</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>category</td><td>元素类别，SAPCONRTROL代表是SAP</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>id</td><td>SAP的id属性,是SAP元素的唯一标识</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>type</td><td>SAP元素类别，如输入框、按钮等</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>name</td><td>SAP元素的名称</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>text</td><td>SAP元素的文本属性</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>subType</td><td>SAP元素的子类型</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>width</td><td>SAP元素宽度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>height</td><td>SAP元素高度</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>left</td><td>SAP元素距离？左上角的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>top</td><td>SAP元素距离？上端的距离</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>SAP元素</td><td>index</td><td>SAP元素的顺序</td><td>NO</td><td>NO</td><td>YES</td></tr></tbody></table><h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><h4 id="功能入口-1"><a href="#功能入口-1" class="headerlink" title="功能入口"></a>功能入口</h4><p>右键单击 节点上的元素截图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dc3054f9-dce3-4b9f-cd25-01d0617b6800/public"                      width = "600"                ><h4 id="回显"><a href="#回显" class="headerlink" title="回显"></a>回显</h4><ul><li>功能说明<br>用于验证是否能找到正确的目标元素，找到的元素会被红框高亮</li><li>使用方法</li></ul><ol><li>点击后会自动激活元素所在的目标窗口，被找到的元素会红框高亮</li><li>如果未找到元素，会返回设计器并toast提示错误</li></ol><h4 id="打开选择器"><a href="#打开选择器" class="headerlink" title="打开选择器"></a>打开选择器</h4><p>打开目标元素对应的元素选择器面板，功能详见<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=30c7c5bb-2754-4101-8a60-ffc08432abf9" >元素选择器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="重新捕获"><a href="#重新捕获" class="headerlink" title="重新捕获"></a>重新捕获</h4><p>重新捕获目标元素</p><h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>移除已捕获的目标元素</p><h4 id="UI解析器"><a href="#UI解析器" class="headerlink" title="UI解析器"></a>UI解析器</h4><p>用于验证设计器的捕获能力，探测界面上的元素是否可以被捕获。功能详见：<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=3dc47008-251e-441e-a575-11bcfb3b5a9b" >UI解析器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="智能捕获"><a href="#智能捕获" class="headerlink" title="智能捕获"></a>智能捕获</h3><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>功能背景</p><ul><li>原有捕获方式会由于元素变化导致流程稳定性差</li><li>某些元素变化是用户无感知的，比如是元素底层的属性特征变化、网页HTML源码变化等；但从用户的角度来看，这个元素并没有变化，样式和内容都没有发生变化</li></ul><p>功能效果</p><ul><li>当元素的底层关键特征发生变化，导致找不到元素时，通过智能捕获可以正确找到元素</li><li>当元素所在的页面发生变化时，比如结构微调或者新增新模块，导致找不到&#x2F;找错元素时，通过智能捕获可以正确找到元素</li></ul><p>功能限制</p><ul><li>不适用情况：<ul><li>若元素的样式发生变化；或界面上由&gt;1个样式、尺寸相似的元素；</li><li>若元素的文本内容发生变化；或界面上有&gt;1个文本相同的元素；</li></ul></li><li>捕获方式及对象：<ul><li>捕获方式：常规捕获、表格捕获、UIA捕获</li><li>对象：BS网页、CS客户端、JAVA客户端、SAP</li></ul></li></ul><ol><li>支持组件</li><li>点击</li><li>输入文本</li><li>鼠标悬停</li><li>发送热键</li></ol><h4 id="使用说明-4"><a href="#使用说明-4" class="headerlink" title="使用说明"></a>使用说明</h4><ol><li><p>在元素选择器中新增：“元素截图”、”OCR查找文本“选项，当元素变化时，作为查找元素的依据</p></li><li><p>更新fallback查找策略；</p></li></ol><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>可以通过%appdata%\speed_dev\logs\engine下面的日志文件中，搜索runAction response关键字，查看指令运行之后的返回结果，通过结果中的extensionCode字段区分是否使用了智能捕获：</p><ul><li>0 未使用智能捕获</li><li>1 未找到窗口时，降权到图片查找</li><li>2 未找到窗口时，降权到OCR文本查找</li><li>1000 未找到元素时，降权到图片查找</li><li>2000 未找到元素时，降权到OCR文本查找</li></ul><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>捕获Chrome元素、IE元素、Edge元素、Java元素、SAP元素。</li><li>首次或重新安装设计器，按需安装扩展程序。</li><li>在电脑A上设计的流程文件，需要在电脑B上执行，电脑B按需安装扩展程序。</li></ul><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>打开工具管理-&gt;查看帮助文档。可以查看所有扩展程序的安装与启用步骤。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>系统自动检测捕获插件是否安装，若未安装则会给出友好提示、引导用户一步步安装。</p><p>如果捕获的时候，发现目标应用程序的权限高于设计器的权限，提示用户“权限不足，请使用管理员权限运行设计器后再次尝试”。</p><p><strong>浏览器插件安装参考文档：<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=c7b8b4c7-c225-412b-89ff-fef0ca14ccd5" >浏览器插件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><h4 id="功能入口-2"><a href="#功能入口-2" class="headerlink" title="功能入口"></a>功能入口</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/69f9cdbf-b20a-4786-9579-611488139f00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b11709f9-37ae-4d54-4541-1b4d31d42c00/public"                      width = "600"                ><ul><li><p>可进行回显目标、重新捕获、在UI解析器中查看操作</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e661bf89-13f6-421b-889d-3bd856cb0500/public"                      width = "600"                ></li></ul><h5 id="1-属性定位模式"><a href="#1-属性定位模式" class="headerlink" title="1. 属性定位模式"></a>1. 属性定位模式</h5><p><strong>属性列表</strong></p><ul><li>应用：目标元素所在的应用名称，如iexplorer.exe</li><li>标题：支持引用变量，支持通配、正则匹配<ul><li>目标元素所在窗口的标题，如【百度一下，你就知道 - Internet Explorer】</li><li>标题中大于20个字符的部分会自动改为*，表示模糊匹配</li></ul></li><li>类型：目标元素类型，如radio button，input box，text，tree，list等</li><li>文本：目标元素中的文本内容，支持引用变量，支持通配、正则匹配<ul><li>如果目标元素中的文本为空（输入框），或者易变，不建议勾选此项</li><li>此属性不能获取图片中的文本内容</li></ul></li></ul><p><strong>元素类型 - 复杂元素</strong></p><ul><li>包括列表list、树Tree、表格Table</li></ul><table><thead><tr><th>元素类型</th><th>列表 - List</th><th>树 - Tree</th><th>表格 - Table</th></tr></thead><tbody><tr><td>元素选择器</td><td><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2d23053f-ea22-4f96-dd02-7c77d159df00/public"                      width = "600"                ></td><td><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/46b102f9-90eb-413f-b065-657b041f9100/public"                      width = "600"                ></td><td><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/60872783-6df9-4619-dc9b-749bda13ba00/public"                      width = "600"                ></td></tr><tr><td>注意事项</td><td>支持选项内容匹配 支持选项序号匹配</td><td>支持选项内容匹配 不支持序号匹配</td><td>仅支持根据行号、列号定位单元格 不支持内容匹配</td></tr></tbody></table><h5 id="2-图片匹配模式"><a href="#2-图片匹配模式" class="headerlink" title="2. 图片匹配模式"></a>2. 图片匹配模式</h5><p><strong>属性列表</strong></p><ul><li>置信度：默认置信度为0.75，即查找与图片匹配依据图片相似度75%以上的图片，可以调整（输入值或拖动bar条），仅支持输入0-1范围的精确到0.01的数字，不支持引用变量。</li><li>匹配范围：默认的匹配范围是目标窗口，可通过选择应用和标题确定匹配范围。</li><li>支持抗分辨率变化，但有以下限制：<ul><li>等比例缩放，界面布局不能变化</li><li>目标元素仍在界面可见</li></ul></li><li><strong>不可在UI解析器中查看</strong></li></ul><h5 id="3-CV识别模式"><a href="#3-CV识别模式" class="headerlink" title="3. CV识别模式"></a>3. CV识别模式</h5><p><strong>属性列表</strong></p><ul><li>CV元素截图：CV识别捕获到的元素截图</li><li>CV识别范围：默认的匹配范围是目标窗口，可通过选择应用和标题确定匹配范围。</li><li><strong>不可在UI解析器中查看</strong></li></ul><h5 id="4-CV表格识别模式"><a href="#4-CV表格识别模式" class="headerlink" title="4. CV表格识别模式"></a>4. CV表格识别模式</h5><p><strong>属性列表</strong></p><ul><li>表格号：捕获后自动生成，从0开始计算，可编辑，支持引用变量</li><li>行：捕获后自动生成，从0开始计算，可编辑，支持引用变量</li><li>列：捕获后自动生成，从0开始计算，可编辑，支持引用变量</li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="组件管理-1"><a href="#组件管理-1" class="headerlink" title="组件管理"></a>组件管理</h3><h4 id="组件包入口"><a href="#组件包入口" class="headerlink" title="组件包入口"></a>组件包入口</h4><p>在设计器顶部导航栏，点击依赖管理–组建管理，可进入组件管理界面。</p><h4 id="组件源配置"><a href="#组件源配置" class="headerlink" title="组件源配置"></a>组件源配置</h4><p>组件管理界面左下角，配置组件包来源，可配置来源。</p><ul><li>本地：当用户安装设计器时，默认会创建本地组件包来源。你可以进行开启与关闭。</li><li>中控： 如果设计器已连接到中控，则会添加此组件包来源，内部会包含中控已有的组件包。该组件源默认为关闭状态，需要手动开启。</li><li>应用市场：在有外网的情况下。可以直接连接并展示应用市场源的组件。方便用户自行安装市场上的组件。</li><li>自定义：用户可选择磁盘或网络文件夹路径作为一个自定义源</li><li>当流程执行时，组件包的查找顺序为：本地—&gt;中控—&gt;应用市场，既优使用先本地源组件。</li></ul><h4 id="组件包信息"><a href="#组件包信息" class="headerlink" title="组件包信息"></a>组件包信息</h4><p>在组件包管理主界面，可以查看当前项目依赖、所有可用来源、本地源、中控源（需配置连接）</p><ol><li>组件包列表<br>当选中“项目依赖项”Tab，则显示当前项目依赖的组件包列表。在列表项组件包图标、组件包名称、组件包简介、版本号、包的作者等信息。</li></ol><ul><li>安装提示：用户鼠标hover在未作为项目依赖的组件包上，则显示安装标志，用户点击，即可安装该组件包为项目依赖。</li><li>卸载提示：用户鼠标hover在已安装的组件包上，则显示卸载标志，用户点击，即可将此组件包从当前项目依赖中移除。</li><li>可以通过顶部的搜索功能进行按名称搜索组件</li></ul><ol><li>组件包详情<br>用户在列表中选中组件包，则在右侧显示组件包详情</li></ol><ul><li><p>详情信息：显示组件包图标、组件包名称、已安装版本号（仅对于已安装的组件包显示）、简介、版本、作者、发布日期、更新说明、此组件包的依赖项。</p></li><li><p>安装组件：用户也可通过list，或直接点击切换版本按钮，切换到合适版本后再进行安装。</p></li><li><p>运行时规则<br>完成组件的安装后，默认会选择“严格”模式。在该模式下，流程发布到执行器执行时，执行器只能使用设计阶段选择的组件版本，如果找不到该版本组件运报告运行异常信息。<br>如果选择了“兼容”模式，则执行器在找不到设计时的组件版本，会在各个源种寻找并安装兼容的组件版本并运行。该模式保留了运行的灵活度，但组件若出现不兼容的情况，会导致运行的异常。</p></li></ul><h4 id="依赖项管理"><a href="#依赖项管理" class="headerlink" title="依赖项管理"></a>依赖项管理</h4><ol><li>依赖项列表<br>安装了新组件后，在项目面板中将显示当前项目的依赖信息。</li><li>依赖项更新、修复、删除<br>在依赖组件包上，点击右键。可以进行组件包的管理、删除、修复操作。</li></ol><ul><li>打开组件包管理：点击即可打开组件包管理界面</li><li>删除依赖项：点击即可删除当前依赖项，具体见下方删除依赖项。</li><li>修复依赖项：对于安装失败的依赖项，会出现修复依赖项按钮。你可以点击修复进行依赖项修复。</li></ul><h3 id="代码包管理"><a href="#代码包管理" class="headerlink" title="代码包管理"></a>代码包管理</h3><h4 id="功能入口-3"><a href="#功能入口-3" class="headerlink" title="功能入口"></a>功能入口</h4><p>在设计器的依赖管理–代码包管理功能中，点击后可打开代码包管理弹出层。</p><h4 id="代码包管理-1"><a href="#代码包管理-1" class="headerlink" title="代码包管理"></a>代码包管理</h4><p>在代码包管理界面，你可以查看 系统内置、扩展包、自定义三类代码包。可以使用搜索栏，检索已经安装好的代码包。</p><ol><li>系统内置<br>系统内置了36种设计器所必须依赖的代码包，你可以点击“+”号图标，查看内置的代码包。</li><li>扩展包<br>扩展包是官方支持的，但未内置到设计器安装包中的代码包，可按以下步骤进行安装操作。<br>a. 点击管理主界面右侧 “安装扩展包”按钮，打开扩展包安装界面。并在界面中点击获取代码扩展，进行下载。<br>b. 下载完成后，在安装界面点击路径按钮添加扩展包，并开始安装。当完成安装后，你可以返回到代码包主界面查看已经完成安装的扩展包。</li><li>自定义（实验室功能）<br>自定义包因为存在未知的兼容性风险，建议谨慎使用该功能。<br>如需使用，请按如下步骤操作：<br>a. 先进入设计器的设置中心，并开启实验室功中的”代码包管理”<br>b. 再次进入到代码包管理界面，可以看到地磅出现了安装包的功能按钮。<br>c. 点击安装包按钮，可以打开包安装工具界面，你可以通过代码源安装所需的代码包。</li></ol><h4 id="AI模型管理"><a href="#AI模型管理" class="headerlink" title="AI模型管理"></a>AI模型管理</h4><h5 id="OCR验证码识别组件"><a href="#OCR验证码识别组件" class="headerlink" title="OCR验证码识别组件"></a>OCR验证码识别组件</h5><h6 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h6><ul><li>由于【OCR验证码识别】组件依赖的模型文件在不断训练升级，且模型文件大小高达200M，所以这次功能升级就是将这个模型文件从设计器执行器的安装包中移除，模型文件上线到弘玑官方市场上统一管理</li></ul><h6 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h6><ul><li>使用【AI能力&gt;OCR&gt;OCR验证码识别】组件时，需要安装依赖的模型文件包</li><li>如果觉得OCR识别准确率不高，可以联系技术支持或产品运营定制化训练后，用新模型替换旧模型</li></ul><h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6><h6 id="设计器"><a href="#设计器" class="headerlink" title="设计器"></a>设计器</h6><ol><li>使用【OCR验证码识别】组件时，会检查是否存在依赖的OCR模型，如果没有会报错提醒，点击“前往安装”会跳转至AI模型管理面板</li><li>“AI模型管理”入口在工具栏的“依赖管理”下，可在线安装或离线安装</li><li>在线安装：使用前提是需要确保设计器所在设备可以访问弘玑官方市场（<a class="link"   href="https://marketplace.cyclone-robotics.com/%EF%BC%89" >https://marketplace.cyclone-robotics.com/） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>离线安装：如果设计器所在设备无法访问，可以采用本地导入的方式离线安装</li><li>如果是离线安装，从哪里获取OCR验证码模型文件？<ol><li>前往弘玑官方市场，需要使用账号密码登录（公司的LDAP账号），登录后可下载最新版OCR验证码模型文件</li><li>如果当前最新版的模型文件识别效果不佳，也可联系技术支持或产品运营进行定制化训练，从离线安装入口导入新模型文件进行替换</li></ol></li></ol><h6 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h6><ol><li>如果要跑的流程中使用到了OCR验证码识别组件，则需要相应在执行器中导入OCR验证码模型</li><li>新增【AI模型管理】在执行器托盘右键下</li></ol><h3 id="旧版组件（erpa）"><a href="#旧版组件（erpa）" class="headerlink" title="旧版组件（erpa）"></a>旧版组件（erpa）</h3><h4 id="旧版组件的本地导入"><a href="#旧版组件的本地导入" class="headerlink" title="旧版组件的本地导入"></a>旧版组件的本地导入</h4><p>在旧版组件管理中，选择【本地】可以将获得的新组件导入到组件库中。</p><p>选择 ① 本地，选择②导入组件，可以选择③单个erpa文件或者选择④存放erpa的文件夹批量导入。</p><p>当有新版本的外部组件需要更新时，选择⑤可以进行新组件更新升级。</p><p>当需要将组件导出到其他项目或计算机时可以选择⑥进行导出。</p><p>不需要再项目中运行或需要将组件移除流程时，可以选择⑦进行禁用，此时流程当中所用到的此功能组件将无法使用。</p><p>如果项目中不在需要此组件时可以选择⑧进行删除。</p><p>选择⑨开发工具可以对此组件进行测试，已经修改等功能。</p><ul><li>调试：进行组件运行测试。</li><li>功能测试会对导入的节点进行功能和属性上的测试，主要用于自定义的组件。</li><li>重新编译：主要针对重新进行修改和编辑后的组件进行编译，编译完成后可以在插件功能测试中显示改动的新功能和属性。</li><li>编辑Schema：对已经编写好的功能组件进行修改和自定义更新。</li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>⑨的部分开发工具功能属于实验室功能，如需使用请与官方技术支持人员联系。</p>    </div>  </div><h4 id="旧版组件市场"><a href="#旧版组件市场" class="headerlink" title="旧版组件市场"></a>旧版组件市场</h4><p>选择共享后可以看到提示，需要连接到应用市场，此时可以查看 Designer Pro 连接中心</p><h2 id="数据抓取"><a href="#数据抓取" class="headerlink" title="数据抓取"></a>数据抓取</h2><h3 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h3><p>用于抓取目标软件中的表格数据和结构化数据，比如：</p><ul><li>表格</li><li>结构化数据</li></ul><h3 id="使用说明-5"><a href="#使用说明-5" class="headerlink" title="使用说明"></a>使用说明</h3><p>表格</p><ul><li>如果是抓表格，请捕获表格中的一个单元格</li><li>可选择要抓取整个表格，或是仅抓取单列数据，或者仅抓取单行数据</li><li>点击继续，将自动爬取数据后，展示在数据预览界面，左下角会统计抓取行数和列数</li><li>左上角有开关控制 首行是否作为表头，默认不开启</li><li>根据引导，如果需要翻页的情况，可继续捕获下一页按钮<ul><li>注意，此翻页不适用于瀑布式加载的情况</li><li>页码组指的是没有下一页按钮，只能选择页面序号的情况</li></ul></li><li>如果不需要翻页，可点击“仅抓取当前页”</li></ul><p>结构化数据</p><ul><li>如果是抓结构化数据，比如当当热销书榜单的书名、作者、价格，需要一列一列数据捕获，请先捕获第一列书名的其中一个元素，比如第一个书名</li><li>根据提示，再捕获第一列书名的另一个元素，建议找个离第一个元素距离比较远的，比如倒数第一个元素</li><li>捕获成功后，会红框高亮所有的相似元素</li><li>捕获成功后，可以选择将元素的URL链接输出到单独列，URL指的是点击这个元素会跳转到的网址链接，可以按需选择是否要输出</li><li>下一步可将数据抓取出来，列名默认值是column1,2,3…支持修改列名</li><li>接下来还要捕获第二列作者信息，点击“新增列”按钮，继续用同样的方法捕获作者元素</li><li>捕获了这两个元素后（一个是单个作者，一个是多个作者），却提示错误了，说明这两个元素并不在网页的同一个层级，也就是说，他们在网页源码层面上并不相似</li><li>点击“重新捕获”，我们再尝试一次，这次我们去捕获单个作者，就成功了</li><li>同样的，可以将列名改为“作者”</li><li>接下来捕获价格，也是同样的方法</li></ul><h3 id="组件属性"><a href="#组件属性" class="headerlink" title="组件属性"></a>组件属性</h3><ul><li>如果是抓表格，会生成组件【抓取表格数据】，属性说明详见<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=76e34de5-f7b6-4ab2-9e00-d4519f72a599" >抓取表格数据 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>如果是抓结构化数据，会生成组件【抓取结构化数据】，属性说明详见<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=3e245750-64e8-46be-8c5c-4e4140b1192c" >抓取结构化数据 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h2 id="弹窗监控"><a href="#弹窗监控" class="headerlink" title="弹窗监控"></a>弹窗监控</h2><h3 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>流程运行过程中，可能会不定时的出现弹窗干扰，导致流程异常</li><li>常见的弹窗可以分为三种：<ol><li>80%为浏览器弹窗，关闭后流程可以继续运行</li><li>15%为客户端软件内弹窗，如更新通知</li><li>5%为系统级别的弹窗，可能无法关闭，或关闭后机器人不能继续运行</li></ol></li><li>弹窗出现的时间不固定，在流程运行时，随时可能跳出弹窗，并且不同弹窗的处理方式也不同</li></ul><h3 id="功能描述-3"><a href="#功能描述-3" class="headerlink" title="功能描述"></a>功能描述</h3><p>解决全流程执行过程中，不定时弹出的已知弹窗</p><ul><li>不定时：不确定何时弹出，降低了流程的开发和执行效率</li><li>已知弹窗：弹窗需要是在流程设计中，遇到过的已知弹窗</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>连贯的原子性业务操作（如多次展开下拉框）如果被弹窗中断（下拉框可能会被折叠），关闭弹窗后无法返回中间步骤继续执行；建议搭建流程时将连贯操作放到一个try-catch整体中重试</li><li>弹窗出现时被阻断的业务操作是不确定的；建议在弹窗监控节点后校验关闭弹窗操作是否被正确执行</li><li>每个流程的弹窗监控最多可以设置开启10个任务，但出于性能考虑，建议弹窗监控不超过五个</li></ul><h3 id="使用说明-6"><a href="#使用说明-6" class="headerlink" title="使用说明"></a>使用说明</h3><ol><li><p>并行弹窗监控功能将对<strong>指定的.flow流程文件</strong>监控；</p></li><li><p>添加弹窗监控后，会在左侧项目栏中为添加过的流程文件名后显示监控</p></li><li><p>对流程添加弹窗监控后，可设置：</p><ul><li>捕获弹窗元素:<ul><li>捕获弹窗元素支持Windows内核弹窗和Chrome内核弹窗</li><li>捕获模式支持：常规、表格、UIA</li></ul></li><li>当捕获的弹窗为Chrome内核弹窗时，将在运行时通过对浏览器进行代码注入的方式，自动拦截该弹窗；</li></ul></li></ol>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>注意：</p><p><strong>由于向浏览器注入拦截代码需要耗时，请确保流程总的运行时长不短于10秒</strong></p>    </div>  </div><ol><li>当捕获的弹窗为windows弹窗时，需要用户手动设置处置流程。<ul><li>以截图中的消息提醒弹窗为例，可通过点击（坐标偏移）去关闭弹窗</li><li>对每一个弹窗，支持三种操作方式：：点击、输入文本、发送热键</li></ul></li><li>执行时将打印监控任务的日志</li></ol><p>日志将保存在以下目录：<strong>“%appdata%&#x2F;cyclone&#x2F;logs&#x2F;monitor”</strong></p>  <div class="note-large green">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-question"></i><p>QA</p>    </div>    <div class="notel-content">      <p>问题：开启了弹窗监控，要关闭的是Chrome内核的弹窗，但却发现关不掉</p><p>解决办法：如果这个弹窗是在打开Chrome浏览器后很快就出现的，建议在打开浏览器前加等待10秒，原因是关闭chrome弹窗的方式是通过注入JS脚本实现的，注入需要一定时间</p>    </div>  </div><h2 id="工具管理"><a href="#工具管理" class="headerlink" title="工具管理"></a>工具管理</h2><h3 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h3><h4 id="UI解析器-1"><a href="#UI解析器-1" class="headerlink" title="UI解析器"></a>UI解析器</h4><p>用于验证设计器的捕获能力，探测界面上的元素是否可以被捕获。功能详见：<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=3dc47008-251e-441e-a575-11bcfb3b5a9b" >UI解析器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="Inspect小工具"><a href="#Inspect小工具" class="headerlink" title="Inspect小工具"></a>Inspect小工具</h4><p>微软提供的官方捕获小工具，用于验证目标程序的元素是否按微软接口规范开发，不符合规范的元素是无法使用常规捕获的。</p><h4 id="诊断工具"><a href="#诊断工具" class="headerlink" title="诊断工具"></a>诊断工具</h4><p>收集电脑硬件环境,以及日志信息。详见说明：<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=3110de46-7998-4411-b272-f3c6b52852d4" >诊断工具 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="Cyclone浏览器"><a href="#Cyclone浏览器" class="headerlink" title="Cyclone浏览器"></a>Cyclone浏览器</h4><p>内置的浏览器，如果您的流程涉及网页自动化,推荐您使用此浏览器。</p><h4 id="恢复分辨率助手-Remote-Helper"><a href="#恢复分辨率助手-Remote-Helper" class="headerlink" title="恢复分辨率助手(Remote Helper)"></a>恢复分辨率助手(Remote Helper)</h4><p>帮助执行器所在的远程桌面恢复界面，如果您的流程涉及界面操作、且将在虚机中执行，建议您先使用此工具查看可恢复的分辨率列表，详见使用说明<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=386a4d99-de9d-4802-836c-cb1eb4f386d9" >恢复分辨率助手 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><h4 id="远程连接助手-Remote-Manager"><a href="#远程连接助手-Remote-Manager" class="headerlink" title="远程连接助手(Remote Manager)"></a>远程连接助手(Remote Manager)</h4><p>当您的机器人被部署在远程桌面上(无人值守场景)，您可在另一台独立的机器上安装远程连接助手并连接上中控，可在中控上配置执行流程时所需的分辨率，增强流程稳定性。详见说明<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=9d692f2e-eb26-40fd-b6a6-1f0114e86388" >远程连接助手 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="clog查看工具（logviewer）"><a href="#clog查看工具（logviewer）" class="headerlink" title="clog查看工具（logviewer）"></a>clog查看工具（logviewer）</h4><p>用于Clog日志内容的基本阅读。若你需要分析较大日志，建议你通过日志导出功能将日志还原（设置-诊断-导出日志），然后使用如notpad++等工具进行分析。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="Chrome插件"><a href="#Chrome插件" class="headerlink" title="Chrome插件"></a>Chrome插件</h4><p>安装Chrome插件，用于Chrome浏览器自动化操作。</p><h4 id="Edge插件"><a href="#Edge插件" class="headerlink" title="Edge插件"></a>Edge插件</h4><p>安装Edge插件，用于Edge浏览器自动化操作。</p><h4 id="Java插件"><a href="#Java插件" class="headerlink" title="Java插件"></a>Java插件</h4><p>安装Java插件，用于Java应用程序自动化操作。</p><h4 id="IE插件"><a href="#IE插件" class="headerlink" title="IE插件"></a>IE插件</h4><p>安装E插件,用于IE浏览器自动化操作。</p><h4 id="Firefox插件"><a href="#Firefox插件" class="headerlink" title="Firefox插件"></a>Firefox插件</h4><p>安装Firefox插件，用于Firefox浏览器自动化操作。</p><h4 id="360安全浏览器插件"><a href="#360安全浏览器插件" class="headerlink" title="360安全浏览器插件"></a>360安全浏览器插件</h4><p>安装360浏览器插件，用于360安全浏览器自动化操作。</p><h4 id="PS2驱动"><a href="#PS2驱动" class="headerlink" title="PS2驱动"></a>PS2驱动</h4><p>安装PS2键盘驱动，常用于输入密码控件。</p><h4 id="HID驱动"><a href="#HID驱动" class="headerlink" title="HID驱动"></a>HID驱动</h4><p>安装HID键盘驱动，常用于输入密码控件。</p><h4 id="FAR驱动"><a href="#FAR驱动" class="headerlink" title="FAR驱动"></a>FAR驱动</h4><p>安装FAR键盘驱动，常用于在远程桌面的密码控件中输入</p><h4 id="微软远程桌面插件"><a href="#微软远程桌面插件" class="headerlink" title="微软远程桌面插件"></a>微软远程桌面插件</h4><p>安装微软远程桌面插件，用于微软远程桌面自动化操作，注意需要在远程桌面中安装相应程序。<br>详见产品手册：<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=eba5f121-4805-46d2-a672-a730628379ef" >微软远程桌面插件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="Citrix插件"><a href="#Citrix插件" class="headerlink" title="Citrix插件"></a>Citrix插件</h4><p>安装Citrix插件，用于Citrix程序自动化操作，注意需要在Citrix中安装相应程序。</p><h3 id="Inspect小工具-1"><a href="#Inspect小工具-1" class="headerlink" title="Inspect小工具"></a>Inspect小工具</h3><h4 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>使用元素捕获功能时，常规、UIA、表格捕获模式不能正常捕获时（鼠标移动到目标元素时没有红框高亮）</li><li>想知道常规&#x2F;UIA&#x2F;表格捕获模式是否能够适配，可以先用Inspect小工具进行捕获</li><li>提问题工单时可以附上Inspect小工具的抓取截图</li></ul><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>前往设计器安装目录…\extra_resources\recorder\tool</li><li>使用管理员权限启动Inspect.exe进行捕获</li><li>用MSAA和UIA分别尝试一下，看下能否在目标元素上画出黄色框框：<ul><li>如果能画出黄色框框，请提问题工单，产研将相应适配这种场景，可以支持捕获</li><li>如果不能画出黄色框框，可以捕获目标元素所在的窗或者区域后，尝试一层一层展开元素DOM树<ul><li>如果无法展开更下层，说明内部元素无法被捕获，常规捕获无法适配，请用其他绕行方案（图片匹配、CV、快捷键、OCR等）</li><li>如果是CS客户端，查看Role属性<ul><li>如果是Role属性值是文档，可以推断这个软件应该是一个内嵌网页，可能可以适配，请提工单</li><li>如果是Role属性值是窗格，可以推断这个情况是由于微软没有提供接口，竞品友商都是抓不到的，请用其他绕行方案（图片匹配、CV、快捷键、OCR等）</li></ul></li></ul></li></ul></li><li>案例说明：</li></ul><ol><li>内网通的内部元素不可被捕获。</li><li>招行CBS7内部元素可被捕获。</li></ol><h3 id="诊断工具-1"><a href="#诊断工具-1" class="headerlink" title="诊断工具"></a>诊断工具</h3><h4 id="使用场景-9"><a href="#使用场景-9" class="headerlink" title="使用场景"></a>使用场景</h4><p>诊断工具，主要两个能力。<br>对安装RPA软件的设备进行预检，快速了解电脑的软件硬件信息。<br>用于发生故障时候，对设备的硬件、系统、软件、RAP及日志进行全面的搜集并打包，提交到研发同学定位问题。</p><h4 id="使用说明-7"><a href="#使用说明-7" class="headerlink" title="使用说明"></a>使用说明</h4><h5 id="1-如何获取"><a href="#1-如何获取" class="headerlink" title="1. 如何获取"></a>1. 如何获取</h5><ul><li>V4.5以下版本：独立绿色版的EXE小工具，可以像产品运营同学 申昌港获取。</li><li>V4.5及以上版本：通过工具管理打开</li></ul><h5 id="2-检测功能"><a href="#2-检测功能" class="headerlink" title="2. 检测功能"></a>2. 检测功能</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 用户点击“检测”按钮后，软件会调起资源管理器弹出层，选择路径后进行保存报告。</span><br></pre></td></tr></table></figure></div><h3 id="恢复分辨率助手-Remote-Helper-1"><a href="#恢复分辨率助手-Remote-Helper-1" class="headerlink" title="恢复分辨率助手(Remote Helper)"></a>恢复分辨率助手(Remote Helper)</h3><h4 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h4><p>恢复分辨率助手(RH)是一个独立的应用程序，可以帮助机器人恢复远程桌面的连接，可独立安装使用，无需升级设计器和执行器的版本。</p><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>无人值守&#x2F;远程机器人通常被部署在云桌面上，在机器人执行控界面元素相关操作时，如果用户断开了远程连接，电脑系统会回收鼠标键盘权限，导致机器人相关操作执行失败，因此需要Remote Helper帮助机器人恢复远程桌面的连接。</p><h4 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h4><ul><li>支持Vmware, 微软云、阿里云、腾讯云、Windows远程桌面</li><li>不支持win-server多用户登录的场景（一个恢复分辨率助手(RH)只能服务于一个用户，一台电脑只能开启一个恢复分辨率助手(RH)，也就是说在多用户登录的场景下，只有一个用户断开远程桌面后能使用恢复分辨率助手(RH)帮助机器人恢复）</li><li>不支持win server 2008</li><li>不支持Citrix、华为云（目前恢复分辨率助手(RH)无法正常工作）</li><li>如遇上述场景，请使用<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=feb96856-3950-4448-b36d-88a532352ac0" >远程连接助手(Remote Manager) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><h4 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h4><ol><li>前往设计器的安装目录下\extra_resources\recorder，确保存在以下三个文件：<ul><li>RemoteHelper.exe</li><li>RemoteHelper_Detail.bat</li><li>RemoteHelper_Monitor.bat</li></ul></li><li>确保与action_gui.dll文件在平级目录，不能用文件夹隔开；</li><li>确保AgentHelper.exe进程不处于运行状态；</li><li>确保tscon.exe进程不处于运行状态；</li><li>确保没有运行过close-rdp.cmd脚本。</li></ol><h4 id="RemoteHelper-Detail-bat"><a href="#RemoteHelper-Detail-bat" class="headerlink" title="RemoteHelper_Detail.bat"></a>RemoteHelper_Detail.bat</h4><ol><li>运行RemoteHelper_Detail.bat文件，可以让实施人员提前知道，这台云桌面（即执行器所在的设备）可以使用恢复分辨率助手(RH)自动恢复到哪几个分辨率；</li><li>设计流程时使用的电脑分辨率（即设计器所在的设备），应尽可能的与推荐的分辨率一致，以增强稳定性；</li></ol><h4 id="RemoteHelper-Monitor-bat"><a href="#RemoteHelper-Monitor-bat" class="headerlink" title="RemoteHelper_Monitor.bat"></a>RemoteHelper_Monitor.bat</h4><ol><li>运行RemoteHelper_Monitor.bat文件，可以让远程连接断开后，帮助机器人恢复远程桌面的连接，以确保执行器正常工作；</li><li>这个不需要每次断开前都执行，注意在每次电脑重启&#x2F;注销之后，手动执行一次即可。</li></ol><h3 id="远程连接助手-Remote-Manager-1"><a href="#远程连接助手-Remote-Manager-1" class="headerlink" title="远程连接助手(Remote Manager)"></a>远程连接助手(Remote Manager)</h3><h4 id="使用场景-10"><a href="#使用场景-10" class="headerlink" title="使用场景"></a>使用场景</h4><p>无人值守&#x2F;远程机器人通常被部署在云桌面上，而在用户断开了云桌面的远程连接时，系统会回收鼠标键盘权限，导致机器人执行前台操作时失败，需要产品化解决方案，应对这种场景</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ul><li>已部署中控，远程连接助手(RM)需要使用中控账号登录</li><li>远程连接助手(RM)需要被安装于一台Windows系统的电脑上，这台电脑可以使用远程桌面连接（mstsc）连接到所有执行器所在的云桌面</li><li>如果远程连接助手(RM)安装在云桌面，注意RM不能自己连接自己，所以这台云桌面不能断开连接</li><li>电脑配置要求<ul><li>系统要求：WIN7及以上</li><li>连接一个机器人要100~150M内存</li><li>举例：8G内存电脑可以连接50+个远端机</li></ul></li></ul><h4 id="功能介绍-2"><a href="#功能介绍-2" class="headerlink" title="功能介绍"></a>功能介绍</h4><p><strong>什么是远程连接助手RemoteManager（RM）？</strong></p><ul><li>用于管理执行器所在的云桌面</li><li>可以模拟远程连接到云桌面，确保云桌面都在连接状态下执行流程</li></ul><p><strong>为什么需要远程连接助手RemoteManager（RM）？</strong></p><ul><li>使用RM用户可以配置连接云桌面时的分辨率，解决目前用户的痛点问题：<ul><li>分辨率变化很大，导致流程不稳定</li><li>低分辨率下开发，用户体验不好</li></ul></li></ul><p><strong>远程连接助手(RM)和<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=ccc3e562-51fc-4d32-8249-5e9d92ea0a2b" >恢复分辨率助手RemoteHelper(RH) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的关系？</strong></p><ul><li>两者并不冲突，可以配合使用</li><li>恢复分辨率助手(RH)适合的场景：<ul><li>客户购买的无人值守&#x2F;远程机器人数量较少，比如只有一两台</li><li>客户不愿耗费多一台机器的资源用于安装远程连接助手(RM)</li><li>流程执行不受分辨率变化影响或影响较小</li></ul></li></ul><h4 id="使用说明-8"><a href="#使用说明-8" class="headerlink" title="使用说明"></a>使用说明</h4><h5 id="1-连接至中控"><a href="#1-连接至中控" class="headerlink" title="1.连接至中控"></a>1.连接至中控</h5><ul><li>确保使用的中控账号 拥有执行器设备管理权限</li></ul><h5 id="2-在中控上管理远程连接助手"><a href="#2-在中控上管理远程连接助手" class="headerlink" title="2.在中控上管理远程连接助手"></a>2.在中控上管理远程连接助手</h5><ul><li><p>连接成功后，进入连接列表页面，展示当前受中控调度去连接了哪些云桌面（不再支持RM本地连接云桌面的方式）</p></li><li><p>连接成功后，中控的远程桌面连接助手列表页会新增一条RM设备，状态为可用，可配置最大连接数，表示最多可连接多少个云桌面</p></li><li><h5 id="在中控流程列表开启远程助手"><a href="#在中控流程列表开启远程助手" class="headerlink" title="在中控流程列表开启远程助手"></a>在中控流程列表开启远程助手</h5><ul><li>在中控上传了一个包含“界面自动化”操作的流程，且设计器版本是4.4beta及以上，会在流程详情看到流程设计时的分辨率</li><li>如果希望该流程在设计时分辨率下执行，可开启远程连接助手，开启后会在流程下发到执行器时，自动调度远程连接助手RM、以该分辨率连接执行器所在的设备</li></ul></li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>仅在流程执行前 中控会下发一次连接任务到RM，也就是说，如果在执行过程中有人连接到远程桌面的话，会踢掉RM的连接，且RM不会再次进行连接</p>    </div>  </div><ul><li>启用远程连接助手时，可以选择如果RM连接失败，流程是否还继续执行，默认是继续执行</li></ul><h3 id="捕获远程桌面插件"><a href="#捕获远程桌面插件" class="headerlink" title="捕获远程桌面插件"></a>捕获远程桌面插件</h3><h4 id="使用场景-11"><a href="#使用场景-11" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>随着云桌面在企业中的广泛应用，前场会遇到这样的场景：RPA需要操作的应用软件安装在远程桌面，而设计器和执行器则安装在本机&#x2F;另一台虚机</li><li>设计器在捕获元素的时候，没法捕获到在远程桌面上的元素</li><li>在加入抓取远程桌面插件后，将支持微软远程桌面&#x2F;Citrix等常见的远程桌面工具，实现对远程桌面元素的捕获</li></ul><h4 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h4><p>支持对象：微软远程桌面&#x2F;Citrix</p><ul><li>远程桌面必须是Windows系统，已验证支持Win7、Win10、win sever 2016</li><li>需要同时在设计器端和远程桌面端安装插件</li><li>设计器端和远程桌面端都需要使用管理员权限安装插件</li></ul><h4 id="使用说明-9"><a href="#使用说明-9" class="headerlink" title="使用说明"></a>使用说明</h4><h5 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h5><ol><li>在设计器端安装<ol><li>以管理员身份运行设计器</li><li>退出已开启的远程桌面</li><li>前往“工具管理”，点击安装“微软远程桌面”、“Citrix插件”</li><li>插件安装成功后，打开远程桌面进行远程桌面端的安装</li></ol></li></ol><h5 id="在远程桌面中安装"><a href="#在远程桌面中安装" class="headerlink" title="在远程桌面中安装"></a>在远程桌面中安装</h5><ol><li>在设计器安装目录下，寻找“…\cyclone\extra_resources\recorder\tool\RemotePackage”文件夹</li><li>将“RemotePackage”文件夹复制到远程桌面中</li><li>如果需要在远程桌面中捕获IE、Chrome、…，需要以管理员身份运行”…\RemotePackage\InstallAsAdministrator.bat”，安装常用的浏览器插件</li><li>管理员身份运行“…\RemotePackage\cyclone_remote.exe”，等待进程出现在任务管理器中，即可实现对远程桌面的捕获</li><li>注意如果远程桌面重启了，需要再次手动启动该进程</li></ol><h4 id="插件卸载"><a href="#插件卸载" class="headerlink" title="插件卸载"></a>插件卸载</h4><p>在设计器卸载</p><ul><li>卸载设计器时会自动卸载插件</li></ul><p>在远程桌面中卸载</p><ul><li>如需卸载远程桌面中安装的浏览器插件，需要以管理员身份运行“…\UninstallAsAdministrator.bat”，卸载安装的浏览器插件</li></ul><h4 id="元素选择器更新"><a href="#元素选择器更新" class="headerlink" title="元素选择器更新"></a>元素选择器更新</h4><ul><li>当用户捕获远程桌面中的元素后，元素选择器会多一层数据：<ul><li>远程桌面窗口标题，支持修改</li><li>远程桌面类型</li></ul></li></ul><h4 id="UI解析器更新"><a href="#UI解析器更新" class="headerlink" title="UI解析器更新"></a>UI解析器更新</h4><ul><li>当用户捕获远程桌面元素之后，UI解析器会多一层数据：<ul><li>远程桌面窗口标题</li><li>远程桌面类型</li><li>远程桌面窗口的宽高左上</li></ul></li></ul><h4 id="Chrome浏览器插件-安装说明"><a href="#Chrome浏览器插件-安装说明" class="headerlink" title="Chrome浏览器插件 安装说明"></a>Chrome浏览器插件 安装说明</h4><h5 id="一、检查插件"><a href="#一、检查插件" class="headerlink" title="一、检查插件"></a>一、检查插件</h5><ol><li>查看插件安装和打开状态，可以通过三种方式打开。</li></ol><p>①拼图按钮-&gt;管理扩展程序</p><p>②三点按钮-&gt;更多工具-&gt;扩展程序</p><p>③在Chrome地址栏直接输入chrome:&#x2F;&#x2F;extensions&#x2F;，敲击回车</p><p>④在打开的页面确认是否有Cyclone Automation Tool的扩展，并且已经打开。</p><h5 id="二、安装方式"><a href="#二、安装方式" class="headerlink" title="二、安装方式"></a>二、安装方式</h5><ol><li><p>设计器软件安装时自动安装插件</p><ul><li><p>Chrome插件在设计器安装时会自动安装（安装时需要关闭浏览器，否则会强制关闭），再次打开浏览器页面会提示打开插件。</p></li><li><p>注意：再次打开浏览器页面时，请务必手动点击打开插件按钮。</p></li></ul></li><li><p>设计器软件中手动安装（推荐）</p><ul><li><p>点击左侧边栏工具管理按钮，点击Chrome插件旁边的“安装”按钮（安装时需要关闭浏览器，否则会强制关闭）。</p></li><li><p>此时会弹出你要允许此应用对你的设备进行更改吗？点击是，等待自动安装完成即可。</p></li><li><p>再次打开浏览器页面，页面右上角会提示打开插件，请手动点击“启用扩展程序”。</p></li></ul></li><li><p>其他安装方式</p><ul><li><p>在设计器的安装目录下\extra_resources\recorder找到文件SpeedAutomationTool.crx，并将它拖入Chrome扩展管理的页面</p></li><li><p>右上角打开开发者模式后，将SpeedAutomationTool.crx文件拖入即可安装，如果不能拖入安装，需要进行</p></li><li><p>在地址栏输入chrome:&#x2F;&#x2F;flags&#x2F;#extensions-on-chrome-urls，并把黄色高亮选项改为enabled。</p></li></ul></li></ol><h5 id="三、启用扩展"><a href="#三、启用扩展" class="headerlink" title="三、启用扩展"></a>三、启用扩展</h5><ul><li>方式一：浏览器提示启用<ul><li>扩展安装完毕后，初次打开浏览器，会弹出一个提示，这时需点击启用扩展程序按钮</li></ul></li><li>方式二：手动启用<ul><li>点击浏览器右上角的①三个点状按钮（自定义及控制Google Chrome）按钮，打开菜单</li><li>点击②更多工具(L) 选项，展开更多工具菜单</li><li>点击③扩展程序(E)选项，打开扩展程序页面</li><li>找到Cyclone Automation Tool，点击开关</li></ul></li></ul><h3 id="IE浏览器插件"><a href="#IE浏览器插件" class="headerlink" title="IE浏览器插件"></a>IE浏览器插件</h3><p>IE插件在设计器安装时会自动安装（安装时需要关闭浏览器，否则会强制关闭）并打开。</p><h4 id="一、检查插件-1"><a href="#一、检查插件-1" class="headerlink" title="一、检查插件"></a>一、检查插件</h4><p>查看插件安装和打开状态，检查是否已安装并开启IE加载项</p><p>点击设置&gt;管理加载项</p><p>启用名称为【BridgeIEBHO Class】的加载项, - 只需启用一次，启用后重启IE即可正常抓取IE元素</p><h4 id="二、安装插件"><a href="#二、安装插件" class="headerlink" title="二、安装插件"></a>二、安装插件</h4><ol><li>设计器软件中手动安装（推荐）</li></ol><ul><li>如果在IE找不到对应的加载项，则需要手动安装插件。首先点击左侧边栏工具管理按钮，点击IE插件旁边的“安装”按钮（安装时需要关闭浏览器，否则会强制关闭）。</li><li>此时会弹出你要允许此应用对你的设备进行更改吗？点击是，等待自动安装完成即可。</li><li>再次打开IE浏览器，启用BridgeIEBHO Class加载项，重启浏览器后即可正常捕获元素。</li></ul><ol start="2"><li>其他安装方式</li></ol><ul><li>在设计器的安装目录下\resources\runTime\cpp找到文件InstallAsAdministrator.bat关闭IE浏览器后，使用管理员权限运行bat文件</li><li>此时会弹出你要允许此应用对你的设备进行更改吗？点击是，进入命令提示符界面，等待命令提示符代码自动运行完。</li><li>再次打开IE浏览器，启用BridgeIEBHO Class加载项，重启浏览器后即可正常捕获元素。</li></ul><h4 id="三、启用加载项"><a href="#三、启用加载项" class="headerlink" title="三、启用加载项"></a>三、启用加载项</h4><ul><li>点击设置&gt;管理加载项</li><li>启用名称为【BridgeIEBHO Class】的加载项（若找不到该加载项请看<a class="link"   href="http://docs.cyclone-robotics.com/articles?a=bf027d2d-4d06-4cc4-b851-9a3afb65296b" >IE浏览器插件 常见问题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</li><li>只需启用一次，启用后重启IE即可正常抓取IE元素</li></ul><h3 id="Edge浏览器插件"><a href="#Edge浏览器插件" class="headerlink" title="Edge浏览器插件"></a>Edge浏览器插件</h3><p>Edge插件在设计器安装时会自动安装（安装时需要关闭浏览器，否则会强制关闭）并打开。</p><h4 id="一、检查插件-2"><a href="#一、检查插件-2" class="headerlink" title="一、检查插件"></a>一、检查插件</h4><p>查看插件安装和打开状态</p><p>点击拼图按钮-&gt;管理扩展</p><p>在地址栏输入edge:&#x2F;&#x2F;extensions&#x2F;，查看是否有</p><p>查看是否有名为Cyclone Automation Tool的扩展和打开的状态，如果未打开，点击按钮打开。如果未安装，请按照下面的指南安装插件。</p><h4 id="二、安装插件-1"><a href="#二、安装插件-1" class="headerlink" title="二、安装插件"></a>二、安装插件</h4><ol><li><p>V3.1.4以前的设计器版本，需要手动安装扩展：<br>（1）连接外网，需要可以访问谷歌的网上应用商店<br>（2）打开<a class="link"   href="https://chrome.google.com/webstore/detail/cyclone-automation-tool/jagfdihfpakhdjbhcmoppfgcggcfobnh" >Cyclone Automation Tool - Chrome 网上应用店 (google.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>（3）点击安装</p></li><li><p>V3.1.4及以上的设计器版本，可以在设计器软件中手动安装（推荐）</p><ul><li><p>如果在Edge找不到对应的加载项，则需要手动安装插件。首先点击左侧边栏工具管理按钮，点击Edge插件旁边的“安装”按钮（安装时需要关闭浏览器，否则会强制关闭）。</p></li><li><p>此时会弹出你要允许此应用对你的设备进行更改吗？点击是，等待自动安装完成即可。</p></li><li><p>再次打开Edge浏览器，在右上角弹出界面中选择“打开扩展”按钮。</p></li></ul></li><li><p>其他安装方式</p><ul><li><p>在设计器的安装目录下\resources\runTime\cpp找到文件CycloneAutomationTool.crx</p></li><li><p>左下角打开开发者模式后，将CycloneAutomationTool.crx文件拖入并点击添加扩展即可</p></li></ul></li></ol><h4 id="三、启用扩展-1"><a href="#三、启用扩展-1" class="headerlink" title="三、启用扩展"></a>三、启用扩展</h4><ol><li>安装成功后，进入①管理扩展，②启用扩展</li><li>启用后，重启重启浏览器后可正常捕获元素。</li></ol><h2 id="UI解析器-2"><a href="#UI解析器-2" class="headerlink" title="UI解析器"></a>UI解析器</h2><h3 id="前置条件-1"><a href="#前置条件-1" class="headerlink" title="前置条件"></a>前置条件</h3><ul><li>如需捕获Chrome，请安装和启用Chrome插件</li><li>如需捕获IE，请安装和启用IE加载项</li><li>如需捕获Java，请安装Java Hook</li><li>如需捕获SAP，请SAP客户端和服务端均启用GUI脚本权限</li></ul><h3 id="功能入口-4"><a href="#功能入口-4" class="headerlink" title="功能入口"></a>功能入口</h3><ul><li>右键单击画布中的组件</li><li>属性栏的目标元素中的“更多”图标</li><li>元素选择器中的“在UI解析器中查看”</li></ul><h3 id="属性列表-1"><a href="#属性列表-1" class="headerlink" title="属性列表"></a>属性列表</h3><p>属性列表分为【窗口属性】和【元素属性】两部分，【窗口属性】代表的是元素所在窗口，【元素属性】为元素本身</p><p>【info】部分属性，如果被取消勾选，当前属性值会在保存、复制、高亮时舍弃</p><p>【属性项】属性名称，不支持编辑</p><p>【匹配模式】下拉可选：&#x3D; 等于、*通配、.*正则</p><p>【属性值】支持编辑，点击即可编辑</p><p>【变量】可引用设计器中的变量 。</p><h3 id="属性对比"><a href="#属性对比" class="headerlink" title="属性对比"></a>属性对比</h3><p>点击【属性对比】，进行第二次捕获</p><p>可对比前后两次捕获，目标元素的属性不同的地方</p><p>在对比值中高亮红字，代表属性值发生了变化 ：</p><ul><li>将发生变化的属性值改为通配符或正则表达式</li><li>如果是有规律的变化，可考虑使用“引用变量”功能</li><li>将变化很大的属性取消勾选</li></ul><h3 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h3><p>开启【原始数据】开关，方便直接修改源代码。</p><h3 id="复制与粘贴"><a href="#复制与粘贴" class="headerlink" title="复制与粘贴"></a>复制与粘贴</h3><p>在UI解析器中捕获后，点击【复制到剪贴板】按钮，复制完整的selector，可粘贴至设计器节点</p><p>在设计器中捕获的元素，也可复制selector后，点击UI解析器中的【粘贴至解析器】</p><h3 id="查看捕获截图"><a href="#查看捕获截图" class="headerlink" title="查看捕获截图"></a>查看捕获截图</h3><p>用户抓取时对元素所在界面的截图，红框高亮目标元素</p><h3 id="层级捕获"><a href="#层级捕获" class="headerlink" title="层级捕获"></a>层级捕获</h3><h4 id="使用场景-12"><a href="#使用场景-12" class="headerlink" title="使用场景"></a>使用场景</h4><p>捕获元素时，需要使用鼠标，但需要捕获的元素在鼠标移动上后会隐藏，这导致了不能捕获<br>网页上有遮罩层，导致捕获不到想要的目标元素</p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li><p>点击层级捕获按钮，捕获所需要的内容，如果出现遮罩层或被隐藏的元素，则对包含其所在的部分进行捕获。</p></li><li><p>捕获后在界面右侧会生成元素层级树，你所捕获的部分会被高亮显示。根据对层级树结构的判断，找到具体需要捕获的元素并双击，此时编辑器中元素属性的属性值会发生改变，变为你需要真正捕获的元素值，最后点击保存。</p></li></ul><h4 id="匹配方式-1"><a href="#匹配方式-1" class="headerlink" title="匹配方式"></a>匹配方式</h4><p>【精准匹配】基于固定值或变量值，可在输入框中输入固定值，或@引用变量</p><p>【通配匹配】支持通配符“*”和“？”</p><p>*：代替零个、单个或多个字符</p><p>？：代替一个字符</p><p>【正则匹配】</p><p>支持Perl正则表达式，详见链接：<a class="link"   href="https://www.runoob.com/perl/perl-regular-expressions.html" >https://www.runoob.com/perl/perl-regular-expressions.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>实现的是regex_search功能，实现部分匹配而不是完全匹配，举例来说，如果目标元素是“百度一下，你就知道“，如果选择了正则匹配，匹配值为”百度“，是可以匹配上的。</p><h2 id="Git版本管理"><a href="#Git版本管理" class="headerlink" title="Git版本管理"></a>Git版本管理</h2><h3 id="功能说明-3"><a href="#功能说明-3" class="headerlink" title="功能说明"></a>功能说明</h3><p>Git管理功能可以满足流程设计者的版本管理需求。</p><h3 id="使用说明-10"><a href="#使用说明-10" class="headerlink" title="使用说明"></a>使用说明</h3><p>在使用git管理功能对项目进行版本控制前，需要完成git初始化操作</p><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><h4 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h4><ul><li>在设计器端使用git进行版本管理之前，需要在本地机器上安装git</li><li>当本地git未安装时，设计器会提示git未安装</li><li>此时，点击”进入官网“下载并安装Git</li><li>Git已安装</li><li>当完成Git的安装后，需要编辑Git作者信息以完成初始化</li><li>Git初始配置</li><li>配置用户名称及邮箱（即在git bash中配置的用户名和邮箱）</li><li>完成后即可选择初始化项目仓库</li><li>Git配置更新</li><li>设计器端不可移除Git作者，但可对Git作者进行更新</li><li>如需移除Git作者，需要在Git Bash中输入指令<ul><li>git config –global –unset user.name “yourUserName”</li><li>git config –global –unset user.email “yourEmail”</li><li>当本地的账号被移除之后，设计器中的作者会自动被移除</li></ul></li></ul><h3 id="项目仓库初始化"><a href="#项目仓库初始化" class="headerlink" title="项目仓库初始化"></a>项目仓库初始化</h3><ul><li>完成本机Git安装和用户信息配置后，点击初始化项目仓库<ul><li>初始化项目仓库完成后，即可看到提交版本和历史版本</li></ul></li></ul><h3 id="功能介绍-3"><a href="#功能介绍-3" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本:"></a>提交版本:</h4><ul><li><p>提交前校验</p><p>保存校验：当用户提交任意项目文件前，会自动校验文件是否保存</p></li><li><p>本地仓库创建、更新</p><ol><li>选中需要提交的文件，填写提交信息并提交后，将完成项目的初始化</li><li>初次提交时，会在项目的目录，生成Git本地仓库 “.git” （发布的时候将忽略 .git目录，工程项目中没有.git目录）</li><li>再次提交时，完成本地仓库的更新</li></ol></li><li><p>提交版本中支持对文件进行搜索</p></li><li><p>支持精准匹配和关键字匹配，如使用文件名、文件后缀进行搜索</p></li></ul><h4 id="历史版本："><a href="#历史版本：" class="headerlink" title="历史版本："></a>历史版本：</h4><p>查看历史版本</p><ul><li>在历史提交记录中，可以查看提交说明、提交时间、提交版本号</li><li>支持流程文件（flow文件）、代码块文件（python、JS、MJS类型文件…）的比对</li><li>文件可点击查看变更内容，比较历史版本版本和前一版本的内容差异（绿色 新增，红色 删除）</li><li>文件内容搜索：可搜索到对应的节点（历史版本和本地版本都可以搜索）、python文件、JS文件可以定位到行号</li></ul><h4 id="提交版本-1"><a href="#提交版本-1" class="headerlink" title="提交版本:"></a>提交版本:</h4><ul><li><p>项目下载</p><p>点击列表下载图标，可下载对应版本的项目文件</p><p>选择目标目录，可下载对应的项目</p><p>点击下载后，用户选择要保存的路径，确认后完成版本下载</p><p>下载的文件为项目压缩包</p></li><li><p>配置用户名称及邮箱（即在git bash中配置的用户名和邮箱）</p><p>完成后即可选择初始化项目仓库</p><p>Git配置更新</p><p>设计器端不可移除Git作者，但可对Git作者进行更新</p><p>如需移除Git作者，需要在Git Bash中输入指令</p><ul><li>git config –global –unset user.name “yourUserName”</li><li>git config –global –unset user.email “yourEmail”</li><li>当本地的账号被移除之后，设计器中的作者会自动被移除</li></ul></li></ul><h4 id="项目仓库初始化-1"><a href="#项目仓库初始化-1" class="headerlink" title="项目仓库初始化"></a>项目仓库初始化</h4><ul><li>完成本机Git安装和用户信息配置后，点击初始化项目仓库</li><li>初始化项目仓库完成后，即可看到提交版本和历史版本</li></ul><h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><ul><li><p>功能介绍</p><p>提交版本:</p><ul><li><p>提交前校验</p><p>保存校验：当用户提交任意项目文件前，会自动校验文件是否保存</p></li><li><p>本地仓库创建、更新</p><ol><li>选中需要提交的文件，填写提交信息并提交后，将完成项目的初始化</li><li>初次提交时，会在项目的目录，生成Git本地仓库 “.git” （发布的时候将忽略 .git目录，工程项目中没有.git目录）</li><li>再次提交时，完成本地仓库的更新</li></ol></li><li><p>本地仓库文件搜索展示：</p><p>提交版本中支持对文件进行搜索</p><p>支持精准匹配和关键字匹配，如使用文件名、文件后缀进行搜索</p></li></ul></li></ul><h4 id="历史版本：-1"><a href="#历史版本：-1" class="headerlink" title="历史版本："></a>历史版本：</h4><ul><li><p>查看历史版本</p><p>在历史提交记录中，可以查看提交说明、提交时间、提交版本号</p></li><li><p>支持流程文件（flow文件）、代码块文件（python、JS、MJS类型文件…）的比对</p><p>文件可点击查看变更内容，比较历史版本版本和前一版本的内容差异（绿色 新增，红色 删除）</p><ul><li>文件内容搜索：可搜索到对应的节点（历史版本和本地版本都可以搜索）、python文件、JS文件可以定位到行号</li></ul></li><li><p>文件下载</p><p>项目下载</p><ol><li>点击列表下载图标，可下载对应版本的项目文件</li><li>选择目标目录，可下载对应的项目</li><li>点击下载后，用户选择要保存的路径，确认后完成版本下载</li><li>下载的文件为项目压缩包</li></ol></li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h4><ul><li>支持http和ssh方法进行克隆，输入远程仓库地址及用户名密码信息后即可成功克隆。</li></ul><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>能够实现用户连接远程仓库后，将本地仓库当前内容提交到远程仓库，并支持文件层级的冲突展示与解决冲突。</p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>能够实现用户连接远程仓库后，将远程仓库最新代码同步至本地</p><h4 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h4><p>用户可以下载远程仓库的历史版本内容，打包下载到本地指定文件夹。</p><h2 id="Designer-Pro-连接中心"><a href="#Designer-Pro-连接中心" class="headerlink" title="Designer Pro 连接中心"></a>Designer Pro 连接中心</h2><h3 id="中控"><a href="#中控" class="headerlink" title="中控"></a>中控</h3><p>Designer Pro连接中心主要管理设计器连接的外部服务器。</p><p>设计器的连接中心，支持基于中控的账号密码，以及账号+密钥的连接方式。</p><h3 id="AI服务"><a href="#AI服务" class="headerlink" title="AI服务"></a>AI服务</h3><h4 id="功能描述-4"><a href="#功能描述-4" class="headerlink" title="功能描述"></a>功能描述</h4><p>连接AI服务器，获得AI服务器的基本信息，并支持AI节点运行</p><h4 id="使用场景-13"><a href="#使用场景-13" class="headerlink" title="使用场景"></a>使用场景</h4><p>某些项目需要基于CV ROBOT 或连接到技能平台，可使用该模块进行连接信息配置</p><h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><p>入口：在设计器的 “连接中心”面板中，新增了一个“AI服务”页签，可打开直连服务的配置弹出层。</p><p>配置：点击连接新服务，可以打开添加服务弹出层。在弹出层中输入正确的连接地址、账号、密码。然后点击连接，即可完成配置。配置成功后，界面将会展示从服务器端读取到的基本参数信息。、连接失败则提醒失败信息。</p>]]></content>
    
    
    <summary type="html">弘玑Cyclone RPA</summary>
    
    
    
    <category term="RPA" scheme="https://www.yiuhangblog.com/categories/RPA/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="弘玑" scheme="https://www.yiuhangblog.com/tags/%E5%BC%98%E7%8E%91/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向</title>
    <link href="https://www.yiuhangblog.com/2022/01/08/20220108JS%E9%80%86%E5%90%91/"/>
    <id>https://www.yiuhangblog.com/2022/01/08/20220108JS%E9%80%86%E5%90%91/</id>
    <published>2022-01-08T10:12:46.000Z</published>
    <updated>2024-02-28T10:35:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS逆向简要介绍案例：模拟百度翻译请求"><a href="#JS逆向简要介绍案例：模拟百度翻译请求" class="headerlink" title="JS逆向简要介绍案例：模拟百度翻译请求"></a>JS逆向简要介绍案例：模拟百度翻译请求</h2><h3 id="检查百度翻译请求"><a href="#检查百度翻译请求" class="headerlink" title="检查百度翻译请求"></a>检查百度翻译请求</h3><p>首先，对百度翻译的请求进行了检查。通过分析发现，百度翻译使用的是<code>POST</code>请求方法。在翻译过程中的请求载荷内容进行了详细观察。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/232002a1-fe68-4401-97ad-2ddb65a4ce00/public"                      width = "300"                ><h3 id="请求参数分析"><a href="#请求参数分析" class="headerlink" title="请求参数分析"></a>请求参数分析</h3><p>在请求的脚本参数中，发现了<code>from</code>和<code>to</code>字段。通过模拟操作，可以推断出这些参数代表着翻译的源语言和目标语言，例如从中文翻译到英文。进一步观察表单数据，可以看到请求所携带的所有参数。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a81e1962-4cfc-400a-f12c-0ea54567e000/public"                      width = "600"                ><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>对于请求的表头参数也进行了检查，以便在模拟请求时能够更准确地伪装。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/905e8fed-305a-4c48-96f3-07db1ffa4f00/public"                      width = "600"                ><h3 id="Sign参数"><a href="#Sign参数" class="headerlink" title="Sign参数"></a>Sign参数</h3><p>首先<code>ctrl</code>+<code>shift</code>+<code>f</code> 全局搜索<code>sign</code>参数所在源代码</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/04a3d114-05d8-4dd8-d9fd-4741a5b32200/public"                      width = "600"                ><p>一个个查看这些<code>sign</code>参数，对符合js模式的进行断点</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9070fc9c-f1cd-43f0-3300-c9483e09a900/public"                      width = "600"                ><p>重新执行翻译过程，可以发现断点停留在<code>sign: b(e)</code>，即js方法调用处</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9cec1c36-4375-4a7b-3000-cee0548ed000/public"                      width = "600"                ><p>在控制台输入参数可以看到<code>sign</code>的值</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e46a1fb6-57a0-49ff-7f08-d44a3a82a700/public"                      width = "600"                ><p>跳转这个调用到其源代码</p><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><h4 id="爬虫代码"><a href="#爬虫代码" class="headerlink" title="爬虫代码"></a>爬虫代码</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jsdata</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求URL和头部信息</span></span><br><span class="line">url = <span class="string">&#x27;https://fanyi.baidu.com/v2transapi?from=zh&amp;to=en&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 ...&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;PSTM=1694260469; BIDUPSID=...; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1703248315;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Acs-Token&#x27;</span>: <span class="string">&#x27;1703217664841_1703248346365_aQyvrnWWYIouJv2VqASm...&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户输入的翻译内容</span></span><br><span class="line">a = <span class="built_in">input</span>(<span class="string">&#x27;输入你要翻译的内容:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用jsdata模块生成签名</span></span><br><span class="line">sign = jsdata.make_js_data(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建表单数据</span></span><br><span class="line">form_data = &#123;</span><br><span class="line">    <span class="string">&quot;from&quot;</span>: <span class="string">&quot;zh&quot;</span>,</span><br><span class="line">    <span class="string">&quot;to&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: a,</span><br><span class="line">    <span class="string">&quot;transtype&quot;</span>: <span class="string">&quot;realtime&quot;</span>,</span><br><span class="line">    <span class="string">&quot;simple_means_flag&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sign&quot;</span>: sign,</span><br><span class="line">    <span class="string">&quot;token&quot;</span>: <span class="string">&quot;2977c992c92eb0731d89f23d17b6edd7&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain&quot;</span>: <span class="string">&quot;common&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ts&quot;</span>: <span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>)),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送POST请求并输出结果</span></span><br><span class="line">res = requests.post(url, headers=headers, data=form_data)</span><br><span class="line"><span class="built_in">print</span>(res.json().get(<span class="string">&quot;trans_result&quot;</span>).get(<span class="string">&quot;data&quot;</span>)[<span class="number">0</span>].get(<span class="string">&#x27;dst&#x27;</span>))</span><br></pre></td></tr></table></figure></div><p>以上代码首先导入了必要的模块，设置了请求的URL和头部信息。通过用户输入获取翻译内容，然后使用<code>jsdata</code>模块来生成签名。随后构建表单数据，包括语言类型、查询词、时间戳等，并发送POST请求。最后，从返回的JSON数据中提取并打印翻译结果。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><code>&quot;ts&quot;: str(int(time.time()*1000))</code> 用于生成一个时间戳，这个时间戳是表单数据（form_data）的一部分，发送给百度翻译的服务器。下面详细解释这个时间戳的生成过程：</p><ol><li><code>time.time()</code>: 这个函数来自Python的<code>time</code>模块，用于获取当前时间。它返回的是一个浮点数，代表自1970年1月1日（称为Unix纪元或Epoch时间）以来的秒数。</li><li><code>time.time() * 1000</code>: 由于<code>time.time()</code>返回的是秒数，而通常服务器端需要的时间戳是以毫秒为单位的。因此，将其乘以1000，将秒转换成毫秒。</li><li><code>int(...)</code>: 这个函数将浮点数转换为整数。在这里，它将乘以1000后的结果转换成整数形式，因为时间戳通常是整数形式的毫秒值。</li><li><code>str(...)</code>: 最后，<code>int</code>类型的时间戳被转换成字符串（<code>str</code>），因为在构建表单数据时，需要的是字符串形式的时间戳。</li></ol><p>综合来看，<code>&quot;ts&quot;: str(int(time.time()*1000))</code> 这一行代码生成了一个表示当前时间的毫秒级时间戳，并将其转换为字符串格式，以便作为HTTP请求的一部分发送。</p>    </div>  </div><h4 id="JS逆向代码"><a href="#JS逆向代码" class="headerlink" title="JS逆向代码"></a>JS逆向代码</h4><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">n</span>(<span class="params">t, e</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; e.<span class="property">length</span> - <span class="number">2</span>; n += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = e.<span class="title function_">charAt</span>(n + <span class="number">2</span>);</span><br><span class="line">        r = <span class="string">&quot;a&quot;</span> &lt;= r ? r.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - <span class="number">87</span> : <span class="title class_">Number</span>(r),</span><br><span class="line">        r = <span class="string">&quot;+&quot;</span> === e.<span class="title function_">charAt</span>(n + <span class="number">1</span>) ? t &gt;&gt;&gt; r : t &lt;&lt; r,</span><br><span class="line">        t = <span class="string">&quot;+&quot;</span> === e.<span class="title function_">charAt</span>(n) ? t + r &amp; <span class="number">4294967295</span> : t ^ r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> gtk = <span class="string">&#x27;320305.131321201&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test_JS_re_code</span>(<span class="params">t,gtk</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> o, i = t.<span class="title function_">match</span>(<span class="regexp">/[\uD800-\uDBFF][\uDC00-\uDFFF]/g</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> === i) &#123;</span><br><span class="line">                <span class="keyword">var</span> a = t.<span class="property">length</span>;</span><br><span class="line">                a &gt; <span class="number">30</span> &amp;&amp; (t = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">10</span>)).<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(a / <span class="number">2</span>) - <span class="number">5</span>, <span class="number">10</span>)).<span class="title function_">concat</span>(t.<span class="title function_">substr</span>(-<span class="number">10</span>, <span class="number">10</span>)))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> s = t.<span class="title function_">split</span>(<span class="regexp">/[\uD800-\uDBFF][\uDC00-\uDFFF]/</span>), c = <span class="number">0</span>, u = s.<span class="property">length</span>, l = []; c &lt; u; c++)</span><br><span class="line">                    <span class="string">&quot;&quot;</span> !== s[c] &amp;&amp; l.<span class="property">push</span>.<span class="title function_">apply</span>(l, <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(t))</span><br><span class="line">                            <span class="keyword">return</span> <span class="title function_">e</span>(t)</span><br><span class="line">                    &#125;(o = s[c].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)) || <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;undefined&quot;</span> != <span class="keyword">typeof</span> <span class="title class_">Symbol</span> &amp;&amp; <span class="literal">null</span> != t[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] || <span class="literal">null</span> != t[<span class="string">&quot;@@iterator&quot;</span>])</span><br><span class="line">                            <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(t)</span><br><span class="line">                    &#125;(o) || <span class="keyword">function</span>(<span class="params">t, n</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">&quot;string&quot;</span> == <span class="keyword">typeof</span> t)</span><br><span class="line">                                <span class="keyword">return</span> <span class="title function_">e</span>(t, n);</span><br><span class="line">                            <span class="keyword">var</span> r = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(t).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">&quot;Object&quot;</span> === r &amp;&amp; t.<span class="property">constructor</span> &amp;&amp; (r = t.<span class="property">constructor</span>.<span class="property">name</span>),</span><br><span class="line">                            <span class="string">&quot;Map&quot;</span> === r || <span class="string">&quot;Set&quot;</span> === r ? <span class="title class_">Array</span>.<span class="title function_">from</span>(t) : <span class="string">&quot;Arguments&quot;</span> === r || <span class="regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.<span class="title function_">test</span>(r) ? <span class="title function_">e</span>(t, n) : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;(o) || <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span>)</span><br><span class="line">                    &#125;()),</span><br><span class="line">                    c !== u - <span class="number">1</span> &amp;&amp; l.<span class="title function_">push</span>(i[c]);</span><br><span class="line">                <span class="keyword">var</span> p = l.<span class="property">length</span>;</span><br><span class="line">                p &gt; <span class="number">30</span> &amp;&amp; (t = l.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) + l.<span class="title function_">slice</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(p / <span class="number">2</span>) - <span class="number">5</span>, <span class="title class_">Math</span>.<span class="title function_">floor</span>(p / <span class="number">2</span>) + <span class="number">5</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) + l.<span class="title function_">slice</span>(-<span class="number">10</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> d = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">103</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">116</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">107</span>)), h = (<span class="literal">null</span> !== r ? r : (r = gtk || <span class="string">&quot;&quot;</span>) || <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>), f = <span class="title class_">Number</span>(h[<span class="number">0</span>]) || <span class="number">0</span>, m = <span class="title class_">Number</span>(h[<span class="number">1</span>]) || <span class="number">0</span>, g = [], y = <span class="number">0</span>, v = <span class="number">0</span>; v &lt; t.<span class="property">length</span>; v++) &#123;</span><br><span class="line">                <span class="keyword">var</span> _ = t.<span class="title function_">charCodeAt</span>(v);</span><br><span class="line">                _ &lt; <span class="number">128</span> ? g[y++] = _ : (_ &lt; <span class="number">2048</span> ? g[y++] = _ &gt;&gt; <span class="number">6</span> | <span class="number">192</span> : (<span class="number">55296</span> == (<span class="number">64512</span> &amp; _) &amp;&amp; v + <span class="number">1</span> &lt; t.<span class="property">length</span> &amp;&amp; <span class="number">56320</span> == (<span class="number">64512</span> &amp; t.<span class="title function_">charCodeAt</span>(v + <span class="number">1</span>)) ? (_ = <span class="number">65536</span> + ((<span class="number">1023</span> &amp; _) &lt;&lt; <span class="number">10</span>) + (<span class="number">1023</span> &amp; t.<span class="title function_">charCodeAt</span>(++v)),</span><br><span class="line">                g[y++] = _ &gt;&gt; <span class="number">18</span> | <span class="number">240</span>,</span><br><span class="line">                g[y++] = _ &gt;&gt; <span class="number">12</span> &amp; <span class="number">63</span> | <span class="number">128</span>) : g[y++] = _ &gt;&gt; <span class="number">12</span> | <span class="number">224</span>,</span><br><span class="line">                g[y++] = _ &gt;&gt; <span class="number">6</span> &amp; <span class="number">63</span> | <span class="number">128</span>),</span><br><span class="line">                g[y++] = <span class="number">63</span> &amp; _ | <span class="number">128</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> b = f, w = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">94</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">54</span>)), k = <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">51</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">94</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">98</span>)) + <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">43</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">45</span>)).<span class="title function_">concat</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">102</span>)), x = <span class="number">0</span>; x &lt; g.<span class="property">length</span>; x++)</span><br><span class="line">                b = <span class="title function_">n</span>(b += g[x], w);</span><br><span class="line">            <span class="keyword">return</span> b = <span class="title function_">n</span>(b, k),</span><br><span class="line">            (b ^= m) &lt; <span class="number">0</span> &amp;&amp; (b = <span class="number">2147483648</span> + (<span class="number">2147483647</span> &amp; b)),</span><br><span class="line">            <span class="string">&quot;&quot;</span>.<span class="title function_">concat</span>((b %= <span class="number">1e6</span>).<span class="title function_">toString</span>(), <span class="string">&quot;.&quot;</span>).<span class="title function_">concat</span>(b ^ f)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div><p>对复制过来的调用JavaScript源代码进行适配修改：</p><ol><li>去掉<code>t.exports</code>属性，不需要赋值，重新命名函数为<code>test_JS_re_code</code></li></ol><p><strong><code>n</code> 函数</strong></p><p>这个函数对给定的整数<code>t</code>和字符串<code>e</code>进行一系列位操作。</p><ul><li><code>t</code>: 初始整数值。</li><li><code>e</code>: 用于操作的字符串，其字符用于决定如何变换<code>t</code>。</li><li>函数通过遍历字符串<code>e</code>并根据其字符执行位移和位异或操作来转换<code>t</code>。</li><li>最后，返回转换后的整数<code>t</code>。</li></ul><p><code>test_JS_re_code</code>函数</p><p>这个函数是主要的函数，用于生成百度翻译的<code>sign</code>值。</p><ul><li><code>t</code>: 要翻译的文本。</li><li><code>gtk</code>: 百度翻译API的一个关键变量，用于生成签名的固定密钥之一。</li></ul><p>这个函数的工作流程大致如下：</p><ol><li><strong>处理输入文本</strong>: 如果文本过长或包含特殊字符（比如表情符号），它会被适当地截断或转换。</li><li><strong>字符编码处理</strong>: 文本<code>t</code>中的每个字符被转换为其ASCII或Unicode编码。</li><li><strong>生成初始值</strong>: 通过某些固定字符和可能是密钥<code>gtk</code>的变量<code>r</code>组合，生成一个初始整数值<code>b</code>。</li><li><strong>迭代处理</strong>: 对上一步得到的整数值<code>b</code>和文本的每个字符编码进行迭代处理，使用<code>n</code>函数和特定的字符串（在变量<code>w</code>和<code>k</code>中定义）进行变换。</li><li><strong>生成最终<code>sign</code>值</strong>: 最终的<code>b</code>值经过一系列操作后，与<code>gtk</code>的某个部分进行操作，生成最终的<code>sign</code>值。</li></ol><h4 id="执行测试代码"><a href="#执行测试代码" class="headerlink" title="执行测试代码"></a>执行测试代码</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_js_data</span>(<span class="params">que</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;translate.js&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        translate = f.read()</span><br><span class="line">        <span class="comment"># 生成js操作对象</span></span><br><span class="line">        js_data = execjs.<span class="built_in">compile</span>(translate)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sign = js_data.call(<span class="string">&#x27;test_JS_re_code&#x27;</span>,que)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign</span><br></pre></td></tr></table></figure></div><ul><li>导入了<code>execjs</code>模块，这个模块允许Python运行JavaScript代码。</li><li>定义了一个名为<code>make_js_data</code>的函数，这个函数接受一个参数<code>que</code>，这个参数是用户想要翻译的文本。</li><li>这段代码从<code>translate.js</code>文件中读取JavaScript代码。<code>translate.js</code>包含了先前分析的那段JavaScript代码（包括<code>n</code>函数和<code>test_JS_re_code</code>函数）。<code>execjs.compile</code>方法编译这段JavaScript代码，使其可以在Python环境中执行。</li><li>通过<code>execjs</code>对象的<code>call</code>方法调用<code>translate.js</code>中的<code>test_JS_re_code</code>函数，传入要翻译的文本<code>que</code>作为参数，生成并返回<code>sign</code>值。</li><li>函数返回计算得到的<code>sign</code>值。</li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <ul><li><code>gtk</code> 和 <code>token</code> 的实际值通常是动态生成的，可能会随着百度翻译网站的更新而变化。在实际应用中，这些值需要从网站的某些部分（如JavaScript代码或隐藏的表单字段）中动态获取。</li><li>硬编码的值只用于示例和概念验证。如果要实现一个可靠和长期有效的解决方案，就需要实现一个方法来动态获取这些值。</li><li>使用硬编码的值可能会导致在百度翻译更新其验证机制后，代码无法正常工作。</li><li><strong><code>gtk</code></strong>: 这通常是一个固定的字符串，用于生成翻译请求中的<code>sign</code>参数。<code>sign</code>参数是基于要翻译的文本和<code>gtk</code>值计算得出的，用于验证请求的合法性。</li><li><strong><code>token</code></strong>: 这是另一个重要的验证参数，通常也是在发送翻译请求时必须包含的。它可能用于识别用户或会话，或者作为另一层的安全验证。</li><li><code>gtk</code>为<code>&#39;320305.131321201&#39;</code>，<code>token</code>为<code>2977c992c92eb0731d89f23d17b6edd7</code></li></ul>    </div>  </div>]]></content>
    
    
    <summary type="html">JS逆向基础理论</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS逆向" scheme="https://www.yiuhangblog.com/tags/JS%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>编码与加解密</title>
    <link href="https://www.yiuhangblog.com/2021/12/27/20211227%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <id>https://www.yiuhangblog.com/2021/12/27/20211227%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8A%A0%E8%A7%A3%E5%AF%86/</id>
    <published>2021-12-27T10:12:46.000Z</published>
    <updated>2024-02-28T10:35:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p><strong>加密解密</strong> 是一种信息安全技术，用于保护数据免受未经授权的访问。加密是将原始数据（明文）转换为无法被轻易读懂的格式（密文）的过程。解密则是将密文还原为原始数据的过程。加密和解密确保只有拥有正确密钥的人可以访问和理解这些数据。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>加密解密技术在网络信息传输安全中起着至关重要的作用，主要涉及以下三个方面：</p><ul><li>**保密性(Confidentiality)**：确保信息在传输过程中不被未授权的人员窥视或窃取。</li><li>**完整性(Integrity)**：确保信息在传输过程中未被修改或篡改。</li><li>**有效性(Availability)**：确保信息的接收者是合法且被授权的。</li></ul><h3 id="常用加密方式"><a href="#常用加密方式" class="headerlink" title="常用加密方式"></a><strong>常用加密方式</strong></h3><table><thead><tr><th><strong>数据加密方式</strong></th><th><strong>描述</strong></th><th><strong>主要解决的问题</strong></th><th><strong>常用算法</strong></th></tr></thead><tbody><tr><td>对称加密</td><td>使用同一个密钥进行数据的加密和解密。加密和解密速度快，适合大量数据的处理，但密钥的分发和管理是一个挑战。</td><td>数据的机密性</td><td>DES, AES</td></tr><tr><td>非对称加密</td><td>使用一对密钥，即公钥和私钥。公钥用于加密数据，私钥用于解密。公钥可以公开，而私钥必须保密。非对称加密通常用于密钥交换和数字签名，提供身份验证和数据机密性。</td><td>身份验证、数据机密性</td><td>DSA，RSA</td></tr><tr><td>单向加密</td><td>仅提供单向加密过程，不能被逆转。通常用于存储敏感信息，如密码哈希。</td><td>数据的完整性、验证数据未被篡改</td><td>MD5，SHA系列算法</td></tr></tbody></table><ul><li><strong>对称加密</strong> 的例子包括 DES（数据加密标准）和 AES（高级加密标准）。AES是现代最常用的对称加密算法，广泛用于WiFi安全、VPN以及许多其他应用中。</li><li><strong>非对称加密</strong> 的知名算法包括 RSA（由Rivest、Shamir和Adleman开发）和 DSA（数字签名算法）。RSA不仅用于加密，也用于数字签名，而DSA主要用于数字签名。</li><li><strong>单向加密（哈希）</strong> 通常用于验证数据完整性。MD5（消息摘要算法第5版）虽然在许多应用中仍在使用，但由于安全性问题，现在更推荐使用SHA系列（安全哈希算法），如SHA-256。</li></ul><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a><strong>进制</strong></h3><p>在计算机中，所有信息最终都是以二进制形式存储的。字符编码就是字符（如字母、数字和符号）与二进制数之间的映射规则。不同的字符编码系统可以支持不同的字符集和语言。</p><h3 id="常见的字符编码"><a href="#常见的字符编码" class="headerlink" title="常见的字符编码"></a>常见的字符编码</h3><ol><li><strong>ASCII（美国标准信息交换码）</strong>:<ul><li>最初设计用于表示英文字符。</li><li>使用7位二进制数来表示一个字符（128个可能的字符）。</li></ul></li><li><strong>Unicode</strong>:<ul><li>为了包含全球所有语言的字符，Unicode被设计出来。</li><li>最常用的形式是UTF-8，它是一种变长编码，可以用1到4个字节表示一个字符。</li></ul></li><li><strong>UTF-8</strong>:<ul><li>在UTF-8编码中，ASCII字符只需一个字节，而其他字符可能需要多达四个字节。</li><li>由于其对ASCII的兼容性和对多字节字符的支持，UTF-8成为了互联网上最常用的编码方式。</li></ul></li></ol><ul><li><strong>二进制</strong>（Base-2）: 只使用0和1。每一位的值是2的幂。</li><li><strong>十进制</strong>（Base-10）: 我们平常使用的数系统，使用0到9。每一位的值是10的幂。</li><li><strong>十六进制</strong>（Base-16）: 使用0到9和A到F。十六进制广泛用于计算机系统中，因为它可以更简洁地表示二进制数。每一位的值是16的幂。</li></ul><table><thead><tr><th>十进制</th><th>十六进制</th><th>二进制</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0000 0000</td></tr><tr><td>1</td><td>1</td><td>0000 0001</td></tr><tr><td>2</td><td>2</td><td>0000 0010</td></tr><tr><td>3</td><td>3</td><td>0000 0011</td></tr><tr><td>4</td><td>4</td><td>0000 0100 &#x3D; 2^2</td></tr><tr><td>5</td><td>5</td><td>0000 0101</td></tr><tr><td>6</td><td>6</td><td>0000 0110</td></tr><tr><td>7</td><td>7</td><td>0000 0111</td></tr><tr><td>8</td><td>8</td><td>0000 1000 &#x3D; 2^3</td></tr><tr><td>9</td><td>9</td><td>0000 1001&#x3D;2^3+2^0</td></tr><tr><td>10</td><td>A</td><td>0000 1010&#x3D;2^3+2^1</td></tr><tr><td>11</td><td>B</td><td>0000 1011</td></tr><tr><td>12</td><td>C</td><td>0000 1100</td></tr><tr><td>13</td><td>D</td><td>0000 1101&#x3D;2^3+2^2+2^0</td></tr><tr><td>14</td><td>E</td><td>0000 1110&#x3D;2^3+2^2+2^1</td></tr><tr><td>15</td><td>F</td><td>0000 1111&#x3D;2^3+2^2+2^1+2^0</td></tr></tbody></table><h3 id="进制间转换方法"><a href="#进制间转换方法" class="headerlink" title="进制间转换方法"></a>进制间转换方法</h3><h4 id="Python中的进制转换"><a href="#Python中的进制转换" class="headerlink" title="Python中的进制转换"></a>Python中的进制转换</h4><p><strong>十进制与二进制</strong></p><p>在Python中，可以使用 <code>bin()</code> 函数将十进制数转换为二进制字符串，<code>int()</code> 函数用于将二进制字符串转换回十进制数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 十进制转二进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">255</span>))  <span class="comment"># 输出: &#x27;0b11111111&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制转十进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;0b11111111&quot;</span>, <span class="number">2</span>))  <span class="comment"># 输出: 255</span></span><br></pre></td></tr></table></figure></div><p><strong>十进制与十六进制</strong></p><p>类似地，<code>hex()</code> 函数用于将十进制数转换为十六进制字符串，<code>int()</code> 函数也可以用于将十六进制字符串转换回十进制数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 十进制转十六进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">255</span>))  <span class="comment"># 输出: &#x27;0xff&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 十六进制转十进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;0xff&quot;</span>, <span class="number">16</span>))  <span class="comment"># 输出: 255</span></span><br></pre></td></tr></table></figure></div><h3 id="Unicode-与字符编码"><a href="#Unicode-与字符编码" class="headerlink" title="Unicode 与字符编码"></a>Unicode 与字符编码</h3><p>Unicode是一个国际标准，它为世界上大多数的文字系统提供了唯一的码位。不同的编码方式（如UTF-8、UTF-16、UTF-32、GBK等）可以用来表示这些码位。</p><ul><li><strong>字符与Unicode码位</strong>：<ul><li>使用 <code>ord()</code> 函数可以获取字符的Unicode码位。</li><li><code>chr()</code> 函数则可以将Unicode码位转换回对应的字符。</li></ul></li><li><strong>字符编码</strong>：<ul><li>字符串的 <code>encode()</code> 方法用于将Unicode字符串编码为特定编码格式的字节串。</li><li>相对地，字节串的 <code>decode()</code> 方法用于将字节串解码为Unicode字符串。</li></ul></li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Unicode码位</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;中&quot;</span>))  <span class="comment"># 输出: 20013</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">20013</span>))  <span class="comment"># 输出: &#x27;中&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码为字节串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;中&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 输出: b&#x27;\xe4\xb8\xad&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;中&quot;</span>.encode(<span class="string">&quot;gbk&quot;</span>))    <span class="comment"># 输出: b&#x27;\xd6\xd0&#x27;</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>UTF-8编码</strong>：<ul><li>UTF-8是一种变长的编码方式，可以使用1到4个字节来表示一个Unicode字符。</li><li>对于ASCII字符（U+0000到U+007F），UTF-8与ASCII编码完全相同，使用单个字节表示。</li></ul></li><li><strong>GBK编码</strong>：<ul><li>GBK是用于简体中文的扩展编码集，是在GB2312基础上扩展而来。</li><li>在GBK编码中，汉字通常使用两个字节表示。</li></ul></li></ul><h2 id="Base64编码原理"><a href="#Base64编码原理" class="headerlink" title="Base64编码原理"></a>Base64编码原理</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Base64编码是一种编码方法，用于将二进制数据转换成ASCII字符串。Base64编码主要用于在不支持二进制数据的系统上存储和传输数据，例如在网页中嵌入图像数据或在电子邮件中发送二进制文件。Base64不是加密方法，它不提供任何安全性或数据保护。Base64是一种基于64个可打印字符来表示二进制数据的编码方法。这些字符包括26个大写字母、26个小写字母、10个数字，以及<code>+</code>和<code>/</code>，共计64个字符。</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol><li><strong>处理非ASCII字符</strong>：最初设计用于电子邮件系统，后来被广泛用于处理包含非ASCII字符的情况，例如中文、日文等。</li><li><strong>网络传输</strong>：在网络上传输数据时，特别是需要通过文本格式传输的二进制数据（如图片、加密数据等），Base64能将这些数据转换成由可打印字符组成的字符串。</li><li><strong>数据表示</strong>：在一些应用中，如电子邮件附件、证书、网页内嵌资源等，Base64用于表示和传输数据。</li></ol><h3 id="Base64编码表"><a href="#Base64编码表" class="headerlink" title="Base64编码表"></a><strong>Base64编码表</strong></h3><p>Base64编码表是将二进制数据按6位一组划分，每组对应一个可打印字符。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/45b56ed7-7556-439b-b46a-4551c4ee9500/public"                      width = "500"                ><h3 id="文本到base64格式的转换"><a href="#文本到base64格式的转换" class="headerlink" title="文本到base64格式的转换"></a>文本到base64格式的转换</h3><p>转换过程通常包括以下步骤：</p><ol><li><strong>将文本转换为ASCII码</strong>：每个字符转换为其对应的ASCII值。</li><li><strong>将ASCII码转换为二进制</strong>：每个ASCII值转换为8位二进制数。</li><li><strong>划分6位一组</strong>：将二进制串划分为每组6位。</li><li><strong>映射到Base64字符</strong>：每组二进制数映射到Base64编码表中对应的字符。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/98f61b9f-84d3-418a-4623-8f6709e1b900/public"                      width = "500"                ><h4 id="ASCII码转换"><a href="#ASCII码转换" class="headerlink" title="ASCII码转换"></a>ASCII码转换</h4><p>首先，文本字符转换为它们对应的ASCII码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&quot;M&quot;</span>)</span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&quot;n&quot;</span>)</span><br><span class="line"><span class="number">110</span></span><br></pre></td></tr></table></figure></div><h4 id="ASCII转二进制"><a href="#ASCII转二进制" class="headerlink" title="ASCII转二进制"></a>ASCII转二进制</h4><p>然后，ASCII码转换为8位的二进制表示：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">77</span>)</span><br><span class="line"><span class="string">&#x27;0b1001101&#x27;</span>  <span class="comment"># 实际上应该是 01001101</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">97</span>)</span><br><span class="line"><span class="string">&#x27;0b1100001&#x27;</span>  <span class="comment"># 实际上应该是 01100001</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">110</span>)</span><br><span class="line"><span class="string">&#x27;0b1101110&#x27;</span>  <span class="comment"># 实际上应该是 01101110</span></span><br></pre></td></tr></table></figure></div><p>请注意，为了确保每个ASCII码都是8位二进制，通常需要在前面补0。</p><h4 id="组合二进制并划分"><a href="#组合二进制并划分" class="headerlink" title="组合二进制并划分"></a>组合二进制并划分</h4><p>接着，将这些二进制串连起来，并每6位分为一组：</p><p><code>010011 010110 000101 101110</code></p><h4 id="二进制转Base64编码"><a href="#二进制转Base64编码" class="headerlink" title="二进制转Base64编码"></a>二进制转Base64编码</h4><p>每组二进制数转换为Base64编码表中对应的字符：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&quot;010011&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">19</span>  <span class="comment"># 对应Base64表中的 &#x27;T&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&quot;010110&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">22</span>  <span class="comment"># 对应Base64表中的 &#x27;W&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&quot;000101&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">5</span>   <span class="comment"># 对应Base64表中的 &#x27;F&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&quot;101110&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">46</span>  <span class="comment"># 对应Base64表中的 &#x27;u&#x27;</span></span><br></pre></td></tr></table></figure></div><p>因此，”Man” 这个字符串在Base64编码中表示为 <code>&quot;TWFu&quot;</code>。</p><ul><li><strong>Base64编码</strong>：Base64编码是一种二进制到文本的编码方法，用于在文本格式中表示二进制数据。每个6位二进制数映射到Base64编码表中的一个字符。</li><li><strong>补码</strong>：在Base64编码中，如果最后一组不足6位，则用0补足6位，并在编码结果末尾添加一个或两个等号（<code>=</code>）作为填充。</li></ul><h3 id="BASE64编码补码"><a href="#BASE64编码补码" class="headerlink" title="BASE64编码补码"></a>BASE64编码补码</h3><p>在Base64编码中，如果二进制数据的位数不是6的倍数，将使用补码<code>=</code>来填充，以保证编码后的字符串长度是4的倍数。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/549c1891-ff37-4f92-56a4-9a5677af6800/public"                      width = "500"                ><ul><li><p><strong>编码与加密的区别</strong>：Base64编码并不是加密过程。它不提供数据保护，只是一种编码方案，任何人都可以使用Base64算法将编码后的字符串解码回原始数据。</p></li><li><p><strong>使用场景</strong>：虽然Base64主要用于在需要以文本格式传输二进制数据的场合，但它并不限于此。例如，Base64也常用于在Web应用中嵌入小的图像或其他类型的文件。</p></li></ul>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>凯撒密码（Caesar Cipher）是一种最简单和最广为人知的加密技术。它是一种替换密码，其中每个字母在明文中被移动了一定数目的位置。例如，当偏移量是3的时候，所有的字母都将向前移动三个位置，因此 ‘A’ 变成了 ‘D’，’B’ 变成了 ‘E’，以此类推。这种密码得名于朱利叶斯·凯撒（Julius Caesar），他用它来保护重要的军事信息。</p><p><strong>工作原理</strong></p><ul><li><strong>加密过程</strong>：在凯撒密码中，字母表中的每个字母都被向右或向左移动一定的固定数目。例如，如果我们选择向右移动3个位置，那么’A’就变成了’D’，’B’变成了’E’，依此类推。</li><li><strong>解密过程</strong>：解密是加密过程的逆过程。如果我们知道了位移的数目，我们可以通过反方向移动同样数目的位置来还原原文。</li></ul><p><strong>示例</strong></p><p>假设我们有一个明文 “HELLO”，我们使用向右位移3的凯撒密码加密：</p><ul><li>‘H’ -&gt; ‘K’</li><li>‘E’ -&gt; ‘H’</li><li>‘L’ -&gt; ‘O’</li><li>‘L’ -&gt; ‘O’</li><li>‘O’ -&gt; ‘R’</li></ul><p>因此，加密后的密文是 “KHOOR”。</p><p><strong>Python实现</strong></p><p>以下是凯撒密码的一个简单Python实现：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">caesar_cipher</span>(<span class="params">text, shift</span>):</span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text)):</span><br><span class="line">        char = text[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加密大写字母</span></span><br><span class="line">        <span class="keyword">if</span> char.isupper():</span><br><span class="line">            result += <span class="built_in">chr</span>((<span class="built_in">ord</span>(char) + shift - <span class="number">65</span>) % <span class="number">26</span> + <span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加密小写字母</span></span><br><span class="line">        <span class="keyword">elif</span> char.islower():</span><br><span class="line">            result += <span class="built_in">chr</span>((<span class="built_in">ord</span>(char) + shift - <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result += char</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试加密</span></span><br><span class="line">text = <span class="string">&quot;HELLO&quot;</span></span><br><span class="line">shift = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Plain Text : &quot;</span> + text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shift pattern : &quot;</span> + <span class="built_in">str</span>(shift))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cipher: &quot;</span> + caesar_cipher(text, shift))</span><br></pre></td></tr></table></figure></div><p><strong>安全性</strong></p><p>凯撒密码是一种非常基础的加密方法，由于其算法简单且容易破解（特别是在现代计算技术的帮助下），因此它不适合用于保护重要的信息。凯撒密码的主要用途在于教育和娱乐。在实际的安全应用中，需要使用更为复杂和安全的加密算法。</p>    </div>  </div><h2 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>单向加密，也被称为哈希（Hashing），是一种加密过程，其中明文数据被转换成固定长度的唯一散列值，但这个过程是不可逆的。这意味着从散列值无法还原回原始数据。单向加密常用于存储密码、验证数据完整性和安全性。</p><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a><strong>常见方法</strong></h3><p>两种常见的单向加密算法是MD5（Message-Digest Algorithm）和SHA（Secure Hash Algorithm）。</p><ol><li><strong>MD5</strong>：<ul><li>MD5生成的散列值长度为128位（即16字节）。</li><li>通常以32个十六进制字符表示（因为每4位二进制可以表示为1位十六进制，所以128位二进制等于32位十六进制）。</li></ul></li><li><strong>SHA</strong>：<ul><li>SHA家族包括多种算法，如SHA-1、SHA-256、SHA-512等，其中SHA-256生成的散列值长度为256位。</li><li>SHA-256的结果通常表示为64个十六进制字符。</li></ul></li><li><strong>更新哈希值</strong>：<ul><li><code>update()</code> 方法用于向哈希对象添加数据。如果同一个哈希对象被多次调用 <code>update()</code>，则新增的数据会被附加到原有数据后面，最终的哈希值是所有数据的总和。</li></ul></li></ol><h4 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">md5_obj = md5()  <span class="comment"># 创建MD5算法加密对象</span></span><br><span class="line">md5_obj.update(<span class="string">&quot;加密数据&quot;</span>.encode())  <span class="comment"># 添加要加密的数据</span></span><br><span class="line"><span class="built_in">print</span>(md5_obj.hexdigest())  <span class="comment"># 获取十六进制表示的散列值</span></span><br></pre></td></tr></table></figure></div><h4 id="SHA加密"><a href="#SHA加密" class="headerlink" title="SHA加密"></a>SHA加密</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">sha256_obj = sha256()  <span class="comment"># 创建SHA-256算法加密对象</span></span><br><span class="line">sha256_obj.update(<span class="string">&quot;加密数据&quot;</span>.encode())  <span class="comment"># 添加要加密的数据</span></span><br><span class="line"><span class="built_in">print</span>(sha256_obj.hexdigest())  <span class="comment"># 获取十六进制表示的散列值</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>安全性</strong>：<ul><li>MD5和SHA-1由于存在安全漏洞，不再推荐用于安全敏感的场合。</li><li>SHA-256是更安全的选择，广泛用于加密货币、SSL证书等。</li></ul></li><li><strong>用途</strong>：<ul><li>单向加密主要用于密码存储、数据完整性校验和数字签名等。</li></ul></li><li><strong>不可逆性</strong>：<ul><li>哈希函数的一个关键特性是它们是单向的，无法逆转。这意味着无法从散列值推算出原始输入。</li></ul></li></ul><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h3 id="概念与简介"><a href="#概念与简介" class="headerlink" title="概念与简介"></a>概念与简介</h3><p><strong>概念</strong>: 对称加密是一种加密方法，其中加密和解密使用相同的密钥。</p><p><strong>简介:</strong></p><ul><li>对称加密算法通常速度较快，适合加密大量数据。常用的对称加密算法包括 <strong>DES</strong>（Data Encryption Standard）、<strong>3DES</strong>（Triple DES）和 <strong>AES</strong>（Advanced Encryption Standard）。<ul><li>**DES (Data Encryption Standard)**：是最初的对称加密标准，使用56位密钥。尽管存在8位校验位，但实际上只用到了56位。DES由于密钥长度较短，容易受到暴力破解攻击。</li><li>**3DES (Triple DES)**：是DES的改进版本，通过使用三重DES加密过程提高安全性。它使用两个或三个密钥，有效长度为112或168位。</li><li><strong>AES</strong> 是一种更现代的对称加密标准，提供多种密钥长度（128、192和256位）。被认为是DES的继任者，提供了更高的安全性和更好的性能。AES在现代加密应用中非常普遍。</li></ul></li></ul><p><strong>特点：</strong></p><ul><li><strong>相同密钥</strong>：加密和解密使用相同的密钥，因此密钥的保密性极为重要。</li><li><strong>密钥长度</strong>：一般较短，通常小于256位。密钥越长，安全性越高，但性能可能受影响。</li><li><strong>对称加密的应用</strong>：对称加密算法通常用于加密大量数据，如文件加密、数据库加密等。</li></ul><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>DES是一种经典的对称加密算法，尽管由于其较短的密钥长度（56位有效长度），在现代计算能力下已不再安全。</p><h4 id="DES加密原理"><a href="#DES加密原理" class="headerlink" title="DES加密原理"></a>DES加密原理</h4><p>DES的加密过程包括初始置换、16轮迭代运算和逆初始置换。每轮迭代运算包括扩展置换、S盒置换和P盒置换，以及与子密钥的混合。<strong>初始置换</strong>（Initial Permutation, IP）和<strong>逆初始置换</strong>（Final Permutation, FP）是DES加密过程中的第一步和最后一步，它们是固定的非加密置换。</p><ul><li><strong>初始置换</strong>：打乱明文数据的顺序。</li><li><strong>16轮迭代运算</strong>：每轮使用不同的密钥进行加密。</li><li><strong>逆初始置换</strong>：恢复数据到最终加密状态。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1b31bb8b-62ec-487a-110c-6fe1cb20ae00/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f0d23f60-6fcd-4ddf-f78c-24fa737bdf00/public"                      width = "500"                ><p><strong>初始IP置换表</strong></p><table><thead><tr><th align="center">58</th><th align="right">50</th><th>12</th><th>34</th><th>26</th><th>18</th><th>10</th><th>2</th><th>60</th><th>52</th><th>44</th><th>36</th><th>28</th><th>20</th><th>12</th><th>4</th></tr></thead><tbody><tr><td align="center">62</td><td align="right">54</td><td>46</td><td>38</td><td>30</td><td>22</td><td>14</td><td>6</td><td>64</td><td>56</td><td>48</td><td>40</td><td>32</td><td>24</td><td>16</td><td>8</td></tr><tr><td align="center">57</td><td align="right">49</td><td>41</td><td>33</td><td>25</td><td>17</td><td>9</td><td>1</td><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td></tr><tr><td align="center">61</td><td align="right">53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td></tr></tbody></table><p><strong>逆置置换表</strong></p><table><thead><tr><th>40</th><th align="center">8</th><th>48</th><th>16</th><th>56</th><th>24</th><th>64</th><th>32</th><th>39</th><th>7</th><th>47</th><th>15</th><th>55</th><th>23</th><th>63</th><th>31</th></tr></thead><tbody><tr><td>38</td><td align="center">6</td><td>46</td><td>14</td><td>54</td><td>22</td><td>62</td><td>30</td><td>37</td><td>5</td><td>45</td><td>13</td><td>53</td><td>21</td><td>61</td><td>29</td></tr><tr><td>36</td><td align="center">4</td><td>44</td><td>12</td><td>52</td><td>20</td><td>60</td><td>28</td><td>35</td><td>3</td><td>43</td><td>11</td><td>51</td><td>19</td><td>59</td><td>27</td></tr><tr><td>34</td><td align="center">2</td><td>42</td><td>10</td><td>50</td><td>18</td><td>58</td><td>26</td><td>33</td><td>1</td><td>41</td><td>9</td><td>49</td><td>17</td><td>57</td><td>25</td></tr></tbody></table><h4 id="Python实现DES加密"><a href="#Python实现DES加密" class="headerlink" title="Python实现DES加密"></a>Python实现DES加密</h4><p>使用Python进行DES加密需要安装<code>pycryptodomex</code>或<code>pycryptodome</code>库。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cryptodome.Cipher <span class="keyword">import</span> DES</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;1234abcd&#x27;</span>  <span class="comment"># 8字节密钥</span></span><br><span class="line">des = DES.new(key, DES.MODE_ECB)  <span class="comment"># 创建DES加密对象，ECB模式</span></span><br><span class="line">content = <span class="string">&quot;加密内容&quot;</span>  </span><br><span class="line"><span class="comment"># 确保内容长度是8的倍数</span></span><br><span class="line">padding = (<span class="number">8</span> - <span class="built_in">len</span>(content) % <span class="number">8</span>) * <span class="string">&quot;-&quot;</span></span><br><span class="line">en_data = content + padding</span><br><span class="line">en_data = des.encrypt(en_data.encode())  <span class="comment"># 加密</span></span><br><span class="line"><span class="built_in">print</span>(en_data)</span><br><span class="line">de_data = des.decrypt(en_data)  <span class="comment"># 解密</span></span><br><span class="line"><span class="built_in">print</span>(de_data.decode())</span><br></pre></td></tr></table></figure></div><ul><li><strong>密钥管理</strong>：对称加密的一个挑战是密钥的安全传输和管理，因为密钥必须在通信双方之间共享。</li><li><strong>加密模式</strong>：除了ECB（Electronic Codebook）模式，还有其他几种模式，如CBC（Cipher Block Chaining）和CFB（Cipher Feedback），每种模式有其特点和用途。</li><li><strong>安全性考量</strong>：随着计算能力的提高，DES由于其较短的密钥长度而变得不够安全，AES由于其更长的密钥和更高效的算法成为更好的选择。</li></ul><h3 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用<strong>三次DES加密算法</strong>。</p><p>由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解。3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p><h4 id="3DES加密原理"><a href="#3DES加密原理" class="headerlink" title="3DES加密原理"></a>3DES加密原理</h4><p>3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），加密算法，其具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，M代表明文，</p><ul><li><strong>加密过程</strong>：<code>C = Ek3(Dk2(Ek1(M)))</code><ul><li>其中，<code>Ek()</code> 表示用密钥 <code>k</code> 进行DES加密，<code>Dk()</code> 表示用密钥 <code>k</code> 进行DES解密。</li><li><code>M</code> 代表明文，<code>C</code> 代表密文。</li><li><code>k1</code>、<code>k2</code> 和 <code>k3</code> 是三个不同的密钥。</li></ul></li><li><strong>解密过程</strong>：<code>M = Dk1(Ek2(Dk3(C)))</code><ul><li>解密过程是加密过程的逆过程。</li></ul></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f03b3c3b-cb6b-4ed1-5450-13fbf5896a00/public"                      width = "500"                ><h4 id="Python实现3DES加密"><a href="#Python实现3DES加密" class="headerlink" title="Python实现3DES加密"></a>Python实现3DES加密</h4><p>实际上，3DES有几种不同的实现方式，包括使用三个不同密钥的3-key模式（最安全，但也最慢），以及使用两个不同密钥的2-key模式。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cryptodome.Cipher <span class="keyword">import</span> DES3</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;12345678abcdefgh&#x27;</span>  <span class="comment"># 16字节密钥用于2-key模式，24字节密钥用于3-key模式</span></span><br><span class="line">des = DES3.new(key, DES3.MODE_ECB)  <span class="comment"># 创建3DES加密对象，ECB模式</span></span><br><span class="line">content = <span class="string">&quot;加密内容&quot;</span>  </span><br><span class="line"><span class="comment"># 确保内容长度是8的倍数</span></span><br><span class="line">padding = (<span class="number">8</span> - <span class="built_in">len</span>(content) % <span class="number">8</span>) * <span class="string">&quot;-&quot;</span></span><br><span class="line">en_data = content + padding</span><br><span class="line">en_data = des.encrypt(en_data.encode())  <span class="comment"># 加密</span></span><br><span class="line"><span class="built_in">print</span>(en_data)</span><br><span class="line">de_data = des.decrypt(en_data)  <span class="comment"># 解密</span></span><br><span class="line"><span class="built_in">print</span>(de_data.decode())</span><br></pre></td></tr></table></figure></div><ul><li><strong>性能</strong>：由于3DES使用了三次DES加密过程，它在相同硬件上比单次DES加密慢三倍左右。</li><li><strong>安全性</strong>：虽然3DES比原始的DES更安全，但它的速度和效率不及更现代的算法，如AES。</li><li><strong>用途</strong>：3DES通常用于需要与旧系统兼容的场景，但新的系统和应用更倾向于使用AES。</li></ul><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>AES（Advanced Encryption Standard），又称Rijndael加密法，是一种区块加密标准，用于替代原来的DES。AES是美国国家标准技术研究所（NIST）于2001年采纳的加密标准，并被广泛使用。</p><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><ul><li><p><strong>分组密码</strong>：AES将明文分为固定大小的数据块进行加密，每个数据块的大小为128位，即16个字节。</p></li><li><p><strong>密钥长度</strong>：AES支持三种长度的密钥：128位、192位和256位。不同的密钥长度会影响加密的轮数。</p></li><li><p>加密轮数</p><p>：根据密钥长度的不同，AES有不同的加密轮数：</p><ul><li>AES-128：10轮</li><li>AES-192：12轮</li><li>AES-256：14轮</li></ul></li><li><p><strong>每轮加密操作</strong>：每一轮包括若干步骤，如字节代换、行移位、列混淆和轮密钥加。</p></li></ul><table><thead><tr><th align="center">AES</th><th align="center"><strong>密钥长度（32位比特字)</strong></th><th align="center"><strong>分组长度(32位比特字)</strong></th><th align="center"><strong>加密轮数</strong></th></tr></thead><tbody><tr><td align="center">AES-128</td><td align="center">4</td><td align="center">4</td><td align="center">10</td></tr><tr><td align="center">AES-192</td><td align="center">6</td><td align="center">4</td><td align="center">12</td></tr><tr><td align="center">AES-256</td><td align="center">8</td><td align="center">4</td><td align="center">14</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/287ba295-5ce2-4f70-3044-a9c9fa3f6700/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b7807e29-1aa4-47d9-e958-1101f5f05100/public"                      width = "500"                ><h4 id="Python实现AES加密"><a href="#Python实现AES加密" class="headerlink" title="Python实现AES加密"></a>Python实现AES加密</h4><p>在Python中使用AES加密时，可以选择不同的加密模式，如CBC（Cipher Block Chaining）模式。CBC模式需要一个初始化向量（IV）来提高安全性。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cryptodome.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;abcdefghijklnmop&#x27;</span>  <span class="comment"># 16字节密钥</span></span><br><span class="line">iv = <span class="string">b&#x27;1234567890abcdef&#x27;</span>   <span class="comment"># 初始化向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建AES加密器实例</span></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line">content = <span class="string">&quot;我爱你&quot;</span></span><br><span class="line">b_content = content.encode()</span><br><span class="line"><span class="comment"># 补足到16的倍数</span></span><br><span class="line">bytes_content = content + (<span class="number">16</span> - <span class="built_in">len</span>(b_content) % <span class="number">16</span>) * <span class="string">&quot;*&quot;</span></span><br><span class="line">en_data = aes.encrypt(bytes_content.encode())</span><br><span class="line"><span class="built_in">print</span>(en_data)  <span class="comment"># 加密后的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">aes_decrypt = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">de_data = aes_decrypt.decrypt(en_data)</span><br><span class="line"><span class="built_in">print</span>(de_data.decode().rstrip(<span class="string">&#x27;*&#x27;</span>))  <span class="comment"># 解密后的数据，去除填充的&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure></div><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="概念与简介-1"><a href="#概念与简介-1" class="headerlink" title="概念与简介"></a><strong>概念</strong>与简介</h3><p>非对称加密是一种加密方法，其中使用一对密钥：一个公钥和一个私钥。公钥用于加密数据，而私钥用于解密。这种方法的关键优势在于，公钥可以公开共享，而私钥则保持私密，从而确保了信息的安全传输。</p><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul><li><strong>安全性</strong>：非对称加密提供了高度的安全性，因为即使公钥是公开的，没有相应的私钥也无法解密信息。</li><li><strong>密钥传输</strong>：不需要安全地传输密钥，因为公钥可以公开。</li><li><strong>效率</strong>：相较于对称加密，非对称加密过程速度较慢，尤其是在处理大量数据时。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>常用于加密少量重要数据，如加密会话密钥。</li><li>广泛应用于数字签名和身份验证。</li></ul><h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h3><h4 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h4><h5 id="素数-Prime-Numbers"><a href="#素数-Prime-Numbers" class="headerlink" title="素数 (Prime Numbers)"></a>素数 (Prime Numbers)</h5><p>素数，也称为质数，指的是一个大于1的自然数，它除了1和其自身外，不能被其他自然数整除。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/691f968c-5097-4d90-0e4b-d6a3795ace00/public"                      width = "300"                ><h5 id="模运算-Modulo-Operation"><a href="#模运算-Modulo-Operation" class="headerlink" title="模运算 (Modulo Operation)"></a>模运算 (Modulo Operation)</h5><p>模运算，即求余运算，在数学中通常用”mod”表示。它与”同余”的概念密切相关。如果两个整数除以同一个正整数得到相同的余数，那么这两个整数是同余的。</p><p>例如，若两个整数$a$和$b$，除以正整数$m$得到的余数相等，则$a \equiv b \ (\text{mod} \ m)$，即$a$同余于$b$模$m$。如：$26 \equiv 14 \ (\text{mod} \ 12)$。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c9a1ab53-f434-4bc7-a745-56ab0aabb600/public"                      width = "300"                ><h5 id="互质关系（Coprime）"><a href="#互质关系（Coprime）" class="headerlink" title="互质关系（Coprime）"></a>互质关系（Coprime）</h5><p>互质关系是指两个正整数$a$和$b$之间的关系，它们除了1以外没有其他共同的正因子。互质关系表示为$\text{gcd}(a, b) &#x3D; 1$，其中$\text{gcd}(a, b)$表示$a$和$b$的最大公因子。</p><p>性质和应用：</p><ul><li>任意两个质数互质。</li><li>如果一个数是质数，另一个数不是它的倍数，它们互质。</li><li>如果两数中较大的那个是质数，则它们互质。</li><li>1和任意自然数互质。</li><li>对于大于1的整数$p$，$p$和$p-1$互质。</li><li>对于大于1的奇数$p$，$p$和$p-2$互质。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3a4c86c8-472f-48ad-30e8-c03533220900/public"                      width = "400"                ><h5 id="欧拉函数-Euler’s-Totient-Function"><a href="#欧拉函数-Euler’s-Totient-Function" class="headerlink" title="欧拉函数 (Euler’s Totient Function)"></a>欧拉函数 (Euler’s Totient Function)</h5><p>欧拉函数，记作$\phi(n)$，是一个数论中的重要函数。它的定义是：对于任意正整数$n$，欧拉函数$\phi(n)$表示在$1$到$n$之间与$n$互质的正整数的数量。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2f98db38-f83d-4d4b-0561-b1c4eadfdd00/public"                      width = "400"                ><p><strong>定义</strong></p><p>对于正整数$n$，欧拉函数$\phi(n)$被定义为：</p><p>$$ \phi(n) &#x3D; \text{数量}{k \in \mathbb{N} : 1 \leq k \leq n, \text{gcd}(k, n) &#x3D; 1} $$</p><p>这里，$\text{gcd}(k, n)$表示$k$和$n$的最大公因数。</p><p><strong>性质</strong></p><ol><li><p><strong>对于质数$p$</strong>:</p><p>因为一个质数除了自身和 $1$ 以外，没有其他因子。因此，除了自身之外，所有小于 $p$ 的正整数都与 $p$ 互质。 </p><p>$$ \phi(p) &#x3D; p - 1 $$ </p><p><strong>推导</strong> </p><p>​对于质数 $p$，它没有除 $1$ 和自身以外的因子。 </p><p>​因此，$1, 2, …, p-1$ 都是与 $p$ 互质的。</p><p>​这意味着与 $p$ 互质的正整数的数量是 $p-1$。</p></li><li><p><strong>两个不同质数的乘积</strong>:</p><p>当 $n$ 是两个不同质数 $p$ 和 $q$ 的乘积时，欧拉函数的计算变得稍微复杂一点</p><p>$$ \phi(pq) &#x3D; (p - 1)(q - 1) $$</p><p><strong>推导</strong></p><p>​首先，由于 $p$ 和 $q$ 是质数，所以除了 $1$ 和它们自身外，它们没有其他因子。 </p><p>​任何小于 $pq$ 且不是 $p$ 或 $q$ 的倍数的数都与 $pq$ 互质。 </p><p>​在 $1$ 到 $pq$ 的数中，有 $q$ 个数是 $p$ 的倍数，有 $p$ 个数是 $q$ 的倍数，但 $pq$ 被算了两次。</p><p>​因此，与 $pq$ 互质的数的数量是 $pq - p - q + 1$。 - 这可以重写为 $(p - 1)(q - 1)$。</p></li><li><p><strong>对于质数$p$的幂$p^n$</strong>:</p><p>当 $n$ 是质数 $p$ 的幂，即 $n &#x3D; p^k$（其中 $k &gt; 1$）时，欧拉函数的计算方式如下： </p><p>$$ \phi(p^k) &#x3D; p^k - p^{k-1} $$</p><p><strong>推导</strong></p><p>​在 $1$ 到 $p^k$ 的数中，与 $p^k$ 不互质的数是 $p$ 的倍数。 </p><p>​这些数是 $p, 2p, 3p, \ldots, p^{k-1}p$，总共有 $p^{k-1}$ 个。 </p><p>​因此，与 $p^k$ 互质的数的数量是 $p^k - p^{k-1}$。</p></li></ol><p><strong>示例</strong></p><ul><li>计算 $\phi(10)$:<ul><li>由于 $10 &#x3D; 2 \times 5$，且 $2$ 和 $5$ 是质数，$\phi(10) &#x3D; (2-1)(5-1) &#x3D; 4$。   </li><li>与 $10$ 互质的数有 $1, 3, 7, 9$。</li></ul></li></ul><p><strong>应用</strong></p><p>欧拉函数在密码学和数论中有着重要的应用，例如在RSA加密算法中，它被用来选择密钥。</p><h5 id="模反元素-模逆元（Modular-Multiplicative-Inverse）"><a href="#模反元素-模逆元（Modular-Multiplicative-Inverse）" class="headerlink" title="模反元素&#x2F;模逆元（Modular Multiplicative Inverse）"></a>模反元素&#x2F;模逆元（Modular Multiplicative Inverse）</h5><p>模反元素是数论和代数中的一个重要概念。当两个正整数$a$和$n$互质时（即它们的最大公因数为$1$），$a$在模$n$下的模反元素是指一个整数$b$，使得$a$乘以$b$在模$n$下的结果等于$1$。</p><p><strong>定义</strong></p><ul><li><p>对于给定的正整数$a$和$n$，如果存在整数$b$满足以下等式，则$b$是$a$的模反元素：</p><p>$$ ab \equiv 1 \pmod{n} $$</p></li><li><p>这里的$\equiv$表示同余，而$\pmod{n}$表示对$n$取模。</p></li></ul><p><strong>计算方法</strong></p><ul><li>要找到$a$在模$n$下的模反元素$b$，可以使用扩展欧几里得算法或费马小定理（如果$n$是质数）。</li></ul><p><strong>示例</strong></p><ul><li>假设$a &#x3D; 3$和$n &#x3D; 11$，那么$3$和$11$互质。</li><li>要找到一个数$b$，使得$3b \equiv 1 \pmod{11}$。</li><li>在这个例子中，$b &#x3D; 4$是$3$的模反元素，因为$3 \cdot 4 &#x3D; 12$，且$12 \equiv 1 \pmod{11}$。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e525b4e3-2eba-44c4-3764-54a4f3604700/public"                      width = "200"                ><p><strong>应用</strong></p><ul><li>模反元素在密码学中非常重要，尤其是在公钥加密和数字签名算法中。</li><li>它也用于计算机科学中的某些算法，如模算术和散列函数。</li></ul><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>RSA是一种广泛使用的非对称加密算法，由Rivest、Shamir和Adleman三位数学家提出。RSA的安全性基于大数分解的难题。在RSA中，加密密钥（公钥）是公开的，而解密密钥（私钥）则必须保密。由于RSA计算量大，通常用于加密小量数据或加密对称加密的密钥。常见的做法是使用RSA加密对称密钥，然后用该对称密钥进行实际数据的加密和解密，这样结合了两者的优点：RSA的安全性和对称加密的效率。</p><h4 id="RSA加密原理"><a href="#RSA加密原理" class="headerlink" title="RSA加密原理"></a>RSA加密原理</h4><p>RSA加密的基本步骤可以分为三个阶段：密钥生成、加密和解密。</p><h5 id="密钥生成过程"><a href="#密钥生成过程" class="headerlink" title="密钥生成过程"></a>密钥生成过程</h5><ol><li><strong>选择两个大的质数</strong> $p$ 和 $q$。这些质数需要足够大，以确保加密的安全性。 </li><li><strong>计算它们的乘积</strong> $n &#x3D; p \times q$。这个乘积 $n$ 用于公钥和私钥，且其长度决定了密钥长度。 </li><li><strong>计算欧拉函数</strong> $\phi(n) &#x3D; (p-1)(q-1)$。这是公钥和私钥生成的关键部分。 </li><li><strong>选择一个公钥指数</strong> $e$。$e$ 是一个小于 $\phi(n)$ 的正整数，并且 $e$ 和 $\phi(n)$ 互质。常见的选择是 $e &#x3D; 65537$，但确保 $e &lt; \phi(n)$。 </li><li><strong>计算私钥</strong> $d$。$d$ 是 $e$ 相对于 $\phi(n)$ 的模逆元，即找到一个整数 $d$ 使得 $ed \equiv 1 \mod \phi(n)$。这可以通过扩展欧几里得算法来实现。</li></ol>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>扩展欧几里得算法及其在RSA加密中的应用</strong></p><p>扩展欧几里得算法是一种用于求解两个整数 <code>a</code> 和 <code>b</code> 的最大公因数（GCD）的同时，找到整数 <code>x</code> 和 <code>y</code> 使得 <code>ax + by = gcd(a, b)</code> 的算法。</p><p><strong>算法描述</strong></p><ol><li><p><strong>基本思想</strong>:</p><ul><li>扩展欧几里得算法基于欧几里得算法的原理，通过反复应用除法原理，直到余数为0。</li><li>在每一步中，算法维护着等式 <code>ax + by = gcd(a, b)</code> 的一个解。</li></ul></li><li><p><strong>算法步骤</strong>:</p><ul><li>如果 <code>b = 0</code>，则 <code>gcd(a, b) = a</code>，且 <code>x = 1</code>, <code>y = 0</code>。</li><li>否则，递归调用扩展欧几里得算法：<code>gcd(b, a % b)</code>。</li><li>通过回溯的方式，计算出 <code>x</code> 和 <code>y</code> 的值。</li></ul></li></ol><p><strong>在RSA加密中的应用</strong></p><p>在RSA加密中，扩展欧几里得算法用于计算私钥 <code>d</code>，这是公钥指数 <code>e</code> 的模逆元相对于 <code>φ(n)</code>。</p><ol><li><p><strong>公钥和私钥的生成</strong>:</p><ul><li>已知公钥指数 <code>e</code> 和 <code>φ(n)</code>（其中 <code>n = pq</code> 是两个质数 <code>p</code> 和 <code>q</code> 的乘积）。</li><li>需要找到一个整数 <code>d</code> 使得 <code>ed ≡ 1 (mod φ(n))</code>。</li><li>这意味着需要找到 <code>x</code> 和 <code>y</code> 使得 <code>ex + φ(n)y = 1</code>。</li></ul></li><li><p><strong>使用扩展欧几里得算法</strong>:</p><ul><li>应用扩展欧几里得算法于 <code>e</code> 和 <code>φ(n)</code>。</li><li>算法将产生 <code>x</code> 和 <code>y</code>，其中 <code>x</code> 就是所求的 <code>d</code>。</li><li>即使 <code>x</code> 是负数，也可以通过加上 <code>φ(n)</code> 来得到正的模逆元。</li></ul></li></ol><p><strong>示例</strong></p><p>假设 <code>e = 17</code> 和 <code>φ(n) = 3120</code>，使用扩展欧几里得算法找到 <code>d</code>，使得 <code>17d ≡ 1 (mod 3120)</code>。算法将返回 <code>d</code> 的值，这是私钥的一部分。</p><p>这种方法确保了RSA加密算法中私钥的生成既安全又有效率。</p>    </div>  </div><h5 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h5><p>加密过程是将明文消息 $M$ 转换成密文 $C$。这通过以下公式完成：  </p><p>$$ C &#x3D; M^e \mod n $$ </p><p>使用公钥 $(n, e)$ 对明文 $M$ 进行加密。 </p><h5 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h5><p>解密过程是将密文 $C$ 还原回原始明文 $M$。这通过以下公式完成：  </p><p>$$ M &#x3D; C^d \mod n $$ </p><p>使用私钥 $(n, d)$，可以将密文 $C$ 解密回明文 $M$。 </p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>在RSA加密算法中，公钥指数 e 的选择对于加密的效率和安全性都至关重要。e &#x3D; 65537 是一个广泛使用的值，其原因如下：</p><ol><li><strong>安全性</strong>:   e 应该是一个与 $\phi(n)$ 互质的大质数。65537 是一个质数，且大多数情况下不会与 $\phi(n)$ 有共同因子。 </li><li><strong>效率</strong>:   65537 在二进制表示中只有两个 1（即 10000000000000001）。这使得进行模幂运算（用于加密和解密）时更加高效。较少的 1 位意味着需要更少的乘法操作。 </li><li><strong>历史原因</strong>:   在RSA的早期，较小的值如 3 和 17 也被作为公钥指数使用。然而，随着对RSA安全性的更深入理解，这些较小的值被认为在某些情况下不够安全。65537 提供了良好的安全性，同时保持了计算效率。 </li><li><strong>平衡性</strong>:   65537 是一个在保持计算效率和确保足够安全性之间的良好平衡。它足够大，可以避免某些已知的攻击方法，同时又不会像更大的数那样使计算量过大。 </li><li>总结来说，e &#x3D; 65537 是RSA加密中的一个标准选择，因为它在安全性和计算效率之间提供了一个很好的平衡点。</li></ol>    </div>  </div><h4 id="RSA加密算法的安全性"><a href="#RSA加密算法的安全性" class="headerlink" title="RSA加密算法的安全性"></a>RSA加密算法的安全性</h4><p>RSA加密算法的安全性主要基于大数分解的难度。当选择的两个大素数<code>p</code>和<code>q</code>足够大时，它们的乘积<code>n = p * q</code>难以分解，这是RSA算法的核心安全基础。</p><ul><li><strong>大素数分解难题</strong>：目前，没有已知的高效算法可以在合理时间内分解非常大的数。这个数学难题是RSA安全性的基石。</li></ul><h4 id="RSA加密算法的缺点"><a href="#RSA加密算法的缺点" class="headerlink" title="RSA加密算法的缺点"></a>RSA加密算法的缺点</h4><p>尽管RSA加密算法被广泛使用，但它确实有一些缺点：</p><ol><li><strong>密钥生成困难</strong>：生成大素数需要特定的算法和足够的计算资源。在某些环境下，这可能是一个限制。</li><li><strong>计算效率低</strong>：由于涉及大数运算，RSA加密和解密过程相对较慢，尤其是当使用较长的密钥时。</li><li><strong>理论安全性未证明</strong>：尽管大数分解被认为是困难的，但尚无理论证明表明破解RSA加密的难度与大数分解的难度等价。</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_OAEP</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">key = RSA.generate(<span class="number">2048</span>)</span><br><span class="line">private_key = key.export_key()</span><br><span class="line">public_key = key.publickey().export_key()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 明文</span></span><br><span class="line">message = <span class="string">&quot;Hello RSA!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用公钥加密</span></span><br><span class="line">public_key = RSA.import_key(public_key)</span><br><span class="line">cipher = PKCS1_OAEP.new(public_key)</span><br><span class="line">encrypted_message = cipher.encrypt(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用私钥解密</span></span><br><span class="line">private_key = RSA.import_key(private_key)</span><br><span class="line">cipher = PKCS1_OAEP.new(private_key)</span><br><span class="line">decrypted_message = cipher.decrypt(encrypted_message)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Original Message:&quot;</span>, message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Encrypted Message:&quot;</span>, binascii.hexlify(encrypted_message))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted Message:&quot;</span>, decrypted_message.decode())</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">爬虫相关加密与解密理论</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="编码" scheme="https://www.yiuhangblog.com/tags/%E7%BC%96%E7%A0%81/"/>
    
    <category term="加解密" scheme="https://www.yiuhangblog.com/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>分布式爬取</title>
    <link href="https://www.yiuhangblog.com/2021/12/18/20211218%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E5%8F%96/"/>
    <id>https://www.yiuhangblog.com/2021/12/18/20211218%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E5%8F%96/</id>
    <published>2021-12-18T00:24:32.000Z</published>
    <updated>2024-02-28T10:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式概念和作用"><a href="#分布式概念和作用" class="headerlink" title="分布式概念和作用"></a>分布式概念和作用</h2><h3 id="分布式系统（Distributed-Systems）"><a href="#分布式系统（Distributed-Systems）" class="headerlink" title="分布式系统（Distributed Systems）"></a>分布式系统（Distributed Systems）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>分布式系统是由一组相互独立的计算机通过网络进行通信和协调工作的系统。每台计算机（通常称为“节点” Node）都有自己的内存和处理能力，它们共同协作以完成特定的任务或管理共享数据。</p><h4 id="作用与特点"><a href="#作用与特点" class="headerlink" title="作用与特点"></a>作用与特点</h4><ol><li><strong>可扩展性（Scalability）</strong>: 分布式系统可以通过增加更多的节点来提高性能和容量，而不是依赖单个更强大的机器。</li><li><strong>容错性（Fault Tolerance）</strong>: 由于系统分布在多个节点上，即使部分节点失败，整个系统仍然可以继续运行。</li><li><strong>资源共享（Resource Sharing）</strong>: 分布式系统允许不同地理位置的节点共享资源，如文件、数据或设备。</li><li><strong>灵活性（Flexibility）</strong>: 可以根据需要在不同的节点上部署不同的服务和应用。</li><li><strong>并行处理（Parallel Processing）</strong>: 多个节点可以同时处理任务，提高处理速度。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>云计算（Cloud Computing）</li><li>大数据处理（Big Data Processing）</li><li>在线事务处理（Online Transaction Processing, OLTP）</li><li>分布式文件系统（Distributed File Systems）</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4f801991-b0f0-4223-f71e-fd8073765b00/public"                      width = "500"                ><h3 id="分布式系统与网络爬虫的结合"><a href="#分布式系统与网络爬虫的结合" class="headerlink" title="分布式系统与网络爬虫的结合"></a>分布式系统与网络爬虫的结合</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a5e079af-0364-48df-8280-b76738c85f00/public"                      width = "500"                ><h4 id="网络爬虫（Web-Crawler）概念"><a href="#网络爬虫（Web-Crawler）概念" class="headerlink" title="网络爬虫（Web Crawler）概念"></a>网络爬虫（Web Crawler）概念</h4><p>网络爬虫，也称为网络蜘蛛（Web Spider）或网络机器人（Web Bot），是一种自动访问互联网并从网页中提取信息的程序。</p><h4 id="结合分布式系统的优势"><a href="#结合分布式系统的优势" class="headerlink" title="结合分布式系统的优势"></a>结合分布式系统的优势</h4><ol><li><strong>提高爬取效率</strong>: 通过多个节点并行爬取，可以显著提高数据收集的速度。</li><li><strong>抗干扰能力强</strong>: 单点爬虫易被封禁，而分布式爬虫由于请求来自不同IP，更难被识别和封禁。</li><li><strong>数据冗余与备份</strong>: 在多个节点上存储数据，增加数据安全性。</li><li><strong>负载均衡（Load Balancing）</strong>: 自动分配任务到不同节点，避免单个节点过载。</li></ol><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ul><li>搜索引擎（如Google, Bing）使用分布式爬虫来索引网页。</li><li>数据挖掘和市场分析，通过分布式爬虫收集大量数据进行分析。</li><li>社交媒体分析，如通过爬取Twitter或Facebook的公开数据进行情感分析或趋势预测。</li></ul><h4 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h4><ul><li><strong>消息队列（Message Queue）</strong>: 如RabbitMQ、Kafka，用于在不同节点间分配任务。</li><li><strong>分布式存储（Distributed Storage）</strong>: 如Hadoop HDFS，用于存储爬取的数据。</li><li><strong>负载均衡器（Load Balancer）</strong>: 均衡请求分配。</li><li><strong>分布式数据库（Distributed Database）</strong>: 如Cassandra或MongoDB，用于高效存储和检索数据。</li></ul><p>将分布式系统的概念应用于网络爬虫，可以极大地提高爬虫的效率和效能，同时降低被封禁的风险。这种结合在数据密集型应用，如搜索引擎和大数据分析中尤为重要。</p><h2 id="Scrapy-Redis"><a href="#Scrapy-Redis" class="headerlink" title="Scrapy-Redis"></a>Scrapy-Redis</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Scrapy-Redis是一个基于Redis的Scrapy扩展，用于支持Scrapy项目的分布式爬取和数据处理。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/88d9fd19-9e75-4d38-bbdd-79a53f9db500/public"                      width = "500"                ><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>分布式爬取</strong>: 通过共享Redis中的请求队列，支持多个Scrapy爬虫实例的协作，适合多域名、大规模网页的爬取。</li><li><strong>分布式数据处理</strong>: 爬取到的数据（Items）被推送至Redis中，允许部署多个数据处理节点。</li><li><strong>兼容性强</strong>: 可以轻松集成至现有的Scrapy项目中，不需大量修改原有代码。</li></ol><h3 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h3><ul><li><strong>Scrapy爬虫节点</strong>: 多个Scrapy实例并行工作，共享任务队列。</li><li><strong>Redis服务器</strong>: 作为中心节点，管理请求队列和数据存储。</li><li><strong>数据处理节点</strong>: 可以是Scrapy管道（Pipelines）或其他数据处理应用。</li></ul><h3 id="Redis的安装与使用"><a href="#Redis的安装与使用" class="headerlink" title="Redis的安装与使用"></a>Redis的安装与使用</h3><h4 id="在Ubuntu-Debian上安装Redis"><a href="#在Ubuntu-Debian上安装Redis" class="headerlink" title="在Ubuntu&#x2F;Debian上安装Redis"></a>在Ubuntu&#x2F;Debian上安装Redis</h4><p>在Linux系统上安装Redis的过程可以通过不同的方法进行，包括使用包管理器或Snapcraft。</p><h5 id="先决条件（Prerequisites）"><a href="#先决条件（Prerequisites）" class="headerlink" title="先决条件（Prerequisites）"></a>先决条件（Prerequisites）</h5><p>对于运行极简发行版的系统（例如Docker容器），可能需要首先安装<code>lsb-release</code>、<code>curl</code>和<code>gpg</code>：</p><p><code>sudo apt install lsb-release curl gpg</code></p><h5 id="添加仓库（Repository）"><a href="#添加仓库（Repository）" class="headerlink" title="添加仓库（Repository）"></a>添加仓库（Repository）</h5><p>将Redis的官方APT仓库添加到系统的apt索引中，然后进行更新：</p><ol><li>导入GPG密钥（Import GPG Key）:</li></ol><p><code>curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg</code></p><ol start="2"><li>添加Redis存储库（Add Redis Repository）:</li></ol><p><code>echo &quot;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main&quot; | sudo tee /etc/apt/sources.list.d/redis.list</code></p><ol start="3"><li>更新系统包列表（Update Package List）:</li></ol><p><code>sudo apt-get update</code></p><ol start="4"><li>安装Redis（Install Redis）:</li></ol><p><code>sudo apt-get install redis</code></p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>如果找不到Redis路径可以先查看redis进程号, 查看命令: <code>ps -ef | grep redis</code></p><p>拿到上面进程号####然后查询<code>ll -l /proc/####/cwd</code>即可</p>    </div>  </div><h4 id="Redis-基本信息和操作"><a href="#Redis-基本信息和操作" class="headerlink" title="Redis 基本信息和操作"></a>Redis 基本信息和操作</h4><h5 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h5><p>Redis（Remote Dictionary Server）是一个开源的、支持网络、基于内存且可选持久化的键值对存储数据库。它通常被用作数据库、缓存或消息传递系统。它提供了丰富的数据结构，如字符串（strings）、哈希表（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）以及位图（bitmaps）等。</p><h5 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h5><ul><li><strong>默认端口</strong>: 6379。</li><li><strong>数据库数量</strong>: 默认支持16个，编号从0到15。</li></ul><h5 id="redis命令"><a href="#redis命令" class="headerlink" title="redis命令"></a>redis命令</h5><ul><li>redis执行了make install后，redis的课执行文件都会自动复制到 &#x2F;usr&#x2F;local&#x2F;bin 目录<ul><li><code>redis-server</code>    redis服务器</li><li><code>redis-cli</code>    redis命令行客户端</li><li><code>redis-benchmark</code>     redis性能测试工具</li><li><code>redis-check-aof</code>     aof文件修复工具</li><li><code>redis-check-dump</code>   rdb文件检查工具</li><li><code>redis-cli shutdown</code>  停止 redis </li><li><code>redis-server</code>   启动 redis-server</li><li><code>redis-server /etc/redis/redis.conf</code>    带配置文件启动</li></ul></li></ul><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ol><li><strong>字符串（String）</strong>：这是 Redis 最基本的数据类型，它可以存储任何形式的字符串，包括文本、数字甚至二进制数据。字符串类型常用于缓存用户信息、会话数据等。</li><li><strong>哈希（Hash）</strong>：哈希是键值对的集合，类似于编程语言中的字典或哈希表。它适用于存储对象，每个对象可以包含多对字段和值。例如，可以用哈希存储用户的各种属性，如姓名、年龄、邮箱等。</li><li><strong>列表（List）</strong>：列表是一系列有序的字符串，类似于数组。Redis 列表是双向链表，因此在列表的头部或尾部添加或删除元素非常快速。它适用于实现队列、栈或其他有序集合。</li><li><strong>集合（Set）</strong>：集合是一组不重复的字符串元素。由于集合中的元素是无序的，可以快速执行添加、删除和检查元素是否存在等操作。集合适用于存储无序的唯一元素，例如标签、好友关系等。</li><li><strong>有序集合（Sorted Set）</strong>：有序集合和普通集合类似，但每个元素都会关联一个浮点数分数，这使得元素能按分数有序排列。有序集合适用于需要按某种顺序访问元素的场景，如排行榜。</li><li><strong>位图（Bitmap）</strong>：位图本质上是字符串类型的一种特殊用法，它允许对字符串的位进行操作。位图适用于处理大量的布尔值，如用户在线状态、特征标志等。</li><li><strong>超级日志（HyperLogLog）</strong>：超级日志是一种用于高效统计唯一元素个数（如独立访客数）的概率数据结构。它可以使用极小的内存空间来处理大量数据。</li></ol><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><h6 id="字符串（String）操作"><a href="#字符串（String）操作" class="headerlink" title="字符串（String）操作"></a>字符串（String）操作</h6><p>Redis 的字符串（String）是最基本的数据类型之一，它支持多种操作，涵盖了对单个或多个字符串值的处理。</p><ul><li><strong>设置值</strong>:<ul><li><code>SET key value</code>: 设置指定键的值。</li><li><code>SETEX key seconds value</code>: 设置键的值，并设置过期时间（以秒为单位）。</li><li><code>SETNX key value</code>: 仅当键不存在时，设置键的值。</li><li><code>MSET key1 value1 [key2 value2 ...]</code>: 同时设置一个或多个键值对。</li></ul></li><li><strong>获取值</strong>:<ul><li>GET key&#96;: 获取指定键的值。</li><li><code>MGET key1 [key2 ...]</code>: 获取一个或多个键的值。</li><li><code>GETSET key value</code>: 设置指定键的值，并返回键的旧值。</li></ul></li><li><strong>操作数值</strong>:<ul><li><code>INCR key</code>: 将键的整数值增加一。</li><li><code>DECR key</code>: 将键的整数值减少一。</li><li><code>INCRBY key increment</code>: 将键的整数值增加指定的量。</li><li><code>DECRBY key decrement</code>: 将键的整数值减少指定的量。</li><li><code>INCRBYFLOAT key increment</code>: 将键的浮点数值增加指定的量。</li></ul></li><li><strong>处理子字符串</strong>:<ul><li><code>GETRANGE key start end</code>: 获取键值的子串。</li><li><code>SETRANGE key offset value</code>: 从指定的偏移量开始替换键的值。</li></ul></li><li><strong>键值长度和追加</strong>:<ul><li><code>STRLEN key</code>: 获取指定键值的长度。</li><li><code>APPEND key value</code>: 将值追加到指定键的现有值的末尾。</li></ul></li><li><strong>位操作</strong>:<ul><li><code>SETBIT key offset value</code>: 对键值的二进制表示的指定偏移量的位进行设置。</li><li><code>GETBIT key offset</code>: 获取键值的二进制表示中指定偏移量的位值。</li><li><code>BITCOUNT key [start end]</code>: 计算字符串被设置为1的位数。</li><li><code>BITOP operation destkey key1 [key2 ...]</code>: 对一个或多个键执行位操作，并将结果存储在目标键中。</li></ul></li><li><strong>过期和持久化</strong>:<ul><li><code>EXPIRE key seconds</code>: 设置键的过期时间（秒）。</li><li><code>PERSIST key</code>: 移除键的过期时间，使其成为持久的键。</li></ul></li></ul><h6 id="哈希表（Hash）操作"><a href="#哈希表（Hash）操作" class="headerlink" title="哈希表（Hash）操作"></a>哈希表（Hash）操作</h6><p>Redis 的哈希（Hash）是一种键值对集合的数据类型，非常适合用来存储对象。哈希表中的每个字段都是唯一的，并且它们映射到特定的值。</p><ul><li><strong>添加和设置字段</strong>:<ul><li><code>HSET key field value</code>: 设置哈希表字段的值。</li><li><code>HMSET key field1 value1 [field2 value2 ...]</code>: 同时设置哈希表的多个字段。</li><li><code>HSETNX key field value</code>: 仅当字段不存在时，设置哈希表字段的值。</li></ul></li><li><strong>获取字段值</strong>:<ul><li><code>HGET key field</code>: 获取存储在哈希表中的字段的值。</li><li><code>HMGET key field1 [field2 ...]</code>: 获取所有给定字段的值。</li><li><code>HGETALL key</code>: 获取在哈希表中指定键的所有字段和值。</li><li><code>HVALS key</code>: 获取哈希表中所有字段的值。</li></ul></li><li><strong>删除字段</strong>:<ul><li><code>HDEL key field1 [field2 ...]</code>: 删除一个或多个哈希表字段。</li></ul></li><li><strong>字段计数</strong>:<ul><li><code>HLEN key</code>: 获取哈希表中字段的数量。</li></ul></li><li><strong>检查字段存在</strong>:<ul><li><code>HEXISTS key field</code>: 查看哈希表的指定字段是否存在。</li></ul></li><li><strong>增减数值字段</strong>:<ul><li><code>HINCRBY key field increment</code>: 为哈希表 key 中的指定字段的整数值加上增量 increment。</li><li><code>HINCRBYFLOAT key field increment</code>: 为哈希表 key 中的指定字段的浮点数值加上增量 increment。</li></ul></li><li><strong>获取所有字段名</strong>:<ul><li><code>HKEYS key</code>: 获取哈希表中的所有字段。</li></ul></li><li><strong>扫描哈希表</strong>:<ul><li><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code>: 迭代哈希表中的键值对。</li></ul></li><li><strong>获取字段值的长度</strong>:<ul><li><code>HSTRLEN key field</code>: 获取存储在哈希表中的字段值的长度。</li></ul></li></ul><h6 id="列表（List）操作"><a href="#列表（List）操作" class="headerlink" title="列表（List）操作"></a>列表（List）操作</h6><p>Redis 的列表（List）是一种线性数据结构，主要用于存储有序的字符串元素集合。Redis 列表是基于双向链表实现的，这意味着即使在很长的列表上，向列表的头部或尾部添加和移除元素仍然非常快速。</p><ul><li><strong>添加元素</strong>:<ul><li><code>LPUSH key value1 [value2 ...]</code>: 将一个或多个值插入到列表头部。</li><li><code>RPUSH key value1 [value2 ...]</code>: 将一个或多个值插入到列表尾部。</li></ul></li><li><strong>移除元素</strong>:<ul><li><code>LPOP key</code>: 移除并返回列表头部的元素。</li><li><code>RPOP key</code>: 移除并返回列表尾部的元素。</li><li><code>LREM key count value</code>: 根据参数 count 的值，移除列表中与参数 value 相等的元素。</li></ul></li><li><strong>列表长度</strong>:<ul><li><code>LLEN key</code>: 获取列表长度。</li></ul></li><li><strong>获取列表元素</strong>:<ul><li><code>LRANGE key start stop</code>: 获取列表指定范围内的元素。</li><li><code>LINDEX key index</code>: 获取列表中指定索引的元素。</li></ul></li><li><strong>修改列表元素</strong>:<ul><li><code>LSET key index value</code>: 将列表中指定索引的元素的值设置为另一个值。</li></ul></li><li><strong>插入元素</strong>:<ul><li><code>LINSERT key BEFORE|AFTER pivot value</code>: 在列表的元素前或后插入元素。</li></ul></li><li><strong>截取列表</strong>:<ul><li><code>LTRIM key start stop</code>: 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</li></ul></li><li><strong>阻塞操作</strong>:<ul><li><code>BLPOP key1 [key2 ...] timeout</code>: 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li><li><code>BRPOP key1 [key2 ...] timeout</code>: 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li><li><code>BRPOPLPUSH source destination timeout</code>: 从列表中弹出一个值，将它推入另一个列表并返回它；如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li></ul></li><li><strong>转移元素</strong>:<ul><li><code>RPOPLPUSH source destination</code>: 移除列表的最后一个元素，将该元素添加到另一个列表并返回。</li></ul></li></ul><h6 id="集合（Set）操作"><a href="#集合（Set）操作" class="headerlink" title="集合（Set）操作"></a>集合（Set）操作</h6><p>Redis 的集合（Set）是一种存储唯一元素且无序的字符串集合。集合非常适合用于存储不重复的数据，如标签、好友关系等。</p><ul><li><strong>添加元素</strong>:<ul><li><code>SADD key member1 [member2 ...]</code>: 向集合添加一个或多个成员。</li></ul></li><li><strong>移除元素</strong>:<ul><li><code>SREM key member1 [member2 ...]</code>: 移除集合中一个或多个成员。</li></ul></li><li><strong>集合大小</strong>:<ul><li><code>SCARD key</code>: 获取集合的成员数。</li></ul></li><li><strong>检查成员存在</strong>:<ul><li><code>SISMEMBER key member</code>: 判断成员元素是否是集合的成员。</li></ul></li><li><strong>获取所有成员</strong>:<ul><li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li></ul></li><li><strong>随机元素</strong>:<ul><li><code>SRANDMEMBER key [count]</code>: 返回集合中一个或多个随机数。</li><li><code>SPOP key [count]</code>: 移除并返回集合中的一个随机元素。</li></ul></li><li><strong>集合运算</strong>:<ul><li><code>SUNION key1 [key2 ...]</code>: 返回所有给定集合的并集。</li><li><code>SINTER key1 [key2 ...]</code>: 返回所有给定集合的交集。</li><li><code>SDIFF key1 [key2 ...]</code>: 返回第一个集合与其他集合之间的差集。</li></ul></li><li><strong>集合运算并存储结果</strong>:<ul><li><code>SUNIONSTORE destination key1 [key2 ...]</code>: 计算所有给定集合的并集，并存储在 destination 集合中。</li><li><code>SINTERSTORE destination key1 [key2 ...]</code>: 计算所有给定集合的交集，并存储在 destination 集合中。</li><li><code>SDIFFSTORE destination key1 [key2 ...]</code>: 计算第一个集合与其他集合的差集，并存储在 destination 集合中。</li></ul></li><li><strong>集合的遍历</strong>:<ul><li><code>SSCAN key cursor [MATCH pattern] [COUNT count]</code>: 迭代集合中的元素。</li></ul></li><li><strong>移动成员到另一个集合</strong>:<ul><li><code>SMOVE source destination member</code>: 将成员从一个集合移动到另一个集合。</li></ul></li></ul><h6 id="有序集合（Sorted-Set）操作"><a href="#有序集合（Sorted-Set）操作" class="headerlink" title="有序集合（Sorted Set）操作"></a>有序集合（Sorted Set）操作</h6><p>Redis 的有序集合（Sorted Set）是一种集合数据类型，它不仅存储成员（Member），还为每个成员关联了一个浮点数分数（Score）。这使得成员能够按照分数的大小排序，从而支持快速的插入、删除、查找和排名操作。</p><ul><li><strong>添加和更新成员</strong>:<ul><li><code>ZADD key score1 member1 [score2 member2 ...]</code>: 向有序集合添加一个或多个成员，或更新已存在成员的分数。</li></ul></li><li><strong>移除成员</strong>:<ul><li><code>ZREM key member1 [member2 ...]</code>: 移除有序集合中的一个或多个成员。</li></ul></li><li><strong>获取成员数量</strong>:<ul><li><code>ZCARD key</code>: 获取有序集合的成员数量。</li></ul></li><li><strong>获取成员分数</strong>:<ul><li><code>ZSCORE key member</code>: 获取有序集合中成员的分数。</li></ul></li><li><strong>增加成员分数</strong>:<ul><li><code>ZINCRBY key increment member</code>: 增加有序集合中成员的分数。</li></ul></li><li><strong>范围查询</strong>:<ul><li><code>ZRANGE key start stop [WITHSCORES]</code>: 返回有序集合中指定区间内的成员。</li><li><code>ZREVRANGE key start stop [WITHSCORES]</code>: 返回有序集合中指定区间内的成员，按分数从高到低排序。</li><li><code>ZRANGEBYSCORE key min max [WITHSCORES]</code>: 根据分数值获取有序集合中的成员。</li></ul></li><li><strong>移除指定排名或分数范围内的成员</strong>:<ul><li><code>ZREMRANGEBYRANK key start stop</code>: 移除有序集合中指定排名（index）区间内的所有成员。</li><li><code>ZREMRANGEBYSCORE key min max</code>: 移除有序集合中分数在给定区间内的成员。</li></ul></li><li><strong>获取成员排名</strong>:<ul><li><code>ZRANK key member</code>: 获取有序集合中成员的排名（按分数值递增）。</li><li><code>ZREVRANK key member</code>: 获取有序集合中成员的排名（按分数值递减）。</li></ul></li><li><strong>有序集合间的运算</strong>:<ul><li><code>ZUNIONSTORE destination numkeys key1 [key2 ...] [WEIGHTS weight1 [weight2 ...]]</code>: 计算多个有序集合的并集，并存储在新的有序集合中。</li><li><code>ZINTERSTORE destination numkeys key1 [key2 ...] [WEIGHTS weight1 [weight2 ...]]</code>: 计算多个有序集合的交集，并存储在新的有序集合中。</li></ul></li><li><strong>遍历有序集合</strong>:<ul><li><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code>: 迭代有序集合中的元素。</li></ul></li></ul><h6 id="键（Key）管理"><a href="#键（Key）管理" class="headerlink" title="键（Key）管理"></a>键（Key）管理</h6><p>Redis 提供了一系列命令用于管理和操作键（Key），这些命令允许你对存储在 Redis 中的数据进行各种操作，包括但不限于查询、移动、重命名和设置键的生命周期。</p><ul><li><strong>键存在性检查</strong>:<ul><li><code>EXISTS key1 [key2 ...]</code>: 检查一个或多个键是否存在。</li></ul></li><li><strong>删除键</strong>:<ul><li><code>DEL key1 [key2 ...]</code>: 删除一个或多个键。</li></ul></li><li><strong>设置键的过期时间</strong>:<ul><li><code>EXPIRE key seconds</code>: 设置键的过期时间（秒）。</li><li><code>PEXPIRE key milliseconds</code>: 设置键的过期时间（毫秒）。</li><li><code>EXPIREAT key timestamp</code>: 设置键的过期时间为 UNIX 时间戳（秒）。</li><li><code>PEXPIREAT key milliseconds-timestamp</code>: 设置键的过期时间为 UNIX 时间戳（毫秒）。</li></ul></li><li><strong>查询键的剩余生存时间</strong>:<ul><li><code>TTL key</code>: 查询键的剩余生存时间（秒）。</li><li><code>PTTL key</code>: 查询键的剩余生存时间（毫秒）。</li></ul></li><li><strong>移除键的过期时间</strong>:<ul><li><code>PERSIST key</code>: 移除键的过期时间。</li></ul></li><li><strong>查找符合给定模式的键</strong>:<ul><li><code>KEYS pattern</code>: 查找所有符合给定模式的键。</li><li><code>SCAN cursor [MATCH pattern] [COUNT count]</code>: 迭代数据库中的数据库键。</li></ul></li><li><strong>重命名键</strong>:<ul><li><code>RENAME key newkey</code>: 修改键名。</li><li><code>RENAMENX key newkey</code>: 仅当 newkey 不存在时，将 key 改名为 newkey。</li></ul></li><li><strong>随机返回一个键</strong>:<ul><li><code>RANDOMKEY</code>: 从数据库中随机返回一个键。</li></ul></li><li><strong>键类型查询</strong>:<ul><li><code>TYPE key</code>: 返回键所储存的值的类型。</li></ul></li><li><strong>移动键到另一个数据库</strong>:<ul><li><code>MOVE key db</code>: 将当前数据库的键移动到指定的数据库 db 当中。</li></ul></li><li><strong>键的字节串长度查询</strong>:<ul><li><code>STRLEN key</code>: 获取指定键所储存的字符串值的长度。</li></ul></li><li><strong>原子操作</strong>:<ul><li><code>DUMP key</code>: 返回存储在指定键的值的序列化版本。</li><li><code>RESTORE key ttl serialized-value [REPLACE]</code>: 通过序列化值创建一个键，ttl 为存活时间，REPLACE 表示是否替换已存在的键。</li></ul></li></ul><h6 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h6><p>在 Redis 中，事务提供了一种将多个命令打包然后一次性、按顺序执行的机制。它通过一系列命令来实现事务的开始、执行和管理。</p><ul><li><strong>开始事务</strong>:<ul><li><code>MULTI</code>: 标记一个事务块的开始。后续的命令将会被队列化，而不是立即执行。</li></ul></li><li><strong>命令入队</strong>:<ul><li>在 <code>MULTI</code> 命令之后输入的命令不会立即被执行，而是会被放入一个队列中。当执行 <code>EXEC</code> 命令时，队列中的所有命令会被连续执行。</li></ul></li><li><strong>执行事务</strong>:<ul><li><code>EXEC</code>: 执行所有在 <code>MULTI</code> 之后入队的命令。如果在执行 <code>EXEC</code> 之前连接被断开，那么事务中的所有命令都不会被执行。</li></ul></li><li><strong>放弃事务</strong>:<ul><li><code>DISCARD</code>: 取消事务，放弃执行事务块内的所有命令。</li></ul></li><li><strong>监视键</strong>:<ul><li><code>WATCH key1 [key2 ...]</code>: 在执行事务之前监视一个或多个键。如果在调用 <code>EXEC</code> 命令之前这些键被其他命令改变了，那么事务将被放弃。</li></ul></li><li><strong>取消监视键</strong>:<ul><li><code>UNWATCH</code>: 取消 WATCH 命令对所有键的监视。</li></ul></li><li><strong>Redis 事务的特点：</strong><ul><li><strong>原子性</strong>: Redis 的事务保证了事务内的命令要么全部执行，要么全部不执行。</li><li><strong>没有隔离级别</strong>: Redis 不支持传统数据库意义上的事务隔离级别。如果事务执行期间，有其他客户端修改了被 <code>WATCH</code> 命令监视的键，那么该事务将被取消。</li><li><strong>不支持回滚</strong>: 在 Redis 中，事务没有回滚的概念。如果事务中某个操作失败，其他操作仍会继续执行。</li></ul></li></ul><h6 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h6><p>Redis 的发布&#x2F;订阅（pub&#x2F;sub）是一种消息通信模式，它使得消息的发送者（发布者）不需要知道消息的接收者（订阅者），反之亦然。这种模式非常适合构建松耦合的应用程序和服务。</p><ul><li><strong>发布消息</strong>:<ul><li><code>PUBLISH channel message</code>: 将消息发送到指定的频道。</li></ul></li><li><strong>订阅频道</strong>:<ul><li><code>SUBSCRIBE channel1 [channel2 ...]</code>: 订阅一个或多个频道。订阅后，客户端将接收这些频道上发布的所有消息。</li></ul></li><li><strong>退订频道</strong>:<ul><li><code>UNSUBSCRIBE [channel1 [channel2 ...]]</code>: 退订一个或多个频道。如果没有提供频道名，客户端将退订所有频道。</li></ul></li><li><strong>按模式订阅频道</strong>:<ul><li><code>PSUBSCRIBE pattern1 [pattern2 ...]</code>: 根据给定的模式订阅频道。模式可以包含通配符。</li></ul></li><li><strong>按模式退订频道</strong>:<ul><li><code>PUNSUBSCRIBE [pattern1 [pattern2 ...]]</code>: 根据给定的模式退订频道。如果没有提供模式，客户端将退订所有模式。</li></ul></li><li><strong>列出当前活跃的频道</strong>:<ul><li><code>PUBSUB CHANNELS [pattern]</code>: 列出当前的活跃频道。可选的模式参数可以用来过滤频道名。</li></ul></li><li><strong>列出特定频道的订阅者数量</strong>:<ul><li><code>PUBSUB NUMSUB [channel1 [channel2 ...]]</code>: 返回一个或多个频道的订阅者数量。</li></ul></li><li><strong>列出按模式订阅的数量</strong>:<ul><li><code>PUBSUB NUMPAT</code>: 返回按模式订阅的数量。</li></ul></li></ul><h6 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h6><p>Redis 从 3.2 版本开始引入了地理空间支持，允许使用一组命令来存储、查询和操作地理位置信息。这些功能基于 Redis 的有序集合实现，每个元素都是一个带有经纬度的地理空间信息。</p><ul><li><strong>添加地理位置信息</strong>:<ul><li><code>GEOADD key longitude latitude member [longitude latitude member ...]</code>: 将指定的地理空间位置（经度、纬度、成员）添加到指定的 key 中。</li></ul></li><li><strong>地理位置查询</strong>:<ul><li><code>GEOPOS key member [member ...]</code>: 返回一个或多个成员位置的经纬度。</li></ul></li><li><strong>计算两地距离</strong>:<ul><li><code>GEODIST key member1 member2 [unit]</code>: 计算两个成员之间的距离。单位可以是 m（米）、km（千米）、mi（英里）或 ft（英尺）。</li></ul></li><li><strong>按半径查询成员</strong>:<ul><li><code>GEORADIUS key longitude latitude radius m|km|mi|ft [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code>: 以指定的经纬度为中心，查找在指定半径内的元素。可选参数提供了多种查询功能，例如排序、限制返回数量等。</li><li><code>GEORADIUSBYMEMBER key member radius m|km|mi|ft [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code>: 以指定成员为中心，查找在指定半径内的元素。</li></ul></li><li><strong>地理空间索引的哈希值</strong>:<ul><li><code>GEOHASH key member [member ...]</code>: 返回一个或多个位置对象的 Geohash 字符串。</li></ul></li></ul><h6 id="基于概率的数据结构"><a href="#基于概率的数据结构" class="headerlink" title="基于概率的数据结构"></a>基于概率的数据结构</h6><p>Redis 支持几种基于概率的数据结构，允许在内存效率和准确性之间取得平衡。这些数据结构特别适用于处理大规模数据集，其中完全准确的结果要么不可行，要么成本过高。</p><ul><li><p><strong>HyperLogLog</strong></p><p>用于高效的基数估计（即估计唯一元素的数量）。</p><ul><li><code>PFADD key element [element ...]</code>: 向 HyperLogLog 中添加元素。</li><li><code>PFCOUNT key [key ...]</code>: 返回 HyperLogLog 的近似基数估计值。</li><li><code>PFMERGE destkey sourcekey [sourcekey ...]</code>: 合并多个 HyperLogLog 到一个新的 HyperLogLog 中。</li></ul></li><li><p><strong>布隆过滤器</strong>（通过 RedisBloom 模块）</p><p>布隆过滤器是一种空间效率很高的数据结构，用于测试一个元素是否是集合的一部分。它可能返回假阳性，但不会返回假阴性。</p><ul><li><p><code>BF.ADD key element</code>: 将元素添加到布隆过滤器。</p></li><li><p><code>BF.MADD key element [element ...]</code>: 向布隆过滤器中添加多个元素。</p></li><li><p><code>BF.EXISTS key element</code>: 检查元素是否可能存在于布隆过滤器中。</p></li><li><p><code>BF.MEXISTS key element [element ...]</code>: 检查多个元素是否可能存在于布隆过滤器中。</p></li></ul></li><li><p>计数最小Sketch（通过 RedisBloom 模块）</p><p>计数最小 Sketch 是一种用于频率估计的数据结构，它可以估计一个元素在数据流中出现的次数。</p><ul><li><code>CMS.INITBYDIM key width depth</code>: 通过指定宽度和深度初始化计数最小 Sketch。</li><li><code>CMS.INITBYPROB key error probability</code>: 通过指定错误率和置信度初始化计数最小 Sketch。</li><li><code>CMS.INCRBY key item count [item count ...]</code>: 增加一个或多个元素的计数值。</li><li><code>CMS.QUERY key item [item ...]</code>: 查询一个或多个元素的计数值。</li></ul></li><li><p>Top-K 结构（通过 RedisBloom 模块）</p><p>Top-K 结构用于跟踪数据流中最常见的元素。</p><ul><li><code>TOPK.RESERVE key topk width depth decay</code>: 创建一个 Top-K 结构。</li><li><code>TOPK.ADD key item [item ...]</code>: 向 Top-K 结构中添加一个或多个元素。</li><li><code>TOPK.QUERY key item [item ...]</code>: 查询一个或多个元素是否在 Top-K 结构中。</li><li><code>TOPK.LIST key</code>: 列出 Top-K 结构中的元素。</li></ul></li></ul><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><ul><li><code>PING</code>：检查服务是否运行。</li><li><code>INFO</code>：获取服务器的信息和统计。</li></ul><h5 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h5><h6 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h6><p>RDB是Redis的一种持久化机制，它会在指定的时间间隔内生成数据集的时间点快照。</p><ul><li><strong>触发机制</strong>: 可以通过<code>SAVE</code>命令手动触发，或者配置在<code>redis.conf</code>文件中的规则自动触发。</li><li><strong>优点</strong>: 提供了一个非常紧凑的数据文件，适合灾难恢复，快照频率可配置，可以最大化性能和数据持久性之间的权衡。</li><li><strong>缺点</strong>: 在生成快照时可能会消耗大量的IO和CPU资源，如果Redis在快照之间崩溃，那么自上次快照以来的所有数据将丢失。</li></ul><h6 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h6><p>AOF是另一种Redis持久化机制，记录了执行过的所有写操作命令，并在服务器启动时重新执行这些命令来重建数据集。</p><ul><li><strong>触发机制</strong>: 每个写操作命令都会追加到AOF文件中。</li><li><strong>优点</strong>: 提供了更好的持久性和安全性，可以配置不同的同步方式，如每秒同步或每写操作同步。</li><li><strong>缺点</strong>: AOF文件通常比RDB文件大，且恢复速度可能慢于RDB方式。</li></ul><h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li><strong>会话缓存</strong>: 存储用户会话信息，如登录状态或用户的临时偏好设置，以便快速读取。</li><li><strong>队列</strong>: 利用Redis的列表数据结构实现消息队列，支持多种队列模式，如FIFO（先进先出），LIFO（后进先出）。</li><li><strong>排行榜</strong>: 使用Redis的有序集合数据类型，它可以保持元素插入的顺序，适合实时排行榜系统。</li><li><strong>计数器</strong>: 利用Redis的原子操作如<code>INCR</code>实现计数器，常用于统计点击数、用户在线数等。</li><li><strong>发布&#x2F;订阅</strong>: Redis提供了PUB&#x2F;SUB模式，允许客户端订阅频道并接收发布到这些频道的消息，适用于实时消息系统如聊天室。</li></ul><h2 id="Redis如何开启远程服务"><a href="#Redis如何开启远程服务" class="headerlink" title="Redis如何开启远程服务"></a>Redis如何开启远程服务</h2><p>Redis开启远程服务的操作方法：</p><ol><li>打开redis的配置文件<code>redis.conf</code></li><li>将<code>bind 127.0.0.1</code>注释掉</li><li>将<code>protected-mode yes</code>改成<code>protected-mode no</code></li><li>添加<code>daemonize no</code></li><li>重启redis服务</li></ol><h2 id="Scrapy-Redis-中存储的数据类型及其用途"><a href="#Scrapy-Redis-中存储的数据类型及其用途" class="headerlink" title="Scrapy-Redis 中存储的数据类型及其用途"></a>Scrapy-Redis 中存储的数据类型及其用途</h2><ul><li><p><strong>List类型 (<code>spidername:items</code>)</strong></p><ul><li>用途：存储爬虫获取到的数据项，数据项是JSON格式的字符串。</li><li>例如：<code>db250:items</code> 存储豆瓣电影 Top 250 的爬取数据。</li></ul></li><li><p><strong>Set类型 (<code>spidername:dupefilter</code>)</strong></p><ul><li>用途：用于存储已访问URL的哈希值，以实现去重。</li><li>特点：存储的是URL的40字符哈希字符串。</li></ul></li><li><p><strong>List类型 (<code>spidername:start_urls</code>)</strong></p><ul><li>用途：存储启动爬虫时的初始URL。</li><li>例如：<code>db250:start_urls</code> 可以存储 <code>https://www.movie.douban.com/top250</code> 作为起始页面。</li></ul></li><li><p><strong>ZSet类型 (<code>spidername:requests</code>)</strong></p><ul><li>用途：存储待调度的请求，内容是序列化的请求对象。</li><li>特点：使用ZSet可以对请求进行优先级排序。</li></ul></li></ul><h2 id="常用设置及其说明"><a href="#常用设置及其说明" class="headerlink" title="常用设置及其说明"></a>常用设置及其说明</h2><ol><li><strong>调度器设置</strong><ul><li><code>SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;</code></li><li>功能：启用Scrapy-Redis的调度器，将请求存储到Redis中。</li></ul></li><li><strong>去重过滤器设置</strong><ul><li><code>DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</code></li><li>功能：确保所有的Spider通过Redis共享相同的重复过滤器。</li></ul></li><li><strong>管道设置</strong><ul><li><code>ITEM_PIPELINES = &#123;&#39;scrapy_redis.pipelines.RedisPipeline&#39;: 300,&#125;</code></li><li>功能：启用Redis管道，将爬取的项存储到Redis中。</li></ul></li><li><strong>Redis连接设置</strong><ul><li><code>REDIS_HOST = &#39;localhost&#39;</code></li><li><code>REDIS_PORT = 6379</code></li><li>功能：指定连接到Redis服务器的主机和端口。</li></ul></li><li><strong>调度器持久化设置</strong><ul><li><code># SCHEDULER_PERSIST = True</code></li><li>功能：设置为True时，不清理Redis队列，允许爬虫暂停和恢复，数据不会丢失。</li><li>特点：这是一个可选设置，根据需求选择是否启用。</li></ul></li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ul><li><strong>扩展性</strong>：Scrapy-Redis的设计使得Scrapy爬虫具有更好的扩展性，特别适用于大规模分布式爬取。</li><li><strong>负载均衡</strong>：通过Redis队列，多个爬虫实例可以共享URL请求，实现负载均衡。</li><li><strong>数据共享</strong>：所有的Spider可以通过Redis数据库共享去重信息和待抓取的URL，从而协同工作。</li></ul><h2 id="分布式项目演示"><a href="#分布式项目演示" class="headerlink" title="分布式项目演示"></a>分布式项目演示</h2><h3 id="演示逻辑"><a href="#演示逻辑" class="headerlink" title="演示逻辑"></a>演示逻辑</h3><ol><li>将代码设置成可以进行分布式爬取代码</li><li>将分布式代码copy一份,一共两份</li><li>两份代码,两处内容存放的位置,两处爬取的内容之和是整体内容</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3d744628-c6fd-402a-f2b1-1ffddfabf700/public"                      width = "500"                ><h5 id="项目配置及项目代码"><a href="#项目配置及项目代码" class="headerlink" title="项目配置及项目代码"></a>项目配置及项目代码</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c93190e8-9dcf-4716-b691-64e7b98ffe00/public"                      width = "500"                ><p><strong>spider作了简单改动,更重要的是在settings里作一些设置</strong></p><h6 id="Spider文件"><a href="#Spider文件" class="headerlink" title="Spider文件"></a>Spider文件</h6><p>代码作了简单改动</p><ol><li><p>导出RedisSpider</p></li><li><p>类继承 RedisSpider</p></li><li><p>注销start_urls   设置  redis_key &#x3D; “db:start_urls”  开启爬虫</p></li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> DbItem</span><br><span class="line"><span class="keyword">from</span> scrapy_redis.spiders <span class="keyword">import</span> RedisSpider</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dbtest1Spider</span>(<span class="title class_ inherited__">RedisSpider</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;#1 Spider on...&quot;</span>)</span><br><span class="line">    name = <span class="string">&quot;dbtest1&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;movie.douban.com&quot;</span>]</span><br><span class="line">    <span class="comment"># start_urls = [&quot;https://movie.douban.com/top250&quot;]  # 修改为开始爬取的页面</span></span><br><span class="line">    redis_key = <span class="string">&quot;dbtest1:start_urls&quot;</span>  <span class="comment"># 3.开启爬虫的key</span></span><br><span class="line">    page_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        node_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node_list:</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">                <span class="comment"># 标题</span></span><br><span class="line">                movie_name = node.xpath(<span class="string">&#x27;./div/a/span/text()&#x27;</span>).get()</span><br><span class="line">                <span class="comment"># 导演</span></span><br><span class="line">                director = node.xpath(<span class="string">&#x27;./div/p/text()&#x27;</span>).get().strip()</span><br><span class="line">                <span class="comment"># 分数</span></span><br><span class="line">                score = node.xpath(<span class="string">&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;</span>).get()</span><br><span class="line"></span><br><span class="line">                item = DbItem()</span><br><span class="line">                item[<span class="string">&quot;movie_name&quot;</span>] = movie_name</span><br><span class="line">                item[<span class="string">&quot;director&quot;</span>] = director</span><br><span class="line">                item[<span class="string">&quot;score&quot;</span>] = score</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 电影详情页</span></span><br><span class="line">                detail_url = node.xpath(<span class="string">&#x27;./div/a/@href&#x27;</span>).get()</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;<span class="string">&quot;info&quot;</span>:item&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送新一页的请求</span></span><br><span class="line">            <span class="comment"># 构造url</span></span><br><span class="line">            <span class="keyword">if</span> response.meta.get(<span class="string">&quot;num&quot;</span>):</span><br><span class="line">                self.page_num = response.meta.get(<span class="string">&#x27;num&#x27;</span>)</span><br><span class="line">            page_url = <span class="string">&quot;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&quot;</span>.<span class="built_in">format</span>(self.page_num*<span class="number">25</span>)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(page_url, callback=self.parse, meta=&#123;<span class="string">&quot;num&quot;</span>: self.page_num&#125;)</span><br><span class="line">            self.page_num +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.page_num ==<span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 详情页解析</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_detail</span>(<span class="params">self,response</span>):</span><br><span class="line">        item = DbItem()</span><br><span class="line">        info = response.meta.get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">        item.update(info)</span><br><span class="line">        description_list = response.xpath(<span class="string">&#x27;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#x27;</span>).getall()</span><br><span class="line">        description = <span class="string">&#x27;&#x27;</span>.join([des.strip() <span class="keyword">for</span> des <span class="keyword">in</span> description_list])</span><br><span class="line"></span><br><span class="line">        item[<span class="string">&quot;description&quot;</span>] = description</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></div><h6 id="Items文件"><a href="#Items文件" class="headerlink" title="Items文件"></a>Items文件</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DbItem</span>(scrapy.Item):</span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    movie_name = scrapy.Field()</span><br><span class="line">    director = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br><span class="line">    description = scrapy.Field()</span><br></pre></td></tr></table></figure></div><h6 id="Pipelines文件"><a href="#Pipelines文件" class="headerlink" title="Pipelines文件"></a>Pipelines文件</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DbPipeline</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.f = <span class="built_in">open</span>(<span class="string">&#x27;film.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        json_str = json.dumps(<span class="built_in">dict</span>(item), ensure_ascii=<span class="literal">False</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.f.write(json_str)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.f.close()</span><br></pre></td></tr></table></figure></div><h6 id="Settings文件"><a href="#Settings文件" class="headerlink" title="Settings文件"></a>Settings文件</h6><p>settings文件需要配置</p><ul><li><p>公共的调度器  SCHEDULER</p></li><li><p>公共的过滤器  DUPEFILTER_CLASS</p></li><li><p>公共存储区域  redis</p></li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">BOT_NAME = <span class="string">&#x27;db&#x27;</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">&#x27;db.spiders&#x27;</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">&#x27;db.spiders&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Override the default request headers:</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用调度将请求存储进redis</span></span><br><span class="line"><span class="comment"># 必须</span></span><br><span class="line">SCHEDULER = <span class="string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保所有spider通过redis共享相同的重复过滤。</span></span><br><span class="line"><span class="comment"># 必须</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#公共管道</span></span><br><span class="line">ITEM_PIPELINES  =  &#123;</span><br><span class="line">    <span class="string">&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="string">&#x27;db.pipelines.DbPipeline&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 指定连接到Redis时要使用的主机和端口。</span></span><br><span class="line"><span class="comment"># 必须</span></span><br><span class="line">REDIS_HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">REDIS_PORT = <span class="number">6379</span></span><br><span class="line"><span class="comment"># 不清理redis队列，允许暂停/恢复抓取。</span></span><br><span class="line"><span class="comment"># 可选  允许暂停,redis数据不丢失</span></span><br><span class="line">SCHEDULER_PERSIST = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志文件配置</span></span><br><span class="line"><span class="comment"># LOG_FILE=&quot;db_redis.log&quot;</span></span><br><span class="line">LOG_ENABLED=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">LOG_FORMAT=<span class="string">&#x27;%(asctime)s  [%(name)s] %(levelname)s: %(message)s&#x27;</span></span><br><span class="line">LOG_DATEFORMAT=<span class="string">&#x27;%Y&#x27;</span></span><br><span class="line"></span><br><span class="line">LOG_ENCODING=<span class="string">&quot;utf-8&quot;</span></span><br><span class="line">LOG_LEVEL=<span class="string">&quot;INFO&quot;</span></span><br></pre></td></tr></table></figure></div><h3 id="执行演示"><a href="#执行演示" class="headerlink" title="执行演示"></a>执行演示</h3><h4 id="爬虫执行"><a href="#爬虫执行" class="headerlink" title="爬虫执行"></a>爬虫执行</h4><p>可以发现爬虫1和爬虫2未有提交URL时进行了等待</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f6ccb84b-d743-4808-d3d7-43f76e432300/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/06dd7665-94c0-40d4-5c1f-299482eacc00/public"                      width = "500"                >  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p><code>TypeError: ExecutionEngine.crawl() got an unexpected keyword argument &#39;spider&#39;</code></p><p>Scrapy版本和scrapy-redis版本有概率不兼容，我的案例是修正Scrapy版本为2.8.0解决问题</p>    </div>  </div><h4 id="添加URL给Redis开启爬取"><a href="#添加URL给Redis开启爬取" class="headerlink" title="添加URL给Redis开启爬取"></a>添加URL给Redis开启爬取</h4><p>执行命令在Redis添加列表添加URL</p><p><code>LPUSH dbtest1:start_urls &quot;https://movie.douban.com/top250&quot;</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/06de15f7-f417-4391-da20-53457d9cef00/public"                      width = "500"                ><p>随后两个爬虫就会开始进行爬取即可</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3f8dbe81-e702-43c5-fbea-690e44e5b200/public"                      width = "500"                ><h2 id="Scrapy-Redis-源码解读"><a href="#Scrapy-Redis-源码解读" class="headerlink" title="Scrapy-Redis 源码解读"></a>Scrapy-Redis 源码解读</h2><h3 id="connection-py"><a href="#connection-py" class="headerlink" title="connection.py"></a>connection.py</h3><p>这个模块的作用是建立与Redis数据库的连接。它通常提供一个工厂方法，用于创建Redis连接对象，这使得Scrapy项目能够连接到Redis服务器并执行各种操作，如存储或检索数据。</p><h3 id="defaults-py"><a href="#defaults-py" class="headerlink" title="defaults.py"></a>defaults.py</h3><p>这里定义了Scrapy-Redis用到的一些默认设置。这可能包括默认的Redis URL、连接参数、队列名称等。这些常量和默认值对于确保Scrapy-Redis的标准行为至关重要。</p><h3 id="dupefilter-py"><a href="#dupefilter-py" class="headerlink" title="dupefilter.py"></a>dupefilter.py</h3><p>这个 <code>dupefilter.py</code> 源码是Scrapy-Redis扩展的一部分，专门用于处理请求去重。请求去重是网页爬虫中的一个关键步骤，用于确保不重复爬取相同的网页，从而提高效率和减少资源浪费。这个模块使用Redis作为存储后端来记录已经处理过的请求。</p><p><strong>类 <code>RFPDupeFilter</code></strong></p><p><code>RFPDupeFilter</code> 类继承自 Scrapy 的 <code>BaseDupeFilter</code>，是一个基于Redis的请求去重过滤器。</p><p><strong>初始化方法 <code>__init__</code></strong></p><ul><li><code>server</code>: 接收一个 Redis 实例，用于与Redis数据库通信。</li><li><code>key</code>: 指定在Redis中用于存储去重指纹（fingerprints）的键。</li><li><code>debug</code>: 一个布尔值，用于确定是否打印日志信息，用于调试。</li></ul><p><strong>类方法 <code>from_settings</code></strong></p><p>这个方法用于从Scrapy的设置中创建一个 <code>RFPDupeFilter</code> 实例。它读取相关配置并实例化一个连接到Redis的去重过滤器。</p><p><strong>类方法 <code>from_crawler</code></strong></p><p>这个方法从Scrapy的爬虫中创建 <code>RFPDupeFilter</code> 实例。它是 <code>from_settings</code> 的包装方法，提供了一个从 <code>Crawler</code> 对象获取设置的快捷方式。</p><p><strong>方法 <code>request_seen</code></strong></p><p>这个方法用于检查一个请求是否已经被看到（即之前已经处理过）。它使用请求的指纹（fingerprint），如果这个指纹已经存在于Redis中，就认为这个请求是重复的。</p><ul><li><code>request_fingerprint</code> 方法用于生成请求的指纹，通常基于请求的URL和其他特征。</li></ul><p><strong>方法 <code>close</code> 和 <code>clear</code></strong></p><ul><li><code>close</code> 方法在过滤器关闭时被调用，用于执行清理工作。</li><li><code>clear</code> 方法用于从Redis中删除所有的去重指纹数据。</li></ul><p><strong>方法 <code>log</code></strong></p><p>这个方法用于在启用调试模式时打印日志信息，记录被过滤掉的重复请求。</p><p><strong>整体工作流程</strong></p><ol><li>当Scrapy爬虫启动时，<code>RFPDupeFilter</code> 会被实例化，并与Redis建立连接。</li><li>对于每个发出的请求，<code>RFPDupeFilter</code> 会计算其指纹并检查这个指纹是否已经存储在Redis中。</li><li>如果指纹已存在，表明请求是重复的，将不会再次处理该请求。</li><li>所有的指纹都存储在Redis中，这允许在分布式爬虫环境下跨多个爬虫实例共享去重信息。</li></ol><h3 id="picklecompat-py"><a href="#picklecompat-py" class="headerlink" title="picklecompat.py"></a>picklecompat.py</h3><p>这个模块是用于数据序列化和反序列化的。虽然您提到它类似于JSON转换，但它实际上更多使用的是pickle库，这是Python中一个常用的序列化方法。它允许复杂的数据结构如Python对象被转换为可以存储在Redis中的形式。</p><h3 id="pipelines-py"><a href="#pipelines-py" class="headerlink" title="pipelines.py"></a>pipelines.py</h3><p>在Scrapy框架中，pipelines用于处理爬取的数据。Scrapy-Redis的这一模块扩展了这个概念，允许将爬取的数据存储在Redis数据库中。这对于分布式爬虫来说特别重要，因为它允许多个爬虫实例共享和存储数据。</p><h3 id="queue-py"><a href="#queue-py" class="headerlink" title="queue.py"></a>queue.py</h3><p>这个模块维护了请求队列。在Scrapy-Redis中，通常有几种类型的队列，例如FIFO（先进先出）、LIFO（后进先出）等，用于控制请求的处理顺序。通过Redis来管理这些队列，可以实现跨多个爬虫实例的请求共享。</p><h3 id="scheduler-py"><a href="#scheduler-py" class="headerlink" title="scheduler.py"></a>scheduler.py</h3><p>这是Scrapy-Redis中的一个核心组件。调度器负责决定何时以及如何发送请求。在Scrapy-Redis中，这通常涉及从Redis队列中获取请求，并在分布式环境下有效地管理这些请求。</p><p><strong>类 <code>Scheduler</code></strong></p><p><code>Scheduler</code> 类是一个基于 Redis 的调度器。</p><p><strong>初始化方法 <code>__init__</code></strong></p><ul><li><code>server</code>: Redis 服务器实例，用于和 Redis 数据库进行交互。</li><li><code>persist</code>: 表示在关闭时是否保留请求数据。如果为 <code>False</code>，则在关闭时清空队列。</li><li><code>flush_on_start</code>: 表示在启动时是否清空 Redis 队列。</li><li><code>queue_key</code>: 请求队列在 Redis 中的键名。</li><li><code>queue_cls</code>: 请求队列的类的路径，用于动态加载队列类。</li><li><code>dupefilter_key</code>: 去重过滤器在 Redis 中的键名。</li><li><code>dupefilter_cls</code>: 去重过滤器类的路径，用于动态加载去重类。</li><li><code>idle_before_close</code>: 在关闭前等待的空闲时间，如果在这段时间内没有接收到消息，则关闭调度器。</li><li><code>serializer</code>: 用于序列化请求的类或模块。</li></ul><p><strong>类方法 <code>from_settings</code></strong></p><p>这个方法从 Scrapy 的设置中创建一个 <code>Scheduler</code> 实例。它读取相关配置并基于这些配置创建一个实例。</p><p><strong>类方法 <code>from_crawler</code></strong></p><p>这个方法从 Scrapy 的爬虫对象中创建一个 <code>Scheduler</code> 实例。它是 <code>from_settings</code> 的包装器，提供从爬虫对象获取设置的方式。</p><p><strong>方法 <code>open</code></strong></p><p>在爬虫开启时调用，用于初始化请求队列和去重过滤器。</p><p><strong>方法 <code>close</code></strong></p><p>在爬虫关闭时调用，根据 <code>persist</code> 参数决定是否清空队列。</p><p><strong>方法 <code>flush</code></strong></p><p>清空队列和去重过滤器中的数据。</p><p><strong>方法 <code>enqueue_request</code></strong></p><p>将新的请求加入队列。如果请求不需要过滤且之前没有见过，那么它将被加入队列。</p><p><strong>方法 <code>next_request</code></strong></p><p>从队列中弹出下一个请求。</p><p><strong>方法 <code>has_pending_requests</code></strong></p><p>检查是否还有等待处理的请求。</p><p><strong>工作流程</strong></p><ol><li>当爬虫启动时，<code>Scheduler</code> 会被初始化。它会创建请求队列和去重过滤器。</li><li>如果设置了 <code>flush_on_start</code>，则在启动时清空 Redis 队列。</li><li>在爬虫运行期间，所有新的请求都会通过 <code>enqueue_request</code> 方法加入队列。如果请求被去重过滤器认为是重复的，它将不会被加入队列。</li><li><code>next_request</code> 方法用于获取下一个要处理的请求，这个过程可能会根据 <code>idle_before_close</code> 设置等待一段时间。</li><li>当爬虫关闭时，根据 <code>persist</code> 设置决定是否清空 Redis 队列。</li></ol><h2 id="通过扩展关闭分布式爬虫"><a href="#通过扩展关闭分布式爬虫" class="headerlink" title="通过扩展关闭分布式爬虫"></a>通过扩展关闭分布式爬虫</h2><p>在Scrapy和Scrapy-Redis中，利用扩展（Extensions）来智能地关闭分布式爬虫是一种有效的策略。这种方法主要依赖于Scrapy的信号系统和对 <code>spider_idle</code> 信号的处理。</p><h3 id="Scrapy-Redis-的-spider-idle-方法"><a href="#Scrapy-Redis-的-spider-idle-方法" class="headerlink" title="Scrapy-Redis 的 spider_idle 方法"></a>Scrapy-Redis 的 spider_idle 方法</h3><p>在Scrapy-Redis中，当一个爬虫耗尽其内部队列中的所有请求时，Scrapy的信号系统会触发 <code>spider_idle</code> 信号。Scrapy-Redis通过重写 <code>spider_idle</code> 方法，并在方法中主动从Redis队列中调度新的请求。由于这个方法抛出了 <code>DontCloseSpider</code> 异常，所以即使没有剩余的本地请求，爬虫也不会停止，而是会继续等待新的请求从Redis中被调度。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The idle signal is called when the spider has no requests left,that&#x27;s when we will schedule new requests from redis queue</span></span><br><span class="line">爬虫程序没有剩余请求时,空闲信号就会被调用，也就是我们将从redis队列调度新请求的时候</span><br><span class="line">crawler.signals.connect(self.spider_idle, signal=signals.spider_idle)</span><br><span class="line">意思就非常明显了,空闲的信号被调用---&gt; spide_idle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spider_idle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Schedules a request if available, otherwise waits.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># <span class="doctag">XXX:</span> Handle a sentinel to close the spider.</span></span><br><span class="line">        self.schedule_next_requests()</span><br><span class="line">        <span class="keyword">raise</span> DontCloseSpider</span><br></pre></td></tr></table></figure></div><p>因为抛出了<code>DontCloseSpider</code>异常，所以当触发spider_idle信号的时候整个爬虫也不会停止。</p><h3 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h3><p>这个自定义扩展<code>RedisSpiderSmartClosedExtensions</code>的目的是在某些条件下智能地关闭爬虫，而不是无限期地等待新的请求。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals <span class="comment"># 引入信号</span></span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> NotConfigured <span class="comment"># 在settings 设置是否开启这个拓展</span></span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResdisSpiderSmartClosedExtensions</span>:  <span class="comment"># 高内聚 低耦合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, idle_number, crawler</span>):</span><br><span class="line">        <span class="comment"># 数量值</span></span><br><span class="line">        self.idle_number = idle_number</span><br><span class="line">        <span class="comment"># 这个就是settings里面的一些配置项</span></span><br><span class="line">        self.crawler = crawler</span><br><span class="line">        <span class="comment"># 专门记录触发信号的时间</span></span><br><span class="line">        self.idle_list = []</span><br><span class="line">        <span class="comment"># 记录次数,进行对比</span></span><br><span class="line">        self.idle_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_crawler</span>(<span class="params">cls, crawler</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> crawler.settings.getbool(<span class="string">&#x27;MYEXT_ENABLED&#x27;</span>):</span><br><span class="line">            <span class="keyword">raise</span> NotConfigured</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断一下 你是不是一个redis爬虫</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">&#x27;redis_key&#x27;</span> <span class="keyword">in</span> crawler.spidercls.__dict__.keys():</span><br><span class="line">            <span class="keyword">raise</span> NotConfigured(<span class="string">&#x27;Only Support Redis Version&#x27;</span>)</span><br><span class="line">        idle_number = crawler.settings.getint(<span class="string">&#x27;IDLE_NUMBER&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">        ext = cls(idle_number, crawler)</span><br><span class="line"></span><br><span class="line">        crawler.signals.connect(ext.spider_idle, signal=signals.spider_idle)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spider_idle</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.idle_count += <span class="number">1</span></span><br><span class="line">        self.idle_list.append(time.time())</span><br><span class="line">        idle_list_len = <span class="built_in">len</span>(self.idle_list)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 长度大于二就证明已经空转很多次了,  key有存在就证明你还没有抓完</span></span><br><span class="line">        <span class="keyword">if</span> idle_list_len &gt; <span class="number">2</span> <span class="keyword">and</span> spider.server.exists(spider.redis_key):</span><br><span class="line">            self.idle_list = [self.idle_list[-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">elif</span> idle_list_len &gt; self.idle_number:</span><br><span class="line">            logger.info(<span class="string">&#x27;\n continued idle number exceed &#123;&#125; Times&#x27;</span></span><br><span class="line">                        <span class="string">&#x27;\n meet the idle shutdown conditions, will close the reptile operation&#x27;</span></span><br><span class="line">                        <span class="string">&#x27;\n idle start time: &#123;&#125;,close spider time: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.idle_number,</span><br><span class="line">                                                                              self.idle_list[<span class="number">0</span>],</span><br><span class="line">                                                                              self.idle_list[-<span class="number">1</span>]))</span><br><span class="line">            self.crawler.engine.close_spider(spider, <span class="string">&#x27;closespider_pagecount&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p><strong>初始化方法 <code>__init__</code></strong></p><ul><li><code>idle_number</code>: 表示允许爬虫空闲的次数（没有新请求的情况）。</li><li><code>crawler</code>: Scrapy的爬虫对象。</li><li><code>idle_list</code>: 用于记录每次空闲时的时间戳。</li><li><code>idle_count</code>: 记录空闲发生的次数。</li></ul><p><strong>方法 <code>from_crawler</code></strong></p><p>这个类方法用于从爬虫的配置中创建扩展实例，并连接到Scrapy的信号。</p><p><strong>方法 <code>spider_opened</code> 和 <code>spider_closed</code></strong></p><ul><li><code>spider_opened</code>: 在爬虫开启时调用，用于记录初始信息。</li><li><code>spider_closed</code>: 在爬虫关闭时调用，用于记录关闭信息。</li></ul><p><strong>方法 <code>spider_idle</code></strong></p><p>这是关键方法。每次爬虫空闲时，都会增加 <code>idle_count</code> 的值，并记录当前时间。如果连续空闲次数超过设定的 <code>idle_number</code>，并且Redis队列中没有新的请求，那么爬虫将被关闭。</p><p><strong><code>settings.py</code> 中的相关设置</strong></p><ul><li><code>EXTENSIONS</code>: 在这里配置自定义的扩展类。</li><li><code>MYEXT_ENABLED</code>: 用于启用或禁用这个扩展。</li><li><code>IDLE_NUMBER</code>: 设置允许的最大空闲次数。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTENSIONS = &#123;</span><br><span class="line">    <span class="comment"># &#x27;scrapy.extensions.telnet.TelnetConsole&#x27;: None,</span></span><br><span class="line">    <span class="string">&#x27;db.extensions.RedisSpiderSmartIdleClosedExensions&#x27;</span>: <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line">MYEXT_ENABLED = <span class="literal">True</span></span><br><span class="line">IDLE_NUMBER = <span class="number">5</span></span><br></pre></td></tr></table></figure></div><p><strong>工作流程</strong></p><ol><li>当爬虫开始运行时，<code>RedisSpiderSmartClosedExtensions</code> 被初始化，并连接到相应的Scrapy信号。</li><li>在爬虫运行期间，每当它空闲时（没有新的请求），<code>spider_idle</code> 方法会被触发。</li><li>如果连续空闲次数超过 <code>IDLE_NUMBER</code> 设置的阈值，并且Redis中没有新的请求，那么这个扩展会指示Scrapy关闭爬虫。</li><li>这种方法使得爬虫在完成其任务后不会无限期地等待，从而有效管理资源。</li></ol><h2 id="Scrapyd"><a href="#Scrapyd" class="headerlink" title="Scrapyd"></a>Scrapyd</h2><p>Scrapyd是一个用于部署和运行Scrapy爬虫的应用，它提供了一个JSON API，通过该API可以实现爬虫的部署、启动、停止等操作。</p><h3 id="安装-Scrapyd-和-Scrapyd-client"><a href="#安装-Scrapyd-和-Scrapyd-client" class="headerlink" title="安装 Scrapyd 和 Scrapyd-client"></a>安装 Scrapyd 和 Scrapyd-client</h3><ol><li><p><strong>安装 Scrapyd</strong></p><p>使用命令 <code>pip install scrapyd</code> 来安装 Scrapyd。</p><p><strong>验证：</strong> 输入 <code>scrapyd</code> 命令。如果能够访问 <code>http://localhost:6800/</code> 页面，表示安装成功。</p></li><li><p><strong>安装 Scrapyd-client</strong></p><p>使用命令 <code>pip install scrapyd-client</code> 来安装 Scrapyd-client，这是一个用于与Scrapyd交互的命令行工具。</p><p><strong>验证：</strong> 在Scrapy项目目录下输入 <code>scrapyd-deploy</code>，如果出现提示 <code>Unknown target: default</code>，表示安装成功。</p></li></ol><h3 id="配置-Scrapy-cfg"><a href="#配置-Scrapy-cfg" class="headerlink" title="配置 Scrapy.cfg"></a>配置 Scrapy.cfg</h3><p>在 <code>scrapy.cfg</code> 文件中，配置部署信息。例如：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[deploy:douban]  <span class="comment"># 部署名称，可自定义</span></span><br><span class="line">url = http://localhost:<span class="number">6800</span>/  <span class="comment"># Scrapyd服务器地址</span></span><br><span class="line">project = db250  <span class="comment"># 项目名称</span></span><br><span class="line">username = xxx  <span class="comment"># 服务器访问用户名（可选）</span></span><br><span class="line">password = xxx  <span class="comment"># 服务器访问密码（可选）</span></span><br></pre></td></tr></table></figure></div><p><strong>验证：</strong> 使用命令 <code>scrapyd-deploy -l</code> 可以查看设置的部署名称和URL。</p><h3 id="执行打包命令"><a href="#执行打包命令" class="headerlink" title="执行打包命令"></a>执行打包命令</h3><p>在包含 <code>scrapy.cfg</code> 的目录下执行部署命令：</p><p><code>scrapyd-deploy [部署名称] -p [项目名称]</code></p><p>例如：</p><p><code>scrapyd-deploy douban -p db250</code></p><p>成功部署后，终端会显示类似如下信息：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deploying to project <span class="string">&quot;db250&quot;</span> <span class="keyword">in</span> http://localhost:<span class="number">6800</span>/addversion.json</span><br><span class="line">Server response (<span class="number">200</span>):</span><br><span class="line">&#123;<span class="string">&quot;node_name&quot;</span>: <span class="string">&quot;YNRBYA8RP4AT92A&quot;</span>, <span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;project&quot;</span>: <span class="string">&quot;db250&quot;</span>, <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1595508145&quot;</span>, <span class="string">&quot;spiders&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></div><h3 id="启动爬虫"><a href="#启动爬虫" class="headerlink" title="启动爬虫"></a>启动爬虫</h3><p>使用 curl 命令启动爬虫：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:6800/schedule.json -d project=[项目名称] -d spider=[爬虫名称]</span><br></pre></td></tr></table></figure></div><p>成功启动后，会返回包含 <code>jobid</code> 的响应，如：</p><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;node_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YNRBYA8RP4AT92A&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;jobid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;98785578cce211eab46598fa9b72ce54&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><h3 id="关闭爬虫"><a href="#关闭爬虫" class="headerlink" title="关闭爬虫"></a>关闭爬虫</h3><p>使用 curl 命令关闭爬虫：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:6800/cancel.json -d project=[项目名称] -d job=[jobid]</span><br></pre></td></tr></table></figure></div><h3 id="列出项目"><a href="#列出项目" class="headerlink" title="列出项目"></a>列出项目</h3><p>列出Scrapyd服务器上的所有项目：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:6800/listprojects.json</span><br></pre></td></tr></table></figure></div><h3 id="删除项目"><a href="#删除项目" class="headerlink" title="删除项目"></a>删除项目</h3><p>从Scrapyd服务器上删除指定项目：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:6800/delproject.json -d project=[项目名称]</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">Scrapy结合Redis进行分布式爬取</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Scrapy" scheme="https://www.yiuhangblog.com/tags/Scrapy/"/>
    
    <category term="Redis" scheme="https://www.yiuhangblog.com/tags/Redis/"/>
    
    <category term="分布式" scheme="https://www.yiuhangblog.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="网页抓取" scheme="https://www.yiuhangblog.com/tags/%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96/"/>
    
    <category term="Scrapyd" scheme="https://www.yiuhangblog.com/tags/Scrapyd/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy</title>
    <link href="https://www.yiuhangblog.com/2021/10/28/20211128scrapy/"/>
    <id>https://www.yiuhangblog.com/2021/10/28/20211128scrapy/</id>
    <published>2021-10-28T05:12:54.000Z</published>
    <updated>2024-02-28T10:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Scrapy是一个用Python编写的高效且结构化的网页抓取框架，广泛应用于数据挖掘、网站监测和自动化测试。它的设计初衷是为了方便用户爬取网站数据和提取结构化数据，但它的用途不仅限于网页抓取，还包括处理API返回的数据（如Amazon Associates Web Services）或进行更广泛的网络爬取任务。</p><p>Scrapy的一个关键特性是它使用了Twisted异步网络库来处理网络通信。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <ol><li><strong>异步编程</strong>:<ul><li>在传统的同步编程模型中，任务按顺序一个接一个地执行。如果一个任务需要等待（例如，等待网络响应），程序将在此期间停止执行后续任务。</li><li>异步编程允许程序在等待一个任务完成的同时继续执行其他任务。这种方式非常适合处理I&#x2F;O密集型任务，比如网络请求，因为程序不需要在每个请求完成时都暂停执行。</li></ul></li><li><strong>Twisted异步网络库</strong>:<ul><li>Twisted是一个事件驱动的网络编程框架，专为Python设计。它支持多种协议，可以用于创建高性能的网络服务器和客户端。</li><li>在Scrapy中，Twisted用于处理网络请求。当Scrapy发出一个请求并等待服务器响应时，它不会阻塞整个爬虫的进程。相反，Scrapy可以利用这段时间执行其他任务，如处理已经收到的数据或发出更多的网络请求。</li></ul></li></ol>    </div>  </div><p><strong>Scrapy中的应用</strong>:</p><ul><li>Scrapy利用Twisted的异步特性来提高爬虫的效率。它能够同时处理多个网络请求，而不会因为单个请求的延迟而阻塞整个爬虫。</li><li>这使得Scrapy非常适合执行大规模的网络抓取任务，因为它可以有效地利用网络资源和处理能力，同时维持高效率的数据收集。</li></ul><p><strong>使用原因：</strong></p><p>1.为了更利于我们将精力集中在请求与解析上<br>2.企业级的要求</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A(找到目标数据) --&gt; B(分析请求流程)</span><br><span class="line">    B --&gt; C(构造http请求)</span><br><span class="line">    C --&gt; D(提取数据)</span><br><span class="line">    D --&gt; E(数据持久化)</span><br></pre></td></tr></table></figure></div><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f796f07e-1ef6-45ba-7001-bcfe018f7300/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6abf6e1a-af6c-433d-6c3b-2d28dd132700/public"                      width = "500"                ><h3 id="Scrapy框架的体系结构"><a href="#Scrapy框架的体系结构" class="headerlink" title="Scrapy框架的体系结构"></a>Scrapy框架的体系结构</h3><p>Scrapy框架的体系结构由几个重要组件组成，这些组件协同工作，实现了从发送请求到提取数据再到存储数据的整个流程：</p><ol><li><strong>引擎（Engine）</strong>: Scrapy引擎是框架的核心，负责控制数据流在各组件之间的流动，触发事件。</li><li><strong>调度器（Scheduler）</strong>: 负责接收引擎发送的请求，并将它们加入队列中。在引擎请求新请求时，调度器发送下一个要抓取的请求给引擎。</li><li><strong>下载器（Downloader）</strong>: 负责从Internet上下载网页内容，并将其封装为响应对象，然后返回给引擎。</li><li><strong>蜘蛛（Spiders）</strong>: 是用户编写用来解析响应并从中提取数据（提取的项目）或额外的跟进URL的类。</li><li><strong>项目管道（Item Pipeline）</strong>: 负责处理由蜘蛛提取出来的项目，通常包括清洗、验证和存储等。</li><li><strong>下载器中间件（Downloader Middlewares）</strong>: 位于引擎和下载器之间，处理引擎和下载器之间的请求和响应。</li><li><strong>蜘蛛中间件（Spider Middlewares）</strong>: 位于引擎和蜘蛛之间，处理蜘蛛的输入（响应）和输出（项目和新的请求）。</li></ol>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>Downloader Middleware（下载中间件）</strong></p><p>这些钩子允许处理、修改和自定义发往下载器的请求以及从下载器返回的响应。下载中间件在Scrapy的请求&#x2F;响应处理流程中提供了几个关键的扩展点。例如，可以使用它来添加HTTP头部到请求中，或者处理从网站返回的HTTP响应。这些中间件的用途包括：</p><ul><li>在请求发送到下载器之前修改或过滤请求。</li><li>在响应发送到爬虫之前处理或修改响应。</li><li>直接生成新的请求，而不是处理当前的响应。</li><li>选择性地放弃某些请求</li></ul><p><strong>Spider Middleware（爬虫中间件）</strong></p><p>爬虫中间件则是处理传入响应、传出项目（item）和请求的钩子。这些中间件在Scrapy的数据处理流程中处于核心位置，允许用户对爬虫的输入和输出进行细致的控制。使用爬虫中间件，可以：</p><ul><li>在爬虫处理回调之后处理请求或项目。</li><li>修改或过滤开始请求（由 <code>start_requests</code> 方法生成的请求）。</li><li>处理由于响应内容引发的异常，根据响应内容调用错误回调（errback）。</li></ul>    </div>  </div><h3 id="数据流过程"><a href="#数据流过程" class="headerlink" title="数据流过程"></a>数据流过程</h3><ol><li><strong>启动过程</strong>:<ul><li>Scrapy开始运行，初始化了调度器、下载器以及蜘蛛。</li></ul></li><li><strong>爬取过程</strong>:<ul><li>引擎向蜘蛛请求第一个要爬取的URL。</li><li>蜘蛛返回第一个要爬取的请求给引擎。</li><li>引擎将请求发送到调度器，并请求下一个URL。</li><li>调度器返回下一个要爬取的请求给引擎。</li></ul></li><li><strong>下载过程</strong>:<ul><li>引擎从调度器中取出请求，通过下载器中间件发送到下载器。</li><li>下载器处理请求，返回响应给引擎。</li><li>引擎收到响应后，通过蜘蛛中间件发送给相应的蜘蛛处理。</li></ul></li><li><strong>解析和提取数据</strong>:<ul><li>蜘蛛处理响应，提取数据并生成新的请求，返回给引擎。</li><li>引擎将提取的数据发送到项目管道，并将新的请求发送到调度器。</li><li>项目管道处理提取出的数据。</li></ul></li><li><strong>循环处理</strong>:<ul><li>以上过程在整个爬取过程中不断重复，直到调度器中没有更多的请求。</li></ul></li><li><strong>关闭过程</strong>:<ul><li>当所有预定的URL都被爬取，且调度器中没有更多的请求时，Scrapy关闭，爬取过程结束。</li></ul></li></ol><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><h4 id="项目命令"><a href="#项目命令" class="headerlink" title="项目命令"></a>项目命令</h4><ol><li><strong>创建项目</strong>:<ul><li>使用命令 <code>scrapy startproject &lt;project_name&gt; [project_dir]</code> 创建新项目。其中 <code>&lt;project_name&gt;</code> 是必填项，表示项目名称；<code>[project_dir]</code> 是可选项，表示项目目录。</li><li>例如：<code>scrapy startproject db</code> 会创建一个名为 ‘db’ 的Scrapy项目。</li></ul></li><li><strong>创建第一个爬虫</strong>:<ul><li>首先，需要进入到项目目录中，使用 <code>cd &lt;project_name&gt;</code> 命令。</li><li>然后，使用 <code>scrapy genspider &lt;name&gt; &lt;domain&gt;</code> 创建一个新的爬虫。这里 <code>&lt;name&gt;</code> 是爬虫的名称，而 <code>&lt;domain&gt;</code> 是爬虫将要爬取的域名。</li><li>例如：<code>scrapy genspider example example.com</code> 会在项目的 <code>spiders</code> 目录下创建一个名为 ‘example’ 的爬虫，它针对的是 ‘example.com’ 网站。</li></ul></li><li><strong>运行项目</strong>:<ul><li>使用命令 <code>scrapy crawl &lt;spider_name&gt;</code> 来运行爬虫。这里 <code>&lt;spider_name&gt;</code> 是在创建爬虫时指定的名称。</li><li>例如：<code>scrapy crawl example</code> 会运行名为 ‘example’ 的爬虫。</li></ul></li><li><strong>设置配置文件</strong>:<ul><li>在 <code>settings.py</code> 文件中，可以配置各种参数，比如 <code>ROBOTSTXT_OBEY</code>（是否遵守网站的robots.txt规则）和 <code>DEFAULT_REQUEST_HEADERS</code>（默认的HTTP头部）。</li></ul></li></ol>  <div class="note-large red">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-bug"></i><p>警告</p>    </div>    <div class="notel-content">      <ol><li><p>由于可以设置多个爬虫，且通过<code>name</code>进行管理，因此<code>scrapy genspider &lt;name&gt; &lt;domain&gt;</code>创建新爬虫的时候的时候<code>name</code>是不能重复的，会报错</p></li><li><p>无数据可以查看是否限制了域名</p><p><code>dbtest1.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1Spider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;test1&quot;</span> <span class="comment">#爬虫名</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;movie.douban.com&quot;</span>] <span class="comment">#限制域名，可以添加多个域名（列表）</span></span><br><span class="line">    start_urls = [<span class="string">&quot;https://movie.douban.com/top250&quot;</span>] <span class="comment">#初始页面，第一个抓取的页面，放在产生请求的地方也就是在爬虫部件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>): <span class="comment">#response就是上面start_urls的响应</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div></li></ol>    </div>  </div><h4 id="项目文件介绍"><a href="#项目文件介绍" class="headerlink" title="项目文件介绍"></a>项目文件介绍</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5d754191-0f99-42c0-e839-335887c57b00/public"                      width = "500"                ><h2 id="爬取豆瓣电影"><a href="#爬取豆瓣电影" class="headerlink" title="爬取豆瓣电影"></a>爬取豆瓣电影</h2><h3 id="项目目的和要求"><a href="#项目目的和要求" class="headerlink" title="项目目的和要求"></a>项目目的和要求</h3><p>目标是创建一个 Scrapy 爬虫来爬取豆瓣电影的前 250 个电影信息。这些信息包括：</p><ol><li>电影名称</li><li>导演和演员信息</li><li>电影评分</li></ol><p>需要将这些信息保存到本地，同时通过 Scrapy 的管道（Pipelines）机制进行持久化。</p><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><h4 id="创建-Spider-类"><a href="#创建-Spider-类" class="headerlink" title="创建 Spider 类"></a>创建 Spider 类</h4><p>首先需要创建一个名为 <code>Test1Spider</code> 的类，该类继承自 <code>scrapy.Spider</code>。在这个类中，定义以下属性和方法：</p><ul><li><code>name</code>: 爬虫的唯一标识名</li><li><code>start_urls</code>: 包含开始爬取的 URL 列表</li><li><code>parse(self, response)</code>: 是爬虫的核心方法，用于处理响应并返回提取的数据或新的请求。</li></ul><p>创建命令示例：</p><p><code>scrapy genspider dbtest1 movie.douban.com</code></p><p>这将在 <code>spiders</code> 目录下生成 <code>dbtest1.py</code> 文件。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/70cfa294-f9bd-4895-16f8-e46a7c5b6f00/public"                      width = "500"                ><h4 id="解析响应（Parsing-Response）"><a href="#解析响应（Parsing-Response）" class="headerlink" title="解析响应（Parsing Response）"></a>解析响应（Parsing Response）</h4><p> 在 <code>parse</code> 方法中，使用 <code>response</code> 对象进行页面内容的解析。可以利用 <code>xpath</code> 或 <code>css</code> 选择器提取所需的数据。</p><ol><li><p>首先分析该页面结构：</p><p>假设要获取标题，导演和分数等信息，通过分析可以发现<code>class=&quot;info&quot;</code>即可包含所有得信息</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5d53dadd-b77e-4703-3fd4-2d1d423b3c00/public"                      width = "500"                ><p>因此修改<code>response</code>直接使用<code>xpath</code>语法</p><p><code>dbtest1.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dbtest1Spider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;dbtest1&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;movie.douban.com&quot;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;https://movie.douban.com/top250&quot;</span>] <span class="comment">#修改为开始爬取的页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 这个地方可以直接使用response 就可以了，response对象里面就已经绑定了lxml的一些方法</span></span><br><span class="line">        node_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li></ol><h4 id="调试前置"><a href="#调试前置" class="headerlink" title="调试前置"></a>调试前置</h4><p>可以在同目录下添加调试文件<code>db_debug.py</code>，方便对爬虫文件进行断点调试</p><p><code>db_debug.py</code>:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.cmdline <span class="keyword">import</span> execute</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">execute([<span class="string">&#x27;scrapy&#x27;</span>, <span class="string">&#x27;crawl&#x27;</span>, <span class="string">&#x27;dbtest1&#x27;</span>]) <span class="comment">#执行命令</span></span><br></pre></td></tr></table></figure></div><p>通过调试可以发现传输了25行数据</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ddee2469-c831-46e8-fda1-e27ac9400d00/public"                      width = "500"                ><h4 id="清洗数据"><a href="#清洗数据" class="headerlink" title="清洗数据"></a>清洗数据</h4><p>对拿到的<code>info</code>标签进行解析，利用循环进行即可</p><p>首先查看标题标签</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7c434622-9bb1-4125-9746-56a18b039a00/public"                      width = "500"                ><p>然后通过其结构利用xpath锁定其位置</p><p><code>dbtest1.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dbtest1Spider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;dbtest1&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;movie.douban.com&quot;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;https://movie.douban.com/top250&quot;</span>] <span class="comment">#修改为开始爬取的页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 这个地方可以直接使用response 就可以了，response对象里面就已经绑定了lxml的一些方法</span></span><br><span class="line">        node_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node_list: <span class="comment">#万一没有数据那么就不执行避免报错</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">                <span class="comment"># 标题</span></span><br><span class="line">                move_title = node.xpath(<span class="string">&#x27;./div/a/span/text()&#x27;</span>).get()</span><br><span class="line">                <span class="comment"># 工作人员</span></span><br><span class="line">                employee = node.xpath(<span class="string">&#x27;./div/p/text()&#x27;</span>).get()</span><br><span class="line">                <span class="comment"># 评分</span></span><br><span class="line">                score = node.xpath(<span class="string">&#x27;./span[@class=&quot;rating_num&quot;]/text()&#x27;</span>).get()</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>在XPath中，<code>./</code>和<code>//</code>是两种不同的路径选择符，它们用于指定当前节点的相对路径。理解它们之间的差异对于正确地从HTML文档中提取数据是很重要的。</p><ol><li><strong><code>./</code> - 当前节点下的直接子节点</strong>:<ul><li><code>./</code>用于选择当前节点的直接子节点。</li><li>当使用<code>./</code>时，它会限制搜索范围到直接下级的元素。</li><li>在例子中，<code>./div</code>意味着选择当前节点（在这里是每个<code>div[@class=&quot;info&quot;]</code>）的直接子<code>div</code>元素。</li></ul></li><li><strong><code>//</code> - 文档中任何位置的节点</strong>:<ul><li><code>//</code>用于选择文档中任何位置的节点，而不考虑它们在文档中的位置。</li><li>使用<code>//</code>时，它会从整个文档中搜索符合条件的节点，而不仅限于当前节点的子节点。</li><li>在例子中，如果使用<code>//div</code>，它将会查找整个文档中所有的<code>div</code>元素，而不仅仅是<code>div[@class=&quot;info&quot;]</code>下的<code>div</code>元素。</li></ul></li></ol><p>使用了<code>./div</code>，这意味着想要选择每个<code>div[@class=&quot;info&quot;]</code>元素的直接子<code>div</code>元素。这是一种更精确的选择方式，确保只选取特定父元素下的子元素，避免从整个文档中获取不相关的<code>div</code>。</p>    </div>  </div><h5 id="调试1"><a href="#调试1" class="headerlink" title="调试1"></a>调试1</h5><p>断点调试后发现其获取的是对象，这是因为在Scrapy框架中，使用<code>.xpath()</code>方法返回的是一个<code>SelectorList</code>对象，而不是直接返回数据。<code>SelectorList</code>是Scrapy中的一个特殊类型，用于表示一组通过XPath选择器找到的元素。</p><ol><li><strong><code>SelectorList</code> 对象</strong>:<ul><li>当调用 <code>.xpath()</code> 方法时，返回的是一个 <code>SelectorList</code> 对象，而不是实际的数据。</li><li><code>SelectorList</code> 是一个包含多个 <code>Selector</code> 对象的列表。每个 <code>Selector</code> 对象代表一个通过XPath表达式匹配到的节点。</li></ul></li><li><strong>使用 <code>.get()</code> 方法提取数据</strong>:<ul><li>为了从 <code>Selector</code> 或 <code>SelectorList</code> 对象中提取数据，需要使用 <code>.get()</code> 方法（在早期版本的Scrapy中，这个方法叫做 <code>.extract_first()</code>）。</li><li><code>.get()</code> 方法从 <code>SelectorList</code> 中提取第一个匹配的元素的数据。如果没有找到匹配的元素，它将返回 <code>None</code>。</li><li>如果想要提取所有匹配的元素，可以使用 <code>.getall()</code> 方法（旧版本中对应 <code>.extract()</code>）。</li></ul></li><li><strong>为什么不直接返回数据</strong>:<ul><li>这种设计允许在决定如何处理匹配到的元素之前先检查它们。例如，可以检查 <code>SelectorList</code> 是否为空，或者提取它包含的所有元素。</li><li>它还提供了更大的灵活性，例如先对匹配到的元素进行进一步的选择或应用额外的XPath表达式。</li></ul></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a1deee4e-4d48-4c82-e2e1-8a1d4880d800/public"                      width = "500"                ><p>因此，要从中提取文本数据，需要调用 <code>.get()</code> 方法。</p><h5 id="调试2"><a href="#调试2" class="headerlink" title="调试2"></a>调试2</h5><p>随后继续调试可以发现工作人员部分，带有额外空白字符</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c82af201-f954-438c-1ee6-7efb40e80a00/public"                      width = "500"                ><p>而使用 <code>.strip()</code> 方法在处理从网页提取的文本数据时是非常常见且有用的，特别是当文本包含了不必要的空白字符（如空格、制表符、换行符等）时。<code>.strip()</code> 方法的作用是移除字符串两端的空白字符，使得提取的数据更加整洁和一致。</p><p>原因和原理：</p><ol><li><strong>移除多余空白</strong>:<ul><li>网页中的文本经常包含了在HTML代码中用于格式化的额外空白字符。这些字符在网页上看不出来，但在提取文本数据时会被包含进来。</li><li><code>.strip()</code> 方法用于移除这些不需要的空白字符，如前后的空格和换行符，这对于清洁数据和后续处理非常有帮助。</li></ul></li><li><strong>格式化和一致性</strong>:<ul><li>使用 <code>.strip()</code> 可以确保数据的格式一致，无论原始HTML中的格式如何。</li><li>它有助于减少后续处理数据时的麻烦，特别是在比较、存储或展示数据时。</li></ul></li><li><strong>使用方法</strong>:<ul><li>在Python中，<code>.strip()</code> 方法无需任何参数即可移除字符串两端的空白字符。</li><li>如果想要移除其他特定字符，也可以传递一个字符串作为参数给 <code>.strip()</code>，它将移除字符串两端的任何包含在该参数中的字符。</li></ul></li></ol><p>这样，<code>employee</code> 将不再包含字符串开头和结尾的空格或换行符，使得数据更加整洁和便于处理。</p><h5 id="调试3"><a href="#调试3" class="headerlink" title="调试3"></a>调试3</h5><p>最后对分数进行调试，发现没有返回数据，而这是因为搜索节点的范围和深度的缘故造成的</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/89f31df7-e603-41eb-5464-8c5efe093300/public"                      width = "500"                ><ul><li>当使用 <code>./span[@class=&quot;rating_num&quot;]/text()</code> ：<ul><li>这里的 <code>./</code> 将会导致XPath表达式只在当前处理节点的直接子节点中进行搜索。如果当前处理节点是 <code>div</code> 元素的父节点，那么 <code>./div[@class=&quot;star&quot;]</code> 将会选中直接子节点中的 <code>class=&quot;star&quot;</code> 的 <code>div</code> 元素。然后，<code>/span[@class=&quot;rating_num&quot;]/text()</code> 将会从这个选中的 <code>div</code> 元素中选择 <code>class=&quot;rating_num&quot;</code> 的 <code>span</code> 元素，并提取其文本内容。</li><li>然而，由于当前处理的节点是 <code>div[@class=&quot;star&quot;]</code> 内部的一个节点，或者更深层次的一个节点，因此 <code>./</code> 就不能正确地选中所需的元素了，因为它不会搜索更深层次的节点。</li><li>所以会返回<code>None</code></li></ul></li><li>当使用 <code>.//span[@class=&quot;rating_num&quot;]/text()</code>：<ul><li><code>.//</code> 表示从当前节点开始查找，不限于直接子节点，而是包括所有后代节点。</li><li><code>div[@class=&quot;star&quot;]</code> 表示选择 <code>class</code> 属性为 “star” 的 <code>div</code> 元素。</li><li><code>span[@class=&quot;rating_num&quot;]</code> 表示选择 <code>class</code> 属性为 “rating_num” 的 <code>span</code> 元素。</li><li><code>/text()</code> 表示获取选定 <code>span</code> 元素的文本内容。</li><li>由于 <code>span</code> 元素嵌套在 <code>class=&quot;star&quot;</code> 的 <code>div</code> 元素内部，所以需要使用 <code>.//</code> 来确保能够选中正确的元素，无论它位于何种深度</li></ul></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6ffff2a9-b43e-4819-2fb5-ae56540da400/public"                      width = "500"                ><p>在XPath中，<code>./</code> 和 <code>.//</code> 的差异主要在于它们搜索节点的范围和深度。这个差别对于定位和提取网页中的数据是至关重要的。</p><ol><li><strong><code>./</code> - 直接子节点</strong>:<ul><li><code>./</code> 表示选择当前节点的直接子节点。</li><li>当使用 <code>./</code> 时，它将只在当前节点的下一级（即直接子节点）中查找匹配的元素。</li><li>例如，如果当前节点是一个<code>div</code>元素，<code>./span</code>将只会选择该<code>div</code>元素的直接子<code>span</code>元素。</li></ul></li><li><strong><code>.//</code> - 当前节点及其所有后代节点</strong>:<ul><li><code>.//</code> 表示在当前节点及其所有后代（子节点、孙节点等）中选择节点。</li><li>当使用 <code>.//</code> 时，它会搜索整个子树，找到所有匹配的元素，无论它们位于当前节点的哪个层级。</li><li>所以，如果当前节点是一个<code>div</code>元素，<code>.//span</code>将会选择该<code>div</code>及其所有子节点中的所有<code>span</code>元素，无论这些<code>span</code>元素嵌套得有多深。</li></ul></li></ol><p>在实际应用中，如果不确定当前处理的节点在HTML结构中的确切位置，使用 <code>.//</code> 会更加安全，因为它不受节点深度的限制。而 <code>./</code> 更适合在已知确切的层次结构和上下文中使用。</p><p><code>dbtest1.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dbtest1Spider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;dbtest1&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;movie.douban.com&quot;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;https://movie.douban.com/top250&quot;</span>] <span class="comment">#修改为开始爬取的页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 这个地方可以直接使用response 就可以了，response对象里面就已经绑定了lxml的一些方法</span></span><br><span class="line">        node_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node_list: <span class="comment">#万一没有数据那么就不执行避免报错</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">                <span class="comment"># 标题</span></span><br><span class="line">                move_title = node.xpath(<span class="string">&#x27;./div/a/span/text()&#x27;</span>).get()</span><br><span class="line">                <span class="comment"># 工作人员</span></span><br><span class="line">                employee = node.xpath(<span class="string">&#x27;./div/p/text()&#x27;</span>).get().strip()</span><br><span class="line">                <span class="comment"># 评分</span></span><br><span class="line">                score = node.xpath(<span class="string">&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;</span>).get()</span><br></pre></td></tr></table></figure></div><h4 id="定义-Item"><a href="#定义-Item" class="headerlink" title="定义 Item"></a>定义 Item</h4><ol><li>Scrapy使用Item类来定义数据结构。当从非结构化数据源（如网页）提取数据时，使用Item对象可以确保数据结构化和一致性。</li><li>Item对象类似于Python字典，但提供了额外的结构化和错误检测功能。这在大型项目中尤其重要，因为它减少了字段名错误和数据不一致的风险。</li><li>在Scrapy项目中，通常需要在<code>items.py</code>文件中定义Item类，然后在爬虫代码中导入和使用这些类。</li></ol><p>Scrapy 使用 <code>Item</code> 类来定义结构化数据字段，它类似于 Python 的字典但提供额外的保护和便利。在 <code>items.py</code> 文件中定义数据结构。</p><p><code>dbtest1.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> DbItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dbtest1Spider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;dbtest1&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;movie.douban.com&quot;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;https://movie.douban.com/top250&quot;</span>]  <span class="comment"># 修改为开始爬取的页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># parse 里面我们只需要关注 怎么解析就行， 因为scrapy会自动帮我们去请求指定的网址</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 这个地方可以直接使用response 就可以了，response对象里面就已经绑定了lxml的一些方法</span></span><br><span class="line">        node_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node_list:  <span class="comment"># 万一没有数据那么就不执行避免报错</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">                <span class="comment"># 标题</span></span><br><span class="line">                move_title = node.xpath(<span class="string">&#x27;./div/a/span/text()&#x27;</span>).get()</span><br><span class="line">                <span class="comment"># 工作人员</span></span><br><span class="line">                employee = node.xpath(<span class="string">&#x27;./div/p/text()&#x27;</span>).get().strip()</span><br><span class="line">                <span class="comment"># 评分</span></span><br><span class="line">                score = node.xpath(<span class="string">&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;</span>).get()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 实例化</span></span><br><span class="line">                item = DbItem()</span><br><span class="line">                item[<span class="string">&#x27;move_title&#x27;</span>] = move_title</span><br><span class="line">                item[<span class="string">&#x27;employee&#x27;</span>] = employee</span><br><span class="line">                item[<span class="string">&#x27;score&#x27;</span>] = score</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></div><p>只会存储<code>item.py</code>里定义的字段</p><p><code>items.py</code>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># https://docs.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DbItem</span>(scrapy.Item):</span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    move_title = scrapy.Field()</span><br><span class="line">    employee = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>在Python中，点（<code>.</code>）和双点（<code>..</code>）是相对导入的一部分，它们表示当前和父包的目录位置。</p><ul><li>单个点（<code>.</code>）表示当前模块的目录位置。</li><li>双点（<code>..</code>）表示父目录的位置。</li></ul><p>当在一个Python模块中看到 <code>from ..items import DbItem</code> 这样的语句时，这意味着：</p><ul><li><code>from ..items</code> 表示从当前模块的父包中的 <code>items</code> 模块导入。</li><li><code>import DbItem</code> 是指导入 <code>items</code> 模块中定义的 <code>DbItem</code> 类。</li></ul><p>这种导入方式通常用在一个包结构中，使得模块可以导入同一包内或父包中的其他模块。例如，在Scrapy项目中，可能有以下的目录结构：</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myproject/</span><br><span class="line">├── myproject/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── items.py</span><br><span class="line">│   ├── middlewares.py</span><br><span class="line">│   ├── pipelines.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   └── spiders/</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       ├── spider1.py</span><br><span class="line">│       └── spider2.py</span><br><span class="line">└── scrapy.cfg</span><br></pre></td></tr></table></figure></div><p>如果在 <code>spider1.py</code> 或 <code>spider2.py</code> 中需要导入 <code>items.py</code> 中定义的 <code>DbItem</code> 类，需要使用相对导入。由于 <code>spiders</code> 是一个子包，需要使用 <code>..</code> 来表示 <code>items.py</code> 所在的父包 <code>myproject</code>。</p><p>使用相对导入的好处是，它不依赖于包的具体位置，这使得整个包更易于重构和移动。然而，相对导入也要小心使用，因为它们只能用在一个包的内部，不能用于顶级模块，否则会引发 <code>ImportError</code>。</p>    </div>  </div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>在Scrapy框架中，<code>yield</code>关键字用于从一个函数返回数据项，但与<code>return</code>不同，<code>yield</code>实现的是一种称为生成器的概念，允许函数在保持其状态的情况下产生一个序列的值，这使得函数能够在每次产生一个值后暂停执行，并在下一次从它停止的地方继续执行。</p><p>在Scrapy中，<code>yield</code>通常在爬虫的<code>parse</code>方法中使用，用来产生以下几种可能的对象：</p><ol><li><strong>Item对象</strong>: 当爬虫解析网页并提取数据时，它会创建一个Item对象，并填充数据。然后通过<code>yield</code>语句返回这个Item对象，Scrapy引擎会将这个Item传递给Item Pipeline进行进一步的处理，如清洗、验证和存储。</li><li><strong>Request对象</strong>: 如果页面需要跟进链接或翻页，爬虫会创建一个Request对象，并通过<code>yield</code>返回。这个Request对象包含了请求的URL和一个回调函数，Scrapy会排队发送这个请求，并在收到响应后将其传递给指定的回调函数。</li></ol><p>使用<code>yield</code>的优势在于它的内存效率和执行效率。生成器不需要在处理大量数据时将它们全部存储在内存中，它们只在需要时产生一个数据项。对于大规模的爬虫任务，这意味着更低的内存消耗和更好的性能。</p><p>下面是使用<code>yield</code>在Scrapy爬虫中返回Item对象的示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="comment"># 解析页面，提取数据</span></span><br><span class="line">    <span class="keyword">for</span> some_data <span class="keyword">in</span> response.css(<span class="string">&#x27;some_selector&#x27;</span>):</span><br><span class="line">        item = MyItem()</span><br><span class="line">        item[<span class="string">&#x27;field1&#x27;</span>] = some_data.css(<span class="string">&#x27;field1_selector::text&#x27;</span>).get()</span><br><span class="line">        item[<span class="string">&#x27;field2&#x27;</span>] = some_data.css(<span class="string">&#x27;field2_selector::text&#x27;</span>).get()</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">yield</span> item  <span class="comment"># 循环返回Item对象</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，每次循环都会提取数据，创建一个Item对象，并通过<code>yield</code>返回它。Scrapy引擎接收到这些Item后，会将它们发送到Item Pipeline。</p>    </div>  </div><h4 id="追踪链接（Following-Links）"><a href="#追踪链接（Following-Links）" class="headerlink" title="追踪链接（Following Links）"></a>追踪链接（Following Links）</h4><ol><li>为了实现多页爬取，需要在爬虫中实现链接追踪。这通常涉及从当前页面提取下一页的链接或根据一定的规则构建新的URL。</li><li>可以在爬虫中使用类变量来追踪当前页码，并在解析函数中构造下一页的URL。如果没有更多的页面可以爬取，爬虫将停止。</li></ol><p>要爬取所有250部电影的信息，需要从初始页面提取到其他页面的链接，并对其进行跟踪。这可以通过构造新的 <code>scrapy.Request</code> 对象并从 <code>parse</code> 方法返回实现</p><h4 id="定义和使用管道（Pipelines）"><a href="#定义和使用管道（Pipelines）" class="headerlink" title="定义和使用管道（Pipelines）"></a>定义和使用管道（Pipelines）</h4><ol><li>Item管道是Scrapy中用于处理爬虫返回的Item对象的组件。它们可以执行多种操作，如清理HTML数据、验证数据完整性、检查重复项和进行数据持久化。</li><li>创建管道组件通常涉及编写一个Python类，并在该类中实现特定的方法来处理Item对象。</li><li>为了激活特定的管道组件，需要在Scrapy的<code>settings.py</code>文件中的<code>ITEM_PIPELINES</code>设置中添加并配置它们。</li></ol><p>管道用于处理 <code>Spider</code> 从网页中提取的 Item。常见的用途包括清洗数据、去重、存储数据到文件或数据库中。</p><ul><li>在 <code>pipelines.py</code> 中定义一个管道类，用于处理 <code>Item</code> 对象。</li><li>在 <code>settings.py</code> 中启用管道（<code>ITEM_PIPELINES</code> 设置）。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># useful for handling different item types with a single interface</span></span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter <span class="comment">#Pipeline可以更加通用地处理不同的Item类或字典。</span></span><br><span class="line"><span class="keyword">import</span> json <span class="comment">#导入Python标准库中的json模块，用于将Python字典转换为JSON字符串。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DbPipeline</span>: <span class="comment">#定义了一个名为DbPipeline的新类，这是一个Scrapy Pipeline的实现。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>): <span class="comment">#open_spider是一个特殊的方法，它在Scrapy爬虫开始运行时被调用。</span></span><br><span class="line">        <span class="comment">#在open_spider方法中，打开一个名为dbtest1result.txt的文件用于写入（&#x27;w&#x27;模式）</span></span><br><span class="line">        <span class="comment">#并设置编码为utf-8。这个文件句柄被保存在self.f属性中，以便在整个Pipeline中使用。</span></span><br><span class="line">        self.f = <span class="built_in">open</span>(<span class="string">&#x27;dbtest1result.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>): <span class="comment">#是Pipeline中的核心方法，每个Item在Pipeline中被处理时都会调用这个方法。</span></span><br><span class="line">        <span class="comment">#将Item对象转换为字典（如果它还不是字典），然后转换为一个JSON字符串。</span></span><br><span class="line">        <span class="comment">#ensure_ascii=False是为了确保非ASCII字符（如中文）能被正确处理。</span></span><br><span class="line">        <span class="comment">#每个JSON字符串后面都加上一个换行符，为了确保写入文件时每个Item占据一行。</span></span><br><span class="line">        json_str = json.dumps(<span class="built_in">dict</span>(item), ensure_ascii=<span class="literal">False</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.f.write(json_str) <span class="comment">#将JSON字符串写入之前打开的文件。</span></span><br><span class="line">        <span class="built_in">print</span>(item) <span class="comment">#在控制台上打印Item，这对于调试和监控Pipeline的处理是有用的。</span></span><br><span class="line">        <span class="keyword">return</span> item <span class="comment">#返回Item对象，这样它就能被后续的Pipeline组件进一步处理。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>): <span class="comment">#是另一个特殊的方法，它在爬虫关闭时调用。</span></span><br><span class="line">        self.f.close() <span class="comment">#关闭文件句柄。这是一个好习惯，因为它可以确保所有内容都被正确地写入磁盘，并释放了系统资源。</span></span><br></pre></td></tr></table></figure></div><h4 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h4><ol><li>可以编写管道类来实现特定的数据处理需求，例如将爬取的数据保存到文件中。</li><li>管道的执行顺序是根据在<code>settings.py</code>中分配给它们的整数值确定的。</li></ol><p>修改 <code>pipelines.py</code> 文件以添加数据存储逻辑。例如，将数据写入到本地的 <code>film.txt</code> 文件中。</p><h4 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h4><p>进入项目根目录，运行以下命令以启动爬虫：</p><p><code>scrapy crawl db</code></p>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <ol><li><p>Robots.txt 协议： 默认情况下，Scrapy 会遵守 Robots.txt 协议。如果需要爬取被此协议禁止的内容，需在 <code>settings.py</code> 中将 <code>ROBOTSTXT_OBEY</code> 设置为 <code>False</code>。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b8f56e7a-3972-4b36-18e6-e6e57ee27600/public"                      width = "500"                ></li><li><p>表头设置（伪装）： 有些网站会根据请求的 User-Agent 进行内容过滤。如果需要，可在 <code>settings.py</code> 中设置自定义的表头。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/94269f46-9430-4c2e-c2f9-9f553db3a100/public"                      width = "500"                ></li><li><p>管道激活<strong>： 需要在 <code>settings.py</code> 中激活管道，以便将提取的数据传递到 <code>pipelines.py</code>。</strong><code>300</code>是一个整数值，定义了Pipeline的执行顺序，数字越小越早执行。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c6c79b2f-3b31-4306-c87a-eb8ffdac8900/public"                      width = "500"                ></li><li><p>Item 字段定义： 在 <code>items.py</code> 中定义字段，这些字段决定了可以从爬取的页面中提取哪些数据。</p></li></ol>    </div>  </div><h2 id="Scrapy-shell"><a href="#Scrapy-shell" class="headerlink" title="Scrapy shell"></a>Scrapy shell</h2><p><code>scrapy shell</code> 是一个强大的交互式环境，它允许开发者在不运行整个爬虫的情况下测试和调试Scrapy的数据抓取代码。它可以加载网页，执行选择器，甚至可以运行爬虫的解析函数，是Scrapy开发中不可或缺的调试工具。</p><p>在项目目录下输入 <code>scrapy shell https://movie.douban.com/top250</code> 会启动Scrapy shell并预加载豆瓣电影Top 250的页面进行调试。下面是对Scrapy shell中提供的一些快捷方法和对象的详细说明：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/70fb8b82-5e37-45c9-10af-b20b65bb7a00/public"                      width = "500"                ><h3 id="快捷方法"><a href="#快捷方法" class="headerlink" title="快捷方法"></a>快捷方法</h3><ul><li><strong><code>shelp()</code></strong>:<ul><li>显示Scrapy shell可用的快捷方法和支持的对象的帮助文档。</li></ul></li><li><strong><code>fetch(url[,redirect=True])</code></strong>:<ul><li>用于在Scrapy shell中获取指定网址的响应。如果<code>redirect</code>为<code>True</code>，则会跟随重定向。</li></ul></li><li><strong><code>fetch(request)</code></strong>:<ul><li>与上面的方法相似，但这里可以传递一个Scrapy的<code>Request</code>对象，而不是URL字符串。</li></ul></li><li><strong><code>view(response)</code></strong>:<ul><li>在本地浏览器中打开当前响应的页面，便于直观地查看Scrapy获取的数据与实际浏览器中呈现的网页之间的差异。</li></ul></li></ul><h3 id="Scrapy-对象"><a href="#Scrapy-对象" class="headerlink" title="Scrapy 对象"></a>Scrapy 对象</h3><ul><li><strong><code>crawler</code></strong>:<ul><li>表示当前运行的爬虫的<code>Crawler</code>对象，包含了很多与爬虫运行相关的信息和接口。</li></ul></li><li><strong><code>spider</code></strong>:<ul><li>当前被加载的<code>Spider</code>对象。如果在shell中加载了一个特定的页面，Scrapy会尝试为这个域创建一个爬虫对象。</li></ul></li><li><strong><code>request</code></strong>:<ul><li>当前被执行的<code>Request</code>对象。在执行<code>fetch()</code>方法后，可以通过这个对象查看请求的具体信息。</li></ul></li><li><strong><code>response</code></strong>:<ul><li>最近一次执行<code>fetch()</code>方法后返回的<code>Response</code>对象。可以通过它来访问页面的内容，并使用选择器提取数据。</li></ul></li><li><strong><code>settings</code></strong>:<ul><li>当前Scrapy项目的设置。可以通过它来查看或修改Scrapy的配置信息。</li></ul></li></ul><p>在Scrapy shell中，也可以使用所有的Python标准库和Scrapy提供的选择器，例如<code>response.xpath()</code>或<code>response.css()</code>来测试和调试数据提取的代码。</p><p>总结起来，<code>scrapy shell</code>提供了一个沙箱环境，让开发者可以实时测试XPath或CSS选择器，查看响应内容，甚至是测试item pipelines的代码，这样可以在不必运行整个Scrapy项目的情况下快速调试和修正代码中的问题。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用IPython 作为控制台的后端在终端（Terminal）中运行 Scrapy shell，Scrapy 会自动检测到 IPython 并使用它，相较于标准 Python 解释器这样操作更加简便。</p><p>在项目文件目录下成功启动Scrapy shell后输入<code>settings[&#39;DEFAULT_REQUEST_HEADERS&#39;]</code>即可查看<code>settings</code>文件中的<code>DEFAULT_REQUEST_HEADERS</code>的默认配置信息</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a0f874b2-3219-4842-082e-de43448cc100/public"                      width = "500"                ><p>同样的可以查看当前的爬虫和爬虫类的属性值</p><p>例如<code>spider.name</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/31526e35-d310-4fb0-15ff-a1b91744ba00/public"                      width = "500"                ><p>或者利用<code>fetch()</code>进行URL的切换</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2f87abc1-95ca-4c9a-381d-215cc6863100/public"                      width = "500"                ><p>但是个人觉得还是用IDE的调试方便，但是一般对于已经部署在服务器的项目还是使用Shell才行，毕竟不用修改代码</p><h2 id="Scrapy-Selector-类"><a href="#Scrapy-Selector-类" class="headerlink" title="Scrapy Selector 类"></a>Scrapy Selector 类</h2><p>选择器 Selector 是 Scrapy 的核心部分，用于提取 HTML&#x2F;XML 文档中的数据。</p><ul><li><p><strong>Scrapy 和 lxml 的关系</strong>:</p><ul><li>Scrapy 默认使用 <code>lxml</code> 作为其解析器，这意味着即使没有直接导入 <code>lxml</code>，Scrapy 仍然依赖于它来解析 HTML&#x2F;XML。</li><li><code>lxml</code> 提供了底层的解析功能，而 Scrapy 的选择器在此基础上提供了更易用的接口。</li></ul></li><li><p><strong>选择器的主要方法</strong>:</p><ul><li><code>xpath()</code>: 接受 XPath 表达式，用于选择 HTML&#x2F;XML 文档中的元素。</li><li><code>css()</code>: 使用 CSS 选择器来选择元素。</li><li>这些方法返回的是选择器列表（SelectorList 对象），可以进一步用于提取或操作数据。</li></ul></li><li><p><strong>提取数据的方法</strong>:</p><ul><li><code>extract()</code>: 返回所有匹配的元素的数据。</li><li><code>extract_first()</code>: 返回第一个匹配元素的数据，如果没有匹配元素则返回 <code>None</code>。</li><li><code>get()</code> 和 <code>getall()</code>: 它们是 <code>extract_first()</code> 和 <code>extract()</code> 的别名。</li></ul></li><li><p><strong>嵌套选择器的使用</strong>:</p><ul><li>在某些情况下，可能需要多次调用 <code>.xpath()</code> 或 <code>.css()</code> 来精确定位数据。</li><li>示例：<code>response.css(&#39;img&#39;).xpath(&#39;@src&#39;)</code> 会首先选择所有 <code>&lt;img&gt;</code> 标签，然后提取它们的 <code>src</code> 属性。</li></ul></li><li><p><strong>使用正则表达式提取数据</strong>:</p><ul><li><code>.re()</code>: 使用正则表达式提取数据，返回匹配的字符串列表。</li><li><code>.re_first()</code>: 返回第一个匹配的字符串。</li></ul></li><li><p><strong>示例 HTML 字符串</strong>:</p><ul><li>提供的 HTML 字符串<code>html_str</code>是一个豆瓣电影页面的一部分，包含电影信息如标题、导演、评分等。</li><li>使用 Scrapy 选择器，可以提取这些信息，如电影名称、评分等。</li></ul></li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">html_str=&quot;&quot;&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hd&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://movie.douban.com/subject/1292052/&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>肖申克的救赎<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span>/<span class="symbol">&amp;nbsp;</span>The Shawshank Redemption<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;other&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span>/<span class="symbol">&amp;nbsp;</span>月黑高飞(港)  /  刺激1995(台)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;playable&quot;</span>&gt;</span>[可播放]<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                            导演: 弗兰克·德拉邦特 Frank Darabont<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>主演: 蒂姆·罗宾斯 Tim Robbins /...<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            1994<span class="symbol">&amp;nbsp;</span>/<span class="symbol">&amp;nbsp;</span>美国<span class="symbol">&amp;nbsp;</span>/<span class="symbol">&amp;nbsp;</span>犯罪 剧情</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;star&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;rating5-t&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;rating_num&quot;</span> <span class="attr">property</span>=<span class="string">&quot;v:average&quot;</span>&gt;</span>9.7<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">property</span>=<span class="string">&quot;v:best&quot;</span> <span class="attr">content</span>=<span class="string">&quot;10.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span>&gt;</span>1980500人评价<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;quote&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;inq&quot;</span>&gt;</span>希望让人自由。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></div><ul><li><strong>选择器使用的完整示例：</strong></li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.通过文本构造实例对象</span></span><br><span class="line">select_txt = Selector(text=html_str) </span><br><span class="line"><span class="comment"># 这段代码通过 Selector 类创建一个选择器实例，接受一个 HTML 字符串作为输入。允许对该 HTML 文档执行 XPath 或 CSS 查询。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取电影的名字(提取单个内容使用get())</span></span><br><span class="line"><span class="built_in">print</span>(select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).get())</span><br><span class="line"><span class="comment"># 这里使用 XPath 查询提取了电影名称。get() 方法返回第一个匹配元素的文本，适用于提取单个内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取多个标签的内容(提取多个内容使用getall())</span></span><br><span class="line"><span class="built_in">print</span>(select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).getall())</span><br><span class="line"><span class="comment"># 与上面类似，但使用 getall() 方法，它返回所有匹配元素的文本列表，适用于提取多个内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取电影的名字(提取单个内容使用extract_first())</span></span><br><span class="line"><span class="built_in">print</span>(select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).extract_first())</span><br><span class="line"><span class="comment"># 这行代码等效于使用 get() 方法。extract_first() 也返回第一个匹配元素的文本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取多个标签的内容(提取多个内容使用extract())</span></span><br><span class="line"><span class="built_in">print</span>(select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).extract())</span><br><span class="line"><span class="comment"># 这行代码等效于使用 getall() 方法。extract() 返回所有匹配元素的文本列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 细分一下标签</span></span><br><span class="line"><span class="built_in">print</span>(select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span[1]/text()&#x27;</span>).getall()[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 这里通过细分 XPath 查询，只选择第一个 &lt;span&gt; 元素的文本，并通过索引 [0] 获取列表中的第一个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 通过response 构造实例对象</span></span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line">response = HtmlResponse(url=<span class="string">&#x27;http://www.example.com/&#x27;</span>, body=html_str.encode())</span><br><span class="line">select_tet = Selector(response=response)</span><br><span class="line"><span class="comment"># 这里通过 HtmlResponse 对象创建了一个选择器实例。HtmlResponse 接受一个 URL 和 HTML 内容作为输入。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(select_tet.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).get())</span><br><span class="line"><span class="built_in">print</span>(response.selector.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).get())</span><br><span class="line"><span class="comment"># 这两行代码都用于提取电影名称。第一行直接使用通过 HtmlResponse 创建的选择器，第二行使用 response 对象的 selector 属性。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(select_tet.css(<span class="string">&#x27;a&#x27;</span>).xpath(<span class="string">&#x27;./span/text()&#x27;</span>).re_first(<span class="string">&#x27;.*的&#x27;</span>))</span><br><span class="line"><span class="comment"># 这里首先使用 CSS 选择器选择所有的 &lt;a&gt; 标签，然后使用 XPath 选择器进一步选择这些 &lt;a&gt; 标签中的 &lt;span&gt; 标签内的文本。最后，使用正则表达式方法 re_first() 提取包含“的”的第一个文本。</span></span><br></pre></td></tr></table></figure></div><h3 id="Selector-类的基础用法"><a href="#Selector-类的基础用法" class="headerlink" title="Selector 类的基础用法"></a>Selector 类的基础用法</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br></pre></td></tr></table></figure></div><p>导入 <code>Selector</code> 类和 <code>HtmlResponse</code> 类的语句。</p><ol><li><strong><code>Selector</code> 类</strong>：<ul><li><code>Selector</code> 类用于从 HTML 或 XML 文档中提取数据。</li><li>它提供了使用 XPath 和 CSS 选择器查询文档的功能。</li><li>通过 <code>Selector</code> 类，可以轻松地提取网页中的特定部分，如文本、链接、标签属性等。</li></ul></li><li><strong><code>HtmlResponse</code> 类</strong>：<ul><li><code>HtmlResponse</code> 类是 Scrapy 用于表示 HTTP 响应的一个类。</li><li>它是 <code>Response</code> 类的一个子类，专门用于处理 HTML 类型的内容。</li><li>通过 <code>HtmlResponse</code>，可以访问响应的 URL、状态码、头部（headers）、正文（body）等信息。</li><li>它通常与 <code>Request</code> 对象一起使用，表示发送请求后收到的 HTTP 响应。</li></ul></li></ol><p>这两个类在编写 Scrapy 爬虫时非常有用。例如，当发送一个 HTTP 请求并收到响应时，可以使用 <code>HtmlResponse</code> 对象来处理这个响应，并使用 <code>Selector</code> 对象来解析和提取所需的数据。</p><h4 id="1-通过文本构造-Selector-实例"><a href="#1-通过文本构造-Selector-实例" class="headerlink" title="1. 通过文本构造 Selector 实例"></a>1. 通过文本构造 Selector 实例</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_txt = Selector(text=html_str)</span><br></pre></td></tr></table></figure></div><ul><li><code>Selector</code> 是 Scrapy 框架中的一个核心类，用于执行对 HTML 或 XML 文档的选择和提取操作。</li><li>这行代码创建了一个 <code>Selector</code> 的实例，命名为 <code>select_txt</code>。</li><li><code>text=html_str</code>：这里 <code>text</code> 参数用于传递 HTML 内容。<ul><li><code>html_str</code> 应该是一个包含 HTML 文档内容的字符串。在实际应用中，这个字符串通常是从网页请求中获取的 HTML 响应体。</li><li>通过传递这个 HTML 字符串，<code>Selector</code> 类的实例 <code>select_txt</code> 将能够解析这个 HTML 文档。</li></ul></li><li>创建了 <code>select_txt</code> 实例后，可以使用它来进行数据提取。</li><li><code>Selector</code> 提供了多种方法来查询和提取 HTML 文档中的数据，最常见的包括 XPath 和 CSS 查询。<ul><li>例如，<code>select_txt.xpath(&#39;//div&#39;)</code> 会选择 HTML 文档中所有的 <code>&lt;div&gt;</code> 元素。</li><li>另一个例子，<code>select_txt.css(&#39;div.classname&#39;)</code> 会选择所有 class 属性为 <code>classname</code> 的 <code>&lt;div&gt;</code> 元素。</li></ul></li><li>这行代码的主要功能是创建一个 Selector 对象，用于解析和操作给定的 HTML 字符串。这是 Scrapy 爬虫开发中常见的模式，用于从网页中提取信息，如提取链接、文本内容、图像地址等。通过这种方式，Scrapy 能够高效地处理和解析网页内容。</li></ul><h5 id="提取电影名称"><a href="#提取电影名称" class="headerlink" title="提取电影名称"></a>提取电影名称</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).get()</span><br></pre></td></tr></table></figure></div><ul><li><p><code>select_txt</code> 是一个 <code>Selector</code> 对象，它包含了 HTML 文档的内容。</p></li><li><p><code>.xpath(&#39;//div[@class=&quot;info&quot;]/div/a/span/text()&#39;)</code> 是一个 XPath 查询。这个查询的含义如下：</p><ul><li><code>//div[@class=&quot;info&quot;]</code>：这部分选择所有具有 <code>class=&quot;info&quot;</code> 属性的 <code>&lt;div&gt;</code> 元素。<code>//</code> 表示在整个文档中查找，而 <code>[@class=&quot;info&quot;]</code> 是一个条件，用于筛选具有指定类名的 <code>&lt;div&gt;</code> 元素。</li><li><code>/div/a/span</code>：对于每个符合上述条件的 <code>&lt;div&gt;</code> 元素，进一步选择其内部的子 <code>&lt;div&gt;</code>，然后选择这些 <code>&lt;div&gt;</code> 内部的 <code>&lt;a&gt;</code> 元素，再选择这些 <code>&lt;a&gt;</code> 元素内部的 <code>&lt;span&gt;</code> 元素。这是一个层层深入的选择过程。</li><li><code>/text()</code>：最后，这部分选择了前面找到的 <code>&lt;span&gt;</code> 元素中的文本内容。<code>text()</code> 函数用于获取一个元素的文本部分。</li></ul></li><li><p><code>.get()</code>：这个方法用于从上面的 XPath 查询中提取第一个匹配元素的文本内容。如果查询没有找到匹配的元素，则返回 <code>None</code>。</p></li></ul><h5 id="提取所有匹配元素的文本列表"><a href="#提取所有匹配元素的文本列表" class="headerlink" title="提取所有匹配元素的文本列表"></a>提取所有匹配元素的文本列表</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).getall()</span><br></pre></td></tr></table></figure></div><ul><li>类似于前面的查询，但使用 <code>getall()</code> 方法来获取所有匹配元素的文本内容列表。</li><li><code>.getall()</code>：这个方法从 XPath 查询中提取所有匹配元素的文本内容，并返回一个列表。如果没有找到匹配的元素，则返回一个空列表。</li></ul><h5 id="使用-extract-first-提取第一个匹配元素的文本"><a href="#使用-extract-first-提取第一个匹配元素的文本" class="headerlink" title="使用 extract_first() 提取第一个匹配元素的文本"></a>使用 extract_first() 提取第一个匹配元素的文本</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).extract_first()</span><br></pre></td></tr></table></figure></div><ul><li><code>extract_first()</code> 方法的功能与 <code>get()</code> 相似，用于提取第一个匹配元素的文本。</li></ul><h5 id="使用-extract-提取所有匹配元素的文本列表"><a href="#使用-extract-提取所有匹配元素的文本列表" class="headerlink" title="使用 extract() 提取所有匹配元素的文本列表"></a>使用 extract() 提取所有匹配元素的文本列表</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).extract()</span><br></pre></td></tr></table></figure></div><ul><li><code>extract()</code> 方法的功能与 <code>getall()</code> 相似，用于提取所有匹配元素的文本内容列表。</li></ul><h5 id="提取特定子元素的文本"><a href="#提取特定子元素的文本" class="headerlink" title="提取特定子元素的文本"></a>提取特定子元素的文本</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_txt.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span[1]/text()&#x27;</span>).getall()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div><ul><li><p><code>select_txt</code> 应该是一个 <code>Selector</code> 对象，包含了 HTML 文档的内容。</p></li><li><p><code>.xpath(&#39;//div[@class=&quot;info&quot;]/div/a/span[1]/text()&#39;)</code> 是一个 XPath 查询。</p><ul><li><code>//div[@class=&quot;info&quot;]</code>：选择所有具有 <code>class=&quot;info&quot;</code> 属性的 <code>&lt;div&gt;</code> 元素。<code>//</code> 表示在整个文档中查找。</li><li><code>/div/a/span[1]</code>：对于每个符合上述条件的 <code>&lt;div&gt;</code> 元素，进一步选择其内部的子 <code>&lt;div&gt;</code>，然后选择这些 <code>&lt;div&gt;</code> 内部的 <code>&lt;a&gt;</code> 元素，再选择这些 <code>&lt;a&gt;</code> 元素内部的第一个 <code>&lt;span&gt;</code> 元素（由 <code>[1]</code> 指定）。</li><li><code>/text()</code>：选择前面找到的 <code>&lt;span&gt;</code> 元素中的文本内容。</li></ul></li><li><p><code>.getall()</code>：这个方法用于从 XPath 查询中提取所有匹配元素的文本内容，并返回一个列表。</p></li><li><p><code>[0]</code>：这个索引用于从列表中获取第一个元素。在 Python 中，列表的索引从 0 开始。</p></li></ul><h4 id="2-通过-response-构造-Selector-实例"><a href="#2-通过-response-构造-Selector-实例" class="headerlink" title="2. 通过 response 构造 Selector 实例"></a>2. 通过 response 构造 Selector 实例</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 HtmlResponse 对象</span></span><br><span class="line">response = HtmlResponse(url=<span class="string">&#x27;http://www.example.com/&#x27;</span>, body=html_str.encode())</span><br><span class="line"><span class="comment"># 创建 Selector 对象</span></span><br><span class="line">select_tet = Selector(response=response)</span><br></pre></td></tr></table></figure></div><ul><li><p><code>HtmlResponse</code> 是 Scrapy 框架中用来表示 HTTP 响应的一个类。</p></li><li><p><code>url=&#39;http://www.example.com/&#39;</code>：这里指定了响应所对应的 URL。在实际的 Scrapy 应用中，这通常是发起请求的目标 URL。</p></li><li><p><code>body=html_str.encode()：body</code></p><p> 参数用于提供 HTTP 响应的正文内容。</p><ul><li><code>html_str</code> 应该是一个包含 HTML 内容的字符串。</li><li><code>.encode()</code> 方法将这个字符串转换为字节序列。在 HTTP 通信中，正文内容通常以字节形式存在，所以需要进行这样的转换。</li></ul></li><li><p><code>Selector</code> 类在 Scrapy 中用于选择和提取 HTML 或 XML 文档中的数据。</p></li><li><p><code>response=response</code>：这里将前面创建的 <code>HtmlResponse</code> 对象传递给 <code>Selector</code>。这样，<code>Selector</code> 就可以使用 <code>HtmlResponse</code> 中的 HTML 内容进行解析和数据提取。</p></li><li><p><code>select_tet</code> 是创建的 <code>Selector</code> 对象的实例，它现在包含了 <code>response</code> 中的 HTML 数据，并可以使用该对象进行各种选择器查询（如 XPath 或 CSS 查询）。</p></li><li><p>这两行代码组合使用 <code>HtmlResponse</code> 和 <code>Selector</code> 类来处理和解析 HTML 数据。首先，使用 <code>HtmlResponse</code> 来模拟一个 HTTP 响应，包括它的 URL 和正文内容。然后，创建一个 <code>Selector</code> 对象来解析这个响应的 HTML 内容，并提供数据提取的功能。这是在 Scrapy 爬虫中常见的模式，用于从网页中提取所需的信息。</p></li></ul><h5 id="使用-Selector-实例和-response-的-selector-属性提取数据"><a href="#使用-Selector-实例和-response-的-selector-属性提取数据" class="headerlink" title="使用 Selector 实例和 response 的 selector 属性提取数据"></a>使用 Selector 实例和 response 的 selector 属性提取数据</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select_tet.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).get()</span><br><span class="line">response.selector.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]/div/a/span/text()&#x27;</span>).get()</span><br></pre></td></tr></table></figure></div><ul><li><p><code>select_tet</code> 应该是一个由 <code>Selector</code> 类实例化的对象。这个对象包含了某个 HTML 文档的内容。</p></li><li><p><code>.xpath(&#39;//div[@class=&quot;info&quot;]/div/a/span/text()&#39;)</code></p><p> 是一个 XPath 选择器表达式。这个表达式的作用是：</p><ul><li><code>//div[@class=&quot;info&quot;]</code>：选择所有具有 <code>class=&quot;info&quot;</code> 属性的 <code>&lt;div&gt;</code> 标签。</li><li><code>/div/a/span</code>：在每个这样的 <code>&lt;div&gt;</code> 标签内，进一步选择嵌套的 <code>&lt;div&gt;</code>，然后选择其内部的 <code>&lt;a&gt;</code> 标签，再选择 <code>&lt;a&gt;</code> 标签内的 <code>&lt;span&gt;</code> 标签。</li><li><code>/text()</code>：提取这些 <code>&lt;span&gt;</code> 标签内的文本内容。</li></ul></li><li><p><code>.get()</code>：这个方法用于获取匹配的第一个元素的文本内容。如果没有找到匹配的元素，将返回 <code>None</code>。</p></li><li><p><code>response</code> 应该是一个 <code>HtmlResponse</code> 对象，通常在 Scrapy 中表示对某个 URL 请求的响应。</p></li><li><p><code>response.selector</code> 是 <code>HtmlResponse</code> 对象的属性，它提供了一个 <code>Selector</code> 对象，用于在响应的 HTML 内容上进行选择器查询。</p></li><li><p><code>.xpath(&#39;//div[@class=&quot;info&quot;]/div/a/span/text()&#39;)</code> 和第一行代码中的 XPath 表达式相同，作用也相同，用于选择特定结构的元素并提取其文本内容。</p></li><li><p><code>.get()</code> 的作用同上，用于获取匹配的第一个元素的文本内容。</p></li><li><p>这两行代码实现的功能是相同的：从 HTML 文档中提取具有特定结构的元素（在这种情况下是某些 <code>&lt;span&gt;</code> 标签内的文本内容）。区别在于它们的选择器来源不同 — 第一行代码使用的是直接从 HTML 文本创建的选择器，而第二行代码使用的是从 <code>HtmlResponse</code> 对象创建的选择器。这种灵活性使得 Scrapy 可以适应不同的数据提取场景。</p></li></ul><h5 id="结合-CSS-和-XPath-选择器及正则表达式提取数据"><a href="#结合-CSS-和-XPath-选择器及正则表达式提取数据" class="headerlink" title="结合 CSS 和 XPath 选择器及正则表达式提取数据"></a>结合 CSS 和 XPath 选择器及正则表达式提取数据</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_tet.css(<span class="string">&#x27;a&#x27;</span>).xpath(<span class="string">&#x27;./span/text()&#x27;</span>).re_first(<span class="string">&#x27;.*的&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li><strong><code>select_tet.css(&#39;a&#39;)</code></strong>:<ul><li><code>select_tet</code> 应该是一个 <code>Selector</code> 对象，它包含了从网页中提取的 HTML 数据。</li><li><code>.css(&#39;a&#39;)</code> 是一个 CSS 选择器，用来选取所有的 <code>&lt;a&gt;</code> 标签。在 Scrapy 中，<code>css</code> 方法用于执行 CSS 选择器查询。</li><li>这一步的结果是一个新的 <code>SelectorList</code> 对象，包含了 HTML 文档中所有的 <code>&lt;a&gt;</code> 标签。</li></ul></li><li><strong><code>.xpath(&#39;./span/text()&#39;)</code></strong>:<ul><li><code>.xpath()</code> 是一个 XPath 选择器方法，用来进一步从前一步的结果中筛选数据。</li><li><code>&#39;./span/text()&#39;</code> 是一个 XPath 查询，它的含义是：在当前节点（这里指的是每个 <code>&lt;a&gt;</code> 标签）的基础上，选择其子节点中的 <code>&lt;span&gt;</code> 标签，并获取这些 <code>&lt;span&gt;</code> 标签的文本内容。</li><li>这一步的结果是一个 <code>SelectorList</code> 对象，包含了所有选中 <code>&lt;span&gt;</code> 标签的文本内容。</li></ul></li><li><strong><code>.re_first(&#39;.\*的&#39;)</code></strong>:<ul><li><code>.re_first()</code> 是一个正则表达式方法，用于在之前选择的文本中进行模式匹配。</li><li><code>&#39;.*的&#39;</code> 是一个正则表达式，<code>.</code> 表示任意字符，<code>*</code> 表示零次或多次重复，<code>的</code> 是要匹配的具体字符。因此，这个表达式的意思是匹配任何以 “的” 结尾的字符串。</li><li><code>re_first</code> 表示只提取第一个匹配的结果。如果没有找到匹配项，则返回 <code>None</code>。</li></ul></li></ul><p>在 HTML 文档中查找所有 <code>&lt;a&gt;</code> 标签，然后在每个 <code>&lt;a&gt;</code> 标签中查找 <code>&lt;span&gt;</code> 标签的文本内容，并从这些文本中提取第一个以 “的” 结尾的字符串。这种方法在处理 HTML 数据时非常灵活，可以有效地结合不同的选择器和正则表达式来提取复杂的数据结构。</p><h2 id="Scrapy-Spider-类"><a href="#Scrapy-Spider-类" class="headerlink" title="Scrapy Spider 类"></a>Scrapy Spider 类</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bc76cc19-8c16-4849-e146-10e8e01f6600/public"                      width = "500"                ><ul><li><p><strong>Spider的名称 (<code>name</code>)</strong>:</p><ul><li>这是一个字符串，用于定义此蜘蛛的名称。</li><li>名称必须唯一，因为它是Scrapy定位和实例化蜘蛛的方式。</li><li>这是最重要的蜘蛛属性，必须提供。</li></ul></li><li><p><strong>起始URLs (<code>start_urls</code>)</strong>:</p><ul><li>这是蜘蛛开始爬取的URL列表。</li><li>爬虫的第一页下载将是此列表中的页面。</li><li>后续的请求将从这些起始URL中提取的数据中连续生成。</li></ul></li><li><p><strong>自定义设置 (<code>custom_settings</code>)</strong>:</p><ul><li>这些设置在运行特定蜘蛛时会覆盖项目范围的全局设置。</li><li>必须定义为类属性，因为在实例化蜘蛛之前，设置就已经更新。</li></ul></li></ul><h3 id="Spider-类的基础结构"><a href="#Spider-类的基础结构" class="headerlink" title="Spider 类的基础结构"></a>Spider 类的基础结构</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spider</span>(<span class="title class_ inherited__">object_ref</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base class for scrapy spiders. All spiders must inherit from this</span></span><br><span class="line"><span class="string">    class.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    custom_settings = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.name = name</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">getattr</span>(self, <span class="string">&#x27;name&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;%s must have a name&quot;</span> % <span class="built_in">type</span>(self).__name__)</span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(self, <span class="string">&#x27;start_urls&#x27;</span>):</span><br><span class="line">            self.start_urls = []</span><br></pre></td></tr></table></figure></div><ul><li><code>class Spider(object_ref)</code>: 这行定义了一个名为 <code>Spider</code> 的类。它从 <code>object_ref</code> 继承，但这里的 <code>object_ref</code> 看起来像是一个错误或者不完整的代码，因为通常 Python 中的类是从 <code>object</code> 类继承的。这可能是一个笔误或者特定项目中的自定义实现。</li><li>类的文档字符串说明了这个类是所有 Scrapy Spider 的基类，意味着所有的 Scrapy 爬虫都应该从这个类继承。</li><li><code>name = None</code>: 这是一个类级别的属性，用于存储爬虫的名称。在 Scrapy 中，每个爬虫的名称应该是唯一的。</li><li><code>custom_settings = None</code>: 这也是一个类级别的属性，用于定义特定于此爬虫的自定义设置，这些设置将覆盖全局设置。</li><li><code>def __init__(self, name=None, **kwargs)</code>: 这是 Spider 类的构造函数。它接受一个可选的 <code>name</code> 参数和任意数量的关键字参数（<code>**kwargs</code>）。</li><li>这部分代码用于设置爬虫的名称。如果构造函数中提供了 <code>name</code>，它将被用作爬虫的名称。</li><li>如果没有提供 <code>name</code> 并且类的 <code>name</code> 属性也没有被设置，会抛出一个 <code>ValueError</code> 异常，因为每个爬虫必须有一个唯一的名称。</li><li><code>self.__dict__.update(kwargs)</code>: 这行代码将所有通过 <code>**kwargs</code> 传入的关键字参数添加到类的实例字典中。这允许在创建爬虫实例时传入额外的属性或设置。</li><li><code>if not hasattr(self, &#39;start_urls&#39;)</code>: 这里检查实例是否有 <code>start_urls</code> 属性，如果没有，则初始化为空列表。<code>start_urls</code> 是爬虫开始爬取的 URL 列表。</li><li>这个类是 Scrapy 爬虫的一个基本框架，提供了命名、自定义设置和初始化的基本机制。任何具体的 Scrapy 爬虫都应该继承这个类，并根据需要提供具体的实现细节。</li></ul><h3 id="日志系统-Logger"><a href="#日志系统-Logger" class="headerlink" title="日志系统 Logger"></a>日志系统 Logger</h3><p>在 Scrapy 的 Spider 类中，日志系统被用于记录信息、警告、错误等。这对于监控爬虫的行为、调试和记录重要事件非常有用。</p><h4 id="Logger-属性"><a href="#Logger-属性" class="headerlink" title="Logger 属性"></a>Logger 属性</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger</span>(<span class="params">self</span>):</span><br><span class="line">    logger = logging.getLogger(self.name)</span><br><span class="line">    <span class="keyword">return</span> logging.LoggerAdapter(logger, &#123;<span class="string">&#x27;spider&#x27;</span>: self&#125;)</span><br></pre></td></tr></table></figure></div><ul><li><code>@property</code>：这是一个 Python 装饰器，用于将一个方法转换为属性。这意味着可以通过 <code>self.logger</code> 访问这个方法返回的值，而不是 <code>self.logger()</code>。</li><li><code>logger = logging.getLogger(self.name)</code>：这里创建了一个日志记录器（logger）。<code>getLogger(self.name)</code> 使用爬虫的名称（<code>self.name</code>）获取一个日志记录器实例。如果不存在具有该名称的记录器，将自动创建一个。</li><li><code>return logging.LoggerAdapter(logger, &#123;&#39;spider&#39;: self&#125;)</code>：返回一个 <code>LoggerAdapter</code> 实例。这是一个对标准日志记录器的包装，它提供了额外的上下文信息，使得每个日志消息都能够知道是由哪个爬虫实例产生的。这里的上下文信息是 <code>&#123;&#39;spider&#39;: self&#125;</code>，即当前的爬虫实例。</li></ul><h4 id="Log-方法"><a href="#Log-方法" class="headerlink" title="Log 方法"></a>Log 方法</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">self, message, level=logging.DEBUG, **kw</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Log the given message at the given log level</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This helper wraps a log call to the logger within the spider, but you</span></span><br><span class="line"><span class="string">    can use it directly (e.g. Spider.logger.info(&#x27;msg&#x27;)) or use any other</span></span><br><span class="line"><span class="string">    Python logger too.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.logger.log(level, message, **kw)</span><br></pre></td></tr></table></figure></div><ul><li><code>def log(self, message, level=logging.DEBUG, **kw)</code>: 这是一个辅助方法，用于在爬虫内部发送日志消息。</li><li><code>level=logging.DEBUG</code>：默认的日志级别设置为 DEBUG。日志级别决定了记录的消息类型。常见的级别包括 DEBUG, INFO, WARNING, ERROR, 和 CRITICAL。</li><li><code>self.logger.log(level, message, **kw)</code>：这个调用使用了之前定义的 <code>logger</code> 属性。它将消息 <code>message</code> 记录到日志中，级别为 <code>level</code>。<code>**kw</code> 可以传递额外的关键字参数。</li></ul><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;my_spider&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 使用日志记录信息</span></span><br><span class="line">        self.logger.info(<span class="string">&#x27;Parsing response from %s&#x27;</span>, response.url)</span><br><span class="line">        <span class="comment"># 其他解析逻辑...</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，每当 <code>parse</code> 方法被调用时，都会记录一个包含响应 URL 的信息级别日志。</p><h3 id="from-crawler-和-set-crawler-方法"><a href="#from-crawler-和-set-crawler-方法" class="headerlink" title="from_crawler 和 _set_crawler 方法"></a>from_crawler 和 _set_crawler 方法</h3><p>Spider 类的 <code>from_crawler</code> 类方法和 <code>_set_crawler</code> 实例方法。这些方法在 Scrapy 的内部机制中扮演重要角色，尤其是在爬虫的初始化过程中。</p><p><strong><code>from_crawler</code> 方法</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">from_crawler</span>(<span class="params">cls, crawler, *args, **kwargs</span>):</span><br><span class="line">    spider = cls(*args, **kwargs)</span><br><span class="line">    spider._set_crawler(crawler)</span><br><span class="line">    <span class="keyword">return</span> spider</span><br></pre></td></tr></table></figure></div><ul><li><code>@classmethod</code>：这是一个 Python 装饰器，用于定义一个类方法。不同于普通的实例方法，类方法接收类本身作为第一个参数（通常命名为 <code>cls</code>）而非类的实例。</li><li><code>from_crawler</code> 是 Scrapy 用来创建 Spider 实例的标准方法。它接收一个 <code>crawler</code> 对象作为参数，以及任意数量的额外的位置和关键字参数。</li><li><code>spider = cls(*args, **kwargs)</code>：这行代码使用传入的参数创建了一个 Spider 实例。</li><li><code>spider._set_crawler(crawler)</code>：这行代码调用 <code>_set_crawler</code> 方法，将 <code>crawler</code> 对象设置到创建的 Spider 实例上。</li><li><code>return spider</code>：返回创建好的 Spider 实例。</li></ul><p><strong><code>_set_crawler</code> 方法</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_set_crawler</span>(<span class="params">self, crawler</span>):</span><br><span class="line">    self.crawler = crawler</span><br><span class="line">    self.settings = crawler.settings</span><br><span class="line">    crawler.signals.connect(self.close, signals.spider_closed)</span><br></pre></td></tr></table></figure></div><ul><li>这是一个内部方法，用于在 Spider 实例上设置 <code>crawler</code> 对象。</li><li><code>self.crawler = crawler</code>：将传入的 <code>crawler</code> 对象赋值给 Spider 实例的 <code>crawler</code> 属性。</li><li><code>self.settings = crawler.settings</code>：将 <code>crawler</code> 对象的设置赋值给 Spider 实例的 <code>settings</code> 属性。这样，Spider 可以访问和使用 Scrapy 项目的设置。</li><li><code>crawler.signals.connect(self.close, signals.spider_closed)</code>：这行代码连接了 Spider 的 <code>close</code> 方法到 Scrapy 的 <code>spider_closed</code> 信号。当爬虫关闭时，这个信号会被触发，并调用 Spider 的 <code>close</code> 方法。</li></ul><p>在 Scrapy 框架中，<code>from_crawler</code> 方法通常由框架自身调用，用于创建并初始化 Spider 对象。这个过程包括设置爬虫的配置和信号处理等。一般情况下，开发者无需覆盖这个方法，除非需要进行一些特殊的初始化操作。<code>from_crawler</code> 和 <code>_set_crawler</code> 方法是 Scrapy 框架中 Spider 类的重要组成部分，它们负责爬虫的初始化和设置。这些方法确保了每个 Spider 实例可以访问到它所需的资源和配置，同时也使得爬虫能够正确响应 Scrapy 框架的信号。</p><h3 id="start-requests-方法"><a href="#start-requests-方法" class="headerlink" title="start_requests 方法"></a>start_requests 方法</h3><p><code>start_requests</code> 是一个关键方法，用于生成爬虫启动时的初始请求。这个方法只会在爬虫开始时调用一次。下面是对这个方法的代码和概念的详细解释和整理：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">    cls = self.__class__</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.start_urls <span class="keyword">and</span> <span class="built_in">hasattr</span>(self, <span class="string">&#x27;start_url&#x27;</span>):</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(</span><br><span class="line">            <span class="string">&quot;Crawling could not start: &#x27;start_urls&#x27; not found &quot;</span></span><br><span class="line">            <span class="string">&quot;or empty (but found &#x27;start_url&#x27; attribute instead, &quot;</span></span><br><span class="line">            <span class="string">&quot;did you miss an &#x27;s&#x27;?)&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> method_is_overridden(cls, Spider, <span class="string">&#x27;make_requests_from_url&#x27;</span>):</span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">&quot;Spider.make_requests_from_url method is deprecated; it &quot;</span></span><br><span class="line">            <span class="string">&quot;won&#x27;t be called in future Scrapy releases. Please &quot;</span></span><br><span class="line">            <span class="string">&quot;override Spider.start_requests method instead (see %s.%s).&quot;</span> % (</span><br><span class="line">                cls.__module__, cls.__name__</span><br><span class="line">            ),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls:</span><br><span class="line">            <span class="keyword">yield</span> self.make_requests_from_url(url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls:</span><br><span class="line">            <span class="keyword">yield</span> Request(url, dont_filter=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><ul><li><code>def start_requests(self)</code>: 这是 Scrapy Spider 类中的一个实例方法，用于生成初始的网页请求。</li><li><code>cls = self.__class__</code>: 获取当前实例的类。</li><li><code>if not self.start_urls and hasattr(self, &#39;start_url&#39;)</code>: 这个条件检查是否定义了 <code>start_urls</code> 属性。如果 <code>start_urls</code> 没有定义或为空，并且错误地定义了 <code>start_url</code>（缺少末尾的 ‘s’），则抛出异常。</li><li><code>if method_is_overridden(cls, Spider, &#39;make_requests_from_url&#39;)</code>: 检查是否重写了 <code>make_requests_from_url</code> 方法。这个方法已被弃用，Scrapy 鼓励使用 <code>start_requests</code> 方法。</li><li><code>warnings.warn(...)</code>: 如果使用了弃用的方法，显示警告信息。</li><li><code>for url in self.start_urls</code>: 遍历 <code>start_urls</code> 列表中的每个 URL。</li><li><code>yield self.make_requests_from_url(url)</code>: 对于每个 URL，使用 <code>make_requests_from_url</code> 方法生成请求。这是兼容旧代码的方式。</li><li><code>yield Request(url, dont_filter=True)</code>: 对于每个 URL，创建一个 Scrapy 的 <code>Request</code> 对象并返回。<code>dont_filter=True</code> 表示对这些请求不应用去重过滤器。</li><li>通常，Scrapy 爬虫定义了 <code>start_urls</code> 列表，并依赖 <code>start_requests</code> 方法来为这些 URL 创建初始请求。可以覆盖 <code>start_requests</code> 方法以提供更复杂的启动逻辑，例如从外部数据源读取 URL，或添加特殊的请求头和元数据。</li><li><code>start_requests</code> 方法是 Scrapy 爬虫的起点，负责生成爬虫的初始请求。这个方法应返回一个可迭代对象，其中包含了爬虫开始时需要处理的 <code>Request</code> 对象。通过重写这个方法，开发者可以自定义爬虫的启动行为，例如，从外部文件读取起始 URL，或者添加特定的请求参数和头部</li></ul><h3 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse 方法"></a>parse 方法</h3><p>这是Scrapy在其请求未指定回调时处理下载的响应时使用的默认回调</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;&#123;&#125;.parse callback is not defined&#x27;</span>.<span class="built_in">format</span>(self.__class__.__name__))</span><br></pre></td></tr></table></figure></div><ul><li><code>parse</code> 是 Scrapy 爬虫中最重要的方法之一。它是默认的回调函数，用于处理由 Scrapy 发出的请求所返回的响应。</li><li>当一个请求没有指定特定的回调函数时，Scrapy 会自动调用 <code>parse</code> 方法。</li><li>在这个示例中，<code>parse</code> 方法被定义为抛出 <code>NotImplementedError</code> 异常。这是一个通常的做法，用来提示开发者应该在自己的爬虫类中覆盖这个方法，提供具体的实现逻辑。</li><li>实际使用中，<code>parse</code> 方法通常包含解析响应（<code>response</code> 对象）并提取数据或进一步生成请求（<code>Request</code> 对象）的逻辑。</li><li><code>parse</code> 是处理响应的默认方法</li></ul><h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close 方法"></a>close 方法</h3><ul><li><code>close</code> 方法在爬虫关闭时被调用。它是一个钩子（hook），提供了一种机会在爬虫结束时执行某些操作，比如清理资源、保存状态、发出通知等。</li><li><code>close</code> 方法的具体实现会根据爬虫的需求而有所不同。在 Scrapy 框架的默认实现中，这个方法可能并未显式地定义，但可以根据需要在自定义爬虫中覆盖它。</li><li>在开发 Scrapy 爬虫时，通常需要实现 <code>parse</code> 方法来定义如何处理响应。这可能包括解析 HTML、处理数据和生成新的请求。</li><li><code>close</code> 方法则用于定义在爬虫关闭时需要执行的任何清理或结束任务。</li><li><code>close</code> 提供了在爬虫结束时执行操作的机会。</li></ul><h2 id="次级页面抓取及数据传递拼接"><a href="#次级页面抓取及数据传递拼接" class="headerlink" title="次级页面抓取及数据传递拼接"></a>次级页面抓取及数据传递拼接</h2><h3 id="次级页面抓取"><a href="#次级页面抓取" class="headerlink" title="次级页面抓取"></a>次级页面抓取</h3><p>在 Scrapy 爬虫中，处理多级页面通常涉及以下步骤：</p><ul><li><p>一级页面（列表页）</p><ul><li>在列表页，会解析出指向详情页的链接，并对每个链接发起请求以进入二级页面。</li></ul></li><li><p>二级页面（详情页）</p><ul><li>在详情页，会提取所需的具体数据。</li></ul></li></ul><p>这个过程通常在 <code>parse</code> 方法（处理列表页）和一个自定义的回调方法（处理详情页）中实现。</p><h3 id="详情页抓取"><a href="#详情页抓取" class="headerlink" title="详情页抓取"></a>详情页抓取</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_detail</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><ul><li><code>get_detail</code> 是一个自定义的回调方法，用于处理从列表页提取的详情页链接的响应。</li><li>这个方法中，编写解析详情页的逻辑，例如提取特定的数据。</li></ul><h3 id="数据提取示例"><a href="#数据提取示例" class="headerlink" title="数据提取示例"></a>数据提取示例</h3><ul><li>第一种方式：<code>&#39;//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]&#39;</code>。这个 XPath 查询用于提取比较简单的结构的数据。</li><li>第二种方式：<code>&#39;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#39;</code>。这个查询适用于当数据结构更复杂或有多种可能的格式时。它使用了 XPath 的联合操作符 <code>|</code> 来匹配多个可能的路径。</li></ul><h3 id="参数的传递拼接"><a href="#参数的传递拼接" class="headerlink" title="参数的传递拼接"></a>参数的传递拼接</h3><ul><li>在 Scrapy 中，<code>meta</code> 参数用于在不同的请求之间传递数据。</li><li>当从列表页发起对详情页的请求时，可以使用 <code>meta</code> 参数携带需要在详情页中使用的数据。例如，可能想传递从列表页提取的某些上下文信息到详情页。</li></ul><p>使用 <code>meta</code> 的示例</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="comment"># 提取详情页链接</span></span><br><span class="line">    detail_url = response.xpath(<span class="string">&#x27;some_xpath_to_detail_url&#x27;</span>).get()</span><br><span class="line">    <span class="comment"># 向详情页发起请求，并传递额外的数据</span></span><br><span class="line">    <span class="keyword">yield</span> scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;<span class="string">&#x27;item&#x27;</span>: <span class="string">&#x27;some_data&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></div><p>在这个示例中，<code>parse</code> 方法提取了详情页的链接，并发起了一个新的请求。通过设置 <code>meta=&#123;&#39;item&#39;: &#39;some_data&#39;&#125;</code>，任何想从列表页到详情页传递的数据都可以包含在这个 <code>meta</code> 字典中。</p><p>在 Scrapy 爬虫中处理多级页面时，通常会在列表页解析出详情页的链接，并为这些链接发起请求。在处理这些请求的回调方法中，会提取详情页的具体数据。使用 <code>meta</code> 参数可以在不同请求之间传递数据，这对于保持爬虫逻辑的连贯性和传递上下文信息非常重要。</p><h3 id="豆瓣为例子"><a href="#豆瓣为例子" class="headerlink" title="豆瓣为例子"></a>豆瓣为例子</h3><h4 id="Spider-文件"><a href="#Spider-文件" class="headerlink" title="Spider 文件"></a>Spider 文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> DbItem</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Db250Spider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;db250&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://movie.douban.com/top250&#x27;</span>]</span><br><span class="line">    page_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        node_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node_list:</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">                <span class="comment"># 标题</span></span><br><span class="line">                movie_name = node.xpath(<span class="string">&#x27;./div/a/span/text()&#x27;</span>).get()</span><br><span class="line">                <span class="comment"># 导演</span></span><br><span class="line">                director = node.xpath(<span class="string">&#x27;./div/p/text()&#x27;</span>).get().strip()</span><br><span class="line">                <span class="comment"># 分数</span></span><br><span class="line">                score = node.xpath(<span class="string">&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;</span>).get()</span><br><span class="line"></span><br><span class="line">                item = DbItem()</span><br><span class="line">                item[<span class="string">&quot;movie_name&quot;</span>] = movie_name</span><br><span class="line">                item[<span class="string">&quot;director&quot;</span>] = director</span><br><span class="line">                item[<span class="string">&quot;score&quot;</span>] = score</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 电影详情页</span></span><br><span class="line">                detail_url = node.xpath(<span class="string">&#x27;./div/a/@href&#x27;</span>).get()</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;<span class="string">&quot;info&quot;</span>:item&#125;)</span><br><span class="line"></span><br><span class="line">            self.page_num +=<span class="number">1</span></span><br><span class="line">            page_url = <span class="string">&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;</span>.<span class="built_in">format</span>(self.page_num*<span class="number">25</span>)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(page_url, callback=self.parse)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 详情页解析</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_detail</span>(<span class="params">self,response</span>):</span><br><span class="line">        item = DbItem()</span><br><span class="line">        info = response.meta.get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">        item.update(info)</span><br><span class="line">        description_list = response.xpath(<span class="string">&#x27;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#x27;</span>).getall()</span><br><span class="line">        description = <span class="string">&#x27;&#x27;</span>.join([des.strip() <span class="keyword">for</span> des <span class="keyword">in</span> description_list])</span><br><span class="line"></span><br><span class="line">        item[<span class="string">&quot;description&quot;</span>] = description</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></div><p>这段代码是一个 Scrapy 爬虫的示例，用于爬取豆瓣电影 Top 250 的相关信息。下面是对这个代码的详细分析：</p><h5 id="爬虫定义"><a href="#爬虫定义" class="headerlink" title="爬虫定义"></a>爬虫定义</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Db250Spider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;db250&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://movie.douban.com/top250&#x27;</span>]</span><br><span class="line">    page_num = <span class="number">0</span></span><br></pre></td></tr></table></figure></div><ul><li>这个类继承自<code>scrapy.Spider</code>，是Scrapy框架中用于创建爬虫的基础类。</li><li><code>class Db250Spider(scrapy.Spider):</code> 这行定义了一个名为<code>Db250Spider</code>的新类，它继承自<code>scrapy.Spider</code>。这意味着<code>Db250Spider</code>是一个Scrapy爬虫，可以继承并使用Scrapy框架提供的所有功能和属性。</li><li><code>name = &#39;db250&#39;</code> 这里设置了爬虫的名字为<code>db250</code>。这个名称是Scrapy项目中唯一的标识符，用于在命令行中指定和运行特定的爬虫。</li><li><code>allowed_domains = [&#39;movie.douban.com&#39;]</code> <code>allowed_domains</code>是一个列表，包含了爬虫允许爬取的域名。这有助于确保爬虫不会跨域爬取。在这个例子中，爬虫只会爬取<code>movie.douban.com</code>域下的页面。</li><li><code>start_urls = [&#39;https://movie.douban.com/top250&#39;]</code> <code>start_urls</code>是一个包含起始URL的列表。当爬虫启动时，Scrapy会自动开始从这些URL发起请求。在这个例子中，爬虫将从豆瓣电影Top 250的主页开始爬取。</li><li><code>page_num = 0</code> <code>page_num</code>是一个类属性，用于跟踪当前爬取的页码。这在处理分页或需要在多个页面之间导航时非常有用。在这个例子中，它被初始化为0。</li><li>接下来在这个爬虫类中定义如<code>parse</code>等方法，以指定如何解析和处理每个请求的响应，以及如何从中提取数据或者进一步生成新的请求。例如，解析豆瓣电影Top 250页面的响应，提取电影信息，然后爬取每个电影的详细页面等。</li></ul><h5 id="主页解析方法-parse"><a href="#主页解析方法-parse" class="headerlink" title="主页解析方法 parse"></a>主页解析方法 parse</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    node_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> node_list:</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">            movie_name = node.xpath(<span class="string">&#x27;./div/a/span/text()&#x27;</span>).get()</span><br><span class="line">            director = node.xpath(<span class="string">&#x27;./div/p/text()&#x27;</span>).get().strip()</span><br><span class="line">            score = node.xpath(<span class="string">&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;</span>).get()</span><br><span class="line"></span><br><span class="line">            item = DbItem()</span><br><span class="line">            item[<span class="string">&quot;movie_name&quot;</span>] = movie_name</span><br><span class="line">            item[<span class="string">&quot;director&quot;</span>] = director</span><br><span class="line">            item[<span class="string">&quot;score&quot;</span>] = score</span><br><span class="line"></span><br><span class="line">            detail_url = node.xpath(<span class="string">&#x27;./div/a/@href&#x27;</span>).get()</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;<span class="string">&quot;info&quot;</span>:item&#125;)</span><br><span class="line"></span><br><span class="line">        self.page_num += <span class="number">1</span></span><br><span class="line">        page_url = <span class="string">&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;</span>.<span class="built_in">format</span>(self.page_num*<span class="number">25</span>)</span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(page_url, callback=self.parse)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></div><h6 id="0-方法定义"><a href="#0-方法定义" class="headerlink" title="0. 方法定义"></a>0. 方法定义</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br></pre></td></tr></table></figure></div><ul><li><code>self</code> 是对当前对象实例（即Spider对象）的引用。</li><li><code>response</code> 是一个包含了HTTP响应数据的对象。它包括响应内容（通常是HTML）、URL、HTTP头等信息。</li><li><code>parse</code>方法的主要功能是处理<code>response</code>，提取有用信息，或者进一步生成需要跟进的URL请求。</li><li>在这个方法中，通常会使用XPath或CSS选择器来解析响应内容（如提取数据）。</li><li>数据提取：可以使用<code>response.xpath()</code>或<code>response.css()</code>方法来选择HTML元素，然后提取所需数据。</li><li>生成跟进请求：如果页面中有链接到其他页面，且想爬取那些页面的数据，可以通过<code>scrapy.Request</code>生成新的请求。</li><li><code>parse</code>方法可以返回以下类型的对象：<ul><li>字典（在Python中通常是通过yield语句生成）。</li><li><code>scrapy.Item</code>对象，这是一个更结构化的方式来管理数据。</li><li><code>Request</code>对象，用于生成新的爬取请求。</li><li>或者它们的组合。</li></ul></li><li><code>parse</code>方法是Scrapy爬虫的核心，用于处理响应并从中提取信息，或者根据页面中的链接生成新的请求。</li></ul><h6 id="1-解析节点列表"><a href="#1-解析节点列表" class="headerlink" title="1. 解析节点列表"></a>1. 解析节点列表</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;info&quot;]&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li>这行代码使用 XPath 查询从响应中提取所有类属性为 <code>&quot;info&quot;</code> 的 <code>&lt;div&gt;</code> 元素。</li><li>这些 <code>&lt;div&gt;</code> 元素包含了电影的主要信息，并存储在 <code>node_list</code> 中。</li><li><code>response</code>:<ul><li>这通常是一个由Scrapy框架（或类似的库）提供的响应对象。</li><li>它代表了一个从网页请求中获得的HTTP响应。</li><li>这个对象包含了完整的网页数据，通常是HTML格式。</li></ul></li><li><code>.xpath()</code>:<ul><li>这是一个方法，用于对<code>response</code>对象中的HTML内容执行XPath查询。</li><li>XPath是一种在XML和HTML文档中查找信息的语言。</li><li>通过XPath，可以导航文档的结构，并选择需要的元素、属性等。</li></ul></li><li><code>&#39;//div[@class=&quot;info&quot;]&#39;</code>:<ul><li>这是传递给<code>.xpath()</code>方法的XPath查询表达式。</li><li>让我们分解这个表达式：<ul><li><code>//</code>: 这个符号表示选择文档中的所有匹配元素，而不仅仅是直接子元素。它在整个文档中进行搜索。</li><li><code>div</code>: 这指定了想要选择的元素类型。在这种情况下，它是<code>&lt;div&gt;</code>元素。</li><li><code>[@class=&quot;info&quot;]</code>: 这是一个条件（谓语），用来进一步细化选择。它指定只选择那些具有<code>class=&quot;info&quot;</code>属性的<code>&lt;div&gt;</code>元素。<ul><li><code>@class</code>: 表示选择元素的<code>class</code>属性。</li><li><code>&quot;info&quot;</code>: 表示属性值必须精确匹配<code>info</code>字符串。</li></ul></li></ul></li></ul></li><li>在网页的响应内容中选择所有<code>class</code>属性值为<code>info</code>的<code>&lt;div&gt;</code>元素，并将这些元素存储在<code>node_list</code>变量中。这个列表可以被进一步用于抽取数据、分析或其他处理。在网页抓取和数据提取的过程中，这是一种非常常见的做法。</li></ul><h6 id="2-判断并遍历节点"><a href="#2-判断并遍历节点" class="headerlink" title="2. 判断并遍历节点"></a>2. 判断并遍历节点</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node_list:</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br></pre></td></tr></table></figure></div><ul><li>首先检查 <code>node_list</code> 是否非空，确保有要处理的节点。</li><li>然后遍历这些节点，每个节点 (<code>node</code>) 代表一个电影条目。</li><li><code>if node_list:</code><ul><li>这是一个条件语句，检查<code>node_list</code>是否非空。在Python中，空列表（<code>[]</code>）被认为是<code>False</code>，而非空列表被认为是<code>True</code>。</li><li>这个条件确保仅当<code>node_list</code>中有元素时，即列表不为空时，才会执行下面的代码块。这是一个良好的编程实践，可以避免在空列表上执行操作时出现错误。</li></ul></li><li><code>for node in node_list:</code><ul><li>这是一个<code>for</code>循环，用于遍历<code>node_list</code>中的每个元素。</li><li>在每次迭代中，<code>node</code>变量会被赋予<code>node_list</code>中的当前元素。</li><li>如果<code>node_list</code>是由之前提到的<code>response.xpath(&#39;//div[@class=&quot;info&quot;]&#39;)</code>表达式返回的，那么每个<code>node</code>很可能是一个表示HTML <code>&lt;div&gt;</code>元素的对象。这种对象通常提供了进一步提取数据（如文本内容、属性等）的方法。</li></ul></li><li>如果<code>node_list</code>不为空，即至少包含一个元素，那么对于列表中的每个元素（每个<code>&lt;div class=&quot;info&quot;&gt;</code>），执行循环体中的代码。循环体的具体内容没有提供，但通常它会包含进一步处理每个<code>node</code>的代码，例如提取信息、打印数据、存储结果等。</li></ul><h6 id="3-提取电影信息"><a href="#3-提取电影信息" class="headerlink" title="3. 提取电影信息"></a>3. 提取电影信息</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie_name = node.xpath(<span class="string">&#x27;./div/a/span/text()&#x27;</span>).get()</span><br><span class="line">director = node.xpath(<span class="string">&#x27;./div/p/text()&#x27;</span>).get().strip()</span><br><span class="line">score = node.xpath(<span class="string">&#x27;.//span[@class=&quot;rating_num&quot;]/text()&#x27;</span>).get()</span><br></pre></td></tr></table></figure></div><ul><li>提取电影名称：使用 XPath 查询从当前节点 (<code>node</code>) 中提取电影名称。</li><li>提取导演信息：获取导演信息，这里使用 <code>.strip()</code> 来移除字符串开头和结尾的空白字符。</li><li>提取电影评分：获取电影评分，这里使用 <code>.//</code> 从当前节点的所有子孙节点中查找符合条件的节点。</li><li><code>movie_name = node.xpath(&#39;./div/a/span/text()&#39;).get()</code><ul><li>这行代码从当前的<code>node</code>中提取电影名称。</li><li><code>./div/a/span/text()</code>: XPath查询语句。<ul><li><code>./</code> 表示从当前节点开始。</li><li><code>div/a/span</code> 定位到一个<code>&lt;span&gt;</code>元素，这个元素是一个<code>&lt;a&gt;</code>元素的子元素，而<code>&lt;a&gt;</code>元素又是一个<code>&lt;div&gt;</code>元素的子元素。</li><li><code>/text()</code> 选择这个<code>&lt;span&gt;</code>元素的文本内容。</li></ul></li><li><code>.get()</code> 是一个方法，用来获取XPath查询结果的第一个匹配项。</li></ul></li><li><code>director = node.xpath(&#39;./div/p/text()&#39;).get().strip()</code><ul><li>这行代码用来提取导演的名称。</li><li><code>./div/p/text()</code>: XPath查询语句。<ul><li>类似于前面的查询，但这次是选择一个<code>&lt;p&gt;</code>元素的文本内容。</li></ul></li><li><code>.get()</code> 同样获取第一个匹配项的文本。</li><li><code>.strip()</code> 是一个字符串方法，用来移除字符串首尾的空白字符（如空格、换行符等）。</li></ul></li><li><code>score = node.xpath(&#39;.//span[@class=&quot;rating_num&quot;]/text()&#39;).get()</code><ul><li>这行代码用于提取电影评分。</li><li><code>.//span[@class=&quot;rating_num&quot;]/text()</code>: XPath查询语句。<ul><li><code>.//</code> 表示在当前节点及其子节点中查找。</li><li><code>span[@class=&quot;rating_num&quot;]</code> 选择所有<code>class</code>属性为<code>rating_num</code>的<code>&lt;span&gt;</code>元素。</li><li><code>/text()</code> 同样选择这些<code>&lt;span&gt;</code>元素的文本内容。</li></ul></li><li><code>.get()</code> 获取第一个匹配结果。</li></ul></li><li>这三行代码是在遍历一个包含多个节点（每个节点代表一个电影信息）的列表时，用来从每个节点中提取特定信息的标准操作。这种方式在爬虫和数据提取的过程中非常常见，特别是当处理诸如电影列表页面这样的结构化数据时。</li></ul><h6 id="4-创建并填充-Scrapy-Item"><a href="#4-创建并填充-Scrapy-Item" class="headerlink" title="4. 创建并填充 Scrapy Item"></a>4. 创建并填充 Scrapy Item</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">item = DbItem()</span><br><span class="line">item[<span class="string">&quot;movie_name&quot;</span>] = movie_name</span><br><span class="line">item[<span class="string">&quot;director&quot;</span>] = director</span><br><span class="line">item[<span class="string">&quot;score&quot;</span>] = score</span><br></pre></td></tr></table></figure></div><ul><li><code>item = DbItem()</code><ul><li>这行代码创建了一个<code>DbItem</code>的实例。通常在Scrapy项目中定义，用于表示提取的数据结构。</li><li>在Scrapy中，<code>Item</code>对象用于定义存储爬取数据的结构。它们类似于Python中的字典，但提供额外的保护和便利，如字段定义和类型检查。</li></ul></li><li><code>item[&quot;movie_name&quot;] = movie_name</code><ul><li>这行代码将之前提取的<code>movie_name</code>（电影名称）赋值给<code>item</code>的<code>&quot;movie_name&quot;</code>键。</li><li>这意味着<code>DbItem</code>类中定义了一个字段<code>movie_name</code>，用于存储电影名称。</li></ul></li><li><code>item[&quot;director&quot;] = director</code><ul><li>类似地，这行代码将提取的<code>director</code>（导演名称）赋值给<code>item</code>的<code>&quot;director&quot;</code>键。</li></ul></li><li><code>item[&quot;score&quot;] = score</code><ul><li>同样地，这行代码将提取的<code>score</code>（电影评分）赋值给<code>item</code>的<code>&quot;score&quot;</code>键。</li></ul></li><li>创建了一个<code>DbItem</code>实例，并填充了从网页中提取的数据：电影名称、导演和评分。在Scrapy中，这样的<code>item</code>对象通常会被进一步传递到管道（pipelines），在那里可以进行如存储到数据库、进行数据清洗或其他处理的操作。使用<code>Item</code>对象的好处在于它提供了结构化的数据存储方式，有助于维护代码的清晰度和可维护性。</li></ul><h6 id="5-请求电影详情页"><a href="#5-请求电影详情页" class="headerlink" title="5. 请求电影详情页"></a>5. 请求电影详情页</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">detail_url = node.xpath(<span class="string">&#x27;./div/a/@href&#x27;</span>).get()</span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;<span class="string">&quot;info&quot;</span>:item&#125;)</span><br></pre></td></tr></table></figure></div><ul><li><code>detail_url = node.xpath(&#39;./div/a/@href&#39;).get()</code><ul><li>这行代码使用XPath选择器从当前处理的节点（<code>node</code>）中提取详情页面的链接。</li><li><code>./div/a/@href</code>: XPath查询语句。<ul><li><code>./</code> 表示从当前节点开始。</li><li><code>div/a</code> 定位到当前节点下的<code>&lt;div&gt;</code>元素中的<code>&lt;a&gt;</code>元素。</li><li><code>@href</code> 获取这个<code>&lt;a&gt;</code>元素的<code>href</code>属性，即链接地址。</li></ul></li><li><code>.get()</code> 方法从XPath选择器返回的结果中获取第一个匹配项，也就是详情页面的URL。</li></ul></li><li><code>yield scrapy.Request(detail_url, callback=self.get_detail, meta=&#123;&quot;info&quot;:item&#125;)</code><ul><li>这行代码创建一个新的Scrapy请求（<code>Request</code>），用于爬取在<code>detail_url</code>中找到的URL。</li><li><code>scrapy.Request(detail_url, ...)</code> 创建一个新的请求对象，其目标是<code>detail_url</code>。</li><li><code>callback=self.get_detail</code> 设置当请求得到响应时应调用的回调方法为<code>get_detail</code>。这意味着，当Scrapy成功访问<code>detail_url</code>并获得响应时，它将自动调用<code>get_detail</code>方法来处理响应。</li><li><code>meta=&#123;&quot;info&quot;:item&#125;</code> 将一个额外的信息字典<code>&#123;&quot;info&quot;: item&#125;</code>传递给回调方法。这通常用于在不同请求之间传递数据。在这里，<code>item</code>对象（可能包含已经提取的某些数据，如电影名、导演、评分等）被传递到详情页面的处理方法中。</li></ul></li><li>在Scrapy中，<code>yield</code>关键字被用于生成请求而不是直接返回它们。这允许Scrapy处理请求队列，并根据可用的资源和设置来调度这些请求。这种方法使得爬虫能够有效地管理大量的并行请求，同时避免过载目标服务器或被封禁。</li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>在编程中，特别是在异步编程和事件驱动编程中，”callback”（回调函数）是一个非常重要的概念。回调函数是传递给另一个函数或方法的函数，它在那个函数或方法执行完某些操作之后被调用。在不同的编程语言和框架中，回调函数的具体实现和使用方式可能有所不同，但其基本概念是相似的。</p><p><strong>回调函数的基本原理</strong></p><ol><li><strong>定义回调函数</strong>: 回调函数是定义的一个函数，它将在未来的某个时间点被调用。这个函数通常定义了在某些操作完成后应该执行的操作。</li><li><strong>将回调函数作为参数传递</strong>: 将这个回调函数作为参数传递给另一个函数或方法。这通常发生在希望在那个函数完成其主要操作后执行一些额外操作的情况下。</li><li><strong>异步操作或事件处理</strong>: 在进行异步操作（如网络请求、文件读写等）或处理事件（如用户输入、定时器触发等）时，回调函数特别有用。在这些情况下，不能立即得到结果，回调函数提供了一种在操作完成时得到通知并执行相关代码的方式。</li></ol><p><strong>回调函数的例子</strong></p><p>在Python中，回调函数的一个常见例子是在多线程或网络请求中使用：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_success</span>(<span class="params">response</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success:&quot;</span>, response.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_error</span>(<span class="params">error</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error:&quot;</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送异步HTTP请求</span></span><br><span class="line">requests.get(<span class="string">&quot;https://www.example.com&quot;</span>, success=on_success, error=on_error)</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>on_success</code>和<code>on_error</code>是回调函数。它们分别在HTTP请求成功时和出错时被调用。</p><p><strong>在Scrapy中的回调函数</strong></p><p>在Scrapy这类网络爬虫框架中，回调函数用于处理从网页请求中返回的响应。例如：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;example_spider&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url=<span class="string">&quot;https://www.example.com&quot;</span>, callback=self.parse)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 处理响应的代码</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>在这里，<code>parse</code>方法是一个回调函数，当Scrapy框架从指定的URL接收到响应时调用。</p><p>总的来说，回调函数是一种在某个操作完成后（通常是异步操作）再执行的函数。它们在事件驱动的程序设计中尤为重要，允许程序在等待一个操作完成时继续执行其他任务，并在适当的时候处理操作结果。</p>    </div>  </div><h6 id="6-分页处理"><a href="#6-分页处理" class="headerlink" title="6. 分页处理"></a>6. 分页处理</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.page_num += <span class="number">1</span></span><br><span class="line">page_url = <span class="string">&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;</span>.<span class="built_in">format</span>(self.page_num*<span class="number">25</span>)</span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(page_url, callback=self.parse)</span><br></pre></td></tr></table></figure></div><ul><li><code>self.page_num += 1</code><ul><li>这行代码将类属性<code>page_num</code>的值增加1。这个属性用于追踪当前爬取的页数。在每次处理完一个页面后，递增<code>page_num</code>以移至下一个页面。</li></ul></li><li><code>page_url = &#39;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#39;.format(self.page_num*25)</code><ul><li>这里构造了下一个页面的URL。</li><li><code>&#39;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#39;</code>是基本的URL格式。豆瓣电影Top 250页面的分页通过URL参数<code>start</code>实现，其中<code>start</code>表示列表的起始位置。</li><li><code>.format(self.page_num*25)</code>用于插入计算后的起始位置。由于每页显示25部电影，那么每递增一页，<code>start</code>的值应增加25。例如，第一页是从0开始（<code>0*25</code>），第二页是从25开始（<code>1*25</code>），依此类推。</li></ul></li><li><code>yield scrapy.Request(page_url, callback=self.parse)</code><ul><li>这行代码生成了一个新的Scrapy请求，用于爬取下一个页面。</li><li><code>scrapy.Request(page_url, callback=self.parse)</code>创建一个新的请求对象，其目标是<code>page_url</code>。</li><li><code>callback=self.parse</code>指定当请求得到响应时，应该调用<code>parse</code>方法来处理该响应。<code>parse</code>是Scrapy爬虫中的标准方法，用于处理和解析响应内容。</li><li>使用<code>yield</code>关键字来生成请求对象，允许Scrapy根据需要来调度和处理这些请求。</li></ul></li><li>在Scrapy中，适当地管理分页是提取多页数据的关键。代码正确地实现了递增页码并构建新页面URL的逻辑。通过在<code>parse</code>方法中重复这个过程，爬虫可以遍历并爬取整个列表的所有页面。</li></ul><h6 id="7-处理结束"><a href="#7-处理结束" class="headerlink" title="7. 处理结束"></a>7. 处理结束</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure></div><ul><li>如果 <code>node_list</code> 为空，说明没有更多的电影信息可以处理，函数返回并结束。</li><li>如果条件不满足（<code>else</code>部分），<code>return</code>语句会被执行。在Python中，<code>return</code>语句用于从函数返回。如果<code>return</code>后没有任何值或表达式，它默认返回<code>None</code>。在这个上下文中，它表示不再继续生成新的请求，爬虫的这个部分将停止执行。</li></ul><p>这个 <code>parse</code> 方法展示了如何在 Scrapy 中处理分页和详情页的链接提取、数据抓取和传递。它有效地结合了 XPath 选择器、Scrapy Item 的使用，以及 Scrapy 的请求和响应机制。</p><h5 id="详情页解析方法-get-detail"><a href="#详情页解析方法-get-detail" class="headerlink" title="详情页解析方法 get_detail"></a>详情页解析方法 get_detail</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_detail</span>(<span class="params">self, response</span>):</span><br><span class="line">    item = DbItem()</span><br><span class="line">    info = response.meta.get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    item.update(info)</span><br><span class="line">    description_list = response.xpath(<span class="string">&#x27;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#x27;</span>).getall()</span><br><span class="line">    description = <span class="string">&#x27;&#x27;</span>.join([des.strip() <span class="keyword">for</span> des <span class="keyword">in</span> description_list])</span><br><span class="line"></span><br><span class="line">    item[<span class="string">&quot;description&quot;</span>] = description</span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></div><h6 id="0-方法定义-1"><a href="#0-方法定义-1" class="headerlink" title="0. 方法定义"></a>0. 方法定义</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_detail</span>(<span class="params">self, response</span>):</span><br></pre></td></tr></table></figure></div><ul><li>这是一个在 Scrapy 爬虫中定义的 <code>get_detail</code> 方法，它是一个回调函数，用于处理电影详情页的响应。</li><li><code>response</code> 参数是 Scrapy 传递给这个方法的响应对象，包含了详情页的数据。</li><li>这个方法定义表明<code>get_detail</code>是一个实例方法，用于处理从一个特定的请求返回的响应。这个方法接收一个参数<code>response</code>，它包含了对应请求的HTTP响应。</li></ul><h6 id="1-初始化和更新-Item"><a href="#1-初始化和更新-Item" class="headerlink" title="1. 初始化和更新 Item"></a>1. 初始化和更新 Item</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item = DbItem()</span><br><span class="line">info = response.meta.get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">item.update(info)</span><br></pre></td></tr></table></figure></div><ul><li><code>item = DbItem()</code>：创建一个 <code>DbItem</code> 对象。<code>DbItem</code> 通常是一个在 Scrapy 项目中定义的 Item 类，用于结构化存储提取的数据。继承自<code>scrapy.Item</code>，用于指定希望收集的数据字段。</li><li><code>info = response.meta.get(&quot;info&quot;)</code>：从响应的 <code>meta</code> 属性中获取传递过来的电影基本信息。这些信息之前在处理列表页时已经被提取并通过 <code>meta</code> 参数传递到这个方法。这里从<code>response.meta</code>中提取了之前传递的元数据。<code>response.meta</code>是一个字典，用于在Scrapy的不同请求之间传递数据。在这个例子中，它被用来传递之前页面上已经抓取的数据。</li><li><code>item.update(info)</code>：将获取到的电影基本信息更新到 <code>item</code> 对象中。这行代码将从上一个页面提取的数据（存储在<code>info</code>字典中）合并到新创建的<code>item</code>对象中。</li></ul><h6 id="2-提取电影描述信息"><a href="#2-提取电影描述信息" class="headerlink" title="2. 提取电影描述信息"></a>2. 提取电影描述信息</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">description_list = response.xpath(<span class="string">&#x27;//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()|//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()&#x27;</span>).getall()</span><br><span class="line">description = <span class="string">&#x27;&#x27;</span>.join([des.strip() <span class="keyword">for</span> des <span class="keyword">in</span> description_list])</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4d3dc2ee-996e-4b93-1c43-5d9e56066700/public"                      width = "500"                ><ul><li><code>response.xpath()</code> 方法用于执行XPath查询。它从响应的HTML中选择指定的元素。</li><li>XPath查询字符串有两部分，通过（并集运算符）连接：<ul><li><code>//div[@id=&quot;link-report&quot;]/span[@class=&quot;all hidden&quot;]/text()</code>: 选取所有<code>id</code>为<code>&quot;link-report&quot;</code>的<code>&lt;div&gt;</code>元素中，类名为<code>&quot;all hidden&quot;</code>的<code>&lt;span&gt;</code>子元素的文本内容。</li><li><code>//div[@id=&quot;link-report&quot;]/span[@property=&quot;v:summary&quot;]/text()</code>: 选取所有<code>id</code>为<code>&quot;link-report&quot;</code>的<code>&lt;div&gt;</code>元素中，<code>property</code>属性为<code>&quot;v:summary&quot;</code>的<code>&lt;span&gt;</code>子元素的文本内容。</li></ul></li><li><code>.getall()</code> 方法获取所有匹配的元素的文本内容，返回一个字符串列表</li><li>将<code>description_list</code>中的所有文本片段合并成一个单一的字符串。</li><li><code>[des.strip() for des in description_list]</code> 是一个列表推导式，用于遍历<code>description_list</code>中的每个元素（<code>des</code>），并对每个元素应用<code>.strip()</code>方法。<code>.strip()</code>方法移除字符串两端的空白字符（包括空格、换行符等）。</li><li><code>&#39;&#39;.join([...])</code> 方法将经过清洁的字符串列表连接成一个单一的字符串。空字符串<code>&#39;&#39;</code>作为连接符，意味着直接将文本片段连在一起，没有额外的字符插入。</li><li>这段代码的作用是从HTML响应中提取电影描述，可能包括多个文本片段，并将它们清洁和合并为一个完整的描述字符串。这种方法在处理包含多个文本块或可选文本块（例如有些电影可能只有一种描述格式）的HTML页面时非常有用。</li></ul><h6 id="3-设置描述并返回-Item"><a href="#3-设置描述并返回-Item" class="headerlink" title="3. 设置描述并返回 Item"></a>3. 设置描述并返回 Item</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item[<span class="string">&quot;description&quot;</span>] = description</span><br><span class="line"><span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></div><ul><li><code>item[&quot;description&quot;] = description</code><ul><li>这行代码将之前提取并合并的描述文本（<code>description</code>）赋值给<code>item</code>对象的<code>&quot;description&quot;</code>字段。</li><li><code>item</code>是一个类似于字典的对象，用于存储提取的数据。在Scrapy中，这通常是一个继承自<code>scrapy.Item</code>的类的实例，用来定义和存储爬取的数据结构。</li><li>这里，<code>&quot;description&quot;</code>字段是之前定义在<code>DbItem</code>（或类似的Item类）中的一个字段，用于保存电影的描述文本。</li></ul></li><li><code>yield item</code><ul><li>使用<code>yield</code>关键字来产生<code>item</code>对象，将其传递给Scrapy的管道系统（Pipelines）。</li><li>在Scrapy中，<code>yield</code>的使用允许框架接管并异步处理这些item对象。这些item随后会通过定义好的管道进行处理，例如进行数据清洗、验证、存储到数据库等操作。</li><li>这种基于生成器的方法使得Scrapy能够有效地处理大量数据，并允许多个item同时在管道中进行处理，从而提高整个爬取和数据处理的效率。</li></ul></li></ul><p>这两行代码的作用是将提取的描述文本保存到一个item对象中，并将这个对象传递给Scrapy的后续处理流程，如管道处理。这是Scrapy爬虫中处理和传递数据的常见模式。</p><h4 id="Items-文件"><a href="#Items-文件" class="headerlink" title="Items 文件"></a>Items 文件</h4><p>定义了一个 Scrapy Item 类，名为 <code>DbItem</code>，用于在 Scrapy 爬虫中存储和组织爬取的数据。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DbItem</span>(scrapy.Item):</span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    movie_name = scrapy.Field()</span><br><span class="line">    director = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br><span class="line">    description = scrapy.Field()</span><br></pre></td></tr></table></figure></div><ul><li><code>import scrapy</code>: 导入 Scrapy 模块，这是使用 Scrapy 框架的基础。</li><li><code>class DbItem(scrapy.Item)</code>: 定义了一个名为 <code>DbItem</code> 的类，该类继承自 <code>scrapy.Item</code>。在 Scrapy 中，<code>Item</code> 类用于定义一种数据结构，使得爬取的数据可以被结构化和标准化。</li><li><code>movie_name = scrapy.Field()</code>: 定义了一个字段 <code>movie_name</code> 来存储电影的名称。使用 <code>scrapy.Field()</code> 表示这是一个用于存储数据的字段。</li><li><code>director = scrapy.Field()</code>: 定义了一个字段 <code>director</code> 用于存储电影的导演信息。</li><li><code>score = scrapy.Field()</code>: 定义了一个字段 <code>score</code> 用于存储电影的评分。</li><li><code>description = scrapy.Field()</code>: 定义了一个字段 <code>description</code> 用于存储电影的详细描述。</li><li>在 Scrapy 爬虫中，<code>Item</code> 类被用来收集和整理爬取的数据。例如，在爬取一个电影网站时，可以使用 <code>DbItem</code> 实例来存储每部电影的相关信息。这样的数据结构化处理使得数据的存储、输出和后续处理变得更加方便和标准化。</li></ul><p><code>DbItem</code> 类是 Scrapy 项目中用于定义和存储特定数据结构的方式。它允许爬虫以一种清晰和一致的方式处理爬取的数据。在这个例子中，<code>DbItem</code> 用于存储电影名称、导演、评分和描述等信息，从而使得数据在 Scrapy 爬虫的整个流程中易于处理和维护。</p><h4 id="Pipelines-文件"><a href="#Pipelines-文件" class="headerlink" title="Pipelines 文件"></a>Pipelines 文件</h4><p>定义了一个 Scrapy 的 <code>Pipeline</code> 类，名为 <code>DbPipeline</code>，用于处理由爬虫提取的数据。在 Scrapy 中，<code>Pipeline</code> 用于数据的清洗、验证和存储。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DbPipeline</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.f = <span class="built_in">open</span>(<span class="string">&#x27;film.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        json_str = json.dumps(<span class="built_in">dict</span>(item), ensure_ascii=<span class="literal">False</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.f.write(json_str)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.f.close()</span><br></pre></td></tr></table></figure></div><h5 id="1-初始化及打开文件"><a href="#1-初始化及打开文件" class="headerlink" title="1. 初始化及打开文件"></a>1. 初始化及打开文件</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">    self.f = <span class="built_in">open</span>(<span class="string">&#x27;film.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li><p><code>class DbPipeline:</code> 定义了一个名为<code>DbPipeline</code>的新类。</p></li><li><p><code>def open_spider(self, spider)</code>: 这个<code>open_spider</code>方法在爬虫开始时被调用。用于进行一些初始化工作。</p></li><li><p><code>self.f = open(&#39;film.txt&#39;,&#39;w&#39;, encoding=&#39;utf-8&#39;)</code>: 这个方法打开一个名为<code>film.txt</code>的文件用于写入（’w’模式），并且指定编码为UTF-8。这是为了确保可以正确写入包含非ASCII字符（如中文）的文本。</p></li><li><p>文件对象被赋值给<code>self.f</code>，这样在这个类的其他方法中也能使用这个文件对象。</p></li></ul><h5 id="2-处理并存储数据"><a href="#2-处理并存储数据" class="headerlink" title="2. 处理并存储数据"></a>2. 处理并存储数据</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">    json_str = json.dumps(<span class="built_in">dict</span>(item), ensure_ascii=<span class="literal">False</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    self.f.write(json_str)</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></div><ul><li><code>def process_item(self, item, spider)</code>: 这个方法会被 Scrapy 框架自动调用，每次爬虫提取出一个 <code>item</code> 时都会执行。<code>process_item</code>方法是管道处理每个item的核心方法。</li><li><code>json_str = json.dumps(dict(item), ensure_ascii=False) + &#39;\n&#39;</code>: 将 <code>item</code> 对象转换成 JSON 字符串。<code>ensure_ascii=False</code> 参数确保非 ASCII 字符（如中文）被正确处理。</li><li><code>self.f.write(json_str)</code>: 将 JSON 字符串写入之前打开的文件。然后，这个JSON字符串（<code>json_str</code>）被写入到前面打开的文件中。每个item占一行，因为在字符串末尾添加了换行符<code>\n</code>。</li><li><code>return item</code>: 返回 <code>item</code>，以便它能够传递到其他可能存在的 pipeline 或最终输出。</li></ul><h5 id="3-关闭文件"><a href="#3-关闭文件" class="headerlink" title="3. 关闭文件"></a>3. 关闭文件</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">    self.f.close()</span><br></pre></td></tr></table></figure></div><ul><li><code>def close_spider(self, spider)</code>: 在爬虫结束时被调用。当爬虫关闭时，Scrapy框架会调用<code>close_spider</code>方法。</li><li><code>self.f.close()</code>: 关闭打开的文件。这是一个重要的步骤，确保数据被完整写入并且文件正常关闭。这个方法关闭了文件对象<code>self.f</code>。这是一个良好的实践，可以确保所有数据都被写入到文件中，并且文件正确地关闭。</li></ul><p>在 Scrapy 项目中，<code>Pipeline</code> 类用于处理从爬虫传递过来的数据。在这个例子中，<code>DbPipeline</code> 负责将每个电影的信息以 JSON 格式保存到一个文本文件中。这样的处理方式适合于数据的持久化存储，例如保存到文件、数据库等。</p><p><code>DbPipeline</code> 类演示了 Scrapy 爬虫中如何使用 pipeline 对提取的数据进行进一步的处理和存储。通过在爬虫启动和关闭时执行相关操作，并在提取数据时进行处理，pipeline 为数据的后续使用提供了一个有效的方式。</p><h4 id="Settings-文件"><a href="#Settings-文件" class="headerlink" title="Settings 文件"></a>Settings 文件</h4><p><code>settings.py</code> 是 Scrapy 项目的配置文件，用于定义爬虫的各种设置。这些设置影响着爬虫的行为方式。</p><p>此处删除了大部分注释</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scrapy settings for db project</span></span><br><span class="line"></span><br><span class="line">BOT_NAME = <span class="string">&#x27;db&#x27;</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">&#x27;db.spiders&#x27;</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">&#x27;db.spiders&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span></span><br><span class="line"><span class="comment">#USER_AGENT = &#x27;db (+http://www.yourdomain.com)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Override the default request headers:</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">  <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure item pipelines</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;db.pipelines.DbPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h5><ul><li><code>BOT_NAME = &#39;db&#39;</code>: 定义了爬虫项目的名称，这里是 <code>&#39;db&#39;</code>。</li><li><code>SPIDER_MODULES = [&#39;db.spiders&#39;]</code>: 指定了包含 Scrapy 爬虫的模块。</li><li><code>NEWSPIDER_MODULE = &#39;db.spiders&#39;</code>: 指定了新爬虫的模板搜索路径。</li></ul><h5 id="用户代理设置"><a href="#用户代理设置" class="headerlink" title="用户代理设置"></a>用户代理设置</h5><ul><li><code>DEFAULT_REQUEST_HEADERS</code>: 这是默认的请求头部设置。在这里，可以设置 <code>Accept</code> 和 <code>Accept-Language</code> 头部，以及用户代理 (<code>User-Agent</code>)。这有助于模仿常规浏览器请求，避免被目标网站识别为爬虫。</li><li><code>ROBOTSTXT_OBEY = False</code>: 这个设置告诉 Scrapy 是否遵守 <code>robots.txt</code> 规则。在这里，它被设置为 <code>False</code>，意味着爬虫将忽略目标网站的 <code>robots.txt</code> 规则。</li></ul><h5 id="Item-Pipeline-设置"><a href="#Item-Pipeline-设置" class="headerlink" title="Item Pipeline 设置"></a>Item Pipeline 设置</h5><ul><li><code>ITEM_PIPELINES</code>: 这个设置定义了项目中启用的 Item Pipeline。在这里，<code>DbPipeline</code> 被设置为处理 item 的 pipeline，<code>300</code> 表示其优先级。</li></ul><h4 id="爬虫项目的目标和请求流程总结"><a href="#爬虫项目的目标和请求流程总结" class="headerlink" title="爬虫项目的目标和请求流程总结"></a>爬虫项目的目标和请求流程总结</h4><h5 id="目标数据"><a href="#目标数据" class="headerlink" title="目标数据"></a>目标数据</h5><ul><li>目标是爬取电影信息以及从次级页面（详情页）获取电影简介。</li></ul><h5 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h5><ul><li><strong>访问一级页面</strong>：爬取电影列表页，提取电影的基本信息和指向详情页的 URL。</li><li><strong>访问次级页面</strong>：访问每部电影的详情页，进一步提取电影的详细简介。</li></ul><h5 id="数据存储和一致性"><a href="#数据存储和一致性" class="headerlink" title="数据存储和一致性"></a>数据存储和一致性</h5><ul><li>由于 Scrapy 是异步的，页面响应的顺序可能与请求发送的顺序不同。因此，使用 <code>meta</code> 参数在请求间传递数据，保证了数据（如电影的基本信息和详细简介）之间的一致性和关联。</li></ul><h2 id="项目案例"><a href="#项目案例" class="headerlink" title="项目案例"></a>项目案例</h2><h3 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h3><ol><li><p>获取腾讯社会招聘的岗位信息</p></li><li><p>要获取信息的URL并不会显示存在页面中因此要通过开发者模式查看，能发现其有众多异步请求且要获取的信息就在其中</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/88ae35cb-20eb-4b88-88aa-47a6b950b400/public"                      width = "500"                ></li><li><p>分析排前的请求，在<code>Fetch/XHR</code>下的<code>Preview</code>可以发现图示请求的数据结构与页面内容近似，因此该页面的URL就应该在这个请求的标头中</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ae0ddfae-1c39-488e-b671-cf052174e300/public"                      width = "500"                ></li><li><p>通过标头构造页面即可开始实施抓取数据，这个URL可以发现拼接了很多参数</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b8e2bf40-9dbd-46e4-417b-39dda1d11900/public"                      width = "500"                ><h3 id="分析规律"><a href="#分析规律" class="headerlink" title="分析规律"></a>分析规律</h3><ol><li>通过分析每页的URL，发现切换页面的规律</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL_1 = <span class="string">&#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=1&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27;</span></span><br><span class="line">URL_2 = <span class="string">&#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702289736331&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=2&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27;</span></span><br></pre></td></tr></table></figure></div><p>可以发现<code>pageIndex</code>是不一样的，一个为1一个为2，那么后续只要利用花括号<code>pageSize=&#123;&#125;</code>传值即可实现页面跳转</p><p>同时可以发现URL都存在<code>api</code>因此其都是为接口数据</p><h3 id="爬取思路"><a href="#爬取思路" class="headerlink" title="爬取思路"></a>爬取思路</h3><ol><li>找到列表页的数据的url</li><li>使用scrapy.Request 方法进行请求</li><li>解析第二步的响应，提取里面的内容</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h4><p>首先在终端输入 <code>scrapy startproject tx</code> 其中<code>tx</code>代表项目名称为腾讯缩写</p><h4 id="2-创建爬虫"><a href="#2-创建爬虫" class="headerlink" title="2. 创建爬虫"></a>2. 创建爬虫</h4><p>然后输入<code>scrapy genspider tencent_data careers.tencent.com</code> 创建爬虫<code>tencent_data</code> 其爬取域名为<code>careers.tencent.com</code></p><h4 id="3-编辑爬虫"><a href="#3-编辑爬虫" class="headerlink" title="3. 编辑爬虫"></a>3. 编辑爬虫</h4><p>在生成<code>tencent_data.py</code>的爬虫文件下继承自<code>scrapy.Spider</code>命名为<code>TencentDataSpider</code>的类中编辑需要构造的URL，在原本的URL内修改参数<code>pageIndex=1</code>为<code>pageIndex=&#123;&#125;</code>以便分页（页面跳转），将<code>url_data</code>格式化字符串中的<code>pageIndex</code>参数设为1，生成第一页的URL，作为爬虫开始爬取的起始点。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TencentDataSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;tencent_data&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;careers.tencent.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">    url_data = <span class="string">&#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27;</span></span><br><span class="line"></span><br><span class="line">    start_urls = [url_data.<span class="built_in">format</span>(<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><h4 id="4-处理列表列"><a href="#4-处理列表列" class="headerlink" title="4. 处理列表列"></a>4. 处理列表列</h4><p>在<code>parse</code>方法中添加一个循环以确定要爬取的页面数量，可以通过循环<code>for</code>来进行。<code>parse</code> 是Scrapy爬虫中默认的回调方法，用于处理响应。该方法通过循环生成接下来四页的URL（从第1页到第4页）。对于每一页，它创建并产生一个新的Scrapy请求 (<code>scrapy.Request</code>)，并指定回调函数为<code>self.parse_data</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TencentDataSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;tencent_data&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;careers.tencent.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">    url_data = <span class="string">&#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27;</span></span><br><span class="line"></span><br><span class="line">    start_urls = [url_data.<span class="built_in">format</span>(<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">            next_page_url = self.url_data.<span class="built_in">format</span>(i)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_page_url, callback=self.parse_data)</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在提供的<code>parse</code>方法中，<code>response</code>参数实际上没有被使用。这是因为该方法的主要目的是生成后续页面的URL，并对每个URL发起新的请求，而不是处理<code>response</code>中的数据。</p><p>在常规的Scrapy爬虫中，<code>parse</code>方法通常用于处理响应，从中提取数据或发现新的URL来跟进。但在这个特定的例子中，<code>parse</code>方法仅用于根据初始响应生成一系列后续页面的请求。实际处理这些页面的响应内容的任务被委托给了另一个方法<code>parse_data</code>（在后续定义）。这意味着在这个特定的<code>parse</code>实现中，初始的<code>response</code>对象不包含需要立即处理的相关数据，其主要作用是触发爬虫开始执行后续页面的请求。</p>    </div>  </div><p>显然请求的文件是JSON文件，因此需要编辑方法处理从网页请求中返回的JSON格式的响应。这个方法特别适用于处理返回JSON数据的API响应。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TencentDataSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;tencent_data&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;careers.tencent.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">    url_data = <span class="string">&#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27;</span></span><br><span class="line"></span><br><span class="line">    start_urls = [url_data.<span class="built_in">format</span>(<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">            next_page_url = self.url_data.<span class="built_in">format</span>(i)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_page_url, callback=self.parse_data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_data</span>(<span class="params">self, response</span>):</span><br><span class="line">        dict_data = response.json() <span class="comment"># json.loads(response.text)</span></span><br><span class="line">        <span class="built_in">print</span>(dict_data)</span><br></pre></td></tr></table></figure></div><ul><li><code>parse_data</code>是一个实例方法，与<code>parse</code>方法类似，它是Scrapy框架用于处理响应的回调函数。不同的是，这个方法专门用于处理JSON响应。</li><li><code>response</code>参数是一个包含HTTP响应数据的对象。在Scrapy中，这个对象通常包括响应的内容和其他元数据。</li><li><code>dict_data = response.json()</code>这一行是核心功能。<code>response.json()</code>方法将响应的内容（假定是JSON格式）解析成Python字典。这允许以Python原生的方式访问JSON响应中的数据。</li><li>在将JSON响应解析为字典后，可以进一步处理这些数据。例如从字典中提取特定的字段，并将它们存储在Scrapy的Item对象中，或者直接进行数据清洗、转换等操作。</li></ul><p>在修改<code>settings.py</code>配置文件的参数为正确后进行调试，发现其<code>response</code>依旧能返回<code>200</code>，然而实际输入的URL和抓取时间戳<code>timestamp</code>并不一样，这说明其对时间戳并不敏感。</p><p>如果敏感且失败则需要构造时间戳<code>int(time.time() * 1000)</code></p><p>进行分析调试结果<code>response.json()</code> 返回的数据结构是一个字典且具有数据</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dc9f98ec-a482-43d8-c3d9-58ce71096b00/public"                      width = "500"                ><p>但是由于这样数据有太多且杂乱无章，因此在获取数据的时候就进行部分的过滤，只获取<code>Data</code>下的<code>Posts</code>里的部分数据即可，例如名称，地址，时间，详情URL等</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/72d94aa2-a334-4558-2a96-f36c2d1cf500/public"                      width = "500"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TencentDataSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;tencent_data&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;careers.tencent.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">    url_data = <span class="string">&#x27;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1702285787290&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=au&#x27;</span></span><br><span class="line"></span><br><span class="line">    PostURL = <span class="string">&#x27;https://careers.tencent.com/tencentcareer/api/post/ByPostId?timestamp=1701864924030&amp;postId=&#123;&#125;&amp;language=zh-cn&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    start_urls = [url_data.<span class="built_in">format</span>(<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">            next_page_url = self.url_data.<span class="built_in">format</span>(i)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_page_url, callback=self.parse_data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_data</span>(<span class="params">self, response</span>):</span><br><span class="line">        dict_data = response.json().get(<span class="string">&quot;Data&quot;</span>).get(<span class="string">&quot;Posts&quot;</span>) <span class="comment"># json.loads(response.text)</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> dict_data:</span><br><span class="line">            item = &#123;&#125;</span><br><span class="line">            item[<span class="string">&#x27;RecruitPostName&#x27;</span>] = data.get(<span class="string">&#x27;RecruitPostName&#x27;</span>)</span><br><span class="line">            item[<span class="string">&#x27;LocationName&#x27;</span>] = data.get(<span class="string">&#x27;LocationName&#x27;</span>)</span><br><span class="line">            item[<span class="string">&#x27;LastUpdateTime&#x27;</span>] = data.get(<span class="string">&#x27;LastUpdateTime&#x27;</span>)</span><br><span class="line">            item[<span class="string">&#x27;CategoryName&#x27;</span>] = data.get(<span class="string">&#x27;CategoryName&#x27;</span>)</span><br><span class="line">            PostId = data.get(<span class="string">&#x27;PostId&#x27;</span>)</span><br><span class="line">detail_url = self.PostURL.<span class="built_in">format</span>(PostId)</span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(detail_url, callback=self.parse_post_detail, meta=&#123;<span class="string">&#x27;info&#x27;</span>: item&#125;)</span><br></pre></td></tr></table></figure></div><ul><li><code>response.json()</code>将返回的JSON数据转换为Python字典。</li><li><code>.get(&quot;Data&quot;).get(&quot;Posts&quot;)</code>从这个字典中获取<code>Data</code>键对应的值，然后从<code>Data</code>中获取<code>Posts</code>键对应的值。JSON结构是<code>&#123;&quot;Data&quot;: &#123;&quot;Posts&quot;: [...]&#125;&#125;</code>，这将得到包含职位信息的列表。</li><li>遍历<code>dict_data</code>列表中的每个元素（每个元素代表一个职位）。</li><li>对于每个职位，创建一个新的字典<code>item</code>，并从<code>data</code>中提取相关字段。</li><li>使用<code>PostId</code>来格式化<code>self.PostURL</code>字符串，以创建指向每个职位详情页的URL。</li><li><code>item = &#123;&#125;</code>: 这行代码创建了一个空字典<code>item</code>，用于存储从每个职位信息中提取的数据。这是一种常见的在爬虫中收集数据的方法。</li><li><code>self.PostURL</code>是在访问当前类实例（在这种情况下是<code>TencentDataSpider</code>的实例）的<code>PostURL</code>属性。这意味着<code>PostURL</code>是这个类的实例属性，而非一个局部变量或一个类变量（类变量将会使用类名来访问，比如<code>TencentDataSpider.PostURL</code>）。</li><li>从<code>data</code>字典中获取<code>PostId</code>值，然后使用这个<code>PostId</code>来格式化<code>self.PostURL</code>字符串。</li><li><code>PostURL</code>  为 <code>self.PostURL.format(PostId)</code>使用了<code>format</code>方法来插入<code>PostId</code>进行构造</li><li>格式化后的URL被存储在<code>detail_url</code>变量中。然后，这个URL被用来生成一个新的请求，该请求被发送到<code>parse_post_detail</code>方法（这是一个假定的方法，用于处理每个职位详情页面的响应）<ul><li><strong><code>scrapy.Request</code></strong>:<ul><li>这是Scrapy用来创建新HTTP请求的类。</li><li><code>detail_url</code>是这个新请求的目标URL。这个URL通常是从当前页面提取的，指向一个需要进一步爬取的页面。</li></ul></li><li><strong><code>callback=self.parse_post_detail</code></strong>:<ul><li><code>callback</code>参数指定了Scrapy在收到此请求的响应后应该调用的方法。</li><li><code>self.parse_post_detail</code>是定义的爬虫类中的一个方法。当Scrapy处理<code>detail_url</code>的响应时，它会将响应数据传递给<code>parse_post_detail</code>方法。</li></ul></li><li><strong><code>meta=&#123;&#39;info&#39;: item&#125;</code></strong>:<ul><li><code>meta</code>是一个字典，用于在Scrapy的不同请求之间传递额外的数据。</li><li>在这个例子中，<code>meta</code>字典包含一个键<code>&#39;info&#39;</code>，其值为<code>item</code>。这意味着可以在<code>parse_post_detail</code>方法中通过<code>response.meta[&#39;info&#39;]</code>来访问这个<code>item</code>对象。</li><li>这种方式在请求链中保持状态或传递数据时非常有用。</li></ul></li><li><strong><code>yield</code></strong>:<ul><li>使用<code>yield</code>关键字来生成请求对象。在Scrapy中，<code>yield</code>的使用使得框架可以接管并异步处理这些请求。</li><li>这允许Scrapy根据需要进行请求的调度，而不是立即发出请求，从而更有效地管理网络资源和避免对目标网站造成过大压力。</li></ul></li></ul></li></ul><h4 id="5-处理详情页和Items-文件"><a href="#5-处理详情页和Items-文件" class="headerlink" title="5. 处理详情页和Items 文件"></a>5. 处理详情页和Items 文件</h4><p>随后定义<code>parse_post_detail</code>方法和构造<code>items.py</code>文件下的类属性</p><p><code>tencent_data.py</code>:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_post_detail</span>(<span class="params">self, response</span>):</span><br><span class="line">    item = TxItem()</span><br><span class="line">    info = response.meta.get(<span class="string">&#x27;info&#x27;</span>)</span><br><span class="line">    item.update(info)</span><br><span class="line">    dict_data = response.json()</span><br><span class="line">    item[<span class="string">&#x27;Requirement&#x27;</span>] = dict_data.get(<span class="string">&quot;Data&quot;</span>).get(<span class="string">&#x27;Requirement&#x27;</span>).replace(<span class="string">&#x27;\r\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    item[<span class="string">&#x27;Responsibility&#x27;</span>] = dict_data.get(<span class="string">&quot;Data&quot;</span>).get(<span class="string">&#x27;Responsibility&#x27;</span>).replace(<span class="string">&#x27;\r\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></div><p><code>items.py</code>:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># https://docs.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxItem</span>(scrapy.Item):</span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    RecruitPostName = scrapy.Field()</span><br><span class="line">    LocationName = scrapy.Field()</span><br><span class="line">    LastUpdateTime = scrapy.Field()</span><br><span class="line">    CategoryName = scrapy.Field()</span><br><span class="line">    Requirement = scrapy.Field()</span><br><span class="line">    Responsibility = scrapy.Field()</span><br></pre></td></tr></table></figure></div><p>然后调试检查查看传值是否成功</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f9d7d000-374c-429b-3e8b-d998e8e61000/public"                      width = "500"                >  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p>调试处理详情页相关方法前需要同时配置Items 文件，不然无法传值</p>  </div><h4 id="6-编辑Pipelines"><a href="#6-编辑Pipelines" class="headerlink" title="6. 编辑Pipelines"></a>6. 编辑Pipelines</h4><p>在<code>Settings.py</code>文件激活Pipelines后，配置Pipelines文件</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># useful for handling different item types with a single interface</span></span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxPipeline</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tencent.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="built_in">str</span>(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></div><p>在Scrapy的管道（Pipeline）中，可以选择用不同的方式来处理文件的打开和关闭。</p><ol><li><strong>类定义</strong>:<ul><li><code>class TxPipeline:</code> 定义了一个名为<code>TxPipeline</code>的新类。</li><li>这个类是Scrapy的一个管道，它必须实现<code>process_item</code>方法。</li></ul></li><li><strong><code>process_item</code>方法</strong>:<ul><li><code>def process_item(self, item, spider):</code> 是管道处理每个爬取的项目（item）的方法。</li><li>每当爬虫提取出数据并生成<code>item</code>对象时，Scrapy框架会自动调用这个方法，并将<code>item</code>对象和<code>spider</code>对象作为参数传递给它。</li></ul></li><li><strong>文件写入操作</strong>:<ul><li><code>with open(&#39;tencent.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as f:</code> 使用<code>with</code>语句打开文件<code>tencent.txt</code>。如果文件不存在，将会创建它。文件以追加模式（<code>&#39;a&#39;</code>）打开，意味着新写入的内容会被添加到文件的末尾，而不是覆盖原有内容。文件以<code>utf-8</code>编码打开，这对于写入非ASCII字符（例如中文）很重要。</li><li><code>f.write(str(item))</code> 将<code>item</code>对象转换为字符串，并写入文件。这里需要注意的是，<code>str(item)</code>可能不会以最优雅的格式输出，特别是如果<code>item</code>包含多个字段或嵌套结构时。在实际应用中，可能需要更精细的格式化方法，比如使用<code>json.dumps</code>来生成更可读的JSON格式。</li></ul></li><li><strong>返回项目</strong>:<ul><li><code>return item</code>：在处理完项目后，管道返回<code>item</code>对象。这允许同一个<code>item</code>被多个管道依次处理。在Scrapy中，项目（items）可以通过多个管道传递，每个管道都可以执行一些操作（如清洗数据、去重、写入数据库等）。</li></ul></li></ol><p><strong>使用<code>with</code>语句:</strong></p><p>在<code>TxPipeline</code>类中，<code>process_item</code>方法使用了<code>with</code>语句来打开文件：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tencent.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">str</span>(item))</span><br></pre></td></tr></table></figure></div><ul><li><strong><code>with</code>语句</strong>：Python中的<code>with</code>语句用于包裹执行需要资源管理的代码块，比如文件操作。<code>with</code>语句可以确保文件在使用完毕后被正确关闭，即使在处理文件过程中发生错误也是如此。</li><li><strong>优点</strong>：使用<code>with</code>语句的主要优点是它会自动处理文件的关闭。这种方式在每次<code>process_item</code>被调用时打开文件，写入数据，然后立即关闭文件，非常适合写入少量数据。</li><li><strong>缺点</strong>：如果<code>process_item</code>被频繁调用，这种方式可能会导致性能问题，因为每次调用都会打开和关闭文件。</li></ul><p><strong>使用<code>open_spider</code>和<code>close_spider</code>方法：</strong></p><p>在之前的案例<code>DbPipeline</code>类中，文件的打开和关闭是在<code>open_spider</code>和<code>close_spider</code>方法中处理的：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">    self.f = <span class="built_in">open</span>(<span class="string">&#x27;dbtest1result.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">    self.f.close()</span><br></pre></td></tr></table></figure></div><ul><li><strong><code>open_spider</code>和<code>close_spider</code>方法</strong>：这两个方法分别在爬虫开始时和结束时被调用。在这里，文件在爬虫启动时被打开，并在爬虫关闭时被关闭。</li><li><strong>优点</strong>：这种方式对于处理大量数据更有效，因为它在整个爬虫过程中只打开和关闭文件一次。这减少了文件操作的开销，提高了性能。</li><li><strong>缺点</strong>：如果爬虫在执行过程中出现异常并意外终止，可能导致文件没有正确关闭。这可能会导致数据丢失或文件损坏。</li><li>如果爬虫产生的数据量不大，或者更关心代码的简洁性，使用<code>with</code>语句是一个很好的选择。</li><li>如果爬虫产生大量数据，或者希望减少文件操作的开销，使用<code>open_spider</code>和<code>close_spider</code>方法可能更合适。</li></ul><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>最后运行，产出文件<code>tencent.txt</code>且具有相应的值则成功</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/980e1a03-5250-421d-819a-35e0effab800/public"                      width = "500"                ><h3 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h3><p>首先在Ubuntu的<code>MySQL</code>创建一个数据库叫<code>tx</code></p><p><code>mysql&gt; create database tx;</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c8f0d32b-0784-4675-0f4d-7607e011f100/public"                      width = "500"                ><p>随后检查是否创建成功<code>mysql&gt; show databases;</code>:</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/82901ac0-b156-4034-eb67-4849826d7f00/public"                      width = "500"                ><p>然后切换数据库并检查内容：</p><p><code>use tx;</code></p><p><code>show tables;</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4c20a872-96e7-4874-39ef-88cbd76a0500/public"                      width = "500"                ><p>检查无误后按照<code>items.py</code>文件下的<code>TxItem</code>类创建表格即可：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 爬虫存数据  必须要先有表格才能进行数据的增加</span><br><span class="line">create table txzp(</span><br><span class="line">    # 主键</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">RecruitPostName varchar(50),</span><br><span class="line">    LocationName varchar(50),</span><br><span class="line">    LastUpdateTime varchar(50),</span><br><span class="line">    CategoryName  varchar(50),</span><br><span class="line">    Requirement text,</span><br><span class="line">    Responsibility text</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cb576bde-dc2c-4b41-03a2-ac981a3a6f00/public"                      width = "500"                ><p>创建表格后通过<code>show tables;</code>查看当前数据库的表格内容</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c6f9d98f-1567-488d-d2ca-ff51a7512400/public"                      width = "500"                ><p>使用<code>desc txzp;</code> 查看 <code>txzp</code> 表格内的内容属性</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fed1f6a3-b5b8-4a8b-a549-a7d7c274f300/public"                      width = "500"                ><h4 id="建立测试文件"><a href="#建立测试文件" class="headerlink" title="建立测试文件"></a>建立测试文件</h4><p><code>tx_debug.py</code>:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立数据库连接</span></span><br><span class="line"><span class="comment"># host: 数据库服务器地址，这里设置为&#x27;localhost&#x27;表示数据库服务在本地</span></span><br><span class="line"><span class="comment"># port: 数据库服务端口，默认MySQL端口为3306</span></span><br><span class="line"><span class="comment"># user: 用户名，这里使用&#x27;yiuhang_test&#x27;</span></span><br><span class="line"><span class="comment"># password: 用户密码，这里为&#x27;Test123..&#x27;</span></span><br><span class="line"><span class="comment"># db: 要连接的数据库名，这里为&#x27;tx&#x27;</span></span><br><span class="line"><span class="comment"># charset: 设置字符集，这里使用&#x27;utf8&#x27;</span></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">                       port=<span class="number">3306</span>,</span><br><span class="line">                       user=<span class="string">&#x27;yiuhang&#x27;</span>,</span><br><span class="line">                       password=<span class="string">&#x27;Test123..&#x27;</span>,</span><br><span class="line">                       db=<span class="string">&#x27;tx&#x27;</span>,</span><br><span class="line">                       charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(conn)  <span class="comment"># 打印连接对象，用于验证是否连接成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个cursor对象，用于执行查询和获取结果</span></span><br><span class="line">curs = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在此处添加数据库操作的CRUD（创建、读取、更新、删除）逻辑</span></span><br><span class="line"><span class="comment"># 例如：curs.execute(&quot;SELECT * FROM your_table&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交事务，对于更改数据库的操作（INSERT, UPDATE, DELETE），需要调用commit()来提交更改</span></span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭cursor和连接</span></span><br><span class="line">curs.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></div><ul><li>这段脚本主要用于建立与MySQL数据库的连接，执行一些数据库操作（CRUD逻辑），然后关闭连接。</li><li><code>pymysql.connect()</code> 函数用于创建与MySQL数据库的连接。</li><li><code>conn.cursor()</code> 方法创建一个游标对象，该对象可以用来执行SQL语句并获取结果。</li><li>数据库的实际操作（如查询、插入数据等）需要在获取游标后进行。</li><li>执行修改数据库内容的操作（如INSERT, UPDATE, DELETE）后，需要调用 <code>conn.commit()</code> 来提交这些更改。</li><li>最后，使用 <code>curs.close()</code> 和 <code>conn.close()</code> 关闭游标和连接，以释放资源。</li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在运行测试文件前，如果使用虚拟机需要检查3306端口是否已经让虚拟机和主机映射，否则会产生 <code>Mysql Python Connector No connection could be made because the target machine actively refused it</code> 的报错。</p><p>当在虚拟机（例如使用VMware）中运行应用程序（如数据库服务器）并希望从主机（物理机器）访问时，需要进行端口映射。这是因为虚拟机通常运行在与主机隔离的网络环境中。端口映射确保从主机到虚拟机的网络通信能够正确进行。</p><p><strong>解释端口映射</strong></p><ol><li><strong>为什么需要端口映射</strong>:<ul><li>虚拟机通常在私有网络中运行，这意味着它们对主机网络而言是不可见的。</li><li>端口映射使得主机可以通过指定的端口访问虚拟机中的服务。</li></ul></li><li><strong>示例解释</strong>:<ul><li><strong>MySQL（端口3306）</strong>: 假设在虚拟机中运行MySQL服务器，它默认监听3306端口。要从主机上的应用程序连接到这个MySQL服务器，需要将虚拟机的3306端口映射到主机的某个端口（也可以是3306）。</li><li><strong>SSH（端口22）</strong>: 同理，如果想要通过SSH连接到虚拟机，需要将虚拟机的22端口映射到主机的某个端口（也可以是22）。</li></ul></li></ol><p><strong>端口映射的步骤</strong></p><ol><li>打开VMware的虚拟网络编辑器。</li><li>选择用于虚拟机的网络适配器（通常是NAT模式）。</li><li>进入NAT设置，然后设置端口转发规则。</li><li>添加规则：指定主机端口，目标IP（虚拟机IP）和虚拟机端口。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0bf96745-e6e2-46a8-207d-c7b8fc3b4b00/public"                      width = "500"                ><p><strong>如果是服务器而非虚拟机</strong></p><ul><li><strong>物理服务器</strong>:<ul><li>如果数据库运行在物理服务器上，通常不需要端口映射，因为服务器与本地机器或其他服务器都在同一网络或可通过互联网直接访问。</li><li>需要注意的是安全设置，如防火墙规则，确保只有授权的客户端能够访问特定端口。</li></ul></li><li><strong>云服务器</strong>:<ul><li>在云平台（如AWS、Azure）上，可能需要配置安全组或网络安全规则来允许特定端口（如3306）的流量。</li><li>这类似于在物理服务器上设置防火墙规则。</li></ul></li></ul><p>在所有情况下，重要的是确保只有信任的客户端能够访问敏感服务（如数据库服务器），并且采用强密码和加密连接（如SSL）来保护数据安全。</p>    </div>  </div><h4 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h4><h5 id="1-在-settings-py-中配置MySQL信息"><a href="#1-在-settings-py-中配置MySQL信息" class="headerlink" title="1. 在 settings.py 中配置MySQL信息"></a>1. 在 settings.py 中配置MySQL信息</h5><p>在Scrapy项目的<code>settings.py</code>文件中，配置数据库连接信息。这是一个字典，包含连接数据库所需的所有信息。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置mysql链接信息</span></span><br><span class="line">DATABASE_CONFIG = &#123;</span><br><span class="line">   <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;mysql&#x27;</span>, <span class="comment"># 使用的是哪一个数据库类型</span></span><br><span class="line">   <span class="string">&#x27;config&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>,  <span class="comment"># 数据库服务器地址</span></span><br><span class="line">      <span class="string">&#x27;port&#x27;</span>: <span class="number">3306</span>,         <span class="comment"># 数据库服务器端口，MySQL默认为3306</span></span><br><span class="line">      <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;yiuhang&#x27;</span>,  <span class="comment"># 数据库用户名</span></span><br><span class="line">      <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Test123..&#x27;</span>, <span class="comment"># 数据库密码</span></span><br><span class="line">      <span class="string">&#x27;db&#x27;</span>: <span class="string">&#x27;tx&#x27;</span>,              <span class="comment"># 数据库名</span></span><br><span class="line">      <span class="string">&#x27;charset&#x27;</span>: <span class="string">&#x27;utf8&#x27;</span>,       <span class="comment"># 数据库编码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="2-在-pipelines-py-中创建MySQL存储的类"><a href="#2-在-pipelines-py-中创建MySQL存储的类" class="headerlink" title="2. 在 pipelines.py 中创建MySQL存储的类"></a>2. 在 pipelines.py 中创建MySQL存储的类</h5><p>在<code>pipelines.py</code>文件中，创建一个Pipeline类，该类负责在爬虫开始时连接数据库，在处理每个item时存储数据，以及在爬虫结束时关闭数据库连接。注释掉之前的配置。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxzpPipeline</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        <span class="comment"># 此方法在爬虫开启时调用</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        <span class="comment"># 对每个爬取的item调用此方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        <span class="comment"># 此方法在爬虫关闭时调用</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><h5 id="3-注册Pipeline"><a href="#3-注册Pipeline" class="headerlink" title="3. 注册Pipeline"></a>3. 注册Pipeline</h5><p>在<code>settings.py</code>文件中，将Pipeline添加到<code>ITEM_PIPELINES</code>设置中。这里的数字表示优先级，范围是0到1000。注释掉之前的配置。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&quot;tx.pipelines.TxzpPipeline&quot;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="4-编写连接MySQL的逻辑"><a href="#4-编写连接MySQL的逻辑" class="headerlink" title="4. 编写连接MySQL的逻辑"></a>4. 编写连接MySQL的逻辑</h5><p>在<code>TxzpPipeline</code>类中，实现数据库连接和关闭逻辑。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxzpPipeline</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在爬虫开启时调用此方法，用于建立数据库连接。</span></span><br><span class="line"><span class="string">        此方法从spider的设置中获取数据库配置信息，并建立连接。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从爬虫的设置中获取数据库配置</span></span><br><span class="line">        data_config = spider.settings.get(<span class="string">&quot;DATABASE_CONFIG&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查配置类型是否为MySQL，确保我们使用正确的配置</span></span><br><span class="line">        <span class="keyword">if</span> data_config.get(<span class="string">&#x27;type&#x27;</span>) == <span class="string">&#x27;mysql&#x27;</span>:</span><br><span class="line">            <span class="comment"># 使用提供的配置参数建立MySQL连接</span></span><br><span class="line">            self.conn = pymysql.connect(**data_config.get(<span class="string">&#x27;config&#x27;</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 创建一个数据库操作游标</span></span><br><span class="line">            self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        对每个从爬虫爬取的item调用此方法。</span></span><br><span class="line"><span class="string">        这里可以添加将item保存到数据库的逻辑。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 示例：保存逻辑（需实现）</span></span><br><span class="line">        <span class="comment"># sql = &quot;INSERT INTO table_name (column1, column2) VALUES (%s, %s)&quot;</span></span><br><span class="line">        <span class="comment"># self.cursor.execute(sql, (item[&#x27;field1&#x27;], item[&#x27;field2&#x27;]))</span></span><br><span class="line">        <span class="comment"># self.conn.commit()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在爬虫结束时调用此方法，用于关闭数据库连接。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭数据库操作游标</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭数据库连接</span></span><br><span class="line">        self.conn.close()</span><br></pre></td></tr></table></figure></div><ol><li><strong>open_spider 方法</strong>：<ul><li>在爬虫启动时被Scrapy框架自动调用。</li><li>从<code>spider</code>的设置 (<code>settings.py</code>) 中获取名为<code>DATABASE_CONFIG</code>的数据库配置信息。</li><li>如果配置类型是MySQL（<code>&#39;type&#39;: &#39;mysql&#39;</code>），则使用这些配置信息（如主机、端口、用户名、密码等）建立数据库连接。</li><li>创建一个用于执行数据库操作的游标。</li><li>方法定义：<code>open_spider(self, spider)</code><ul><li><strong>作用</strong>：<code>open_spider</code>是一个特殊的Scrapy方法，它在爬虫启动时自动调用。这是设置爬虫运行前所需资源的理想位置，例如建立数据库连接。</li><li><strong>参数</strong>：<code>self</code>指向类的实例，而<code>spider</code>是当前运行的爬虫实例。通过<code>spider</code>，可以访问Scrapy项目的设置和其他与爬虫相关的属性。</li></ul></li><li>获取数据库配置：<code>data_config = spider.settings.get(&quot;DATABASE_CONFIG&quot;)</code><ul><li><strong>作用</strong>：这一行从Scrapy的<code>settings.py</code>文件中获取数据库配置信息。将配置放在<code>settings.py</code>中可以集中管理配置，并在需要时轻松更改，而无需修改代码本身。</li><li><strong>为什么重要</strong>：这种做法增加了代码的灵活性和可维护性，因为可以在不同环境（如开发、测试、生产）中使用不同的数据库配置，而无需更改代码。</li></ul></li><li>检查配置类型：<code>if data_config.get(&#39;type&#39;) == &#39;mysql&#39;:</code></li><li><strong>作用</strong>：这个条件检查确保从<code>settings.py</code>中获取的配置是为MySQL数据库设计的。这是一个安全措施，以防配置被错误地设置。</li><li><strong>为什么重要</strong>：在可能有多种数据库配置的情况下（例如MySQL、PostgreSQL等），这个检查确保Pipeline使用正确的配置。这有助于避免运行时错误和配置混淆。</li><li>建立MySQL连接：<code>self.conn = pymysql.connect(**data_config.get(&#39;config&#39;))</code><ul><li><strong>作用</strong>：这行代码使用<code>pymysql</code>模块建立到MySQL数据库的连接。<code>**data_config.get(&#39;config&#39;)</code>是一个字典解包操作，它将配置字典中的键值对作为参数传递给<code>pymysql.connect</code>函数。</li><li><strong>为什么重要</strong>：建立数据库连接是进行数据库操作的首要步骤。使用<code>pymysql</code>模块可以方便地与MySQL数据库交互。这种方法的优点是可以直接从配置文件中读取连接信息，提高了代码的可读性和可维护性。</li></ul></li><li>创建数据库游标：<code>self.cursor = self.conn.cursor()</code><ul><li><strong>作用</strong>：创建一个数据库游标对象，该对象允许在数据库中执行SQL命令并处理结果。</li><li><strong>为什么重要</strong>：游标是执行和管理数据库操作的关键。它不仅允许执行SQL语句，还能帮助有效地检索查询结果。在Scrapy中，通常会在<code>process_item</code>方法中使用此游标执行数据库操作。</li></ul></li></ul></li><li><strong>process_item 方法</strong>：<ul><li>对爬虫爬取的每个item调用此方法。</li><li>这是数据处理和保存的主要地方。在这个方法中，可以编写将爬取的数据（<code>item</code>）保存到MySQL数据库的逻辑。</li><li>在这个示例中，该方法仅返回<code>item</code>，需要根据具体需求来实现数据插入的逻辑。</li></ul></li><li><strong>close_spider 方法</strong>：<ul><li>在爬虫结束时被Scrapy框架自动调用。</li><li>关闭数据库游标和连接，确保释放资源。</li></ul></li></ol><h5 id="5-编写存储逻辑"><a href="#5-编写存储逻辑" class="headerlink" title="5.编写存储逻辑"></a>5.编写存储逻辑</h5><p>实现<code>process_item</code>方法以将每个item存储到MySQL数据库。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">    <span class="comment"># 定义插入数据的SQL语句</span></span><br><span class="line">    sql = <span class="string">&quot;INSERT INTO txzp(RecruitPostName, LocationName, LastUpdateTime, CategoryName, Requirement, Responsibility) VALUES(%s,%s,%s,%s,%s,%s)&quot;</span></span><br><span class="line">    params = [</span><br><span class="line">        item.get(<span class="string">&#x27;RecruitPostName&#x27;</span>),</span><br><span class="line">        item.get(<span class="string">&#x27;LocationName&#x27;</span>),</span><br><span class="line">        item.get(<span class="string">&#x27;LastUpdateTime&#x27;</span>),</span><br><span class="line">        item.get(<span class="string">&#x27;CategoryName&#x27;</span>),</span><br><span class="line">        item.get(<span class="string">&#x27;Requirement&#x27;</span>),</span><br><span class="line">        item.get(<span class="string">&#x27;Responsibility&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">    self.cursor.execute(sql, params)</span><br><span class="line">    self.conn.commit()</span><br></pre></td></tr></table></figure></div><h6 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a><strong>方法定义</strong></h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br></pre></td></tr></table></figure></div><ul><li><code>process_item</code>：这是Scrapy框架中Pipeline对象的一个核心方法，用于处理从爬虫传递过来的每个item。</li><li><code>self</code>：指向当前类（<code>TxzpPipeline</code>）的实例。</li><li><code>item</code>：这是一个从爬虫传递到Pipeline的数据项。它通常是一个类似字典的对象，包含了爬虫提取的数据。</li><li><code>spider</code>：引用当前的爬虫实例，允许访问爬虫特定的功能或数据。</li></ul><h6 id="SQL-语句的定义"><a href="#SQL-语句的定义" class="headerlink" title="SQL 语句的定义"></a>SQL <strong>语句的定义</strong></h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;INSERT INTO txzp(RecruitPostName, LocationName, LastUpdateTime, CategoryName, Requirement, Responsibility) VALUES(%s,%s,%s,%s,%s,%s)&quot;</span></span><br></pre></td></tr></table></figure></div><ul><li>这行代码定义了一个SQL插入语句，用于将数据插入到名为<code>txzp</code>的MySQL表中。</li><li><code>INSERT INTO txzp</code>：指定要插入数据的表名。</li><li><code>(RecruitPostName, LocationName, LastUpdateTime, CategoryName, Requirement, Responsibility)</code>：这些是表中的列名，将为这些列插入数据。</li><li><code>VALUES(%s,%s,%s,%s,%s,%s)</code>：这是参数化的查询部分，<code>%s</code>是占位符，用于在执行时插入实际的数据值。</li></ul><h6 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a><strong>准备数据</strong></h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">params = [</span><br><span class="line">    item.get(<span class="string">&#x27;RecruitPostName&#x27;</span>),</span><br><span class="line">    item.get(<span class="string">&#x27;LocationName&#x27;</span>),</span><br><span class="line">    item.get(<span class="string">&#x27;LastUpdateTime&#x27;</span>),</span><br><span class="line">    item.get(<span class="string">&#x27;CategoryName&#x27;</span>),</span><br><span class="line">    item.get(<span class="string">&#x27;Requirement&#x27;</span>),</span><br><span class="line">    item.get(<span class="string">&#x27;Responsibility&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><ul><li>这部分代码创建了一个列表<code>params</code>，包含了要插入到数据库中的数据。</li><li><code>item.get(&#39;RecruitPostName&#39;)</code>等语句从<code>item</code>对象中提取相应的数据。<code>get</code>方法用于安全地访问字典键值，即使键不存在也不会引发错误。</li></ul><h6 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL<strong>语句</strong></h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.cursor.execute(sql, params)</span><br></pre></td></tr></table></figure></div><ul><li>使用之前创建的数据库游标<code>self.cursor</code>来执行SQL语句。</li><li><code>execute</code>方法执行前面定义的SQL语句，并用<code>params</code>列表中的值替换占位符<code>%s</code>。</li><li>这种参数化查询方法可以有效防止SQL注入攻击，比直接将字符串拼接到SQL语句更安全。</li></ul><h6 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.conn.commit()</span><br></pre></td></tr></table></figure></div><ul><li>调用<code>self.conn.commit()</code>来提交事务，确保更改被保存到数据库。</li><li>在数据库操作中，<code>commit</code>是一个重要步骤，它使得执行的操作（如插入、更新、删除）成为永久性的。</li><li>如果不调用<code>commit</code>，那么即使执行了SQL语句，数据也不会被实际保存到数据库中。</li></ul><h3 id="执行确认"><a href="#执行确认" class="headerlink" title="执行确认"></a>执行确认</h3><p>执行测试文件<code>tx_debug.py</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5cb85ca5-058b-43b7-e27d-c99d25a7fc00/public"                      width = "500"                ><p>连接成功后执行测试文件<code>db_debug.py</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cd021416-57dd-4aae-6b83-d4d80fd7cc00/public"                      width = "500"                ><p>随后连接Linux检查数据库是否存储数据即可</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ddbef679-365c-42f1-c75c-de15d103a500/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/02f70597-affb-4947-3c06-02baba0ee600/public"                      width = "500"                ><h2 id="Scray-Request-类"><a href="#Scray-Request-类" class="headerlink" title="Scray Request 类"></a>Scray Request 类</h2><p>Scrapy的<code>Request</code>类是用于表示一个HTTP请求的基本类。以下是其构造函数的参数和一些特殊的<code>meta</code>键值的详细说明：</p><h3 id="构造函数参数"><a href="#构造函数参数" class="headerlink" title="构造函数参数"></a>构造函数参数</h3><ul><li><strong>url</strong> (<code>str</code>): 请求的URL。</li><li><strong>callback</strong> (<code>callable</code>): 当请求成功时，Scrapy将调用此回调函数处理响应。</li><li><strong>method</strong> (<code>str</code>): HTTP方法（如<code>&#39;GET&#39;</code>, <code>&#39;POST&#39;</code>等）。默认为<code>&#39;GET&#39;</code>。</li><li><strong>headers</strong> (<code>dict</code>): 自定义的请求头。</li><li><strong>body</strong> (<code>str</code> 或 <code>unicode</code>): 请求体内容。如果未提供，默认为空字符串。</li><li><strong>cookies</strong> (<code>dict</code> 或 <code>[dict]</code>): 请求时附带的cookies。</li><li><strong>meta</strong> (<code>dict</code>): 包含此请求的额外信息，可以在不同的回调函数间共享。</li><li><strong>encoding</strong> (<code>str</code>): 编码类型，默认为<code>&#39;utf-8&#39;</code>。用于URL编码和将body转换为bytes。</li><li><strong>priority</strong> (<code>int</code>): 请求的优先级。数字越大优先级越高，默认为0。</li><li><strong>dont_filter</strong> (<code>bool</code>): 如果设置为<code>True</code>，则不会对请求进行去重过滤。</li><li><strong>errback</strong> (<code>callable</code>): 如果请求过程中发生错误，将调用此函数。</li><li><strong>flags</strong> (<code>list</code>): 一组字符串标志，通常用于日志记录或调试。</li><li><strong>cb_kwargs</strong> (<code>dict</code>): 传递给回调函数的关键字参数。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.http  <span class="keyword">import</span>  Request,FormRequest</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class Request(object_ref):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, url, callback=None, method=&#x27;GET&#x27;, headers=None, body=None,</span></span><br><span class="line"><span class="string">                 cookies=None, meta=None, encoding=&#x27;utf-8&#x27;, priority=0,</span></span><br><span class="line"><span class="string">                 dont_filter=False, errback=None, flags=None, cb_kwargs=None):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><h3 id="Request-meta-的特殊键值"><a href="#Request-meta-的特殊键值" class="headerlink" title="Request.meta 的特殊键值"></a>Request.meta 的特殊键值</h3><ul><li><strong>dont_redirect</strong> (<code>bool</code>): 不处理HTTP重定向。</li><li><strong>dont_retry</strong> (<code>bool</code>): 不对失败的HTTP请求进行重试。</li><li><strong>handle_httpstatus_list</strong> (<code>list</code>): 包含HTTP状态码的列表，这些状态码的响应将不被视为错误。</li><li><strong>handle_httpstatus_all</strong> (<code>bool</code>): 处理所有HTTP状态码。</li><li><strong>dont_merge_cookies</strong> (<code>bool</code>): 不合并此请求的cookies。</li><li><strong>cookiejar</strong> (<code>int</code>&#x2F;<code>object</code>): 指定用于此请求的cookie jar。</li><li><strong>dont_cache</strong> (<code>bool</code>): 禁止对此请求使用HTTP缓存。</li><li><strong>redirect_reasons</strong> (<code>list</code>): 跟踪重定向的原因。</li><li><strong>redirect_urls</strong> (<code>list</code>): 存储请求过程中的所有重定向URL。</li><li><strong>bindaddress</strong> (<code>tuple</code>): 指定用于出站连接的本地IP地址和端口。</li><li><strong>dont_obey_robotstxt</strong> (<code>bool</code>): 不遵守robots.txt规则。</li><li><strong>download_timeout</strong> (<code>float</code>): 设置下载超时时间。</li><li><strong>download_maxsize</strong> (<code>int</code>): 设置允许下载的最大字节数。</li><li><strong>download_latency</strong> (<code>float</code>): 设置下载延迟。</li><li><strong>download_fail_on_dataloss</strong> (<code>bool</code>): 如果出现数据丢失，下载失败。</li><li><strong>proxy</strong> (<code>str</code>): 设置此请求的代理服务器。</li><li><strong>ftp_user</strong> (<code>str</code>): FTP请求的用户名。</li><li><strong>ftp_password</strong> (<code>str</code>): FTP请求的密码。</li><li><strong>referrer_policy</strong> (<code>str</code>): 设置引用策略。</li><li><strong>max_retry_times</strong> (<code>int</code>): 设置请求最大重试次数。</li></ul><h2 id="FormRequest-类"><a href="#FormRequest-类" class="headerlink" title="FormRequest 类"></a>FormRequest 类</h2><p>Scrapy框架中的<code>FormRequest</code>类，它是<code>Request</code>类的一个子类，专门用于处理表单请求。</p><p><code>FormRequest</code>是Scrapy用来发送数据到表单的特殊请求类型。它继承自基本的<code>Request</code>类，并添加了处理表单数据的特定功能。</p><h3 id="构造函数参数-1"><a href="#构造函数参数-1" class="headerlink" title="构造函数参数"></a>构造函数参数</h3><ul><li><strong><code>\*args</code> 和 <code>\**kwargs</code></strong>:<ul><li>这些是Python中的标准参数，允许接收任意数量的位置参数（<code>*args</code>）和关键字参数（<code>**kwargs</code>）。这在继承时使得<code>FormRequest</code>可以接收<code>Request</code>类接受的所有参数。</li></ul></li><li><strong><code>formdata</code></strong> (<code>dict</code> 或 类似于列表的元组对):<ul><li>这是用于传递表单数据的关键字参数。如果提供了<code>formdata</code>，<code>FormRequest</code>将以<code>application/x-www-form-urlencoded</code>格式编码这些数据并包含在请求体中。</li><li>如果<code>method</code>未指定且<code>formdata</code>存在，则默认将请求方法设置为<code>POST</code>。</li></ul></li></ul><h3 id="方法逻辑"><a href="#方法逻辑" class="headerlink" title="方法逻辑"></a>方法逻辑</h3><ol><li><strong>检查<code>formdata</code>和<code>method</code></strong>:<ul><li>如果提供了<code>formdata</code>且未指定<code>method</code>，则默认将<code>method</code>设置为<code>POST</code>。</li></ul></li><li><strong>调用基类构造函数</strong>:<ul><li>使用<code>super(FormRequest, self).__init__(*args, **kwargs)</code>调用基类（<code>Request</code>）的构造函数，确保所有基本的初始化逻辑被执行。</li></ul></li><li><strong>处理<code>formdata</code></strong>:<ul><li>如果提供了<code>formdata</code>，它将被转换为查询字符串。</li><li>对于<code>POST</code>请求，这个查询字符串将被设置为请求体，同时设置<code>Content-Type</code>头为<code>application/x-www-form-urlencoded</code>。</li><li>对于非<code>POST</code>请求（例如<code>GET</code>），查询字符串将被附加到URL上。</li></ul></li></ol><h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><ul><li><code>valid_form_methods</code> 是一个类属性，定义了<code>FormRequest</code>支持的HTTP方法。默认为<code>[&#39;GET&#39;, &#39;POST&#39;]</code>。</li><li><code>_urlencode</code> 函数用于将表单数据转换为URL编码的字符串。</li><li><code>_set_body</code> 和 <code>_set_url</code> 是内部方法，用于设置请求体和更新请求URL。</li></ul><p><code>FormRequest</code>通常用于向网站提交表单，例如登录页面、搜索查询等。由于它自动处理表单数据的编码，因此相比于普通的<code>Request</code>，在处理表单请求时更加方便。</p><p>在使用scrapy发动POST请求的时候,常使用此方法,能较方便的发送请求.具体的使用,见登录github案例;</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FormRequest</span>(<span class="title class_ inherited__">Request</span>):</span><br><span class="line">    valid_form_methods = [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        formdata = kwargs.pop(<span class="string">&#x27;formdata&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> formdata <span class="keyword">and</span> kwargs.get(<span class="string">&#x27;method&#x27;</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            kwargs[<span class="string">&#x27;method&#x27;</span>] = <span class="string">&#x27;POST&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(FormRequest, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> formdata:</span><br><span class="line">            items = formdata.items() <span class="keyword">if</span> <span class="built_in">isinstance</span>(formdata, <span class="built_in">dict</span>) <span class="keyword">else</span> formdata</span><br><span class="line">            querystr = _urlencode(items, self.encoding)</span><br><span class="line">            <span class="keyword">if</span> self.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">                self.headers.setdefault(<span class="string">b&#x27;Content-Type&#x27;</span>, <span class="string">b&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">                self._set_body(querystr)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._set_url(self.url + (<span class="string">&#x27;&amp;&#x27;</span> <span class="keyword">if</span> <span class="string">&#x27;?&#x27;</span> <span class="keyword">in</span> self.url <span class="keyword">else</span> <span class="string">&#x27;?&#x27;</span>) + querystr)</span><br></pre></td></tr></table></figure></div><h2 id="HTTP响应处理"><a href="#HTTP响应处理" class="headerlink" title="HTTP响应处理"></a>HTTP响应处理</h2><p>当使用Scrapy或类似的网络爬虫框架时，处理HTTP响应是一个常见的任务。以下是响应对象的主要属性和方法：</p><ul><li><strong>url</strong>（字符串）: 此响应的URL。</li><li><strong>status</strong>（整数）: 响应的HTTP状态码。默认为200。</li><li><strong>headers</strong>（字典）: 此响应的响应头。可以是单值或多值。</li><li><strong>body</strong>（字节）: 响应主体。为字节类型，可使用<code>response.text</code>以字符串形式访问。</li><li><strong>flags</strong>（列表）: 包含初始响应标志的列表。</li><li><strong>request</strong>（Request对象）: 表示生成此响应的请求。</li></ul><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><ul><li><strong>url</strong>: 包含请求URL的字符串。只读。</li><li><strong>method</strong>: 表示HTTP方法的字符串。</li><li><strong>headers</strong>: 请求头的类似字典对象。</li><li><strong>body</strong>: 包含请求正文的字符串。只读。</li><li><strong>meta</strong>: 包含请求的任意元数据的字典。</li><li><strong>copy()</strong>: 返回此请求的副本。</li><li><strong>replace()</strong>: 返回一个具有更新字段的新请求。</li></ul><h2 id="Scrapy日志配置和使用"><a href="#Scrapy日志配置和使用" class="headerlink" title="Scrapy日志配置和使用"></a>Scrapy日志配置和使用</h2><p>在Scrapy项目中，正确配置和使用日志是监控爬虫行为、调试和记录关键信息的重要方面。</p><h3 id="日志文件配置"><a href="#日志文件配置" class="headerlink" title="日志文件配置"></a>日志文件配置</h3><p>在Scrapy的<code>settings.py</code>文件中，可以配置以下日志相关的设置：</p><ul><li><strong>LOG_FILE</strong>: 设置日志输出文件的路径。如果设置为<code>None</code>，日志将输出到控制台。</li><li><strong>LOG_ENABLED</strong>: 控制是否启用日志记录，布尔值，默认为<code>True</code>。</li><li><strong>LOG_ENCODING</strong>: 设置日志文件的编码，默认为<code>&#39;utf-8&#39;</code>。</li><li><strong>LOG_LEVEL</strong>: 设置日志级别，默认为<code>&#39;DEBUG&#39;</code>。其他级别包括<code>&#39;INFO&#39;</code>、<code>&#39;WARNING&#39;</code>、<code>&#39;ERROR&#39;</code>、<code>&#39;CRITICAL&#39;</code>。</li><li><strong>LOG_FORMAT</strong>: 自定义日志的格式。格式选项包括：<ul><li><code>%(levelno)s</code>: 日志级别的数值。</li><li><code>%(levelname)s</code>: 日志级别名称。</li><li><code>%(pathname)s</code>: 执行程序的路径。</li><li><code>%(filename)s</code>: 执行程序名。</li><li><code>%(funcName)s</code>: 日志的当前函数。</li><li><code>%(lineno)d</code>: 日志的当前行号。</li><li><code>%(asctime)s</code>: 日志记录的时间。</li><li><code>%(thread)d</code>: 线程ID。</li><li><code>%(threadName)s</code>: 线程名称。</li><li><code>%(process)d</code>: 进程ID。</li><li><code>%(message)s</code>: 日志信息。</li><li><code>%(name)s</code>: 日志记录器的名称。</li></ul></li><li><strong>LOG_DATEFORMAT</strong>: 设置日志的日期格式。</li><li><strong>LOG_STDOUT</strong>: 布尔值，控制是否将标准输出（stdout）重定向到日志，通常设为<code>False</code>。</li><li><strong>LOG_SHORT_NAMES</strong>: 布尔值，设置为<code>True</code>时，日志记录器将使用短名称。</li></ul><h3 id="Python日志模块"><a href="#Python日志模块" class="headerlink" title="Python日志模块"></a>Python日志模块</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建logger对象</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志处理器：控制台和文件</span></span><br><span class="line">streamH = logging.StreamHandler()</span><br><span class="line">fileH = logging.FileHandler(<span class="string">&#x27;test_log.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志格式</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;时间:%(asctime)s -- 日志级别:%(levelname)s -- 报错信息:%(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将格式应用到日志处理器</span></span><br><span class="line">streamH.setFormatter(formatter)</span><br><span class="line">fileH.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将处理器添加到logger</span></span><br><span class="line">logger.addHandler(streamH)</span><br><span class="line">logger.addHandler(fileH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logger.error(<span class="string">&quot;我真的知道错误&quot;</span>)</span><br></pre></td></tr></table></figure></div><ul><li>在这个示例中，创建了一个名为<code>hello</code>的日志记录器。</li><li>两个处理器（<code>StreamHandler</code>和<code>FileHandler</code>）分别用于输出日志到控制台和文件。</li><li>使用<code>Formatter</code>设置了日志的格式。</li><li>日志记录器通过添加这些处理器来启用日志记录。</li></ul><h3 id="项目中的常见设置"><a href="#项目中的常见设置" class="headerlink" title="项目中的常见设置"></a>项目中的常见设置</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOG_FILE = <span class="string">&#x27;logfile_name.log&#x27;</span></span><br><span class="line">LOG_LEVEL = <span class="string">&#x27;INFO&#x27;</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>logger</strong>: Scrapy在每个Spider实例中提供了一个可用的logger实例，用于记录日志。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在生产环境中，通常将日志级别设置为<code>INFO</code>或<code>WARNING</code>，以减少日志文件的大小。</li><li>保证日志记录的详细程度与应用程序的需求相符，同时避免记录过于敏感的信息，如用户凭据等。</li><li>日志文件的管理（如归档和清理）也是重要的，以避免日志文件占用过多磁盘空间。</li></ul><h2 id="GitHub登录过程分析与实现"><a href="#GitHub登录过程分析与实现" class="headerlink" title="GitHub登录过程分析与实现"></a>GitHub登录过程分析与实现</h2><h3 id="登录分析"><a href="#登录分析" class="headerlink" title="登录分析"></a>登录分析</h3><p>首先前往GitHub <a class="link"   href="https://github.com/login" >https://github.com/login <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 进行登录操作，检查登录的过程提交的数据</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/75e9ccf3-7176-40e0-005b-8da0595f7b00/public"                      width = "500"                ><p>可以发现其在登录的过程中进行了<code>POST</code>请求，并提交表单到 <code>https://github.com/session</code>。关键在于准确地捕获并发送所有必要的表单参数。</p><p>检查其<code>Payload</code>可以查看到其参数和对应的值</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6bbae919-0c59-43c7-f3f1-74576158c400/public"                      width = "500"                ><p>由于密码和账户组合有三种情况，因此通过分别保持密码和账户相同分别再进行两次请求，并查看它们的值</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/46935bf8-4016-4473-fd9d-e987b01fd100/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/de4ff6da-3de9-4d6d-d113-370d7ddee800/public"                      width = "500"                ><p>比较三者的不同可以发现其是<code>authenticity_token</code> ，<code>login</code>，<code>password</code>，<code>required_field_####</code>，<code>timestamp</code>和<code>timestamp_secret</code>，因此需要在后面进行构造</p><h4 id="登录参数"><a href="#登录参数" class="headerlink" title="登录参数"></a>登录参数</h4><p>因此登录GitHub时，提交的表单数据不仅包含用户名和密码，还包括一些隐藏字段，如<code>authenticity_token</code>、<code>timestamp</code>和<code>timestamp_secret</code>。这些字段可能是为了安全性（如防止CSRF攻击）而设置的。</p><p>一个典型的登录请求包含以下参数：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">form_data = &#123;</span><br><span class="line">    <span class="string">&quot;commit&quot;</span>: <span class="string">&quot;Sign in&quot;</span>,</span><br><span class="line">    <span class="string">&quot;authenticity_token&quot;</span>: authenticity_token,</span><br><span class="line">    <span class="string">&quot;login&quot;</span>: ACCOUNT,  <span class="comment"># 用户名</span></span><br><span class="line">    <span class="string">&quot;password&quot;</span>: PASSWORD,  <span class="comment"># 密码</span></span><br><span class="line">    <span class="string">&quot;webauthn-support&quot;</span>: <span class="string">&quot;supported&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webauthn-iuvpaa-support&quot;</span>: <span class="string">&quot;unsupported&quot;</span>,</span><br><span class="line">    <span class="string">&quot;return_to&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;required_field_####&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;timestamp&quot;</span>: timestamp,</span><br><span class="line">    <span class="string">&quot;timestamp_secret&quot;</span>: timestamp_secret,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="form-data-数据来源"><a href="#form-data-数据来源" class="headerlink" title="form_data 数据来源"></a>form_data 数据来源</h4><p>这些数据大部分可以在访问 <code>https://github.com/login</code> 页面时从页面HTML中捕获。特别是<code>authenticity_token</code>、<code>required_field_</code>、<code>timestamp</code>和<code>timestamp_secret</code>是动态生成的，因此每次登录前都需要先访问登录页面来获取这些数据。</p><h3 id="请求流程-1"><a href="#请求流程-1" class="headerlink" title="请求流程"></a>请求流程</h3><h4 id="请求流程-2"><a href="#请求流程-2" class="headerlink" title="请求流程"></a>请求流程</h4><ol><li>访问 <code>https://github.com/login</code> 以获取登录所需的参数。</li><li>向 <code>https://github.com/session</code> 提交POST请求，携带用户名、密码及其他必需数据。</li></ol><h3 id="Scrapy实现"><a href="#Scrapy实现" class="headerlink" title="Scrapy实现"></a>Scrapy实现</h3><h4 id="编辑爬虫文件"><a href="#编辑爬虫文件" class="headerlink" title="编辑爬虫文件"></a>编辑爬虫文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> git.spiders <span class="keyword">import</span> USER</span><br><span class="line"></span><br><span class="line"><span class="comment"># from git.spiders import USER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GithubLoginSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;github_login&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;github.com&quot;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;https://github.com/login&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        authenticity_token = response.xpath(<span class="string">&#x27;//input[@name=&quot;authenticity_token&quot;]/@value&#x27;</span>).get()</span><br><span class="line">        required_field = response.xpath(<span class="string">&#x27;//input[@type=&quot;text&quot; and @hidden=&quot;hidden&quot; ]/@name&#x27;</span>).get()</span><br><span class="line">        timestamp = response.xpath(<span class="string">&#x27;//input[@name=&quot;timestamp&quot;]/@value&#x27;</span>).get()</span><br><span class="line">        timestamp_secret = response.xpath(<span class="string">&#x27;//input[@name=&quot;timestamp_secret&quot;]/@value&#x27;</span>).get()</span><br><span class="line"></span><br><span class="line">        form_data = &#123;</span><br><span class="line">            <span class="string">&quot;commit&quot;</span>: <span class="string">&quot;Sign in&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;authenticity_token&#x27;</span>: authenticity_token,</span><br><span class="line">            <span class="string">&quot;login&quot;</span>: USER.LOGIN,</span><br><span class="line">            <span class="string">&quot;password&quot;</span>: USER.PASSWORD,</span><br><span class="line">            <span class="string">&quot;webauthn-conditional&quot;</span>: <span class="string">&quot;undefined&quot;</span>,</span><br><span class="line">            <span class="string">&quot;javascript-support&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;webauthn-support&quot;</span>: <span class="string">&quot;supported&quot;</span>,</span><br><span class="line">            <span class="string">&quot;webauthn-iuvpaa-support&quot;</span>: <span class="string">&quot;unsupported&quot;</span>,</span><br><span class="line">            <span class="string">&quot;return_to&quot;</span>: <span class="string">&quot;https://github.com/login&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;allow_signup&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;client_id&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;integration&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            required_field: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;timestamp&quot;</span>: timestamp,</span><br><span class="line">            <span class="string">&quot;timestamp_secret&quot;</span>: timestamp_secret,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> scrapy.FormRequest(url=<span class="string">&quot;https://github.com/session&quot;</span>, formdata=form_data, callback=self.login)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;CosmicTrace&#x27;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已成功拿到值&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;失敗了&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure></div><h5 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GithubLoginSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;github_login&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;github.com&quot;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;https://github.com/login&quot;</span>]</span><br></pre></td></tr></table></figure></div><ul><li>定义了一个名为<code>GithubLoginSpider</code>的Scrapy爬虫类。</li><li><code>name</code>属性设置为<code>&quot;github_login&quot;</code>，是爬虫的唯一标识。</li><li><code>allowed_domains</code>列表限制了爬虫只能爬取<code>&quot;github.com&quot;</code>域名下的页面。</li><li><code>start_urls</code>包含了爬虫开始爬取的URL，这里是GitHub的登录页面。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">authenticity_token = response.xpath(<span class="string">&#x27;//input[@name=&quot;authenticity_token&quot;]/@value&#x27;</span>).get()</span><br><span class="line">required_field = response.xpath(<span class="string">&#x27;//input[@type=&quot;text&quot; and @hidden=&quot;hidden&quot; ]/@name&#x27;</span>).get()</span><br><span class="line">timestamp = response.xpath(<span class="string">&#x27;//input[@name=&quot;timestamp&quot;]/@value&#x27;</span>).get()</span><br><span class="line">timestamp_secret = response.xpath(<span class="string">&#x27;//input[@name=&quot;timestamp_secret&quot;]/@value&#x27;</span>).get()</span><br></pre></td></tr></table></figure></div><ul><li><code>parse</code>是Scrapy爬虫的默认回调方法，爬虫向一个URL发出请求时，获得的响应会自动传递给这个方法。在这个例子中，<code>response</code> 对象包含了对 <code>start_urls</code> 中URL的HTTP响应。</li><li>这几行代码使用XPath从登录页面的HTML中提取了<code>authenticity_token</code>、<code>required_field</code>、<code>timestamp</code>和<code>timestamp_secret</code>。这些字段通常用于防止跨站请求伪造（CSRF）攻击。<ul><li><code>response.xpath(&#39;//input[@name=&quot;authenticity_token&quot;]/@value&#39;).get()</code><ul><li><code>//input[@name=&quot;authenticity_token&quot;]</code>：这部分的XPath查找文档中所有<code>&lt;input&gt;</code>元素，其中<code>name</code>属性等于<code>&quot;authenticity_token&quot;</code>。<code>//</code>表示在整个文档中查找，而不仅限于某个特定部分。</li><li><code>/@value</code>：这部分表示从找到的<code>&lt;input&gt;</code>元素中提取<code>value</code>属性。在HTML中，<code>&lt;input&gt;</code>标签的<code>value</code>属性通常用来存储输入字段的值。</li><li><code>.get()</code>：这是Scrapy的Selector对象的方法，用于提取XPath选择器的第一个匹配结果。如果没有匹配的元素，它将返回<code>None</code>。</li></ul></li><li><code>response.xpath(&#39;//input[@type=&quot;text&quot; and @hidden=&quot;hidden&quot;]/@name&#39;).get()</code><ul><li><code>//input[@type=&quot;text&quot; and @hidden=&quot;hidden&quot;]</code>：这个XPath查找所有<code>&lt;input&gt;</code>元素，它们的<code>type</code>属性为<code>&quot;text&quot;</code>且同时拥有<code>hidden=&quot;hidden&quot;</code>属性。这通常是隐藏的表单字段，对用户不可见，但对于表单提交可能是必需的。</li><li><code>/@name</code>：这表示提取这些<code>&lt;input&gt;</code>元素的<code>name</code>属性。</li><li><code>.get()</code>：同样，这是用来获取第一个匹配结果的Scrapy方法。</li></ul></li><li><code>response.xpath(&#39;//input[@name=&quot;timestamp&quot;]/@value&#39;).get()</code><ul><li><code>//input[@name=&quot;timestamp&quot;]</code>：这个XPath寻找所有<code>&lt;input&gt;</code>元素，其<code>name</code>属性为<code>&quot;timestamp&quot;</code>。这通常用于跟踪表单的创建或提交时间。</li><li><code>/@value</code>：提取这些<code>&lt;input&gt;</code>元素的<code>value</code>属性。</li><li><code>.get()</code>：获取第一个匹配结果。</li></ul></li><li><code>response.xpath(&#39;//input[@name=&quot;timestamp_secret&quot;]/@value&#39;).get()</code><ul><li><code>//input[@name=&quot;timestamp_secret&quot;]</code>：查找所有<code>&lt;input&gt;</code>元素，其<code>name</code>属性为<code>&quot;timestamp_secret&quot;</code>。这个值可能是与<code>timestamp</code>相关的加密或哈希值。</li><li><code>/@value</code>：提取<code>value</code>属性。</li><li><code>.get()</code>：获取第一个匹配结果。</li></ul></li></ul></li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">form_data = &#123;</span><br><span class="line">    <span class="string">&quot;commit&quot;</span>: <span class="string">&quot;Sign in&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;authenticity_token&#x27;</span>: authenticity_token,</span><br><span class="line">    <span class="string">&quot;login&quot;</span>: USER.LOGIN,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: USER.PASSWORD,</span><br><span class="line">    <span class="string">&quot;webauthn-conditional&quot;</span>: <span class="string">&quot;undefined&quot;</span>,</span><br><span class="line">    <span class="string">&quot;javascript-support&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webauthn-support&quot;</span>: <span class="string">&quot;supported&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webauthn-iuvpaa-support&quot;</span>: <span class="string">&quot;unsupported&quot;</span>,</span><br><span class="line">    <span class="string">&quot;return_to&quot;</span>: <span class="string">&quot;https://github.com/login&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;allow_signup&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;client_id&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;integration&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    required_field: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;timestamp&quot;</span>: timestamp,</span><br><span class="line">    <span class="string">&quot;timestamp_secret&quot;</span>: timestamp_secret,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><strong>commit</strong>: 表单提交按钮的值，通常在登录表单中可以找到。</li><li><strong>authenticity_token</strong>: 一个安全令牌，用于防止CSRF攻击，从登录页面的HTML中提取。</li><li><strong>login</strong>: GitHub的用户名，<code>USER.LOGIN</code>应该替换为实际的用户名。</li><li><strong>password</strong>: GitHub的密码，<code>USER.PASSWORD</code>应该替换为实际的密码。</li><li><strong>webauthn-conditional</strong>, <strong>javascript-support</strong>, <strong>webauthn-support</strong>, <strong>webauthn-iuvpaa-support</strong>: 这些字段可能与GitHub的特定前端逻辑相关，例如Web认证和JavaScript支持。</li><li><strong>return_to</strong>: 登录后应重定向到的URL。</li><li><strong>allow_signup</strong>, <strong>client_id</strong>, <strong>integration</strong>: 这些可能是额外的表单字段，用于GitHub的内部跟踪或逻辑。</li><li><strong>required_field</strong>: 之前从页面提取的隐藏字段，其确切意图可能是内部验证。</li><li><strong>timestamp</strong> 和 <strong>timestamp_secret</strong>: 与表单提交时效性和安全性相关的字段。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> scrapy.FormRequest(url=<span class="string">&quot;https://github.com/session&quot;</span>, formdata=form_data, callback=self.login)</span><br></pre></td></tr></table></figure></div><ul><li>这行代码创建了一个Scrapy的<code>FormRequest</code>对象，用于向GitHub的<code>https://github.com/session</code> URL发送一个POST请求。</li><li><code>formdata=form_data</code> 指定了要发送的表单数据。</li><li><code>callback=self.login</code> 指定了Scrapy在收到响应后应调用的方法。<code>self.login</code>方法将处理登录请求的响应。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;CosmicTrace&#x27;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已成功拿到值&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;失敗了&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure></div><ul><li><code>def login(self, response):</code> - 这行定义了一个名为 <code>login</code> 的方法。由于存在 <code>self</code> 参数，可以判断这个方法属于某个类，并且这个方法接受一个参数 <code>response</code>。</li><li><code>if &#39;CosmicTrace&#39; in response.text:</code> - 这行代码检查 <code>response.text</code> 中是否包含字符串 ‘CosmicTrace’。如果包含，意味着满足了某种成功的条件。</li><li><code>print(&quot;已成功拿到值&quot;)</code> - 如果在 <code>response.text</code> 中找到了字符串，就打印出 “已成功拿到值”，表示操作成功。</li><li><code>else:</code> - 如果在 <code>response.text</code> 中没有找到字符串 ‘CosmicTrace’，则执行这部分代码。</li><li><code>print(&#39;失敗了&#39;)</code> - 如果没有找到字符串，就打印出 ‘失敗了’，即“失败了”。</li><li><code>print(response)</code> - 这行代码会在执行完if-else条件后打印整个 <code>response</code> 对象。这对于调试或记录日志很有用，可以查看请求的完整响应。</li></ul><h5 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h5><p>编辑调试文件</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.cmdline <span class="keyword">import</span> execute</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">execute([<span class="string">&#x27;scrapy&#x27;</span>, <span class="string">&#x27;crawl&#x27;</span>, <span class="string">&#x27;github_login&#x27;</span>])</span><br></pre></td></tr></table></figure></div><h5 id="Settings-文件-1"><a href="#Settings-文件-1" class="headerlink" title="Settings 文件"></a>Settings 文件</h5><p>编辑配置文件</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Scrapy settings for git project</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For simplicity, this file contains only settings considered important or</span></span><br><span class="line"><span class="comment"># commonly used. You can find more settings consulting the documentation:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     https://docs.scrapy.org/en/latest/topics/settings.html</span></span><br><span class="line"><span class="comment">#     https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span></span><br><span class="line"><span class="comment">#     https://docs.scrapy.org/en/latest/topics/spider-middleware.html</span></span><br><span class="line"></span><br><span class="line">BOT_NAME = <span class="string">&quot;git&quot;</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">&quot;git.spiders&quot;</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">&quot;git.spiders&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span></span><br><span class="line"><span class="comment">#USER_AGENT = &quot;git (+http://www.yourdomain.com)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure maximum concurrent requests performed by Scrapy (default: 16)</span></span><br><span class="line"><span class="comment">#CONCURRENT_REQUESTS = 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a delay for requests for the same website (default: 0)</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/settings.html#download-delay</span></span><br><span class="line"><span class="comment"># See also autothrottle settings and docs</span></span><br><span class="line"><span class="comment">#DOWNLOAD_DELAY = 3</span></span><br><span class="line"><span class="comment"># The download delay setting will honor only one of:</span></span><br><span class="line"><span class="comment">#CONCURRENT_REQUESTS_PER_DOMAIN = 16</span></span><br><span class="line"><span class="comment">#CONCURRENT_REQUESTS_PER_IP = 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable cookies (enabled by default)</span></span><br><span class="line"><span class="comment">#COOKIES_ENABLED = False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable Telnet Console (enabled by default)</span></span><br><span class="line"><span class="comment">#TELNETCONSOLE_ENABLED = False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Override the default request headers:</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">   <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>,</span><br><span class="line">   <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable or disable spider middlewares</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/spider-middleware.html</span></span><br><span class="line"><span class="comment">#SPIDER_MIDDLEWARES = &#123;</span></span><br><span class="line"><span class="comment">#    &quot;git.middlewares.GitSpiderMiddleware&quot;: 543,</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable or disable downloader middlewares</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span></span><br><span class="line"><span class="comment">#DOWNLOADER_MIDDLEWARES = &#123;</span></span><br><span class="line"><span class="comment">#    &quot;git.middlewares.GitDownloaderMiddleware&quot;: 543,</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable or disable extensions</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/extensions.html</span></span><br><span class="line"><span class="comment">#EXTENSIONS = &#123;</span></span><br><span class="line"><span class="comment">#    &quot;scrapy.extensions.telnet.TelnetConsole&quot;: None,</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure item pipelines</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"><span class="comment">#ITEM_PIPELINES = &#123;</span></span><br><span class="line"><span class="comment">#    &quot;git.pipelines.GitPipeline&quot;: 300,</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable and configure the AutoThrottle extension (disabled by default)</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/autothrottle.html</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_ENABLED = True</span></span><br><span class="line"><span class="comment"># The initial download delay</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_START_DELAY = 5</span></span><br><span class="line"><span class="comment"># The maximum download delay to be set in case of high latencies</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_MAX_DELAY = 60</span></span><br><span class="line"><span class="comment"># The average number of requests Scrapy should be sending in parallel to</span></span><br><span class="line"><span class="comment"># each remote server</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0</span></span><br><span class="line"><span class="comment"># Enable showing throttling stats for every response received:</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_DEBUG = False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable and configure HTTP caching (disabled by default)</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings</span></span><br><span class="line"><span class="comment">#HTTPCACHE_ENABLED = True</span></span><br><span class="line"><span class="comment">#HTTPCACHE_EXPIRATION_SECS = 0</span></span><br><span class="line"><span class="comment">#HTTPCACHE_DIR = &quot;httpcache&quot;</span></span><br><span class="line"><span class="comment">#HTTPCACHE_IGNORE_HTTP_CODES = []</span></span><br><span class="line"><span class="comment">#HTTPCACHE_STORAGE = &quot;scrapy.extensions.httpcache.FilesystemCacheStorage&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set settings whose default value is deprecated to a future-proof value</span></span><br><span class="line">REQUEST_FINGERPRINTER_IMPLEMENTATION = <span class="string">&quot;2.7&quot;</span></span><br><span class="line">TWISTED_REACTOR = <span class="string">&quot;twisted.internet.asyncioreactor.AsyncioSelectorReactor&quot;</span></span><br><span class="line">FEED_EXPORT_ENCODING = <span class="string">&quot;utf-8&quot;</span></span><br></pre></td></tr></table></figure></div><h5 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h5><p>调试测试文件，断点在<code>login</code>方法，发现其返回200，输出响应的<code>TXT</code>格式，复制其内容保存为<code>HTML</code>文件并打开</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/af0f69ee-c5b3-43b4-8f94-45958240ec00/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4ae3b81e-1b99-4297-ec77-7340c8ada700/public"                      width = "500"                ><p>可以发现其成功显示出登录后的界面</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1a16d792-70d7-4750-e228-ef21a8a0cb00/public"                      width = "500"                ><p>也可以通过判断可以发现<code>HTML</code>是否含有账号名来判断调试是否成功</p><h2 id="Scrapy下载中间件（Downloader-Middleware）"><a href="#Scrapy下载中间件（Downloader-Middleware）" class="headerlink" title="Scrapy下载中间件（Downloader Middleware）"></a>Scrapy下载中间件（Downloader Middleware）</h2><p>下载中间件是Scrapy的核心组件之一，它提供了一个灵活的方式来自定义请求和响应的处理过程。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>作用</strong>：下载中间件用于拦截并处理Scrapy发出的所有HTTP请求和响应。它们在Scrapy的请求&#x2F;响应处理过程中提供了多个钩子（hooks）点。</li><li><strong>功能</strong>：可以用于修改请求和响应、处理重定向、重试失败的请求、设置代理、处理cookies等。</li><li><strong>实现</strong>：它是通过实现特定的方法的Python类来定义的。</li></ul><h3 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h3><ul><li><p>Scrapy自带了多种下载中间件，这些中间件提供了对不同方面的处理支持。</p></li><li><p>可以通过运行命令 <code>scrapy settings --get=DOWNLOADER_MIDDLEWARES_BASE</code> 查看Scrapy自带的所有下载中间件及其优先级。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware&quot;</span>: <span class="number">100</span>, <span class="string">&quot;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&quot;</span>: <span class="number">300</span>, <span class="string">&quot;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&quot;</span>: <span class="number">350</span>, <span class="string">&quot;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&quot;</span>: <span class="number">400</span>, <span class="string">&quot;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&quot;</span>: <span class="number">500</span>, <span class="string">&quot;scrapy.downloadermiddlewares.retry.RetryMiddleware&quot;</span>: <span class="number">550</span>, <span class="string">&quot;scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware&quot;</span>: <span class="number">560</span>, <span class="string">&quot;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&quot;</span>: <span class="number">580</span>, <span class="string">&quot;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&quot;</span>: <span class="number">590</span>, <span class="string">&quot;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&quot;</span>: <span class="number">600</span>, <span class="string">&quot;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&quot;</span>: <span class="number">700</span>, <span class="string">&quot;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&quot;</span>: <span class="number">750</span>, <span class="string">&quot;scrapy.downloadermiddlewares.stats.DownloaderStats&quot;</span>: <span class="number">850</span>, <span class="string">&quot;scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware&quot;</span>: <span class="number">900</span>&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>这些内置中间件包括对robots.txt的处理、HTTP代理支持、Cookies处理等。</p></li><li><p>用户可以通过在<code>DOWNLOADER_MIDDLEWARES</code>设置中添加自定义的中间件来扩展Scrapy的功能。</p></li><li><p>设置是一个字典，键是中间件类的路径，值是中间件的顺序（0-1000之间的整数）。数字越小，优先级越高，即越接近Scrapy引擎</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;myproject.middlewares.CustomMiddleware&#x27;</span>: <span class="number">543</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><p>详见官方文档</p><p><a class="link"   href="https://docs.scrapy.org/en/latest/topics/downloader-middleware.html" >https://docs.scrapy.org/en/latest/topics/downloader-middleware.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="下载中间件实例"><a href="#下载中间件实例" class="headerlink" title="下载中间件实例"></a>下载中间件实例</h3><ol><li><strong>RobotsTxtMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 此中间件用于处理网站的robots.txt规则。它会自动解析并遵守目标网站的robots.txt文件，从而限制爬虫的行为以符合网站的爬取政策。</li><li><strong>配置方法</strong>: 默认情况下，Scrapy会遵守robots.txt规则。可以通过在项目的<code>settings.py</code>中设置<code>ROBOTSTXT_OBEY = False</code>来禁用此功能。</li></ul><ol start="2"><li><strong>HttpAuthMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 管理HTTP认证的中间件，用于处理那些需要HTTP认证（如基本认证、摘要认证）的网站。</li><li><strong>配置方法</strong>: 可以通过在Scrapy的<code>Request</code>对象中指定<code>http_user</code>和<code>http_pass</code>属性来启用HTTP认证。</li></ul><ol start="3"><li><strong>DownloadTimeoutMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 设置下载请求的超时时间。如果请求在指定时间内未得到响应，它将被视为失败，并且可以被重试中间件重新处理。</li><li><strong>配置方法</strong>: 可以通过设置<code>DOWNLOAD_TIMEOUT</code>来调整全局超时时间。</li></ul><ol start="4"><li><strong>DefaultHeadersMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 为所有的Scrapy请求设置默认HTTP头部。这对于为每个请求添加或覆盖特定的HTTP头（如Accept-Language）非常有用。</li><li><strong>配置方法</strong>: 在<code>settings.py</code>文件中，使用<code>DEFAULT_REQUEST_HEADERS</code>设置来定义默认的HTTP头部。</li></ul><ol start="5"><li><strong>UserAgentMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 此中间件允许为每个请求随机或固定地设置User-Agent。User-Agent通常被网站用来识别访问者使用的浏览器和操作系统。</li><li><strong>配置方法</strong>: 可以通过在<code>settings.py</code>中设置<code>USER_AGENT</code>或者使用自定义的User-Agent提供器来改变User-Agent。</li></ul><ol start="6"><li><strong>RetryMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 处理失败的HTTP请求并尝试重新发送。这对于处理暂时的网络问题或服务器错误非常有用。</li><li><strong>配置方法</strong>: 默认情况下，Scrapy会重试失败的请求。可以在<code>settings.py</code>中修改<code>RETRY_TIMES</code>来调整重试次数。</li></ul><ol start="7"><li><strong>AjaxCrawlMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 用于处理JavaScript生成的页面。这使得Scrapy能够爬取那些需要执行JavaScript代码才能显示完整内容的页面。</li><li><strong>配置方法</strong>: 默认不启用，需要在<code>settings.py</code>中显式启用。</li></ul><ol start="8"><li><strong>MetaRefreshMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 自动处理页面的meta刷新标签。有些网页可能会使用meta标签来自动刷新或重定向到另一个页面。</li><li><strong>配置方法</strong>: 默认启用。可以通过在<code>settings.py</code>中设置<code>METAREFRESH_ENABLED = False</code>来禁用它。</li></ul><ol start="9"><li><strong>HttpCompressionMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 此中间件自动处理压缩的HTTP响应，例如gzip或deflate格式的内容。</li><li><strong>配置方法</strong>: 默认启用，无需特别配置。</li></ul><ol start="10"><li><strong>RedirectMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 自动处理HTTP重定向。对于301和302类型的重定向，此中间件会自动跟随重定向链接。</li><li><strong>配置方法</strong>: 默认启用，可以通过<code>REDIRECT_ENABLED</code>设置来禁用。</li></ul><ol start="11"><li><strong>CookiesMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 管理Cookies。对于需要管理多个会话或跟踪用户会话的爬虫来说，这个中间件非常有用。</li><li><strong>配置方法</strong>: 默认启用，可以通过<code>COOKIES_ENABLED = False</code>来禁用。</li></ul><ol start="12"><li><strong>HttpProxyMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 处理HTTP代理。通过使用代理，爬虫可以从不同的IP地址发送请求，这有助于绕过IP封锁或进行匿名抓取。</li><li><strong>配置方法</strong>: 可以通过在请求的<code>meta</code>中设置<code>proxy</code>键来启用代理。</li></ul><ol start="13"><li><strong>DownloaderStats</strong></li></ol><ul><li><strong>功能描述</strong>: 收集下载统计信息。这个中间件为每个响应或异常收集统计数据，帮助分析和优化爬虫性能。</li><li><strong>配置方法</strong>: 默认启用，一般无需更改配置。</li></ul><ol start="14"><li><strong>HttpCacheMiddleware</strong></li></ol><ul><li><strong>功能描述</strong>: 提供对HTTP缓存的支持。此中间件能够缓存请求的响应，以便下次请求相同资源时快速获取。</li><li><strong>配置方法</strong>: 默认不启用，可以通过在<code>settings.py</code>中设置<code>HTTPCACHE_ENABLED = True</code>来启用。</li></ul><h3 id="下载中间件API"><a href="#下载中间件API" class="headerlink" title="下载中间件API"></a>下载中间件API</h3><ul><li>每个下载中间件可以实现以下一个或多个方法：<ul><li><strong><code>process_request(request, spider)</code></strong>: 在发送请求之前调用。可以返回None、一个Response对象、一个Request对象或抛出一个异常。</li><li><strong><code>process_response(request, response, spider)</code></strong>: 在接收到响应后调用。可以返回Response对象或抛出异常。</li><li><strong><code>process_exception(request, exception, spider)</code></strong>: 当下载处理过程中发生异常时调用。</li><li><strong><code>from_crawler(cls, crawler)</code></strong>: 类方法，用于访问Scrapy的核心组件和API，以及创建中间件实例。</li></ul></li></ul><h4 id="返回值的重要性"><a href="#返回值的重要性" class="headerlink" title="返回值的重要性"></a>返回值的重要性</h4><ul><li>每个方法的返回值都非常重要，它决定了请求或响应接下来的处理流程。<ul><li>如果<code>process_request</code>返回非None值，Scrapy将不会继续处理该请求，而是立即调用相应的<code>process_response</code>方法。</li><li>如果<code>process_response</code>返回一个新的请求（Request对象），Scrapy将停止调用其他中间件的<code>process_response</code>方法，转而处理这个新的请求。</li><li>在<code>process_exception</code>中返回一个新的请求对象将同样导致Scrapy停止调用其他中间件的<code>process_exception</code>方法，并处理这个新的请求。</li></ul></li></ul><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><h3 id="UA代理池中间件"><a href="#UA代理池中间件" class="headerlink" title="UA代理池中间件"></a>UA代理池中间件</h3><p>在Scrapy项目中，使用自定义中间件来实现用户代理池（User-Agent Pool）是一种常见的做法，用于避免被目标网站识别并可能被阻止。</p><p>自定义的用户代理池中间件允许每个请求随机使用不同的用户代理（User-Agent），从而减少被目标网站识别为爬虫的风险。</p><h4 id="1-在-settings-py-中定义用户代理列表"><a href="#1-在-settings-py-中定义用户代理列表" class="headerlink" title="1. 在 settings.py 中定义用户代理列表"></a>1. 在 settings.py 中定义用户代理列表</h4><p>首先，在Scrapy项目的<code>settings.py</code>文件中定义一个用户代理列表：</p><p><code>settings</code>文件 <code>user_agent_list</code> </p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user_agent</span></span><br><span class="line">USER_AGENT_LIST = [</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 &quot;</span></span><br><span class="line">        <span class="string">&quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></div><p>这个列表包含了多个不同的用户代理字符串，用于在发起请求时模拟不同的浏览器。</p><h4 id="2-在-middlewares-py-中实现用户代理中间件"><a href="#2-在-middlewares-py-中实现用户代理中间件" class="headerlink" title="2. 在 middlewares.py 中实现用户代理中间件"></a>2. 在 middlewares.py 中实现用户代理中间件</h4><p>在<code>middlewares.py</code>文件中实现自定义的中间件，用于在每个请求中随机选择一个用户代理：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> scrapy.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomUserAgentMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        <span class="comment"># 随机选择一个用户代理</span></span><br><span class="line">        user_agent = random.choice(settings.get(<span class="string">&#x27;USER_AGENT_LIST&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> user_agent:</span><br><span class="line">            <span class="comment"># 设置请求的User-Agent</span></span><br><span class="line">            request.headers.setdefault(<span class="string">&#x27;User-Agent&#x27;</span>, user_agent)</span><br></pre></td></tr></table></figure></div><ul><li><code>RandomUserAgentMiddleware</code> 类定义了一个<code>process_request</code>方法，该方法在每个请求发送之前被调用。</li><li>方法中，随机从<code>USER_AGENT_LIST</code>中选取一个用户代理，并将其设置为该请求的<code>User-Agent</code>。</li></ul>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>也有另一种方法是直接从 <code>settings</code> 模块导入</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .settings <span class="keyword">import</span> USER_AGENT_LIST</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAMiddleware</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        request.headers[<span class="string">&#x27;User-Agent&#x27;</span>] = random.choice(USER_AGENT_LIST)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_response</span>(<span class="params">self, request, response, spider</span>):</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></div><ul><li>这种方法直接从<code>settings.py</code>文件中导入<code>user_agent_list</code>。</li><li>优点是直接和简洁，尤其是在用户代理列表只在这个中间件中使用时。</li><li>缺点是它降低了配置的灵活性。如果想在不同的环境（例如开发环境和生产环境）中使用不同的用户代理列表，或者希望能够通过命令行参数动态覆盖这些设置，这种方法可能不太适用。</li><li>之前的方法使用Scrapy的内置<code>settings</code>模块来访问项目设置（在<code>settings.py</code>文件中定义的设置）。</li><li>优点是它利用了Scrapy框架的设置管理机制，可以更容易地在整个项目中管理和维护这些设置。</li><li>缺点是需要导入<code>scrapy.conf.settings</code>，这在某些情况下可能稍显冗余。</li><li>如果倾向于使用Scrapy框架的标准特性，并希望在项目的不同组件间共享配置，那么第一种方法（使用<code>scrapy.conf.settings</code>）可能更适合。</li><li>如果项目结构比较简单，或者只在一个地方使用这个用户代理列表，那么第二种方法（直接从<code>settings.py</code>导入）可能更直接有效。</li></ul>    </div>  </div><h4 id="3-在-settings-py-中启用中间件"><a href="#3-在-settings-py-中启用中间件" class="headerlink" title="3. 在 settings.py 中启用中间件"></a>3. 在 settings.py 中启用中间件</h4><p>在<code>settings.py</code>文件中，将自定义的中间件添加到<code>DOWNLOADER_MIDDLEWARES</code>设置中，以启用该中间件：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;myproject.middlewares.RandomUserAgentMiddleware&#x27;</span>: <span class="number">400</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>替换<code>&#39;myproject.middlewares.RandomUserAgentMiddleware&#39;</code>为实际的中间件路径。</li><li>数值<code>400</code>是中间件的优先级。可以根据需要调整这个值以控制中间件的执行顺序。</li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>使用用户代理池可以帮助模拟常规用户的浏览行为，但应注意合理使用以避免对目标网站造成不必要的负担。</li><li>请确保遵守目标网站的爬虫政策和使用条款。</li><li>用户代理字符串应尽量选择常见且更新的版本，以提高爬虫的隐蔽性。</li></ul><h3 id="IP代理池"><a href="#IP代理池" class="headerlink" title="IP代理池"></a>IP代理池</h3><p>在Scrapy项目中使用IP代理池是为了隐藏爬虫的真实IP地址，这有助于绕过目标网站的IP封锁或请求频率限制。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>IP代理池可以让Scrapy爬虫在每次请求时使用不同的IP地址，从而提高爬虫的匿名性和效率。</p><h5 id="1-在-settings-py-中定义IP代理池"><a href="#1-在-settings-py-中定义IP代理池" class="headerlink" title="1. 在 settings.py 中定义IP代理池"></a>1. 在 settings.py 中定义IP代理池</h5><p>在Scrapy项目的<code>settings.py</code>文件中，定义一个包含多个代理IP的列表：</p><p>(此处是示例,以下的代理基本无法使用的,同时不建议去找免费的代理,不安全)</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># IP代理池</span></span><br><span class="line">IPPOOL = [</span><br><span class="line">    &#123;<span class="string">&quot;ipaddr&quot;</span>: <span class="string">&quot;61.129.70.131:8080&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;ipaddr&quot;</span>: <span class="string">&quot;61.152.81.193:9100&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;ipaddr&quot;</span>: <span class="string">&quot;120.204.85.29:3128&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;ipaddr&quot;</span>: <span class="string">&quot;219.228.126.86:8123&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;ipaddr&quot;</span>: <span class="string">&quot;61.152.81.193:9100&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;ipaddr&quot;</span>: <span class="string">&quot;218.82.33.225:53853&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;ipaddr&quot;</span>: <span class="string">&quot;223.167.190.17:42789&quot;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p>这个列表包含了多个字典，每个字典代表一个代理服务器，其中<code>ipaddr</code>键的值是代理服务器的IP地址和端口。</p><h5 id="2-在-middlewares-py-中实现IP代理中间件"><a href="#2-在-middlewares-py-中实现IP代理中间件" class="headerlink" title="2. 在 middlewares.py 中实现IP代理中间件"></a>2. 在 middlewares.py 中实现IP代理中间件</h5><p>在<code>middlewares.py</code>文件中，实现一个中间件来随机使用IP代理池中的一个代理：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> scrapy.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        <span class="comment"># 从IP池中随机选择一个IP</span></span><br><span class="line">        thisip = random.choice(settings.get(<span class="string">&#x27;IPPOOL&#x27;</span>))</span><br><span class="line">        <span class="comment"># 将选中的IP设置为请求的代理</span></span><br><span class="line">        request.meta[<span class="string">&quot;proxy&quot;</span>] = <span class="string">&quot;http://&quot;</span> + thisip[<span class="string">&#x27;ipaddr&#x27;</span>]</span><br></pre></td></tr></table></figure></div><ul><li><code>ProxyMiddleware</code> 类定义了一个<code>process_request</code>方法，该方法在每个请求发送之前被调用。</li><li>方法中，随机从<code>IPPOOL</code>中选取一个IP代理，并将其设置为该请求的代理。</li></ul>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>第一种方法是从预定义的IP代理池中随机选择一个代理，而另一种种方法是实时从一个API获取代理IP</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IPPMiddleware</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        url = <span class="string">&#x27;https://api.hailiangip.com:8522/api/getIpEt?dataType=1&amp;encryptParam=...（省略）&#x27;</span></span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        data = <span class="string">&quot;https://&quot;</span> + res.text</span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = data</span><br></pre></td></tr></table></figure></div><p>选择哪种方法取决于具体需求和环境。如果需要更高的灵活性和更大的代理IP池，且不介意依赖外部服务和可能的额外成本，那么使用实时API获取代理可能是更好的选择。如果更注重稳定性和控制，且不希望增加额外的依赖和成本，那么使用预定义的代理池可能更适合。</p>    </div>  </div><h5 id="3-在-settings-py-中启用自定义中间件"><a href="#3-在-settings-py-中启用自定义中间件" class="headerlink" title="3. 在 settings.py 中启用自定义中间件"></a>3. 在 settings.py 中启用自定义中间件</h5><p>在<code>settings.py</code>文件中，将自定义的中间件添加到<code>DOWNLOADER_MIDDLEWARES</code>设置中，以启用该中间件：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;myproject.middlewares.ProxyMiddleware&#x27;</span>: <span class="number">543</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>替换<code>&#39;myproject.middlewares.ProxyMiddleware&#39;</code>为实际的中间件路径。</li><li>数值<code>543</code>是中间件的优先级。可以根据需要调整这个值以控制中间件的执行顺序。</li></ul><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>请注意，示例中的代理IP可能无法使用。在实际应用中，建议使用可靠且安全的付费代理服务。</li><li>免费代理可能不稳定，且有安全隐患，例如可能会被用于拦截或篡改数据。</li><li>使用代理时，请确保遵守目标网站的爬虫政策和使用条款，合理使用以避免对目标网站造成不必要的负担。</li></ul><h3 id="Scrapy-settings-py-配置详解"><a href="#Scrapy-settings-py-配置详解" class="headerlink" title="Scrapy settings.py 配置详解"></a>Scrapy settings.py 配置详解</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1f0ac0fb-c284-4fc5-f542-7b15d1a03900/public"                      width = "500"                ><p><code>settings.py</code> 文件是 Scrapy 项目的核心配置文件，用于定义爬虫的行为和项目的全局设置。</p><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p><strong>项目名称</strong>:</p><ul><li><p><code>BOT_NAME</code>: 定义项目名称，通常用作日志记录的标识。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOT_NAME = <span class="string">&#x27;baidu&#x27;</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>爬虫模块路径</strong>:</p><ul><li><p><code>SPIDER_MODULES</code>: 指定包含 Scrapy 爬虫的模块。</p></li><li><p><code>NEWSPIDER_MODULE</code>: 定义使用 <code>genspider</code> 命令创建新爬虫时的默认模块。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SPIDER_MODULES = [<span class="string">&#x27;baidu.spiders&#x27;</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">&#x27;baidu.spiders&#x27;</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>用户代理 (User-Agent)</strong>:</p><ul><li><p><code>USER_AGENT</code>: 定义爬虫默认使用的用户代理。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER_AGENT = <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>Robots.txt 协议</strong>:</p><ul><li><p><code>ROBOTSTXT_OBEY</code>: 设置是否遵守网站的 robots.txt 协议。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>Cookies 支持</strong>:</p><ul><li><p><code>COOKIES_ENABLED</code>: 设置是否启用 cookies。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COOKIES_ENABLED = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>Telnet 控制台</strong>:</p><ul><li><p><code>TELNETCONSOLE_ENABLED</code>: 设置是否启用 Telnet 控制台用于查看爬虫运行情况。</p>  <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TELNETCONSOLE_ENABLED = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>默认请求头</strong>:</p><ul><li><p><code>DEFAULT_REQUEST_HEADERS</code>: 设置 Scrapy 发送 HTTP 请求时默认使用的请求头。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><p><strong>请求重试</strong>:</p><ul><li><p><code>RETRY_ENABLED</code>: 设置是否启用请求重试。</p></li><li><p><code>RETRY_TIMES</code>: 设置请求重试的次数。</p></li><li><p><code>RETRY_HTTP_CODECS</code>: 设置触发重试的 HTTP 状态码。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RETRY_ENABLED = <span class="literal">True</span></span><br><span class="line">RETRY_TIMES = <span class="number">3</span></span><br><span class="line">RETRY_HTTP_CODECS = [<span class="number">500</span>, <span class="number">502</span>, <span class="number">503</span>, <span class="number">504</span>, <span class="number">408</span>]</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="并发与延迟"><a href="#并发与延迟" class="headerlink" title="并发与延迟"></a>并发与延迟</h4><p><strong>最大并发请求数</strong>:</p><ul><li><p><code>CONCURRENT_REQUESTS</code>: 设置下载器最大处理的并发请求数量。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCURRENT_REQUESTS = <span class="number">32</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>每个域的最大并发请求数</strong>:</p><ul><li><p><code>CONCURRENT_REQUESTS_PER_DOMAIN</code>: 设置每个域名的最大并发请求数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCURRENT_REQUESTS_PER_DOMAIN = <span class="number">16</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>每个IP的最大并发请求数</strong>:</p><ul><li><p><code>CONCURRENT_REQUESTS_PER_IP</code>: 设置每个 IP 的最大并发请求数。如果设置，<code>CONCURRENT_REQUESTS_PER_DOMAIN</code> 将被忽略。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCURRENT_REQUESTS_PER_IP = <span class="number">16</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>下载延迟</strong>:</p><ul><li><p><code>DOWNLOAD_DELAY</code>: 设置对同一网站的请求间隔秒数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOAD_DELAY = <span class="number">3</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="智能限速-AutoThrottle"><a href="#智能限速-AutoThrottle" class="headerlink" title="智能限速 (AutoThrottle)"></a>智能限速 (AutoThrottle)</h4><p><strong>AutoThrottle 扩展</strong>:</p><ul><li>自动调整 Scrapy 到最佳爬取速度，减轻对目标站点的压力。</li><li><code>AUTOTHROTTLE_ENABLED</code>: 开启 AutoThrottle。</li><li><code>AUTOTHROTTLE_START_DELAY</code>: 初始下载延迟。</li><li><code>AUTOTHROTTLE_MAX_DELAY</code>: 最大下载延迟。</li><li><code>AUTOTHROTTLE_TARGET_CONCURRENCY</code>: 每秒并发请求数的目标值。</li><li><code>AUTOTHROTTLE_DEBUG</code>: 开启调试模式，以观察 AutoThrottle 的行为。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AUTOTHROTTLE_ENABLED = <span class="literal">True</span></span><br><span class="line">AUTOTHROTTLE_START_DELAY = <span class="number">5</span></span><br><span class="line">AUTOTHROTTLE_MAX_DELAY = <span class="number">60</span></span><br><span class="line">AUTOTHROTTLE_TARGET_CONCURRENCY = <span class="number">1.0</span></span><br><span class="line">AUTOTHROTTLE_DEBUG = <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><h4 id="中间件、Pipelines、扩展"><a href="#中间件、Pipelines、扩展" class="headerlink" title="中间件、Pipelines、扩展"></a>中间件、Pipelines、扩展</h4><ol><li><p><strong>启用或禁用 Spider 中间件</strong>:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SPIDER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;baidu.middlewares.BaiduSpiderMiddleware&#x27;</span>: <span class="number">543</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>启用或禁用下载器中间件</strong>:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;baidu.middlewares.MyCustomDownloaderMiddleware&#x27;</span>: <span class="number">543</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>启用或禁用扩展</strong>:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTENSIONS = &#123;</span><br><span class="line">    &#x27;scrapy.extensions.telnet.TelnetConsole&#x27;: None,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>配置 Item Pipelines</strong>:</p><ul><li>ITEM_PIPELINES: 设置启用的 Item Pipeline。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">  <span class="string">&#x27;baidu.pipelines.CustomPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><h2 id="Spider类下载图片"><a href="#Spider类下载图片" class="headerlink" title="Spider类下载图片"></a>Spider类下载图片</h2><p>在Scrapy框架中，下载图片与下载文本数据确实有一些相似之处，但也有其特有的处理方式。Scrapy通过内置的支持使得下载图片变得相对简单。与处理文本数据不同，处理图片通常涉及处理二进制数据，并可能需要额外的中间件支持。</p><h3 id="测试文件-1"><a href="#测试文件-1" class="headerlink" title="测试文件"></a>测试文件</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.cmdline <span class="keyword">import</span> execute</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">execute([<span class="string">&#x27;scrapy&#x27;</span>, <span class="string">&#x27;crawl&#x27;</span>, <span class="string">&#x27;baidu_img&#x27;</span>])</span><br></pre></td></tr></table></figure></div><h3 id="手动保存图片"><a href="#手动保存图片" class="headerlink" title="手动保存图片"></a>手动保存图片</h3><h4 id="Spider文件"><a href="#Spider文件" class="headerlink" title="Spider文件"></a>Spider文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> re,os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduImgSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;baidu_img&quot;</span></span><br><span class="line">    allowed_domains = []</span><br><span class="line">    start_urls = [<span class="string">&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=111210&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;oq=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;rsp=-1&quot;</span>]</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">            re_data = re.findall(<span class="string">&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;</span>, response.text)</span><br><span class="line">            <span class="keyword">for</span> im <span class="keyword">in</span> re_data:</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(im, callback=self.get_img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_img</span>(<span class="params">self, response</span>):</span><br><span class="line">        img_data = response.body</span><br><span class="line">        <span class="comment"># 直接保存图片</span></span><br><span class="line">        <span class="comment"># 如果没有 imgspider 这个文件夹，mkdir创建</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;imgspider&#x27;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;imgspider&#x27;</span>)</span><br><span class="line">        filename = <span class="string">&#x27;imgspider/&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(self.num)</span><br><span class="line">        self.num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(img_data)</span><br></pre></td></tr></table></figure></div><h5 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h5><ul><li>定义一个继承自<code>scrapy.Spider</code>的爬虫类<code>BaiduImgSpider</code>。</li><li><code>name</code>：为爬虫指定一个唯一的名称。</li><li><code>allowed_domains</code>：定义爬虫允许爬取的域名列表。这里为空，表示不对域名进行限制。</li><li><code>start_urls</code>：包含一个起始URL的列表，该URL是百度图片搜索的结果页面。</li><li><code>parse</code>：是爬虫的一个方法，处理响应并提取数据。</li><li>使用正则表达式从页面源代码中提取所有图片的URL。正则表达式<code>&#39;thumbURL&quot;:&quot;(.*?)&quot;&#39;</code>用于匹配图片的URL。</li><li>遍历所有提取到的图片URL。</li><li>对每个图片URL，生成一个Scrapy请求，并将响应发送到<code>get_img</code>方法。</li><li><code>get_img</code>：处理图片下载的方法。</li><li><code>response.body</code>：获取响应的二进制数据，即图片内容。</li><li>检查是否存在名为<code>imgspider</code>的目录，如果不存在，则创建该目录。用于保存下载的图片。</li><li>构造图片文件的保存路径和文件名。这里使用<code>self.num</code>来为图片生成唯一的文件名，但需要注意<code>self.num</code>在爬虫类中初始化。</li><li>以二进制写入模式打开文件，将图片数据写入文件。</li></ul><h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>该爬虫直接从百度图片的搜索结果页面提取图片URL，具体的URL模式可能会随着百度网站的更新而变化。</li><li>使用正则表达式提取数据可能不如使用XPath或CSS选择器那样稳定，因为如果百度网页的结构发生变化，正则表达式可能需要更新。</li><li>确保遵守百度图片的版权和使用条款，不要用于任何侵犯版权或违法的用途。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a87697e5-898e-470d-6d0a-49635a56e600/public"                      width = "500"                >  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p>调试处理前配置Settings文件进行伪装，否则连接失败</p>  </div><h3 id="Pipeline-保存图片"><a href="#Pipeline-保存图片" class="headerlink" title="Pipeline 保存图片"></a>Pipeline 保存图片</h3><h4 id="Items-文件-1"><a href="#Items-文件-1" class="headerlink" title="Items 文件"></a>Items 文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># https://docs.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduItem</span>(scrapy.Item):</span><br><span class="line">    img_data = scrapy.Field()</span><br></pre></td></tr></table></figure></div><ul><li>定义一个名为<code>BaiduItem</code>的Item类，该类用于在爬虫和Pipeline之间传递数据。</li><li>它继承自<code>scrapy.Item</code>。在Scrapy中，<code>Item</code>是用来收集从网页提取的数据的简单容器。</li><li><code>BaiduItem</code>类将被用来存储从百度图片搜索结果中提取的数据。</li><li><code>BaiduItem</code>类中定义了一个字段<code>img_data</code>。</li><li><code>scrapy.Field()</code>是Scrapy用来定义Item字段的特殊容器，用于存储从网页中提取的数据。</li><li>在这个例子中，<code>img_data</code>字段用于存储图片的二进制数据或图片的URL。</li><li>创建了一个<code>BaiduItem</code>的实例，并将提取到的图片数据或URL填充到<code>img_data</code>字段。</li><li>然后，可以将这个填充了数据的<code>BaiduItem</code>实例传递给Pipeline进行进一步的处理，例如保存图片到文件系统或数据库</li></ul><h4 id="Spider-文件-1"><a href="#Spider-文件-1" class="headerlink" title="Spider 文件"></a>Spider 文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> re,os</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> BaiduItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduImgSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;baidu_img&quot;</span></span><br><span class="line">    allowed_domains = []</span><br><span class="line">    start_urls = [<span class="string">&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=111210&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;oq=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;rsp=-1&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">            re_data = re.findall(<span class="string">&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;</span>, response.text)</span><br><span class="line">            <span class="keyword">for</span> im <span class="keyword">in</span> re_data:</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(im, callback=self.get_img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_img</span>(<span class="params">self, response</span>):</span><br><span class="line">        item = BaiduItem()</span><br><span class="line">        img_data = response.body</span><br><span class="line">        item[<span class="string">&#x27;img_data&#x27;</span>] = img_data</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></div><ul><li>定义一个名为<code>BaiduImgSpider</code>的爬虫类，指定爬虫名称、允许的域名（在这里为空）和起始URL。</li><li><code>parse</code>是Scrapy爬虫处理响应的默认方法。使用正则表达式从响应中提取图片的URL。</li><li>对每个找到的图片URL，发起一个新的Scrapy请求，并指定回调方法<code>get_img</code>来处理这些请求。</li><li><code>get_img</code>方法处理图片下载的响应。创建一个<code>BaiduItem</code>实例，并将下载的图片数据（二进制格式）存储在<code>img_data</code>字段中。</li><li>将包含图片数据的item提交给Pipeline进行进一步处理。</li></ul><h4 id="Pipelines-文件-1"><a href="#Pipelines-文件-1" class="headerlink" title="Pipelines 文件"></a>Pipelines 文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduPipeline</span>():</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;imgpipeline&#x27;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;imgpipeline&#x27;</span>)</span><br><span class="line">        filename = <span class="string">&#x27;imgpipeline/&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(self.num)</span><br><span class="line">        self.num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(item.get(<span class="string">&#x27;img_data&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></div><ul><li>导入了所需的模块和类。<code>ItemAdapter</code>用于适配不同类型的Item对象，<code>os</code>模块用于处理文件和路径操作。</li><li><code>num</code>是一个类变量，用于生成图片文件的名称。</li><li><code>process_item</code>是Pipeline处理item的方法。</li><li>检查名为<code>imgpipeline</code>的文件夹是否存在，如果不存在，则创建它。这个文件夹用于存储下载的图片。</li><li>为下载的图片生成文件名，并将<code>num</code>递增以确保文件名的唯一性。</li><li>以二进制写模式打开文件，并将图片数据写入文件。</li><li>返回处理后的item。</li></ul>  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p><code>settings.py</code>中激活<code>BaiduPipeline</code>避免没有传值</p>  </div><h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>这个爬虫和Pipeline的实现假定图片的URL可以直接从百度图片搜索结果的页面HTML中提取。如果百度更改其HTML结构或JavaScript动态加载机制，这个方法可能需要更新。</li><li>当处理大量图片或大型网站时，请确保遵循robots.txt规则并尊重网站的版权和使用条款。</li></ul><h2 id="ImagesPipeline类下载图片"><a href="#ImagesPipeline类下载图片" class="headerlink" title="ImagesPipeline类下载图片"></a>ImagesPipeline类下载图片</h2><p>Scrapy提供了一个专门的<code>ImagesPipeline</code>类，用于方便地下载和处理图片。要正确使用这个类，需要按照以下步骤操作：</p><ol><li><p>在Spider文件中提取图片URLs</p><ul><li>爬虫应该解析目标页面，提取图片的URLs，并将它们存储在item的一个字段中。</li></ul></li><li><p>在Items文件中定义<code>image_urls</code>字段</p><ul><li>定义一个Scrapy Item，并包含一个名为<code>image_urls</code>的字段，用于存储待下载的图片URLs。</li></ul></li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BdImagePipeItem</span>(scrapy.Item):</span><br><span class="line">    image_urls = scrapy.Field()</span><br></pre></td></tr></table></figure></div><ol start="3"><li>创建继承自ImagesPipeline的管道类<ul><li>创建一个新的Pipeline类，继承自<code>ImagesPipeline</code>。这个类可以被用来进一步自定义图片的下载和处理行为（如过滤、转换格式等）。</li></ul></li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BdImagePipeline</span>(<span class="title class_ inherited__">ImagesPipeline</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><ol start="4"><li>在Settings文件中配置图片存储路径和Pipeline<ul><li>在项目的<code>settings.py</code>文件中，设置图片存储路径（<code>IMAGES_STORE</code>）和启用图片管道。</li></ul></li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGES_STORE = <span class="string">&#x27;/path/to/your/images/dir&#x27;</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">&#x27;yourproject.pipelines.BdImagePipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="5"><li><p>安装Pillow库</p><ul><li><code>ImagesPipeline</code>需要Pillow库来处理图片。确保安装了Pillow库（版本4.0或以上）。</li></ul></li></ol><p></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow</span><br></pre></td></tr></table></figure></div><ol start="6"><li><p>媒体管道的特性和设置</p><ul><li><p>Scrapy的媒体管道（包括<code>ImagesPipeline</code>）提供了一些有用的特性，例如避免重新下载最近下载的媒体、生成缩略图、检查图像尺寸等。</p></li><li><p>除了<code>IMAGES_STORE</code>之外，还有许多其他设置可以用来定制媒体管道的行为，如<code>IMAGES_EXPIRES</code>、<code>IMAGES_THUMBS</code>、<code>IMAGES_MIN_HEIGHT</code>、<code>IMAGES_MIN_WIDTH</code>等。</p></li></ul></li></ol><h3 id="媒体管道的特性"><a href="#媒体管道的特性" class="headerlink" title="媒体管道的特性"></a>媒体管道的特性</h3><p>Scrapy的媒体管道提供了强大的功能来处理下载的媒体文件，如图片和文件。特别是对于图像，Scrapy提供了额外的处理功能。</p><h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><ul><li><strong>避免重复下载</strong>：媒体管道会跟踪最近下载的文件，避免重复下载相同的媒体内容。</li><li><strong>灵活的存储位置</strong>：支持多种存储方式，包括本地文件系统、Amazon S3、谷歌云存储等。</li></ul><h4 id="图像特有功能"><a href="#图像特有功能" class="headerlink" title="图像特有功能"></a>图像特有功能</h4><ul><li><strong>格式转换</strong>：下载的图片会被转换为通用的JPG格式，并确保图片模式为RGB。</li><li><strong>缩略图生成</strong>：可以自动生成指定尺寸的缩略图。</li><li><strong>尺寸过滤</strong>：通过设置，可以过滤掉低于指定宽度或高度的图片。</li></ul><h3 id="媒体管道的设置"><a href="#媒体管道的设置" class="headerlink" title="媒体管道的设置"></a>媒体管道的设置</h3><p>为了使用媒体管道，需要在项目的<code>settings.py</code>文件中进行相应的配置。</p><h4 id="启用媒体管道"><a href="#启用媒体管道" class="headerlink" title="启用媒体管道"></a>启用媒体管道</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;<span class="string">&#x27;scrapy.pipelines.images.ImagesPipeline&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></div><ul><li>这行代码启用了Scrapy的图像管道，并设置其优先级为1。</li></ul><h4 id="设置存储位置和字段"><a href="#设置存储位置和字段" class="headerlink" title="设置存储位置和字段"></a>设置存储位置和字段</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FILES_STORE=<span class="string">&#x27;/path/to/valid/dir&#x27;</span>文件管道存放位置</span><br><span class="line">IMAGES_STORE=<span class="string">&#x27;/path/to/valid/dir&#x27;</span>图片管道存放位置</span><br><span class="line">FILES_URLS_FIELD=<span class="string">&#x27;field_name_for_your_files_urls&#x27;</span>    自定义文件url字段</span><br><span class="line">FILES_RESULT_FIELD=<span class="string">&#x27;field_name_for_your_processed_files&#x27;</span> 自定义结果字段</span><br><span class="line">IMAGES_URLS_FIELD = <span class="string">&#x27;field_name_for_your_images_urls&#x27;</span> 自定义图片url字段</span><br><span class="line">IMAGES_RESULT_FIELD = <span class="string">&#x27;field_name_for_your_processed_images&#x27;</span> 结果字段</span><br><span class="line">FILES_EXPIRES = <span class="number">90</span>    文件过期时间   默认<span class="number">90</span>天</span><br><span class="line">IMAGES_EXPIRES = <span class="number">90</span>    图片过期时间   默认<span class="number">90</span>天</span><br><span class="line">IMAGES_THUMBS= &#123;<span class="string">&#x27;small&#x27;</span>: (<span class="number">50</span>, <span class="number">50</span>), <span class="string">&#x27;big&#x27;</span>:(<span class="number">270</span>, <span class="number">270</span>)&#125; 缩略图尺寸</span><br><span class="line">IMAGES_MIN_HEIGHT= <span class="number">110</span>     过滤最小高度</span><br><span class="line">IMAGES_MIN_WIDTH= <span class="number">110</span>      过滤最小宽度</span><br><span class="line">MEDIA_ALLOW_REDIRECTS= <span class="literal">True</span>    是否重定向，默认为<span class="literal">False</span></span><br></pre></td></tr></table></figure></div><h3 id="Spider文件-1"><a href="#Spider文件-1" class="headerlink" title="Spider文件"></a>Spider文件</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> re,os</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> BaiduItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduImgSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;baidu_img&quot;</span></span><br><span class="line">    allowed_domains = []</span><br><span class="line">    start_urls = [<span class="string">&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=111210&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;oq=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;rsp=-1&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">            re_data = re.findall(<span class="string">&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;</span>, response.text)</span><br><span class="line"></span><br><span class="line">            item = BaiduItem()</span><br><span class="line">            item[<span class="string">&#x27;image_urls&#x27;</span>] = re_data</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></div><ul><li>导入了Scrapy框架、正则表达式库和项目中定义的<code>BaiduItem</code>。</li><li>定义了一个名为<code>BaiduImgSpider</code>的爬虫类。</li><li><code>start_urls</code>包含了开始爬取的URL（百度图片搜索结果）。</li><li><code>parse</code>方法处理响应并提取图片URL。</li><li>使用正则表达式从页面中提取图片的URL。</li><li>创建一个<code>BaiduItem</code>实例，并将提取到的URL列表赋值给<code>image_urls</code>字段。</li><li>使用<code>yield</code>语句返回这个item。</li></ul><h3 id="Items文件"><a href="#Items文件" class="headerlink" title="Items文件"></a>Items文件</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># https://docs.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduItem</span>(scrapy.Item):</span><br><span class="line">    image_urls = scrapy.Field()</span><br></pre></td></tr></table></figure></div><ul><li>定义了一个名为<code>BaiduItem</code>的Item类，包含一个<code>image_urls</code>字段。</li><li><code>image_urls</code>用于存储待下载的图片URL列表。</li></ul><h3 id="Pipelines文件"><a href="#Pipelines文件" class="headerlink" title="Pipelines文件"></a>Pipelines文件</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># useful for handling different item types with a single interface</span></span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduPipeline</span>(<span class="title class_ inherited__">ImagesPipeline</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><ul><li>导入了Scrapy的<code>ImagesPipeline</code>。</li><li>定义了一个名为<code>BaiduPipeline</code>的类，它继承自<code>ImagesPipeline</code>。</li><li>目前这个类没有进行任何自定义操作，直接继承了<code>ImagesPipeline</code>的全部功能。</li></ul><h3 id="Settings文件"><a href="#Settings文件" class="headerlink" title="Settings文件"></a>Settings文件</h3><p>添加图片管道存放位置<code>IMAGES_STORE=&#39;imgStore&#39;</code></p><p>添加缩略图尺寸设置：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGES_THUMBS= &#123;</span><br><span class="line">    <span class="string">&#x27;small&#x27;</span>: (<span class="number">60</span>, <span class="number">60</span>),</span><br><span class="line">    <span class="string">&#x27;large&#x27;</span>:(<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3cde6b5e-2c19-4226-0403-1beecf4f4900/public"                      width = "500"                ><h2 id="ImagesPipeline类方法重写-改名与翻页"><a href="#ImagesPipeline类方法重写-改名与翻页" class="headerlink" title="ImagesPipeline类方法重写 (改名与翻页)"></a>ImagesPipeline类方法重写 (改名与翻页)</h2><h3 id="Spider文件-2"><a href="#Spider文件-2" class="headerlink" title="Spider文件"></a>Spider文件</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> re,os</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> BaiduItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduImgSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;baidu_img&quot;</span></span><br><span class="line">    allowed_domains = []</span><br><span class="line">    start_urls = [<span class="string">&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=111210&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;oq=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;rsp=-1&quot;</span>]</span><br><span class="line"></span><br><span class="line">    page_url =<span class="string">&#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=7201144097221860430&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;queryWord=%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=0&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=&#123;&#125;&amp;rn=30&amp;gsm=1e&amp;1702544763785=&#x27;</span></span><br><span class="line"></span><br><span class="line">    page_num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        re_data = re.findall(<span class="string">&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;</span>, response.text)</span><br><span class="line"></span><br><span class="line">        item = BaiduItem()</span><br><span class="line">        item[<span class="string">&#x27;image_urls&#x27;</span>] = re_data</span><br><span class="line">        <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.page_num == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        url = self.page_url.<span class="built_in">format</span>(self.page_num * <span class="number">30</span>)</span><br><span class="line">        self.page_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url)</span><br></pre></td></tr></table></figure></div><ul><li><code>page_url</code>定义了用于翻页的URL模板。</li><li><code>page_num</code>用于追踪当前的翻页数。</li><li><code>parse</code>方法用正则表达式从响应中提取图片URL，并将它们存入<code>BaiduItem</code>的<code>image_urls</code>字段。</li><li>控制翻页，如果当前页面数达到4，则停止爬取。</li><li>格式化<code>page_url</code>以获取下一页的URL，并更新<code>page_num</code>。</li><li>使用<code>scrapy.Request</code>生成新的请求来爬取下一页。</li></ul><h3 id="Pipelines文件-1"><a href="#Pipelines文件-1" class="headerlink" title="Pipelines文件"></a>Pipelines文件</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> .settings <span class="keyword">import</span> IMAGES_STORE</span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduPipeline</span>(<span class="title class_ inherited__">ImagesPipeline</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">item_completed</span>(<span class="params">self, results, item, info</span>):</span><br><span class="line">        images_paths = [x.get(<span class="string">&#x27;path&#x27;</span>) <span class="keyword">for</span> ok, x <span class="keyword">in</span> results <span class="keyword">if</span> ok]</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> images_paths:</span><br><span class="line">            os.rename(os.path.join(IMAGES_STORE,path),</span><br><span class="line">                      os.path.join(IMAGES_STORE, <span class="built_in">str</span>(self.num) + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">                      )</span><br><span class="line">            self.num += <span class="number">1</span></span><br></pre></td></tr></table></figure></div><ul><li><p>导入所需的模块和类，包括Scrapy的内置<code>ImagesPipeline</code>。</p></li><li><p>定义了继承自<code>ImagesPipeline</code>的<code>BaiduPipeline</code>类。</p></li><li><p><code>num</code>用于生成重命名后的图片文件名。</p></li><li><p>重写<code>item_completed</code>方法，该方法在item的图片被下载完成后调用。</p></li><li><p>遍历下载的图片路径，并重命名每张图片，使用<code>num</code>作为新的文件名。</p></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/775cf980-849c-4067-1e49-6a38b9890500/public"                      width = "500"                >]]></content>
    
    
    <summary type="html">Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Scrapy" scheme="https://www.yiuhangblog.com/tags/Scrapy/"/>
    
    <category term="网页抓取" scheme="https://www.yiuhangblog.com/tags/%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>验证识别</title>
    <link href="https://www.yiuhangblog.com/2021/10/26/20211026%E9%AA%8C%E8%AF%81%E8%AF%86%E5%88%AB/"/>
    <id>https://www.yiuhangblog.com/2021/10/26/20211026%E9%AA%8C%E8%AF%81%E8%AF%86%E5%88%AB/</id>
    <published>2021-10-25T23:12:45.000Z</published>
    <updated>2024-02-28T10:50:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识验证码"><a href="#认识验证码" class="headerlink" title="认识验证码"></a>认识验证码</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写。<br>是一种用来区分用户是计算机还是人的公共全自动程序</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>认证码是一种人机识别手段，最终目的是区分正常用户和机器的操作。<br>可以防止：恶意破解密码、注册、刷票、论坛灌水，防止黑客对用户的密码进行暴力破解。<br>一般是提出一个问题，这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答这个的问题，所以回答出问题的用户就可以被认为是人类。</p><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><h4 id="图形验证码："><a href="#图形验证码：" class="headerlink" title="图形验证码："></a>图形验证码：</h4><p>这类验证码大多是计算机随机产生一个字符串，在把字符串增加噪点、干扰线、变形、重叠、不同颜色、扭曲组成一张图片来增加识别难度。</p><h4 id="滑块验证码："><a href="#滑块验证码：" class="headerlink" title="滑块验证码："></a>滑块验证码：</h4><p>也叫行为验证码，比较流行的一种验证码，通过用户的操作行为来完成验证，其中最出名的就是极验。<br>滑动验证码的原理就是使用机器学习中的深度学习技术，根据一些特征来区分是否为正常用户。通过记录用户的滑动速度，还有每一小段时间的瞬时速度，用户鼠标点击情况，以及滑动后的匹配程度来识别。而且，不是说滑动到正确位置就是验证通过，而是根据特征识别来区分是否为真用户，滑到正确位置只是一个必要条件。</p><h4 id="点触验证码："><a href="#点触验证码：" class="headerlink" title="点触验证码："></a>点触验证码：</h4><p>点击类验证码都是给出一张包含文字的图片，通过文字提醒用户点击图中相同字的位置进行验证。</p><h2 id="Pillow库"><a href="#Pillow库" class="headerlink" title="Pillow库"></a>Pillow库</h2><h3 id="PIL库"><a href="#PIL库" class="headerlink" title="PIL库"></a>PIL库</h3><p>PIL (Python Image Library) 已经算是 Python 处理图片的标准库了，兼具强大的功能和简洁的 API.<br>但是PIL库的更新非常缓慢， 并且它只支持到python2.7，不支python3</p><h3 id="Pillow库-1"><a href="#Pillow库-1" class="headerlink" title="Pillow库"></a>Pillow库</h3><p>由于PIL库更新太慢了，于是一群志愿者在PIL库的基础上创建的分支版本，命名为Pillow.<br>Pillow目前最新支持到python3.6以上，它的维护和开发十分活跃，兼容PIL库的绝大多数语法，并且增加了许多新的特性，推荐直接使用Pillow</p><h3 id="Pillow库安装"><a href="#Pillow库安装" class="headerlink" title="Pillow库安装"></a>Pillow库安装</h3><p>安装:pip install pillow</p><h4 id="PIL与Pillow使用注意"><a href="#PIL与Pillow使用注意" class="headerlink" title="PIL与Pillow使用注意"></a>PIL与Pillow使用注意</h4><p>Pillow和PIL不能共存在一个环境中，如果之前安装了PIL的话，需要删除掉才能在安装Pillow<br>由于是继承自PIL的分支， 所以Pillow库的导入是这样的</p><p>Import PIL</p><h2 id="图形基本概念"><a href="#图形基本概念" class="headerlink" title="图形基本概念"></a>图形基本概念</h2><p>因为要处理的是图形,所以需要了解一下基本概念</p><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>图片尺寸（size）指的是图片的宽度和高度<br>通过size属性可以获取图片的尺寸，它的返回值是一个元组，<br>元组里面有两个值，分别是水平和垂直方向上的像素个数</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a6f26a71-c157-40f1-29b5-2c1feed84600/public"                      width = "300"                ><h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>笛卡尔像素坐标系<br>x轴从左到右,y轴从上到下增长<br>图像矩形区域的表示(左,顶,右,底);800*600像素表示(0,0,800,600)</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/839b2aa3-ea1e-4c9e-8ea4-82e0df486500/public"                      width = "500"                ><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>图片均是由一个或者多个数据通道构成<br>RGB图像,每张图片都是由三个数据通道叠加构成，分别为R 、G 、B<br>PNG图像有RGBA四个通道，A代表透明度<br>对于灰度图像（没有色彩的图片， RGB色彩分量全部相等），只有一个通道。<br>灰度指的是黑白图像中点的颜色深度，范围一般是0到255， 白色为255，黑色为0</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1cfd3305-10d6-476b-2dd7-409dd172f600/public"                      width = "400"                ><h3 id="图像获取"><a href="#图像获取" class="headerlink" title="图像获取"></a>图像获取</h3><ol><li>从文件中加载图像</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picture=Image.<span class="built_in">open</span>(<span class="string">&quot;test.png&quot;</span>)</span><br></pre></td></tr></table></figure></div><ol start="2"><li>创建一个新的图像</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picture=Image.new(<span class="string">&quot;RGB&quot;</span>,(<span class="number">200</span>,<span class="number">100</span>),<span class="string">&quot;red&quot;</span>)</span><br></pre></td></tr></table></figure></div><ol start="3"><li>处理其他的图像获得</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im=picture.crop((<span class="number">116</span>,<span class="number">168</span>,<span class="number">658</span>,<span class="number">798</span>))</span><br></pre></td></tr></table></figure></div><p><strong>获取图像通道</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im.getbands()</span><br><span class="line">(<span class="string">&quot;R&quot;</span>,<span class="string">&quot;G&quot;</span>,<span class="string">&quot;B&quot;</span>)</span><br></pre></td></tr></table></figure></div><h2 id="简单验证码处理"><a href="#简单验证码处理" class="headerlink" title="简单验证码处理"></a>简单验证码处理</h2><h3 id="灰度化"><a href="#灰度化" class="headerlink" title="灰度化"></a>灰度化</h3><p>目的:为二值化做准备</p><p>彩色变黑白，三通道变成一个通道</p><p>图片的灰度化，就是让像素点矩阵中的每一个像素点满足 R&#x3D;G&#x3D;B，此时这个值叫做灰度值，白色为255，黑色为0</p><p>灰度转化一般公式为：<br> R&#x3D;G&#x3D;B &#x3D; 处理前的 R * 0.3 + G * 0.59 + B * 0.11</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/caf30616-1f28-4476-c41c-eb4156db0300/public"                      width = "300"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">黑   <span class="number">0</span>---<span class="number">255</span>   白色</span><br><span class="line"></span><br><span class="line">第一个像素点的灰度值税  <span class="number">187</span>     <span class="number">123</span>   改成 <span class="number">255</span></span><br><span class="line">第一个像素点的灰度值税  <span class="number">34</span>      <span class="number">123</span>   改成 <span class="number">0</span></span><br></pre></td></tr></table></figure></div><h3 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h3><p>图像的二值化，就是将图像的像素点矩阵中的每个像素点的灰度值设置为0（黑色）或255（白色），从而实现二值化，将整个图像呈现出明显的只有黑和白的视觉效果。<br>二值化原理是利用设定的一个阈值来判断图像像素是0还是255， 一般小于阈值的像素点变为0， 大于的变成255<br>这个临界灰度值就被称为阈值，阈值的设置很重要，阈值过大或过小都会对图片造成损坏<br>选择阈值的原则是：既要尽可能保存图片信息，又要尽可能减少背景和噪声的干扰</p><p><strong>常用阈值选择的方法是：</strong></p><ul><li>灰度平均值值法： 取127 （0~255的中数， （0+255）&#x2F;2 &#x3D; 127）</li><li>平均值法：<br>计算像素点矩阵中的所有像素点的灰度值的平均值avg       </li><li>迭代法：<br>选择一个近似阈值作为估计值的初始值（比如全图像的平均灰度），然后进行分割图像，产生两组像素，一组大于初始灰度值，另一组小于初始灰度值，根据产生的子图像的特征来选取新的阈值，在利用新的阈值分割图像，经过多次循环，使得错误分割的图像像素点降到最小。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;1.png&quot;</span>)</span><br><span class="line">img_gray = img.convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line"><span class="comment"># img_gray.save(&quot;img_gray.png&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binarization</span>(<span class="params">ig</span>):</span><br><span class="line">    w,h=img_gray.size</span><br><span class="line">    tmp=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            tmp += ig.getpixel((i,j))</span><br><span class="line">    avg_pixel = tmp/w/h</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二值化处理</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            p = ig.getpixel((i, j))</span><br><span class="line">            <span class="keyword">if</span> p&gt;avg_pixel:</span><br><span class="line">                ig.putpixel((i, j), <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ig.putpixel((i, j), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ig</span><br><span class="line">img_bz = binarization(img_gray)</span><br><span class="line">img_bz.save(<span class="string">&#x27;img_bz.png&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/62383031-464d-4b90-e67d-f884f391f800/public"                      width = "300"                ><h3 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5bc64283-5270-402d-3d24-5c909ad31900/public"                      width = "300"                ><p>目的:清除干扰点,让图片更清晰,让计算机更利于识别<br>孤立的噪点，他的周围应该都是白色，或者大多数点都是白色的，所以在判断的时候条件应该放宽，一个点是黑色并且相邻的点为白色的点的个数大于一个固定的值，那么这个点就是噪点。</p><h3 id="降噪原理"><a href="#降噪原理" class="headerlink" title="降噪原理"></a>降噪原理</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2fec1c37-a232-4d90-3ec4-294176e39f00/public"                      width = "300"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">安装的库名  不一定是使用的库名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pip install pillow</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import PIL</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;1.png&quot;</span>) <span class="comment"># 创建一个对象img</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(img.getbands()) <span class="comment">#(&#x27;R&#x27;, &#x27;G&#x27;, &#x27;B&#x27;) 三原色通道</span></span><br><span class="line"></span><br><span class="line">img_gray = img.convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binarization</span>(<span class="params">ig</span>):</span><br><span class="line">    w, h = img_gray.size <span class="comment"># 获取长宽</span></span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):<span class="comment">#循环宽</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h): <span class="comment">#循环高</span></span><br><span class="line">            <span class="comment"># 通过嵌套循环获取所有像素点的坐标</span></span><br><span class="line">            <span class="comment"># getpixel 方法是用来获取图像中某一点像素的rgb颜色</span></span><br><span class="line">            <span class="comment"># 需要传元组形式的坐标</span></span><br><span class="line">            tmp += ig.getpixel((i, j))</span><br><span class="line"></span><br><span class="line">    avg_pixel = tmp / w / h</span><br><span class="line">    <span class="comment"># 找到灰度图像的阙值</span></span><br><span class="line">    <span class="built_in">print</span>(avg_pixel)  <span class="comment"># 236.21198586154773</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二值化处理</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            p = ig.getpixel((y, z)) <span class="comment"># 保持rgb的颜色到p</span></span><br><span class="line">            <span class="keyword">if</span> p &gt; avg_pixel: <span class="comment"># 由于阀值是浮点所以正常情况是不存在相等的问题，当然进行处理等于的情况也行</span></span><br><span class="line">                ig.putpixel((y, z), <span class="number">255</span>) <span class="comment"># 如果大于阙值则变白色</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ig.putpixel((y, z), <span class="number">0</span>) <span class="comment"># 反之亦然</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 噪点范围</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">point_list</span>(<span class="params">i, j, prange</span>): <span class="comment">#i和j是坐标，prange是范围</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(i - prange, i + prange): <span class="comment"># i以外的范围</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(j - prange, j + prange): <span class="comment"># j以外的范围</span></span><br><span class="line">            <span class="keyword">if</span> x == i <span class="keyword">and</span> y == j: <span class="comment">#中心点确定为黑色</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">yield</span> (x, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入需要降噪的二值化图片</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reduce_noise</span>(<span class="params">ig</span>):</span><br><span class="line">    w, h = ig.size</span><br><span class="line">    prange = <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="keyword">if</span> j &lt; h * <span class="number">0.06</span> <span class="keyword">or</span> j &gt; h * (<span class="number">1</span> - <span class="number">0.2</span>):</span><br><span class="line">                ig.putpixel((i, j), <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            p = ig.getpixel((i, j))</span><br><span class="line">            <span class="keyword">if</span> p &lt; <span class="number">100</span>:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> point_list(i, j, prange):</span><br><span class="line">                    <span class="comment"># 判断周围是否是白色,如果白色多 就是噪点</span></span><br><span class="line">                    <span class="keyword">if</span> ig.getpixel((x, y)) &gt; <span class="number">100</span>:</span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> count &gt; <span class="number">0.5</span> * ((prange * <span class="number">2</span> + <span class="number">1</span>) ** <span class="number">2</span> - <span class="number">1</span>):</span><br><span class="line">                    ig.putpixel((i, j), <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bz_image = Image.<span class="built_in">open</span>(<span class="string">&#x27;img_bz.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ig_tong = reduce_noise(bz_image)</span><br><span class="line">ig_tong.save(<span class="string">&#x27;img_test.png&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h2 id="Tesseract识别"><a href="#Tesseract识别" class="headerlink" title="Tesseract识别"></a>Tesseract识别</h2><h3 id="OCR识别概念"><a href="#OCR识别概念" class="headerlink" title="OCR识别概念"></a>OCR识别概念</h3><p>OCR （Optical Character Recognition）光学字符识别， 指的是对文本资料的图像文件进行分析识别处理，获取文集及版面信息的过程</p><h3 id="Tesseract-OCR"><a href="#Tesseract-OCR" class="headerlink" title="Tesseract-OCR"></a>Tesseract-OCR</h3><p>一个开源的字符识别引擎，我们可以用他来识别一些简单的验证码。</p><h3 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h3><p><a class="link"   href="https://digi.bib.uni-mannheim.de/tesseract/%E5%8F%AF%E8%87%AA%E8%A1%8C%E4%B8%8B%E8%BD%BD,%E7%82%B9%E5%87%BB%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%8D%B3%E5%8F%AF" >https://digi.bib.uni-mannheim.de/tesseract/可自行下载,点击下一步即可 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>;</p><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tesseract-ocr</span><br><span class="line">sudo apt-get install libtesseract-dev</span><br></pre></td></tr></table></figure></div><h3 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tesseract</span><br></pre></td></tr></table></figure></div><h2 id="Pytesser3"><a href="#Pytesser3" class="headerlink" title="Pytesser3"></a>Pytesser3</h2><p>是一个在Python内使用Tesseract-Ocr的库，<br>Pytesseract文档：<a class="link"   href="https://pypi.org/project/pytesseract/" >https://pypi.org/project/pytesseract/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Pytesseract</span><br></pre></td></tr></table></figure></div><h3 id="需要配置"><a href="#需要配置" class="headerlink" title="需要配置:"></a>需要配置:</h3><p>方法一:将pytesseract包下面__init__文件内tesseract_exe_name的值设置为tesseract.exe的路径,<br>方法二者在代码中指定</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6297cfc8-1ba3-4657-522f-3af683f07200/public"                      width = "500"                ><h3 id="Pytesseract认识："><a href="#Pytesseract认识：" class="headerlink" title="Pytesseract认识："></a>Pytesseract认识：</h3><p>Pytesseract识别效果不佳，如果想提高识别率，可以使用 jTessBoxEditor对Tesseract进行简单的训练。<br>OCR是一个专门的图像处理的领域<br>高精度的识别需要依靠深度学习、神经网络等技术<br>本章重点是对图片文件的理解</p><h2 id="滑块验证码"><a href="#滑块验证码" class="headerlink" title="滑块验证码"></a>滑块验证码</h2><p><strong>演示网址 <a class="link"   href="https://captcha1.scrape.center/" >https://captcha1.scrape.center/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p><p>​获取图片验证码,包含缺口图,滑块图,完整图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/29919799-14cf-45c8-2116-9a1119133400/public"                      width = "200"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fc642aab-3a43-4978-450c-2e5a7d17fd00/public"                      width = "500"                ><ul><li><p>三个canvas标签分别对应了缺口图，滑块图和完整图。</p><p>通过修改页面样式:</p><ol><li>让滑块隐藏，截取缺口图;</li><li>隐藏缺口图,显示滑块图,截取滑块图;</li><li>显示完整图，截取完整图。</li></ol></li></ul><h3 id="1-隐藏滑块-截取缺口图"><a href="#1-隐藏滑块-截取缺口图" class="headerlink" title="1.隐藏滑块,截取缺口图"></a>1.隐藏滑块,截取缺口图</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/821bfd11-b5f3-49c4-68b2-18d0e08abd00/public"                      width = "500"                ><p><strong>设置后效果</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8dfe7cdc-ee6a-4f1c-f455-6c26d8579d00/public"                      width = "200"                ><h3 id="2-隐藏缺口图-显示滑块图-截取滑块图"><a href="#2-隐藏缺口图-显示滑块图-截取滑块图" class="headerlink" title="2.隐藏缺口图,显示滑块图,截取滑块图"></a>2.隐藏缺口图,显示滑块图,截取滑块图</h3><p>隐藏缺口图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d719c08a-1b18-438c-9c15-3f86d727a900/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/070b3439-2923-4110-f09c-4ad5f3046100/public"                      width = "200"                ><p>下滑右侧栏可以看到对滑块的设置</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/264d50cb-bf68-48d7-7b34-e8ad9ac7e100/public"                      width = "500"                ><h3 id="3-显示完整图，截取完整图"><a href="#3-显示完整图，截取完整图" class="headerlink" title="3.显示完整图，截取完整图"></a>3.显示完整图，截取完整图</h3><p>选择第三个canvas    </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/62579c2a-a88b-47a1-f2c3-f714406c4e00/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8d66f8b5-3d3d-4a62-4601-f766818c7e00/public"                      width = "200"                ><h3 id="4-计算距离"><a href="#4-计算距离" class="headerlink" title="4. 计算距离"></a>4. 计算距离</h3><p>​计算缺口位置,滑块位置,滑块要移动的距离</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8ed44ab5-f8e2-42ce-fe07-4f34f4767600/public"                      width = "200"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0db8f229-4e38-4eed-2ef8-f306f72c0f00/public"                      width = "200"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4a196cc2-84d7-444d-df7d-d591bd984800/public"                      width = "200"                ><h3 id="5-确定距离"><a href="#5-确定距离" class="headerlink" title="5. 确定距离"></a>5. 确定距离</h3><p>距离&#x3D;滑块左边缘与缺口左边缘之间的距离<br>distance&#x3D;滑块左边缘X坐标-缺口左边缘X坐标</p><h3 id="一-更改元素样式-获取图片"><a href="#一-更改元素样式-获取图片" class="headerlink" title="一    更改元素样式, 获取图片"></a>一    更改元素样式, 获取图片</h3><ul><li>功能:获取验证图片</li><li>参数:无</li><li>返回值:<br>缺口图地址<br>滑块图地址<br>完整图地址</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_captcha</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#(1)隐藏滑块  得到缺口图</span></span><br><span class="line">    js_hide_slice = <span class="string">&#x27;document.getElementsByClassName(&quot;geetest_canvas_slice&quot;)[0].style.display=&quot;none&quot;&#x27;</span></span><br><span class="line">    driver.execute_script(js_hide_slice)</span><br><span class="line">    <span class="comment">#截取缺口图</span></span><br><span class="line">    part_imgpath=<span class="string">&quot;./part.png&quot;</span></span><br><span class="line">    driver.find_element(by=By.CLASS_NAME, value=<span class="string">&quot;geetest_canvas_bg&quot;</span>).screenshot(part_imgpath)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (2)显示滑块  隐藏缺口图  得到滑块图</span></span><br><span class="line">    js_show_slice = <span class="string">&#x27;document.getElementsByClassName(&quot;geetest_canvas_slice&quot;)[0].style.display=&quot;block&quot;&#x27;</span></span><br><span class="line">    js_hide_part= <span class="string">&#x27;document.getElementsByClassName(&quot;geetest_canvas_bg&quot;)[0].style.display=&quot;none&quot;&#x27;</span></span><br><span class="line">    driver.execute_script(js_show_slice+<span class="string">&quot;;&quot;</span>+js_hide_part)</span><br><span class="line">    <span class="comment"># 截取滑块图</span></span><br><span class="line">    slice_imgpath = <span class="string">&quot;./slice.png&quot;</span></span><br><span class="line">    driver.find_element_by_class_name(<span class="string">&quot;geetest_canvas_slice&quot;</span>).screenshot(slice_imgpath)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (3)显示完整图</span></span><br><span class="line">    js_show_full1 = <span class="string">&#x27;document.getElementsByClassName(&quot;geetest_canvas_fullbg&quot;)[0].style.display=&quot;block&quot;&#x27;</span></span><br><span class="line">    js_show_full2 = <span class="string">&#x27;document.getElementsByClassName(&quot;geetest_canvas_fullbg&quot;)[0].style.opacity=&quot;1&quot;&#x27;</span></span><br><span class="line">    driver.execute_script(js_show_full1+<span class="string">&quot;;&quot;</span>+js_show_full2)</span><br><span class="line">    <span class="comment"># 截取完整图</span></span><br><span class="line">    full_imgpath = <span class="string">&quot;./full.png&quot;</span></span><br><span class="line">    driver.find_element_by_class_name(<span class="string">&quot;geetest_canvas_fullbg&quot;</span>).screenshot(full_imgpath)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#还原目的 还原成原来的模样  包含缺口图与滑块</span></span><br><span class="line">    js_hide_full1 = <span class="string">&#x27;document.getElementsByClassName(&quot;geetest_canvas_fullbg&quot;)[0].style.display=&quot;none&quot;&#x27;</span></span><br><span class="line">    js_hide_full2 = <span class="string">&#x27;document.getElementsByClassName(&quot;geetest_canvas_fullbg&quot;)[0].style.opacity=&quot;0&quot;&#x27;</span></span><br><span class="line">    js_show_part = <span class="string">&#x27;document.getElementsByClassName(&quot;geetest_canvas_bg&quot;)[0].style.display=&quot;&quot;&#x27;</span></span><br><span class="line">    driver.execute_script(js_hide_full1 + <span class="string">&quot;;&quot;</span> + js_hide_full2+ <span class="string">&quot;;&quot;</span>+js_show_part)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> part_imgpath, slice_imgpath, full_imgpath</span><br></pre></td></tr></table></figure></div><h3 id="二-计算演示"><a href="#二-计算演示" class="headerlink" title="二    计算演示"></a>二    计算演示</h3><h4 id="找到滑块的x坐标"><a href="#找到滑块的x坐标" class="headerlink" title="找到滑块的x坐标"></a>找到滑块的x坐标</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_slice_x</span>(<span class="params">img_slice</span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(img_slice)</span><br><span class="line">    w, h = img.size</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            rgb = img.getpixel((x,y))  <span class="comment"># (255,255,255)</span></span><br><span class="line">            <span class="comment"># 判断比白色小就证明不是白色， 不是白色这个点就是我们所需要的值</span></span><br><span class="line">            <span class="keyword">if</span> rgb[<span class="number">0</span>] + rgb[<span class="number">1</span>] + rgb[<span class="number">2</span>] &lt; <span class="number">600</span>:  <span class="comment"># 765</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;滑块的坐标是&quot;</span>, x)</span><br><span class="line">                <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></div><h4 id="找到缺口图的x坐标"><a href="#找到缺口图的x坐标" class="headerlink" title="找到缺口图的x坐标"></a>找到缺口图的x坐标</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_bg_x</span>(<span class="params">img_bg, img_full</span>):</span><br><span class="line">    bg = Image.<span class="built_in">open</span>(img_bg)</span><br><span class="line">    full = Image.<span class="built_in">open</span>(img_full)</span><br><span class="line">    w, h = bg.size</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            bg_rgb = bg.getpixel((x, y))</span><br><span class="line">            full_rgb = full.getpixel((x, y))</span><br><span class="line">            r = bg_rgb[<span class="number">0</span>] - full_rgb[<span class="number">0</span>]</span><br><span class="line">            g = bg_rgb[<span class="number">1</span>] - full_rgb[<span class="number">1</span>]</span><br><span class="line">            b = bg_rgb[<span class="number">2</span>] - full_rgb[<span class="number">2</span>]</span><br><span class="line">            abs_value = <span class="built_in">abs</span>(r) + <span class="built_in">abs</span>(g) + <span class="built_in">abs</span>(b)</span><br><span class="line">            <span class="keyword">if</span> abs_value &gt; <span class="number">120</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;缺口的坐标是&#x27;</span>, x)</span><br><span class="line">                <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></div><h4 id="计算距离"><a href="#计算距离" class="headerlink" title="计算距离"></a>计算距离</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_distance</span>(<span class="params">img_bg, img_slice, img_full</span>):</span><br><span class="line">    slice_x = get_slice_x(img_slice)</span><br><span class="line">    bg_x = get_bg_x(img_bg, img_full)</span><br><span class="line">    data = <span class="built_in">abs</span>(bg_x-slice_x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;需要移动的距离是&quot;</span>, data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></div><h4 id="进行移动"><a href="#进行移动" class="headerlink" title="进行移动"></a>进行移动</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">move_silder</span>(<span class="params">tracks</span>):</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    element = driver.find_element(by=By.CLASS_NAME, value=<span class="string">&#x27;geetest_slider_button&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    action_chains = ActionChains(driver)</span><br><span class="line"></span><br><span class="line">    action_chains.click_and_hold(element)</span><br><span class="line">    action_chains.pause(<span class="number">1</span>) <span class="comment"># 在执行下一个动作之前 暂停1秒</span></span><br><span class="line">    action_chains.move_by_offset(tracks+<span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">    action_chains.pause(<span class="number">1</span>)</span><br><span class="line">    action_chains.move_by_offset(-<span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">    action_chains.pause(<span class="number">1</span>)</span><br><span class="line">    action_chains.release().perform()</span><br></pre></td></tr></table></figure></div><h4 id="总体执行"><a href="#总体执行" class="headerlink" title="总体执行"></a>总体执行</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    url = <span class="string">&#x27;https://captcha1.scrape.center/&#x27;</span></span><br><span class="line">    driver.get(url)</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    driver.find_element(by=By.CLASS_NAME, value=<span class="string">&#x27;el-button&#x27;</span>).click()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    img_bg, img_slice, img_full = get_captcha()</span><br><span class="line">    distance = get_distance(img_bg, img_slice, img_full)</span><br><span class="line">    move_silder(distance)</span><br></pre></td></tr></table></figure></div><h2 id="点触验证码"><a href="#点触验证码" class="headerlink" title="点触验证码"></a>点触验证码</h2><p>点触验证码是一种常见的反爬手段<br>解决方案有两种：一种是直接解决，这需要深度学习机器学习等图像处理技术，以大量的数据训练识别模型，最终达到模型足矣识别图片中的文字提示和应该点击的区域之间的对应关系。<br>这需要非常专业的设备，比如GPU运算，和专业的开发和维护人员。</p><p>因此市面上有专业解决此类问题的OCR解决提供商。也就是第二种间接解决的方案，调用第三方接口。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/75ccf027-b6ae-41fc-e61d-6061243f2100/public"                      width = "300"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7e6f566b-4240-4beb-f459-86191c916500/public"                      width = "300"                ><h2 id="B站登录案例"><a href="#B站登录案例" class="headerlink" title="B站登录案例"></a>B站登录案例</h2><p><code>https://www.bilibili.com/</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/073745e8-b46b-4d6f-d803-90611ae76000/public"                      width = "500"                ><h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>通过登录入口，发现其元素的类为<code>header-login-entry</code>, 利用<code>selenium</code>进行点击模拟</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/122a14e5-fbd2-468b-4c3d-8e4d9e013d00/public"                      width = "500"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> main_02</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.bilibili.com/&#x27;</span></span><br><span class="line"></span><br><span class="line">wb = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">wb.get(url)</span><br><span class="line"></span><br><span class="line">wb.find_element(by=By.CLASS_NAME, value=<span class="string">&#x27;header-login-entry&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">3</span>) <span class="comment"># 反应时间，隐性反应太麻烦了先强制等待</span></span><br></pre></td></tr></table></figure></div><h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>点击成功后，发现账号输入的元素为<code>placeholder=&quot;请输入账号&quot;</code>，利用<code>XPATH</code>锁定这个元素所在，密码也是一样的</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1d371197-2e86-42cc-e970-0dc7a395f200/public"                      width = "500"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//div/input[@placeholder=&quot;请输入账号&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//div/input[@placeholder=&quot;请输入密码&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p>然后同样的查看登录按钮的元素并锁定<code>btn_primary</code> </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/84470ca9-2378-4af6-dbc7-1c7938d6df00/public"                      width = "500"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wb.find_element(by=By.CLASS_NAME, value=<span class="string">&#x27;btn_primary &#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><p>挑选能覆盖所有验证码内容的类<code>geetest_widget</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c0039ec0-25a0-40ba-acd3-b6ac1c609600/public"                      width = "500"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//div[@class=&quot;geetest_widget&quot;]&#x27;</span>).screenshot(<span class="string">&#x27;input.png&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h3><p>进行第三方OCR操作</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> chaojiying_Python <span class="keyword">import</span> chaojiying</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">superying</span>():</span><br><span class="line">    supertest = chaojiying.Chaojiying_Client(<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;931146&#x27;</span>)</span><br><span class="line">    im = <span class="built_in">open</span>(<span class="string">&#x27;input.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">    res = supertest.PostPic(im, <span class="number">9004</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># data = &#123;&#x27;err_no&#x27;: 0,</span></span><br><span class="line"><span class="comment">#         &#x27;err_str&#x27;: &#x27;OK&#x27;,</span></span><br><span class="line"><span class="comment">#         &#x27;pic_id&#x27;: &#x27;2233720420832210145&#x27;,</span></span><br><span class="line"><span class="comment">#         &#x27;pic_str&#x27;: &#x27;49,280|59,172&#x27;,  #  |    ，    int()</span></span><br><span class="line"><span class="comment">#         &#x27;md5&#x27;: &#x27;8dc82695a1f5f8a60a298b7822a15893&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># （114,296）（59,180）</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 识别结果</span></span><br><span class="line">data = main_02.superying()</span><br><span class="line">pic_list = data.get(<span class="string">&#x27;pic_str&#x27;</span>).split(<span class="string">&quot;|&quot;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="第六步："><a href="#第六步：" class="headerlink" title="第六步："></a>第六步：</h3><p>进行模拟操作, 同样的确认提交的元素<code>geetest_commit_tip</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dd99aafb-4658-4161-1f04-0d75050b8900/public"                      width = "500"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">img_click</span>(<span class="params">click_list</span>):</span><br><span class="line">    <span class="comment"># 截图用是的哪个对象， 点击就必须用哪个对象  # 4.0.0</span></span><br><span class="line">    img_element = wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//div[@class=&quot;geetest_widget&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> click_list:  <span class="comment"># [&#x27;153,194&#x27;, &#x27;258,203&#x27;, &#x27;212,135&#x27;, &#x27;245,305&#x27;]</span></span><br><span class="line">        data  = i.split(<span class="string">&quot;,&quot;</span>)  <span class="comment"># [&quot;153&quot;, &quot;194&quot;]</span></span><br><span class="line">        x = <span class="built_in">int</span>(data[<span class="number">0</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(data[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 这段代码是使用Selenium的ActionChains类来模拟鼠标操作。</span></span><br><span class="line">        <span class="comment"># 其中，`wb`是WebDriver对象，`img_element`表示要移动到的元素，</span></span><br><span class="line">        <span class="comment"># `x`和`y`表示鼠标相对于元素左上角的偏移量。</span></span><br><span class="line">        <span class="comment"># 这段代码的作用是移动鼠标到指定元素的指定位置，并进行点击操作。</span></span><br><span class="line">        ActionChains(wb).move_to_element_with_offset(img_element, xoffset=x, yoffset=y).click().perform()</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//div/a/div[@class=&quot;geetest_commit_tip&quot;]&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">img_click(pic_list)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">利用selenium和像素比较进行基本的验证自动化执行</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="自动化工具" scheme="https://www.yiuhangblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    <category term="算法" scheme="https://www.yiuhangblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图像识别" scheme="https://www.yiuhangblog.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
    <category term="滑块验证" scheme="https://www.yiuhangblog.com/tags/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81/"/>
    
    <category term="点触验证" scheme="https://www.yiuhangblog.com/tags/%E7%82%B9%E8%A7%A6%E9%AA%8C%E8%AF%81/"/>
    
    <category term="字符验证" scheme="https://www.yiuhangblog.com/tags/%E5%AD%97%E7%AC%A6%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Selenium 自动化工具</title>
    <link href="https://www.yiuhangblog.com/2021/02/24/20210224selenium/"/>
    <id>https://www.yiuhangblog.com/2021/02/24/20210224selenium/</id>
    <published>2021-02-23T22:12:56.000Z</published>
    <updated>2024-02-28T10:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Selenium 是一个web自动化工具</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>自动化测试<br>通过它，我们可以写出自动化程序，模拟浏览器里操作web界面。 比如点击界面按钮，在文本框中输入文字 等操作。</li><li>获取信息<br>而且还能从web界面获取信息。 比如招聘网站职位信息，财经网站股票价格信息 等等，然后用程序进行分析处理。</li></ol><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6046ad3d-1616-4556-cad2-43aec3aba200/public"                      width = "300"                ><p>Selenium测试直接运行在浏览器中，就好像一个真正的用户在操作一样， 支持大部分主流的浏览器，包括IE(7,8,9,10,11)，Firefox，Safari，Chrome，Opera等。</p><p>我们可以利用它来模拟用户点击访问网站，绕过一些复杂的认证场景，通过selenium+驱动浏览器这种组合可以直接渲染解析js，绕过大部分的参数构造和反爬。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>新版本的Selenium已经不在支持phantomjs，原作者也已经放弃维护该项目了。</p><p>还有在做爬虫的时候尽量不要用这种方法，Selenium+浏览器的组合速度慢，应付不了数据量比较大的爬取以及并发爬取。并且很吃电脑资源。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A(selenium) --&gt; B(Chrome)</span><br><span class="line">    B --&gt; C(Chrome Drive)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># selenium ------http------&gt; 浏览器驱动， 去操作浏览器实现效果 -------&gt; 浏览器驱动 ----------&gt; selenium</span><br><span class="line"># 浏览器驱动相当于 http server</span><br><span class="line"># 浏览器驱动和浏览器版本要一致</span><br></pre></td></tr></table></figure></div><p>注意:每个驱动该对应每个浏览器;有时候浏览器会自动升级,导致浏览器不可用;</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="selenium安装"><a href="#selenium安装" class="headerlink" title="selenium安装"></a>selenium安装</h4><p><code>终端输入 pip install selenium==4.0.0</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么一定要装这个版本 </span><br><span class="line">我们在给图片定位的时候（0,0）坐标点是选在图片的左上角位置的</span><br></pre></td></tr></table></figure></div><h4 id="浏览器驱动安装"><a href="#浏览器驱动安装" class="headerlink" title="浏览器驱动安装"></a>浏览器驱动安装</h4><blockquote><p>chrome驱动下载地址:<br><a class="link"   href="https://chromedriver.chromium.org/downloads" >https://chromedriver.chromium.org/downloads <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>xxxxxxxxxx op1&#x3D;&gt;operation: 1.找到目标数据op2&#x3D;&gt;operation: 2.分析请求流程op3&#x3D;&gt;operation: 3.构造http请求op4&#x3D;&gt;operation: 4.提取数据op5&#x3D;&gt;operation: 5.数据持久化​op1(right)-&gt;op2(right)-&gt;op3(right)-&gt;op4(right)-&gt;op5(right)flowCreated with Raphaël 2.2.01.找到目标数据2.分析请求流程3.构造http请求4.提取数据5.数据持久化</p><p><a class="link"   href="https://developer.microsoft.com/zh-cn/microsoft-edge/tools/webdriver/" >Microsoft Edge WebDriver - Microsoft Edge Developer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>所有edge驱动版本</p><p><a class="link"   href="https://msedgewebdriverstorage.z22.web.core.windows.net/" >Microsoft Edge - Webdriver (windows.net) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>如何禁止更新–参考博客</p><p><a class="link"   href="https://blog.csdn.net/jylsrnzb/article/details/131492090" >https://blog.csdn.net/jylsrnzb/article/details/131492090 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p>然后把下载成功的驱动放到python环境的根目录</p><h4 id="验证运行是否成功（Chrome）为例"><a href="#验证运行是否成功（Chrome）为例" class="headerlink" title="验证运行是否成功（Chrome）为例"></a>验证运行是否成功（Chrome）为例</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">wb = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">wb.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p>运行后成功自动弹出Chrome即可：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2740a8fa-10ec-4b01-54bb-8b122882a300/public"                      width = "500"                ><h3 id="元素选取"><a href="#元素选取" class="headerlink" title="元素选取"></a>元素选取</h3><h4 id="find-element-s-by-…方法"><a href="#find-element-s-by-…方法" class="headerlink" title="find_element(s)by_…方法"></a>find_element(s)<em>by</em>_…方法</h4><p>在一个页面中有很多不同的策略可以定位一个元素。我们可以选择最合适的方法去查找元素。Selenium提供了下列的方法:</p><p>注： 其中的element加上一个s，则是对应的多个元素的查找方法</p><h4 id="老版本selenium的方法"><a href="#老版本selenium的方法" class="headerlink" title="老版本selenium的方法"></a>老版本selenium的方法</h4><table><thead><tr><th><strong>单个元素查找方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>find_element_by_xpath()</td><td>通过Xpath查找</td></tr><tr><td>find_element_by_class_name()</td><td>通过class属性查找</td></tr><tr><td>find_element_by_id()</td><td>通过id属性查找</td></tr><tr><td>find_element_by_name()</td><td>通过name属性进行查找</td></tr><tr><td>find_element_by_css_selector()</td><td>通过css选择器查找 语法规则</td></tr><tr><td>find_element_by_link_text()</td><td>通过链接文本查找</td></tr><tr><td>find_element_by_partial_link_text()</td><td>通过链接文本的部分匹配查找</td></tr><tr><td>find_element_by_tag_name()</td><td>通过标签名查找</td></tr></tbody></table><h4 id="新版本的用法：By对象查找"><a href="#新版本的用法：By对象查找" class="headerlink" title="新版本的用法：By对象查找"></a>新版本的用法：By对象查找</h4><p>除了以上的多种查找方式，还有两种私有方法集成了上面的所有的查找方法，让我们更方便的使用</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>find_element(By.XPATH, ‘&#x2F;&#x2F;button&#x2F;span’)</td><td>通过Xpath查找一个</td></tr><tr><td>find_elements(By.XPATH, ‘&#x2F;&#x2F;button&#x2F;span’)</td><td>通过Xpath查找多个</td></tr></tbody></table><p>其中的第一个参数可以选择使用查找的方法，By.xxx 使用xxx方式解析，解析方法如下：</p><p>注：By对象导入：  from selenium.webdriver.common.by   import   By</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ID = <span class="string">&quot;id&quot;</span> </span><br><span class="line">XPATH = <span class="string">&quot;xpath&quot;</span> </span><br><span class="line">LINK_TEXT = <span class="string">&quot;link text&quot;</span> </span><br><span class="line">PARTIAL_LINK_TEXT = <span class="string">&quot;partial link text&quot;</span> </span><br><span class="line">NAME = <span class="string">&quot;name&quot;</span> </span><br><span class="line">TAG_NAME = <span class="string">&quot;tag name&quot;</span> </span><br><span class="line">CLASS_NAME = <span class="string">&quot;class name&quot;</span> </span><br><span class="line">CSS_SELECTOR = <span class="string">&quot;css selector&quot;</span> </span><br></pre></td></tr></table></figure></div><h4 id="文本输入-提交"><a href="#文本输入-提交" class="headerlink" title="文本输入,提交"></a>文本输入,提交</h4><pre><code>chrome.find_element_by_id(&quot;all&quot;).send_keys(&quot;username&quot;)chrome.find_element_by_id(&quot;password&quot;).send_keys(&quot;password&quot;)chrome.find_element_by_css_selector(&quot;submit button&quot;).click()</code></pre><h4 id="使用案例（以豆瓣为例）"><a href="#使用案例（以豆瓣为例）" class="headerlink" title="使用案例（以豆瓣为例）"></a>使用案例（以豆瓣为例）</h4><p>通过分析搜索框元素发现输入的元素内容<code>search_text</code>：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0978a1c2-4285-4bfe-9363-4a9f645ef900/public"                      width = "500"                ><p>通过分析搜索框元素发现提交的元素内容<code>submit</code>：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/02973d1e-8c41-469c-f871-89dacc9f6500/public"                      width = "500"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">wb = webdriver.Edge()</span><br><span class="line"></span><br><span class="line">wb.get(<span class="string">&#x27;https://movie.douban.com/top250&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 老版本</span></span><br><span class="line"><span class="comment"># wb.find_element_by_xpath(&#x27;//input[@name=&quot;search_text&quot;]&#x27;).send_keys(&#x27;周杰伦&#x27;)</span></span><br><span class="line"><span class="comment"># wb.find_element_by_xpath(&#x27;//input[@type=&quot;submit&quot;]&#x27;).click()</span></span><br><span class="line"><span class="comment"># 新版本</span></span><br><span class="line">wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//input[@name=&quot;search_text&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;张译&#x27;</span>) <span class="comment"># 等同于输入框输入值</span></span><br><span class="line">wb.find_element(By.XPATH, value=<span class="string">&#x27;//div[@class=&quot;inp-btn&quot;]/input&#x27;</span>).click() <span class="comment"># 等同于点击搜索</span></span><br></pre></td></tr></table></figure></div><h2 id="动作切换"><a href="#动作切换" class="headerlink" title="动作切换"></a>动作切换</h2><h3 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h3><p>用selenium操作浏览器如果需要在打开新的页面，这个时候会有问题，因为我们用selenium操作的是第一个打开的窗口，所以新打开的页面我们是无法去操作的，所以我们要用到切换窗口：即handle切换的方法</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>js &#x3D; ‘window.open(“<a class="link"   href="https://www.baidu.com" );'chrome.execute_script(js)/">https://www.baidu.com&quot;);&#39;chrome.execute_script(js) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td>打开新标签</td></tr><tr><td>window_handles</td><td>获取所有页面窗口的句柄</td></tr><tr><td>current_window_handle</td><td>获取当前页面窗口的句柄</td></tr><tr><td>switch_to.window(window_name)</td><td>定位页面转到指定的window_name页面</td></tr></tbody></table><p>Window_handles的顺序并不是浏览器上标签的顺序，尽量避免多标签操作</p><h4 id="窗口切换案例（少量页面）"><a href="#窗口切换案例（少量页面）" class="headerlink" title="窗口切换案例（少量页面）"></a>窗口切换案例（少量页面）</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">wb = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">wb.get(<span class="string">&#x27;https://movie.douban.com/top250&#x27;</span>)</span><br><span class="line"></span><br><span class="line">js = <span class="string">&#x27;window.open(&quot;https://www.baidu.com&quot;)&#x27;</span></span><br><span class="line">wb.execute_script(js) <span class="comment"># 执行js代码</span></span><br><span class="line"><span class="comment"># time.sleep(10) # 10s避免闪退展示影响效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(wb.title) # 豆瓣电影 Top 250，焦点在https://movie.douban.com/top250上</span></span><br><span class="line"><span class="comment"># print(wb.window_handles) # [&#x27;14DB233ADDD3A1A9EF54DBDFF3412AE0&#x27;, &#x27;BD2EDCF05D390B30B0F86FA7BE5A4948&#x27;] 查看句柄</span></span><br><span class="line"></span><br><span class="line">wb.switch_to.window(wb.window_handles[<span class="number">1</span>]) <span class="comment"># 切换句柄到第二个[1]窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(wb.title) # 百度一下，你就知道 焦点在https://www.baidu.com上</span></span><br></pre></td></tr></table></figure></div><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><p>在实际的爬虫中，明明定位的路径没问题，这个时候我们可以考虑一下是否是该页面存在frame&#x2F;iframe&#x2F;frameset的问题导有时候我们会遇到找不到元素的问题致的定位不到元素。</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>switch_to.frame(frame_reference)</td><td>切到指定frame，可用id或name(str)、index(int)、元素(WebElement)定位</td></tr><tr><td>switch_to.parent_frame()</td><td>切到父级frame，如果已是主文档，则无效果， 相当于后退回去</td></tr><tr><td>switch_to_default_content()</td><td>切换到主页面，DOM树最开始的frame</td></tr></tbody></table><h4 id="页面切换案例"><a href="#页面切换案例" class="headerlink" title="页面切换案例"></a>页面切换案例</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7fe9c27b-1bf4-4a32-ff6a-1ae6f5878200/public"                      width = "500"                ><p>由于登录的元素后续跟随有时间戳<code>auto-id-1701347680519</code>，因此选用同样是id的<code>id=&quot;j-nav-login&quot;</code>，保持唯一性</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/29cb1dc7-157f-4133-c136-0f5423299400/public"                      width = "500"                ><p>对于弹窗，首先应获取iframe标签，切换句柄</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a408a82f-53ec-4121-05c6-a51dcbbbb700/public"                      width = "500"                ><p>然后根据其按钮所在元素模拟点击</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f9839300-70b4-4bb0-d810-2c6d45d6a800/public"                      width = "500"                ><p>账号密码通过<code>placeholder</code>来进行定位</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">目的： 实现 https://study.163.com/自动登录</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">wb = webdriver.Chrome()</span><br><span class="line">wb.maximize_window()  <span class="comment"># 全屏，避免元素点击不到</span></span><br><span class="line"></span><br><span class="line">wb.get(<span class="string">&#x27;https://study.163.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//span[@class=&quot;ux-btn th-bk-main ux-btn- ux-btn- ux-modal-btn um-modal-btn_ok th-bk-main&quot;]&#x27;</span>).click() <span class="comment">#点击弹窗</span></span><br><span class="line">wb.find_element(by=By.ID, value=<span class="string">&quot;j-nav-login&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 先获取iframe标签</span></span><br><span class="line">fr = wb.find_element(by=By.XPATH,value=<span class="string">&#x27;//iframe[@frameborder=&quot;0&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 再切换焦点到iframe上</span></span><br><span class="line">wb.switch_to.frame(fr)</span><br><span class="line"></span><br><span class="line">wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//input[@placeholder=&quot;请输入手机号&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;18300000000&#x27;</span>)</span><br><span class="line">wb.find_element(by=By.XPATH, value=<span class="string">&#x27;//input[@placeholder=&quot;请输入密码&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;qwe123...&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="页面弹窗"><a href="#页面弹窗" class="headerlink" title="页面弹窗"></a>页面弹窗</h3><p>有的时候还会遇到弹窗的问题， 主要有两种一种是浏览器弹窗（alert&#x2F;prompt），一种是自定义弹窗<br>自定义弹窗，就是一个自定义的div层，是隐藏页面中的，当触发了这个弹窗后，他就显示出来，这种方式我们通过正常的定位方式是可以定位到的。<br>alert弹窗，就要用下面的方法处理：</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 老的版本使用的是switch_to_alert</span><br><span class="line"># 现在使用的是switch_to</span><br></pre></td></tr></table></figure></div><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>switch_to</td><td>定位到alert弹窗，返回一个弹窗的对象</td></tr><tr><td>dismiss()</td><td>对弹窗对象的取消操作（相当于点击弹窗上的取消按钮）</td></tr><tr><td>accept()</td><td>对弹窗对象的确定操作（相当于点击弹窗上的确定按钮）</td></tr><tr><td>send_keys(key)</td><td>对弹窗对象内的输入框输入数据（针对于prompt弹窗）</td></tr><tr><td>text</td><td>获取弹窗内的文本</td></tr></tbody></table><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第一种--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;alert&quot;</span> <span class="attr">value</span>=<span class="string">&quot;alert&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;welcome! 请按确认继续&#x27;)&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第二种--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;confirm&quot;</span> <span class="attr">value</span>=<span class="string">&quot;confirm&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;confirm(&#x27;确认吗？&#x27;)&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第三种--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;prompt&quot;</span> <span class="attr">value</span>=<span class="string">&quot;prompt&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;var name=prompt(&#x27;请输入的名字:&#x27;); document.write(name)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wb = webdriver.Chrome()</span><br><span class="line">wb.get(<span class="string">r&#x27;\弹框.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="comment"># wb.find_element(by=By.ID, value=&#x27;alert&#x27;).click()</span></span><br><span class="line"><span class="comment"># print(wb.switch_to.alert.text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="comment"># wb.find_element(by=By.ID, value=&#x27;confirm&#x27;).click()</span></span><br><span class="line"><span class="comment"># print(wb.switch_to.alert.text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种</span></span><br><span class="line"><span class="comment"># wb.find_element(by=By.ID, value=&#x27;prompt&#x27;).click()</span></span><br><span class="line"><span class="comment"># prompt_tag = wb.switch_to.alert</span></span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line"><span class="comment"># prompt_tag.send_keys(&quot;CosTrace&quot;)</span></span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line"><span class="comment"># prompt_tag.accept()</span></span><br></pre></td></tr></table></figure></div><h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>在selenium操作浏览器的过程中，每一次请求url，selenium都会等待页面加载完成以后，才会将操作权限在交给我们的程序。但是，由于ajax和各种JS代码的异步加载问题，当一个页面被加载到浏览器时，该页面内的元素可以在不同的时间点被加载，这就使得元素的定位变得十分困难，当元素不再页面中时，使用selenium去查找的时候会抛出ElementNotVisibleException异常。为了解决这个问题，selenium提供了两种等待页面加载的方式，显示等待和隐式等待，让我们可以等待元素加载完成后在进行操作。</p><h3 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h3><p>显式等待： 显式等待指定某个条件，然后设置最长等待时间，程序每隔XX时间看一眼，如果条件成立，则执行下一步，否则继续等待，直到超过设置的最长时间，然后抛出超时异常（TimeoutException）。<br>显示等待主要使用了WebDriverWait类与expected_conditions模块。<br>一般写法：WebDriverWait(driver, timeout, poll_frequency, igonred_exceptions).until(method, message)<br>Driver：传入WebDriver实例。<br>timeout: 超时时间，等待的最长时间（同时要考虑隐性等待时间）<br>poll_frequency: 调用until中的方法的间隔时间，默认是0.5秒<br>ignored_exceptions: 忽略的异常，如果在调用until的过程中抛出这个元组中的异常，则不中断代码，继续等待.<br>Method：可执行方法<br>Message： 超时时返回的信息</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取等待的元素</span></span><br><span class="line">element = (By.XPATH, <span class="string">&#x27;//iframe[@frameborder=&quot;0&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 显式等待</span></span><br><span class="line">WebDriverWait(driver=wb, timeout=<span class="number">5</span>, poll_frequency=<span class="number">0.2</span>).until(EC.presence_of_element_located(element), <span class="string">&#x27;Not Found&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="expected-conditions条件"><a href="#expected-conditions条件" class="headerlink" title="expected_conditions条件"></a>expected_conditions条件</h3><p>expected_conditions是selenium的一个子模块，其中包含一系列可用于判断的条件，配合该类的方法，就能够根据条件而进行灵活地等待了</p><table><thead><tr><th><strong>ActionChains提供的方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>title_is                                             title_contains</td><td>这两个条件类验证title，验证传入的参数title是否等于或包含于driver</td></tr><tr><td><strong>presence_of_element_located</strong>            presence_of_all_elements_located</td><td>这两个条件验证元素是否出现，传入的参数都是元组类型的locator，如(By.ID, ‘kw’)顾名思义，一个只要一个符合条件的元素加载出来就通过；另一个必须所有符合条件的元素都加载出来才行</td></tr><tr><td>visibility_of_element_located                  invisibility_of_element_located                                              visibility_of</td><td>这三个条件验证元素是否可见，前两个传入参数是元组类型的locator，第三个传入WebElement</td></tr><tr><td>text_to_be_present_in_element text_to_be_present_in_element_value</td><td>判断某段文本是否出现在某元素中,一个判断元素的text，一个判断元素的value</td></tr><tr><td>frame_to_be_available_and_switch_to_it</td><td>判断frame是否可切入，可传入locator元组或者直接传入定位方式：id、name、index或WebElement</td></tr><tr><td>alert_is_present</td><td>判断是否有alert出现</td></tr><tr><td><strong>element_to_be_clickable</strong></td><td>判断元素是否可点击，传入locator</td></tr></tbody></table><h3 id="隐性等待"><a href="#隐性等待" class="headerlink" title="隐性等待"></a>隐性等待</h3><p>隐性等待implicitly_wait(xx) ：设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。<br>弊端就是程序会一直等待整个页面加载完成，就算需要的元素加载出来了还是需要等待。也就是一般情况下看到浏览器标签栏那个小圈不再转，才会执行下一步，<br>隐性等待对整个driver的周期都起作用，所以只要设置一次即可<br>隐性等待和显性等待可以同时用，但要注意：等待的最长时间取两者之中的大者<br>默认等待时间为0，可以通过下面的方式设置：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)        <span class="comment">#隐式等待，最长10s</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="强制等待"><a href="#强制等待" class="headerlink" title="强制等待"></a>强制等待</h3><p>强制等待就是不论如何,在此处都需要阻塞等待一段时间,及time.sleep()</p><h2 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h2><p>在selenium当中除了简单的点击动作外，还有一些稍微复杂的动作，就需要用到ActionChains（动作链）这个子模块来满足我们的需求。</p><p>ActionChains可以完成复杂一点的页面交互行为，例如元素的拖拽，鼠标移动，悬停行为，内容菜单交互。它的执行原理就是当调用ActionChains方法的时候不会立即执行，而是将所有的操作暂时储存在一个队列中，当调用perform()方法的时候，会按照队列中放入的先后顺序执行前面的操作。</p><p>ActionChains包：from selenium.webdriver.common.action_chains  import ActionChains</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th><strong>ActionChains提供的方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>click(on_element&#x3D;None)</td><td>鼠标左键单击传入的元素</td></tr><tr><td>double_click(on_element&#x3D;None)</td><td>双击鼠标左键</td></tr><tr><td>context_click(on_element&#x3D;None)</td><td>点击鼠标右键</td></tr><tr><td>click_and_hold(on_element&#x3D;None)</td><td>点击鼠标左键，按住不放</td></tr><tr><td>release(on_element&#x3D;None)</td><td>在某个元素位置松开鼠标左键</td></tr><tr><td>drag_and_drop(source, target)</td><td>拖拽到某个元素然后松开</td></tr><tr><td>drag_and_drop_by_offset(source, xoffset, yoffset)</td><td>拖拽到某个坐标然后松开</td></tr><tr><td>move_to_element(to_element)</td><td>鼠标移动到某个元素</td></tr><tr><td>move_by_offset(xoffset, yoffset)</td><td>移动鼠标到指定的x，y位置</td></tr><tr><td>move_to_element_with_offset(to_element, xoffset, yoffset)</td><td>将鼠标移动到距某个元素多少距离的位置</td></tr><tr><td>perform()</td><td>执行链中的所有动作</td></tr></tbody></table><h3 id="动作链示例"><a href="#动作链示例" class="headerlink" title="动作链示例"></a>动作链示例</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2a6f985c-e50f-43bf-bef4-468bae939900/public"                      width = "500"                ><p>通过查看登录按钮的元素，发现其父级类为<code>el-button</code>，确定登录对象</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4ab0edc0-3598-48ac-b4cb-c9a0d8975500/public"                      width = "500"                ><p>通过查看滑块元素，确定滑块对象<code>geetest_slider_button</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取驱动</span></span><br><span class="line">wb = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 挑选页面</span></span><br><span class="line">wb.get(<span class="string">&#x27;https://captcha1.scrape.center/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_silder</span>(<span class="params">tracks</span>):</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 确定登录对象</span></span><br><span class="line">    wb.find_element(by=By.CLASS_NAME, value=<span class="string">&#x27;el-button&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">3</span>) <span class="comment"># 或者使用隐式代码询问验证滑块是否跳出</span></span><br><span class="line">    <span class="comment"># 确定滑块对象</span></span><br><span class="line">    element = wb.find_element(by=By.CLASS_NAME, value=<span class="string">&#x27;geetest_slider_button&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 动作链</span></span><br><span class="line">    <span class="comment"># 实例化新对象</span></span><br><span class="line">    action_chains = ActionChains(wb)</span><br><span class="line"><span class="comment"># 进行模拟操作</span></span><br><span class="line">    action_chains.click_and_hold(element) <span class="comment"># 按住不放</span></span><br><span class="line">    action_chains.pause(<span class="number">1</span>)  <span class="comment"># 在执行下一个动作之前 暂停1秒</span></span><br><span class="line">    action_chains.move_by_offset(tracks, <span class="number">0</span>) <span class="comment"># 滑动tracks的距离</span></span><br><span class="line">    action_chains.pause(<span class="number">1</span>)  <span class="comment"># 在执行下一个动作之前 暂停1秒</span></span><br><span class="line">    action_chains.move_by_offset(tracks - <span class="number">50</span>, <span class="number">0</span>) <span class="comment">#滑动tracks-50的距离</span></span><br><span class="line">    action_chains.pause(<span class="number">1</span>)<span class="comment"># 在执行下一个动作之前 暂停1秒</span></span><br><span class="line">    action_chains.release().perform() <span class="comment"># 执行以上所有动作链</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move_silder(<span class="number">150</span>) <span class="comment"># 调用函数，tracks = 150</span></span><br></pre></td></tr></table></figure></div><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Chrome.refresh()</td><td>刷新页面</td></tr><tr><td>Chrome.close()</td><td>关闭当前标签</td></tr><tr><td>Chrome.quit()</td><td>关闭所有标签</td></tr><tr><td>Chrome.page_source</td><td>网页源代码</td></tr><tr><td>Chrome.cookies</td><td>本页保存的cookie</td></tr><tr><td>Chrome.maximize_window()</td><td>最大化窗口</td></tr></tbody></table><h3 id="无界面设置"><a href="#无界面设置" class="headerlink" title="无界面设置"></a>无界面设置</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置chrome  无界面</span></span><br><span class="line"><span class="keyword">from</span>  selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span>   webdriver</span><br><span class="line">chrome_options=Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">&quot;--headless&quot;</span>)</span><br><span class="line">wd_headless=webdriver.Chrome(options=chrome_options)</span><br><span class="line">wd_headless.get(<span class="string">&#x27;http://www.treejs.cn/v3/demo/cn/exedit/drag.html&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;无界面操纵&quot;</span>,wd_headless.page_source)  </span><br></pre></td></tr></table></figure></div><h3 id="截图功能"><a href="#截图功能" class="headerlink" title="截图功能"></a>截图功能</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">selenium的webdriver对象本身就自带截图功能</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wb = webdriver.Chrome()</span><br><span class="line">wb.maximize_window()</span><br><span class="line">wb.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># wb.save_screenshot(&#x27;baidu.png&#x27;) # 建议使用png</span></span><br><span class="line"><span class="comment"># wb.get_screenshot_as_file(&#x27;baidu01.png&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(wb.get_screenshot_as_base64())</span></span><br><span class="line"><span class="comment"># print(wb.get_screenshot_as_png())</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">Selenium库对各浏览器执行自动化处理</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Selenium" scheme="https://www.yiuhangblog.com/tags/Selenium/"/>
    
    <category term="自动化工具" scheme="https://www.yiuhangblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>页面解析工具</title>
    <link href="https://www.yiuhangblog.com/2021/02/23/20210223%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.yiuhangblog.com/2021/02/23/20210223%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7/</id>
    <published>2021-02-23T06:12:56.000Z</published>
    <updated>2024-02-28T10:50:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BS4"><a href="#BS4" class="headerlink" title="BS4"></a>BS4</h2><p>BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库，它的使用方式相对于正则来说更加的简单方便，常常能够节省我们大量的时间。</p><h3 id="官方中文文档"><a href="#官方中文文档" class="headerlink" title="官方中文文档"></a>官方中文文档</h3><p><a class="link"   href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" >https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>pip install beautifulsoup4</strong></p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><table><thead><tr><th><strong>解析器</strong></th><th><strong>使用方法</strong></th><th><strong>优势</strong></th><th><strong>劣势</strong></th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库执行速度适中文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>lxml XML 解析器</td><td>BeautifulSoup(markup, [“lxml”, “xml”])&#96;&#96;BeautifulSoup(markup, “xml”)</td><td>速度快唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性以浏览器的方式解析文档生成HTML5格式的文档</td><td>速度慢不依赖外部扩展</td></tr></tbody></table><p>由于这个解析的过程在大规模的爬取中是会影响到整个爬虫系统的速度的，所以推荐使用的是lxml，速度会快很多，而lxml需要单独安装：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;lxml&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p>如果一段HTML或XML文档格式不正确的话,那么在不同的解析器中返回的结果可能是不一样的，所以要指定某一个解析器。</p><h3 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e21bc48e-0303-49dd-5507-71e48db20900/public"                      width = "500"                ><h4 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h4><p>tag就是标签的意思，tag还有许多的方法和属性。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7b181ea1-88a1-429b-37cf-d5c83a623500/public"                      width = "500"                ><h4 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ea4c88db-d785-4838-620c-824192d29e00/public"                      width = "500"                ><h4 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ee60116b-f76c-4300-49be-2f984d22f100/public"                      width = "500"                ><h4 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b910c03f-f531-4694-3d13-2fbd9365e200/public"                      width = "500"                ><h3 id="Tag和遍历文档树"><a href="#Tag和遍历文档树" class="headerlink" title="Tag和遍历文档树"></a>Tag和遍历文档树</h3><p>tag对象可以说是BeautifulSoup中最为重要的对象，通过BeautifulSoup来提取数据基本都围绕着这个对象来进行操作。<br>首先，一个节点中是可以包含多个子节点和多个字符串的。例如html节点中包含着head和body节点。所以BeautifulSoup就可以将一个HTML的网页用这样一层层嵌套的节点来进行表示。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2de98c8e-4ce0-4841-7819-d1b9a3695600/public"                      width = "500"                ><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4  <span class="keyword">import</span> BeautifulSoup<span class="comment">#导包</span></span><br><span class="line">soup=BeautifulSoup(html_str,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">type</span>(soup)</span><br><span class="line"></span><br><span class="line">bs4.BeautifulSoup</span><br></pre></td></tr></table></figure></div><h4 id="Tag-标签取出简单示例"><a href="#Tag-标签取出简单示例" class="headerlink" title="Tag 标签取出简单示例"></a>Tag 标签取出简单示例</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html_data = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      我们都是害虫</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div id=&quot;info&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;&lt;span class=&quot;pl&quot;&gt;导演&lt;/span&gt;: &lt;span class=&quot;attrs&quot;&gt;&lt;a href=&quot;/celebrity/1362276/&quot; rel=&quot;v:directedBy&quot;&gt;邢文雄&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;&lt;span class=&quot;pl&quot;&gt;编剧&lt;/span&gt;: &lt;span class=&quot;attrs&quot;&gt;&lt;a href=&quot;/celebrity/1362276/&quot;&gt;邢文雄&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;actor&quot;&gt;&lt;span class=&quot;pl&quot;&gt;主演&lt;/span&gt;: &lt;span class=&quot;attrs&quot;&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1319032/&quot; rel=&quot;v:starring&quot;&gt;马丽&lt;/a&gt; / &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1355058/&quot; rel=&quot;v:starring&quot;&gt;魏翔&lt;/a&gt; / &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1362567/&quot; rel=&quot;v:starring&quot;&gt;陈明昊&lt;/a&gt; / &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1319540/&quot; rel=&quot;v:starring&quot;&gt;周大勇&lt;/a&gt; / &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;/celebrity/1363857/&quot; rel=&quot;v:starring&quot;&gt;黄才伦&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1350408/&quot; rel=&quot;v:starring&quot;&gt;艾伦&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1394939/&quot; rel=&quot;v:starring&quot;&gt;高海宝&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1386801/&quot; rel=&quot;v:starring&quot;&gt;韩笑&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1444360/&quot; rel=&quot;v:starring&quot;&gt;孙贵权&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1426220/&quot; rel=&quot;v:starring&quot;&gt;许猛&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1467304/&quot; rel=&quot;v:starring&quot;&gt;全容杓&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1467305/&quot; rel=&quot;v:starring&quot;&gt;卜俊男&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1316008/&quot; rel=&quot;v:starring&quot;&gt;张志忠&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1367242/&quot; rel=&quot;v:starring&quot;&gt;张建新&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1398260/&quot; rel=&quot;v:starring&quot;&gt;马驰&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1353283/&quot; rel=&quot;v:starring&quot;&gt;陶亮&lt;/a&gt; / &lt;/span&gt;&lt;span style=&quot;display: none;&quot;&gt;&lt;a href=&quot;/celebrity/1403276/&quot; rel=&quot;v:starring&quot;&gt;詹卢卡·佐帕&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;more-actor&quot; title=&quot;更多主演&quot;&gt;更多...&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;pl&quot;&gt;类型:&lt;/span&gt; &lt;span property=&quot;v:genre&quot;&gt;喜剧&lt;/span&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &lt;span class=&quot;pl&quot;&gt;制片国家/地区:&lt;/span&gt; 中国大陆&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;pl&quot;&gt;语言:&lt;/span&gt; 汉语普通话&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;pl&quot;&gt;上映日期:&lt;/span&gt; &lt;span property=&quot;v:initialReleaseDate&quot; content=&quot;2022-02-01(中国大陆)&quot;&gt;2022-02-01(中国大陆)&lt;/span&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;pl&quot;&gt;片长:&lt;/span&gt; &lt;span property=&quot;v:runtime&quot; content=&quot;109&quot;&gt;109分钟&lt;/span&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;pl&quot;&gt;又名:&lt;/span&gt; Too Cool To Kill&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;pl&quot;&gt;IMDb:&lt;/span&gt; tt16254308&lt;br&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_data, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取第一个a标签(tag)里面的文本信息</span></span><br><span class="line"><span class="built_in">print</span>(soup.a.text, <span class="built_in">type</span>(soup.a.text))  <span class="comment"># 邢文雄 &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(soup.a.string, <span class="built_in">type</span>(soup.a.string))  <span class="comment"># 邢文雄 &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签的属性</span></span><br><span class="line"><span class="built_in">print</span>(soup.a.get(<span class="string">&quot;href&quot;</span>))  <span class="comment"># /celebrity/1362276/</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子代标签</span></span><br><span class="line">body = soup.body</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(body.children))  <span class="comment"># &lt;list_iterator object at 0x000001B973C23BE0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后代标签</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(body.descendants))  <span class="comment"># &lt;generator object Tag.descendants at 0x00000159C796A510&gt;</span></span><br><span class="line">test = body.descendants</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 兄弟标签  （同级的标签，有相同的父标签）</span></span><br><span class="line">span = body.span</span><br><span class="line"><span class="built_in">print</span>(span.next_sibling.next_sibling.next_sibling)  <span class="comment"># 下一个兄弟标签</span></span><br><span class="line"><span class="comment"># 第一个兄弟是 &lt;br&gt;</span></span><br><span class="line"><span class="comment"># 第二个兄弟是 \n</span></span><br><span class="line"><span class="comment"># 第三个兄弟是第一个内容标签</span></span><br><span class="line"><span class="built_in">print</span>(span.previous_sibling.previous_sibling)</span><br><span class="line"><span class="comment"># 第一个兄弟是 \n</span></span><br><span class="line"><span class="comment"># 第二个兄弟是 我们所需的标签</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父类标签, 加了s就是所有父类标签，不加就是它本身</span></span><br><span class="line">p_parents = span.parents</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(p_parents))  <span class="comment"># &lt;generator object PageElement.parents at 0x000001A4DBD37E40&gt;</span></span><br></pre></td></tr></table></figure></div><h5 id="1-find-all"><a href="#1-find-all" class="headerlink" title="1.find_all"></a>1.find_all</h5><p>直接通过名字和属性来进行访问，很多时候只能适用于比较简单的一些场景，所以BeautifulSoup还提供了搜索整个文档树的方法find_all()。</p><ul><li><p>通过<code>name</code>搜索，<code>find_all(&#39;b&#39;)</code>可以直接查找出整个文档树中所有的b标签，并返回列表</p></li><li><p>通过属性搜索，我们在搜索的时候一般只有标签名是不够的，因为可能同名的标签很多，那么这时候我们就要通过标签的属性来进行搜索。这时候我们可以通过传递给<code>attrs</code>一个字典参数来搜索属性。<br><code>soup.find_all(attrs=&#123;&#39;class&#39;: &#39;sister&#39;&#125;)</code></p></li><li><p>通过文本搜索，在find_all()方法中，还可以根据文本内容来进行搜索。<code>soup.find_all(string=&quot;Elsie&quot;)</code></p></li><li><p>限制查找范围为子节点<br><code>find_all()</code>方法会默认的去所有的子孙节点中搜索，而如果将<code>recursive</code>参数设置为<code>False</code>，则可以将搜索范围限制在直接子节点中。 <code>soup.html.find_all(&quot;title&quot;, recursive=False)</code></p></li><li><p>通过正则表达式来筛选查找结果在BeautifulSoup中，也是可以与re模块进行相互配合的，将<code>re.compile</code>编译的对象传入<code>find_all()</code>方法，即可通过正则来进行搜索。<code>tags = soup.find_all(re.compile(&quot;^b&quot;))</code></p></li><li><p>以之前的数据为例子：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>, string=<span class="string">&#x27;邢文雄&#x27;</span>)) </span><br><span class="line"><span class="comment"># [&lt;a href=&quot;/celebrity/1362276/&quot; rel=&quot;v:directedBy&quot;&gt;邢文雄&lt;/a&gt;, &lt;a href=&quot;/celebrity/1362276/&quot;&gt;邢文雄&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;span&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;pl&#x27;</span>&#125;))</span><br><span class="line"><span class="comment"># [&lt;span class=&quot;pl&quot;&gt;导演&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;编剧&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;主演&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;类型:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;制片国家/地区:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;语言:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;上映日期:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;片长:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;又名:&lt;/span&gt;, &lt;span class=&quot;pl&quot;&gt;IMDb:&lt;/span&gt;]</span></span><br></pre></td></tr></table></figure></div></li></ul><h5 id="2-CSS选择器"><a href="#2-CSS选择器" class="headerlink" title="2.CSS选择器"></a>2.CSS选择器</h5><p>在BeautifulSoup中，同样也支持使用CSS选择器来进行搜索。使用select()，在其中传入字符串参数，就可以使用CSS选择器的语法来找到tag。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;span &gt; a&#x27;</span>))</span><br></pre></td></tr></table></figure></div><h2 id="JSON-Path"><a href="#JSON-Path" class="headerlink" title="JSON Path"></a>JSON Path</h2><p>JSON Path 是一种查询语言，用于从 JSON (JavaScript Object Notation) 数据中提取和处理信息。它类似于 SQL，但专门用于与 JSON 数据交互。使用 JSON Path，可以从复杂的 JSON 结构中轻松检索特定元素或值。这在处理大型或嵌套的 JSON 数据时特别有用。</p><p>以下是 JSON Path 的一些主要用途：</p><ol><li><strong>数据提取</strong>：从 JSON 数据中选择和提取数据，例如提取特定属性的值或筛选符合特定条件的元素。</li><li><strong>查询构建</strong>：创建灵活的查询来搜索和筛选 JSON 数据中的信息。</li><li><strong>数据处理</strong>：简化对复杂 JSON 结构的遍历和分析，无需编写复杂的代码。</li><li><strong>API 交互</strong>：常用于与 RESTful API 交互时解析和处理返回的 JSON 数据。</li></ol><p>JSON Path 通过提供一种简洁的语法来实现这些功能，使得从复杂的 JSON 结构中检索信息变得更加简单和直接。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonpath  <span class="comment"># pip install jsonpath</span></span><br><span class="line"></span><br><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&quot;resultCode&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;resultMsg&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reqId&quot;</span>: <span class="string">&quot;52f9f3e1-1d76-47b4-b2ae-226633b61476&quot;</span>,</span><br><span class="line">    <span class="string">&quot;systemTime&quot;</span>: <span class="string">&quot;1681991278593&quot;</span>,</span><br><span class="line">    <span class="string">&quot;videoInfo&quot;</span>: &#123;  <span class="comment"># 父亲</span></span><br><span class="line">        <span class="string">&quot;playSta&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;video_image&quot;</span>: <span class="string">&quot;https://image.pearvideo.com/cont/20170714/cont-1110173-10436784.png&quot;</span>,</span><br><span class="line">        <span class="string">&quot;srcUrl&quot;</span>: <span class="string">&quot;https://video.pearvideo.com/mp4/short/20170714/1681991278593-10632788-hd.mp4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;videos&quot;</span>: &#123;  <span class="comment"># 儿子</span></span><br><span class="line">            <span class="string">&quot;hdUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;hdflvUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sdUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sdflvUrl&quot;</span>: <span class="string">&quot;&quot;</span>,  <span class="comment"># 孙子</span></span><br><span class="line">            <span class="string">&quot;srcUrl&quot;</span>: <span class="string">&quot;https://video.pearvideo.com/mp4/short/20170714/1681991278593-10632788-hd.mp4&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># jsonpath(数据,&#x27;语法&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dic.get(&quot;videoInfo&quot;).get(&quot;videos&quot;).get(&quot;srcUrl&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(jsonpath.jsonpath(dic, &#x27;$..srcUrl&#x27;))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(jsonpath.jsonpath(dic, &#x27;$..video_image&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(jsonpath.jsonpath(dic, <span class="string">&#x27;$..videos.srcUrl&#x27;</span>)) </span><br><span class="line"><span class="comment">#[&#x27;https://video.pearvideo.com/mp4/short/20170714/1681991278593-10632788-hd.mp4&#x27;]</span></span><br></pre></td></tr></table></figure></div><h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。<br>相比于BeautifulSoup，Xpath在提取数据时会更有效率。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><code>pip install lxml</code></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>XPath 使用路径表达式在 XML&#x2F;HTML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p><p>下面列出了最有用的路径表达式：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/de2ffe23-49cf-4fe4-345d-94013c995300/public"                      width = "500"                ><h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h3><p>谓语用来查找某个或某些特定的节点或者包含某个指定值的节点<br>谓语被嵌在方括号中。在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果。实例:</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7e787bdf-efd4-48ce-f495-dd8785421c00/public"                      width = "500"                ><h3 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h3><p>XPath通配符可用来选取未知节点</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配任何元素节点。</td></tr><tr><td>@*</td><td>匹配任何属性节点。</td></tr><tr><td>node()</td><td>匹配任何类型的节点。</td></tr></tbody></table><h3 id="选取多个路径"><a href="#选取多个路径" class="headerlink" title="选取多个路径"></a>选取多个路径</h3><p>通过在路径表达式中使用”|”运算符，可以选取若干个路径。在下面的表格中，列出了一些路径表达式，以及这些表达式的结果：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/CosmicTrace/Remote_img_load/Blog/%E9%80%89%E5%8F%96%E5%A4%9A%E4%B8%AA%E8%B7%AF%E5%BE%84.png"                      width = "500"                ><h3 id="获取节点下文本"><a href="#获取节点下文本" class="headerlink" title="获取节点下文本"></a>获取节点下文本</h3><p>用text()获取某个节点下的文本，用string()获取某个节点下所有的文本。</p><h2 id="解析工具应用案例"><a href="#解析工具应用案例" class="headerlink" title="解析工具应用案例"></a>解析工具应用案例</h2><h3 id="1-明确目标："><a href="#1-明确目标：" class="headerlink" title="1. 明确目标："></a>1. 明确目标：</h3><p>以豆瓣电影排行榜为案例，抓取豆瓣电影的排行榜: <a class="link"   href="https://movie.douban.com/chart" >https://movie.douban.com/chart <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>需要提取的数据：</p><pre><code>1. movie_name2. movie_actor3. movie_score</code></pre><h3 id="2-进行伪装与请求："><a href="#2-进行伪装与请求：" class="headerlink" title="2. 进行伪装与请求："></a>2. 进行伪装与请求：</h3><p>进行伪装与请求：</p><ol><li>requests</li></ol><h3 id="3-交互响应中去提取我们需要的信息："><a href="#3-交互响应中去提取我们需要的信息：" class="headerlink" title="3. 交互响应中去提取我们需要的信息："></a>3. 交互响应中去提取我们需要的信息：</h3><ol><li>正则  2. bs4 3.  json()  4. xpath（可平替bs4）</li></ol><h3 id="4-保存结果"><a href="#4-保存结果" class="headerlink" title="4. 保存结果"></a>4. 保存结果</h3><ol><li>文件</li></ol><h3 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/chart&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">     <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line"> &#125;</span><br><span class="line">res = requests.get(url, headers=headers)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;douban.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># encoding=&#x27;utf8&#x27; 避免乱码</span></span><br><span class="line">     f.write(res.text)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 读取已保存的文件 douban.html</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;douban.html&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过etree读取改文件，建立对象page</span></span><br><span class="line">page = etree.HTML(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例操作，一层一层往下探究对象</span></span><br><span class="line">test = page.xpath(<span class="string">&#x27;//div[@class=&quot;pl2&quot;]/a/text()&#x27;</span>) <span class="comment"># xpath(xpath语法字符串)</span></span><br><span class="line"><span class="built_in">print</span>(test)</span><br><span class="line"> li = []</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> test:</span><br><span class="line">     movie_name = i.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> movie_name:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">     li.append(movie_name)</span><br><span class="line"></span><br><span class="line"> <span class="built_in">print</span>(li) <span class="comment"># 获取处理后的列表，分析拿到片名，但是因为还有其它值，不可能多个循环，所以实际应用不能这么操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际操作</span></span><br><span class="line">test2 = page.xpath(<span class="string">&#x27;//tr[@class=&quot;item&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">movie = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> yao:</span><br><span class="line">    <span class="comment"># 电影的名字</span></span><br><span class="line">    movie_name = i.xpath(<span class="string">&#x27;./td/a[@class=&quot;nbg&quot;]/@title&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    my_key = md5(movie_name.encode()).hexdigest()</span><br><span class="line">    <span class="comment"># print(movie_name)</span></span><br><span class="line">    <span class="comment"># 电影的演员表</span></span><br><span class="line">    movie_actor = i.xpath(<span class="string">&#x27;./td/div/p[@class=&quot;pl&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># print(movie_actor)</span></span><br><span class="line">    <span class="comment"># 电影的评分</span></span><br><span class="line">    <span class="comment"># movie_score = i.xpath(&#x27;//span[@class=&quot;rating_nums&quot;]/text()&#x27;)</span></span><br><span class="line">    <span class="comment"># movie_score = i.xpath(&#x27;./td/div/div/span[@class=&quot;rating_nums&quot;]/text()&#x27;)[0]</span></span><br><span class="line">    movie_score = i.xpath(<span class="string">&#x27;./td//span[@class=&quot;rating_nums&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># print(movie_score)</span></span><br><span class="line">    movie.update(&#123;my_key: [&#123;<span class="string">&#x27;片名&#x27;</span>:movie_name,<span class="string">&#x27;演员&#x27;</span>: movie_actor, <span class="string">&#x27;评分&#x27;</span>: movie_score&#125;]&#125;)</span><br><span class="line"><span class="built_in">print</span>(movie)</span><br></pre></td></tr></table></figure></div><h3 id="6-租客网代码示例"><a href="#6-租客网代码示例" class="headerlink" title="6. 租客网代码示例"></a>6. 租客网代码示例</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://cs.zu.anjuke.com/?from=HomePage_TopBar&#x27;</span></span><br><span class="line"></span><br><span class="line">res = requests.get(url)</span><br><span class="line"></span><br><span class="line">tree = etree.HTML(res.text)</span><br><span class="line"></span><br><span class="line">div = tree.xpath(<span class="string">&#x27;//div[@class=&quot;zu-itemmod clearfix&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> div:</span><br><span class="line">    <span class="comment"># 标题</span></span><br><span class="line">    title = i.xpath(<span class="string">&#x27;./div/h3/a/b[@class=&quot;strongbox&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 价格</span></span><br><span class="line">    price = i.xpath(<span class="string">&#x27;./div//strong[@class=&quot;price&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 地址</span></span><br><span class="line">    address = i.xpath(<span class="string">&#x27;./div//address[@class=&quot;details-item tag&quot;]/text()&#x27;</span>)</span><br><span class="line">    <span class="comment"># [&#x27;\n                            &#x27;, &#x27;\xa0\xa0\n                            芙蓉&#x27;, &#x27;五一广场 &#x27;, &#x27;韭菜园路101号                        &#x27;]</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1.使用join 把列表转换成字符串了</span></span><br><span class="line"><span class="string">    2.字符串使用replace进行替换</span></span><br><span class="line"><span class="string">    总结： 先拼接再替换</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    address = <span class="string">&#x27;&#x27;</span>.join(address).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(address)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存进文件中</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;租房信息.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;标题：&quot;</span>+ title + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;价格：&quot;</span> + price + <span class="string">&quot;\t&quot;</span>+ <span class="string">&quot;地址：&quot;</span> + address + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">利用beautifulsoup4 Xpath JSONPath等工具对各网站进行基本的解析</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Requests" scheme="https://www.yiuhangblog.com/tags/Requests/"/>
    
    <category term="页面解析" scheme="https://www.yiuhangblog.com/tags/%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    
    <category term="BS4" scheme="https://www.yiuhangblog.com/tags/BS4/"/>
    
    <category term="beautifulsoup4" scheme="https://www.yiuhangblog.com/tags/beautifulsoup4/"/>
    
    <category term="Xpath" scheme="https://www.yiuhangblog.com/tags/Xpath/"/>
    
  </entry>
  
  <entry>
    <title>Requests</title>
    <link href="https://www.yiuhangblog.com/2021/02/22/20210222requests/"/>
    <id>https://www.yiuhangblog.com/2021/02/22/20210222requests/</id>
    <published>2021-02-22T10:12:32.000Z</published>
    <updated>2024-02-28T10:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>Requests是一个优雅而简单的Python HTTP库，专为人类而构建。</li><li>中文官方文档：<a class="link"   href="http://cn.python-requests.org/zh_CN/latest/%E3%80%82" >http://cn.python-requests.org/zh_CN/latest/。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>英文文档：<a class="link"   href="http://docs.python-requests.org/en/master/api/" >http://docs.python-requests.org/en/master/api/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ol><h3 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h3><p>Requests的作者Kenneth Reitz同样是一个富有传奇色彩的人物。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ebe94005-9242-490a-c95f-3f8f65caeb00/public"                      width = "300"                ><p>Requests目前基本上完全满足web请求的所有需求，以下是requests的特性:</p><ol><li>Keep-Alive &amp; 连接池</li><li>国际化域名和URL</li><li>带持久Cookie的会话</li><li>浏览器式的SSL认证</li><li>自动内容解码</li><li>基本&#x2F;摘要时的身份认证</li><li>优雅的 key&#x2F;value Cookie</li><li>自动解压</li><li>Unicode 响应体</li><li>HTTP(S) 代理支持</li><li>文件分块上传</li><li>流下载</li><li>连接超时</li><li>分块请求</li><li>支持 .netrc</li></ol><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>使用 Requests 发送网络请求非常简单。导包, 之后添加方法进行。</p><p>Requests的请求不再像urllib一样需要去构造各种Request、opener和handler，使用Requests构造的方法，并在其中传入需要的参数即可。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/51b569f1-0498-4f36-6d53-00c89b166c00/public"                      width = "500"                ><p>发起请求的方法变得简单，只需要着重关注一下发起请求的参数 ，10个重要的参数。</p><pre><code>    method, 请求方法    url,  资源地址    params=None, 查询参数也叫做查询字符串    data=None,   post请求的表单数据    headers=None, 请求头    cookies=None, cookies    files=None, # 文件    auth=None, # 校验身份    timeout=None, 超时时间    allow_redirects=True, # 重定向    proxies=None, 代理    hooks=None,#  钩子函数    stream=None,#     verify=None, 证书忽略    cert=None, # 字符串 --证书的地址  元组（）    json=None,  post 请求的JSON数据</code></pre><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>传递URL参数也不用再像urllib中那样需要去拼接URL，而是简单的，构造一个字典，并在请求时将其传递给params参数，此时，查看请求的URL，则可以看到URL已经构造正确了，并且，有时候我们会遇到相同的url参数名，但有不同的值，而python的字典又不支持键的重名，那么我们可以把键的值用列表表示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7f8762cd-2cb4-4508-d72c-d60336cce600/public"                      width = "500"                ><h3 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h3><p>如果想自定义请求的Headers，同样的将字典数据传递给headers参数。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ad80f763-27fe-436f-8feb-d7d8afcc1f00/public"                      width = "500"                ><h3 id="添加cookies"><a href="#添加cookies" class="headerlink" title="添加cookies"></a>添加cookies</h3><p>Requests中自定义Cookies也不用再去构造CookieJar对象，直接将字典递给cookies参数。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b586a3c7-624d-43de-a157-6801d316e400/public"                      width = "500"                ><h3 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h3><p>设置访问超时，设置timeout参数即可。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/92288210-3b84-4085-ec2b-b42029223a00/public"                      width = "500"                ><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>当我们需要使用代理时，同样构造代理字典，传递给proxies参数。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d89b6db6-9852-478b-b526-6100eabd8900/public"                      width = "500"                ><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>很多网站是http开头，为了不影响老客户，原网站不动，当访问http的原网址时，重定向到新的https网址，在requests中 allow_redirects默认是True，如果是False则不允许重定向，也就无法重定向新网址获取数据。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a974fb9f-dd8d-4d1c-a2a2-086c7e427300/public"                      width = "500"                ><h3 id="证书忽略验证"><a href="#证书忽略验证" class="headerlink" title="证书忽略验证"></a>证书忽略验证</h3><p>有时候我们使用了抓包工具，这个时候由于抓包工具提供的证书并不是由受信任的数字证书颁发机构颁发的，所以证书的验证会失败，所以我们就需要关闭证书验证。在请求的时候把verify参数设置为False就可以关闭证书验证了。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/06669ccd-5e63-4ad6-b215-87b1b0746300/public"                      width = "500"                 ><h3 id="POST请求发送Json数据"><a href="#POST请求发送Json数据" class="headerlink" title="POST请求发送Json数据"></a>POST请求发送Json数据</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4d7b510d-c549-4447-607d-8274502ec600/public"                      width = "500"                ><h3 id="POST请求发送Form表单数据"><a href="#POST请求发送Form表单数据" class="headerlink" title="POST请求发送Form表单数据"></a>POST请求发送Form表单数据</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c813a276-37d0-496f-15fe-017503fe4e00/public"                      width = "500"                ><h3 id="POST示例"><a href="#POST示例" class="headerlink" title="POST示例"></a>POST示例</h3><p>以<a class="link"   href="https://www.17k.com/%E7%99%BB%E5%BD%95%E4%B8%BA%E6%A1%88%E4%BE%8B%EF%BC%8C%E9%A6%96%E5%85%88%E5%88%86%E6%9E%90%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91" >https://www.17k.com/登录为案例，首先分析登录逻辑 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><blockquote><p>尝试登录操作，发现操作后会其Headers下会显示请求的网址<a class="link"   href="https://passport.17k.com/ck/user/login%EF%BC%8C%E4%B8%94%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E4%B8%BAPOST" >https://passport.17k.com/ck/user/login，且请求类型为POST <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d24eb36f-d6c9-431e-b80d-369e73653c00/public"                      width = "500"                ></blockquote><p>随后分析所需的构造参数</p><blockquote><p>在Payload下可以发现其为表单数据，应构造的参数为{loginName:  123， password: 123}</p><p>另外还需添加headers伪装</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d8c6059c-4b66-44d3-75d9-38f3f5360100/public"                      width = "500"                ></blockquote><p>接着根据分析的要素，构造请求，向服务器提交数据即可</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&#x27;https://passport.17k.com/ck/user/login&#x27;</span></span><br><span class="line"></span><br><span class="line">form_data = &#123;</span><br><span class="line">    <span class="string">&#x27;loginName&#x27;</span>:  <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.post(url, data=form_data, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure></div><h2 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(res.text)#直接转换成字符串 非字节码</span><br><span class="line">print(res.content)#图片数据 使用此参数</span><br><span class="line">print(res.status_code)#状态码</span><br><span class="line">print(res.json()[&quot;headers&quot;][&quot;User-Agent&quot;])#自动转换成 字典格式</span><br><span class="line"># 一定要确保使用的格式是json格式的数据</span><br><span class="line">print(res.headers)#响应头</span><br><span class="line">print(res.cookies)#响应cookie</span><br><span class="line">print(res.url)#请求的url</span><br><span class="line">print(res.request.url)#请求的url</span><br><span class="line">print(res.request.headers)#请求头</span><br></pre></td></tr></table></figure></div><h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>通过Requests发起请求获取到的，是一个requests.models.Response对象。通过这个对象我们可以很方便的获取响应的内容。<br>之前通过urllib获取的响应，读取的内容都是bytes的二进制格式，需要我们自己去将结果decode()一次转换成字符串数据。<br>而Requests通过text属性，就可以获得字符串格式的响应内容。</p><h3 id="字符编码和二进制数据"><a href="#字符编码和二进制数据" class="headerlink" title="字符编码和二进制数据"></a>字符编码和二进制数据</h3><p>Requests会自动的根据响应的报头来猜测网页的编码是什么，然后根据猜测的编码来解码网页内容，基本上大部分的网页都能够正确的被解码。而如果发现text解码不正确的时候，就需要我们自己手动的去指定解码的编码格式。而如果需要获得原始的二进制数据，那么使用content属性即可。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6fb98545-be0f-498f-8181-9d0c06acc200/public"                      width = "500"                ><h2 id="session方法"><a href="#session方法" class="headerlink" title="session方法"></a>session方法</h2><p>session方法是requests库发起请求的一种方法，这种方法会自动保存访问页面得到的cookie值，从而再次访问的时候会自动携带cookie，使得操作cookie方便，不需要我们自己添加cookie了。常用于登录；</p><h3 id="经典的登录逻辑"><a href="#经典的登录逻辑" class="headerlink" title="经典的登录逻辑"></a>经典的登录逻辑</h3><p>功能:自动更新请求头信息，常用在账号登录的时候，先访问登录页url，再访问数据提交的url<br>例:12306</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/59675270-9f1f-4e1a-8047-e711ab21b700/public"                      width = "500"                ><h3 id="session的使用"><a href="#session的使用" class="headerlink" title="session的使用"></a>session的使用</h3><p>基本的使用方法与requests.get 相似，使用的session的时候需要先创建session对象</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session=requests.session()#创建session对象</span><br><span class="line">session.headers=headers#添加请求头</span><br><span class="line">res_ss=session.get(index_url)</span><br></pre></td></tr></table></figure></div><h3 id="session示例"><a href="#session示例" class="headerlink" title="session示例"></a>session示例</h3><p>首先利用测试网址编入cookies</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">session = requests.session()</span><br><span class="line">resp_ss = session.get(<span class="string">&#x27;http://httpbin.org/cookies/set/CosTrace/12345678&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp_ss.text)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;cookies&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;CosTrace&quot;: &quot;12345678&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><p>采用<code>requests.get</code>方法尝试获取cookies，发现不存在值，这是因为<code>requests</code>方法本身不存在存储的功能</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resp_req = requests.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp_req.text)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;cookies&quot;: &#123;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><p>随后我们用<code>session</code>方法尝试获取cookies，发现成功</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resp_req = session.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp_req.text)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;cookies&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;CosTrace&quot;: &quot;12345678&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><h2 id="Requests案例1-简易百度图片抓取"><a href="#Requests案例1-简易百度图片抓取" class="headerlink" title="Requests案例1  - 简易百度图片抓取"></a>Requests案例1  - 简易百度图片抓取</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">目标：百度图片抓取</span></span><br><span class="line"><span class="string">1. 打开网页 --&gt;请求 --&gt;伪装</span></span><br><span class="line"><span class="string">    a. 安装模块 pip install requests</span></span><br><span class="line"><span class="string">    b. 请求失败的话就在伪装继续添加标头</span></span><br><span class="line"><span class="string">2. 下载图片 --保存本地 --&gt;交互</span></span><br><span class="line"><span class="string">    a. 把响应内容中的图片url提取出来</span></span><br><span class="line"><span class="string">    b. 对每个图片的url，进行请求二进制的方法进行保存</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests, re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值url</span></span><br><span class="line">url = <span class="string">&#x27;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=index&amp;fr=&amp;hs=0&amp;xthttps=000000&amp;sf=1&amp;fmq=&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;oq=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;rsp=-1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表头字典，制作伪装</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值请求服务, 获取http数据</span></span><br><span class="line">resp = requests.get(url, headers=headers)</span><br><span class="line">http_data = resp.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式提取图片</span></span><br><span class="line">re_data = re.findall(<span class="string">&#x27;thumbURL&quot;:&quot;(.*?)&quot;&#x27;</span>, http_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环提取, md5去重命名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> re_data:</span><br><span class="line">    name_encode = md5(i.encode()).hexdigest()</span><br><span class="line">    img_resp = requests.get(i)</span><br><span class="line">    b_img_data = img_resp.content</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;name_encode&#125;</span>.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(b_img_data)</span><br></pre></td></tr></table></figure></div><h2 id="Requests案例2-多页百度图片抓取"><a href="#Requests案例2-多页百度图片抓取" class="headerlink" title="Requests案例2 - 多页百度图片抓取"></a>Requests案例2 - 多页百度图片抓取</h2><blockquote><p>首先分析，在标头的响应查看滚动页面时返回的URL，分析翻页时的变化：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在标头的响应查看滚动页面时返回的url</span></span><br><span class="line">url_1 = <span class="string">&#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=8578568584458070132&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;queryWord=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=60&amp;rn=30&amp;gsm=3c&amp;1701269373791=&#x27;</span></span><br><span class="line">url_2 = <span class="string">&#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=8578568584458070132&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;queryWord=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=90&amp;rn=30&amp;gsm=5a&amp;1701269630311=&#x27;</span></span><br><span class="line">url_3 = <span class="string">&#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=8578568584458070132&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;queryWord=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=120&amp;rn=30&amp;gsm=78&amp;1701269630813=&#x27;</span></span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>随后比较三个URL直接的关系，可以发现大部分都是相同，因此删除所有相同的部分进行比较：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析链接不同的规律，下面是不同的部分：</span></span><br><span class="line"><span class="comment"># pn: 当前显示的图片数量，一次翻页显示30张，pn（Page Number）: 这个参数通常用于分页功能，表示当前显示的页面编号或者某些情况下显示的项目数量。</span></span><br><span class="line"><span class="comment"># 例如，在图像搜索结果中，pn=90可能表示当前显示的是第90张图片或第90页的内容。</span></span><br><span class="line"><span class="comment"># gsm未知，可能表示一个特定的标识符或编码，用于追踪请求或控制返回的内容</span></span><br><span class="line"><span class="comment"># 后面的长数值是时间戳，时间戳通常用于记录事件发生的具体时间，有时用于缓存控制或确保请求的唯一性</span></span><br><span class="line"></span><br><span class="line">url_1_compar = <span class="string">&#x27;pn=60&amp;gsm=3c&amp;1701269373791=&#x27;</span></span><br><span class="line">url_2_compar = <span class="string">&#x27;pn=90&amp;gsm=5a&amp;1701269630311=&#x27;</span></span><br><span class="line">url_3_compar = <span class="string">&#x27;pn=120&amp;gsm=78&amp;1701269630813=&#x27;</span></span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>最后把完整URL输入到浏览器，查看删减这三个不同的部分哪些会影响数据的获取：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过删减url发现时间戳和gsm均不影响翻页，因此剩余影响数据获取的不同点是pn，且每30一获取：</span></span><br><span class="line">url_1_compar_2 = <span class="string">&#x27;pn=60&#x27;</span></span><br><span class="line">url_2_compar_2 = <span class="string">&#x27;pn=90&#x27;</span></span><br><span class="line">url_3_compar_2 = <span class="string">&#x27;pn=120&#x27;</span></span><br></pre></td></tr></table></figure></div></blockquote><p>通过分析可以发现百度翻页规律，随后编写循环（此例为三页）配合案例1的伪装即可获取</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表头字典，制作伪装</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;images&#x27;</span>):</span><br><span class="line">    os.mkdir(<span class="string">&#x27;images&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写循环，每30返回一次：</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    url = <span class="string">f&#x27;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=8578568584458070132&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;queryWord=%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=<span class="subst">&#123;i * <span class="number">30</span>&#125;</span>&amp;rn=30&#x27;</span></span><br><span class="line">    resp = requests.get(url, headers=headers)  <span class="comment"># 赋值请求服务, 获取http数据</span></span><br><span class="line">    data = resp.json()  <span class="comment"># json -&gt; 字符串转成dict格式，前提条件就是resp一定时json格式</span></span><br><span class="line">    data_list = data.get(<span class="string">&quot;data&quot;</span>)  <span class="comment"># 这是一个列表</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> data_list:</span><br><span class="line">        img_url = j.get(<span class="string">&quot;thumbURL&quot;</span>)  <span class="comment"># 获取该变量下的值</span></span><br><span class="line">        <span class="keyword">if</span> img_url:  <span class="comment"># 当请求到数据时</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                img_url_encode = md5(img_url.encode()).hexdigest()  <span class="comment"># md5去重，唯一标识符</span></span><br><span class="line">                img_resp = requests.get(img_url)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(e)  <span class="comment"># 是否有脏数据</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b_img_data = img_resp.content</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;images/&#x27;</span> + img_url_encode + <span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(b_img_data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">Python Requests库介绍和基本使用</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Requests" scheme="https://www.yiuhangblog.com/tags/Requests/"/>
    
  </entry>
  
  <entry>
    <title>爬虫与网络基础理论</title>
    <link href="https://www.yiuhangblog.com/2021/02/21/20210221%E7%88%AC%E8%99%AB%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    <id>https://www.yiuhangblog.com/2021/02/21/20210221%E7%88%AC%E8%99%AB%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</id>
    <published>2021-02-20T19:12:54.000Z</published>
    <updated>2024-02-28T10:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-爬虫概念"><a href="#一-爬虫概念" class="headerlink" title="一.爬虫概念"></a>一.爬虫概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>网络爬虫也叫网络蜘蛛，特指一类自动批量下载网络资源的程序，这是一个比较口语化的定义。</li><li>更加专业和全面对的定义是：<strong>网络爬虫是伪装成客户端与服务端进行数据交互的程序</strong>。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>数据采集<strong>（重要）</strong><ul><li>大数据监控，产品推荐</li><li>大数据杀熟，某平台订酒店时间长了会贵一点</li><li>灰产，内部买卖</li></ul></li><li>搜索引擎<ul><li>百度，谷歌（比较少），主要还是页面存储</li></ul></li><li>模拟操作<ul><li>测试机器人</li><li>灌水机器人（快速刷屏）</li></ul></li></ol><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ol><li>通用爬虫<ul><li>百度，谷歌</li></ul></li><li>聚焦爬虫<ul><li>专门为某站点制作的</li></ul></li><li>增量爬虫<ul><li>监控站点，一旦有更新就爬取（在线小说，漫画）</li></ul></li><li>深网爬虫<ul><li>输入表单才能获取数据（登录账号密码之后才能获取）</li></ul></li></ol><h3 id="爬虫开发的重难点"><a href="#爬虫开发的重难点" class="headerlink" title="爬虫开发的重难点"></a>爬虫开发的重难点</h3><ol><li><p>数据的获取</p><ul><li>伪装</li></ul></li><li><p>采集的速度</p><ul><li>多爬虫</li><li>分布式</li></ul></li></ol><h2 id="二-网络与HTTP-HTTPS协议"><a href="#二-网络与HTTP-HTTPS协议" class="headerlink" title="二.网络与HTTP&#x2F;HTTPS协议"></a>二.网络与HTTP&#x2F;HTTPS协议</h2><h3 id="网络类型（Network-Types）"><a href="#网络类型（Network-Types）" class="headerlink" title="网络类型（Network  Types）"></a>网络类型<strong>（Network  Types）</strong></h3><p>网络类型主要指的是不同的网络构建方式和范围：</p><p>更多关注于网络的物理或逻辑结构和地理范围。它们描述的是网络的“形状”和“大小”，以及设备间连接的物理或无线方式。</p><blockquote><h4 id="1-本地区域网-LAN-Local-Area-Network"><a href="#1-本地区域网-LAN-Local-Area-Network" class="headerlink" title="1. 本地区域网 (LAN - Local Area Network)"></a>1. 本地区域网 (LAN - Local Area Network)</h4><ul><li><strong>定义</strong>：LAN是一个小范围内的网络，通常用于单个建筑或一组紧密相连的建筑。</li><li><strong>用途</strong>：用于连接个人电脑或工作站，以便于共享资源（如打印机）和交换信息。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b1b8fc73-a200-4851-39c2-7a1215f04400/public"                      width = "500"                ></blockquote><blockquote><h4 id="2-广域网-WAN-Wide-Area-Network"><a href="#2-广域网-WAN-Wide-Area-Network" class="headerlink" title="2. 广域网 (WAN - Wide Area Network)"></a>2. 广域网 (WAN - Wide Area Network)</h4><ul><li><strong>定义</strong>：WAN覆盖广泛的地理区域，可以是城市、国家甚至跨国。</li><li><strong>用途</strong>：用于连接不同地理位置的LANs，允许不同地区的用户和组织之间交换数据。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b170bba4-9797-4d82-dd05-3a989c0af600/public"                      width = "500"                ><p><strong>芝加哥（Accounts Receivable）</strong></p><ul><li><strong>网络</strong>：使用IPv4。</li><li><strong>设备</strong>：包括iSeries A服务器，有一个IPv6地址（4321::54bc）和一个IPv4地址（10.1.1.1）。</li><li><strong>IPv4路由器</strong>：连接iSeries A服务器和Internet。</li></ul><p><strong>达拉斯（Accounts Payable）</strong></p><ul><li><strong>网络</strong>：使用IPv6。</li><li><strong>设备</strong>：包括iSeries B服务器，有一个IPv6地址（9876::55cc）。</li><li><strong>客户端</strong>：连接到iSeries B服务器。</li><li><strong>2838 Ethernet adapter</strong>：表示连接设备使用的网络适配器。</li></ul><p><strong>中间部分</strong></p><ul><li><strong>IPv4&#x2F;6路由器</strong>：具有IPv4地址（10.1.2.1）和IPv6地址（9876::55bb），这表明它能够处理IPv4和IPv6的数据包。</li></ul><p><strong>连接</strong></p><ul><li><strong>绿色线</strong>：表示配置了一个隧道，它允许在IPv4和IPv6网络之间安全地传输数据。隧道的本地端点是芝加哥的IPv4地址（10.1.1.1），远程端点是达拉斯的IPv4地址（10.1.2.1），并且隧道的本地IPv6地址是芝加哥的IPv6地址（4321::54bc）。</li></ul><p>图示展示了两个使用不同IP协议版本的网络之间的互联方式，并通过一个配置了隧道的路由器进行数据传输。这显示了在IPv4和IPv6共存环境中如何实现网络互操作性。</p><p>IPv4和IPv6是两种互联网协议版本，它们是互联网通信的基础。</p><p><strong>IPv4（Internet Protocol version 4）</strong></p><ul><li><strong>IPv4</strong> 是第四版的互联网协议，目前广泛使用于互联网中。</li><li>它基于32位地址长度，这意味着它可以支持大约43亿个独特的IP地址。</li><li>IPv4地址通常以点分十进制形式表示，例如192.168.1.1。</li></ul><p><strong>IPv6（Internet Protocol version 6）</strong></p><ul><li><strong>IPv6</strong> 是为了解决IPv4地址耗尽问题而设计的下一代互联网协议。</li><li>它基于128位地址长度，这意味着它可以支持几乎无限数量的设备。</li><li>IPv6地址通常以冒号分隔的十六进制形式表示，例如2001:0db8:85a3:0000:0000:8a2e:0370:7334。</li></ul><p><strong>主要区别</strong></p><ul><li><strong>地址空间</strong>：IPv4的地址空间相对较小，而IPv6提供了更大的地址空间来满足互联网的增长需求。</li><li><strong>安全性</strong>：IPv6设计之初就考虑了安全性，包括IPsec（一种用于IP网络通信加密和认证的框架）作为标准部分，而IPv4中IPsec是可选的。</li><li><strong>配置</strong>：IPv6支持自动配置能力，设备可以自动分配IP地址，而IPv4通常需要手动分配或通过DHCP（动态主机配置协议）实现自动分配。</li><li><strong>数据包处理</strong>：IPv6简化了数据包头部结构，以提高处理速度和效率。</li><li><strong>移动性和多播</strong>：IPv6原生支持移动性和多播传输，而IPv4则需要额外的协议支持。</li></ul><p>IPv4到IPv6的过渡是一个复杂的过程，因为它们不直接兼容。为了解决这个问题，实施了多种过渡技术，例如隧道和双栈策略，以便两种协议可以在同一网络内协同工作。</p></blockquote><blockquote><h4 id="3-城域网-MAN-Metropolitan-Area-Network"><a href="#3-城域网-MAN-Metropolitan-Area-Network" class="headerlink" title="3. 城域网 (MAN - Metropolitan Area Network)"></a>3. 城域网 (MAN - Metropolitan Area Network)</h4><ul><li><strong>定义</strong>：MAN是介于LAN和WAN之间的网络，通常覆盖一个城市。</li><li><strong>用途</strong>：常用于连接多个局域网，提供高速网络服务给整个城市</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/59b240ec-9b36-4b0f-dac3-b43000cf7500/public"                      width = "500"                ><p>MAN连接了多个局域网（LAN - Local Area Network），每个LAN都通过一个网络处理引擎（NPE - Network Processing Engine）与MAN相连。</p><ol><li><strong>城域网（MAN）</strong>：位于图中心，代表了城市或都市区域的网络。</li><li><strong>局域网（LAN）</strong>：分布在MAN周围，每个LAN可能代表一个不同的组织、办公室建筑或校园网络。</li><li><strong>网络处理引擎（NPE）</strong>：在每个LAN和MAN之间的连接点处，有一个标记为NPE的设备。这些设备负责处理进入和离开局域网的数据，可能执行数据路由、交换、安全和其他网络服务。</li></ol><p>NPE（Network Processing Engine）通常指的是一种高性能的网络处理器，它被设计用来处理和转发数据包。在城域网（MAN - Metropolitan Area Network）的环境中，NPE的作用是尤为关键的，因为它可以处理高速网络流量，确保数据包的快速和有效传输。</p><p>在城域网中，NPE可以用于以下几个主要方面：</p><ol><li><strong>数据包转发</strong>：NPE负责在网络设备中高效地处理和转发数据包。由于城域网通常连接着多个局域网（LANs），NPE在处理大量跨网络流量时的性能至关重要。</li><li><strong>路由决策</strong>：NPE可以进行复杂的路由计算，以确定数据包的最佳路径。这对于确保在城域网环境中数据传输的高效性和可靠性非常重要。</li><li><strong>流量管理</strong>：在城域网中，NPE可能涉及流量整形、负载平衡和拥塞管理等任务，以优化网络性能和资源利用。</li><li><strong>安全处理</strong>：NPE还可以执行一些安全相关的功能，比如入侵检测、防火墙功能和VPN支持。</li><li><strong>质量服务（QoS）</strong>：NPE可以帮助实施QoS策略，确保关键应用和服务得到优先的网络资源，保证服务质量。</li></ol><p>在城域网这样的高速网络环境中，NPE的作用不仅仅局限于数据包的基本转发，它还涉及到整个网络性能和服务质量的维护和提升。随着网络技术的发展，NPE的功能和重要性只会继续增长。</p></blockquote><blockquote><h4 id="4-个人区域网-PAN-Personal-Area-Network"><a href="#4-个人区域网-PAN-Personal-Area-Network" class="headerlink" title="4. 个人区域网 (PAN - Personal Area Network)"></a>4. 个人区域网 (PAN - Personal Area Network)</h4><ul><li><strong>定义</strong>：PAN是一个非常小的网络，用于连接个人设备，如手机、笔记本电脑和平板电脑。</li><li><strong>用途</strong>：用于个人设备间的数据传输，如通过蓝牙或Wi-Fi。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c1f9aca9-86b4-4408-6f58-436f42451500/public"                      width = "500"                ></blockquote><blockquote><h4 id="5-无线局域网-WLAN-Wireless-Local-Area-Network"><a href="#5-无线局域网-WLAN-Wireless-Local-Area-Network" class="headerlink" title="5. 无线局域网 (WLAN - Wireless Local Area Network)"></a>5. 无线局域网 (WLAN - Wireless Local Area Network)</h4><ul><li><strong>定义</strong>：WLAN是一种无线的局域网，使用无线数据连接来链接多个设备。</li><li><strong>用途</strong>：提供与LAN相似的功能，但无需物理连线，增加了移动性。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2e329670-03c8-4027-f700-262ed2cf8100/public"                      width = "500"                ></blockquote><blockquote><h4 id="6-虚拟私人网-VPN-Virtual-Private-Network"><a href="#6-虚拟私人网-VPN-Virtual-Private-Network" class="headerlink" title="6. 虚拟私人网 (VPN - Virtual Private Network)"></a>6. 虚拟私人网 (VPN - Virtual Private Network)</h4><ul><li><strong>定义</strong>：VPN是一种通过公共网络（如互联网）提供加密连接的网络技术。</li><li><strong>用途</strong>：允许远程用户安全地访问内部网络资源，常用于企业远程工作和数据保护。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7eb4679e-5912-4490-967e-a290b8ae9900/public"                      width = "500"                ><ol><li><p><strong>互联网服务提供商（ISP）</strong>：连接用户到互联网的公司或组织。</p></li><li><p><strong>互联网</strong>：全球性的公共网络。</p></li><li><p><strong>内部网（Intranet）</strong>：一个私人网络，通常是公司或组织内部的网络，它包含了受保护的资源和服务。</p></li><li><p><strong>VPN连接</strong>：一个安全的连接，通过公共互联网从用户到内部网。</p></li><li><p><strong>隧道</strong>：VPN连接创建了一条加密的“隧道”，它通过不安全的互联网传输数据。隧道保护了数据不被外部读取或干扰，即使数据在公共互联网上传输。</p><p>在这个场景中，用户通过ISP连接到互联网，并通过VPN创建一个安全的隧道连接到其公司的内部网。这种方式允许远程用户安全地访问公司网络内部的资源，如同他们直接连接到公司的局域网（LAN）一样。这是远程工作和保护数据在不安全网络上传输的常见方式。</p></li></ol></blockquote><blockquote><h4 id="7-企业私人网络-EPN-Enterprise-Private-Network"><a href="#7-企业私人网络-EPN-Enterprise-Private-Network" class="headerlink" title="7. 企业私人网络 (EPN - Enterprise Private Network)"></a>7. 企业私人网络 (EPN - Enterprise Private Network)</h4><ul><li><strong>定义</strong>：EPN是专为特定企业设计的私人网络，用于连接企业内部各部门和资源。</li><li><strong>用途</strong>：用于大型企业，确保数据安全性和网络管理的高效性。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6bafc412-7112-4ee9-fc77-ae3ee9e0d500/public"                      width = "500"                ><p>远程工作者（Telecommuters）如何通过本地互联网服务提供商（Local ISP）连接到企业局域网（Enterprise LAN），并访问位于企业内部的资源:</p><ol><li><strong>远程工作人员（Telecommuters）</strong>：流程开始于远程工作者。这些用户需要从家庭或远程办公地点通过其个人电脑接入企业网络。</li><li><strong>本地ISP（Local ISP）</strong>：远程工作者通过本地互联网服务提供商连接到互联网。本地ISP负责将用户的数据传输到互联网上，并且是用户通往互联网的桥梁。</li><li><strong>互联网</strong>：一旦远程工作者的数据流通过本地ISP，它就进入了互联网，这是一个全球性的公共网络。</li><li><strong>远程接入服务器（Remote Access Server）</strong>：远程工作者通过互联网连接到企业的远程接入服务器。这通常涉及到建立一个虚拟私人网络（VPN）连接，它在用户和企业网络之间创建了一条加密的通道，确保数据传输的安全性。</li><li><strong>企业局域网（Enterprise LAN）</strong>：一旦远程工作者通过VPN连接成功，他们就可以访问企业局域网，就如同他们物理地处于企业的办公室内一样。</li><li><strong>文件服务器（File Servers）</strong>：在连接到企业LAN之后，远程工作者可以访问文件服务器，这些服务器存储了企业的共享文档和资源。</li><li><strong>服务器农场（Server Farm）</strong>：除了文件服务器，远程工作者还可能需要访问服务器农场中的应用服务器，这些服务器提供了企业运行所需的关键业务应用程序和数据处理服务。</li><li><strong>第二层交换机（L2 Switch）</strong>：LAN中的数据流通过第二层交换机，它负责在数据链路层转发数据帧到正确的目的地。</li><li><strong>网关路由器（Gateway Router）</strong>：如果远程工作者需要访问互联网上的资源，流量会经过企业的网关路由器。这台路由器也可能执行网络地址转换（NAT）和安全功能，如防火墙。</li><li><strong>企业ISP（Enterprise ISP）</strong>：最后，如果数据需要发送到企业外部的目的地，它将通过企业的互联网服务提供商转发出去。</li></ol></blockquote><blockquote><h4 id="8-内容分发网络-CDN-Content-Delivery-Network"><a href="#8-内容分发网络-CDN-Content-Delivery-Network" class="headerlink" title="8. 内容分发网络 (CDN - Content Delivery Network)"></a>8. 内容分发网络 (CDN - Content Delivery Network)</h4><ul><li><strong>定义</strong>：CDN是一组分布在多个地理位置的服务器，用于有效地传递互联网内容。</li><li><strong>用途</strong>：用于快速传送大量数据，常用于网页内容、视频流媒体等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7be10293-630a-482d-b915-990eb2b3f600/public"                       width = "500"                ></blockquote><blockquote><h4 id="9-云计算网络"><a href="#9-云计算网络" class="headerlink" title="9. 云计算网络"></a>9. 云计算网络</h4><ul><li><strong>定义</strong>：这类网络是基于云计算技术，提供资源和服务的虚拟化网络。</li><li><strong>用途</strong>：支持各种云服务，如软件即服务（SaaS）、平台即服务（PaaS）和基础设施即服务（IaaS）。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d6583f3c-fc5b-4198-39c2-29dfab953300/public"                      width = "500"                 ><p><strong>云计算（Cloud Computing）</strong></p><p>云计算是一种利用远程服务器网络（通常在互联网上）来存储、管理和处理数据的模式，而不是在本地计算机或服务器上。这种模型允许用户和企业使用互联网来访问更强大的计算资源和大规模存储设施。</p><p><strong>特点</strong>：</p><ul><li><strong>集中式数据处理</strong>：数据处理和存储在中心化的数据中心进行。</li><li><strong>可扩展性</strong>：云服务提供动态扩展能力，根据需求增减资源。</li><li><strong>成本效益</strong>：用户通常按使用量付费，减少了前期投资和维护成本。</li><li><strong>全球访问</strong>：用户可以从世界任何地方通过互联网访问服务。</li></ul><p><strong>边缘计算（Edge Computing）</strong></p><p>边缘计算则是数据在产生源头附近的网络边缘或设备上进行处理。这种模式旨在将计算任务从中心化的数据中心转移到网络的边缘，减少延迟，提高响应速度。</p><p><strong>特点</strong>：</p><ul><li><strong>分布式数据处理</strong>：数据处理在离数据源更近的地方进行，如用户的设备或本地服务器上。</li><li><strong>降低延迟</strong>：通过在数据产生的地方进行处理，减少了数据传输到中心数据中心的需要，从而降低了延迟。</li><li><strong>带宽效率</strong>：减少了大量数据传输，节省了带宽，对于带宽受限的场景特别有用。</li><li><strong>实时处理</strong>：适用于需要即时反馈的应用，如自动驾驶车辆、工业自动化等。</li></ul><p><strong>云计算 vs 边缘计算</strong></p><p>​<strong>数据中心远近</strong>：云计算依赖远程数据中心，而边缘计算依赖近端处理。</p><p>​<strong>延迟问题</strong>：云计算可能面临网络延迟问题，边缘计算则能提供更低延迟。</p><p>​<strong>带宽需求</strong>：云计算可能需要更多的带宽来传输数据，边缘计算减少了跨网络的数据流量。</p><p>​<strong>适用场景</strong>：</p><ul><li>云计算适用于需要大量计算和存储资源，但对延迟要求不是特别高的场景。</li><li>边缘计算适用于对实时分析和响应有严格要求的场景。</li></ul><p><strong>结合使用</strong></p><p>云计算和边缘计算可以结合使用，形成云边协同的架构。在这种架构中，边缘计算负责实时的数据处理和决策，而云计算则负责深度分析和长期存储。这种模式可以最大化地利用两者的优势，满足不同的业务需求。</p></blockquote><blockquote><h4 id="10-其它"><a href="#10-其它" class="headerlink" title="10.其它"></a>10.其它</h4><ul><li><strong>传感器网络（Sensor Networks）</strong>：由许多分布式传感器组成，用于监测和记录物理环境的条件，并将收集的数据传输到一个中心位置。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ed98322c-970c-49b1-a6d6-f69642432a00/public"                      width = "500"                ><ul><li><strong>虚拟网络（Virtual Networks）</strong>：通常建立在其他网络之上，通过软件定义网络（SDN）等技术实现。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/09e8f9e0-c9ad-4ad5-d5ba-09b7ac4a2200/public"                      width = "500"                ><ul><li><strong>存储区域网络（SAN - Storage Area Network）</strong>：连接存储设备和服务器的专用高速网络，允许服务器访问共享存储资源。SAN是一个高速的专用网络，连接存储设备与服务器，通常使用光纤通道（Fibre Channel）或iSCSI协议。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e538edf8-39e3-43a8-0ba4-4c3a3d801600/public"                      width = "500"                ><p>​        <strong>特点</strong>：</p><p>​<strong>性能高</strong>：SAN为服务器提供块级别的存储，可以实现高速数据传输。</p><p>​<strong>可扩展性强</strong>：可以支持大量存储设备，适合大型企业。</p><p>​<strong>灵活性</strong>：存储资源可以在SAN中被多个服务器共享。</p><p>​<strong>适用场景</strong>：</p><p>​数据中心</p><p>​大型数据库应用</p><p>​高性能计算环境</p><p>​<strong>NAS（Network Attached Storage 网络附加存储）</strong>: </p><p>​NAS是一种专用的文件存储设备，它通过网络提供数据访问给网络上的其他设备。</p><p>​<strong>特点</strong>：</p><p>​<strong>易于访问和共享</strong>：NAS通过标准的网络协议（如NFS、SMB&#x2F;CIFS）提供文件级别的存储和访问，使得不同操作系统的用户可以共享数据。</p><p>​<strong>配置简单</strong>：通常易于安装和配置，适合于需要文件共享的小型办公环境。</p><p>​<strong>可扩展性</strong>：可以根据需要添加更多的存储设备。</p><p>​<strong>适用场景</strong>：</p><p>​文件共享, 小型企业的数据备份, 媒体服务器</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/46ff809f-7716-4c87-55d6-f3c52ab4a500/public"                      width = "500"                ><p>​<strong>DAS（直接附加存储 Direct  Attached  Storage）</strong></p><p>​DAS是直接连接到计算机的存储设备，例如内部或外部硬盘驱动器。</p><p>​<strong>特点</strong>：</p><p>​<strong>成本低</strong>：相比NAS和SAN，DAS通常更便宜，因为它不需要额外的网络设备。</p><p>​<strong>简单性</strong>：直接连接到服务器，不需要复杂的配置。</p><p>​<strong>性能</strong>：由于是直接连接的，可以提供良好的数据传输速度。</p><p>​<strong>适用场景</strong>：</p><p>​个人计算机, 小型办公环境, 需要快速数据访问的应用</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/66286d0a-04fb-481e-05f2-d47e4e79da00/public"                      width = "500"                ><ul><li><p><strong>集成服务数字网络（ISDN - Integrated Services Digital Network）</strong>：早期的高速网络服务，提供语音和数据服务。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/18cc1f8a-33f7-4268-9a44-09b8cb1e8800/public"                      width = "500"                ></li></ul></blockquote><h3 id="网络架构（Network-Architectures）"><a href="#网络架构（Network-Architectures）" class="headerlink" title="网络架构（Network  Architectures）"></a>网络架构<strong>（Network  Architectures）</strong></h3><p>架构模式则是指在这些网络中实现数据交换和处理的方法和设计：</p><p>关注于如何在网络中设计和组织资源、服务和数据流。它们描述的是网络内部数据和服务的组织和流动方式。</p><blockquote><h4 id="1-客户端-服务器（C-S-Client-Server）"><a href="#1-客户端-服务器（C-S-Client-Server）" class="headerlink" title="1. 客户端&#x2F;服务器（C&#x2F;S - Client&#x2F;Server）"></a>1. 客户端&#x2F;服务器（C&#x2F;S - Client&#x2F;Server）</h4><ul><li><strong>定义</strong>：C&#x2F;S架构中，客户端和服务器是两个独立的实体。客户端发送请求到服务器，服务器处理请求并返回数据。</li><li><strong>特点</strong>：客户端软件通常需要安装在用户的设备上，可以提供丰富的功能和良好的用户体验。服务器负责数据处理和存储。</li><li><strong>应用</strong>：常见于企业应用、多用户系统、网络游戏等领域。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/029cd3ca-3829-4227-d16e-aa7a7a574500/public"                      width = "500"                ></blockquote><blockquote><h4 id="2-浏览器-服务器（B-S-Browser-Server）"><a href="#2-浏览器-服务器（B-S-Browser-Server）" class="headerlink" title="2. 浏览器&#x2F;服务器（B&#x2F;S - Browser&#x2F;Server）"></a>2. 浏览器&#x2F;服务器（B&#x2F;S - Browser&#x2F;Server）</h4><ul><li><strong>定义</strong>：B&#x2F;S架构中，用户通过浏览器（作为客户端）来访问服务器上的资源和服务。</li><li><strong>特点</strong>：不需要在客户端安装特定的软件，只需一个浏览器即可访问服务。服务器处理后端逻辑和数据存储。</li><li><strong>应用</strong>：互联网网站、Web应用程序等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ef7ff1e9-0a79-4e15-5837-8aab82499000/public"                      width = "500"                ></blockquote><blockquote><h4 id="3-移动端-服务器（M-S-Mobile-Server）"><a href="#3-移动端-服务器（M-S-Mobile-Server）" class="headerlink" title="3. 移动端&#x2F;服务器（M&#x2F;S - Mobile&#x2F;Server）"></a>3. 移动端&#x2F;服务器（M&#x2F;S - Mobile&#x2F;Server）</h4><ul><li><strong>定义</strong>：M&#x2F;S架构专注于移动设备作为客户端，与服务器进行交互。</li><li><strong>特点</strong>：适应了移动设备的特性，如触摸界面、定位服务和推送通知。服务器处理复杂的逻辑和数据存储。</li><li><strong>应用</strong>：移动应用程序，如社交媒体应用、移动电子商务应用等。</li></ul></blockquote><blockquote><h4 id="4-对等网络（P2P-Peer-to-Peer）"><a href="#4-对等网络（P2P-Peer-to-Peer）" class="headerlink" title="4. 对等网络（P2P - Peer-to-Peer）"></a>4. 对等网络（P2P - Peer-to-Peer）</h4><ul><li><strong>定义</strong>：在P2P架构中，每个节点既作为客户端又作为服务器，节点之间直接交换数据。</li><li><strong>特点</strong>：不依赖中心化的服务器，提高了系统的可扩展性和容错能力。</li><li><strong>应用</strong>：文件共享系统、加密货币网络、某些通信应用等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7a571f26-f4da-40ae-2107-bfc1072edd00/public"                      width = "500"                ></blockquote><blockquote><h4 id="5-微服务架构（Microservices-Architecture）"><a href="#5-微服务架构（Microservices-Architecture）" class="headerlink" title="5.微服务架构（Microservices  Architecture）"></a>5.微服务架构（Microservices  Architecture）</h4><ul><li><strong>定义</strong>：微服务架构是一种将应用程序作为一组小服务开发的方法，每个服务在其自己的进程中运行，通常围绕业务能力构建。</li><li><strong>特点</strong>：服务之间通过轻量级的通信机制进行交互，每个服务独立部署，可在不同的环境中独立扩展。</li><li><strong>应用</strong>：现代云应用、大型企业级应用等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5a18fc87-3c20-42ec-1547-32250ab6a800/public"                      width = "500"                ></blockquote><blockquote><h4 id="6-服务导向架构（SOA-Service-Oriented-Architecture）"><a href="#6-服务导向架构（SOA-Service-Oriented-Architecture）" class="headerlink" title="6. 服务导向架构（SOA - Service-Oriented Architecture）"></a>6. 服务导向架构（SOA - Service-Oriented Architecture）</h4><ul><li><strong>定义</strong>：SOA是一种设计模式，其中应用程序的组件提供服务给其他组件，通过网络中的通信协议进行交互。</li><li><strong>特点</strong>：强调可重用的服务，服务之间通常是松耦合的。</li><li><strong>应用</strong>：企业级应用、系统集成等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/eceb2f61-a305-4213-7d9d-8a758f5d4c00/public"                      width = "500"                ></blockquote><blockquote><h4 id="7-网格计算（Grid-Computing）"><a href="#7-网格计算（Grid-Computing）" class="headerlink" title="7. 网格计算（Grid Computing）"></a>7. 网格计算（Grid Computing）</h4><ul><li><strong>定义</strong>：网格计算是一种分布式计算形式，它将来自不同域的计算资源连接起来，以达到共同的目标。</li><li><strong>特点</strong>：高度分布式，适合于大规模的数据处理和复杂计算任务。</li><li><strong>应用</strong>：科学研究、大规模模拟、数据分析等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c007fc78-95b5-4f3c-3a43-1227649fbd00/public"                      width = "500"                ></blockquote><blockquote><h4 id="8-雾计算（Fog-Computing）"><a href="#8-雾计算（Fog-Computing）" class="headerlink" title="8. 雾计算（Fog  Computing）"></a>8. 雾计算（Fog  Computing）</h4><ul><li><strong>定义</strong>：雾计算是一种分布式计算架构，它将计算、存储和网络服务扩展到网络的边缘。</li><li><strong>特点</strong>：减少了对中心数据中心的依赖，减少延迟，提高了数据处理的速度。</li><li><strong>应用</strong>：物联网（IoT）、实时数据分析、智能城市等。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4a5843b6-2f70-49ed-f1f3-717dcb105000/public"                      width = "500"                ></blockquote><p>总的来说，网络类型和架构模式是网络设计的两个不同层面。类型更侧重于网络的物理和逻辑布局，而架构则侧重于系统的内部设计和数据流动。两者相辅相成，共同构成完整的网络系统。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="背景知识：OSI模型"><a href="#背景知识：OSI模型" class="headerlink" title="背景知识：OSI模型"></a>背景知识：OSI模型</h4><blockquote><p>OSI模型，全称是“开放式系统互连参考模型”（Open Systems Interconnection Reference Model），是一个用于解释和标准化网络内不同计算机系统之间通信过程的概念模型。这个模型由国际标准化组织（ISO）在1980年代初期开发，目的是促进不同类型计算机系统之间的兼容性和标准化通信。</p><table><thead><tr><th>层面</th><th>功能</th></tr></thead><tbody><tr><td><strong>物理层（Physical Layer）</strong></td><td>负责实际的物理连接，包括电缆、光纤、无线电频率等的传输媒介。</td></tr><tr><td><strong>数据链路层（Data Link Layer）</strong></td><td>负责在相邻节点之间的可靠连接，处理帧定界、物理地址寻址、流量控制等。</td></tr><tr><td><strong>网络层（Network Layer）</strong></td><td>负责在多个网络之间建立、维护和终止连接，包括路由选择、分组转发等。</td></tr><tr><td><strong>传输层（Transport Layer）</strong></td><td>负责在端到端的通信中保持数据的完整性，处理错误检测和恢复、数据传输顺序等。</td></tr><tr><td><strong>会话层（Session Layer）</strong></td><td>负责建立、管理和终止会话，控制数据交换的对话和同步。</td></tr><tr><td><strong>表示层（Presentation Layer）</strong></td><td>负责数据的表示、加密和压缩，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</td></tr><tr><td><strong>应用层（Application Layer）</strong></td><td>为各种应用软件提供服务，包括电子邮件、文件传输和其他网络软件服务。</td></tr></tbody></table><p>每一层都有其特定的功能，它们一起协作，确保从一个设备到另一个设备的数据传输是顺畅和高效的。虽然在实际的网络实现中，如因特网的TCP&#x2F;IP模型更为普遍，但OSI模型仍然是理解网络通信非常重要的一个概念工具。</p></blockquote><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a><strong>原因</strong></h4><p>计算机之间也是需要一种<strong>规则</strong>，保障之间信息的<strong>有效交流</strong>，这就是<strong>HTTP协议</strong>;</p><h4 id="概念及特点"><a href="#概念及特点" class="headerlink" title="概念及特点"></a><strong>概念及特点</strong></h4><ul><li><p>HTTP是 Hyper Text Transfer Protocol（<strong>超文本传输协议</strong>）的缩写，是用于从<strong>万维网</strong>（WWW: World Wide Web ）服务器传输<strong>超文本</strong>到<strong>本地浏览器</strong>的传送协议。</p></li><li><p>目前互连网上90%的网络传输都是基于HTTP协议。</p></li><li><p>HTTP是一个基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）; </p><ul><li><p>使用TCP通信协议的重要的原因是基于其<strong>面向连接的</strong>特点：</p><blockquote><p>TCP&#x2F;IP（传输控制协议&#x2F;网际协议）是一组用于控制网络通信的协议，并且是因特网的基础。它由两个主要的协议组成：TCP和IP。</p><ol><li><p><strong>IP（网际协议）</strong>：负责将数据包从发送方路由到接收方。IP提供了一种机制，可以识别发送和接收设备的唯一地址（即IP地址）。IP协议主要负责数据包的寻址和路由，确保数据能够在网络中正确地从一个点传送到另一个点。</p></li><li><p><strong>TCP（传输控制协议）</strong>：在IP提供的基础上，TCP负责在两个终端之间建立可靠的连接，确保数据准确无误地传输。它通过分割数据为多个部分、确保每个部分都被正确接收，并且在必要时进行重传，来完成这一任务。TCP还负责控制数据传输的速率，防止网络拥塞。</p></li><li><p>TCP&#x2F;IP模型通常被划分为四层，每层都有其特定的功能：</p><table><thead><tr><th>层面</th><th>功能</th></tr></thead><tbody><tr><td><strong>应用层</strong></td><td>直接为用户的应用程序（如浏览器、电子邮件客户端等）提供服务。</td></tr><tr><td><strong>传输层</strong></td><td>包括TCP和UDP（用户数据报协议），负责提供端对端的通信。</td></tr><tr><td><strong>互联网层</strong></td><td>主要包括IP协议，负责在多个网络之间传输数据包。</td></tr><tr><td><strong>网络接口层</strong></td><td>包括用于实际网络连接的各种协议，负责数据在物理网络上的传输。</td></tr></tbody></table><p>TCP&#x2F;IP模型由于其简洁性和高效性，在互联网的发展中起到了核心作用，是现代网络通信不可或缺的一部分。</p></li></ol></blockquote></li></ul></li></ul><h3 id="HTTPS（安全超文本传输协议）"><a href="#HTTPS（安全超文本传输协议）" class="headerlink" title="HTTPS（安全超文本传输协议）"></a>HTTPS（安全超文本传输协议）</h3><ol><li><strong>定义与用途</strong>：<ul><li>HTTPS是HTTP的安全版本，用于在不安全的网络上安全传输数据。</li><li>它通过加密和认证确保数据传输的安全性和完整性。</li></ul></li><li><strong>加密机制</strong>：<ul><li><strong>传输层安全性（TLS）或安全套接层（SSL）</strong>：HTTPS使用这些协议对数据进行加密。</li><li>加密保护数据不被中间人攻击（MITM）窃听或篡改。</li></ul></li><li><strong>数字证书</strong>：<ul><li>HTTPS使用数字证书验证服务器的身份，确保用户正在与预期的服务器通信。</li><li>数字证书由权威的证书颁发机构（CA）签发。</li></ul></li><li><strong>特点</strong>：<ul><li><strong>增加了安全层</strong>：相比HTTP，HTTPS提供了数据的机密性和完整性。</li><li><strong>性能开销</strong>：加密和解密过程需要额外的处理，可能会略微影响性能。</li></ul></li></ol><h3 id="HTTP与HTTPS的比较"><a href="#HTTP与HTTPS的比较" class="headerlink" title="HTTP与HTTPS的比较"></a>HTTP与HTTPS的比较</h3><ul><li><strong>安全性</strong>：HTTPS明显优于HTTP，因为它通过加密保护数据。</li><li><strong>端口</strong>：HTTP通常使用端口80，而HTTPS使用端口443。</li><li><strong>应用场景</strong>：对于需要保护数据安全的网站（如在线银行、电子商务等），强烈推荐使用HTTPS。</li></ul><p>总之，HTTP和HTTPS都是实现网络通信的重要协议，但HTTPS在安全性方面提供了显著的优势。随着网络安全意识的提高，越来越多的网站和服务正在转向HTTPS。</p><h2 id="三-HTTP协议的使用"><a href="#三-HTTP协议的使用" class="headerlink" title="三.HTTP协议的使用"></a>三.HTTP协议的使用</h2><h3 id="HTTP请求流程"><a href="#HTTP请求流程" class="headerlink" title="HTTP请求流程"></a>HTTP请求流程</h3><p>一次http请求的基本流程是，有客户端向服务端发起一次请求(request), 而服务器在接收到以后返回给客户端一个响应（response）。所以一次完整的http请求包含请求和响应两部分。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2c8641ae-0ec6-4933-ba7b-fbfdf0a13200/public"                      width = "500"                ><ol><li><strong>客户端打开连接</strong>：当在浏览器中输入一个URL或点击一个链接时，浏览器会向服务器发起一个HTTP请求。这通常开始于TCP的三次握手过程，建立客户端和服务器之间的连接。</li><li><strong>发送HTTP请求</strong>：一旦TCP连接建立，客户端（如浏览器）就会通过这个连接发送一个HTTP请求。这个请求包含了请求行（如“GET &#x2F;index.html HTTP&#x2F;1.1”）、请求头（包含用户代理信息、接受的内容类型等）和（在POST请求中）一个请求体。</li><li><strong>服务器处理请求</strong>：服务器接收到HTTP请求后，会根据请求的资源（如HTML文件、图像等）进行处理。</li><li><strong>服务器响应</strong>：服务器处理完请求后，会回送一个HTTP响应。这个响应包含一个状态行（如“HTTP&#x2F;1.1 200 OK”）、响应头（包含内容类型、长度等）和响应体（请求的数据）。</li><li><strong>关闭连接</strong>：在交换完数据后，通常由客户端发起TCP的四次挥手过程来关闭TCP连接。</li></ol><blockquote><h4 id="TCP三次握手（建立连接）"><a href="#TCP三次握手（建立连接）" class="headerlink" title="TCP三次握手（建立连接）"></a>TCP三次握手（建立连接）</h4><ol><li><strong>SYN</strong>：客户端发送一个SYN（同步序列编号）标志的TCP包到服务器，以开始一个新的连接。</li><li><strong>SYN-ACK</strong>：服务器接收到SYN包后，回送一个包含SYN和ACK（确认字符）标志的TCP包以确认收到。</li><li><strong>ACK</strong>：客户端收到服务器的SYN-ACK包后，再发送一个ACK包作为响应，完成连接建立。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/78ec936a-ce05-4fa1-6cd9-d40fee243700/public"                      width = "500"                 ><p>这个过程主要确保双方都准备好开始新的连接。</p><h4 id="数据传输（正在连接）"><a href="#数据传输（正在连接）" class="headerlink" title="数据传输（正在连接）"></a>数据传输（正在连接）</h4><p>一旦TCP连接建立，HTTP请求就可以通过这个连接发送了。</p><ol><li><strong>HTTP请求</strong>：客户端通过建立好的TCP连接，发送一个HTTP请求到服务器。这个请求包含了请求方法（如GET或POST）、请求的资源（如网页）、以及其他必要的头信息。</li><li><strong>服务器处理</strong>：服务器接收并处理这个请求，然后准备相应的HTTP响应。</li><li><strong>HTTP响应</strong>：服务器通过同一个TCP连接返回一个HTTP响应。响应通常包含状态码（如200 OK），响应头信息，以及请求的数据（如HTML文档）。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0c6186dc-d6dc-4f9d-0e71-d61ea67b3100/public"                      width = "500"                 ><h4 id="TCP四次挥手（关闭连接）"><a href="#TCP四次挥手（关闭连接）" class="headerlink" title="TCP四次挥手（关闭连接）"></a>TCP四次挥手（关闭连接）</h4><ol><li><strong>FIN</strong>：当通信结束时，发起关闭的一方（通常是客户端）会发送一个FIN（结束）标志的TCP包，表明它已经没有数据发送了。</li><li><strong>ACK</strong>：接收方接到FIN包后，会回送一个ACK包作为确认。</li><li><strong>FIN</strong>：接着，接收方发送一个带有FIN标志的TCP包，以表明它也没有数据发送了。</li><li><strong>ACK</strong>：最后，发起关闭的一方收到FIN后，再发送一个ACK包作为响应。一段时间后，连接被完全关闭。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4fc6823f-b725-4840-dd22-7022178f5000/public"                      width = "500"                 ><p>这个过程确保了双方都能够完成所有数据的发送和接收，从而安全地关闭连接。</p></blockquote><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h3><p>发送http请求时，通过URL对网络资源进行定位。</p><p>URL（Uniform Resource Locator），中文叫统一资源定位符。是用来标识某一处资源的地址。也即是我们常说的网址。以下面这个URL为例，普通URL的各部分组成：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cd57e0a7-6f0d-4fc5-ac07-b45d213e3300/public"                      width = "500"                 ><blockquote><ol><li><p>协议</p><ul><li><p><strong>定义</strong>：指定了如何通过网络访问资源的方法或规则。</p></li><li><p><strong>常见例子</strong>：<code>http</code>, <code>https</code>。这决定了与服务器交互时使用的规则和标准。</p></li></ul></li><li><p>域名</p><ul><li><p><strong>定义</strong>：是互联网上一个服务器或一组服务器的易于记忆的地址。</p></li><li><p><strong>作用</strong>：它被解析成一个IP地址，这是定位服务器的实际数字标识。</p></li><li><p><strong>例子</strong>：<code>example.com</code>。</p></li></ul></li><li><p>端口（默认80）</p><ul><li><p><strong>定义</strong>：一个网络地址的一部分，用于标识特定的进程或服务。</p></li><li><p><strong>默认值</strong>：</p><ul><li>对于HTTP，端口默认是80。</li><li>对于HTTPS，端口默认是443。</li></ul></li><li><p><strong>说明</strong>：在URL中通常省略默认端口。</p></li><li><p>端口在网络通信中是一个重要的概念，它们用于区分一台计算机上的不同服务或进程。在TCP&#x2F;IP协议中，一个端口被定义为一个数字，这个数字用来区分主机上的不同服务或应用程序。每个TCP或UDP包都有特定的端口号，以确保数据传输的正确性。</p><p><strong>端口分类</strong></p><p>​端口号的范围从0到65535，根据用途不同，端口被划分为以下几类：</p><ul><li><strong>系统或保留端口</strong>（0-1023）：<ul><li>这些是众所周知的端口号，通常由系统或者特定的应用程序使用。</li><li>例如，HTTP服务通常使用端口80，HTTPS服务使用端口443，FTP使用端口21。</li></ul></li><li><strong>用户或注册端口</strong>（1024-49151）：<ul><li>这些端口可由用户或应用程序使用，不需要系统级权限。</li><li>很多著名的应用程序会使用这一范围内的端口号。</li></ul></li><li><strong>动态或私有端口</strong>（49152-65535）：<ul><li>这些端口一般不用于特定服务，而是动态分配给客户端临时通信。</li></ul></li></ul><p><strong>常见服务的标准端口</strong></p><ul><li><strong>MySQL</strong>：默认端口为3306。</li><li><strong>MongoDB</strong>：默认端口为27017。</li><li><strong>REST API</strong>：没有固定端口。REST API是一种设计风格，而不是应用程序或服务。它可以运行在任何端口上，通常选择的是80或443（如果使用HTTPS）。</li></ul><p><strong>端口的重要性</strong></p><ul><li><strong>安全性</strong>：一些端口因为常用于特定服务而更受攻击者关注，例如80和443。因此，网络安全措施经常涉及这些端口的监控和保护。</li><li><strong>配置和管理</strong>：正确配置端口对于确保网络服务正确运行至关重要。例如，在部署数据库或API时，必须确保端口设置正确，且不与其他服务冲突。</li></ul><p><strong>结论</strong></p><p>端口是网络通信的基本组成部分，正确理解和使用端口对于维护网络服务的健康和安全非常重要。每种服务都可能有一个或多个默认端口，但这些可以根据具体需求或安全考虑进行更改。</p></li></ul></li><li><p>路径</p><ul><li><p><strong>定义</strong>：表示服务器上资源的具体位置。</p></li><li><p><strong>结构</strong>：通常由一系列的斜杠(<code>/</code>)分隔的部分组成。</p></li><li><p><strong>例子</strong>：在URL <code>http://example.com/photos/image.jpg</code> 中，<code>/photos/image.jpg</code> 是路径，指向服务器上的特定图片。</p></li></ul></li><li><p>参数</p><ul><li><p><strong>定义</strong>：用于提供额外信息以完成对资源的请求。</p></li><li><p><strong>结构</strong>：通常以问号（<code>?</code>）开始，后跟一系列的“键-值”对，每对之间用和号（<code>&amp;</code>）分隔。</p></li><li><p><strong>例子</strong>：在URL <code>http://example.com/index.html?page=2&amp;sort=asc</code> 中，<code>page=2&amp;sort=asc</code> 是参数，用于指示页面编号和排序方式。</p></li></ul></li></ol></blockquote><h3 id="HTTP请求格式-请求行-请求头-空行-请求体"><a href="#HTTP请求格式-请求行-请求头-空行-请求体" class="headerlink" title="HTTP请求格式 (请求行,请求头,空行,请求体)"></a><strong>HTTP请求格式 (请求行,请求头,空行,请求体)</strong></h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下部分：请求行，请求头，空行和请求数据。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/29f184f7-16d4-4280-bf06-95871ba21600/public"                      width = "500"                ><p>一旦TCP连接建立，HTTP请求就发生在这个连接上。HTTP请求是在<strong>应用层</strong>发生的，HTTP请求依赖于TCP连接。在HTTP请求发送之前，TCP三次握手必须先完成，以确保数据传输的可靠性，具体分为以下几个部分：</p><ol><li><p><strong>请求行</strong>：</p><p>​包括HTTP方法（如GET, POST等）、请求的资源路径和HTTP版本，例如，<code>GET /index.html HTTP/1.1</code>。</p><p>​HTTP请求方法定义了客户端与服务器交互的不同方式。每种方法都有其特定用途。以下是HTTP 1.0和HTTP 1.1中定义的请求方法及其描述的整理：</p><p><strong>HTTP 1.0 定义的请求方法</strong></p><ul><li><strong>GET</strong><ul><li>描述：请求指定的页面信息，并返回实体主体。</li><li>特点：URL中添加请求参数，显示在地址栏；请求字符串限制1024个字节；主要用于获取数据。</li></ul></li><li><strong>POST</strong><ul><li>描述：向指定资源提交数据进行处理请求（如提交表单或上传文件）。数据包含在请求体中。可能导致新资源的建立和&#x2F;或已有资源的修改。</li><li>特点：没有大小限制；相对于GET更安全，因为数据不会显示在URL中。</li></ul></li><li><strong>HEAD</strong><ul><li>描述：类似于GET，但服务器返回的响应中不包含实体的主体部分。用于获取报头。</li><li>特点：常用于验证资源是否存在，以及获取资源的元数据。</li></ul></li></ul><p><strong>HTTP 1.1 新增的请求方法</strong></p><ul><li><strong>OPTIONS</strong><ul><li>描述：允许客户端查看服务器的性能。</li><li>特点：用于客户端确定服务器对特定资源支持的方法。</li></ul></li><li><strong>PUT</strong><ul><li>描述：向指定资源位置上传其最新内容，通常用于更新内容。</li><li>特点：替换所有当前表示的内容。</li></ul></li><li><strong>DELETE</strong><ul><li>描述：请求服务器删除指定的资源。</li><li>特点：用于删除资源。</li></ul></li><li><strong>TRACE</strong><ul><li>描述：回显服务器收到的请求，主要用于测试或诊断。</li><li>特点：用于诊断信息。</li></ul></li><li><strong>CONNECT</strong><ul><li>描述：预留给能够将连接改为管道方式的代理服务器。</li><li>特点：用于代理服务器。</li></ul></li></ul><p><strong>注意事项</strong></p><ul><li>方法名称是区分大小写的。</li><li>当资源不支持某个方法时，服务器应返回状态码405（Method Not Allowed）；当服务器不认识或不支持某个方法时，应返回状态码501（Not Implemented）。</li><li>HTTP服务器至少应实现GET和HEAD&#x2F;POST方法，其他方法是可选的。服务器还可以支持扩展的自定义方法。</li></ul><p>总的来说，不同的HTTP请求方法支持不同的操作，选择适当的方法取决于执行的操作和所需的结果。GET和POST是最常用的两种方法，分别用于获取和提交数据。</p></li><li><p><strong>请求头</strong>：包含关于请求的附加信息，如用户代理、接受类型等。由多个头部字段组成，每个字段包含一个名称和一个值，用冒号(<code>:</code>)分隔。请求头提供了关于请求的附加信息，例如客户端信息、所需内容类型等。例如：</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Host: www.baidu.com请求的目标主机和端口号（如果非默认端口）</span></span><br><span class="line"><span class="section">User-Agent: Mozilla/5.0 (Windows NT 10.0; ...)发出请求的浏览器或其他客户端的标识</span></span><br><span class="line"><span class="section">Referer: http://www.example.com/index.html页面跳转处，指出产生请求的页面URL</span></span><br><span class="line"><span class="section">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8客户端能够接收的内容类型</span></span><br><span class="line"><span class="section">Accept-Language: en-US,en;q=0.5用户希望优先接收的语言和地区</span></span><br><span class="line"><span class="section">Accept-Encoding: gzip, deflate, br客户端支持的内容编码（如压缩算法）</span></span><br><span class="line"><span class="section">Accept-Charset: utf-8, iso-8859-1;q=0.5可接受的应答的字符集</span></span><br><span class="line"><span class="section">Connection: keep-alive控制选项，如是否保持连接持续</span></span><br><span class="line"><span class="section">Cache-Control: max-age=0关于缓存的指令</span></span><br><span class="line"><span class="section">Cookie: BAIDUID=...包含服务器之前发送到用户浏览器的Cookie</span></span><br><span class="line"><span class="section">Content-Length: 348发送给HTTP服务器数据的长度</span></span><br><span class="line"><span class="section">Content-Type: application/json具体请求的媒体类型</span></span><br><span class="line"><span class="section">Content-Range: bytes 21010-47021/47022响应资源的范围</span></span><br><span class="line"><span class="section">Cache-Control: no-cache指定请求和响应遵循的缓存机制</span></span><br></pre></td></tr></table></figure></div><p>每次HTTP请求的头部可能会有所不同，这取决于发出请求的客户端、用户的配置、网站的要求等多种因素。</p><p>如果想查看一个具体网站（比如百度官网）的HTTP请求头，可以使用浏览器的开发者工具来查看。可以通过右键点击网页并选择“检查”或者使用F12键来打开开发者工具，然后切换到“网络”选项卡，查看具体的请求详情。</p></li><li><p><strong>空行</strong>：请求头和请求体之间的一个空行，标识请求头的结束。</p></li><li><p><strong>请求体</strong>：不是所有的HTTP请求都有请求体，它主要用于像POST这样的方法，包含了发送给服务器的数据。例如，在表单提交时，请求体可能包含填写的表单数据。POST 方法适用于需要客户填写表单的场合。与请求体相关的最常使用的是包体类型 Content-Type 和包体长度 Content-Length;</p></li></ol><h3 id="HTTP响应格式-状态行-响应头-空行-响应正文"><a href="#HTTP响应格式-状态行-响应头-空行-响应正文" class="headerlink" title="HTTP响应格式 (状态行,响应头,空行,响应正文)"></a>HTTP响应格式 (状态行,响应头,空行,响应正文)</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9d674372-c8f5-45ec-32bb-f27cc6dd8c00/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8264d6d7-2f81-4943-d6dc-d4647052f300/public"                      width = "500"                ><ol><li><strong>状态行</strong></li></ol><p>​状态行由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;</p><ul><li><p>状态码   由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：</p><ul><li><p>1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;</p></li><li><p>2xx：表示服务器已成功接收到请求并进行处理;</p></li><li><p>3xx：表示服务器要求客户端重定向;</p></li><li><p>4xx：表示客户端的请求有非法内容;</p></li><li><p>5xx：表示服务器未能正常处理客户端的请求而出现意外错误;</p></li></ul></li><li><p>状态码描述文本有如下取值：</p><ul><li><p>200 OK：表示客户端请求成功;</p></li><li><p>400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解;</p></li><li><p>401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用;</p></li><li><p>403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因;</p></li><li><p>404 Not Found：请求的资源不存在，例如，输入了错误的URL;</p></li><li><p>500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求;</p></li><li><p>503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常;</p></li></ul></li></ul><ol start="2"><li><strong>响应头</strong></li></ol><p>​响应头的具体内容可以根据服务器的配置和特定请求而变化。</p><ul><li>Allow服务器支持哪些请求方法（如GET、POST等）。</li><li>Date表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon，31Dec200104：25：57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</li><li>Set-Cookie非常重要的header，用于把cookie发送到客户端浏览器，每一个写入cookie都会需要一个Set-Cookie。</li><li>Expires指定Response的过期时间，从而不再缓存它，重新从服务器获取，会更新缓存。过期之前使用本地缓存。降低服务器负载，缩短加载时间。</li><li>Content-Type WEB服务器告诉客户端自己响应的对急的类型和字符集。</li><li>Content-Encoding：内容编码格式</li></ul><ol start="3"><li><strong>空行</strong></li></ol><p>响应头和响应体由空行连接。 最后一个响应头之后是一个空行，发送回车符和换行符，通知客户端以下不再有请响应头;</p><ol start="4"><li><strong>响应体</strong></li></ol><p>该响应消息的响应体是一个HTML文档。浏览器可以直接识别这个HTML文件。而我们访问的是一个JSP文件，响应回去的是一个HTML文件。说明服务器将该JSP翻译成了一个HTML，然后再响应给浏览器。</p><h3 id="HTTP三点注意事项"><a href="#HTTP三点注意事项" class="headerlink" title="HTTP三点注意事项"></a><strong>HTTP三点注意事项</strong></h3><ul><li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP&#x2F;1.1开始支持持久连接（keep-alive），允许在一个连接上处理多个请求，但是是串行处理不是并行。</li><li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。</li><li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 这种无状态的情况，并不适合我们进行业务需求，我们需要保持我们的登录状态，方便我们访问。通常使用cookies、session等技术在HTTP层之上维护状态。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a67df357-6a03-4119-a6f4-b8de4a7ed900/public"                      width = "500"                ><h2 id="四-会话技术"><a href="#四-会话技术" class="headerlink" title="四.会话技术"></a>四.会话技术</h2><p><strong>原因</strong></p><p>HTTP是无状态的，那服务端怎么区分同一个用户的连续请求呢，这就用到了会话技术：Cookies和session。</p><p><strong>概念</strong></p><ul><li><p>Cookie  有时也用其复数形式 Cookies。<br>指某些网站为了辨别用户身份、进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密）。最新的规范是 RFC6265  。</p></li><li><p>Cookie   可以理解为一个凭证<br>1.实际是由服务器发给客户端的特殊信息，<br>2.这些信息以文本文件的方式存放在客户端，<br>3.客户端每次向服务器发送请求的时候都会带上这些特殊的信息。<br>服务器在接收到Cookie以后，会验证Cookie的信息，以此来辨别用户的身份。</p></li></ul><p><strong>Session</strong>中文经常翻译为会话，其本来的含义是指有始有终的一系列动作&#x2F;消息，比如打电话时从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个Session。这个词在各个领域都有在使用，而我们Web领域，一般使用的是其本义，一个浏览器窗口从打开到关闭这个期间。</p><p>Session的目的则是，在一个客户从打开浏览器到关闭浏览器这个期间内，发起的所有请求都可以被识别为同一个用户。</p><p>而实现的方式则是，在一个客户打开浏览器开始访问网站的时候，会生成一个Cookie，SessionID，这个ID每次的访问都会带上，而服务器会识别这个SessionID并且将与这个SessionID有关的数据保存在服务器上。由此来实现客户端的状态识别。因此<strong>Session是基于cookie的</strong>.</p><p>Session与Cookie相反，<strong>Session是存储在服务器上的数据</strong>，只由客户端传上来的SessionID来进行判定，所以相对于Cookie，Session的安全性更高。</p><p>一般SessionID会在浏览器被关闭时丢弃，或者服务器会验证Session的活跃程度，例如30分钟某一个SessionID都没有活跃，那么也会被识别为失效。</p><h2 id="五-Proxy-代理"><a href="#五-Proxy-代理" class="headerlink" title="五.Proxy 代理"></a>五.Proxy 代理</h2><h3 id="代理的概念"><a href="#代理的概念" class="headerlink" title="代理的概念"></a>代理的概念</h3><p>代理实际指代理服务器，它的功能是代替用户取获取网络信息，就像是一个网络信息的中转站。正常情况下请求一个网站时，我们发送请求给web服务器，然后web服务器把响应传回给我们；而如果设置了代理服务器，此时我们就不是直接给web服务器发送请求，而是先向代理服务器发送请求，然后代理服务器再把我们的请求转发给目标web服务器，接着web服务器把响应返回给代理服务器，之后代理服务器再把响应返回给我们。使用这样的访问方式，我们同样可以正常访问网页，但是中间经过了代理服务器后，web服务器就不能识别到我们本机的IP了，只能识别代理服务器的IP，这样我们本机的真实IP就被伪装起来了，这就是代理服务器的基本原理和作用。</p><h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3><p>代理具体有什么作用呢</p><ul><li>突破自身IP访问限制，访问一些自身IP不能访问的站点。</li><li>访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li><li>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li><li>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。</li></ul><p>代理对于爬虫的作用</p><p>由于爬虫爬取速度过快，在爬取过程中可能遇到同一个IP访问过于频繁的问题，此时网站就会让我们输入验证码登录或者直接封锁IP，这样会给爬取带来极大的不便。使用代理隐藏真实的IP，让服务器误以为是代理服务器在请求自己。这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果。</p>]]></content>
    
    
    <summary type="html">爬虫基本网络架构，协议和代理的基础理论</summary>
    
    
    
    <category term="数据抓取" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.yiuhangblog.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="网络协议" scheme="https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="网络类型" scheme="https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="网络架构" scheme="https://www.yiuhangblog.com/tags/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Tableau数据可视化图表</title>
    <link href="https://www.yiuhangblog.com/2020/10/05/20201005Tableau%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8/"/>
    <id>https://www.yiuhangblog.com/2020/10/05/20201005Tableau%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8/</id>
    <published>2020-10-05T05:32:48.000Z</published>
    <updated>2024-02-28T10:50:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Tableau？"><a href="#什么是Tableau？" class="headerlink" title="什么是Tableau？"></a>什么是Tableau？</h1><p>Tableau 是一款强大的数据可视化工具，广泛用于数据分析和商业智能领域。它使用户能够通过拖放的方式轻松创建和分享各种各样的交互式和可视化的数据报告。Tableau 支持从多种数据源获取数据，包括 Excel、SQL 数据库、云服务中的数据等。</p><p>Tableau 的主要特点包括：</p><ul><li><strong>易用性</strong>：用户无需编程知识即可快速创建复杂的数据可视化。</li><li><strong>强大的数据处理能力</strong>：Tableau 能够处理大量数据，并从中提取有价值的信息。</li><li><strong>交互性</strong>：创建的可视化报告是交互式的，用户可以通过筛选、排序等操作深入探索数据。</li><li><strong>灵活的数据连接选项</strong>：支持连接到各种数据源，包括实时数据和大数据平台。</li><li><strong>分享和协作</strong>：Tableau 的报告可以通过 Tableau Server 或 Tableau Online 轻松与他人共享，支持团队协作。</li></ul><p>Tableau 提供不同的产品来满足不同的需求，包括 Tableau Desktop（用于个人数据分析和报告创建）、Tableau Server（企业级数据分享和管理）、Tableau Online（基于云的共享和协作平台）以及 Tableau Public（允许用户免费创建和发布数据可视化到网上）。</p><p>通过使用 Tableau，组织和个人可以更加直观地理解数据，帮助做出基于数据的决策。</p><h2 id="Tableau-家族产品初探索"><a href="#Tableau-家族产品初探索" class="headerlink" title="Tableau 家族产品初探索"></a>Tableau 家族产品初探索</h2><h3 id="Tableau-Desktop"><a href="#Tableau-Desktop" class="headerlink" title="Tableau Desktop"></a>Tableau Desktop</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/102dce20-8a84-4978-a360-2f89df416f00/public"                      width = "600"                ><p>Tableau Desktop 是 Tableau 产品套件中的一个核心组件，专为个人数据分析和可视化设计而设计。它使用户能够在本地计算机上直接创建丰富、交互式的数据可视化、报告和仪表板。以下是 Tableau Desktop 的一些关键特点和功能：</p><h4 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h4><ul><li><strong>多数据源连接</strong>：Tableau Desktop 支持连接到几乎任何类型的数据源，包括文件（如 Excel、CSV）、数据库（如 SQL Server、MySQL）、云服务（如 Google Analytics、Salesforce）等。</li><li><strong>数据混合</strong>：能够将来自不同数据源的数据组合在一起，进行更深入的分析。</li></ul><h4 id="可视化创建"><a href="#可视化创建" class="headerlink" title="可视化创建"></a>可视化创建</h4><ul><li><strong>拖放界面</strong>：通过直观的拖放操作，用户可以轻松地创建各种数据可视化，无需编程知识。</li><li><strong>高度可定制</strong>：提供多种可视化类型和自定义选项，让用户能够设计出满足特定需求的报告和仪表板。</li><li><strong>交互式探索</strong>：用户可以通过筛选、钻取和排序等交互操作，深入探索数据。</li></ul><h4 id="分析功能"><a href="#分析功能" class="headerlink" title="分析功能"></a>分析功能</h4><ul><li><strong>即席查询</strong>：允许用户快速对数据进行即席分析，探索数据之间的关系。</li><li><strong>高级分析</strong>：支持趋势线、预测、聚类等高级分析功能，帮助用户识别模式和趋势。</li></ul><h4 id="共享与协作"><a href="#共享与协作" class="headerlink" title="共享与协作"></a>共享与协作</h4><ul><li><strong>发布和共享</strong>：创建的视图和仪表板可以发布到 Tableau Server 或 Tableau Online，与同事或客户共享，实现团队协作和数据驱动决策。</li><li><strong>交互式仪表板</strong>：发布的仪表板保持其交互性，使最终用户能够根据自己的需要探索数据。</li></ul><h4 id="版本和许可"><a href="#版本和许可" class="headerlink" title="版本和许可"></a>版本和许可</h4><p>Tableau Desktop 提供不同的版本，包括专业版和个人版，以满足不同用户的需求。专业版提供了更广泛的数据连接选项和功能，而个人版则在功能上有所限制。Tableau Desktop 是基于订阅的许可模式，用户需要购买许可才能使用。</p><p>通过 Tableau Desktop，数据分析师和业务用户可以将复杂的数据转化为易于理解和交互的视图，从而发现洞见并做出更加明智的决策。</p><h3 id="Tableau-Server"><a href="#Tableau-Server" class="headerlink" title="Tableau Server"></a>Tableau Server</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8c4a87dd-1071-4701-3c44-75c8b03a5c00/public"                      width = "600"                ><p>Tableau Server 是 Tableau 产品家族中的一个关键组成部分，设计用于在企业环境中共享、协作和发布 Tableau 数据可视化和仪表板。它是一个在线平台，允许用户通过 web 浏览器访问在 Tableau Desktop 上创建的报告和分析。以下是 Tableau Server 的一些主要特征和功能：</p><h4 id="数据共享与协作"><a href="#数据共享与协作" class="headerlink" title="数据共享与协作"></a>数据共享与协作</h4><ul><li><strong>安全发布</strong>：用户可以将在 Tableau Desktop 上创建的可视化、报告和仪表板安全地发布到 Tableau Server，确保数据和信息的集中管理和控制。</li><li><strong>实时协作</strong>：支持团队成员之间的实时协作，允许用户评论、共享视图和交互式分析，促进决策过程。</li></ul><h4 id="访问控制和管理"><a href="#访问控制和管理" class="headerlink" title="访问控制和管理"></a>访问控制和管理</h4><ul><li><strong>灵活的权限管理</strong>：管理员可以对数据、报告和仪表板设置详细的访问权限，确保只有授权用户才能访问敏感信息。</li><li><strong>用户和群组管理</strong>：支持对用户和群组进行管理，简化了权限和访问控制的配置。</li></ul><h4 id="移动访问"><a href="#移动访问" class="headerlink" title="移动访问"></a>移动访问</h4><ul><li><strong>移动优化</strong>：Tableau Server 提供的视图和仪表板针对移动设备进行了优化，支持在各种设备上（如智能手机和平板电脑）进行访问和交互。</li></ul><h4 id="集成和扩展性"><a href="#集成和扩展性" class="headerlink" title="集成和扩展性"></a>集成和扩展性</h4><ul><li><strong>企业级集成</strong>：可以与企业中现有的认证系统（如 Active Directory）集成，实现单点登录（SSO）。</li><li><strong>API和扩展</strong>：提供丰富的 API 支持，允许开发者创建自定义应用程序和集成，扩展 Tableau 的功能。</li></ul><h4 id="可伸缩性和可靠性"><a href="#可伸缩性和可靠性" class="headerlink" title="可伸缩性和可靠性"></a>可伸缩性和可靠性</h4><ul><li><strong>高可伸缩性</strong>：Tableau Server 设计用于满足从小型团队到大型企业的需求，可以根据组织的成长进行扩展。</li><li><strong>数据刷新和自动化</strong>：支持定期数据刷新和报告自动化，确保用户总是访问到最新的数据。</li></ul><h4 id="部署选项"><a href="#部署选项" class="headerlink" title="部署选项"></a>部署选项</h4><ul><li><strong>本地部署</strong>：可以在企业的本地服务器上部署 Tableau Server，完全控制数据和基础设施。</li><li><strong>云部署</strong>：也可以选择在云环境（如 Amazon Web Services、Google Cloud Platform 或 Microsoft Azure）中部署，利用云计算的灵活性和扩展性。</li></ul><p>Tableau Server 为企业提供了一个强大的平台，用于数据驱动的决策支持，通过使数据可视化和报告更加易于访问、共享和理解，从而增强了组织的数据文化和分析能力</p><h3 id="Tableau-Online"><a href="#Tableau-Online" class="headerlink" title="Tableau Online"></a>Tableau Online</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5dfc02f7-c203-4980-87ae-a1fb5bc47000/public"                      width = "600"                ><p>Tableau Online 是 Tableau 提供的一个托管的软件即服务(SaaS)解决方案，它允许用户通过云分享、发布和协作 Tableau 数据可视化和仪表板。它基本上是 Tableau Server 的云版本，提供相似的功能和体验，但无需企业自己维护服务器或其他硬件设备。以下是 Tableau Online 的一些主要特点和功能：</p><h4 id="云基础架构"><a href="#云基础架构" class="headerlink" title="云基础架构"></a>云基础架构</h4><ul><li><strong>无需硬件维护</strong>：作为一个完全托管的服务，Tableau Online 为用户省去了安装、配置和维护服务器的需求，简化了部署和管理过程。</li><li><strong>快速部署</strong>：用户可以迅速启动和扩展他们的数据分析项目，无需担心基础设施的限制。</li></ul><h4 id="数据连接和集成"><a href="#数据连接和集成" class="headerlink" title="数据连接和集成"></a>数据连接和集成</h4><ul><li><strong>连接到多种数据源</strong>：Tableau Online 支持直接连接到云基础的数据源，如 Google BigQuery、Amazon Redshift、Snowflake 等，以及通过 Tableau Bridge 实现对本地数据源的实时或定期刷新。</li><li><strong>数据集成</strong>：允许通过各种数据集成和预处理工具准备和优化数据，以提高分析效率。</li></ul><h4 id="协作和分享"><a href="#协作和分享" class="headerlink" title="协作和分享"></a>协作和分享</h4><ul><li><strong>易于分享和访问</strong>：用户可以创建、发布和分享仪表板，使团队成员或客户能够通过 web 浏览器或移动设备访问最新的分析。</li><li><strong>实时协作</strong>：支持在线评论、共享和交互功能，促进团队成员之间的沟通和协作。</li></ul><h4 id="安全性和合规性"><a href="#安全性和合规性" class="headerlink" title="安全性和合规性"></a>安全性和合规性</h4><ul><li><strong>安全的数据环境</strong>：Tableau Online 提供高级安全功能，包括数据加密、双因素认证和详细的访问控制，以保护敏感信息。</li><li><strong>合规性</strong>：遵守包括 GDPR 在内的主要国际安全和隐私标准。</li></ul><h4 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h4><ul><li><strong>自动扩展</strong>：随着需求的增加，Tableau Online 可以自动扩展，提供所需的计算资源，确保性能和响应速度。</li></ul><h4 id="移动访问-1"><a href="#移动访问-1" class="headerlink" title="移动访问"></a>移动访问</h4><ul><li><strong>移动优化</strong>：通过 Tableau Mobile 应用程序，用户可以在任何地方访问和交云式的仪表板和视图，使数据分析更加灵活和便捷。</li></ul><p>Tableau Online 适合那些希望利用云计算优势、减少 IT 开销并快速启动数据分析项目的企业和团队。它为用户提供了一个强大、灵活且易于管理的平台，用于探索、可视化和分享数据洞见。</p><h1 id="Tableau-Desktop-工作区"><a href="#Tableau-Desktop-工作区" class="headerlink" title="Tableau Desktop 工作区"></a>Tableau Desktop 工作区</h1><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>想要使用 <em>Tableau</em> 对数据进行分析，并且通过可视化进行展示，首先需要使用 <em>Tableau</em> 连接数据源，连接成功后，即可进入数据源工作区，数据源页面通常包含左侧数据窗格区、画布区、元数据网格分区数据预览区四个部分</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/58fff47c-3ffa-462e-7682-a15f88e1a200/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8b2063b7-813e-42e8-ab93-7e7214dbcb00/public"                      width = "600"                ><h2 id="工作表"><a href="#工作表" class="headerlink" title="工作表"></a>工作表</h2><p>在Tableau中连接数据之后，即可进入工作表工作区。工作表工作区通常包含菜单、工具栏、数据窗口、页面和筛选器和标记卡等区域，通过将字段拖放到行列功能区上来生成可视化图表，同时也可以对数据进行简单的数据处理。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3ec1cf70-b72b-42f2-92b4-2d40eb4d8500/public"                      width = "600"                ><h2 id="仪表板"><a href="#仪表板" class="headerlink" title="仪表板"></a>仪表板</h2><p>仪表板工作区是把工作表和一些图片、文本、网页类型的对象按一定的布局方式组织在一起。仪表板工作区通常包含仪表板窗口、布局窗口、仪表板视图、仪表板对象窗口等。在仪表板工作区，我们可以把之前加工的工作表整合成一张数据看板。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3ae84f91-975e-4b14-2c7c-192828f08e00/public"                      width = "600"                ><h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p>故事是将多个工作表、仪表板按照一定的逻辑顺序串联起来的PPT，一般将故事用作演示工具。故事工作区通常包含仪表板和工作表窗口、故事视图区、故事说明和导航器设置等。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b000db90-fed0-4435-c13d-81489f6a6b00/public"                      width = "600"                ><h1 id="数据源处理案例"><a href="#数据源处理案例" class="headerlink" title="数据源处理案例"></a>数据源处理案例</h1><h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>连接到文件：支持导入本地文件，文本，execl，cvs，json，pdf等。</p><p>连接到服务器：SQL Server，MySQL，Oracle，等关系或非关系行数据库。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/64eae605-0f5e-45d3-aedf-09d1c91ab400/public"                      width = "600"                ><h2 id="Tableau字段类型"><a href="#Tableau字段类型" class="headerlink" title="Tableau字段类型"></a>Tableau字段类型</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9a4c8d81-b4c0-49a0-98d7-37f42ebb4600/public"                      width = "600"                ><h1 id="条形图与直方图案例"><a href="#条形图与直方图案例" class="headerlink" title="条形图与直方图案例"></a>条形图与直方图案例</h1><h2 id="Tableau绘制条形图"><a href="#Tableau绘制条形图" class="headerlink" title="Tableau绘制条形图"></a>Tableau绘制条形图</h2><p><strong>概念</strong>：条形图，又称条状图，柱状图，是最常用的图标类型之一，他是通过垂直或水平的条形展示维度字段的分布情况</p><p><strong>应用</strong>：最适宜比较不同类别的大小。</p><p><strong>维度多为字符串类型代表的是类别  度量多为数值类型可以进行计算 求和 求平均值等</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/932c862c-5a88-4b6b-ba2a-b34777fe8b00/public"                      width = "600"                ><p>条形图1：各地区酒店数量 </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b1e8c0d7-3789-4258-f334-7a4e8663d500/public"                      width = "600"                ><p>条形图2：各地区酒店均价 </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2946b907-fc3a-45c7-a78e-575a8950e500/public"                      width = "600"                ><p>堆积图3：价格等级堆积柱状图 （应用场景用于构成）</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fd877a9f-3238-4fbd-224a-b8f07715b500/public"                      width = "600"                ><h2 id="Tableau绘制直方图"><a href="#Tableau绘制直方图" class="headerlink" title="Tableau绘制直方图"></a>Tableau绘制直方图</h2><p><strong>概念</strong>：直方图与条形图类似，主要区别在于条形图的横轴为单个类别，不用考虑纵轴上的度量值，</p><p>用条形的长度表示各类别数量的多少;而直方图的横轴为对分析类别的分组( Tableau 中称为分桶)，</p><p>横轴宽度表示各组的组距，纵轴代表每级样本数量的多少。</p><p><strong>应用</strong>：适用于对类别进行分组统计分析。分组的原因可能是因为类别是连续的，或者类别虽然离散但是数量过多，可以视为近似于连续，当然也可以基于某种业务需要</p><p>直方图概念与用途（主要是用于呈现数值的分布情况）</p><p>创建评分直方图 ：数据桶（用于数值的区间）</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/abfd6bac-7690-43d4-cae0-12fa7f541300/public"                      width = "600"                ><p><strong>数据桶建议值&#x3D;最大值与最小值的差异</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/85890470-058e-4153-8b7b-5a779cb44d00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/862a750a-70ef-4ea6-273c-ae2e45347500/public"                      width = "600"                ><h2 id="场景思考"><a href="#场景思考" class="headerlink" title="场景思考"></a>场景思考</h2><h3 id="什么时候用条形图？"><a href="#什么时候用条形图？" class="headerlink" title="什么时候用条形图？"></a>什么时候用条形图？</h3><h4 id="比较类别数据"><a href="#比较类别数据" class="headerlink" title="比较类别数据"></a>比较类别数据</h4><p>当需要比较不同类别或分组之间的数值时，条形图是一个非常有效的工具。例如，比较不同产品的销售额、不同地区的人口数量或不同时间段的访问量。</p><h4 id="显示数据的排名或顺序"><a href="#显示数据的排名或顺序" class="headerlink" title="显示数据的排名或顺序"></a>显示数据的排名或顺序</h4><p>条形图可以清晰地显示各个类别按数值大小的排名，使得观察哪些类别表现最好或最差变得直观。这对于展示排行榜或优先级排序非常有用。</p><h4 id="展示变化或趋势"><a href="#展示变化或趋势" class="headerlink" title="展示变化或趋势"></a>展示变化或趋势</h4><p>虽然条形图主要用于类别比较，但它们也可以用来显示时间序列数据中的变化或趋势，特别是当时间点较少，关注点在于具体时间点的值比较时。</p><h4 id="部分对整比较"><a href="#部分对整比较" class="headerlink" title="部分对整比较"></a>部分对整比较</h4><p>堆叠条形图或分段条形图可以用来展示不同类别在整体中所占的比例或部分对整的比较，如不同部门的支出占总预算的比例。</p><h4 id="简单的数据量展示"><a href="#简单的数据量展示" class="headerlink" title="简单的数据量展示"></a>简单的数据量展示</h4><p>当数据集不是很复杂，只需要展示少量的类别和数值时，条形图是一种简单直观的展示方式。</p><h4 id="使用条形图时的注意事项"><a href="#使用条形图时的注意事项" class="headerlink" title="使用条形图时的注意事项"></a>使用条形图时的注意事项</h4><ul><li><strong>选择适当的条形图类型</strong>：根据你的数据和分析目标，选择最合适的条形图类型，如水平条形图、垂直条形图、堆叠条形图等。</li><li><strong>考虑条形的排序</strong>：条形的排序可以影响图表的可读性和信息的传达。根据需要考虑使用升序、降序或特定的逻辑顺序。</li><li><strong>清晰的标签和标题</strong>：确保每个条形都有清晰的标签，使观众能够轻松理解图表中的数据。同时，图表应有一个描述性的标题，说明图表展示的是什么信息。</li><li><strong>避免过度拥挤</strong>：当类别数量过多时，条形图可能会变得拥挤且难以阅读。在这种情况下，考虑使用其他类型的图表，或者将数据分成几个不同的图表来展示。</li></ul><h1 id="折线图，饼图与环形图案例"><a href="#折线图，饼图与环形图案例" class="headerlink" title="折线图，饼图与环形图案例"></a>折线图，饼图与环形图案例</h1><h2 id="数据前处理"><a href="#数据前处理" class="headerlink" title="数据前处理"></a>数据前处理</h2><p>tableau 的数据可视化能力强一点，数据处理能力相对弱一点。</p><p>拆分 </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f89e8873-c9d7-4acf-a816-912c3afbc900/public"                      width = "600"                ><p>隐藏</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/57c28a6c-b527-43ce-2935-001762072900/public"                      width = "600"                ><p>自定义拆分 ：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d201bf8a-ad13-432f-5cb1-6553b64c5800/public"                      width = "600"                ><p>修改数值格式  上映日期字段改为日期</p><h2 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h2><p><strong>概念</strong>：一种以折线的上升或下降来表示统计数量的增减变化趋势的统计图。</p><p><strong>应用</strong>：最适用于时间序列的数据。</p><p>创建电影数量变化折线图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d4441147-de18-4370-67e2-d857fbdc5000/public"                      width = "600"                ><p>创建电影票房变化折线图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/683e2bc1-1b8d-4c04-ce75-3e16f04f2e00/public"                      width = "600"                ><p>2015年的电影数量与票房比较分析</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/26f757ab-aa94-4ac1-b940-7f107b7a8300/public"                      width = "600"                ><h2 id="饼图与环形图"><a href="#饼图与环形图" class="headerlink" title="饼图与环形图"></a>饼图与环形图</h2><p><strong>概念</strong>：用圆形及圆内扇形的角度来表示数值大小的图形。</p><p><strong>应用</strong>：最适合用来展示一个数据系列中各项值的大小与总和的比例</p><p>酒店价格等级饼图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/40d822e5-0ad1-4e19-b71d-db0814aa8900/public"                      width = "600"                ><p>酒店价格等级环形图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2c4199f5-1064-4294-db97-3df49f349500/public"                      width = "600"                ><p>导出：导出图片</p><p>说明：撰写分析意见</p><h2 id="场景思考-1"><a href="#场景思考-1" class="headerlink" title="场景思考"></a>场景思考</h2><h3 id="什么时候使用折线图？"><a href="#什么时候使用折线图？" class="headerlink" title="什么时候使用折线图？"></a>什么时候使用折线图？</h3><p><strong>折线图</strong></p><p>折线图适合用于展示数据随时间的变化情况，它可以清晰地展示趋势、波动或者比较不同数据系列之间的关系。你应该在以下情况使用折线图：</p><ul><li><strong>时间序列数据</strong>：当你有一系列按时间顺序排列的数据点时，折线图是展示这种数据变化趋势的理想选择。</li><li><strong>比较多个数据系列</strong>：如果你想比较多组数据在相同时间框架内的变化，折线图可以帮助观众理解这些数据系列之间的关系。</li><li><strong>强调趋势或模式</strong>：当需要强调数据随时间的增长、下降或周期性波动时，折线图能够清楚地展示这些趋势。</li></ul><h3 id="什么时候使用饼图？"><a href="#什么时候使用饼图？" class="headerlink" title="什么时候使用饼图？"></a>什么时候使用饼图？</h3><p><strong>饼图</strong></p><p>饼图适合用于展示各部分占整体的比例关系，它通过切分圆形的方式让我们一目了然地看到各部分之间的比例大小。你应该在以下情况使用饼图：</p><ul><li><strong>展示比例</strong>：当你需要展示一个整体被分成几部分，以及各部分占整体的百分比时，饼图是一个好选择。</li><li><strong>有限的分类数据</strong>：饼图最适合展示少量分类的数据比例分布。如果分类太多，饼图会显得拥挤，难以阅读。</li><li><strong>强调部分与整体之间的关系</strong>：饼图能够清晰地展示出各部分与整体之间的比例关系，适用于当你想强调单个或多个部分在整体中所占的重要性时。</li></ul><h1 id="基础表，树形图，气泡图，词云案例"><a href="#基础表，树形图，气泡图，词云案例" class="headerlink" title="基础表，树形图，气泡图，词云案例"></a>基础表，树形图，气泡图，词云案例</h1><h2 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h2><p><strong>概念</strong>：基本表，又称作文本表、交叉表，即一般意义上的表格，它是一种最为直观的数据表现方式，在数据分析中具有不可忽视的作用</p><p><strong>应用：</strong>可以代替冗长的文字叙述，便于计算、分析和对比</p><p>基本表的使用</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/23ae59a4-e73c-495e-486b-76df68060a00/public"                      width = "600"                ><p>凹凸表的使用</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/00a97070-11d5-427a-e05a-d431b1acbb00/public"                      width = "600"                ><h2 id="树状图"><a href="#树状图" class="headerlink" title="树状图"></a>树状图</h2><p><strong>概念</strong>：也称树形图，使用一组嵌套矩形来显示数据，也是一种突出显示异常数据点或重要数据的方法。</p><p><strong>应用</strong>：适用于展示数据之间的层级和占比关系。</p><ul><li>不同类型酒店数量与价格</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9b464af7-5bf9-4cd3-80a7-54fb67e72e00/public"                      width = "600"                ><ul><li>香港不同地区酒店数量与价格</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/67db54e0-7b9a-420a-0fee-371516e3d900/public"                      width = "600"                ><h2 id="气泡图与词云"><a href="#气泡图与词云" class="headerlink" title="气泡图与词云"></a>气泡图与词云</h2><p><strong>概念</strong>：通过每个气泡表示维度字段的一个取值，各个气泡的大小或颜色代表了度量值的大小。</p><p><strong>应用</strong>：具有视觉吸引力，能够以非常直观的方式展示数据的大小</p><ul><li>不同类型电影数量与票房</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d0720a22-6212-48b5-749f-cbc0032c1100/public"                      width = "600"                ><ul><li>动作电影动态气泡图</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/54508766-b1b1-4a87-02ec-c6000a2cdb00/public"                      width = "600"                ><ul><li>词云图制作</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2f1abc4e-bed3-4247-a1bc-59c98f0f6c00/public"                      width = "600"                ><h1 id="标靶图案例"><a href="#标靶图案例" class="headerlink" title="标靶图案例"></a>标靶图案例</h1><h2 id="制作标靶图"><a href="#制作标靶图" class="headerlink" title="制作标靶图"></a>制作标靶图</h2><p><strong>概念</strong>：通常是基于条形图的基础上，增加一些参考区间，可以帮助分析人员更加直观的了解两个度量之间的关系，通常是用来比较计划值和实际值，比如说我的这个东西有没有达到我的一个计划值或标准。</p><ul><li><p>二月份电量销售额完成情况</p></li><li><p>参考线与参考区间</p></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d99a4c6a-8d03-4e0a-a5d2-a2c8af375d00/public"                      width = "1000"                ><h1 id="数据集合并"><a href="#数据集合并" class="headerlink" title="数据集合并"></a>数据集合并</h1><p><strong>概念</strong>：数据合并就是将值（行）从一个表附加到另一个表,合并两个或更多表。它用于数据结构完全一致的数据的合并，合并不会增加新的列，只是将不同文件的数据追加在一起，增加了行数。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/389c4493-fd85-4383-3921-45391d56fb00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7ecad5bb-4bce-4f7a-c5f6-c08fe6e2ab00/public"                      width = "600"                ><h1 id="数据分层，数据组，数据集"><a href="#数据分层，数据组，数据集" class="headerlink" title="数据分层，数据组，数据集"></a>数据分层，数据组，数据集</h1><h2 id="数据分层（层级）结构-（下钻-上卷）"><a href="#数据分层（层级）结构-（下钻-上卷）" class="headerlink" title="数据分层（层级）结构 （下钻&#x2F;上卷）"></a>数据分层（层级）结构 （下钻&#x2F;上卷）</h2><h3 id="分层结构的概念与意义"><a href="#分层结构的概念与意义" class="headerlink" title="分层结构的概念与意义"></a>分层结构的概念与意义</h3><p><strong>概念</strong>：它是一种维度之间自上而下的组织形式，tableau默认包含对某些结构的分层形式，如日期时间，地理角色，以日期维度为例，本身就包含年 季度 月 周 日 时。</p><p><strong>应用</strong>：在 Tableau 中，有两种方法可以进行下钻和上卷，一种是单击行列功能区字段前方的“+”号，另-种是在视图标题上右键选择下钻。例如，我们想要查看中国不同地区、省份、城市的销售额情况，就可以利用分层结构的下钻和上卷功能</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ffb4af0e-51a2-4cff-bb4d-b1fdc7e3b600/public"                      width = "600"                ><h3 id="分层结构的创建与应用-层级无法嵌套"><a href="#分层结构的创建与应用-层级无法嵌套" class="headerlink" title="分层结构的创建与应用, 层级无法嵌套"></a>分层结构的创建与应用, 层级无法嵌套</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4c73d466-618c-4953-66e8-3cd17e6aca00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/66ae1c0c-2b3d-433c-255d-49dd1e5ce000/public"                      width = "600"                ><h2 id="数据分组-（分组赋值）"><a href="#数据分组-（分组赋值）" class="headerlink" title="数据分组 （分组赋值）"></a>数据分组 （分组赋值）</h2><h3 id="数据组创建及使用"><a href="#数据组创建及使用" class="headerlink" title="数据组创建及使用"></a>数据组创建及使用</h3><p><strong>概念</strong>：组是我们维度或度量成员值的离散组合，分组可以实现维度成员的重新组合，以及度量值的范围分类（回形针图标）</p><h3 id="人工坐席接听分组"><a href="#人工坐席接听分组" class="headerlink" title="人工坐席接听分组"></a>人工坐席接听分组</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/feb7210e-391a-40e5-067a-8949683cbe00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d830c753-1ffc-4d4c-5420-81277aa76900/public"                      width = "600"                ><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h3 id="数据集的相关概念"><a href="#数据集的相关概念" class="headerlink" title="数据集的相关概念"></a>数据集的相关概念</h3><p><strong>概念</strong>：集是根据某些条件定义数据子集的自定义字段，可以理解为维度的部分成员。集能够用于计算，参与计算字段的编辑。</p><p><strong>类型</strong>：根据是否能够随着<strong>数据动态变化</strong>，集可以分为两大类：<strong>常量集和计算集</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/880e5a24-3329-4a68-6dc8-526ccad65100/public"                      width = "600"                ><p><strong>作用</strong>：集主要用于筛选，通过选取维度的部分成员作为数据子集，以实现对不同对象的选取。</p><h3 id="创建数据集"><a href="#创建数据集" class="headerlink" title="创建数据集"></a>创建数据集</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/20972963-7176-4aac-0114-1d189740d100/public"                      width = "600"                ><h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><h3 id="计算字段基础"><a href="#计算字段基础" class="headerlink" title="计算字段基础"></a>计算字段基础</h3><p>概念，类型，创建，使用，编辑</p><p>根据数据源字段维度，度量，参数等，使用函数和运算符来定义的字段，和其他字段一样也能拖放到功能区构建视图</p><p>还能由于创建新的字段，且返回值分成数值型，字符型。 会新增一个<strong>数据列</strong></p><p><strong>创建计算字段后会在数据源中新增一列，但不会影响原始数据</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/eb9848e0-baf3-45fc-1319-bf2f93cf9600/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/46b71839-b121-4e6d-2550-a3527649b500/public"                      width = "600"                ><p><strong>复杂一点的计算字段</strong></p><p>if 函数</p><p>盈利标准：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF SUM([利润])&gt;0 THEN <span class="string">&quot;盈利&quot;</span></span><br><span class="line">ELSE <span class="string">&quot;亏损&quot;</span></span><br><span class="line">END</span><br></pre></td></tr></table></figure></div><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>度量聚合和维度集合，大多数情况使用的是度量聚合</p><h3 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h3><p>粒度结合散点图使用，代表的是散点图的颗粒浓度。</p><h1 id="人口金字塔"><a href="#人口金字塔" class="headerlink" title="人口金字塔"></a>人口金字塔</h1><p>概念：又叫炫风图，本质上就是成对的条形图，在同一个行上对称的显示和比较两个类别的统计指标，用另一个分类来显示不同的行</p><h2 id="创建人口金字塔"><a href="#创建人口金字塔" class="headerlink" title="创建人口金字塔"></a>创建人口金字塔</h2><p><code>女性人数 IF [性别]=&quot;Female&quot; THEN [总人数] ELSE 0 END</code></p><p><code>男性人数 IF [性别]=&quot;Male&quot; THEN [总人数] ELSE 0 END</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/716a9150-446d-428a-cd50-ae1a41022e00/public"                      width = "600"                ><h1 id="漏斗图"><a href="#漏斗图" class="headerlink" title="漏斗图"></a>漏斗图</h1><h2 id="漏斗图概念与用途"><a href="#漏斗图概念与用途" class="headerlink" title="漏斗图概念与用途"></a>漏斗图概念与用途</h2><p>概念：直观的展示业务流程，可以快速发现流程中存在的问题，在电商，营销，客户关系管理等领域广泛应用</p><h2 id="公众号流量转化漏斗图"><a href="#公众号流量转化漏斗图" class="headerlink" title="公众号流量转化漏斗图"></a>公众号流量转化漏斗图</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6dfc9730-ff6b-4709-e10e-8d45700dac00/public"                      width = "600"                ><h1 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h1><h2 id="甘特图的概念和用途"><a href="#甘特图的概念和用途" class="headerlink" title="甘特图的概念和用途"></a>甘特图的概念和用途</h2><p><strong>概念</strong>：甘特图，又称横道图，是以图示的方式通过活动列表和时间刻度形象地表示出任何特定项目的活动顺序和持续时间。甘特图的横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上该活动或项目的持续时间，因此可以用来比较与日期相关的不同活动（项目）的持续时间长短。甘特图也常用于显示不同任务之间的依赖关系，并被普遍用于项目管理中。</p><p><strong>用途</strong>：已图视的方式来表达，通过活动列表和时间刻度，能够形象的表达出特定的项目的顺序和持续时间，普遍用在项目管理页面</p><h2 id="交货延期情况的甘特图"><a href="#交货延期情况的甘特图" class="headerlink" title="交货延期情况的甘特图"></a>交货延期情况的甘特图</h2><p> <strong>蓝色的天</strong>：代表的是维度，或可以理解为一个分类符。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/abcf3d19-5548-4cd4-4070-ae7e9207c800/public"                      width = "600"                ><p> <strong>绿色的天</strong>：代表的是真正的时间，可以进行计算</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3385a19b-b847-4981-ed84-3cea35a47a00/public"                      width = "600"                ><p>举例说明 年龄是一个真的的数字，可以进行计算，而身份证号无法进行计算。</p><h1 id="填充地图"><a href="#填充地图" class="headerlink" title="填充地图"></a>填充地图</h1><p>概念：实现国家、省&#x2F;自治区、地市级等不同详细级别数据的地理位置展示</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1dd112e4-6922-4705-1983-50e7a148e200/public"                      width = "600"                ><h1 id="范围-线图"><a href="#范围-线图" class="headerlink" title="范围-线图"></a>范围-线图</h1><h2 id="概念与用途"><a href="#概念与用途" class="headerlink" title="概念与用途"></a>概念与用途</h2><p>范围-线图是将整体数据的部分统计特征（均值，最大值，最小值等）展示在图形中，既可以说明群体特征，还可以展示个体信息</p><p>更可以比较个体与整体的相对关系。</p><h2 id="创建范围-线图"><a href="#创建范围-线图" class="headerlink" title="创建范围-线图"></a>创建范围-线图</h2><p>FIXED 指定维度进行聚合计算</p><p>AVG 求平均 </p><p>MAX 最大值 </p><p>MIN 最小值 </p><p>SUM 最大值</p><p>每天人工接听量的平均值   <code>&#123; FIXED [日期] :AVG([人工服务接听量])&#125;</code>  </p><p>每天人工接听量的最大值    <code>&#123; FIXED [日期] :MAX([人工服务接听量])&#125;</code></p><p>每天人工接听量的最小值    <code>&#123; FIXED [日期] :MIN([人工服务接听量])&#125;</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ffa4c06e-57f7-4b29-94d4-ca53df5c2600/public"                      width = "600"                ><h1 id="网络图"><a href="#网络图" class="headerlink" title="网络图"></a>网络图</h1><h2 id="简单的网络图"><a href="#简单的网络图" class="headerlink" title="简单的网络图"></a>简单的网络图</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a0a9c229-cea6-4310-50b1-b2ff3bbbdc00/public"                      width = "600"                ><h2 id="线路方式创建网络图"><a href="#线路方式创建网络图" class="headerlink" title="线路方式创建网络图"></a>线路方式创建网络图</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6e75af3a-8e8b-49cc-8ef6-726c259f8800/public"                      width = "600"                ><h1 id="仪表板高级应用"><a href="#仪表板高级应用" class="headerlink" title="仪表板高级应用"></a>仪表板高级应用</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>仪表板是若干视图的集合，让我们能同时比较各种数据。例如，我们有一组每天都要审阅的数据像收入的数据、业绩目标达成的数据、</p><p>用户数据等，就可以创建一个一次性显示所有视图的仪表板(下图)，将这些数据整合到一张仪表板上，而不是导航到单独的工作表。</p><h2 id="仪表板功能简介"><a href="#仪表板功能简介" class="headerlink" title="仪表板功能简介"></a>仪表板功能简介</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f9f7558d-76f9-4fd6-eac0-2495de280400/public"                      width = "600"                ><h2 id="仪表板布局"><a href="#仪表板布局" class="headerlink" title="仪表板布局"></a>仪表板布局</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2d161f09-2268-47f9-68ce-831d49e40800/public"                      width = "600"                ><p>布局1</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3de9db8b-70c3-4748-0902-87c16a5c3400/public"                      width = "600"                ><p>布局2</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/167a9370-d065-46a8-5a09-c25e1d21dc00/public"                      width = "600"                ><h2 id="故事-1"><a href="#故事-1" class="headerlink" title="故事"></a>故事</h2><p>概念：故事是一系列共同作用以传达信息的虚拟化项。可以创建故事以讲述数据，提供上下文，演示决策与结果的关系，或者只是创建一个极具吸引力的案例。同时，故事还是按顺序排列的工作表集合。故事中各个单独的工作表称为<strong>“故事点”</strong>。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93f54420-0ff4-4287-0ed9-6428dec1e900/public"                      width = "600"                ><h1 id="超市经营情况大屏制作"><a href="#超市经营情况大屏制作" class="headerlink" title="超市经营情况大屏制作"></a>超市经营情况大屏制作</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b1af838f-f78d-4f14-1c82-01a8fea7ea00/public"                      width = "600"                ><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="创建分类文件夹–日期–地区–产品–客户–其他"><a href="#创建分类文件夹–日期–地区–产品–客户–其他" class="headerlink" title="创建分类文件夹–日期–地区–产品–客户–其他"></a>创建分类文件夹–日期–地区–产品–客户–其他</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0ed2f912-295c-4753-6db6-0d68fddaaa00/public"                      width = "600"                ><h3 id="创建KPI参数"><a href="#创建KPI参数" class="headerlink" title="创建KPI参数"></a>创建KPI参数</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/276c0bd2-a1d3-4654-6a7a-ffd5ed7c4900/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a36ca087-b498-49a9-35d6-b0c2b8281900/public"                      width = "600"                ><h3 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h3><h4 id="指标Sales"><a href="#指标Sales" class="headerlink" title="指标Sales"></a>指标Sales</h4><p><code>SUM([销售额])</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2ce1e16f-1b36-4ba4-ff10-e8631de3c700/public"                      width = "600"                ><h4 id="利润率Profit"><a href="#利润率Profit" class="headerlink" title="利润率Profit %"></a>利润率Profit %</h4><p><code>SUM([利润])/SUM([销售额])</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c0e4fac7-f561-4728-569d-d780096fb100/public"                      width = "600"                ><h4 id="订单数Order"><a href="#订单数Order" class="headerlink" title="订单数Order"></a>订单数Order</h4><p><code>COUNT([订单 ID])</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b99193b7-8e33-448f-5db0-568d8c81e800/public"                      width = "600"                ><h4 id="折扣率Discount"><a href="#折扣率Discount" class="headerlink" title="折扣率Discount%"></a>折扣率Discount%</h4><p><code>SUM([销售额])/SUM([销售额]/(1-[折扣]))</code> </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f8507217-23ea-47c8-df96-86f00f67a500/public"                      width = "600"                ><h4 id="利润Profit"><a href="#利润Profit" class="headerlink" title="利润Profit"></a>利润Profit</h4><p><code>SUM([利润])</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3c40eb24-20a2-4729-ef0a-d981aa340800/public"                      width = "600"                ><h4 id="KPI"><a href="#KPI" class="headerlink" title="KPI"></a>KPI</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/94dd3ab3-facd-45ae-d564-463f4bdac500/public"                      width = "600"                >  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p><strong>WHEN ‘指标Sales’ 里面的值一定不能拖入</strong></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CASE [Option KPI]</span><br><span class="line">WHEN <span class="string">&#x27;指标Sales&#x27;</span> THEN [指标Sales]</span><br><span class="line">WHEN <span class="string">&#x27;利润Profit&#x27;</span>THEN [利润Profit]</span><br><span class="line">WHEN <span class="string">&#x27;利润率Profit %&#x27;</span>THEN [利润率Profit %]</span><br><span class="line">WHEN <span class="string">&#x27;订单数Order&#x27;</span>THEN [订单数Order]</span><br><span class="line">WHEN <span class="string">&#x27;折扣率Discount%&#x27;</span>THEN [折扣率Discount%]</span><br><span class="line">END</span><br></pre></td></tr></table></figure></div>    </div>  </div><h4 id="KPI-MAX"><a href="#KPI-MAX" class="headerlink" title="KPI MAX"></a>KPI MAX</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a6a64da2-e19d-413f-576e-c83b30e8a600/public"                      width = "600"                ><h4 id="KPI-MIN"><a href="#KPI-MIN" class="headerlink" title="KPI MIN"></a>KPI MIN</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b28099a5-3f88-40e9-9c56-8db3dfb2c800/public"                      width = "600"                ><h3 id="图表制作"><a href="#图表制作" class="headerlink" title="图表制作"></a>图表制作</h3><h4 id="创建KPI指标卡"><a href="#创建KPI指标卡" class="headerlink" title="创建KPI指标卡"></a>创建KPI指标卡</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ba107722-5822-4df2-994f-72e94631b800/public"                      width = "600"                ><h4 id="创建地图"><a href="#创建地图" class="headerlink" title="创建地图"></a>创建地图</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b9d7c599-536c-4126-9aad-50fb5ffa6500/public"                      width = "600"                ><h4 id="创建细分饼图"><a href="#创建细分饼图" class="headerlink" title="创建细分饼图"></a>创建细分饼图</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f6353185-2ee3-49b3-36e8-1789e3340200/public"                      width = "600"                ><h4 id="创建月份趋势图"><a href="#创建月份趋势图" class="headerlink" title="创建月份趋势图"></a>创建月份趋势图</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3c537205-975b-44c0-7e32-4527a56dea00/public"                      width = "600"                ><h4 id="创建子类别条形图"><a href="#创建子类别条形图" class="headerlink" title="创建子类别条形图"></a>创建子类别条形图</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2cd69a33-a46e-4925-0500-1216823ffa00/public"                      width = "600"                ><h3 id="仪表板制作"><a href="#仪表板制作" class="headerlink" title="仪表板制作"></a>仪表板制作</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ee6315cc-0d2c-42b5-4de2-4c56733a3700/public"                      width = "600"                ><h3 id="仪表板交互"><a href="#仪表板交互" class="headerlink" title="仪表板交互"></a>仪表板交互</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/61da0109-4891-4c12-29d3-55217ed42d00/public"                      width = "600"                >]]></content>
    
    
    <summary type="html">Tableau的认识操作，可视化图表创建</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="可视化" scheme="https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="Tableau" scheme="https://www.yiuhangblog.com/tags/Tableau/"/>
    
  </entry>
  
  <entry>
    <title>Power Query和可视化图表(Power BI)</title>
    <link href="https://www.yiuhangblog.com/2020/09/21/20200921%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8(Power%20BI)/"/>
    <id>https://www.yiuhangblog.com/2020/09/21/20200921%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8(Power%20BI)/</id>
    <published>2020-09-21T10:36:45.000Z</published>
    <updated>2024-02-28T10:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Power-Query的认识操作"><a href="#Power-Query的认识操作" class="headerlink" title="Power Query的认识操作"></a>Power Query的认识操作</h2><h3 id="如何进入Power-Query"><a href="#如何进入Power-Query" class="headerlink" title="如何进入Power Query"></a>如何进入Power Query</h3><p>在 <strong>Excel</strong> 中，进入 Power Query 的方式是选择 “数据” 选项卡下的 “从数据源获取” 或 “查询编辑器”。在 <strong>Power BI</strong> 中，进入 Power Query 的方式是通过点击 “首页” 选项卡下的 “转换数据”。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4e8f08a9-c2e8-496e-517f-b4739e075600/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bb72df7e-38dd-4a32-7f32-3a0fba8bfe00/public"                      width = "600"                ><h3 id="添加自定义列"><a href="#添加自定义列" class="headerlink" title="添加自定义列"></a>添加自定义列</h3><p>在 Power Query 中，可以通过 “添加列” 选项卡下的 “自定义列” 功能来创建新列。在这里，可以使用 M 语言编写公式，基于现有数据创建新的数据列。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/32da8a7b-12b0-410d-4de5-7a8f8d2a7300/public"                      width = "600"                ><h3 id="添加条件列"><a href="#添加条件列" class="headerlink" title="添加条件列"></a>添加条件列</h3><p>条件列允许基于现有列中的值来创建新列。例如，根据销售量对数据进行分类。这可以通过 “添加列” 选项卡下的 “条件列” 完成。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a5556eff-f1fc-441b-d894-85619a054e00/public"                      width = "600"                ><h3 id="索引列，重复列，拆分，提取"><a href="#索引列，重复列，拆分，提取" class="headerlink" title="索引列，重复列，拆分，提取"></a>索引列，重复列，拆分，提取</h3><ul><li><strong>索引列</strong>：可以添加一个序号列，对每行数据进行编号。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2fe434d0-c8d6-45cd-433c-ca15407b3000/public"                      width = "600"                ><ul><li><strong>重复列</strong>：允许创建现有列的副本。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/32365cb7-2d41-411a-109f-5bb97fd47600/public"                      width = "600"                ><ul><li><strong>拆分</strong>：可以根据某些条件（如分隔符）将文本列拆分成多个列。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/97d4ae87-00f5-40f8-537d-fb9e41b9c300/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3937df2d-a6bf-493f-ade0-68e6d2fec000/public"                      width = "600"                ><ul><li><strong>提取</strong>：允许从文本列中提取特定的字符。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0c43b068-bfa8-4164-cb44-4f70d3ba4900/public"                      width = "600"                ><h3 id="标题，删除，替换，筛选"><a href="#标题，删除，替换，筛选" class="headerlink" title="标题，删除，替换，筛选"></a>标题，删除，替换，筛选</h3><ul><li><strong>标题</strong>：调整列标题，使其更具描述性。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1b9bd801-e1ce-4013-b70e-0086ed929300/public"                      width = "600"                ><ul><li><p><strong>删除</strong>：删除不需要的列或行。</p></li><li><p><strong>替换</strong>：在列中替换文本或数值。</p></li><li><p><strong>筛选</strong>：根据条件筛选数据。</p></li></ul><h3 id="合并查询原理"><a href="#合并查询原理" class="headerlink" title="合并查询原理"></a>合并查询原理</h3><ul><li><strong>合并查询</strong>：两个或多个查询的数据组合在一起。合并可以通过不同的方式完成，如下所示：<ul><li><strong>左外合并</strong>：包括左表的所有行和右表中匹配的行。</li><li><strong>右外合并</strong>：包括右表的所有行和左表中匹配的行。</li><li><strong>外部合并</strong>：包括两个表中的所有行。</li><li><strong>内部合并</strong>：只包括两个表中匹配的行。</li><li><strong>左反合并</strong>：只包括左表中独有的行。</li><li><strong>右反合并</strong>：只包括右表中独有的行。</li></ul></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/eb53d8f7-f844-4699-f47d-855fc97bcd00/public"                      width = "600"                ><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>导入多表Excel</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6fb38f6e-06a7-4b6e-0aef-878074f50f00/public"                      width = "600"                ><p>左外合并</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/db65c2e1-5c35-493e-dfd0-ec011eebcb00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3671b964-2907-4da8-1301-9541f1922800/public"                      width = "600"                ><ul><li><p><strong>透视与透视列</strong></p><ul><li><strong>透视</strong>：将多行数据转换为列，通常用于整理和分析数据。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/15acf92f-c99f-4c65-b340-991e8abcb600/public"                      width = "600"                ><ul><li><strong>透视列</strong>：将列数据转换为行格式，与透视相反。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4f098e27-7012-4976-eb56-cd2063532e00/public"                      width = "600"                ></li><li><p><strong>分组依据</strong></p><ul><li>在 Power Query 中，可以根据一个或多个列的值对数据进行分组。这对于汇总信息非常有用。</li></ul></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/722fe6ea-09fe-4617-f622-b26132abb100/public"                      width = "600"                ><h2 id="可视化图表"><a href="#可视化图表" class="headerlink" title="可视化图表"></a>可视化图表</h2><h3 id="常用图表"><a href="#常用图表" class="headerlink" title="常用图表"></a>常用图表</h3><h4 id="堆积图条形图与柱状图"><a href="#堆积图条形图与柱状图" class="headerlink" title="堆积图条形图与柱状图"></a>堆积图条形图与柱状图</h4><p><strong>应用场景：</strong>最适宜比较不同类别的大小。</p><p>工作中为了反映数据细分和总体情况，我们常常会使用到堆积条形图，这种图形让我们既能看到整体推移情况，又能看到某个分组单元的总体情况，还能看到组内组成部分的细分情况，一举多得</p><p><strong>组成要素</strong>： </p><ol><li>组数：把数据分成几组，指导性的经验是将数据分成5到10组。</li><li>组宽度：通常来说，每组的宽度是一致的。组数和组宽度的选择就不是独立决定的，一个经验标准是：近似组宽度&#x3D;（最大值-最小值）&#x2F;组数，然后根据四舍五入确定初步的近似组宽度，之后根据数据的状况进行调整。</li><li>组限：分为组下限（进入该组的最小可能数据）和组上限（进入该组的最大可能数据），并且一个数据只能在一个组限内。绘画条形图时，不同组之间是有空隙的；而绘画直方图时，不同组之间是没有空隙的<strong>。</strong></li></ol><p><strong>注意：</strong>1. 确定谁是图例，2. 数据颜色和数据标，3. 标题，背景，4. 边框和阴影，5. x轴与y轴的起始刻度</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ac44a249-dd61-4f0c-7a6b-d3292c4a8c00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f0594fe0-0a9a-4b30-bdd8-05ae796bf900/public"                      width = "600"                ><h4 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h4><p><strong>应用场景</strong>：最适用于时间序列的数据。</p><p><strong>概念</strong>：什么是折线图呢？折线图是排列在工作表的列或行中的数据可以绘制到折线图中。折线图可以显示随时间(根据常用比例设置)而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。当有多个系列时，尤其适合使用折线图。如果有几个均匀分布的数值标签(尤其是年)，也应该使用折线图。在折线图中，类别数据沿水平轴均匀分布，所有值数据沿垂直轴均匀分布。</p><p><strong>注意</strong>：1. 确定谁是图例，2. 数据颜色和数据标签，3. 形状，4. 标题，背景，5. 边框和阴影，6. x轴与y轴的起始刻度</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fa2f3cce-98dc-4dd1-d555-73c077366400/public"                      width = "600"                ><h4 id="分区图与堆积面积图"><a href="#分区图与堆积面积图" class="headerlink" title="分区图与堆积面积图"></a>分区图与堆积面积图</h4><p><strong>概念</strong>：什么是分区图呢？分区图又称面积图，它着重强调数量随时间而变化的程度，也可用于引起人们对总值趋势的注意并清晰展现数据的增减趋势、增减的速度、增减的规律、峰值等特征等。此外，堆积面积图还可以显示部分与整体的关系。面积图包含图表区、标题、绘图区、图例、坐标轴、坐标轴标题、网格线、数据标签、数据系列（区域）等元素，广泛运用于各行各业，比如销售金额增幅，客流量统计等。  </p><p><strong>堆积面积图</strong>：层叠面积图上最大的面积代表了所有数据量的总和，是一个整体</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/75c3969a-01b0-4647-e978-4ec6c870e000/public"                      width = "600"                ><h4 id="瀑布图"><a href="#瀑布图" class="headerlink" title="瀑布图"></a>瀑布图</h4><p><strong>应用场景</strong>：一般用于计算公司销售毛利情况，出现有正数和负数的情况。</p><p><strong>概念</strong>：瀑布图是数据可视化分析中常见的一种图形，采用绝对值与相对值结合的方式，适用于表达数个特定数值之间的数量变化关系。对于一系列具有累计性质的正值&#x2F;负值具有很好的展示功能，既可以辅助理解数据的大小，又能直观地展示出数据的增减变化，反映数据在不同时期或受不同因素的影响结果</p><p><strong>注意</strong>：情绪颜色和细目</p><p>建议配合切片器使用，便于查看细分的日期</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9736e464-2d7b-47f7-0efe-cc4c5864d200/public"                      width = "600"                ><h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><p><strong>概念</strong>：散点图始终有两个数值轴可以显示：一组沿水平轴的数值数据，另一组沿垂直轴的数值数据。 图表在 x 和 y 数值的交叉处显示点，将这些值单独合并到各个数据点。 Power BI 可以跨水平轴均匀或不均匀地分布这些数据 点。 具体视散点图表示的数据而定。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/81b17449-52d4-4dfa-f436-c018c8b03c00/public"                      width = "600"                ><h4 id="饼图与环形图"><a href="#饼图与环形图" class="headerlink" title="饼图与环形图"></a>饼图与环形图</h4><p><strong>应用场景</strong>：最适合用来展示一个数据系列中各项值的大小与总和的比例</p><p><strong>概念</strong>：用圆形及圆内扇形的角度来表示数值大小的图形。</p><p>建议配合切片器使用，便于查看各个店铺的详细情况</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/db3296d5-5fd9-4c78-ac97-43a858a07100/public"                      width = "600"                ><h4 id="树状图"><a href="#树状图" class="headerlink" title="树状图"></a>树状图</h4><p><strong>应用创景</strong>：适用于展示数据之间的层级和占比关系。(钻取和上卷)</p><p><strong>概念：</strong>树状图将分层数据显示为一组嵌套矩形。 层次结构中的每个级别都由一个有色矩形（分支）表示，其中包含更小的矩形（叶）。 Power BI 根据度量值来确定每个矩形内的空间大小。 矩形按大小从左上方（最大）到右下方（最小）排列。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e2c911f4-dd89-4399-23eb-fb500f07de00/public"                      width = "600"                ><h4 id="漏斗图"><a href="#漏斗图" class="headerlink" title="漏斗图"></a>漏斗图</h4><p><strong>应用场景</strong>：一般作用与进度推进场景</p><p><strong>概念</strong>：直观的展示业务流程，可以快速发现流程中存在的问题，在电商，营销，客户关系管理等领域广泛应用 </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/26a9fd97-f3ae-4f69-4a29-d3bb11035600/public"                      width = "600"                >  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>漏斗分析法</strong></p><p>漏斗分析法是一种常用于数字营销和用户体验分析的方法。它通过将用户的整个转化过程视为一个漏斗，帮助定位在用户从潜在客户转化为最终客户的过程中的问题节点。这种方法特别适用于网站、应用程序和电子商务平台。</p><p><strong>漏斗法的关键概念</strong></p><ul><li><strong>向前找流量</strong>：这意味着要关注吸引用户的渠道和方法，理解何种营销策略、内容或广告在吸引潜在客户方面最为有效。</li><li><strong>向后看转化</strong>：这涉及到分析用户在漏斗的每个阶段的转化情况，比如从意识到兴趣，再到决策和行动，以便理解在哪个阶段用户最有可能流失。</li><li><strong>自身看画像</strong>：这是指理解你的目标用户群体的特征，包括他们的行为、偏好和需求。</li></ul><p><strong>漏斗分析法的应用</strong></p><ol><li><strong>定位问题节点</strong>：通过分析用户在漏斗的各个阶段的留存和流失，可以识别出用户体验中的问题点。例如，如果在结账过程中有大量用户流失，这可能表明结账过程存在问题。</li><li><strong>用户转化分析</strong>：漏斗分析帮助你理解用户从了解产品到最终购买的整个过程，哪些环节最有效，哪些环节需要改进。</li><li><strong>用户流失分析</strong>：通过分析在转化过程中流失的用户，可以了解导致用户流失的原因，并采取措施减少流失。</li><li><strong>关键交易路径分析</strong>：在电子商务等场景中，了解用户从浏览商品到完成购买的路径，并分析在这个过程中的每个环节的表现。</li><li><strong>数据对比分析</strong>：通过比较不同时间段或不同用户群体的漏斗数据，可以发现问题和机会点。</li><li><strong>针对性改进策略</strong>：基于漏斗分析的结果，可以采取具体的优化措施，比如改进网站设计、优化结账流程、调整营销策略等。</li></ol><p><strong>按照已知的转化路径，借助漏斗模型分析总体和每一步的转化情况。例如将漏斗图用于网站关键路径的转化率分析，不仅能显示用户的最终转化率，同时还可以展示每一节点的转化率。</strong></p>    </div>  </div><h4 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h4><p><strong>应用场景</strong>：适用于销售指标完成情况。</p><p>建议配合切片器使用，便于查看各个店铺的详细情况</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7487d4e5-b2c3-4a34-bc24-3f41d81e3800/public"                      width = "600"                ><h4 id="卡片图"><a href="#卡片图" class="headerlink" title="卡片图"></a>卡片图</h4><p><strong>应用场景</strong>：适用于总销售额汇总展示 </p><p>建议配合切片器使用</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8f8c7818-8a7d-4a8b-cdd4-4af37211c600/public"                      width = "600"                ><h3 id="高级图表"><a href="#高级图表" class="headerlink" title="高级图表"></a>高级图表</h3><h4 id="KPI"><a href="#KPI" class="headerlink" title="KPI"></a>KPI</h4><p>高级的卡片图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/40eb09fa-7cc6-4c7e-fd19-bb21b790d600/public"                      width = "600"                ><h4 id="分解数"><a href="#分解数" class="headerlink" title="分解数"></a>分解数</h4><p><strong>概念</strong>：可以理解为一个小型的数据分析模型，逐级进行分析展示</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/473e1bdc-0613-468d-c5c8-bfc494f30600/public"                      width = "600"                >  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>逻辑拆解法</strong></p><p>逻辑拆解法是一种解决问题的强大工具，它通过将复杂问题分解成若干个更小、更易管理的子问题来工作。这种方法源于费米问题，这类问题以物理学家恩里科·费米命名，他以通过估算来解决复杂问题而闻名。通过将大问题分解成一系列小问题，我们可以更容易地估计或解决这些小问题，从而逐步构建出大问题的答案。</p><blockquote><p>费米问题是指通过估算来近似解决复杂问题的一种方法。这种问题通常是开放式的，并且不可能直接得到精确答案。费米问题的解决通常需要借助于逻辑推理、已知数据、经验法则和合理假设。费米问题的解决过程涉及到对问题的分解，评估各部分的概率或数量，然后将这些部分合成以得出整体问题的大致答案。</p><p><strong>费米问题的解决原则：</strong></p><ol><li><strong>提出问题：</strong> 定义一个清晰且具体的问题。</li><li><strong>分解问题：</strong> 将问题分解为更小、更具体的子问题。</li><li><strong>估算参数：</strong> 对每个子问题进行数量估算，如果可能的话，使用已知的数据或常识。</li><li><strong>合理假设：</strong> 在缺少确切信息的情况下，做出合理的假设来填补空白。</li><li><strong>计算答案：</strong> 组合所有子问题的估算值来得出整个问题的近似答案。</li><li><strong>复核与调整：</strong> 检查结果的合理性，并在必要时调整假设和估算。</li></ol></blockquote><p><strong>逻辑树的构建</strong></p><p>逻辑树（也称为问题树、分解树等）是逻辑拆解法的核心工具。它以树状结构展示问题的分解过程，每个节点代表问题的一个子部分。逻辑树从一个单一的、定义明确的问题开始，这个问题位于树的根部。然后，这个问题被分解成若干个子问题，这些子问题构成树的第一层分支。每个子问题又可以进一步分解成更小的问题，形成下一层分支，依此类推，直至所有的问题都被分解成足够简单，可以直接解决的问题。</p><p><strong>逻辑树的原则</strong></p><p>逻辑树是一种帮助系统化分解问题的工具。以下是构建逻辑树的原则：</p><ol><li><strong>层次结构：</strong> 逻辑树应该有明确的层次结构，从根问题开始，逐步向下分解。</li><li><strong>互斥性：</strong> 每一层的子问题应该是互斥的，即它们不应该重叠，每个子问题应该覆盖根问题的不同部分。</li><li><strong>完整性：</strong> 所有子问题的集合应该能够完整地覆盖上一层问题的内容。</li><li><strong>逻辑性：</strong> 每次分解都应基于逻辑关系，如因果关系、分类、过程步骤等。</li><li><strong>可操作性：</strong> 分解的最终子问题应足够具体，以便可以采取行动或进行量化分析。</li></ol><p><strong>逻辑拆解法的步骤</strong></p><ol><li><strong>定义问题：</strong> 首先明确你要解决的问题。这个问题应该尽可能具体和清晰。</li><li><strong>构建逻辑树：</strong> 从问题出发，思考哪些主要因素或子问题构成了这个问题。这一步是创建逻辑树的开始，每个因素或子问题都是树的一个分支。</li><li><strong>进一步分解子问题：</strong> 对每个子问题继续进行分解，直到这些问题足够简单，可以直接解答或通过已知信息解决。</li><li><strong>分析和解决子问题：</strong> 对每个最终的子问题进行分析和解决。这可能涉及到数学计算、逻辑推理、数据分析或其他专业知识。</li><li><strong>整合结果：</strong> 最后，将所有子问题的解决方案整合起来，形成对原始问题的完整答案。</li></ol>    </div>  </div><h4 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h4><p>地图默认是不勾选的—点击文件–选项和设置–选项–勾选上地图和着色地图视觉对象 </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/848f7f45-c8e7-4361-ccf3-2194a840ea00/public"                      width = "600"                ><h4 id="关键影响着"><a href="#关键影响着" class="headerlink" title="关键影响着"></a>关键影响着</h4><p><strong>概念</strong>：类似于一个小型的AI,可以进行简单的自动分析。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6a44b72a-4a80-4f59-ca44-a9f5ca199900/public"                      width = "600"                ><h4 id="功能区图表"><a href="#功能区图表" class="headerlink" title="功能区图表"></a>功能区图表</h4><p><strong>应用场景</strong>：根据不同时间段显示排名</p><p><strong>概念：</strong>  可创建功能区图表来直观显示数据，并快速发现哪个数据类别具有最高排名（最大值）。 功能区图表能够高效地显示排名变化，并且会在每个时间段内始终将最高排名（值）显示在最顶部。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7a4f47c7-1f63-48c8-96f6-877ab079db00/public"                      width = "600"                ><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>制作出中国主要交通城市健康排行榜</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><h4 id="单页数据获取"><a href="#单页数据获取" class="headerlink" title="单页数据获取"></a>单页数据获取</h4><p>数据获取拓展 获取贝壳网数据 <a class="link"   href="https://sz.zu.ke.com/zufang" >https://sz.zu.ke.com/zufang <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b53ad9a5-9b83-4354-6453-6393fb7ca400/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cf847779-4db2-4e4b-d585-1fc08dd7e500/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5eecd381-6b05-4960-5b9e-d166c3b7b000/public"                      width = "600"                ><p>这样就完成了单页数据的获取</p><h4 id="批量获取多页数据"><a href="#批量获取多页数据" class="headerlink" title="批量获取多页数据"></a><strong>批量获取多页数据</strong></h4><p>定义数字变量P   &#96;(p as number) as table &#x3D;&gt;&#96;&#96;</p><p>&#96;&#96;Number.ToText(p)&#96;: 将定义的变量P转为文本与前面的url地址进行拼接，最终生成我们要采集数据的URL</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7c7deca6-ac56-4755-df72-8c9b5f173800/public"                      width = "600"                ><p>输入框里输入1点击调用，就是采集第一页的数据，输入2就是采集第二页的数据以此类推</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/16283d66-f188-407b-c5a9-76d30bf10400/public"                      width = "600"                ><p>新建源，生成一个空查询</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c249f799-0033-4d48-50f7-593091437200/public"                      width = "600"                ><p>输入框里输入<code>=&#123;1..10&#125;</code> 这样我们在调用这个查询的时候就会采集1-10页的数据</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c75b9f78-f887-43a8-1bd8-daf645e8f600/public"                      width = "600"                ><p>点击上面的转换，转换到表</p><p>这样我们就建立好了一个查询，待会p的参数就会从我们创建好的Column1这个函数里去调用</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/915caaab-abdb-4ad2-7247-81238a7c3d00/public"                      width = "600"                ><p>添加列–调用自定义函数–功能查询&#x2F;选择贝壳P&#x2F;选择我们刚刚生成的Column1</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2cd4e092-8bb8-4f6a-2c09-380dbf51cc00/public"                      width = "600"                ><p>如此一来 我们就实现了1-10页的批量爬取，当然如果要爬取更多页的数据调整1-10的参数即可。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5c7fae03-ad36-485d-f58e-1b3ef64fc200/public"                      width = "600"                >  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>Powerbi 不是专业的爬取工具，但遇到反扒机制比较强的网站，或网页结构比较复杂的，那Power bi就不适用。我们就需要使用更专业的爬取工具去采集数据，如Python，八爪鱼，火车头等采集工具。在采集数据之前最好想采集一页测试一下，如果可以在进行批量采集。如果采集不到，就只能换其他采集工具去采集数据。</p>    </div>  </div><h4 id="导入高德地图数据"><a href="#导入高德地图数据" class="headerlink" title="导入高德地图数据"></a>导入高德地图数据</h4><p>导入数据源：中国主要城市交通数据</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>修正表格标题和进行值的拆分</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/05a1da83-49ca-4bf2-1676-30e8b8f83700/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e16b254c-c652-4712-44b8-577fdf43d800/public"                      width = "600"                ><h3 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h3><h4 id="度量值与计算列"><a href="#度量值与计算列" class="headerlink" title="度量值与计算列"></a>度量值与计算列</h4><p>给交通健康排名表里每个城市打上健康或亚健康标签</p><h5 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h5><p><code>健康城市数量 =CALCULATE(MAX(&#39;城市类型统计&#39;[城市数量]),&#39;城市类型统计&#39;[健康状态]=&quot;健康&quot;)</code>，在城市类型统计表里面健康类型这个字段等于健康的，统计满足条件的城市数量最大值。</p><ol><li><code>CALCULATE</code> 函数：这是一个强大的函数，通常用于更改数据上下文并执行基于条件的计算。它可以应用过滤器来修改或创建新的数据上下文，并在这个上下文中计算表达式。</li><li><code>MAX(&#39;城市类型统计&#39;[城市数量])</code>：这个表达式是<code>CALCULATE</code>函数中的第一个参数，用于找出“城市类型统计”表中“城市数量”列的最大值。</li><li><code>&#39;城市类型统计&#39;[健康状态]=&quot;健康&quot;</code>：这是<code>CALCULATE</code>函数中的第二个参数，表示一个过滤器。它的作用是从“城市类型统计”表中筛选出那些“健康状态”列值为“健康”的记录。</li></ol><p>结合这些组件，整个公式的逻辑是：</p><ul><li>首先筛选出“健康状态”为“健康”的城市。</li><li>然后在这个已经过滤的数据集中找出“城市数量”列的最大值。</li></ul><p>所以，这个公式计算的是在所有被标记为“健康”的城市中，数量最多的城市有多少个。换句话说，这是在寻找在健康状态下具有最多城市数的记录。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c0f14041-1037-461d-7b83-9df29f034700/public"                      width = "600"                ><h5 id="新建列"><a href="#新建列" class="headerlink" title="新建列"></a>新建列</h5><p><code>健康类型 = IF(&#39;交通健康排名&#39;[排名]&lt;=&#39;城市类型统计&#39;[健康城市数量],&quot;健康&quot;,&quot;亚健康&quot;)</code> 判断健康排名小于等于健康城市数量，健康城市引用我们刚刚建设的度量值，满足就是健康，否则就是亚健康。</p><ol><li><code>IF</code> 函数：这是一个条件函数，通常用于根据给定的条件判断返回不同的结果。它有三个参数：一个逻辑测试（条件），如果条件为真时的结果，以及如果条件为假时的结果。</li><li><code>&#39;交通健康排名&#39;[排名]</code>：这是在某个表中引用的“排名”列，这里假设它是一个数值列，表示城市在交通健康方面的排名。</li><li><code>&#39;城市类型统计&#39;[健康城市数量]</code>：这是在另一个表中引用的“健康城市数量”列，假设这个列保存了某种计算或确定的健康城市的数量。</li><li><code>&lt;=</code>：这是一个比较运算符，表示“小于或等于”。</li></ol><p>整个公式的逻辑是：</p><ul><li>检查一个城市在“交通健康排名”中的排名是否小于或等于“城市类型统计”中定义的“健康城市数量”。</li><li>如果条件为真（即，如果城市的排名在健康城市数量范围内），则该城市被分类为“健康”。</li><li>如果条件为假（即，如果城市的排名超出了健康城市数量范围），则该城市被分类为“亚健康”。</li></ul><p>结果是一个新的列或标签，表示每个城市基于其交通健康排名的健康状态。 </p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/de82c357-f7b4-478a-baaf-2f2fd38ec100/public"                      width = "600"                ><h4 id="构建数据关联关系"><a href="#构建数据关联关系" class="headerlink" title="构建数据关联关系"></a>构建数据关联关系</h4><p>健康类型2 <code>= IF(&#39;交通健康排名&#39;[排名]&lt;=56,&quot;健康&quot;,&quot;亚健康&quot;)</code>（硬编码56）</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4bdebe99-06fe-4d10-63d8-103b40ab3900/public"                      width = "600"                ><ol><li><strong>IF函数：</strong> 这是一个基本的逻辑函数，它根据一个条件测试返回两个可能的结果之一。IF函数的结构是 <code>IF(条件, 真时返回值, 假时返回值)</code>。</li><li><strong>条件测试：</strong> <code>&#39;交通健康排名&#39;[排名]&lt;=56</code>。这里检查的是某个城市的排名是否小于或等于56。</li><li><strong>真时返回值：</strong> 如果上述条件成立（即排名是56或更好），则函数返回字符串”健康”。</li><li><strong>假时返回值：</strong> 如果条件不成立（即排名超过56），则函数返回字符串”亚健康”。</li></ol><p>这意味着，根据这个公式，所有排名在56或56之内的城市被认为是“健康”的，而所有排名超过56的城市则被认为是“亚健康”的。</p><h3 id="可视化大屏制作"><a href="#可视化大屏制作" class="headerlink" title="可视化大屏制作"></a>可视化大屏制作</h3><h4 id="城市健康状态占比：环形图"><a href="#城市健康状态占比：环形图" class="headerlink" title="城市健康状态占比：环形图"></a>城市健康状态占比：环形图</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9ce07281-1c95-4c1e-8bb0-6ea702be0900/public"                      width = "600"                ><h4 id="交通健康-亚健康城市top3：卡片图"><a href="#交通健康-亚健康城市top3：卡片图" class="headerlink" title="交通健康&#x2F;亚健康城市top3：卡片图"></a>交通健康&#x2F;亚健康城市top3：卡片图</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/036ebee7-22d1-40e8-52fc-77cc679b4300/public"                      width = "600"                ><h4 id="六宫格指标项表"><a href="#六宫格指标项表" class="headerlink" title="六宫格指标项表"></a>六宫格指标项表</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/469a6077-5899-403a-cd5f-6783c25f6f00/public"                      width = "600"                ><h4 id="地图-1"><a href="#地图-1" class="headerlink" title="地图"></a>地图</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/98847b7f-547b-417a-9a1f-b72979c79f00/public"                      width = "600"                ><h4 id="交通健康排名表"><a href="#交通健康排名表" class="headerlink" title="交通健康排名表"></a>交通健康排名表</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ca78bd8b-adb9-45e0-aeeb-71c415059300/public"                      width = "600"                ><h4 id="健康-亚健康卡片图"><a href="#健康-亚健康卡片图" class="headerlink" title="健康&#x2F;亚健康卡片图"></a>健康&#x2F;亚健康卡片图</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/76da257a-ef3e-45d3-dee1-88faa473b400/public"                      width = "600"                ><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c1d1eca4-a4d3-4b16-6b0b-38f65a435200/public"                      width = "600"                ><h4 id="中国交通主要城市健康榜标题"><a href="#中国交通主要城市健康榜标题" class="headerlink" title="中国交通主要城市健康榜标题"></a>中国交通主要城市健康榜标题</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a7af0769-1620-48cf-f884-ed305eb50500/public"                      width = "600"                >]]></content>
    
    
    <summary type="html">Power Query的认识操作，可视化图表创建</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="可视化" scheme="https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="Power BI" scheme="https://www.yiuhangblog.com/tags/Power-BI/"/>
    
    <category term="Power Query" scheme="https://www.yiuhangblog.com/tags/Power-Query/"/>
    
  </entry>
  
  <entry>
    <title>商务智能基础(Power BI)</title>
    <link href="https://www.yiuhangblog.com/2020/09/15/20200915PowerBI%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.yiuhangblog.com/2020/09/15/20200915PowerBI%E5%9F%BA%E7%A1%80/</id>
    <published>2020-09-15T12:21:39.000Z</published>
    <updated>2024-02-28T10:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="商务智能"><a href="#商务智能" class="headerlink" title="商务智能"></a>商务智能</h2><p>BI也叫商务智能，是一种主要由数据仓库、数据分析、查询报表、数据可视化等组成的数据类技术解决方案</p><p>商务智能BI可以实现业务流程和业务数据的规范化、流程化、标准化，打通ERP、OA、CRM等不同业务信息系统，整合纳企业数据，利用数据可视化满足企业不同人群对数据查询、分析和探索的需求，从而为管理和业务提供数据依据和决策支持。</p><p>将商业智能BI核心内容进行总结，大致有三大特征:</p><ol><li>一套完整的由数据仓库、查询报表、数据分析等组成的数据类技术解决方案</li><li>将企业中不同系统(ERP、OA)中的数据打通并进行有效的整合:</li><li>利用合适的查询和分析工具快速准确地提供报表，为企业提供决策支持。</li></ol><h3 id="BI的由来"><a href="#BI的由来" class="headerlink" title="BI的由来"></a>BI的由来</h3><p>BI是信息化，数字化的增长，以及社会和商业对数据的依赖</p><h3 id="BI的定义"><a href="#BI的定义" class="headerlink" title="BI的定义"></a>BI的定义</h3><p>一类由数据仓库（或数据集市）、查询报表、数据分析、数据挖掘、数据备份和恢复等部分组成的、以帮助企业决策为目的的技术及其应用。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/debc5e30-cb63-40ae-c720-9a5cf3c3a600/public"                      width = "600"                ><h3 id="Power-BI-概念"><a href="#Power-BI-概念" class="headerlink" title="Power BI 概念"></a>Power BI 概念</h3><p>Power BI是微软官方推出的可视化数据探索和交互式报告工具。</p><p>PowerBI是一款强大的可视化软件，它可以轻松的连接到数百个数据源，简化数据并可视化重要数据信息，生成美观的报表并进行发布，供组织在 Web和移动设备上使用。每个人都可创建个性化仪表板，获取针对其业务的全方位独特见解。简单来说就是可以从各种数据源中提取数据并对数据进行整理分析，然后生成精美的图表并且可以在电脑端和移动端与他人共享的一个神器。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0f6b42ed-37fd-447f-b4a9-a33d27d3fe00/public"                      width = "600"                ><h3 id="Power-BI-组成"><a href="#Power-BI-组成" class="headerlink" title="Power BI 组成"></a>Power BI 组成</h3><ul><li>Power BI 包括多个协同工作的元素，从以下三个基本元素开始：</li><li>Power BI Desktop （报表端） Wdinows 桌面应用程序 进行数据处理大屏可视化制作。</li><li>Power BI 服务（服务端）是一个包含软件服务、应用和连接器的集合。 Power BI 服务有时被称为 Power BI Online ，它是 Power BI 的服务型软件 (SaaS) 的部分，类似于一个网页，有了账号我们在Power BI Desktop 上做的就可以发布到我们的网页上去，相当于分了<br>一块内存，你就可以在我的上面做一些发布，存储。然后就可以发布到浏览器上进行协同和交互。</li><li>Power BI 移动端 适用于Windows，ios和Android设备的</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7c4046a2-b6f7-4877-80ca-bbadb9babf00/public"                      width = "600"                ><p>可视化效果（或视觉对象）是数据的可视化表示形式，如图表、颜色编码图，或其他可以创建并用来直观呈现数据的有趣形式。 Power BI 提供各种类型的可视化效果，而且随时会新增一些可视化效果。下图显示了在 Power BI 中创建的不同可视化效果的集合</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a7024011-e824-4208-98a1-d79c9cee5300/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/237739e4-6fa4-4c2e-f4fc-ef1d98610b00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/30580493-44ce-4d06-7706-3bdf0325a300/public"                      width = "600"                ><h3 id="Power-BI-流程"><a href="#Power-BI-流程" class="headerlink" title="Power BI 流程"></a>Power BI 流程</h3><h4 id="连接到数据"><a href="#连接到数据" class="headerlink" title="连接到数据"></a>连接到数据</h4><p>要开始使用 Power BI Desktop，第一步为连接到数据。 可从 Power BI Desktop 连接到多个不同数据源。<br>连接到数据：在“开始”功能区，选择“获取数据”&gt;“更多” 。<br>此时将显示“获取数据”窗口，其中显示了 Power BI Desktop 可连接到的多个类别。</p><h4 id="转换和清理数据、创建模型"><a href="#转换和清理数据、创建模型" class="headerlink" title="转换和清理数据、创建模型"></a>转换和清理数据、创建模型</h4><p>在 Power BI Desktop 中，可以使用内置 power query编辑器 清理并转换数据。 使用 Power Query 编辑器可以对数据进行更改，如更改数据类型、删除列或合并来自多个源的数据</p><h4 id="创建视觉对象"><a href="#创建视觉对象" class="headerlink" title="创建视觉对象"></a>创建视觉对象</h4><p>拥有数据模型后，即可将字段拖动到报表画布上以创建视觉对象 。 视觉对象是模型中的数据的图形表示形式。 可以在 Power BI Desktop 中选择多个不同类型的视觉对象</p><h4 id="创建报表"><a href="#创建报表" class="headerlink" title="创建报表"></a>创建报表</h4><p>即创建视觉对象集合，这些视觉对象可显示已用于在 Power BI Desktop 中创建模型的数据的各个方面。 一个 Power BI Desktop 文件中的视觉对象集合称为“报表”。 报表可以有一个或多个页面组成。</p><h3 id="Power-BI-界面认识"><a href="#Power-BI-界面认识" class="headerlink" title="Power BI 界面认识"></a>Power BI 界面认识</h3><h4 id="界面认识"><a href="#界面认识" class="headerlink" title="界面认识"></a>界面认识</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>主页：主要是获取数据</p><ul><li>报表：创建报表和视觉对象，大部分创建时间都花费在这里。</li><li>数据：查看与报表关联的数据模型中使用的表、度量值和其他数据，并转换数据以便在报表的模型中充分利用。</li><li>模型：查看和管理数据模型中各表之间的关系。</li></ul><p>插入：主要是用于布局</p><p>建模：新建度量值，新建列，新建表是最常用的视</p><p>视图：图面美化</p><p>优化：字面理解</p><p>帮助：字面理解</p><h5 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h5><p>报表视图：可进行图表制作</p><p>表格视图：可以进行数据处理，表和表字段查看，新建列，新建度量值等操作。</p><p>模型视图：可以进行表之间的关联关系查看与连接。</p><h5 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h5><ol><li><p>从Execl导入</p><p>本地Execl数据导入</p></li><li><p>获取数据</p><p>支持多源化数据导入，本地，web，sql等上百个数据源接入</p></li></ol><h4 id="矩阵表操作"><a href="#矩阵表操作" class="headerlink" title="矩阵表操作"></a>矩阵表操作</h4><ol><li><p>数据导入</p><p>点击加载：进入到数据可视化页面</p><p>点击转换数据：进入到数据清洗页面（Power Query）</p></li><li><p>点击矩阵表添加</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bb28d60f-a954-45b4-e882-f0565a6f4b00/public"                      width = "600"                ><h5 id="设置视觉对象格式"><a href="#设置视觉对象格式" class="headerlink" title="设置视觉对象格式"></a>设置视觉对象格式</h5><p>数据源：00</p><ol><li><p>值：调节字体大小</p></li><li><p>列标题：默认会把列加大</p></li><li><p>行标题：默认会把行加大</p></li><li><p>搜索框：输入 + 显示开启或关闭+</p></li><li><p>搜索框：输入大小，调节正规边框的大小， 高最大为 720，宽最大为1260，</p></li><li><p>调节的是矩阵图的大小，内容不会随这图的大小而变化。</p></li><li><p>列小计： 每一列小计，默认是打开的</p></li><li><p>行小计：每一行小计，默认是打开的</p></li><li><p>列总计：与列小计一体的，列小计关闭默认也会关闭</p></li><li><p>行总计：与行小计一体的，行小计关闭默认也会关闭</p></li><li><p>隐藏行：筛选器里面进行筛选</p></li><li><p>隐藏列：筛选器里面进行筛选</p></li><li><p>数据条：美化</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/368d3698-b574-406b-1f8a-e9a7d5d94600/public"                      width = "600"                ><h5 id="设置筛选"><a href="#设置筛选" class="headerlink" title="设置筛选"></a>设置筛选</h5><p>点击筛选器，点开需要筛选的视觉对象，即可筛选</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2211ba63-1a90-4143-041b-729b00868800/public"                      width = "600"                ><h4 id="运算符与新建列"><a href="#运算符与新建列" class="headerlink" title="运算符与新建列"></a>运算符与新建列</h4><h5 id="认识运算符"><a href="#认识运算符" class="headerlink" title="认识运算符"></a>认识运算符</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/94117f94-842f-4512-0ed8-3c75921dd200/public"                      width = "600"                ><h6 id="新建列"><a href="#新建列" class="headerlink" title="新建列"></a>新建列</h6><p>数据源：01.02.04</p><p>新增列：英文的 ‘ 号 或 [ 都可以新增列进行计算 效果是相同的</p><p><code>新列 = &#39;销售表&#39;[销售数量]*10</code></p><p><code>新列2 = [销售数量]*10</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0993d10e-9bd4-4307-52cd-d1ce127b8300/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/53ea63b2-d808-43a3-f3e1-f90358c19000/public"                      width = "600"                ><p><strong>实际操作</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4dff613f-0349-4e5d-9cbf-826ea8726600/public"                      width = "600"                ><h6 id="场景思考"><a href="#场景思考" class="headerlink" title="场景思考"></a>场景思考</h6><p>什么时候用 ‘ 带表名 什么时候用[ 不带表名</p><p>一张表操作时可以不用带表名，多张表操作时要带上表名</p><h6 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h6><p>新建列的时候，当另一个需要计算的列来自其他表的时候，一定要指明表明是什么</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d85c0ca0-02f2-4ba0-1380-92662c035d00/public"                      width = "600"                ><h6 id="计算销售成本"><a href="#计算销售成本" class="headerlink" title="计算销售成本"></a>计算销售成本</h6><p>两个表之间的操作，先进行表与表之间的关联，在模型视图进行，拖动品名到销售表即可</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/19206cce-f9bb-45ae-4a0c-062a9708df00/public"                      width = "600"                ><p>关系函数 Related：从其他的表（关联表）中返回值</p><p><code>销售成本 = &#39;销售表&#39;[销售数量]*RELATED(&#39;商品表&#39;[进价])</code></p><h4 id="建模与关系函数"><a href="#建模与关系函数" class="headerlink" title="建模与关系函数"></a>建模与关系函数</h4><ol><li>一对多关系</li><li>传递方向 向下筛选 向上索取</li><li>多端可以向一端索取，一端可以控制传递方向相同的多端数据</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5e64d8b6-5f23-41ea-a58b-5b033b3dca00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b7a60c6a-2f0e-4e34-887e-b9b1b57fab00/public"                      width = "600"                ><h5 id="Lookupvalue函数："><a href="#Lookupvalue函数：" class="headerlink" title="Lookupvalue函数："></a>Lookupvalue函数：</h5><p>语法：Lookupvalue（把那张表的那个列拿过来，找那张表上的谁？，找自己表里的谁？）把别人表里的字段V到自己表里</p><p><code>单价 = LOOKUPVALUE(&#39;商品表&#39;[进价],&#39;商品表&#39;[品名],&#39;销售表&#39;[商品名称])</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/017584bb-8e41-4b9f-355f-7ca88b939600/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/13cd84e1-73ed-4606-1a78-4342e964c100/public"                      width = "600"                ><h4 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h4><p>表工具里新建度量值</p><p>度量值在创建好之后可以在任意的环境中去使用。去执行不同的计算，也可以拖入图表。</p><h5 id="新建度量值（计算一列的值）"><a href="#新建度量值（计算一列的值）" class="headerlink" title="新建度量值（计算一列的值）"></a>新建度量值（计算一列的值）</h5><p><code>销售总量 = SUM(&#39;销售表&#39;[销售数量])</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9b4dab4c-6d39-44eb-e5c4-c76d6180f600/public"                      width = "600"                ><p>在报表视图使用任意图表如（卡片图）进行展示</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f725c53e-4259-4ed5-0d0c-e8473169b800/public"                      width = "600"                ><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>数据源：超市销售明细表</p><h5 id="求和：SUM-‘表’-字段"><a href="#求和：SUM-‘表’-字段" class="headerlink" title="求和：SUM(‘表’[字段])"></a>求和：SUM(‘表’[字段])</h5><p><code>销售额求和 = SUM(&#39;超市销售明细表&#39;[销售额])</code></p><h5 id="求平均：AVERAGE-‘表’-字段"><a href="#求平均：AVERAGE-‘表’-字段" class="headerlink" title="求平均：AVERAGE(‘表’[字段])"></a>求平均：AVERAGE(‘表’[字段])</h5><p><code>成本额平均值 = AVERAGE(&#39;超市销售明细表&#39;[成本额])</code></p><h5 id="最大值：MAX-‘表’-字段"><a href="#最大值：MAX-‘表’-字段" class="headerlink" title="最大值：MAX(‘表’[字段])"></a>最大值：MAX(‘表’[字段])</h5><p><code>销售额最大值 = MAX(&#39;超市销售明细表&#39;[销售额])</code></p><h5 id="最小值：MIN-‘表’-字段"><a href="#最小值：MIN-‘表’-字段" class="headerlink" title="最小值：MIN(‘表’[字段])"></a>最小值：MIN(‘表’[字段])</h5><p><code>销售额最小值 = MIN(&#39;超市销售明细表&#39;[销售额])</code></p><h5 id="记录数：Count（’表’）"><a href="#记录数：Count（’表’）" class="headerlink" title="记录数：Count（’表’）"></a>记录数：Count（’表’）</h5><p><code>记录数 = COUNTROWS(&#39;超市销售明细表&#39;)</code></p><h5 id="去重计数：DISTINCTCOUNT-‘表’-字段"><a href="#去重计数：DISTINCTCOUNT-‘表’-字段" class="headerlink" title="去重计数：DISTINCTCOUNT(‘表’[字段])"></a>去重计数：DISTINCTCOUNT(‘表’[字段])</h5><p><code>去重计数 = DISTINCTCOUNT(&#39;超市销售明细表&#39;[省份])</code></p><h4 id="条件判断函数"><a href="#条件判断函数" class="headerlink" title="条件判断函数"></a>条件判断函数</h4><p>数据源：12</p><p><code>销售成本 = &#39;例1&#39;[销售数量]*&#39;例1&#39;[单价]</code></p><p>text类型不能进行数值计算 会全部报错。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5ebc7cd6-e929-4464-6e12-ed98f7a5af00/public"                      width = "600"                ><h5 id="IFERROR-遇到错误时使用指定数值替换"><a href="#IFERROR-遇到错误时使用指定数值替换" class="headerlink" title="IFERROR 遇到错误时使用指定数值替换"></a>IFERROR 遇到错误时使用指定数值替换</h5><p><code>销售金额 = IFERROR(&#39;例1&#39;[销售数量] *&#39;例1&#39;[单价],BLANK())</code></p><p>BLANK()返回空</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7217674a-4931-40ee-8608-e899ae706600/public"                      width = "600"                ><p>也可以返回数字，但无法返回字符串</p><p><code>销售金额 = IFERROR(&#39;例1&#39;[销售数量] *&#39;例1&#39;[单价],123)</code></p><p>这样返回的就是123， 只能返回数值</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f8555eca-fe56-45a5-acb3-81e35b025900/public"                      width = "600"                ><h5 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h5><p>简单的条件判断</p><p><code>称呼 = IF(&#39;Sheet1&#39;[性别] =&quot;男&quot;,&quot;先生&quot;,&quot;女生&quot;)</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/288bfcf6-e96f-48b9-afcb-44aedc34e900/public"                      width = "600"                ><p><code>称呼 = IF(&#39;例2&#39;[性别]=&quot;男&quot;,&quot;先生&quot;)</code><br>女士不写，返回也可以是空值，也可以输入数字。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/85d64e01-006f-4c95-9d2f-f2aa5613cf00/public"                      width = "600"                ><p>复杂一点的if条件判断</p><p><code>间隔 = IF([取款日期]=BLANK(),BLANK(),[取款日期]-[存款日期])</code></p><p>如果 值 等于 什么 那么我们就返回 什么 返回。。。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/162774d3-f174-4a5a-30cf-19d054a2b800/public"                      width = "600"                ><h5 id="switch多项条件判断"><a href="#switch多项条件判断" class="headerlink" title="switch多项条件判断"></a>switch多项条件判断</h5><p>适用于多条件判断</p><div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SWITCH</span>(</span><br><span class="line">    [<span class="type">Expression</span>],</span><br><span class="line">    [<span class="type">Value1</span>], [<span class="type">Result1</span>],</span><br><span class="line">    [<span class="type">Value2</span>], [<span class="type">Result2</span>],</span><br><span class="line">    ...</span><br><span class="line">    [<span class="type">ValueN</span>], [<span class="type">ResultN</span>],</span><br><span class="line">    [<span class="type">DefaultResult</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><ol><li><strong>Expression</strong>: 这是你将评估的表达式。通常情况下，这是一个列名称或者一个能够计算得到单一值的表达式。</li><li><strong>Value1, Value2, …, ValueN</strong>: 这些是你将会检查的值。这些值将会与 <code>[Expression]</code> 比较。</li><li><strong>Result1, Result2, …, ResultN</strong>: 对应于每个 <code>Value</code>，当 <code>[Expression]</code> 与 <code>Value</code> 匹配时返回的结果。</li><li><strong>DefaultResult</strong>（可选）: 如果没有任何 <code>Value</code> 与 <code>[Expression]</code> 匹配，将返回此结果。如果省略此参数，且没有匹配项，<code>SWITCH</code> 将返回空值。</li></ol><p><code>月份 = SWITCH(&#39;例3&#39;[月],1,&quot;一月&quot;,2,&quot;二月&quot;,3,&quot;三月&quot;,4,&quot;四月&quot;,5,&quot;五月&quot;,6,&quot;六月&quot;,7,&quot;七月&quot;,8,&quot;八月&quot;,9,&quot;九月&quot;,10,&quot;十月&quot;,11,&quot;十一月&quot;,12,&quot;十二月&quot;,&quot;无法识别&quot;)</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a95c0854-5e1b-4afd-20c8-def5970d2f00/public"                      width = "600"                ><h5 id="switch特殊用法"><a href="#switch特殊用法" class="headerlink" title="switch特殊用法"></a>switch特殊用法</h5><p>在 Power BI 的 <code>SWITCH</code> 函数中，使用 <code>TRUE()</code> 作为表达式可以让你基于一系列的条件判断来返回不同的结果。这种方法在需要基于多个不同列或更复杂的逻辑条件进行判断时非常有用。</p><div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SWITCH</span>(</span><br><span class="line">    TRUE(),</span><br><span class="line">    [<span class="type">Condition1</span>], [<span class="type">Result1</span>],</span><br><span class="line">    [<span class="type">Condition2</span>], [<span class="type">Result2</span>],</span><br><span class="line">    ...</span><br><span class="line">    [<span class="type">ConditionN</span>], [<span class="type">ResultN</span>],</span><br><span class="line">    [<span class="type">DefaultResult</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>这里的每个 <code>[ConditionN]</code> 是一个返回布尔值（真或假）的表达式。如果该表达式的结果为真（TRUE），则 <code>SWITCH</code> 函数将返回对应的 <code>[ResultN]</code>。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6ba504af-2d6b-4f40-c98b-6e35cce1e400/public"                      width = "600"                ><p><code>年龄段 = SWITCH(TRUE(),&#39;例4&#39;[年龄]&lt;30,&quot;30岁以下&quot;,&#39;例4&#39;[年龄]&lt;40,&quot;30-40岁&quot;,&#39;例4&#39;[年龄]&lt;50,&quot;40-50岁&quot;,&quot;50岁以上&quot;)</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/159a4374-30d2-4c8e-ad8d-0f8adaff0700/public"                      width = "600"                >]]></content>
    
    
    <summary type="html">商务智能基础介绍，PowerBI基础界面与操作介绍</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="可视化" scheme="https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="函数" scheme="https://www.yiuhangblog.com/tags/%E5%87%BD%E6%95%B0/"/>
    
    <category term="Power BI" scheme="https://www.yiuhangblog.com/tags/Power-BI/"/>
    
  </entry>
  
  <entry>
    <title>用户画像</title>
    <link href="https://www.yiuhangblog.com/2020/08/29/20200829%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    <id>https://www.yiuhangblog.com/2020/08/29/20200829%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/</id>
    <published>2020-08-29T08:15:36.000Z</published>
    <updated>2024-02-29T13:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是用户画像"><a href="#什么是用户画像" class="headerlink" title="什么是用户画像"></a>什么是用户画像</h2><p>用户画像是一种在数据分析和市场营销中常用的工具，它通过收集和分析用户数据来创建一个或一组虚拟的典型用户代表。这些数据通常包括但不限于用户的基本信息（如年龄、性别、地域），以及更具体的行为特征（如购买习惯、兴趣爱好、互联网使用习惯等）。用户画像的建立，旨在帮助企业更好地理解其目标客户群，以便为他们提供更加个性化、精准的服务或产品。</p><p>用户画像的核心在于给用户打上易于理解和分析的标签，这些标签既包括基础的人口统计信息，也包括用户的行为特征和偏好。这种通过标签化来描述用户的方法，可以帮助企业从大量的用户数据中，快速抽象和识别出关键的用户特征和需求。</p><p>例如，如果一个用户经常在某直播平台购买彩妆产品，该平台可能会根据用户的购买记录给其打上“女性”、“价格敏感”和“忠实用户”等标签。通过分析这些标签，平台能够推断出用户的一系列特征，如消费能力和可能的年龄范围。这些信息进一步帮助平台为用户提供更为精准的商品推荐，提高营销效率和用户满意度。</p><p>用户画像的应用非常广泛，从提高广告和营销活动的效果，到优化产品设计和服务，再到增强用户体验和满意度，都有其重要作用。通过精确的用户画像，企业能够更有效地定位目标市场，实现精准营销，从而在竞争激烈的市场环境中脱颖而出。</p><h2 id="用户画像的作用"><a href="#用户画像的作用" class="headerlink" title="用户画像的作用"></a>用户画像的作用</h2><p>用户画像的作用在于将分散的、非结构化的用户行为数据转化为有结构的、标签化的信息集合，从而使得这些数据能够被直接用于多种数据分析和用户模型构建的场景。用户画像通过对用户行为的细致标签化，提供了一种直观且有效的方法来理解和预测用户的需求和行为。以下是用户画像的主要作用和应用场景的详细解析：</p><ol><li><p><strong>精准营销</strong>：用户画像使得企业能够将广泛的用户群体细分成具有特定需求和特征的小群体或个体，从而实现更加个性化的营销策略。通过了解用户的具体偏好和需求，企业可以通过短信、电子邮件、社交媒体等渠道进行更为精准的营销活动，大大提高营销效率和效果。</p></li><li><p><strong>数据分析</strong>：用户画像为数据分析提供了丰富的基础数据。通过分析不同用户画像群体的属性和行为特征，企业可以洞察到各个用户群体的分布特征、偏好差异和潜在需求，为产品开发、市场策略调整提供数据支持。</p></li><li><p><strong>产品应用</strong>：用户标签构成了许多数据产品的基础，尤其是个性化推荐系统和客户关系管理（CRM）的搭建。通过对用户的精确标签化，产品可以提供更为个性化的内容、服务或产品推荐，增强用户体验和满意度。</p></li><li><p><strong>数据挖掘</strong>：用户画像是构建推荐系统、搜索引擎、广告投放系统等复杂数据挖掘应用的基础。它们依赖于精细的用户画像来提高服务的精准度和个性化水平，包括但不限于提升广告的投放效果、优化内容推荐的相关性、调整产品的市场定位等。</p></li></ol><p>综上所述，用户画像的建立和应用对于现代企业尤其是互联网公司来说，是实现用户理解、产品优化、市场营销精准化的关键工具。通过有效的用户画像管理，企业不仅能够提高其产品和服务的市场竞争力，还能够更好地满足用户的个性化需求，从而在激烈的市场竞争中占据有利地位。</p><h2 id="用户画像搭建需要具备的条件"><a href="#用户画像搭建需要具备的条件" class="headerlink" title="用户画像搭建需要具备的条件"></a>用户画像搭建需要具备的条件</h2><p>构建用户画像是一个涉及多维度信息收集和分析的复杂过程，旨在通过标签化用户信息来抽象出用户的全貌。这个过程不仅有助于企业更深入地了解其用户群体，还能够为提供更加个性化的服务和产品决策提供支持。下面详细解释用户画像构建过程中涉及的各个维度：</p><ol><li><p><strong>基本属性</strong>：</p><ul><li>基本属性包括用户的社会属性和一些变动频率较低的平台特征，如年龄、性别、教育背景、地理位置等。</li><li>这些信息通常通过用户注册、填写资料等直接方式获取，无需复杂的统计或算法挖掘。</li></ul></li><li><p><strong>平台属性</strong>：</p><ul><li>平台属性反映用户在特定平台上的行为特征，例如用户的活跃度、偏好的内容类型、使用频率等。</li><li>这类属性通过分析用户的在线行为和交互模式，利用算法进行挖掘和标识。</li></ul></li><li><p><strong>行为属性</strong>：</p><ul><li>行为属性记录了用户在平台上的具体操作，包括浏览、点击、购买等单点行为。</li><li>通过这些行为数据，可以进一步分析用户的兴趣点、购买习惯和活跃时间段等。</li></ul></li><li><p><strong>产品偏好</strong>：</p><ul><li>产品偏好描述了用户对某些产品或服务的喜好程度，这不仅包括自家的产品，也可能涵盖竞争对手的产品。</li><li>这类偏好可以通过用户的购买历史、浏览记录和反馈来进行挖掘和分析。</li></ul></li><li><p><strong>兴趣偏好</strong>：</p><ul><li>兴趣偏好是通过深入分析用户与产品或内容之间的交互来描绘的，它涵盖了品牌偏好、类目偏好和具体的标签偏好等。</li><li>了解用户的兴趣偏好对于个性化推荐和精准营销至关重要。</li></ul></li><li><p><strong>敏感度</strong>：</p><ul><li>敏感度指的是用户对于平台活动或优惠的反应程度，如对热点事件、折扣和促销活动的敏感度。</li><li>识别用户的敏感度有助于调整营销策略和提升用户参与度。</li></ul></li></ol><p>通过将这些维度的信息进行有效统计和分析，企业能够构建出全面而深入的用户画像。这不仅有助于精准定位目标用户群，还能够基于用户的具体需求和偏好来优化产品设计、调整营销策略、提高用户满意度和忠诚度。用户画像的建立和应用，是现代企业深化用户理解、提升业务效能的重要手段。</p><h2 id="如何构建用户画像"><a href="#如何构建用户画像" class="headerlink" title="如何构建用户画像"></a>如何构建用户画像</h2><p>从实际操作角度出发，构建用户画像主要包括数据源分析、目标分析、数据建模等步骤。</p><h3 id="数据源分析"><a href="#数据源分析" class="headerlink" title="数据源分析"></a>数据源分析</h3><p>数据是构建用户画像的核心，它不仅支撑着用户画像的建立和优化，还确保了画像的客观性和说服力。用户画像的数据来源可以从宏观和微观两个层面来理解，每个层面提供了不同视角的数据支持，共同构成了用户画像的全貌。</p><h4 id="宏观维度"><a href="#宏观维度" class="headerlink" title="宏观维度"></a>宏观维度</h4><p>宏观维度的数据主要来源于更广泛的行业和市场层面，涉及的范围比较广，可以为用户画像提供一个宽阔的背景和基础。具体包括：</p><ul><li><strong>行业数据</strong>：涉及整个行业的趋势、发展方向、用户需求变化等信息，有助于了解用户画像在更大范围内的位置和变化。</li><li><strong>用户总体数据</strong>：包含用户群体的整体特征、偏好和行为模式，如人口统计学特征、整体购买力、品牌偏好等。</li><li><strong>总体浏览数据</strong>：反映用户群体在整个平台或行业内的浏览行为和内容偏好，提供用户兴趣点和关注领域的宏观视图。</li><li><strong>总体内容数据</strong>：包括用户群体消费内容的种类、频率和偏好等，有助于理解哪些内容类型最能吸引目标用户群体。</li></ul><h4 id="微观维度"><a href="#微观维度" class="headerlink" title="微观维度"></a>微观维度</h4><p>微观维度的数据更加聚焦于个体用户，提供细致的用户行为和特征分析，是构建精准用户画像不可或缺的部分。具体包括：</p><ul><li><strong>用户属性数据</strong>：个体用户的基础信息，如年龄、性别、职业、地理位置等。</li><li><strong>用户行为数据</strong>：记录了用户的具体操作和行为，如点击、浏览、购买、反馈等。</li><li><strong>用户成长数据</strong>：跟踪用户在平台上的成长轨迹，包括用户等级、活跃度的变化、成长速度等。</li><li><strong>访问深度</strong>：衡量用户对平台内容的深度探索，如页面访问深度、停留时间等。</li><li><strong>模块化数据</strong>：分析用户对不同平台模块的使用偏好和频率。</li><li><strong>用户参与度数据</strong>：用户对平台活动、内容互动的参与程度，如评论、分享、点赞等。</li><li><strong>用户点击数据</strong>：用户在平台上点击行为的记录，可用于分析用户的即时兴趣和偏好。</li></ul><p>结合宏观和微观两个层面的数据，可以全面地构建出用户画像，不仅能够反映用户的基本属性和行为特征，还能够洞察用户的潜在需求和偏好变化。这种基于数据的用户画像建立方法，为企业提供了精准营销、产品优化和服务改进的重要依据，是现代企业深入理解用户、提升竞争力的关键工具。</p><h3 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h3><p>用户画像构建的目的在于深入理解用户的需求、偏好和行为模式，以便实现更有效的用户服务、产品设计和市场营销。用户画像的应用目的不同，会影响到构建过程中参考元素的侧重点和设计的标签体系，从而确保用户画像能够有效地支持特定的业务目标。以下是关于用户画像构建目的和应用的详细解析：</p><h4 id="用户画像构建的目的"><a href="#用户画像构建的目的" class="headerlink" title="用户画像构建的目的"></a>用户画像构建的目的</h4><ol><li><p><strong>实现精准营销</strong>：通过精确了解用户的特征和需求，企业可以设计更为针对性的营销策略，提高营销活动的转化率和效率，从而增加产品销量。</p></li><li><p><strong>改进产品和提升用户体验</strong>：通过分析用户画像，企业能够发现产品设计中的不足，以及用户体验的潜在提升点，进而对产品进行优化，满足用户的实际需求。</p></li></ol><h4 id="用户画像的应用目的影响"><a href="#用户画像的应用目的影响" class="headerlink" title="用户画像的应用目的影响"></a>用户画像的应用目的影响</h4><ul><li><strong>参考元素的侧重差异</strong>：针对精准营销的用户画像可能更加关注用户的消费习惯和购买能力，而针对产品改进的用户画像则可能更加关注用户的使用行为和体验反馈。</li><li><strong>标签体系的设计差异</strong>：根据用户画像的应用目的，设计的标签体系会有所不同，以确保标签能够有效地支持特定的业务需求。例如，针对营销的用户画像可能包含更多与消费偏好相关的标签，而针对产品改进的用户画像则可能包含更多与用户互动和反馈相关的标签。</li></ul><p>用户画像的细化和应用</p><ul><li><strong>基础数据的梳理</strong>：完成用户画像构建的第一步是梳理和整合可用的基础数据，这些数据包括用户的基本属性、行为数据、偏好信息等。</li><li><strong>精细化处理</strong>：根据业务目标和标准，对不同维度的用户数据进行精细化处理，将用户拆分成不同的群组和标签，以实现用户的细分。</li><li><strong>标签与权重</strong>：为每个用户打上反映其兴趣、偏好、需求的标签，并分配相应的权重。权重反映了用户对某一内容的兴趣或需求程度，有助于进一步精确营销和个性化推荐。</li></ul><p>用户画像的构建和应用是一个动态调整和持续优化的过程，随着市场环境的变化和用户需求的发展，企业需要不断地更新和细化用户画像，以确保其能够有效支持企业的业务目标和用户服务。通过精细化的用户画像，企业不仅能够更好地理解和服务现有用户，还能够发现潜在用户群体，为企业的长期发展提供坚实的数据支持。</p><h3 id="数据建模方法"><a href="#数据建模方法" class="headerlink" title="数据建模方法"></a>数据建模方法</h3><p>数据建模对于构建用户画像来说是至关重要的步骤，因为它提供了一种系统化的方法来组织和解释用户数据。以下是基于事件模型概述的用户画像数据建模方法：</p><h4 id="1-用户标识"><a href="#1-用户标识" class="headerlink" title="1. 用户标识"></a>1. 用户标识</h4><ul><li><strong>目的</strong>：确保每个用户都能被唯一识别，从而实现单点定位和用户行为的精确追踪。</li><li><strong>应用</strong>：使用用户ID、邮箱、手机号码或任何其他唯一标识符来区分每个用户。</li></ul><h4 id="2-时间"><a href="#2-时间" class="headerlink" title="2. 时间"></a>2. 时间</h4><ul><li><strong>时间戳</strong>：记录用户行为发生的具体时间点，有助于分析用户行为的时间分布和模式。</li><li><strong>时间长度</strong>：衡量用户在特定页面或应用中的停留时间，这可以反映用户对内容的兴趣程度。</li></ul><h4 id="3-地点（用户接触点）"><a href="#3-地点（用户接触点）" class="headerlink" title="3. 地点（用户接触点）"></a>3. 地点（用户接触点）</h4><ul><li><strong>网址</strong>：用户访问的页面URL，不仅限于PC端，也包括移动端的应用页面，如社交媒体、电商网站等。</li><li><strong>内容</strong>：用户在特定网址访问的内容，如文章、产品信息等。内容的性质决定了用户的兴趣和偏好。</li></ul><h4 id="4-事件（用户行为类型）"><a href="#4-事件（用户行为类型）" class="headerlink" title="4. 事件（用户行为类型）"></a>4. 事件（用户行为类型）</h4><ul><li><strong>行为类型</strong>：用户的具体操作，如浏览、搜索、添加购物车、购买、评论、点赞、收藏等。</li><li><strong>应用</strong>：通过分析不同类型的用户行为，可以洞察用户的需求、兴趣和偏好。</li></ul><h4 id="数据模型公式"><a href="#数据模型公式" class="headerlink" title="数据模型公式"></a>数据模型公式</h4><p>[用户标识 + 时间(时间戳 + 时间长度) + 地点(网址 + 内容) + 事件(行为类型)]</p><h4 id="标签打上的逻辑"><a href="#标签打上的逻辑" class="headerlink" title="标签打上的逻辑"></a>标签打上的逻辑</h4><p>基于上述模型，可以根据用户的行为在特定时间、特定地点进行的特定事件来为用户打上相应的标签。这些标签反映了用户的兴趣、偏好和需求，为后续的个性化推荐、精准营销和产品优化提供了基础。</p><h4 id="实施建模"><a href="#实施建模" class="headerlink" title="实施建模"></a>实施建模</h4><p>在实施数据建模时，需要采集和处理大量的用户数据，包括但不限于用户的浏览历史、交互行为和反馈。数据清洗和处理是此阶段的关键任务，以确保数据质量和模型的准确性。随后，通过应用数据分析和挖掘技术，如机器学习算法，可以从这些数据中提取有价值的洞察，形成精细化的用户画像。</p><p>通过这种方法构建的用户画像，不仅能够为企业提供深入的用户洞察，还能够支持更加个性化和精准的用户服务和营销策略，最终提升用户满意度和企业竞争力。</p><h3 id="标签体系构建"><a href="#标签体系构建" class="headerlink" title="标签体系构建"></a>标签体系构建</h3><p>graph TD<br>    A[阶段效果] –&gt; B[静态数据标签]<br>    A –&gt; C[动态数据标签]</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    原始数据 --&gt; 静态数据</span><br><span class="line">    静态数据 --&gt; 人口属性</span><br><span class="line">    人口属性 --&gt; 性别</span><br><span class="line">    人口属性 --&gt; 年龄</span><br><span class="line">    人口属性 --&gt; 身材</span><br><span class="line">    静态数据 --&gt; 社会属性</span><br><span class="line">    社会属性 --&gt; 职业</span><br><span class="line">    社会属性 --&gt; 地域</span><br><span class="line">    社会属性 --&gt; 婚姻情况</span><br><span class="line">    静态数据 --&gt; 商业属性</span><br><span class="line">    商业属性 --&gt; 消费等级</span><br><span class="line">    商业属性 --&gt; 消费周期</span><br><span class="line">    商业属性 --&gt; 消费占比</span><br><span class="line"></span><br><span class="line">    原始数据 --&gt; 动态数据</span><br><span class="line">    动态数据 --&gt; 行为数据</span><br><span class="line">    行为数据 --&gt; 访问或启动次数</span><br><span class="line">    行为数据 --&gt; 访问时长</span><br><span class="line">    行为数据 --&gt; 浏览路径</span><br><span class="line">    动态数据 --&gt; 偏好数据</span><br><span class="line">    偏好数据 --&gt; 使用App或Web</span><br><span class="line">    偏好数据 --&gt; 访问时间</span><br><span class="line">    偏好数据 --&gt; 浏览或收藏内容</span><br><span class="line">    动态数据 --&gt; 交易数据</span><br><span class="line">    交易数据 --&gt; 贡献率</span><br><span class="line">    交易数据 --&gt; 客单价</span><br><span class="line">    交易数据 --&gt; 回购率</span><br></pre></td></tr></table></figure></div><p>标签体系构建是用户画像创建过程中的核心环节，涉及对用户信息的全面收集和深入分析，以形成有助于企业深入理解用户的结构化信息框架。这个过程通常涵盖了从基础数据梳理到动态数据分析的全方位工作，旨在通过不同维度的数据标签化，实现对用户行为和特征的精细描述。以下是标签体系构建的详细解析：</p><h4 id="建模数据"><a href="#建模数据" class="headerlink" title="建模数据"></a>建模数据</h4><p>建模数据是构建用户画像的基础，包括用户的行为、交易记录、社交互动等数据。这些数据通过分析和挖掘，能够提供用户行为模式、偏好和需求的洞察。</p><h5 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a>静态数据</h5><p>静态数据提供了用户的基础框架和背景信息，主要包括：</p><ul><li><strong>人口属性</strong>：性别、年龄等基本信息，这些是用户画像的基础标签，通常不需要复杂的数据建模。</li><li><strong>社会属性</strong>：地址、职业、婚姻状况等信息，反映用户的社会地位和生活背景。</li><li><strong>商业属性</strong>：消费等级、消费周期、消费占比等，揭示用户的消费能力和习惯。</li></ul><h5 id="动态数据"><a href="#动态数据" class="headerlink" title="动态数据"></a>动态数据</h5><p>动态数据关注用户的行为和活动，包括：</p><ul><li><strong>行为数据</strong>：浏览时间、浏览路径等，反映用户的兴趣和行为习惯。</li><li><strong>偏好数据</strong>：使用终端、浏览内容、日常爱好、购物偏好等，揭示用户的个性化需求。</li><li><strong>交易数据</strong>：贡献率、客单价、复购率等，体现用户的消费价值和忠诚度。</li></ul><h4 id="用户画像分类"><a href="#用户画像分类" class="headerlink" title="用户画像分类"></a>用户画像分类</h4><p>用户画像的分类基于静态和动态数据的结合，可以分为：</p><ul><li><strong>静态用户信息标签和2D用户画像</strong>：基于人口属性、社会属性和商业属性的用户画像，为企业提供用户的基本框架和背景。</li><li><strong>动态用户信息标签和3D用户画像</strong>：在2D画像的基础上增加了用户行为这一维度，通过分析用户的实际行为数据（如浏览、评论、购买等）来进行更深入的用户分析，实现活跃与不活跃用户的区分，以及对用户偏好和需求的更准确预测。</li></ul><p>通过这样的标签体系构建，企业可以形成一个立体、动态的用户画像，不仅包括用户的基本信息和社会属性，还包括用户的行为模式和偏好。这使得企业能够更精准地进行市场定位、产品推荐、个性化营销和服务优化，最终提升用户满意度和企业的市场竞争力。</p><h3 id="绘制用户画像"><a href="#绘制用户画像" class="headerlink" title="绘制用户画像"></a>绘制用户画像</h3><p>您上传的图片包含了用户画像构建方法的信息，根据您的描述，可以概括为以下几个步骤：</p><h3 id="定性与定量结合的研究方法"><a href="#定性与定量结合的研究方法" class="headerlink" title="定性与定量结合的研究方法"></a>定性与定量结合的研究方法</h3><ol><li><p><strong>定性的方法</strong>：</p><ul><li>首先通过定性分析，对产品、行为和用户个体的性质及特征进行概括，形成对应的产品标签、行为标签和用户标签。</li></ul></li><li><p><strong>定量的方法</strong>：</p><ul><li>基于定性分析的结果，对每个标签打上一定的权重。然后利用数学公式，将权重化的标签综合起来，计算得出总的标签权重，从而形成一个最终的用户画像模型。</li></ul></li><li><p><strong>数据建模—给标签加上权重</strong>：</p><ul><li>在确定标签之后，需要给每个标签分配一个权重，这个过程要根据用户行为数据和用户属性等相关信息来进行。</li><li>例如，在用户购买行为中，近期购买某品牌手机的用户与仅浏览该品牌手机的用户相比，对于品牌忠诚度的体现不同，因此它们的权重应该有所区别。</li></ul></li><li><p><strong>用户画像的建立方法</strong>：</p><ul><li>根据用户信息的获取和分析方法的不同，可以分为：<br>a. <strong>定性用户画像</strong>：主要基于定性分析，如用户访谈、焦点小组讨论等。<br>b. <strong>定性画像+定量验证</strong>：先进行定性分析形成初步画像，再通过定量方法验证和调整。<br>c. <strong>定量用户画像</strong>：主要依赖于数据和算法模型，通过分析用户行为数据构建画像。</li></ul></li></ol><p>这三种方法在实际应用中可以相互补充，定性分析能够提供深入的用户洞察和直观的标签构想，而定量分析则为这些标签提供了可量化的度量和验证手段。在构建用户画像时，通常需要结合这两种方法来提高画像的准确性和可操作性。</p><table><thead><tr><th align="left">方法</th><th align="left">步骤</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">定性用户画像</td><td align="left">1. 定性研究：访谈<br />2. 细分用户群<br />3. 建立细分群体的用户画像</td><td align="left">省时省离，简单，需要专业人员少</td><td align="left">缺少数据支持和验证</td></tr><tr><td align="left">定性画像+定量验证</td><td align="left">1. 定性研究：访谈<br />2. 细分用户群体<br />3. 定量验证细分群体<br />4. 建立细分群体的用户画像</td><td align="left">有一定的定量验证工作</td><td align="left">工作量较大成本较高</td></tr><tr><td align="left">定量用户画像</td><td align="left">1. 定性研究<br />2. 多个细分假说<br />3. 通过定量收集细分数据<br />4. 基于统计的聚类分析细分用户<br />5. 建立细分群体的用户画像</td><td align="left">有充分的佐证，更加科学</td><td align="left">工作量较大成本较高</td></tr></tbody></table><h2 id="用户画像的具体应用案例"><a href="#用户画像的具体应用案例" class="headerlink" title="用户画像的具体应用案例"></a>用户画像的具体应用案例</h2><p>用户画像的构建和应用是现代营销策略中不可或缺的一部分，它帮助品牌深入理解用户需求和偏好，实现精准定位和个性化营销。以下是具体的应用案例，展示了用户画像如何在实际操作中发挥作用。</p><h3 id="快消品牌案例：广告投放和私域运营"><a href="#快消品牌案例：广告投放和私域运营" class="headerlink" title="快消品牌案例：广告投放和私域运营"></a>快消品牌案例：广告投放和私域运营</h3><p><strong>背景</strong>：<br>某日化快消品牌在年终活动期间希望通过公域广告投放快速推广新产品。品牌通过分析用户画像，将历史购买用户基于购买意向度进行分层，并进一步根据用户活跃度将其分为“活跃期”、“沉睡期”和“沉默期”，实施差异化的销售策略。</p><p><strong>应用</strong>：</p><ul><li><strong>用户画像分析</strong>：通过用户画像洞察客户的购买品类、购买习惯、补货周期和近期浏览加购等信息。</li><li><strong>精准营销</strong>：基于用户画像信息为消费者推送相应的内容和产品，以满足他们的需求并促进购买。</li><li><strong>个性化体验</strong>：用户在线上购物时获得满足，易于找到适合自己的产品，增强对品牌的好感。</li></ul><p><strong>效果</strong>：</p><ul><li>活动期间销售额提升近20%。</li><li>会员的季度唤醒率显著提高。</li></ul><h3 id="应用策略和效果分析"><a href="#应用策略和效果分析" class="headerlink" title="应用策略和效果分析"></a>应用策略和效果分析</h3><p>这个案例展示了用户画像在快消品牌营销中的具体应用，通过精细化的用户分层和个性化的内容推送，品牌能够更有效地触达目标用户，提升用户参与度和购买转化率。用户画像的应用不仅限于广告投放，还包括产品推荐、内容定制等多个方面，能够全方位地提升用户体验和品牌忠诚度。</p><p>此外，用户画像还支持品牌进行有效的新品推广。通过分析目标用户群体的行为、属性和购买情况，品牌可以精准匹配并锁定潜在的意向人群，为新品上市创造有利条件。通过小范围的市场测试和用户反馈收集，品牌可以快速调整营销策略，进一步优化产品和服务，实现持续的业务增长。</p><p>这些案例凸显了用户画像在现代营销中的重要性，它使品牌能够在竞争激烈的市场环境中更加精准地定位目标用户，提供更加个性化的服务和产品，从而实现销售增长和品牌价值提升。</p>]]></content>
    
    
    <summary type="html">用户画像的概念，分析和流程</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="思路" scheme="https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"/>
    
    <category term="用户画像" scheme="https://www.yiuhangblog.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>业务目标</title>
    <link href="https://www.yiuhangblog.com/2020/08/25/20200825%E4%B8%9A%E5%8A%A1%E7%9B%AE%E6%A0%87/"/>
    <id>https://www.yiuhangblog.com/2020/08/25/20200825%E4%B8%9A%E5%8A%A1%E7%9B%AE%E6%A0%87/</id>
    <published>2020-08-25T12:21:39.000Z</published>
    <updated>2024-02-28T10:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对业务目标的理解"><a href="#对业务目标的理解" class="headerlink" title="对业务目标的理解"></a>对业务目标的理解</h2><h3 id="业务目标由谁制定"><a href="#业务目标由谁制定" class="headerlink" title="业务目标由谁制定"></a>业务目标由谁制定</h3><p>在互联网公司里，事业部中的商分团队，负责经营分析方向的同学协助业务线的负责人及核心 管理层，需要根据行业的增长空间，对比外部竞争对手的目前状态，历史过往的经营数据，以及年趋 势的增长性，及季节因素等，结合全年可支配的销售预算、营销费用预算，及市场投放的广告费用预 算等等，综合给出预估的未来一年的增长性。在这个目标的测算过程中可能和核心管理层多次沟通， 然后多次调整。目的是为了在此过程里对分项目，分渠道，分团队的各方向目标都能够做到可实现， 可落地，但并非躺赢。</p><h3 id="业务目标有什么作用"><a href="#业务目标有什么作用" class="headerlink" title="业务目标有什么作用"></a>业务目标有什么作用</h3><p>目标，可以是定性的，也可以是粗定量的，也可以是细定量的。在企业的发展过程中，处于探索期或 者快速成长期的目标，往往一开始是由核心管理者的行业背景经验快速”拍”出来的，目标可能是一个 模糊的授意。那么就需要在执行过程里，将所有的目标变成可实现的，可衡量的具象化指标。另外， 企业发展到成熟期的，已经对市场环境、竞争对手和自身的发展规划相对清晰，制定目标已经成为了 工作流中很重要的一环。</p><h2 id="业务目标如何制定"><a href="#业务目标如何制定" class="headerlink" title="业务目标如何制定"></a>业务目标如何制定</h2><h3 id="业务目标的制定方法"><a href="#业务目标的制定方法" class="headerlink" title="业务目标的制定方法"></a>业务目标的制定方法</h3><p>目标，就是对什么该做什么不该做的直观定义，并非一个数字，制定过程需符合SMAR T原则。目的就是为了判断阶段里所做的事情是否围绕目标服务，团队是否共同协作为了此目标努力。对于很多企业 来说，市场规模&amp;保证营收，都是企业非常关注且非常重要的目标。不管是规模指标还是营收指标， 前提都是完成一定的交易量级，交易额。</p><h4 id="制定目标需考虑的因素"><a href="#制定目标需考虑的因素" class="headerlink" title="制定目标需考虑的因素"></a>制定目标需考虑的因素</h4><ul><li>市场规模数据：通常来自于权威的行研分析报告，主要来自宏观的一些国家政策、人均可支配收入，在历史的发展上人均在这个行业上产生的GDP等等数据，拟合增长曲线后给出的市场规模数据。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cc282ef0-4649-45c7-262d-7ae12d073000/public"                      width = "600"                ><ul><li>线上化率预估：互联网公司中，很多运营操作其实就是讲消费者消费行为从线下引导到线上的动作，比如观影，从walkin到影院大厅购票到在网上自助购买，到大厅自助打票的过程。相对流 程简单，容易抽象的行业线上化率相对较高，一些行业内部的分散性高，或从业人员的学历低， 流程相对复杂个性化高的部分等等都会制约线上化率的发展，通常这类数据也来自于行研分析报 告。根据国家政策，例如5G,智能手机等等的普及，行业的历史发展的线上化率曲线，拟合线 上化率。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b6f1e363-297d-412c-2ba1-10fd4c166200/public"                      width = "600"                ><ul><li>市占水平：来自经营数据，或者财报数据。另外也可以从企业自身用户规模量级和转化效率佐证 这一数据是否合理.</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6c030f43-4dfb-4f6b-7bc7-fae8ed75d600/public"                      width = "300"                ><ul><li>历史同期交易额增长：比如制定今年3月目标，会参考去年3月相对前年3月的增长情况，但对于 很多新生企业来说，没有这么久的历史数据，那么可以转而参考去年3月相对去年2月的增长情况。</li></ul><p>​举例：<br>​2020年3月GMV预估&#x3D;2019年3月GMV *（1 +2019年3月&#x2F;2018年3月的YOY）<br>​2020年 3 月 GMV 预估&#x3D;2020年 2 月 GMV *（1 +2019年 3 月 &#x2F;2019 年2 月的YOY）</p><ul><li>交易商家数：商家单门店产出每月变化较小，会从供给角度校验下大数是否合理。但如果企业自身现在目前在市场的供给覆盖情况还不足，此项数据可参考性就需要再衡量。</li></ul><p>​公式：2020年GMV预估&#x3D;20年市场规模预估 * 20年线上化率预估 * 20年自身占比规模 * 调整系数</p><p>​&#x3D; 19年交易量* （ 1+19年YOY ）<br>​&#x3D; 20年用户量级预估*转化效率<br>​&#x3D; 在线营业商家量*单商家贡献</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a696ee18-d006-469a-dfe7-faa5f007f000/public"                      width = "600"                ><h4 id="直接影响交易额增长的客观因素"><a href="#直接影响交易额增长的客观因素" class="headerlink" title="直接影响交易额增长的客观因素"></a>直接影响交易额增长的客观因素</h4><ul><li>天气：例如雷雨、台风等</li><li>温度：不同温度区间对消费需求的刺激情况，一般情况下，高温（超过35°C）或低温（低于0°C）会随 着恶劣程度对需求量正向&#x2F;负向刺激</li><li>节假日：区分放假的节假日和不放假的节假日，且不同节假日的影响效果不同</li><li>周末：周末普遍需求上涨</li><li>补贴力度：不同补贴力度和活动类型对用户的刺激影响程度不同</li></ul><h3 id="业务目标的调整"><a href="#业务目标的调整" class="headerlink" title="业务目标的调整"></a>业务目标的调整</h3><p>通常来说，目标制定出来后，可以在原先的基础上进行调整，但是不会推翻目标重来。为什么呢？对于很多企业，目标就是价值和成果的象征，是凝聚团队成员朝一个方向去共同努力的风向标。频繁的 变更目标，会导致团队整体的方向感出现严重的问题，无法协作，无法形成凝聚力。</p><p>以下条件下可以进行目标的调整:</p><ul><li>不可抗力。<ul><li>举例：今年从春节左右开始的疫情，对于很多企业都是受到了发展的限制。</li></ul></li><li>主要的客观条件、或者支持因素发生变化。<ul><li>举例：国民出行意愿降低，地方政策管控聚集类场所阶段的不营业。</li></ul></li><li>企业的战略方向调整。<ul><li>举例：作为高优孵化的业务方向，调整为低优或限制发展。</li></ul></li></ul><h2 id="业务目标如何拆解"><a href="#业务目标如何拆解" class="headerlink" title="业务目标如何拆解"></a>业务目标如何拆解</h2><p>基于刚才提到的目标拆解的意义，需要开始着手进行分拆的事项。以下有几种常见的拆解方式，是基 于团队的之间的分工方式不同，而进行的流水线拆分，或者横向拆分的方法。也或者在项目中或者特 定的时间点需要将两者进行结合。</p><h3 id="对达成的过程指标进行分拆"><a href="#对达成的过程指标进行分拆" class="headerlink" title="对达成的过程指标进行分拆"></a>对达成的过程指标进行分拆</h3><p>主要是面向的大家负责的是不同的职能范围。比如面向C端产运团队的同学，根据公式交易额&#x3D;UV * 转化率 * 单uv价格。里面基本三个过程指标都是变量的情况下，逐一确认变量。知晓各团队所扛的指标分别是多少。</p><p>举例：</p><p>预估2019年8月交易额需要达到1000W，已知单UV贡献的价格基本在150元左右。里面存在UV和转化率两个变量。</p><p>(1) 给出2018年8月环比7月的转化率水平，再根据2019年7月的转化率水平得知是否可保持对应的 增长性。得知2019年8月的转化率目标需达到31.49%。</p><table><thead><tr><th>年</th><th>月</th><th>转化率</th></tr></thead><tbody><tr><td>2018</td><td>7</td><td>27.60%</td></tr><tr><td>2018</td><td>8</td><td>30.50%</td></tr><tr><td>2019</td><td>7</td><td>28.50%</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bc8fd1f6-5d41-4778-a9e1-c79303606c00/public"                      width = "600"                ><p>(2) 根据推算出来的转化率指标推算流量&#x3D;交易额&#x2F;单UV价格&#x2F;转化率&#x3D;211676</p><p>结论：</p><p>负责引流团队要保障引流动作带来用户在21.16W左右，同时负责补贴团队需要通过补贴手段保障转化率水平在31.49%左右。</p><h3 id="按照品类-区域进行分拆"><a href="#按照品类-区域进行分拆" class="headerlink" title="按照品类&#x2F;区域进行分拆"></a>按照品类&#x2F;区域进行分拆</h3><p>这种情况通常来说，是大家面向的同样的工作范畴，但是可能负责的具体的产品范围或者地域范围不同。比如面向商拓团队的时候，这种情况非常常见，要从大区、区域、城市、个人，这样逐层拆解。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8cb76624-b3bd-4825-d029-ea33e77b4300/public"                      width = "600"                ><p>拆分逻辑：<br>按照品类A+品类日&#x3D;总交易额的思路，先对目标进行分拆。</p><p>方案一：品类A的19年8月目标&#x3D;品类A的18年完成值 *【1+ (19年7月-18年7月)&#x2F;18年7月】 *</p><p>方案二：大区A的19年8月目标&#x3D;品类A的19年8月目标 *大区A占比。大区A占比，参考19年7月的各大区的占比情况</p><h3 id="按照项目进行分拆"><a href="#按照项目进行分拆" class="headerlink" title="按照项目进行分拆"></a>按照项目进行分拆</h3><p>在企业的实际工作开展过程中，会针对在拓展获客渠道，捕捉时下热点，保障供给能力等方面分别发 起一些独立的项目，这些独立的项目可能是面向部分渠道，面向部分的产品。所以针对这类项目需要 单独进行目标的制定，目标不一定是以结果指标作为最终考核指标，也可能会以项目需要达成的导向 以过程指标作为目标。</p><p>举例：<br>在时下疫情阶段，为了深化供给侧的合作深度，决定发起一个项目，去谈合作紧密型的优质商家，并且在C端页面给予一定的流量扶持。要给出该项目的项目目标。</p><p>首先在制定目标前要考虑，这个项目的目标是为了得到什么结果，面向供给侧，是为了在阶段里拿下更多优质商家，面向用户侧是为了流量做倾斜处理。</p><p>所以，需要先进行一拨数据摸底。明确优质商家的定性和定量的指标到底是什么。经过和业务侧的反复沟通，确认如下指标为衡量优质商家的标准。</p><ul><li>独家供给：对比其他竞对网站独家覆盖</li><li>库存率高：在线库存量&#x2F;物理库存量＞&#x3D;70%</li><li>绝对低价：对比其他竞对网站价格低</li><li>拒单退款水平低：对比其他同类商家拒单水平低，退款水平低</li></ul><p>通过调取2019年7月的这些指标，得到了优质商家的覆盖量级在1.5w家左右。而现在站上根据用户主动搜索主动点评的这类明星商家大概有10w家左右，</p><p>根据测算商家所处的省份，城市信息，确定各地可跟进的量级。大区A需要跟进4w家，大区B需要跟进3w家，大区C需要跟进1.5w家。</p><p>按照各区的人员比例，确认一个商拓人员一周可以跟进的量级约在4家。大区A有200人，在8月约可以跟进3200家，大区B有100人约可以跟进1600家，大区C有100人约可以跟进1600家。</p><p>再根据商家一个月可以自主报名的比例约在20%,约可以完成2w家。</p><p>因此2019年8月优质商家覆盖的目标约为2.64W家。需要完成独家供给、库存率高、绝对价低，拒单 退款水平低的要求。</p><p>流量扶持的目标则在引流和转化两个方向展开。</p><h3 id="按照特定时间点进行分拆"><a href="#按照特定时间点进行分拆" class="headerlink" title="按照特定时间点进行分拆"></a>按照特定时间点进行分拆</h3><p>依据各行业的淡旺季情况的不同，对于旺季的特定时点往往会依据过去的历次时点的峰值水平，由核心管理层直接发起一个定性的峰值目标。例如在双十一天猫要冲破x百亿。</p><p>分析师这时候需要做的是，首先确认特定时点的起止时间点。例如旅游行业的十一出行，确认是2019年9月30日-2019年10月7日，还是其他的时间点。</p><p>按照时间点分拆分日目标，首先先要对用户出行的峰值时间进行预估，确认哪天是最容易达到峰值的。像今年的十一，十一当日肯定是出行的高峰时间，用户前后借假休的概率偏低，没有前后的周六 日。另外根据机票、火车票等用户的出行时间，都可以锁定，用户的出行时间。</p><p>确认峰值时间点后，根据历次特定时点带来的用户量级和转化效率看，距离峰值目标的实际差距。通常情况下，企业内有大量的AB实验，确认各手段对于转化率的提升的作用。补贴到达一定水平后，其实转化率会趋于到一个顶峰值不再波动。</p><p>根据峰值时间的交易量目标反推。交易量目标&#x3D;引流用户量级转化效率人均可产生的交易额</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>销售的业绩指标，分析师在每月中下旬开始做下月的预估，地面团队需要在每月20号给到下月明确的交易量目标；电销团队时间节奏基本保持一致。两团队逻辑保持基本一致。</p><h3 id="具体计算逻辑"><a href="#具体计算逻辑" class="headerlink" title="具体计算逻辑"></a>具体计算逻辑</h3><h4 id="整体目标确定"><a href="#整体目标确定" class="headerlink" title="整体目标确定"></a>整体目标确定</h4><p>按照大盘下个月的目标，一般是交易额&#x2F;GMV ，计算出下个单的交易量目标</p><p>业务线大盘2020的5月的交易额目标 11亿元 ，计算出交易量： 11亿&#x2F;120(客单价) * 80%(消费 人群) &#x3D;733万</p><h4 id="分别确定地面和电销的整体目标"><a href="#分别确定地面和电销的整体目标" class="headerlink" title="分别确定地面和电销的整体目标"></a>分别确定地面和电销的整体目标</h4><p>计算逻辑一般是按照地面团队的180个城市和电销团队负责的2000县城在过去一个月或者一个季度全部消费间夜量在酒店夜住大盘的占比来确定。</p><p>地面团队历史交易占比70% ，电销团队是30% ，根据交易量占比拆分，5月份的交易量 &#x3D; 733万 + 0.7 &#x3D; 513万 ， 电销交易量 &#x3D; 733万 * 0.3 &#x3D; 220万</p><h4 id="分拆地面和电销的分城市-分区县目标"><a href="#分拆地面和电销的分城市-分区县目标" class="headerlink" title="分拆地面和电销的分城市&amp;分区县目标"></a>分拆地面和电销的分城市&amp;分区县目标</h4><p>地面团队：根据YOY ，拆分城市的各自数据</p><p>电销团队：根据MOM，拆分区县的数据</p><h4 id="调整目标"><a href="#调整目标" class="headerlink" title="调整目标"></a>调整目标</h4><p>可控：</p><ul><li><p>地面团队：对于分城市的YOY异常高的数据，可以参考上个月的实际完成值(大盘的本月目标 &#x2F; 上个月完成值)</p></li><li><p>电销团队 ：对于分区县的MOM异常，可以参考上个月的实际完成 值（大盘 的本月目标&#x2F;上个月完成值）</p></li></ul><p>不可控：</p><ul><li>疫情、节假日出现、企业的战略方向(调整为低或者限制发展)、国民出行意愿低、天气温度等</li></ul>]]></content>
    
    
    <summary type="html">业务目标的概念，拆解和调整</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="思路" scheme="https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"/>
    
    <category term="业务目标" scheme="https://www.yiuhangblog.com/tags/%E4%B8%9A%E5%8A%A1%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>数据分析方法与流程</title>
    <link href="https://www.yiuhangblog.com/2020/08/15/20200815%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <id>https://www.yiuhangblog.com/2020/08/15/20200815%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</id>
    <published>2020-08-15T07:56:21.000Z</published>
    <updated>2024-02-28T10:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h2><p>在数据分析中，分析方法是指用于从数据中提取有用信息和洞察的技术和流程。这些方法可以根据数据类型、分析目标和所需的洞察类型而有所不同。以下是一些常见的数据分析方法：</p><ol><li><strong>描述性分析（Descriptive Analysis）</strong>:<ul><li>目的：描述和总结数据集的特征。</li><li>方法：使用统计指标（如平均值、中位数、众数）、数据可视化（如条形图、饼图、直方图）等。</li></ul></li><li><strong>诊断性分析（Diagnostic Analysis）</strong>:<ul><li>目的：探究数据背后的原因和关系。</li><li>方法：寻找变量间的相关性和因果关系，使用例如回归分析、相关性分析等。</li></ul></li><li><strong>预测性分析（Predictive Analysis）</strong>:<ul><li>目的：基于历史数据预测未来事件。</li><li>方法：使用统计模型和机器学习算法，如线性回归、时间序列分析、随机森林等。</li></ul></li><li><strong>规范性分析（Prescriptive Analysis）</strong>:<ul><li>目的：提出基于数据分析的行动建议。</li><li>方法：运用优化和仿真技术，结合预测性分析结果提供决策支持。</li></ul></li><li><strong>探索性数据分析（Exploratory Data Analysis, EDA）</strong>:<ul><li>目的：探索数据集以发现模式、异常、趋势等。</li><li>方法：使用各种统计图表和数据可视化技术，进行初步的数据探索。</li></ul></li><li><strong>机器学习和人工智能（Machine Learning and AI）</strong>:<ul><li>目的：利用算法自动学习和改进从数据中的洞察。</li><li>方法：包括监督学习、非监督学习、强化学习等。</li></ul></li></ol><p>每种方法都有其独特的应用场景和优势，选择哪种方法取决于具体的业务问题和数据特性。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <ol><li><strong>分析模型</strong>:<ul><li><strong>定义</strong>: 分析模型是一个框架或者结构，用来代表数据、变量之间的关系，以及这些关系如何与要研究的现象相联系。它们通常基于特定的理论或假设。</li><li><strong>举例</strong>: 如RFM模型（衡量客户价值和参与度）、AARRR模型（用户生命周期跟踪）、线性回归模型（预测数值型响应变量和解释变量之间的关系）等。</li><li><strong>特点</strong>: 分析模型通常是针对特定问题或领域设计的，如市场分析、财务预测、用户行为分析等。</li></ul></li><li><strong>分析方法</strong>:<ul><li><strong>定义</strong>: 分析方法指的是一套程序或技术，用于处理和分析数据，以提取有用信息或洞察。这些方法更多关注于“如何分析”而不是“分析什么”。</li><li><strong>举例</strong>: 如描述性统计、机器学习算法、时间序列分析、探索性数据分析（EDA）等。</li><li><strong>特点</strong>: 分析方法通常是通用的，可以应用于多种不同的数据集和问题。</li></ul></li></ol><p>简单来说，分析模型是一种针对特定问题或领域的结构或框架，而分析方法则是处理和分析数据的一套技术或程序。在实际应用中，通常会将合适的分析方法应用于特定的分析模型，以解决具体的业务问题或实现数据洞察的目标。</p>    </div>  </div><h3 id="RFM-模型"><a href="#RFM-模型" class="headerlink" title="RFM 模型"></a>RFM 模型</h3><p>RFM模型更多地与描述性和诊断性分析相关，重点在于理解和分析现有客户的行为模式</p><p>这三项数据成为了衡量客户价值和客户创利能力的重要工具和手段。也是 RFM 模型的三个重要指标：</p><ul><li><strong>Recency (最近性)</strong>: 衡量客户最后一次购买或交互的时间。越近的行为通常意味着更高的再次购买或互动的可能性。</li><li><strong>Frequency (频率)</strong>: 衡量客户在特定时间内的购买或互动次数。频率越高，表明客户越忠诚。</li><li><strong>Monetary Value (金钱价值)</strong>: 衡量客户在一段时间内为公司带来的总收入。较高的消费总额通常指示出更有价值的客户。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cca39ea9-d97a-4e89-5ea9-b4f2c6a50400/public"                      width = "600"                ><p>个指标针对的业务不同，定义也会有所不同。但是无论是什么业务，各指标都有如下的特征：</p><p>1）最近一次消费时间间隔（R）：上一次消费时间离现在越近，再次消费的几率越大。即 R 值越小，用户的活跃度越大，用户的价值就越高；</p><p>2）消费频率（F）：购买频率越高，说明用户对品牌产生一定的信任和情感维系。即 F 值越大，用户的忠诚度就越大，用户的价值就越高；</p><p>3）消费金额（M）：消费金额越高，说明用户对产品的购买力越大。即 M 值越大，用户的购买力就越大，用户的价值就越高。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/73b186c4-68f5-4dea-c503-40491f93c600/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d3982dc6-d178-485b-7486-d9b4f0e11a00/public"                      width = "600"                ><h4 id="RFM-模型的作用"><a href="#RFM-模型的作用" class="headerlink" title="RFM 模型的作用"></a>RFM 模型的作用</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/976ebe87-aaba-4aaf-05d2-7e9c976b2300/public"                      width = "600"                ><p>RFM模型的作用主要包括：</p><ul><li><strong>客户细分</strong>：帮助企业区分不同价值的客户，以便更有效地定位和沟通。</li><li><strong>个性化营销</strong>：根据客户的RFM评分，实施更有针对性的营销策略。</li><li><strong>提高客户忠诚度</strong>：识别忠诚客户，从而采取措施提高他们的满意度和留存率。</li><li><strong>预测客户行为</strong>：通过分析历史购买数据，预测客户未来的购买行为和潜在价值。</li><li><strong>资源优化分配</strong>：确保营销资源更集中地投入到最有价值的客户群体。</li></ul><p>总的来说，RFM模型是帮助企业更好地理解和服务其客户群体的强大工具。通过精准的客户细分，企业可以更有效地分配营销资源，提高客户满意度和忠诚度，从而增加收入和盈利能力。</p><h4 id="RFM-模型的构建流程"><a href="#RFM-模型的构建流程" class="headerlink" title="RFM 模型的构建流程"></a>RFM 模型的构建流程</h4><h5 id="计算-R、F、M-的值"><a href="#计算-R、F、M-的值" class="headerlink" title="计算 R、F、M 的值"></a>计算 R、F、M 的值</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6175448d-1fea-4d49-815b-ce98e1ff0400/public"                      width = "600"                ><h5 id="根据-RFM-的阈值，对用户进行分类"><a href="#根据-RFM-的阈值，对用户进行分类" class="headerlink" title="根据 RFM 的阈值，对用户进行分类"></a>根据 RFM 的阈值，对用户进行分类</h5><p>1）给 R、F、M 各值按价值划分打分区间</p><p>这里需要注意的是，我们不是按指标的数值大小打分，而是对指标的价值打分。像最近一次消费时间间隔（R），消费时间间隔最近，即 R 值越小，用户的价值越高，反之，用户的价值越低。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b15f6fec-5a1e-45fa-385c-fd5725ba3b00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a1ae1144-423c-4e64-e649-06c6153a5c00/public"                      width = "600"                ><p>2）计算价值的平均值</p><p>打完分数后，分别计算 R、F、M 各打分值的平均值，结果如下：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b022f719-a54d-4a81-e3a4-759d3c8a2700/public"                      width = "600"                ><p>3）用户分类</p><p>最后，我们将两个用户的 RFM 值与各值的平均值进行对比。</p><p>如果一行里的 R 值打分大于平均值，就标记该行的 R 值打分为“高”，反之标记为“低”。F、M 值亦是同理。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2c255ebe-92b7-4607-d38c-b3baeaad3400/public"                      width = "600"                ><p>再将标记好的 RFM 高低值与用户分类规则表进行对比，可以得出用户属于哪种类别。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e721aec3-aca4-42fa-99c2-a5aeb7ae9b00/public"                      width = "600"                ><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2cd0e89c-5e4f-42b1-c783-968c6412a300/public"                      width = "600"                >  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>划分 RFM 的“高低”值，关键是找到划分的阈值。分析目标的不同，所选择的分析方法也可能不同。上面的例子中，我们为 RFM 各值进行分区域评分，再计算各评分值的平均值来得到阈值。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/faeeee56-a466-4582-f91f-c650226ba900/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7dbb838b-b9d4-46ef-477f-120c51051600/public"                      width = "600"                >    </div>  </div><h4 id="RFM总结"><a href="#RFM总结" class="headerlink" title="RFM总结"></a>RFM总结</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f4c9dcb2-7bd8-43be-e68a-21e3e208f100/public"                      width = "600"                ><h3 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h3><p>关联分析（Association Analysis）是数据挖掘的一个重要方面，主要用于发现在大型数据集中不同项之间的有意义的关联或规律。这种分析尤其在市场篮子分析（Market Basket Analysis）中广泛应用，但其应用范围远不止于此。以下是关联分析的一些关键点：</p><ol><li><strong>核心概念</strong>:<ul><li><strong>项集（Itemset）</strong>: 数据集中的一个或多个项目的组合。</li><li><strong>支持度（Support）</strong>: 在所有事务中某个项集出现的频率。</li><li><strong>置信度（Confidence）</strong>: 一个项集的出现在另一个项集已经出现的条件下的条件概率。</li><li><strong>提升度（Lift）</strong>: 衡量两个项集的关联强度，即项集A的出现对项集B出现概率的影响。</li></ul></li><li><strong>常用算法</strong>:<ul><li><strong>Apriori算法</strong>: 一种经典的关联规则挖掘算法，通过迭代方式寻找频繁项集。</li><li><strong>FP-Growth算法</strong>: 一种有效的频繁项集挖掘方法，使用FP树结构来压缩数据集，效率高于Apriori算法。</li></ul></li><li><strong>应用实例</strong>:<ul><li><strong>市场篮子分析</strong>: 在零售业中分析哪些商品经常一起被购买。</li><li><strong>推荐系统</strong>: 根据用户过去的购买行为或喜好推荐商品或内容。</li><li><strong>交叉销售和促销策略</strong>: 确定哪些产品应该一起展示或促销。</li><li><strong>医疗数据分析</strong>: 在医疗数据中寻找疾病和症状之间的关联。</li></ul></li><li><strong>挑战</strong>:<ul><li><strong>大数据量处理</strong>: 在大数据集上进行关联分析可能非常耗时。</li><li><strong>生成规则的质量</strong>: 生成的规则数量可能非常庞大，且不是所有规则都有实际意义或价值。</li><li><strong>误解和错误的因果关系</strong>: 强关联不一定意味着因果关系。</li></ul></li></ol><p>关联分析在为商业决策提供数据支持方面发挥着重要作用，能够帮助企业更好地理解客户行为，并据此优化产品布局和营销策略。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0e8d30d0-9cf6-48f5-8036-49dbc6d3a800/public"                      width = "600"                ><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><h5 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h5><p>现在手里有一份快餐店的用户交易数据：</p><p>如图所示：用户1001用户购买了【薯条、可乐】等2类商品，用户1002用户购买了【薯条、可乐、奶茶】等3类商品，以此类推，1004用户购买了汉堡、可乐】2类商品等</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f141cb44-6e28-4391-d016-540dde79c700/public"                      width = "600"                ><p>基于这份数据，我会向快餐店老板提出建议，推出薯条和奶茶的组合套餐。因为我发现购买奶茶的用户，有很大概率会加购薯条，发现的过程如下：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9c98caef-c8ac-4e4f-7d79-b2b24ce4fe00/public"                      width = "600"                ><p>从那份只有4条数据的交易数据入手，它有点像购物小票。交易数据记录了用户的单次消费行为，即交易记录，如1001号订单，意思是某用户一次性购买了两种（非数量）食品：薯条、可乐。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2c407c14-d374-4060-0dac-653bcb865600/public"                      width = "600"                ><h5 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h5><p>而每条交易记录又可称为一个事务。所以，这份交易数据一共含有4条“事务”</p><p>即1001用户购买了【薯条、可乐】，这是一次事务；1002用户购买了【薯条、可乐、奶茶】这是两次事务，以此类推，</p><p>1004用户购买了【汉堡、可乐】这是第四次事务。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c4952b9a-a4b8-4089-dcfb-a37123e79500/public"                      width = "600"                ><h5 id="项"><a href="#项" class="headerlink" title="项"></a>项</h5><p>交易中的不同物品可称为一个项。</p><p>比如说，这4条交易记录，商品类目去重后，一共含有4个项（商品类目）：{“薯条”，“可乐”，“奶茶”，“汉堡”}</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/66ea0b33-48f3-441f-c695-016221177d00/public"                      width = "600"                ><h5 id="项集"><a href="#项集" class="headerlink" title="项集"></a>项集</h5><ul><li>0个或多个项的集合，可称为一个项集，一般用{X}的形式表示项集，k 个项组成的项集, 叫 k 项集</li><li>如{薯条，可乐},有两项，看见花括号就是集合，所以是2 项集，在比如{薯条}，有1 项，看见花括号就是集合，所以是1项集</li><li>前面的4项商品，可以相互组成15个项集，项集内不存在相同的项，如{奶茶，薯条，薯条}。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a723c3c4-520f-4dbf-1a4c-1ba41fedf500/public"                      width = "600"                ><h5 id="支持度"><a href="#支持度" class="headerlink" title="支持度"></a>支持度</h5><ul><li>{X}的支持度 &#x3D; {X}在事务中出现的次数 &#x2F; 事务总数。</li><li>事务总数在上面已经讲到，就说每条交易记录又可称为一个事务。所以，这份交易数据一共含有4条“事务”</li><li>即1001用户购买了【薯条、可乐】，这是一次事务；1002用户购买了【薯条、可乐、奶茶】这是两次事务，以此类推，</li><li>1004用户购买了【汉堡、可乐】这是第四次事务。随意X的支持度的分母&#x2F;事务总数就是4，薯条和奶茶同时出现在一块儿的购买商品</li><li>在1002的订单号里，其他的订单号没有同时出现【薯条、奶茶】的身影，所以分子&#x2F;{薯条、奶茶}出现的次数就是1，1除以4 &#x3D;1&#x2F;4等于0.25</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/454e3e2d-fe84-45c5-f7b8-b7615c1d3800/public"                      width = "600"                ><h5 id="频繁项集"><a href="#频繁项集" class="headerlink" title="频繁项集"></a>频繁项集</h5><ul><li>此时，我们需要人为地设定一个支持度，名为最小支持度，用于筛掉那些不符合需求的项集。</li><li>比如4 项集：{可乐，汉堡，奶茶，薯条}就不符合需求，比如说，给个超参数0.2，小于0.2的支持度过滤掉，大于等0.2的保留</li><li>被留下来的项集（≥ 最小支持度），被称为频繁项集。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b7957f2d-b5a1-4589-f61d-702a7c3d0a00/public"                      width = "600"                ><h5 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h5><ul><li>有了频繁项集，就可以生产关联规则了。</li><li>关联分析是探索数据之间联系的技术，而数据之间的联系，我们用关联规则来表示，表达式为：{X}→{Y}（X 和 Y 之间不存在相同项）。</li><li>X项集和Y项集之间存在哪种关联规则有顺序之分，为了方便描述，我们把规则前面的项集叫前件，把规则后面的项集叫后件。</li><li>假设有频繁项集 {奶茶，薯条}，它可以生成2条关联规则：{薯条}→{奶茶}和{奶茶}→{薯条}。前者的意思是，购买“薯条”的顾客，和购买“奶茶”之间，可能存在有某种联系；同理可得，后者的意思是，购买“奶茶”的顾客，和购买“薯条”之间，可能存在有某种联系</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0ef44d33-be25-4365-1f77-85b32c575f00/public"                      width = "600"                ><h5 id="置信度"><a href="#置信度" class="headerlink" title="置信度"></a>置信度</h5><ul><li>置信度(Confidence)可用于衡量关联规则的可靠程度，表示在前件出现的情况下，后件出现的概率。一般来说，概率越高，规则的可靠性越强。</li><li>关联规则{X}→{Y}的置信度 &#x3D; {X，Y}的支持度 &#x2F; {X}的支持度。在上边已提到，{薯条、奶茶}支持度 &#x3D; {薯条、可乐}同时出现了1次，一共有1001、1002、1003、1004等4次事务，所以{薯条、奶茶}支持度就是1&#x2F;4&#x3D;0.25,</li><li>{薯条}的支持度 &#x3D; {薯条}出现在了1001，1002，1003等3次，一共有4次事务，所以{薯条}的支持度 &#x3D;3&#x2F;4 &#x3D; 0.75</li><li>最后2者一相除约等于0.33</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8b3b8620-2abd-4ffb-4de1-e214b6b21a00/public"                      width = "600"                ><ul><li>同为关联规则，可靠程度有“强”有“弱”。</li><li>在实际业务中，也需要人为地设定置信度，名为最小置信度，用于筛掉一些不符合需求的关联规则。被留下来的关联规则（ ≥ 最小置信度），叫做强关联规则。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8dc21c17-bfe6-44d7-6d8a-054075f36700/public"                      width = "600"                ><h5 id="提升度"><a href="#提升度" class="headerlink" title="提升度"></a>提升度</h5><ul><li>关联规则既有促进关系，也有抑制关系。因而，还需引入提升度(Lift)对它们进行判断。</li><li>{X}→{Y}的提升度 &#x3D; {X}→{Y}的置信度 &#x2F; {Y}的支持度，意思是评估 X 的出现，对 Y 出现的影响有多大。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0ed64012-16b1-40fa-c2cb-3a7aee4c4e00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bb05a0fa-969f-492b-db90-3af0678d4d00/public"                      width = "600"                ><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6b340d0d-fc2e-47c4-5948-ffc4f8da0d00/public"                      width = "600"                ><p>大多数的关联分析工作，主要任务就是生成频繁项集和关联规则。有了计算公式和流程，理论上，可以手算，不过难度可想而知：</p><ul><li>一个3项（k 项）的数据集，能产生7（2^k - 1）个非空频繁项集。</li><li>一个3项（k 项）的频繁项集，可产生6（2^k - 2）个关联规则。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/625e9af9-8355-4b1b-2d06-d2c00617c500/public"                      width = "600"                ><p>随着“项”的增加，频繁项集和关联规则的计算量必将呈指数增长。</p><p>而现实生活中的“项”（商品）成百上千，真实的“事务”（交易）数以万计。。提高计算效率，可以使用Apriori 算法。</p>]]></content>
    
    
    <summary type="html">数据分析中用到的部分方法，落地流程及业务指标</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="思路" scheme="https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"/>
    
    <category term="RFM" scheme="https://www.yiuhangblog.com/tags/RFM/"/>
    
    <category term="关联分析" scheme="https://www.yiuhangblog.com/tags/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
    
    <category term="模板" scheme="https://www.yiuhangblog.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="指标拆解" scheme="https://www.yiuhangblog.com/tags/%E6%8C%87%E6%A0%87%E6%8B%86%E8%A7%A3/"/>
    
    <category term="落地流程" scheme="https://www.yiuhangblog.com/tags/%E8%90%BD%E5%9C%B0%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据分析思路模板</title>
    <link href="https://www.yiuhangblog.com/2020/07/28/20200728%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.yiuhangblog.com/2020/07/28/20200728%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E6%80%9D%E8%B7%AF/</id>
    <published>2020-07-28T01:32:16.000Z</published>
    <updated>2024-02-28T10:49:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定量"><a href="#定量" class="headerlink" title="定量"></a>定量</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4837a94c-2b23-49a3-c53f-6afde7bfae00/public"                      width = "600"                ><ol><li><strong>明确目标</strong>：这是开始任何数据分析项目的第一步。明确目标意味着确定想通过数据分析解决的具体问题或达成的具体目标。这可能包括理解特定现象、预测未来趋势、识别模式或关系等。</li><li><strong>数据处理</strong>：在这一步中，将收集相关数据并进行预处理。数据处理包括清洗（去除或纠正错误、不完整、不一致的数据）、格式化、结构化，以及可能的数据转换，以便于进一步分析。</li><li><strong>数据分析</strong>：这一阶段是定量分析的核心，涉及使用统计方法、算法、模型等对数据进行深入探究。这可能包括描述性统计分析、推理统计分析、预测建模、聚类分析等。</li><li><strong>数据展现</strong>：数据分析的结果需要以清晰、易懂的方式展现。这通常涉及数据可视化（如图表、图形、仪表板等），以及用于解释数据的文本描述。</li><li><strong>报告撰写</strong>：最后一步是撰写报告，将分析过程、结果、以及洞察呈现给相关利益相关者。报告应该包括关键发现、数据分析的方法论、结论，以及可能的建议或行动方案。</li></ol><h3 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h3><ol><li><p>在对数据进行分析之前，首先第一步便是要明确目标。</p></li><li><p>明确目标这个环节往往需要做到以下三点，分别是：</p><ul><li><p>明确分析需求</p></li><li><p>搭建分析框架</p></li><li><p>收集分析数据</p></li></ul></li><li><p>接下来结合防护服装厂案例，来了解一下在这三个环节都分别需要做些什么。</p></li><li><p>首先来学习一下如何明确分析需求。</p></li></ol>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <blockquote><p>现状和痛点这两个事都要藏在心里面不要不要直接说（写这两个的都被优化了🤣）</p></blockquote>    </div>  </div><h4 id="明确分析需求"><a href="#明确分析需求" class="headerlink" title="明确分析需求"></a>明确分析需求</h4><p>防护服装厂从 2020 年初开始售卖防护服，到 7 月初的时候，营销总监发现账目上已经开始出现亏损。总监十分焦虑，想要在短时间内快速找到亏损的原因，以及对应的解决策略。</p><p>从总监遇到的难题中不难发现，这次的任务需要解决两个问题，分别是：</p><ul><li>找到亏损原因</li><li>找出对应的解决策略</li></ul><p>在明白了这次的任务需要做什么以后，接下来就要思考如何去解决这些问题了。而要想解决问题，往往就需要搭建一个分析框架，系统地指导我们该如何去解决问题。</p><h5 id="报告制式"><a href="#报告制式" class="headerlink" title="报告制式"></a>报告制式</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93da82bc-cbb6-4a6c-b1ec-08fbbf3d3e00/public"                      width = "300"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 一、背景</span></span><br><span class="line">某某科技公司，运营了一家小型的<span class="strong">****</span>工厂，该厂经营状态过往处于不稳定的状态，在今年6月底，经营开始处于亏损状态。通过本次对该厂历史经营数据的分析，帮助公司推断该厂的发展，并对该厂的亏损问题处理提供建议。</span><br><span class="line"></span><br><span class="line"><span class="section">## 二、目的 </span></span><br><span class="line">探寻该厂的亏损问题的原因、及下一阶段的经营发展趋势，并对防护服装厂的亏损问题处理提供建议。</span><br></pre></td></tr></table></figure></div><h4 id="搭建分析框架"><a href="#搭建分析框架" class="headerlink" title="搭建分析框架"></a>搭建分析框架</h4><p>通过刚才的分析，已经知道了这次任务首先要做的就是找到防护服付账厂亏损背后的原因。</p><p>而亏损意味着利润为负，所以本质上我们要研究的是防护服装厂的利润情况。</p><p>订单量、单价、成本以及销售额都是会影响防护服付账厂利润的。</p><p>现在的问题是，即便知道了这四个因素会影响防护服付账厂的利润，接下来该如何动手去分析呢？到这里思路依旧不明朗。</p><p>尤其是这些因素，彼此之间又存在一些关联，互相影响。比如想研究订单量的变化情况，结果发现订单量对利润可能不构成直接影响。</p><h5 id="公式拆解法"><a href="#公式拆解法" class="headerlink" title="公式拆解法"></a>公式拆解法</h5><p>一种比较适合这个问题场景的方法：公式拆解法。首先来了解一下公式拆解法是什么。</p><p>公式拆解法就是利用数学公式，将会影响因变量的因素按照层级关系罗列出来。然后通过分析这些因素的变化情况，来推演因变量是如何受到这些因素影响的，如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d8e34a0f-2e7e-42cf-35f9-b400eaad0f00/public"                      width = "600"                ><p>首先从最根本的研究对象，或者说因变量开始拆解。由于防护服装厂的亏损本质上就是利润为负，那么利润就是最终想要研究的对象，放在最顶层</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3f415a79-578e-45a6-8356-5f6d8d93be00/public"                      width = "600"                ><p>在对销售额拆解完毕以后，正常情况下应该思考成本会和哪些因素有关。</p><p>不过这里有个好消息，就是之前的一位员工在计算防护服付账厂各月成本的时候，已经求得防护服付账厂在 2020 年 1 月到 6 月期间，各月成本&#x2F;工资&#x2F;投放&#x2F;房租&#x2F;水电暖几乎没有变化，成本这块儿可以忽略不计。</p><p>所以利润这个因素可以看作只受到销售额的影响，之后没有必要对成本继续拆解了。</p><p>当然，这个拆解的过程是可以不断细分下去的，但是有一点要考虑，数据的采集成本。</p><p>比如说想要继续研究订单量这个因素，我们可能会觉得这和市场的供货量有关，于是就想要去采集 2020年年初到 6 月份期间市场上防护服装厂的总产能，想通过产能的变化来分析订单量的变化原因。</p><p>防护服付账厂的订单量很有可能是被这部分”大客户“所主导的。</p><p>如果因为某些原因，“大客户”出现了比较严重的流失，那么就会对订单量产生比较大的影响。</p><p>基于这条拆解思路，可以根据公式：订单量 &#x3D; 订单量（省份1） + 订单量（省份2） + 订单量（省份3）+ …，对订单量进行进一步的拆解</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d40061d6-8560-41c0-df79-9cdb8211a200/public"                      width = "600"                ><p>到这里就已经利用公式拆解法对防护服付账厂的利润情况进行了拆解。</p><p>从搭建的模型来看，后续的分析需要用到以下四层信息：销售额、订单量、防护服付账单价、订单来源省份。</p><h5 id="报告制式-1"><a href="#报告制式-1" class="headerlink" title="报告制式"></a>报告制式</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93da82bc-cbb6-4a6c-b1ec-08fbbf3d3e00/public"                      width = "300"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 三 、分析思路</span></span><br><span class="line"><span class="section">### 3.1方法：</span></span><br><span class="line">利润 = 销售额-成本，现已知1-6月份防护服装成本是变动微小，故本次分析主要从“销售额”进行分析。</span><br><span class="line"></span><br><span class="line"><span class="section">### 3.2总方法：</span></span><br><span class="line">通过销售额及其影响因子的分析，对过往销售额变化的规律、变化原因进行剖析</span><br><span class="line"></span><br><span class="line"><span class="section">### 3.3公式：</span></span><br><span class="line">销售额 = 订单量 × 单价</span><br><span class="line">订单量 = 省份1+省份2...+省份n</span><br><span class="line"></span><br><span class="line"><span class="section">### 3.4分析框架：</span></span><br><span class="line">分析各月的“销售额”变化趋势，分析变化规律与原因。</span><br><span class="line">分析各月“订单量”的变化趋势，分析变化规律与原因。</span><br><span class="line">分析各月“单价”的变化趋势，分析变化规律与原因。</span><br><span class="line">分析各月各省份“订单量”的变化趋势，分析变化规律及原因。</span><br></pre></td></tr></table></figure></div><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7c10b1c5-4426-4b88-cb7a-2fa4e1694700/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 CSV 数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">protective_clothing = np.loadtxt(<span class="string">&#x27;mask_data.csv&#x27;</span>, dtype = <span class="built_in">str</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(protective_clothing)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e5eeba5f-9fa4-4f59-1606-82a6486f6600/public"                      width = "600"                ><p><code>numpy</code>库为读取各种文件类型的数据提供了非常简便高效的方法。</p><p><code>np.loadtxt(&#39;path&#39;, dtype , encoding )</code> 就是其中一种高效读取 csv 文件的方法.</p><p>这个方法有很多参数，这里先介绍三种最常用的：<code>path</code>，<code>dtype</code>，<code>encoding</code>。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1e64a965-e97d-496e-a40f-e6a6d734e400/public"                      width = "600"                ><p>对于参数 <code>path</code>，需要传一个文件路径给它，可以是相对路径，也可以是绝对路径。这里出于方便，就可以传一个相对路径给参数 <code>path</code>。</p><p>对于参数<code>dtype</code>，根据业务需要转换成我们想要的数据类型，在该案例中，因为数据是字符串类型，我们就要转换成<code>dtype = str</code></p><p>对于参数 <code>encoding</code>，需要传一个文件编码格式给它。文件编码格式的选取需要根据所读文件的编码格式来定。</p><p>从拆解好的思路中不难发现，需要用到的信息有：销售额、订单量、单价以及省份信息。</p><p>同时，刚才也分析过我们需要用到时间这个维度的信息，与之对应的日期这一列数据，也存在与我们的数据之中。</p><p>不过在观察各列的数据时，数据的异常情况，如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6d9c771b-fb0d-45b7-704b-80d8e8ccd400/public"                      width = "600"                ><h5 id="报告制式-2"><a href="#报告制式-2" class="headerlink" title="报告制式"></a>报告制式</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93da82bc-cbb6-4a6c-b1ec-08fbbf3d3e00/public"                      width = "300"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 四、数据来源</span></span><br><span class="line">从公司数据库中导入营销数据mask<span class="emphasis">_data.csv，原始数据一共包含101942行，数据的结构如下：</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ead85be6-6d21-46bd-d764-c765dc22e400/public"                      width = "600"                ><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/db3017a9-75e1-4ab2-c704-099bfc267600/public"                      width = "800"                ><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/42756a2d-5893-419d-59e9-cd033cf93200/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e4cedc54-5bbc-496f-ae0f-53359624e600/public"                      width = "600"                >  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <blockquote><p>数据清洗和数据处理不是一回事，数据清洗属于数据处理的一个环节</p></blockquote>    </div>  </div><h4 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7c4dceb6-8ed5-4659-ed75-bdf6f9dfbb00/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入Pandas库并将其简化为pd</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># 导入数据分析库</span></span><br><span class="line"><span class="comment"># 读取本地口罩厂的数据</span></span><br><span class="line">mask_data = pd.read_csv(<span class="string">&quot;mask_data.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(mask_data)</span><br></pre></td></tr></table></figure></div><h5 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h5><h6 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h6><p>使用<code>df.info()</code>方法查看数据集信息</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b304e470-5529-4060-7a5e-bd3bb10d0d00/public"                      width = "600"                ><p>其中，日期，省，订单量，单价，销售额这些列的非空数据都比数据总量要小，说明都有缺失值</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a11b30dc-77b5-4213-aae6-ee60cbd12700/public"                      width = "300"                ><p>在 <code>pandas</code> 库中，我们可以使用<code>isna()</code>方法来查找<code>DataFrame</code> 对象 以及 <code>Series</code> 对象中的缺失值。它可以将查找结果以 <code>DataFrame</code> 对象或者 <code>Series</code> 对象的形式进行返回。<code>df.isna()</code>返回的是 <code>DataFrame</code> 对象，<code>Series.isna()</code> 返回的就是 <code>Series</code> 对象。</p><p><code>protective_clothing.isna()</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看数据后5行</span></span><br><span class="line">protective_clothing.tail()</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d6d0270d-5d0f-4f7a-d2c7-4248965ae500/public"                      width = "600"                ><h6 id="删除缺失值"><a href="#删除缺失值" class="headerlink" title="删除缺失值"></a>删除缺失值</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有缺失值</span></span><br><span class="line"></span><br><span class="line">mask_data_na_clean = mask_data.dropna()</span><br></pre></td></tr></table></figure></div><h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5609d4bb-0cbf-4540-622c-9aae5164e800/public"                      width = "800"                ><h5 id="重复值"><a href="#重复值" class="headerlink" title="重复值"></a>重复值</h5><h6 id="处理重复值"><a href="#处理重复值" class="headerlink" title="处理重复值"></a>处理重复值</h6><p>重复值很好理解，就跟字面意思一样，指的是表格中重复出现的数据。在多数情况中，重复值都是完全相同的数据。</p><p>重复值处理的第一步和缺失值一样，还是要先查找重复值。</p><p>我们可以直接使用<code>df.duplicated()</code> （中文意思：重复的）方法来查找<code>DataFrame</code> 对象中的重复数据。</p><p>使用 <code>df.duplicated()</code> 方法会返回一个 <code>Series</code> 对象，找出所有重复值。重复为 <code>True</code>，不重复为<code>False</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找 protective_clothing 中的重复行</span></span><br><span class="line">mask_data_na_clean.duplicated()</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ad11600d-048e-4e21-a294-9589ecda4400/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 protective_clothing 中的重复数据</span></span><br><span class="line">mask_data_na_clean[mask_data_na_clean.duplicated()]</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a0d957b0-a905-4294-70e8-1d9e04cfb000/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接删除所有重复值</span></span><br><span class="line">mask_data_na_dup_clean = mask_data_na_clean.drop_duplicates()</span><br><span class="line"><span class="comment"># 查看 protective_clothing 中的重复数据</span></span><br><span class="line">mask_data_na_dup_clean[mask_data_na_dup_clean.duplicated()]</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d47d0f4e-0b0a-41ce-b966-213e04b9c700/public"                      width = "600"                ><p>在运行结果中我们能看见<code>mask_data_na_dup_clean</code>的表头下面是空的，说明到这里已经没有重复数据了。值得一提的是，<code>df.drop_duplicates()</code> 方法并不会将所有重复的行都删除。</p><h6 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h6><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6df92af1-6559-4e48-9b36-a5fc583bec00/public"                      width = "800"                ><h5 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h5><h6 id="处理异常值"><a href="#处理异常值" class="headerlink" title="处理异常值"></a>处理异常值</h6><p>有时数据中有一个或多个异常大或异常小的数值，超出了这份数据实际的限定范围，这样的数值被称为<br>异常值。</p><p>我们在数据清洗中要先对异常值进行识别，因为它有可能是一个错误的数值。</p><p>对于异常值，我们首先要做的是检查数据是否存在异常。若数据存在异常我们则需要抽取限定范围的数据，过滤异常值。</p><p><strong>检查异常值</strong></p><ul><li>检查数据是否存在异常的方法 —— <code>describe()</code>。</li><li><code>describe</code> 单词在英语里是描述的意思，而在 <code>pandas</code> 库中 <code>describe()</code> 方法则可以查看 <code>Series</code> 对象或者 <code>DataFrame</code> 对象的描述性统计信息。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 protective_clothing 的描述性统计信息</span></span><br><span class="line">mask_data_na_dup_clean.describe()</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/90228bc6-3d82-4bff-8a5e-f8cc6172d300/public"                      width = "600"                ><p>抽取数据范围，在<code>pandas</code>库中，有一种筛选数据的方法叫做布尔索引，使用<code>df[&#39;列索引&#39;]</code> 来提取某一列的信息。在 <code>pandas</code> 库中，我们还可以在 <code>df[]</code> 中通过表达式的形式来提取一定范围的数据。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看单价小于等于200的数据</span></span><br><span class="line">mask_data_na_dup_clean[mask_data_na_dup_clean[<span class="string">&#x27;单价&#x27;</span>] &lt;= <span class="number">200</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看单价小于等于200的数据</span></span><br><span class="line">mask_data_na_dup_clean[<span class="string">&#x27;单价&#x27;</span>] &lt;= <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选单价小于等于200的数据</span></span><br><span class="line">mask_data_na_dup_s200_clean = mask_data_na_dup_clean[mask_data_na_dup_clean[<span class="string">&#x27;单价&#x27;</span>] &lt;= <span class="number">200</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防护服装厂数据的描述性统计信息</span></span><br><span class="line">mask_data_na_dup_s200_clean.describe()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选订单量大于0的数据</span></span><br><span class="line">mask_data_na_dup_l0_s200_clean = mask_data_na_dup_s200_clean[mask_data_na_dup_s200_clean[<span class="string">&#x27;订单量&#x27;</span>] &gt; <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看mask_data的描述性统计信息</span></span><br><span class="line">mask_data_na_dup_l0_s200_clean.describe()</span><br><span class="line">mask_data_na_dup_l0_s200_clean.info()</span><br></pre></td></tr></table></figure></div><h6 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h6><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fea5656f-ae45-492d-204e-8c5ff3901600/public"                      width = "800"                ><h4 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h4><h5 id="转换日期数据"><a href="#转换日期数据" class="headerlink" title="转换日期数据"></a>转换日期数据</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask_data_na_dup_l0_s200_clean_date_fot = pd.to_datetime(mask_data_na_dup_l0_s200_clean[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span> = <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"><span class="comment"># 查看date_data</span></span><br><span class="line"><span class="built_in">print</span>(mask_data_na_dup_l0_s200_clean_date_fot)</span><br></pre></td></tr></table></figure></div><h6 id="提取月份信息"><a href="#提取月份信息" class="headerlink" title="提取月份信息"></a>提取月份信息</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取日期数据中的月份信息</span></span><br><span class="line">month_mask_data = mask_data_na_dup_l0_s200_clean_date_fot.dt.month</span><br><span class="line"><span class="comment"># 查看month_data</span></span><br><span class="line"><span class="built_in">print</span>(month_mask_data)</span><br></pre></td></tr></table></figure></div><h6 id="增加新列"><a href="#增加新列" class="headerlink" title="增加新列"></a>增加新列</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将月份数据添加到原数据中</span></span><br><span class="line">mask_data_na_dup_l0_s200_clean[<span class="string">&#x27;月份&#x27;</span>] = month_mask_data</span><br><span class="line"><span class="comment"># 查看原数据</span></span><br><span class="line"><span class="built_in">print</span>(mask_data_na_dup_l0_s200_clean)</span><br></pre></td></tr></table></figure></div><h6 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存清洗干净的数据，并取消写入行索引</span></span><br><span class="line">mask_data_na_dup_l0_s200_clean.to_csv(<span class="string">&#x27;mask_data.csv&#x27;</span>, index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure></div><h4 id="报告制式-3"><a href="#报告制式-3" class="headerlink" title="报告制式"></a>报告制式</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93da82bc-cbb6-4a6c-b1ec-08fbbf3d3e00/public"                      width = "300"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 五、数据处理</span></span><br><span class="line"><span class="section">### 5.1清洗数据：</span></span><br><span class="line"><span class="code">缺失值</span></span><br><span class="line"><span class="code">重复值</span></span><br><span class="line"><span class="code">异常值</span></span><br><span class="line"><span class="code">### 5.2 整理数据：</span></span><br><span class="line"><span class="code">多增加【月份】这一列，时间维度</span></span><br><span class="line"><span class="code">### 5.3 清洗结果：</span></span><br><span class="line"><span class="code">    我们对以上三种数据均进行了删除处理，其中清洗前数据一共有101942，清洗后数据一共有99485行。</span></span><br><span class="line"><span class="code">    清洗数据占比：占比2%</span></span><br><span class="line"><span class="code">    清洗前后数据量变化极小，因此可以忽略对结果的影响。</span></span><br></pre></td></tr></table></figure></div><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/137c2931-47c2-4f97-c4ad-3a5431876800/public"                      width = "800"                ><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/38a40682-6f87-4bde-8e0b-f801550d4a00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/292fcc3d-6ffa-421e-7212-c2db8eabd800/public"                      width = "600"                ><p>根据前面的分析拆解，我们知道本次分析的重点是—销售额，订单量，单价，各省订单量随着时间变化的趋势及其变化原因。</p><p>那么，我们可以通过分组聚合对每一组数据进行描述性统计分析，然后利用折线图进行变化趋势的分析。</p><p>防护服装厂的任务，需要解决总监的两个问题—找到亏损原因、找出对应的解决策略。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c36cc924-91ff-40c8-608b-15ec437f8d00/public"                      width = "600"                ><h4 id="分组聚合，统计数据"><a href="#分组聚合，统计数据" class="headerlink" title="分组聚合，统计数据"></a>分组聚合，统计数据</h4><p>本次分析的影响因素是销售额、订单量、单价、各省订单量，而且是以一个月为颗粒度，进行时间维度上的变化趋势和原因分析。</p><p>清洗后的数据<code>mask_data_clean</code>，它的列索引中包含着我们需要的销售额、订单量等数据。</p><p>以销售额为例，如果要分别查看 1 月到 6 月以来的销售额，可以根据月份对数据<code>mask_data_clean</code>进行分组。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/79394181-c2c1-4940-888f-a9829cbb3d00/public"                      width = "600"                ><p>我们可以计算出销售额的总数，因为它代表着这个月销售额的总体情况，可以通过对比它的上升或下降，查看其每月变化。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/57f0aa2a-a3e7-4666-9dcc-fcc4a0c6e700/public"                      width = "600"                ><p>首先要根据月份对数据集进行分组<code>groupby</code>，同时还需要对销售额列进行一次聚合计算，计算出销售额的总和<code>sum</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入Pandas库并将其简化为pd</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># 导入数据分析库</span></span><br><span class="line"><span class="comment"># 读取本地口罩厂的数据</span></span><br><span class="line">mask_data = pd.read_csv(<span class="string">&quot;mask_data_clean.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每月销售额总数</span></span><br><span class="line">sales_income = mask_data_clean.groupby(<span class="string">&#x27;月份&#x27;</span>)[<span class="string">&#x27;销售额&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看数据</span></span><br><span class="line">sales_income</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2f77bbb2-847f-47d1-4766-19824e1c5700/public"                      width = "600"                ><p>可以看到，打印的结果是一个 <code>Series</code> 对象，它的值是销售额的总数，行索引是月份。</p><p>根据数值已经可以大致看出，1-3 月总销售额增加， 3-6 月则在下降。基于这样的每月销售额统计数据，才能方便地进入后续趋势分析步骤中。</p><p>那么应该如何去分析其他3个影响因素呢？上一节课我们提到过公式拆解法搭建我们的分析框架和方法，销售额 &#x3D; 订单量*单价</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f2017124-0355-450e-92c9-80b26510ed00/public"                      width = "600"                ><p>根据对各月销售额的分析，我们可以总结出：不同影响因素进行分组聚合操作时，有两个要点。</p><ul><li>根据什么进行分组；</li><li>选择什么代表性的统计方法，进行聚合计算。</li></ul><p>那么对于各月订单量、各月单价、各月各省订单量，应该根据什么进行分组，应该选择什么统计性数值呢？</p><p>例如对不同班级、不同班级不同性别、不同班级不同性别是否带眼镜等等情况都是如何一一进行分组聚合的。</p><p>​比如，不同班级不同性别的分组聚合方式是这样的：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f21740ba-9442-43a2-caf3-abe54f1b6600/public"                      width = "600"                ><p>不过单价的平均值可以反映出某一商品在一定时期内的平均价格，一定程度上可以体现普遍的价格数量。因此选择平均数作为单价的统计性指标。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask_data_clean.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bd40cb75-c854-4f6e-2001-f9ffa90dad00/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取各月总订单量</span></span><br><span class="line">order_number = mask_data_clean.groupby(<span class="string">&#x27;月份&#x27;</span>)[<span class="string">&#x27;订单量&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">order_number</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7cf68e7d-764a-41e6-cb05-9aac926b0c00/public"                      width = "600"                ><p>不错，它同样能够体现出这个月所有订单量的变化情况，1-3 月数量上升，3-6 月数量下降。</p><p>接下来来看每月单价，找一下如何计算单价的平均值：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ed78cbf5-3efa-4c96-1dfb-bce15cb0b100/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取每月平均单价</span></span><br><span class="line">month_price = mask_data_clean.groupby(<span class="string">&#x27;月份&#x27;</span>)[<span class="string">&#x27;单价&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">month_price</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/69ccf146-d53d-4f0c-bfe0-834c9e55c700/public"                      width = "600"                ><p>要用列表来包含两个用于分组的索引</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取各省各月总订单量</span></span><br><span class="line">month_order = mask_data_clean.groupby([<span class="string">&#x27;省&#x27;</span>, <span class="string">&#x27;月份&#x27;</span>])[<span class="string">&#x27;订单量&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">month_order</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d08a8097-d142-4cf8-b8ea-428703955700/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取各省各月总订单量</span></span><br><span class="line">month_order_2 = mask_data_clean.groupby([<span class="string">&#x27;月份&#x27;</span>, <span class="string">&#x27;省&#x27;</span>])[<span class="string">&#x27;订单量&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">month_order_2</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c62668de-65e2-4a87-d49d-32963a01e200/public"                      width = "600"                ><p>终端打印出的 Series 数据，它的外层索引是月份，内层是省份，因此从上往下，看到的是每个月不同省的总订单量数据。</p><ul><li>通过 <code>month_order</code>，我们能大致看出某个省的总订单量随月份的变化情况；</li><li>而通过 <code>month_order_2</code> ，则可以看出某个月时不同省份总订单量的变化情况。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/55414aa5-161d-47a1-7b99-b43716cf9a00/public"                      width = "600"                ><h4 id="折线分析，确定趋势"><a href="#折线分析，确定趋势" class="headerlink" title="折线分析，确定趋势"></a>折线分析，确定趋势</h4><p>首先还是来看每月总销售额，前面我们将它存储在变量 sales_income 中，怎么画出对应的折线图</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取每月销售额总数</span></span><br><span class="line">sales_income = mask_data_clean.groupby(<span class="string">&#x27;月份&#x27;</span>)[<span class="string">&#x27;销售额&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">sales_income</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2245d3d2-e38d-435c-df11-067dae0dac00/public"                      width = "600"                ><p>这是一个Series对象，行索引是月份，值是每月总销售额。因此可以直接用 pandas 的plot()方法画图。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fac09ef5-8764-4329-2aff-2928dcaf4600/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=[<span class="string">&quot;SimHei&quot;</span>] <span class="comment">#设置字体</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span> <span class="comment">#该语句解决图像中的“-”负号的乱码问题</span></span><br><span class="line">sales_income.plot(kind = <span class="string">&#x27;line&#x27;</span>, figsize = (<span class="number">7</span>,<span class="number">7</span>) ,title = (<span class="string">&#x27;画出各月总销售额的折线图&#x27;</span>))</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/45222d41-e9bc-4bf6-9d1f-c32321afc500/public"                      width = "600"                ><p>直接使用前面的<code>Series</code>对象，就可以画出来一个以月份为横坐标，以单位数值为纵坐标，总销售额为数据点的折线图。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9d30be7b-959f-4964-366c-63997f808500/public"                      width = "600"                ><p>按理来说，画出各月总销售额的折线图之后，就可以继续去分析其统计值的变化趋势了。</p><p>但是下面我们会先把“各月订单量、单价、各省订单量”剩下 3 个折线图都画出来之后，再进入下一步的趋势分析。</p><p>因为这 4 个影响因素关系密切：订单量不变时，单价越高销售额也会越高；同理单价不变时，订单量越多销售额也会越高。</p><p>如果这些因素的变化趋势也呈现这样的某些共性，就可以综合起来进行分析，就更容易抓住关键性的影响因素，可以聚焦问题。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画出各月总订单量的折线图</span></span><br><span class="line">order_number.plot(kind = <span class="string">&#x27;line&#x27;</span>, figsize = (<span class="number">7</span>, <span class="number">7</span>), title = <span class="string">&#x27;各月总订单量趋势图&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/62852949-b864-4430-80b4-f20e8bc25700/public"                      width = "600"                ><p>可以得到以月份为横坐标，单位数值为纵坐标，平均单价为数据点的折线图，单位为元。</p><p>最后来看各省各月总订单量的变化趋势，它的特殊之处在于，需要通过多条折线图来直观体现出不同省份不同月份的区别。</p><p>前面我们将各省各月的统计数据存储在变量 <code>month_order</code>和 <code>month_order_2</code>中，它们是两个 <code>Series</code> 对象。</p><p>但是多条折线图需要基于 <code>DataFrame</code> 数据来画，因此我们需要使用 <code>unstack()</code> 方法将 <code>Series</code> 对象变为 <code>DataFrame</code> 对象。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将month_order1转换为DataFrame，存储在month_order_df中</span></span><br><span class="line">month_order_df = month_order.unstack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看month_order1_df中的数据</span></span><br><span class="line">month_order_df</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b9cac6eb-3651-460c-9e4c-bd530654b000/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据month_order_df绘制多条折线图，标题为&#x27;各月各省总订单量趋势图&#x27;</span></span><br><span class="line">month_order_df.plot(kind = <span class="string">&#x27;line&#x27;</span>, figsize = (<span class="number">7</span>, <span class="number">7</span>), title = <span class="string">&#x27;各月各省总订单量趋势图&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b8dc7259-410d-4187-328d-20c63be9ad00/public"                      width = "600"                ><p>我们画出来的是各月各省总订单量趋势图，它以不同颜色线条表示不同月份，以省份为横坐标，以数值单位为纵坐标，以订单量数值为数据点形成的折线图。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将month_order_2转换为DataFrame，存储在month_order_2_df中</span></span><br><span class="line">month_order_2_df = month_order_2.unstack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据month_order2_df绘制多条折线图，标题为&#x27;各省各月总订单量趋势图&#x27;</span></span><br><span class="line">month_order_2_df.plot(kind = <span class="string">&#x27;line&#x27;</span>,figsize = (<span class="number">7</span>, <span class="number">7</span>), title = <span class="string">&#x27;各省各月总订单量趋势图&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/92867763-7250-425e-1b46-ce3667b15100/public"                      width = "600"                ><p>现在我们已经画完了 4 个需要的折线图，接着就可以具体观察折线图，详细分析不同影响因素的变化趋势</p><p>观察折线图，有3个要点，</p><p>​一是整体的<strong>走势</strong></p><p>​二是走势的<strong>规律性</strong></p><p>​三是走势的<strong>波动</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ca4e5cc2-a223-46eb-b3d9-2a4a78e1c000/public"                      width = "600"                ><p>我们可以直接通过折线图的线条倾斜程度，看出走势波动的强烈程度，比如下图就是不同变化程度的体现.</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9394bfd4-14a0-4de8-292e-e32d9ed79d00/public"                      width = "600"                ><p>基于这三个要点，可以让我们更加全面地描述折线图的趋势特征。接下来我们整体来看一看四个影响因素随月份变化时对应的折线图。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d3454629-01f2-4cec-c44d-95821490ed00/public"                      width = "600"                ><p>可以发现无论各月的总销售额、总订单量、平均单价，以及各省在各月的总订单量，变化趋势有很大的相似性：</p><p>1）在 1 月到 3 月的折线是随着时间增长而增加，整体呈增加趋势，其中 2 月到 3 月增长快速；3 月之后整体呈下降趋势，3 月到 4 月出现了“急跌”。</p><p>2）目前的折线中未出现多个类似形状的起伏波动，未体现出任何规律性。</p><p>3）而且图中只有一处波动起伏，在这个起伏的最高点，对应着 3 月的数据，此处为最大值。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/99c1cd0b-1bc0-47e2-32ec-b76007c7da00/public"                      width = "600"                ><p>本质上，趋势是由背后的原因推动的。看趋势，更得看背后的原因，而不是单纯的看着结果走势想当然。</p><p>因此接下来的时间，我们来分析防护服装厂各项影响因素的统计值都在“走下坡路”的原因，给总监一个“交代”。</p><h4 id="原因剖析，聚焦问题"><a href="#原因剖析，聚焦问题" class="headerlink" title="原因剖析，聚焦问题"></a>原因剖析，聚焦问题</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4a99610a-ad80-4f84-acc4-7c7a3489e900/public"                      width = "600"                ><p>这里趋势变化非常明显，最大值（转折点）为 3 月，因此我们重点关注这个值，以其特殊性作为突破口。</p><p>根据订单量、单价的变化，我们可以知道，3 月之前，工厂的防护服装需求量和价格都增长猛烈，3 月之后却又出现大幅下降。</p><p>按理来说，防护服装属于医用防护品和日用生活品，不受季节、时间的影响。一般其需求源头比较稳定，物价也很稳定。</p><p>但是对比 1-3 月份总订单量的变化，其纵坐标的值是 0 到 2，但是单位是百万。因此是从 1 月份的万余盒，增长到 2 月份的 30 余万盒，突然涨到 3 月份 196 万余盒，变化迅猛。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/11314251-e088-49bd-e224-488b3b035700/public"                      width = "600"                ><p>另外通过折线图也能够发现趋势变化的强烈程度，比如 3 月到 4 月的订单量，就是一个“急跌”，订单量一下子缩水了 100 多万！</p><p>因此认为，要想在两三个月内迅速改变防护服装的供需关系，应该是属于社会性问题的外部冲击。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/39ad592c-a50b-40e4-c0ff-d6164438cc00/public"                      width = "600"                ><p>与防护服装使用的历史一致，几乎每次大的普及推广都是受传染性疾病或空气污染等外部影响。</p><p>因此这里排除业务内部原因，比如偶发性降价促销活动带来的客流量上涨与衰退，以及工厂竞争能力降低带来的市场占有率从高到低等等内部问题。</p><p>因为这些情况都属于常规运营问题，造成的影响远不会如此剧烈。</p><p>实际上，从 2020 年 1 月底开始，国内就蔓延出了新冠的传染性疾病，到了 3 月份，疫情感染人数才逐渐得到控制。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d31ca533-2cdd-424d-e969-c487fb0aff00/public"                      width = "600"                ><p>当然我们还是要结合疫情的情况，进行材料的佐证，这样才能尽量合情合理的去解释所发生的现象。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/13c9c007-da05-43f2-5db2-f66937cf0200/public"                      width = "600"                ><p>疫情最严重的时期为 2 月份，2 月初电视中还经常出现药店防护服装断供的新闻，3 月中下旬开始，全国陆续开始复工，人群流动性增加的情况下，防护服装的需求也是达到了最高点。</p><p>而且我们也可以看到，各省的订单量变化中，以湖北省的变化最为强烈，在 2020年的新冠疫情中，湖北省是重灾区，全省 5927 万人口，是非常大的需求缺口。</p><p>据说我们的工厂整个 2-3 月都在加班加点进行生产，但是防护服装的价格与销量都还是只增不降，说明需求根本无法及时得到满足。</p><p>而到 3 月之后，疫情好转，全国各地陆续放松，尤其是不再要求必须在公众场合佩戴防护服装，人们对于防护服装的需求迅速回落，一直到 6 月销量和价格都仍在下落的过程中。</p><p>可以说，2020 年 1 月到 6 月，由于新冠疫情的影响，防护服装的供需关系发生了很大的波动变化，导致工厂防护服装的订单量、价格以及整体销售额也自然随之发生变化。</p><p>但如果直接给出结论，就只是空口无凭了，做数据分析就是要能够发掘和解释其背后的逻辑。</p><h4 id="深入洞察，提出对策"><a href="#深入洞察，提出对策" class="headerlink" title="深入洞察，提出对策"></a>深入洞察，提出对策</h4><p>说到问题根源，其实还是一个供需关系，如果防护服装厂商在供需矛盾中不占优势，想要继续维持原来高价格高销量的情况几乎是不可能。</p><p>因为人们的购买标准，将从“能用”升级为性价比高、质量好、服务好等更复杂的行业竞争力问题上。</p><p>因此当疫情减少，刚性需求减少后，防护服装行业的市场竞争将会越发激烈。</p><p>1 月这段时间基本不属于疫情影响范围内，比较能够体现出日常情况下人们对于防护服装的需求。我们可以以此对比一下疫情前后，订单量和单价的情况：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b3cf835a-4a4e-4fa2-465d-7f928d722c00/public"                      width = "600"                ><p>如果这种状态下，6 月份防护服装厂是处于亏损，那么未来这段时间，防护服装厂将继续处于亏损状态。</p><p>众所周知，“比亚迪”作为一个汽车企业，由于这次生产转型，其在防护服装行业也占有了一席之地。因此，现在的情况是危机也是转机，是打开稳定市场的好机会。</p><p>基于这样的分析，跟总监提出两种不同的建议：</p><p>1)公司可以对防护服装厂进行改革，不过对于工厂的优势，改革的重点及规划，还有待进一步对产品、营销体系等情况的分析。</p><p>2)如果公司不对防护服装厂进行新的投入和改革，防护服装厂将会持续亏损，建议尽早对防护服装厂做转让处理。</p><p>当然，还有第三种方案，那就是基于国际局势考虑，目前南半球及欧美国家，由于气候及政策等原因，新冠疫情的危机是越演愈烈。<br>预计对于疫情为加重趋势的国家，防护服装的需求量仍会比较高涨。</p><p>3)如果可以及时打开国际销售渠道，并维持相对较低的成本，工厂将仍能保持供需矛盾中的优势地位，维持高单价高销量的营收情况。</p><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/21a9340f-1a9b-4ecb-d65e-8497f0582900/public"                      width = "800"                ><p>我们说整个数据分析过程就是根据分析目的，用适当的分析方法及工具，对数据进行处理和分析，提取有价值的信息，其目的是总结出所研究对象的内在规律。</p><p>在实际工作中，数据分析能够帮助管理者进行判断和决策，以便制定适当的策略与采取相应的行动。因此掌握数据分析能力对于我们的工作会有很多的帮助。</p><h3 id="数据展现"><a href="#数据展现" class="headerlink" title="数据展现"></a>数据展现</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c3059193-069c-4af4-7a32-1afef0d2a300/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6070452a-fcbb-4c4f-cdb1-cc6b16e64f00/public"                      width = "600"                ><h4 id="选对图表"><a href="#选对图表" class="headerlink" title="选对图表"></a>选对图表</h4><p>不同图表的适用场景</p><p>不同的图表一般会有不同的适用场景，我们将折线图、柱状图和饼图进行简单对比。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ef21f6b8-8ee4-48f1-5582-21c5f821df00/public"                      width = "600"                ><p>可以清晰地看到，折线图主要是呈现数据变化的趋势；柱状图让数值大小的比较更加明显；至于饼图，能够直观地显示各部分相对于整体的占比。</p><p>多条折线图兼具了折线图和柱状图的优势，能够比较多组数据在同一个维度上的趋势，比如上一节课绘制的“各省各月订单量趋势图”就是各个省份的订单量在同一个维度“月”进行的比较。</p><h4 id="明确数据展现的目标"><a href="#明确数据展现的目标" class="headerlink" title="明确数据展现的目标"></a>明确数据展现的目标</h4><h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h5><p>各月的总销售额、总订单量、平均单价以及各省在各月总订单量，都出现了1-3月迅猛增长呈增长趋势，3-6月呈下降趋势的情况。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/22ff948c-44f4-4a9a-7a87-a2b96f182300/public"                      width = "600"                ><p>使用折线图呈现总销售额、总订单量以及平均单价在1-6月之间的变化趋势是合理的，但是我们仔细观察这三张图就会发现：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7d53fb48-01b6-4387-e8b1-3a6581b16000/public"                      width = "600"                ><ol><li>观察 y 轴，不能很快知道数据的数量级和单位；</li><li>图中折线颜色均是默认的蓝色，放在一起对比不容易区分；</li><li>图中折线对应的数据标记点不够明显，无法很好地与坐标轴上的值进行对应；</li><li>此外，图中的图表标题、坐标轴刻度、坐标轴标题等字体都太小了，看不清楚。</li></ol><p>所以，我们重点调整这几张图的坐标轴标题、折线以及数据标记点样式，并调整图表标题、坐标轴刻度、坐标轴标题等字体大小。</p><p>用多条折线图呈现各省在各月总订单量的变化趋势是合理的，但同样也存在一些问题：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b5e4308d-0e6a-47e4-d26f-ffb9beece100/public"                      width = "600"                ><ol><li>观察 y 轴，不能很快知道数据的数量级和单位；</li><li>图中折线对应的数据标记点不够明显，无法很好地与坐标轴上的值进行对应；</li><li>此外，图中的图表标题、坐标轴刻度、坐标轴标题等字体都太小了，看不清楚。</li></ol><p>因此，我们重点调整多条折线图的坐标轴标题、折线以及数据标记点样式，并调整图表标题、坐标轴刻度、坐标轴标题重点调整的字体大小。</p><h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h5><p>通过对比 1 月和 6 月的订单量、平均单价，发现 6 月的订单量虽然比日常（1月）要高，但是平均单价已经降至比 1 月还低。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0b487232-9868-4e31-4060-f9fa4a422c00/public"                      width = "600"                ><p>使用折线图呈现订单量、平均单价在 1 月和 6 月的数值比较是不合理的，建议用柱状图。除此之外：</p><ol><li>图中 y 轴均缺少标题，不能很快得知它们的数量级；</li><li>对 1 月和 6 月的数值比较，但是图中没有数值，而是添加了额外的标注；</li><li>强调 1 月和 6 月进行对比，但是颜色没有做专门的区分。</li><li>此外，图中的图表标题、坐标轴刻度、坐标轴标题等字体都太小了，看不清楚。</li></ol><p>因此，我们绘制柱状图，并重点关注该柱状图的坐标轴标题、数据标签以及柱子样式，并调整图表标题、坐标轴刻度、坐标轴标题重点调整的字体大小。</p><h4 id="绘制各月总订单量趋势图"><a href="#绘制各月总订单量趋势图" class="headerlink" title="绘制各月总订单量趋势图"></a>绘制各月总订单量趋势图</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入pandas库</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 读取清洗好的数据</span></span><br><span class="line">mask_data_clean = pd.read_csv(<span class="string">&#x27;mask_data_clean.csv&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取各月总订单量</span></span><br><span class="line">order_number = mask_data_clean.groupby(<span class="string">&#x27;月份&#x27;</span>)[<span class="string">&#x27;订单量&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">order_number</span><br></pre></td></tr></table></figure></div><p>x 坐标值是月份的信息，y 坐标值是每个月对应的口罩订单量合计值。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2f06664e-bd90-486c-563c-5d0c14208d00/public"                      width = "600"                ><p>我们发现折线图中每一个点的 x 坐标值就对应着 <code>order_number</code> 对象左边的索引，而折线图中每一个点的 y 坐标值就对应着 <code>order_number</code> 对象右边的数据。下面就以两个点为例：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/00535ea5-70bf-48c3-2470-77c98b812a00/public"                      width = "600"                ><p>可以用 Series 对象的 index 和 values 属性分别获取左边的索引和右边的数据。</p><p>首先看一下 index 属性</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">order_number.index</span><br><span class="line"></span><br><span class="line"><span class="comment"># Int64Index([1, 2, 3, 4, 5, 6], dtype=&#x27;int64&#x27;, name=&#x27;月份&#x27;)</span></span><br></pre></td></tr></table></figure></div><p>这里返回的是一个 index 对象，里面存储了月份信息。</p><p>我们再来看一下 values 属性</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">order_number.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># array([ 13852., 389319., 1961480., 546276., 158188., 22222.])</span></span><br></pre></td></tr></table></figure></div><p>确定了 x&#x2F;y 坐标值，我们就调用折线图绘图函数 <code>plt.plot()</code> 开始绘图。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = order_number.index</span><br><span class="line">y = order_number.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制折线图</span></span><br><span class="line">plt.plot(x, y)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d07c42bb-bc57-46ae-2d4d-fe48de88df00/public"                      width = "600"                ><p>绘图函数 plt.plot()本身是很强大的，通过调整其中的参数还可以进一步调整折线的样式</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a19cefbf-1024-4c3c-c916-48f034e11500/public"                      width = "600"                ><p>基于刚才确定的目标，我们重点调整坐标轴标题、折线以及数据标记点样式，并调整图表标题、坐标轴刻度、坐标轴标题的字体大小。</p><p>先看线条的宽度和颜色，需要用到的参数分别是 <code>linewidth</code> 和 <code>color</code>。</p><p>参数 <code>linewidth</code> 可以设置线条的宽度，常见为数值类型。</p><p>参数 <code>color</code> 可以设置线条的的颜色。下图为 <code>matplotlib</code> 库支持的颜色，只需要向 <code>color</code> 传入颜色块旁边对应的英文单词即可，常见为字符串类型。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/432a2896-10e3-440a-f981-26aaaf948100/public"                      width = "600"                ><p>设置线条的宽度为3：<code>linewidth=3</code>，颜色为红色：<code>color=&#39;r&#39;</code>（’red’可以简写为’r’）</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 绘制折线图，只调整线条的样式</span></span><br><span class="line">plt.plot(x, y, linewidth=<span class="number">3</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/35f1bad9-4f0f-492d-a9ad-989503c2a000/public"                      width = "600"                ><p>可以看到调整参数 <code>linewidth</code> 和 <code>color</code> 后，线条宽度变宽，并且变成红色。</p><p>接着调整数据标记点的样式，需要用到的参数是 <code>marker</code>、<code>markerfacecolor</code> 和 <code>markersize</code>。</p><p>参数 <code>marker</code> 可以设置数据标记点的形状，有点、圆、加号等，常见为字符串类型，更多的形状</p><p>参数 <code>markersize</code> 和 <code>markerfacecolor</code> 用来设置数据标记点的大小和填充颜色。<code>markersize</code> 的设置方法与 <code>linewidth</code> 参数相同，而 <code>markerfacecolor</code> 参数的设置方法与 <code>color</code>参数一致。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ba7f2392-7eea-47af-93bc-a5254ab27600/public"                      width = "600"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 绘制折线图，只调整数据标记点的样式</span></span><br><span class="line">plt.plot(x, y, linewidth=<span class="number">3</span>, color=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>,markersize=<span class="number">10</span>,markerfacecolor=<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/141b3067-6fbf-4b20-703e-2ca4a8db1d00/public"                      width = "400"                ><p>可以看到调整 <code>marker</code>、<code>markersize</code> 以及 <code>markerfacecolor</code> 之后，数据标记点形状变成圆形，尺寸更大，填充颜色为白色。</p><p>调整折线图中图表标题、坐标轴刻度、坐标轴标题的字体样式</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = order_number.index</span><br><span class="line">y = order_number.values</span><br><span class="line"><span class="comment"># 绘制折线图，并调整线条、标记点的样式</span></span><br><span class="line">plt.plot(x, y, linewidth=<span class="number">3</span>, color=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, markerfacecolor=<span class="string">&#x27;w&#x27;</span>, markersize=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 设置图表标题名及字体大小</span></span><br><span class="line">plt.title(<span class="string">&#x27;各月总订单量趋势图&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置坐标轴的刻度字体大小</span></span><br><span class="line">plt.xticks(fontsize=<span class="number">12</span>)</span><br><span class="line">plt.yticks(fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 设置坐标轴的标题名及字体大小</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;月份&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;各月总订单量（百万）&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line"><span class="comment"># 保存画布</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;各月总订单量趋势图.png&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/205ae976-2761-4d1b-867f-870e396c6f00/public"                      width = "400"                ><h5 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3d0d1c23-92b0-4afc-bb5d-8caac0f37100/public"                      width = "800"                ><h4 id="绘制各省各月订单量趋势图"><a href="#绘制各省各月订单量趋势图" class="headerlink" title="绘制各省各月订单量趋势图"></a>绘制各省各月订单量趋势图</h4><p>重点调整多条折线图的坐标轴标题、折线以及数据标记点样式，并调整图表标题、坐标轴刻度、坐标轴标题的字体大小。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调整画布大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = month_order_df.index</span><br><span class="line">y = month_order_df.values</span><br><span class="line"><span class="comment"># 绘制折线图，并调整线条、标记点的样式</span></span><br><span class="line">plt.plot(x, y, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;o&#x27;</span>, markerfacecolor=<span class="string">&#x27;w&#x27;</span>, markersize=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 设置图表标题名及字体大小</span></span><br><span class="line">plt.title(<span class="string">&#x27;各省各月口罩订单量变化折线图&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置坐标轴的刻度字体大小</span></span><br><span class="line">plt.xticks(fontsize=<span class="number">12</span>)</span><br><span class="line">plt.yticks(fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 设置坐标轴的标题名及字体大小</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;月份&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;各省各月口罩订单量（百万）&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line"><span class="comment"># 添加图例</span></span><br><span class="line">plt.legend([<span class="string">&#x27;其它&#x27;</span>,<span class="string">&#x27;广东&#x27;</span>,<span class="string">&#x27;江苏&#x27;</span>,<span class="string">&#x27;河南&#x27;</span>,<span class="string">&#x27;湖北&#x27;</span>,<span class="string">&#x27;湖南&#x27;</span>])</span><br><span class="line"><span class="comment"># 保存画布</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;各省各月口罩订单量变化折线图.png&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0c1bd611-2e13-4d0c-cbcd-341491e1c000/public"                      width = "300"                ><h5 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dc47784f-e379-4867-7232-2905541b7400/public"                      width = "800"                ><h4 id="绘制各月平均单价分布图"><a href="#绘制各月平均单价分布图" class="headerlink" title="绘制各月平均单价分布图"></a>绘制各月平均单价分布图</h4><p>“各月平均单价趋势图”和“各月平均单价分布图”拥有相同的数据“单价”以及相同的时间维度“月”，因此 “各月平均单价趋势图”的 x&#x2F;y 坐标值同样可以用在“各月平均单价柱状图”中。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求得各月平均单价数据，并将其赋值给变量 mask_price</span></span><br><span class="line">mask_price = mask_data_clean.groupby(<span class="string">&#x27;月份&#x27;</span>)[<span class="string">&#x27;单价&#x27;</span>].mean()</span><br><span class="line"><span class="comment"># 查看mask_price</span></span><br><span class="line">mask_price</span><br><span class="line"><span class="comment"># 设置 x 坐标值</span></span><br><span class="line">x = mask_price.index</span><br><span class="line"><span class="comment"># 设置 y 坐标值</span></span><br><span class="line">y = mask_price.values</span><br></pre></td></tr></table></figure></div><p>确定好 x&#x2F;y 坐标值，接下来调用柱状图绘图函数 <code>plt.bar()</code>开始绘图，与绘图函数 <code>plt.plot()</code>相似，<code>plt.bar()</code>也可以通过调整其中的参数去改变柱子的样式</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8c3fddb0-de09-4777-9adc-2d517d876e00/public"                      width = "600"                ><p>基于刚才确定的目标，我们重点关注该柱状图的坐标轴标题、数据标签以及柱子样式，并调整图表标题、坐标轴刻度、坐标轴标题的字体大小。</p><p>先调整柱子的颜色和宽度，用到的参数分别是 <code>color</code> 和 <code>width</code>。这里的<code>color</code> 和折线图中的<code>color</code> 略有不同，当设置一种颜色时，传入值的类型为字符串；设置多种颜色时，传入值的类型为列表。<code>width</code> 则需要传入(0, 1]区间 (大于 0，小于等于 1) 内的浮点数，数值越大表示柱子的宽度越宽；当 <code>width</code> 的值为 1 时，柱子之间的间隙就为 0。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 绘制柱状图，设置柱子的颜色为绿色，宽度为 0.6</span></span><br><span class="line">plt.bar(x, height=y, color=<span class="string">&#x27;g&#x27;</span>, width=<span class="number">0.6</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b02d15f5-784b-4c95-4456-222e1db79c00/public"                      width = "600"                ><p>可以看到添加了参数 <code>color</code> 和 <code>width</code> 之后，柱子宽度变窄，并且变成绿色。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e57c9752-81fe-4669-c0b0-be0fcdda7700/public"                      width = "600"                ><p>需要注意，柱的颜色是按照列表中颜色字符串的顺序设置的。</p><p>但是这个绿色太深了，只能用“丑”来形容，得想办法优化一下。</p><p>参数 <code>alpha</code> 可以设置柱子颜色的透明度，需要传入(0, 1]区间内的浮点数，数值越小，表示柱子颜色越浅；相反，则越深。适当地调整颜色深浅，可以提升视觉舒适度。</p><p>综上，我们设置柱子颜色透明度为 60%：<code>alpha=6</code>；调整 1 月份和 6 月份的柱子颜色分别为红色、蓝色，其他柱子依然是绿色：<code>color=[&#39;r&#39;, &#39;g&#39;, &#39;g&#39;, &#39;g&#39;, &#39;g&#39;, &#39;b&#39;]</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱状图，并调整柱子的颜色和透明度</span></span><br><span class="line">plt.bar(x, height=y, color=[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], width=<span class="number">0.6</span>, alpha=<span class="number">0.6</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/760d55c6-bc20-4899-8e11-3352d921e900/public"                      width = "400"                ><p>可以看到，柱子颜色变浅了，而且1 月份和 6 月份的柱子颜色分别变成红色、蓝色。</p><h5 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/02119820-a795-43de-87cd-a20c0ed5da00/public"                      width = "800"                ><h4 id="报告制式-4"><a href="#报告制式-4" class="headerlink" title="报告制式"></a>报告制式</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93da82bc-cbb6-4a6c-b1ec-08fbbf3d3e00/public"                      width = "300"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 六、数据分析</span></span><br><span class="line"><span class="section">### 6.1变化趋势</span></span><br><span class="line"><span class="code">销售额、订单量、单价变化趋势</span></span><br><span class="line"><span class="code">#### 1. 各月“销售额”：</span></span><br><span class="line"><span class="code">“销售额”2～3月份急剧上升、3～4月急剧下降，在3月份达到顶峰。</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/db321ddd-19bf-469a-a035-ba2d7088af00/public"                      width = "400"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 2.各月“订单量”：</span></span><br><span class="line"><span class="code">“订单量”表现与“销售额”月表现趋势相同。2～3月份急剧上升、3～4月急下降。在3月份达到顶峰。</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2baf744b-4c16-4266-e451-3ed9d7f86500/public"                      width = "400"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与疫情前对比，6月份比1月份的订单总量略高（1月份的防护服装订单总量为13852盒，6月份22222盒）</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4808be71-107a-4eea-0f08-ae475cd22900/public"                      width = "400"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 3. 各月“单价”：</span></span><br><span class="line"><span class="code">从变化趋势来看，“单价”表现与“销售额”、“订单量”表现趋势相同。2～3月份急剧上升、3～4月急剧下降。在3月份达到顶峰。</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f205c80d-8cec-43c9-f22f-7625f26fa900/public"                      width = "400"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与疫情前对比，6月份比1月份的防护服装单价更低（1月份的防护服装单价为39元/盒，6月份30元/盒）。</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/920387dd-fe70-4638-12be-ef4ea0489100/public"                      width = "400"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 6.2原因分析/内因外因</span></span><br><span class="line"><span class="bullet">1.</span> 销售额、订单量、单价波动情况</span><br><span class="line">“销售额”波动：2～3月份急剧上升、3～4月急剧下降。在3月份达到顶峰。</span><br><span class="line">“单价”波动：2～3月份急剧上升、3～4月急剧下降。在3月份达到顶峰。</span><br><span class="line">“订单量”波动：2～3月份急剧上升、3～4月急剧下降。3月份达到顶峰。</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d5c5a1e7-a0e6-491d-dc12-df21652d1900/public"                      width = "700"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“各省份订单量”波动：各客户之间的变化趋势相同，并且我们发现湖北省的防护服装订单量显著大于其他省份，湖北省为我们的“大客户”，并且“大客户”的订单量也在大幅降低</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ed8c0bf8-16c5-41b8-986d-78e013e9b400/public"                      width = "400"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">2.</span> 疫情是在1-3月份呈上升、3-6月份呈下降，疫情与销售额、订单量、单价变化趋势表现一致。与此同时“大客户“群体也同样是疫情期间的影响重灾地区。因此，过往在3月份的明显波动的盈利状况主要与疫情有关系。</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6639f303-6793-4c12-c805-3c7fe1218800/public"                      width = "700"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/418091a4-e4d9-4d17-714b-63e90dfbf400/public"                      width = "700"                ><blockquote><p>图片来自网络，数据与国家卫健委官网一致</p></blockquote><p><a class="link"   href="https://voice.baidu.com/act/newpneumonia/newpneumonia/?from=osari_aladin_banner" >https://voice.baidu.com/act/newpneumonia/newpneumonia/?from=osari_aladin_banner <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">3.</span> 与1月（日常情况）对比可知，6月的单价已经降到比较低的水平，订单量相对日常情况略高。由于疫情已经趋于稳定，之后订单量与单价不会再继续同时升高，那么6月已经亏损的情况下，之后的一段时间仍会继续亏损。</span><br></pre></td></tr></table></figure></div><h3 id="撰写数据分析报告"><a href="#撰写数据分析报告" class="headerlink" title="撰写数据分析报告"></a>撰写数据分析报告</h3><p>撰写数据分析报告的是为了将分析结果、建议以及其他有价值的信息传递给读者。对于“口罩厂”项目来说，读者是总监，我们要让总监正确地理解结果和建议，并做出有针对性的决策。</p><h4 id="数据分析报告的形式"><a href="#数据分析报告的形式" class="headerlink" title="数据分析报告的形式"></a>数据分析报告的形式</h4><p>先来看看数据分析报告的形式，其实不限于文档、演示文稿以及表格。但是在不同的场景下，选对形式还是很关键的。</p><p>下图是不同形式报告的优劣对比，你可以根据自己的需求选择合适的形式。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1b1277d2-4e17-4f87-0466-16de7023c600/public"                      width = "700"                ><h4 id="数据分析报告的结构"><a href="#数据分析报告的结构" class="headerlink" title="数据分析报告的结构"></a>数据分析报告的结构</h4><p>再来看数据分析报告的结构，一般会采用总分总结构，包括：背景、目的、分析思路、分析正文、结论及建议、附录等。</p><p>1）背景：阐述进行数据分析的原因、意义，以及其他相关信息，比如公司现阶段的经营情况。</p><p>2）目的：这次分析要解决什么问题，达到何种目的。有时会将背景和目的放在一起写。</p><p>3）分析思路：用到了什么分析方法，得到的分析框架是什么。</p><p>4）分析正文是报告的主体部分，包含所有的数据事实和观点，通过数据图表和文字呈现，一般包括三个</p><p>部分：<br>第一步.数据来源：解释数据的来源，并展示数据的基本情况。<br>第二步.数据处理：进行了哪些数据处理操作以及处理的结果是什么。<br>第三步.数据分析：以图文结合的方式展示分析过程和结果，并能证明分析过程合理，分析结果能够应用于实际的工作场景。</p><p>5）结论及建议：以综述性文字展现数据分析结果，并结合公司的具体业务或问题给出建议。</p><p>6）附录：提供正文中涉及到的，但是未详细阐述的资料，一般包括名词解释、源数据以及分析代码等，为整个分析报告提供补充说明。</p><h4 id="项目回顾"><a href="#项目回顾" class="headerlink" title="项目回顾"></a>项目回顾</h4><p>1）背景<br>跟着项目一路走来，你应该再熟悉不过了：公司有一家小型口罩工厂，在今年 6 月底开始处于亏损状态。</p><p>2）目标<br>对历史经营数据进行分析，找到亏损原因，并结合公司实际情况提供对应的解决策略。</p><p>3）分析思路<br>借助公式拆解法，推演出影响口罩厂利润的几个因素以及分析的维度。</p><p>4）分析正文</p><ul><li>基于分析框架向公司数据部门提交需求，拿到的数据基本符合需求，但也存在一些问题，比如一些数据是脏数据，一些数据则用不到，还有一些数据不是目标格式。</li><li>针对上述存在的问题，进行了数据清洗、数据整理、分组聚合以及描述性统计分析等操作。</li><li>整理完数据后，根据销售额、订单量、口罩单价、订单来源省份的影响因素以及月的时间维度进行分析，并通过作图查看各个数据的对比和趋势，最终发现数据变化的规律和原因。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e0ab7a9e-5c3a-48e6-7658-94dd5f96d000/public"                      width = "700"                ><p>除了分析某厂内部的数据，还结合外部环境数据去佐证我们的结论。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cb95419a-73a7-4b34-4c04-0b1e2d01f200/public"                      width = "700"                ><p>5）结论及建议<br>最后，总结数据变化的规律和原因，并结合口罩厂数据和外部环境数据，从避免亏损和追求盈利两个方向给出建议。</p><p>6）附录<br>在分析报告中没有难以理解的名词，整个过程主要用 Python 对数据进行了分析，所以附上原始数据和分析代码。</p><h4 id="报告制式-5"><a href="#报告制式-5" class="headerlink" title="报告制式"></a>报告制式</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93da82bc-cbb6-4a6c-b1ec-08fbbf3d3e00/public"                      width = "300"                ><div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### 七、结论及建议</span></span><br><span class="line"><span class="section">## 【结论】</span></span><br><span class="line"><span class="code">    结论1：防护服装厂的“销售额”在1-3月份呈上升态势，3-6月份呈下降态势，并且在2-3月份急剧上升，3-4月份急剧下降。“订单量”、“单价”都表现出同样的变化情况。</span></span><br><span class="line"><span class="code">    结论2：疫情是影响防护服装厂销售额、订单量、单价在2-3月份、3-4月份出现急剧上升、急剧下降的现象的原因。</span></span><br><span class="line"><span class="code">    结论3：根据疫情逐渐稳定，防护服装需求下降的情况，可以推断防护服装厂6月份之后还将持续亏损。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">## 【建议】</span></span><br><span class="line"><span class="code">    建议1：如果公司不对防护服装厂新投入和改革，防护服装厂会持续亏损，建议尽早对防护服装厂进行转让处理。</span></span><br><span class="line"><span class="code">    建议2：如果公司对防护服装厂新投入和改革，那需要进一步分析产品情况、营销体系等因素对于日常营销的影响，把握住改革重点。</span></span><br><span class="line"><span class="code">    建议3：结合国外的疫情发展，可考虑打开疫情重灾国家的销售渠道，以便保持高单价高销量的营收模式。</span></span><br></pre></td></tr></table></figure></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6fc30248-c0ee-4a2c-bbf5-465599a62700/public"                      width = "800"                >]]></content>
    
    
    <summary type="html">进行数据分析和撰写报告的思路模板</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="思路" scheme="https://www.yiuhangblog.com/tags/%E6%80%9D%E8%B7%AF/"/>
    
    <category term="模板" scheme="https://www.yiuhangblog.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="报告" scheme="https://www.yiuhangblog.com/tags/%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>FineBI案例</title>
    <link href="https://www.yiuhangblog.com/2020/07/12/20200712FineBI%E6%A1%88%E4%BE%8B/"/>
    <id>https://www.yiuhangblog.com/2020/07/12/20200712FineBI%E6%A1%88%E4%BE%8B/</id>
    <published>2020-07-12T05:45:23.000Z</published>
    <updated>2024-02-28T10:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="案例-1-营业额问题分析"><a href="#案例-1-营业额问题分析" class="headerlink" title="案例 1 营业额问题分析"></a>案例 1 营业额问题分析</h2><h3 id="案例背景"><a href="#案例背景" class="headerlink" title="案例背景"></a>案例背景</h3><p>作为数据分析师，面对某公司8月营业额的问题，主要任务是识别问题并提出解决方案。重点关注两个方面：</p><ol><li><strong>商品进货预测</strong>:<ul><li>分析销售额最高的商品以预测热门商品，以便进行有效的库存管理。</li><li>通过不同商品类别的销售额占比分析，优化货架空间分配，提高销售效率。</li></ul></li><li><strong>分析8月毛利额下滑原因</strong>:<ul><li>使用毛利率衡量公司盈利能力，分析8月毛利额下滑原因。</li><li>发现湖南省虽销售额高，但毛利率低，进一步分析揭示成本额较高。</li></ul></li></ol><h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><ol><li><strong>商品进货预测</strong>:<ul><li>确定销售额最大的前10件产品，预测未来进货需求。</li></ul></li><li><strong>毛利额下滑分析</strong>:<ul><li>分析8月毛利额较低的省份、城市、门店和产品，寻找原因。</li></ul></li></ol><h4 id="关注指标"><a href="#关注指标" class="headerlink" title="关注指标"></a>关注指标</h4><ul><li><strong>销售额</strong>和<strong>毛利额</strong>（销售额 - 成本额）</li><li><strong>毛利率</strong>：衡量公司盈利能力的关键指标，受时间、地区、商品等因素影响。</li><li><strong>毛利率计算公式</strong>：毛利率 &#x3D; (毛利额 &#x2F; 销售额) × 100%<ul><li><strong>FineBI中毛利率计算</strong>：SUM_agg(毛利额) &#x2F; SUM_agg(销售额)</li></ul></li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <ol><li>尽管8月的营业额出现问题，但原因可能不仅仅局限于8月。</li><li>需要考虑部分商品可能存在季节性变化，这也可能是影响因素之一。</li><li>单价并不是决定营收的关键因素</li></ol>    </div>  </div><h3 id="分析报告实现步骤"><a href="#分析报告实现步骤" class="headerlink" title="分析报告实现步骤"></a>分析报告实现步骤</h3><h4 id="上传数据表"><a href="#上传数据表" class="headerlink" title="上传数据表"></a>上传数据表</h4><p>获取相关数据，进行初步整理，寻找异常值。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9d18c84b-5d1c-4dd2-811e-78f71ca75000/public"                      width = "600"                ><p>由于表中存在四万条数据，因此存在空值影响不大。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e11894f7-92bf-4060-4580-f90fe04ebb00/public"                      width = "600"                ><p>挑选票据号数量最大的，过滤筛选查看其值，可以发现同一时间点同一票据下存在多个数量相同商品相同类似批次销售的数据，对此可以进行分析，根据自身业务与同事沟通是否存在数据本身的重复，还是正常销售客户进货行为，还是存在涉嫌黑产的行为。若是重复则进行去重，正常则不作处理，若是其它行为则不是数据分析的范畴了。</p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>对数据进行清洗、整理，确保数据准确性。</p><p>根据上述的初步数据整理，假设是正常销售行为，因此本案例不作数据处理。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6b7097c6-93aa-499b-d6d8-5f777bab2e00/public"                      width = "600"                ><p>添加毛利额</p><h4 id="组件交互"><a href="#组件交互" class="headerlink" title="组件交互"></a>组件交互</h4><p>通过交互式组件展示分析结果，增强报告的可读性和互动性。</p><h5 id="新增销售额排名分组表"><a href="#新增销售额排名分组表" class="headerlink" title="新增销售额排名分组表"></a>新增销售额排名分组表</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e0eacc07-81cd-45d5-870c-c195046b2400/public"                      width = "600"                ><p>拖动需要的表头维度<code>商品名称</code>，指标<code>数量</code>，<code>销售额</code>和<code>毛利额</code>到分组表，过滤维度数量最大为10</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dbbb2018-57c1-4329-1caa-0a777136e100/public"                      width = "600"                ><p>降序排列销售额，即可得到完整处理后的销售额最大的前10件产品</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ac27bcea-7655-455b-babc-95e9fa649b00/public"                      width = "600"                ><p>随后在客制化如颜色，数字显示格式后，重命名该组件为销售额最大的10件商品以作区分后新建一个新组件</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2300d3d0-78cf-43a3-d09e-a756441bac00/public"                      width = "600"                ><p>拖动维度<code>日期(年月日)</code>，两个指标<code>毛利额</code>，然后设定日期为年月格式进行汇总</p><h5 id="新增毛利额环比增长率"><a href="#新增毛利额环比增长率" class="headerlink" title="新增毛利额环比增长率"></a>新增毛利额环比增长率</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7ea94391-9668-465a-56bd-afbc5d7a7700/public"                      width = "600"                ><p>新增环比增长率</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2c5a6a49-8fc6-499d-3d75-e5171aa00d00/public"                      width = "600"                ><p>随后重命名以示区分，即可完成毛利额环比增长率的分组表</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/36296a93-2c35-417c-492e-462563c36e00/public"                      width = "600"                ><p>为了不影响源数据，复制一份新的毛利额环比增长率的分组表然后修改为自定义图表</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/11a41a23-dfc5-449d-7f1e-eb22f9863300/public"                      width = "600"                ><p>通过修改毛利额为折线图，环比增长率的直轴为右侧对两组数据的可视化进行分割展示</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b288dfa5-893b-499d-1db4-963909928500/public"                      width = "600"                ><p>按业务需求客制化如颜色，命名，是否加标签即可</p><h5 id="新增销售品类占比饼图"><a href="#新增销售品类占比饼图" class="headerlink" title="新增销售品类占比饼图"></a>新增销售品类占比饼图</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/625e57bd-29fa-4c18-2af4-9b5d155f1100/public"                      width = "600"                ><p>拖动维度<code>商品类别</code>，指标<code>销售额</code>，然后更改指标为占比</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/305f5811-d11a-4095-6690-460c96443a00/public"                      width = "600"                ><p>切换到饼图，然后添加标签即可</p><h5 id="对8月毛利额较低的维度钻取分析下滑原因"><a href="#对8月毛利额较低的维度钻取分析下滑原因" class="headerlink" title="对8月毛利额较低的维度钻取分析下滑原因"></a>对8月毛利额较低的维度钻取分析下滑原因</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cae6adca-f75f-4f12-2e00-5f280c12d500/public"                      width = "600"                ><p>添加毛利率计算公式</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/82a88c16-9cee-4f68-507d-cb4f4a6ecf00/public"                      width = "600"                ><p>添加<code>城市</code>与<code>省份</code>的地理角色，然后拖动<code>城市</code>到<code>省份</code>进行钻取</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b74d33e9-9a39-48a6-9afa-7339fc37ca00/public"                      width = "600"                ><p>继续添加<code>门店名称</code>和<code>商品名称</code>到钻取目录，根据从属关系由上自下排列</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e83f4100-50e6-4d8a-7da1-07db1aa50000/public"                      width = "600"                ><p>将拖动维度钻取目录<code>省份,城市</code>，拖动指标<code>毛利率</code>，<code>毛利额</code>，<code>销售额</code>，<code>成本额</code>，升序毛利率查看省份最低的是哪一个</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8fc2d14a-3379-4030-92d7-117ea11f7200/public"                      width = "600"                ><p>点击最低毛利率的湖南省右侧的箭头进行多次钻取，查看受影响的门店</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6b090638-bd25-43b4-ec12-d15a8bfa6500/public"                      width = "600"                ><p>最后钻取该门店的商品可以发现德芙巧克力处于亏本状态</p><h4 id="添加到仪表板"><a href="#添加到仪表板" class="headerlink" title="添加到仪表板"></a>添加到仪表板</h4><p>将分析结果整合到仪表板中，方便管理层进行决策参考。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8b45fc78-292d-4515-ab1c-824e66a16000/public"                      width = "600"                ><p>拖动先前制作的所有组件到仪表盘中</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d65274c4-b3a2-4476-76ac-2053ff66b600/public"                      width = "600"                ><p>添加过滤组件年月日并拖动到仪表盘中，然后对该仪表盘进行设置为当前数据的日期范围<code>日期(年月日)</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f4f2f1cc-d800-4c93-1451-efc653372a00/public"                      width = "600"                ><p>随后在生成的过滤组件中对日期进行设置即可，修改受影响的组件可以通过重新编辑过滤组件即可</p><h3 id="进行分析"><a href="#进行分析" class="headerlink" title="进行分析"></a>进行分析</h3><p>通过之前分析可以发现八月份环比存在异常，因此需要专门分析八月份的门店营收情况</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/71557ff6-0a21-409c-b0bb-8d1123c43c00/public"                      width = "600"                ><p>根据之前钻取的结果，分别把毛利率异常的维度筛选下来，做成折线图可以发现在八月十七号出现异常</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3d6ad888-85c5-4778-7925-13732cf06200/public"                      width = "600"                ><p>再对仪表盘组件进行重新编辑和分析时，我们观察到一个显著的现象：8月17日，即中国的七夕节当天，德芙巧克力的销售额出现异常波动，销售额显著增加但毛利额异常低下。鉴于七夕节在现代被广泛认为是情侣之间表达爱意的节日，巧克力作为爱情的象征，在这一天的销售激增与节日背景高度相关。因此，在这种情况下，运营团队需要深入了解公司是否实施了特定的营销活动，例如会员优惠、积分折扣等。</p><p>若确认存在此类营销策略，接下来的重点应是评估这些活动是否受到了不正当的利用，比如黑灰产用户的滥用或是门店员工的内部舞弊行为。这些风险因素的识别和管理是风控部门职责范围内的关键事项。因此，建议风控部门对这一异常数据进行详细分析，以确保企业运营的安全和效率。</p><h2 id="案例-2-旅程项目分析"><a href="#案例-2-旅程项目分析" class="headerlink" title="案例 2 旅程项目分析"></a>案例 2 旅程项目分析</h2><h3 id="案例背景-1"><a href="#案例背景-1" class="headerlink" title="案例背景"></a>案例背景</h3><p>某初创项目咨询公司，发现差旅费过高的问题，需要给出差旅费用改善方案</p><p>已知数据表<code>报销明细</code>，<code>机票全价</code>，<code>项目列表</code>和<code>住宿标准</code>，对他们汇总对旅程价格进行分析，基于结果发现问题和给出决策建议</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8a1fffec-73bc-471a-f5ad-257ddde84b00/public"                      width = "600"                ><h3 id="分析报告实现步骤-1"><a href="#分析报告实现步骤-1" class="headerlink" title="分析报告实现步骤"></a>分析报告实现步骤</h3><h4 id="数据处理-1"><a href="#数据处理-1" class="headerlink" title="数据处理"></a>数据处理</h4><p>首先根据<code>行程</code>作为主键对表<code>报销明细</code>和<code>机票全价</code>就行左合并</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/582faa0b-a85a-42b0-0b4c-12bf4eb03b00/public"                      width = "600"                ><p>随后对合并后的表与<code>项目列表</code>根据<code>项目编号</code>继续左合并</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/189c2142-a97a-4fa9-ada8-a8a17c04bd00/public"                      width = "600"                ><p>最后类似的，根据<code>住宿地</code>继续左合并<code>住宿标准</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/914f812b-87ae-46e3-06c3-7bca763a8600/public"                      width = "600"                ><p>由于机票价格存在季节性，因此需要计算机票折扣，则新增公式列<code>机票折扣</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/811d639f-ef4b-410a-01de-798481044600/public"                      width = "600"                ><p>住宿存在预算标准限制，因此需要计算住宿超标率，新增公式列<code>住宿超标率</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/63cf2f35-becb-456f-93c6-bb0dbbe7f000/public"                      width = "600"                ><h4 id="组件交互-1"><a href="#组件交互-1" class="headerlink" title="组件交互"></a>组件交互</h4><h5 id="月度差旅趋势分析"><a href="#月度差旅趋势分析" class="headerlink" title="月度差旅趋势分析"></a>月度差旅趋势分析</h5><p>添加组件，作为月度差旅趋势分析，同时添加是否计费帮助进行占比分析</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3e361c3f-dd61-4614-553a-5ed09256a800/public"                      width = "600"                ><h5 id="费用种类占比"><a href="#费用种类占比" class="headerlink" title="费用种类占比"></a>费用种类占比</h5><p>添加组件，对费用种类占比进行可视化</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c7397b67-7def-4519-990c-fc00f2b17b00/public"                      width = "600"                ><h5 id="计费项目排名"><a href="#计费项目排名" class="headerlink" title="计费项目排名"></a>计费项目排名</h5><p>添加分区柱形图，转化<code>项目编号</code>为维度，转化其区间分组为相同值为一组，使非计费项目的颜色为深色，创建非计费项目排名</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d2948f46-9f90-40aa-709b-fc47d0268c00/public"                      width = "600"                ><h5 id="非计费项目差旅费占比变化趋势"><a href="#非计费项目差旅费占比变化趋势" class="headerlink" title="非计费项目差旅费占比变化趋势"></a>非计费项目差旅费占比变化趋势</h5><p>过滤金额为非计费项目命名为非计费项目金额，创建新的计算规则为<code>SUM_AGG($&#123;非计费项目金额&#125;)/SUM_AGG($&#123;金额&#125;)</code>非计费项目差旅费占比，添加进组件分区折线图，得出占比变化趋势</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b11257e4-51e6-4989-61f1-0e73a62f1c00/public"                      width = "600"                ><h5 id="机票折扣分布"><a href="#机票折扣分布" class="headerlink" title="机票折扣分布"></a>机票折扣分布</h5><p>转化<code>机票折扣</code>为维度，过滤<code>费用种类</code>为机票。设置区间分组为三组，1-7折，8-9折和全价，创建组件分区柱形图，根据<code>日期</code>与<code>次数</code>进行分类</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a6e757e8-7d70-4a84-41c4-94d228368200/public"                      width = "600"                ><h5 id="高额订票人员表"><a href="#高额订票人员表" class="headerlink" title="高额订票人员表"></a>高额订票人员表</h5><p>复制之前创建的机票折扣分布，继承其<code>机票折扣</code>的过滤条件，对<code>机票折扣</code>进行二次过滤，只选择8-9折和全价区间。添加<code>发起人姓名</code>作为第二个维度，删除<code>日期</code>。添加组件分组表，对次数进行降序得出高额订票人员排名。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2744c44c-fe6d-404f-e63d-8e4567f70a00/public"                      width = "600"                ><h5 id="住宿超标率构成"><a href="#住宿超标率构成" class="headerlink" title="住宿超标率构成"></a>住宿超标率构成</h5><p>复制<code>住宿超标率</code>重命名为<code>住宿超标分组</code>并转化为维度，设置区间分组三组为不超标，超20%和超50%，设置过滤<code>费用种类</code>为住宿，添加组件饼图</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ee8365f1-c8fc-43d8-f7ef-852eecbf2800/public"                      width = "600"                ><h5 id="超标率地区分布"><a href="#超标率地区分布" class="headerlink" title="超标率地区分布"></a>超标率地区分布</h5><p>对<code>住宿天数</code>和<code>住宿超标率</code>在散点图进行四象限创建</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e48133c4-9fe0-476e-15cb-22c9ba55b600/public"                      width = "600"                ><h4 id="添加到仪表板-1"><a href="#添加到仪表板-1" class="headerlink" title="添加到仪表板"></a>添加到仪表板</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8cd442bc-7f41-46f5-ccfc-105d5a95e800/public"                      width = "600"                >]]></content>
    
    
    <summary type="html">FineBI 简要案例</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="FineBI" scheme="https://www.yiuhangblog.com/tags/FineBI/"/>
    
    <category term="数据处理" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    <category term="案例" scheme="https://www.yiuhangblog.com/tags/%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>FineBI组件</title>
    <link href="https://www.yiuhangblog.com/2020/06/26/20200626FineBI%E7%BB%84%E4%BB%B6/"/>
    <id>https://www.yiuhangblog.com/2020/06/26/20200626FineBI%E7%BB%84%E4%BB%B6/</id>
    <published>2020-06-26T05:45:23.000Z</published>
    <updated>2024-02-28T10:49:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h2><p>FineBI 可以为客户实现数据可视化，进行可视化分析，可视化的展现结果就是一张张的仪表板，而仪表板是由不同类型的组件构成的，本节即为你介绍如何制作可视化组件。</p><p>FineBI 用于数据分析的可视化组件包括表格、图表、时间过滤组件、文本组件等等，能够提供给你更丰富的选择。</p><h2 id="组件编辑"><a href="#组件编辑" class="headerlink" title="组件编辑"></a>组件编辑</h2><p>FineBI 中可以制作图表和表格进行可视化展示，通过将数据字段拖入分析区域实现图表或者表格的创建。</p><p>组件编辑界面的各区域功能如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e4db0878-58f1-4912-6657-39d40e936800/public"                      width = "600"                ><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>组件制作大致使用流程:<br>1：在【组件管理栏】创建组件<br>2：将【待分析区】中的字段拖入【分析区域字段框】或【图表生成区】<br>3：在【图表配置区】设置需要的图表类型和相关属性和样式<br>4：再根据需求在【组件全局过滤】进行设置</p><p>门店销售数据统计</p><table><thead><tr><th>销售日期</th><th>店风格</th><th>店名</th><th>店性质</th><th>品类描述</th><th>品牌描述</th><th>所属大区</th><th>所属小区</th><th>毛利</th><th>销售额</th></tr></thead><tbody><tr><td>30&#x2F;09&#x2F;2017</td><td>时尚馆</td><td>成都店</td><td>自有店</td><td>女士轻便服装</td><td>WHO.A.U</td><td>中西区</td><td>西南</td><td>209</td><td>1,046</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>时尚馆</td><td>成都店</td><td>自有店</td><td>女士轻便服装</td><td>WHO.A.U</td><td>中西区</td><td>西南</td><td>673</td><td>3,366</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>北京一期（百货）</td><td>自有店</td><td>女士上班服装</td><td>X.ZHINING</td><td>北方区</td><td>华北</td><td>124</td><td>3,979</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>时尚馆</td><td>重庆店</td><td>自有店</td><td>女士上班服装</td><td>WHO.A.U</td><td>中西区</td><td>西南</td><td>894</td><td>5,960</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>时尚馆</td><td>重庆店</td><td>自有店</td><td>女士上班服装</td><td>WHO.A.U</td><td>中西区</td><td>西南</td><td>151</td><td>1,008</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>上宝山店</td><td>自有店</td><td>女士成熟服装</td><td>O.C.T.MAMI(十月妈咪)</td><td>东南区</td><td>上海</td><td>136</td><td>4,863</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>上宝山店</td><td>自有店</td><td>女士成熟服装</td><td>O.C.T.MAMI(十月妈咪)</td><td>东南区</td><td>上海</td><td>337</td><td>1,203</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>天新百店</td><td>自有店</td><td>女士內衣</td><td>O.C.T.MAMI(十月妈咪)</td><td>北方区</td><td>华北</td><td>924</td><td>3,556</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>上浦建店</td><td>自有店</td><td>女士內衣</td><td>O.C.T.MAMI(十月妈咪)</td><td>东南区</td><td>上海</td><td>753</td><td>2,789</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>武汉百货</td><td>自有店</td><td>女士內衣</td><td>O.C.T.MAMI(十月妈咪)</td><td>中西区</td><td>华中</td><td>164</td><td>5,679</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>时尚馆</td><td>武徐东店</td><td>管理店</td><td>女士內衣</td><td>O.C.T.MAMI(十月妈咪)</td><td>中西区</td><td>华中</td><td>481</td><td>1,767</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>北京一期（百货）</td><td>自有店</td><td>女士饰物</td><td>ZIPPO(之宝)</td><td>北方区</td><td>华北</td><td>558</td><td>1,758</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>北京二期（百货）</td><td>自有店</td><td>女士手袋及皮件</td><td>LESPORTSAC</td><td>北方区</td><td>华北</td><td>132</td><td>5,399</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>天新百店</td><td>自有店</td><td>女士皮鞋</td><td>HANG TEN</td><td>北方区</td><td>华北</td><td>461</td><td>1,847</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>北京一期（百货）</td><td>自有店</td><td>女士皮鞋</td><td>HANG TEN</td><td>北方区</td><td>华北</td><td>381</td><td>1,376</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>北京二期（百货）</td><td>自有店</td><td>女士皮鞋</td><td>HANG TEN</td><td>北方区</td><td>华北</td><td>337</td><td>1,485</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>时尚馆</td><td>北彩旋店.</td><td>自有店</td><td>女士皮鞋</td><td>HANG TEN</td><td>北方区</td><td>华北</td><td>126</td><td>4,648</td></tr><tr><td>30&#x2F;09&#x2F;2017</td><td>生活馆</td><td>北利莹百貨</td><td>自有店</td><td>女士皮鞋</td><td>HANG TEN</td><td>北方区</td><td>华北</td><td>173</td><td>6,883</td></tr></tbody></table><p>步骤:</p><ol><li>创建分析主题</li><li>上传数据表</li><li>数据处理</li><li>点击【组件】进入编辑界面,一个分析主题可以添加多个组件，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9ed24dba-96d7-443f-fbb8-6e77ee4a9600/public"                      width = "600"                ><ol start="5"><li>选择「堆积柱形图」，将待分析区域字段「店性质」拖入横轴栏，将「毛利」和「销售额」拖入纵轴栏，就生成了一张<br>图表。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fa06ba49-74c0-42a9-7efe-47c9daeb3b00/public"                      width = "600"                ><ol start="6"><li><p>设置图形属性和组件样式，对组件进行美化。例如自定义设置图表配色，或者更改柱状图圆角度数。</p></li><li><p>需要进行计算或者添加交互功能的根据具体数据表不同需求再进行， 如下图所示：</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e9e48f0d-721c-46fc-88b8-0316cbe31400/public"                      width = "600"                ><h4 id="自定义图表"><a href="#自定义图表" class="headerlink" title="自定义图表"></a>自定义图表</h4><h5 id="自定义图表示例"><a href="#自定义图表示例" class="headerlink" title="自定义图表示例"></a>自定义图表示例</h5><p>品类经营分析</p><table><thead><tr><th>销售日期</th><th>毛利额</th><th>商品单价</th><th>销售金额</th><th>销售数量</th></tr></thead><tbody><tr><td>2015-01-01</td><td>2.4</td><td>0.5</td><td>3</td><td>6</td></tr><tr><td>2015-01-01</td><td>6.46</td><td>5.6</td><td>8.07</td><td>0.96</td></tr><tr><td>2015-01-01</td><td>2</td><td>3</td><td>2.5</td><td>1</td></tr><tr><td>2015-01-01</td><td>1.08</td><td>4</td><td>4</td><td>1</td></tr><tr><td>2015-01-01</td><td>1.83</td><td>6.7</td><td>6.5</td><td>1</td></tr><tr><td>2015-01-01</td><td>1</td><td>1.6</td><td>1.25</td><td>0.78</td></tr><tr><td>2015-01-01</td><td>3.08</td><td>9.6</td><td>3.85</td><td>0.4</td></tr><tr><td>2015-01-01</td><td>4.4</td><td>5.5</td><td>5.5</td><td>1</td></tr><tr><td>2015-01-01</td><td>10.03</td><td>19.6</td><td>12.54</td><td>0.64</td></tr><tr><td>2015-01-01</td><td>2.4</td><td>3</td><td>3</td><td>1</td></tr><tr><td>2015-01-01</td><td>0.69</td><td>19.8</td><td>2.7</td><td>0.2</td></tr><tr><td>2015-01-01</td><td>6.32</td><td>7.9</td><td>7.9</td><td>1</td></tr><tr><td>2015-01-01</td><td>6.32</td><td>7.9</td><td>7.9</td><td>1</td></tr><tr><td>2015-01-01</td><td>1.46</td><td>2.58</td><td>1.83</td><td>0.71</td></tr><tr><td>2015-01-01</td><td>0.91</td><td>1.8</td><td>1.14</td><td>0.64</td></tr><tr><td>2015-01-01</td><td>6.62</td><td>89.8</td><td>8.28</td><td>0.13</td></tr><tr><td>2015-01-01</td><td>1.34</td><td>2.56</td><td>1.68</td><td>0.66</td></tr><tr><td>2015-01-01</td><td>3.08</td><td>16</td><td>6.14</td><td>0.38</td></tr></tbody></table><p>用户希望一个图表组件上，有多种图表类型。如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e86b12da-37ed-4b3d-627f-9b56000fc600/public"                      width = "600"                ><h5 id="自定义图表制作"><a href="#自定义图表制作" class="headerlink" title="自定义图表制作"></a>自定义图表制作</h5><ol><li>图表类型下选择【自定义图表】，将【销售日期】字段拖入横轴，【毛利额】、【商品单价】、【销售金额】字段拖入纵轴。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/624a3842-7d4b-4466-d387-8bc7785ce000/public"                      width = "600"                ><ol start="2"><li>鼠标悬浮在【毛利额】字段上，点击右下角倒三角，点击【设置值轴】，设置最小值为【0】，最大值为【4000】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f0656890-4049-49be-9912-579ee8adcf00/public"                      width = "600"                ><ol start="3"><li>【图形属性】下点击【全部】，将【指标名称】字段拖入到【颜色】栏中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/77b2c0ae-f180-4691-2f3f-ac95d07ec000/public"                      width = "600"                ><ol start="4"><li>在图形属性下，点开【销售金额】字段，图形选择【线】，设置成为 双柱形图-折线图 。如下图所示</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7955bfea-945c-41ea-32c8-0f371538cc00/public"                      width = "600"                ><h4 id="分区柱形图"><a href="#分区柱形图" class="headerlink" title="分区柱形图"></a>分区柱形图</h4><h5 id="分区柱形图示例"><a href="#分区柱形图示例" class="headerlink" title="分区柱形图示例"></a>分区柱形图示例</h5><p>分区柱形图为并列展示维度下各个分类指标的柱形图，能清晰的比较出多种维度下不同指标的数量差距，但是当维度数据较多时，图表的可读性就比较差。效果如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5efc9c82-94b1-4113-fabd-3696a12ad200/public"                      width = "600"                ><p>销售明细表</p><table><thead><tr><th>销售日期</th><th>产品归属业务部</th><th>产品名称</th><th>产品品规</th><th>产品品类</th><th>客户编码</th><th>客户名称</th><th>区域</th><th>生产厂家</th><th>销售单位</th><th>销售类型</th><th>销售人员</th><th>不含税销售单价</th><th>不含税销售额</th><th>城建税、教育费附加、地方教育附加</th><th>出库单编码</th><th>单位生产成本</th><th>发票号</th><th>发票金额</th><th>发票增值税额</th><th>发票增值税率</th><th>含税销售单价</th><th>含税销售额</th><th>人力成本</th><th>物流编号</th><th>现金折扣</th><th>销售数量</th><th>总成本</th></tr></thead><tbody><tr><td>2019-01-05</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>8.62</td><td>86,206,896.55</td><td>775,812.41</td><td>1,234,567</td><td>4.58</td><td>123,456</td><td>86,206,896.55</td><td>13,793,103.45</td><td>0.16</td><td>10</td><td>100,000,000</td><td>12,500,000</td><td>12,345,678</td><td>2,586,206.9</td><td>10,000,000</td><td>45,800,000</td></tr><tr><td>2019-01-30</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>b</td><td>8.62</td><td>129,310,344.83</td><td>1,163,718.62</td><td>1,234,568</td><td>4.58</td><td>123,457</td><td>129,310,344.83</td><td>20,689,655.17</td><td>0.16</td><td>10</td><td>150,000,000</td><td>18,750,000</td><td>12,345,679</td><td>3,879,310.34</td><td>15,000,000</td><td>68,700,000</td></tr><tr><td>2019-02-10</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>8.62</td><td>103,448,275.86</td><td>930,974.9</td><td>1,234,569</td><td>4.58</td><td>123,458</td><td>103,448,275.86</td><td>16,551,724.14</td><td>0.16</td><td>10</td><td>120,000,000</td><td>15,000,000</td><td>12,345,680</td><td>3,103,448.28</td><td>12,000,000</td><td>54,960,000</td></tr><tr><td>2019-02-20</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>8.62</td><td>112,068,965.52</td><td>1,008,556.14</td><td>1,234,570</td><td>4.58</td><td>123,459</td><td>112,068,965.52</td><td>17,931,034.48</td><td>0.16</td><td>10</td><td>130,000,000</td><td>16,250,000</td><td>12,345,681</td><td>3,362,068.97</td><td>13,000,000</td><td>59,540,000</td></tr><tr><td>2019-03-08</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>退货</td><td>b</td><td>8.62</td><td>-172,413.79</td><td>-1,551.62</td><td>1,234,571</td><td>4.58</td><td>123,460</td><td>-172,413.79</td><td>-27,586.21</td><td>0.16</td><td>10</td><td>-200,000</td><td>-25,000</td><td>12,345,682</td><td>-5,172.41</td><td>-20,000</td><td>-91,600</td></tr><tr><td>2019-04-06</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>b</td><td>8.85</td><td>115,044,247.79</td><td>865,866.27</td><td>1,234,572</td><td>4.58</td><td>123,461</td><td>115,044,247.79</td><td>14,955,752.21</td><td>0.13</td><td>10</td><td>130,000,000</td><td>16,681,415.93</td><td>12,345,683</td><td>3,451,327.43</td><td>13,000,000</td><td>59,540,000</td></tr><tr><td>2019-05-05</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司2</td><td>盒</td><td>发货</td><td>a</td><td>8.85</td><td>79,646,017.7</td><td>571,365.88</td><td>1,234,573</td><td>4.78</td><td>123,462</td><td>79,646,017.7</td><td>10,353,982.3</td><td>0.13</td><td>10</td><td>90,000,000</td><td>11,548,672.57</td><td>12,345,684</td><td>2,389,380.53</td><td>9,000,000</td><td>43,020,000</td></tr><tr><td>2019-06-15</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司2</td><td>盒</td><td>发货</td><td>b</td><td>8.85</td><td>61,946,902.65</td><td>444,395.68</td><td>1,234,574</td><td>4.78</td><td>123,463</td><td>61,946,902.65</td><td>8,053,097.35</td><td>0.13</td><td>10</td><td>70,000,000</td><td>8,982,300.88</td><td>12,345,685</td><td>1,858,407.08</td><td>7,000,000</td><td>33,460,000</td></tr><tr><td>2019-01-03</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>a</td><td>15.52</td><td>3,103,448.28</td><td>24,411.81</td><td>1,234,575</td><td>9.16</td><td>123,464</td><td>3,103,448.28</td><td>496,551.72</td><td>0.16</td><td>18</td><td>3,600,000</td><td>450,000</td><td>12,345,686</td><td>93,103.45</td><td>200,000</td><td>1,832,000</td></tr><tr><td>2019-01-08</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>b</td><td>15.52</td><td>7,758,620.69</td><td>61,029.52</td><td>1,234,576</td><td>9.16</td><td>123,465</td><td>7,758,620.69</td><td>1,241,379.31</td><td>0.16</td><td>18</td><td>9,000,000</td><td>1,125,000</td><td>12,345,687</td><td>232,758.62</td><td>500,000</td><td>4,580,000</td></tr><tr><td>2019-01-10</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>139,655,172.41</td><td>1,098,531.31</td><td>1,234,577</td><td>9.16</td><td>123,466</td><td>139,655,172.41</td><td>22,344,827.59</td><td>0.16</td><td>18</td><td>162,000,000</td><td>20,250,000</td><td>12,345,688</td><td>4,189,655.17</td><td>9,000,000</td><td>82,440,000</td></tr><tr><td>2019-01-19</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>155,172,413.79</td><td>1,220,590.34</td><td>1,234,578</td><td>9.16</td><td>123,467</td><td>155,172,413.79</td><td>24,827,586.21</td><td>0.16</td><td>18</td><td>180,000,000</td><td>22,500,000</td><td>12,345,689</td><td>4,655,172.41</td><td>10,000,000</td><td>91,600,000</td></tr><tr><td>2019-01-31</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>232,758,620.69</td><td>1,830,885.52</td><td>1,234,579</td><td>9.16</td><td>123,468</td><td>232,758,620.69</td><td>37,241,379.31</td><td>0.16</td><td>18</td><td>270,000,000</td><td>33,750,000</td><td>12,345,690</td><td>6,982,758.62</td><td>15,000,000</td><td>137,400,000</td></tr><tr><td>2019-02-10</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>201,724,137.93</td><td>1,586,767.45</td><td>1,234,580</td><td>9.16</td><td>123,469</td><td>201,724,137.93</td><td>32,275,862.07</td><td>0.16</td><td>18</td><td>234,000,000</td><td>29,250,000</td><td>12,345,691</td><td>6,051,724.14</td><td>13,000,000</td><td>119,080,000</td></tr><tr><td>2019-03-10</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>139,655,172.41</td><td>1,098,531.31</td><td>1,234,581</td><td>9.16</td><td>123,470</td><td>139,655,172.41</td><td>22,344,827.59</td><td>0.16</td><td>18</td><td>162,000,000</td><td>20,250,000</td><td>12,345,692</td><td>4,189,655.17</td><td>9,000,000</td><td>82,440,000</td></tr><tr><td>2019-04-15</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.93</td><td>127,433,628.32</td><td>844,796.6</td><td>1,234,582</td><td>9.16</td><td>123,471</td><td>127,433,628.32</td><td>16,566,371.68</td><td>0.13</td><td>18</td><td>144,000,000</td><td>18,477,876.11</td><td>12,345,693</td><td>3,823,008.85</td><td>8,000,000</td><td>73,280,000</td></tr><tr><td>2019-05-12</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.93</td><td>79,646,017.7</td><td>527,997.88</td><td>1,234,583</td><td>9.16</td><td>123,472</td><td>79,646,017.7</td><td>10,353,982.3</td><td>0.13</td><td>18</td><td>90,000,000</td><td>11,548,672.57</td><td>12,345,694</td><td>2,389,380.53</td><td>5,000,000</td><td>45,800,000</td></tr><tr><td>2019-06-15</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.93</td><td>71,681,415.93</td><td>475,198.09</td><td>1,234,584</td><td>9.16</td><td>123,473</td><td>71,681,415.93</td><td>9,318,584.07</td><td>0.13</td><td>18</td><td>81,000,000</td><td>10,393,805.31</td><td>12,345,695</td><td>2,150,442.48</td><td>4,500,000</td><td>41,220,000</td></tr></tbody></table><h5 id="分区柱形图制作"><a href="#分区柱形图制作" class="headerlink" title="分区柱形图制作"></a>分区柱形图制作</h5><ol><li>在图表类型下选择【分区柱形图】，将【品牌编号】、【销售日期】字段拖入到横轴中，【销售额】、【毛利】字段拖入到纵轴中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3e2787c0-79a3-467f-f8cf-c1a41187a200/public"                      width = "600"                ><ol start="2"><li>点击销售日期(年月日)字段下拉框，选择年月，完成后的图表如下所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b01af0f3-789a-45fb-c38b-f8b4644f0800/public"                      width = "600"                ><h5 id="设置分区柱形图样式"><a href="#设置分区柱形图样式" class="headerlink" title="设置分区柱形图样式"></a>设置分区柱形图样式</h5><ol start="3"><li>将【指标名称】字段拖入颜色栏，点击颜色栏，设置柱形显示颜色，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e1ffa4fd-e6bb-4c40-8635-145e4cfb5a00/public"                      width = "600"                ><ol start="4"><li>点击【大小栏】，调整柱形的柱宽和大小，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fd24fb68-f818-4a52-2c61-e043d6d04c00/public"                      width = "600"                ><h4 id="堆积柱形图"><a href="#堆积柱形图" class="headerlink" title="堆积柱形图"></a>堆积柱形图</h4><h5 id="堆积柱形图示例"><a href="#堆积柱形图示例" class="headerlink" title="堆积柱形图示例"></a>堆积柱形图示例</h5><p>堆积柱形图将每根柱子进行分割，可以显示大类目下的细分类目占比情况。它既可以直观地看出每个指标的值，还能够反映出维度总和。可应用在：</p><p>展示某互联网产品在一周内由不同渠道获得的流量对比。</p><p>销售部有 3 个部门：销售部门 A 、销售部门 B 、销售部门 C ，需要统计销售部各个部门的贡献成分及变化。</p><p>周流量数据</p><table><thead><tr><th>序号</th><th>星期</th><th>直接访问</th><th>邮件营销</th><th>联盟广告</th><th>视频广告</th><th>搜索引擎</th></tr></thead><tbody><tr><td>1</td><td>周一</td><td>320</td><td>120</td><td>220</td><td>150</td><td>820</td></tr><tr><td>2</td><td>周二</td><td>302</td><td>132</td><td>182</td><td>212</td><td>832</td></tr><tr><td>3</td><td>周三</td><td>301</td><td>101</td><td>191</td><td>201</td><td>901</td></tr><tr><td>4</td><td>周四</td><td>334</td><td>134</td><td>234</td><td>154</td><td>934</td></tr><tr><td>5</td><td>周五</td><td>390</td><td>90</td><td>290</td><td>190</td><td>1290</td></tr><tr><td>6</td><td>周六</td><td>330</td><td>230</td><td>330</td><td>330</td><td>1330</td></tr><tr><td>7</td><td>周日</td><td>320</td><td>210</td><td>310</td><td>410</td><td>1320</td></tr></tbody></table><p>堆积柱形图能清晰的看出每个维度下不同指标的大小，也可以比较出不同维度类别的数据量差距。但是只适用于维度不多的数据，不适用于维度太多的场景。堆积柱形图例如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/059e2e89-c432-4daa-fa5c-0fd6d1ec9600/public"                      width = "600"                ><h5 id="堆积柱形图制作"><a href="#堆积柱形图制作" class="headerlink" title="堆积柱形图制作"></a>堆积柱形图制作</h5><ol><li>将【星期】字段拖入维度栏中，将指标下的字段【直接访问、邮件营销、联盟广告、视频广告、搜索引擎】按顺序置入指标栏中，在图表类型下选择【堆积柱形图】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1194f3f6-a76c-479e-fcab-1446b470cd00/public"                      width = "600"                ><ol start="2"><li><p>设置【按照星期排序】</p><ul><li><p>自定义排序，鼠标悬浮在横轴上的【星期】字段上，点击右侧倒三角符号，设置自定义排序。如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/52c2e540-a1ab-479d-209c-80ef76f05000/public"                      width = "600"                ></li><li><p>通过序号字段实现排序，将【序号】字段拖入【细粒度】栏。再将鼠标悬浮在横轴上的【星期】字段上，点击右侧倒三角符号，选择【升序&gt;序号(求和)】，如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/96cc2053-a641-4316-896f-3ba443cbd400/public"                      width = "600"                ></li></ul></li></ol><h5 id="堆积柱形图设置组件样式"><a href="#堆积柱形图设置组件样式" class="headerlink" title="堆积柱形图设置组件样式"></a>堆积柱形图设置组件样式</h5><ol start="3"><li><p>将指标字段【直接访问、邮件营销、联盟广告、视频广告、搜索引擎】指标 分别 拖入 各自 的图形属性中与它们名称相同的下拉栏的【标签】中。如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/43acd485-b2ca-4fc8-bba2-02138d18b000/public"                      width = "600"                ></li></ol><h4 id="多系列柱形图"><a href="#多系列柱形图" class="headerlink" title="多系列柱形图"></a>多系列柱形图</h4><h5 id="多系列柱形图表示例"><a href="#多系列柱形图表示例" class="headerlink" title="多系列柱形图表示例"></a>多系列柱形图表示例</h5><p>多系列柱形图用于显示不同系列指标间的对比效果，能清晰的看出每个维度下不同指标的大小，通过不同的柱形比较出不同维度类别的数据量差距。但是只适用于维度不多的数据，不适用于维度太多的场景。</p><p>访问统计事实表</p><table><thead><tr><th>统计日期</th><th>地区ID</th><th>访问ID</th><th>访问平台</th><th>渠道ID</th><th>用户ID</th><th>访问次数</th><th>浏览量</th><th>跳出次数</th><th>总停留时间</th></tr></thead><tbody><tr><td>2015-09-01</td><td>3299</td><td>379</td><td>Android</td><td>QD1004</td><td>USER0115</td><td>6</td><td>10</td><td>4</td><td>1,656</td></tr><tr><td>2015-09-01</td><td>4417</td><td>380</td><td>IOS</td><td>QD1015</td><td>USER0116</td><td>5</td><td>6</td><td>4</td><td>648</td></tr><tr><td>2015-09-01</td><td>1101</td><td>381</td><td>Android</td><td>QD1013</td><td>USER0117</td><td>5</td><td>14</td><td>4</td><td>1,512</td></tr><tr><td>2015-09-01</td><td>2201</td><td>382</td><td>IOS</td><td>QD1015</td><td>USER0118</td><td>2</td><td>12</td><td>4</td><td>1,728</td></tr><tr><td>2015-09-01</td><td>2113</td><td>383</td><td>IOS</td><td>QD1003</td><td>USER0119</td><td>5</td><td>9</td><td>4</td><td>1,548</td></tr><tr><td>2015-09-01</td><td>3712</td><td>384</td><td>移动浏览器</td><td>QD1006</td><td>USER0120</td><td>3</td><td>12</td><td>4</td><td>1,440</td></tr><tr><td>2015-09-02</td><td>3299</td><td>385</td><td>Android</td><td>QD1014</td><td>USER0121</td><td>3</td><td>12</td><td>4</td><td>1,008</td></tr><tr><td>2015-09-02</td><td>4420</td><td>386</td><td>Android</td><td>QD1020</td><td>USER0122</td><td>2</td><td>15</td><td>4</td><td>1,260</td></tr><tr><td>2015-09-03</td><td>6211</td><td>387</td><td>Android</td><td>QD1011</td><td>USER0123</td><td>2</td><td>10</td><td>4</td><td>396</td></tr><tr><td>2015-09-03</td><td>4418</td><td>388</td><td>IOS</td><td>QD1011</td><td>USER0124</td><td>2</td><td>8</td><td>4</td><td>432</td></tr><tr><td>2015-09-03</td><td>4420</td><td>389</td><td>IOS</td><td>QD1009</td><td>USER0125</td><td>3</td><td>14</td><td>4</td><td>1,116</td></tr><tr><td>2015-09-03</td><td>6203</td><td>390</td><td>IOS</td><td>QD1003</td><td>USER0126</td><td>5</td><td>12</td><td>4</td><td>288</td></tr><tr><td>2015-09-03</td><td>6110</td><td>391</td><td>移动浏览器</td><td>QD1009</td><td>USER0127</td><td>6</td><td>8</td><td>4</td><td>756</td></tr><tr><td>2015-09-04</td><td>3412</td><td>392</td><td>IOS</td><td>QD1019</td><td>USER0128</td><td>1</td><td>10</td><td>4</td><td>648</td></tr><tr><td>2015-09-04</td><td>7110</td><td>393</td><td>Android</td><td>QD1020</td><td>USER0129</td><td>1</td><td>14</td><td>4</td><td>792</td></tr><tr><td>2015-09-04</td><td>2112</td><td>394</td><td>Android</td><td>QD1016</td><td>USER0130</td><td>5</td><td>6</td><td>4</td><td>396</td></tr><tr><td>2015-09-04</td><td>4418</td><td>395</td><td>IOS</td><td>QD1011</td><td>USER0131</td><td>5</td><td>10</td><td>4</td><td>1,584</td></tr><tr><td>2015-09-04</td><td>2312</td><td>396</td><td>Android</td><td>QD1020</td><td>USER0132</td><td>5</td><td>6</td><td>4</td><td>720</td></tr><tr><td>2015-09-04</td><td>3713</td><td>397</td><td>IOS</td><td>QD1005</td><td>USER0133</td><td>2</td><td>11</td><td>4</td><td>720</td></tr><tr><td>2015-09-04</td><td>4417</td><td>398</td><td>IOS</td><td>QD1018</td><td>USER0134</td><td>5</td><td>7</td><td>4</td><td>1,800</td></tr><tr><td>2015-09-04</td><td>4117</td><td>399</td><td>IOS</td><td>QD1016</td><td>USER0135</td><td>5</td><td>14</td><td>4</td><td>792</td></tr><tr><td>2015-09-04</td><td>4117</td><td>400</td><td>IOS</td><td>QD1020</td><td>USER0136</td><td>1</td><td>11</td><td>4</td><td>324</td></tr><tr><td>2015-09-04</td><td>3405</td><td>401</td><td>移动浏览器</td><td>QD1016</td><td>USER0137</td><td>4</td><td>9</td><td>5</td><td>360</td></tr><tr><td>2015-09-05</td><td>6212</td><td>402</td><td>IOS</td><td>QD1005</td><td>USER0138</td><td>5</td><td>9</td><td>4</td><td>792</td></tr><tr><td>2015-09-05</td><td>4115</td><td>403</td><td>Android</td><td>QD1008</td><td>USER0139</td><td>4</td><td>9</td><td>4</td><td>216</td></tr><tr><td>2015-09-05</td><td>3301</td><td>404</td><td>Android</td><td>QD1003</td><td>USER0140</td><td>6</td><td>10</td><td>4</td><td>396</td></tr><tr><td>2015-09-05</td><td>4451</td><td>405</td><td>Android</td><td>QD1006</td><td>USER0141</td><td>3</td><td>11</td><td>4</td><td>828</td></tr><tr><td>2015-09-05</td><td>4452</td><td>406</td><td>Android</td><td>QD1001</td><td>USER0142</td><td>4</td><td>10</td><td>4</td><td>864</td></tr><tr><td>2015-09-05</td><td>3715</td><td>407</td><td>IOS</td><td>QD1015</td><td>USER0143</td><td>4</td><td>6</td><td>4</td><td>756</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cc780a2b-3bb8-4692-0a34-52c2cbea1800/public"                      width = "600"                ><h5 id="多系列柱形图表制作"><a href="#多系列柱形图表制作" class="headerlink" title="多系列柱形图表制作"></a>多系列柱形图表制作</h5><ol><li>选择【多系列柱形图】，将待分析区域【统计日期】、【浏览量】、【访问次数】、【跳出次数】拖入右侧分析区域，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1b60f67f-814a-4d92-aeee-cf5c7b048f00/public"                      width = "600"                ><ol start="2"><li>筛选出2015.7.13之前的数据。美化组件：颜色设置，大小设置等 如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5260312a-4b2d-4788-7e06-63abd03d9b00/public"                      width = "600"                ><h5 id="多系列柱形图表制作-开启堆积"><a href="#多系列柱形图表制作-开启堆积" class="headerlink" title="多系列柱形图表制作(开启堆积)"></a>多系列柱形图表制作(开启堆积)</h5><p>此案例增加 【添加计算字段】和【开启堆积】</p><p>销售明细表</p><table><thead><tr><th>销售日期</th><th>产品归属业务部</th><th>产品名称</th><th>产品品规</th><th>产品品类</th><th>客户编码</th><th>客户名称</th><th>区域</th><th>生产厂家</th><th>销售单位</th><th>销售类型</th><th>销售人员</th><th>不含税销售单价</th><th>不含税销售额</th><th>城建税、教育费附加、地方教育附加</th><th>出库单编码</th><th>单位生产成本</th><th>发票号</th><th>发票金额</th><th>发票增值税额</th><th>发票增值税率</th><th>含税销售单价</th><th>含税销售额</th><th>人力成本</th><th>物流编号</th><th>现金折扣</th><th>销售数量</th><th>总成本</th></tr></thead><tbody><tr><td>2019-01-05</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>8.62</td><td>86,206,896.55</td><td>775,812.41</td><td>1,234,567</td><td>4.58</td><td>123,456</td><td>86,206,896.55</td><td>13,793,103.45</td><td>0.16</td><td>10</td><td>100,000,000</td><td>12,500,000</td><td>12,345,678</td><td>2,586,206.9</td><td>10,000,000</td><td>45,800,000</td></tr><tr><td>2019-01-30</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>b</td><td>8.62</td><td>129,310,344.83</td><td>1,163,718.62</td><td>1,234,568</td><td>4.58</td><td>123,457</td><td>129,310,344.83</td><td>20,689,655.17</td><td>0.16</td><td>10</td><td>150,000,000</td><td>18,750,000</td><td>12,345,679</td><td>3,879,310.34</td><td>15,000,000</td><td>68,700,000</td></tr><tr><td>2019-02-10</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>8.62</td><td>103,448,275.86</td><td>930,974.9</td><td>1,234,569</td><td>4.58</td><td>123,458</td><td>103,448,275.86</td><td>16,551,724.14</td><td>0.16</td><td>10</td><td>120,000,000</td><td>15,000,000</td><td>12,345,680</td><td>3,103,448.28</td><td>12,000,000</td><td>54,960,000</td></tr><tr><td>2019-02-20</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>8.62</td><td>112,068,965.52</td><td>1,008,556.14</td><td>1,234,570</td><td>4.58</td><td>123,459</td><td>112,068,965.52</td><td>17,931,034.48</td><td>0.16</td><td>10</td><td>130,000,000</td><td>16,250,000</td><td>12,345,681</td><td>3,362,068.97</td><td>13,000,000</td><td>59,540,000</td></tr><tr><td>2019-03-08</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>退货</td><td>b</td><td>8.62</td><td>-172,413.79</td><td>-1,551.62</td><td>1,234,571</td><td>4.58</td><td>123,460</td><td>-172,413.79</td><td>-27,586.21</td><td>0.16</td><td>10</td><td>-200,000</td><td>-25,000</td><td>12,345,682</td><td>-5,172.41</td><td>-20,000</td><td>-91,600</td></tr><tr><td>2019-04-06</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>b</td><td>8.85</td><td>115,044,247.79</td><td>865,866.27</td><td>1,234,572</td><td>4.58</td><td>123,461</td><td>115,044,247.79</td><td>14,955,752.21</td><td>0.13</td><td>10</td><td>130,000,000</td><td>16,681,415.93</td><td>12,345,683</td><td>3,451,327.43</td><td>13,000,000</td><td>59,540,000</td></tr><tr><td>2019-05-05</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司2</td><td>盒</td><td>发货</td><td>a</td><td>8.85</td><td>79,646,017.7</td><td>571,365.88</td><td>1,234,573</td><td>4.78</td><td>123,462</td><td>79,646,017.7</td><td>10,353,982.3</td><td>0.13</td><td>10</td><td>90,000,000</td><td>11,548,672.57</td><td>12,345,684</td><td>2,389,380.53</td><td>9,000,000</td><td>43,020,000</td></tr><tr><td>2019-06-15</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司2</td><td>盒</td><td>发货</td><td>b</td><td>8.85</td><td>61,946,902.65</td><td>444,395.68</td><td>1,234,574</td><td>4.78</td><td>123,463</td><td>61,946,902.65</td><td>8,053,097.35</td><td>0.13</td><td>10</td><td>70,000,000</td><td>8,982,300.88</td><td>12,345,685</td><td>1,858,407.08</td><td>7,000,000</td><td>33,460,000</td></tr><tr><td>2019-01-03</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>a</td><td>15.52</td><td>3,103,448.28</td><td>24,411.81</td><td>1,234,575</td><td>9.16</td><td>123,464</td><td>3,103,448.28</td><td>496,551.72</td><td>0.16</td><td>18</td><td>3,600,000</td><td>450,000</td><td>12,345,686</td><td>93,103.45</td><td>200,000</td><td>1,832,000</td></tr><tr><td>2019-01-08</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>b</td><td>15.52</td><td>7,758,620.69</td><td>61,029.52</td><td>1,234,576</td><td>9.16</td><td>123,465</td><td>7,758,620.69</td><td>1,241,379.31</td><td>0.16</td><td>18</td><td>9,000,000</td><td>1,125,000</td><td>12,345,687</td><td>232,758.62</td><td>500,000</td><td>4,580,000</td></tr><tr><td>2019-01-10</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>139,655,172.41</td><td>1,098,531.31</td><td>1,234,577</td><td>9.16</td><td>123,466</td><td>139,655,172.41</td><td>22,344,827.59</td><td>0.16</td><td>18</td><td>162,000,000</td><td>20,250,000</td><td>12,345,688</td><td>4,189,655.17</td><td>9,000,000</td><td>82,440,000</td></tr><tr><td>2019-01-19</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>155,172,413.79</td><td>1,220,590.34</td><td>1,234,578</td><td>9.16</td><td>123,467</td><td>155,172,413.79</td><td>24,827,586.21</td><td>0.16</td><td>18</td><td>180,000,000</td><td>22,500,000</td><td>12,345,689</td><td>4,655,172.41</td><td>10,000,000</td><td>91,600,000</td></tr><tr><td>2019-01-31</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>232,758,620.69</td><td>1,830,885.52</td><td>1,234,579</td><td>9.16</td><td>123,468</td><td>232,758,620.69</td><td>37,241,379.31</td><td>0.16</td><td>18</td><td>270,000,000</td><td>33,750,000</td><td>12,345,690</td><td>6,982,758.62</td><td>15,000,000</td><td>137,400,000</td></tr><tr><td>2019-02-10</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>201,724,137.93</td><td>1,586,767.45</td><td>1,234,580</td><td>9.16</td><td>123,469</td><td>201,724,137.93</td><td>32,275,862.07</td><td>0.16</td><td>18</td><td>234,000,000</td><td>29,250,000</td><td>12,345,691</td><td>6,051,724.14</td><td>13,000,000</td><td>119,080,000</td></tr><tr><td>2019-03-10</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.52</td><td>139,655,172.41</td><td>1,098,531.31</td><td>1,234,581</td><td>9.16</td><td>123,470</td><td>139,655,172.41</td><td>22,344,827.59</td><td>0.16</td><td>18</td><td>162,000,000</td><td>20,250,000</td><td>12,345,692</td><td>4,189,655.17</td><td>9,000,000</td><td>82,440,000</td></tr><tr><td>2019-04-15</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.93</td><td>127,433,628.32</td><td>844,796.6</td><td>1,234,582</td><td>9.16</td><td>123,471</td><td>127,433,628.32</td><td>16,566,371.68</td><td>0.13</td><td>18</td><td>144,000,000</td><td>18,477,876.11</td><td>12,345,693</td><td>3,823,008.85</td><td>8,000,000</td><td>73,280,000</td></tr><tr><td>2019-05-12</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.93</td><td>79,646,017.7</td><td>527,997.88</td><td>1,234,583</td><td>9.16</td><td>123,472</td><td>79,646,017.7</td><td>10,353,982.3</td><td>0.13</td><td>18</td><td>90,000,000</td><td>11,548,672.57</td><td>12,345,694</td><td>2,389,380.53</td><td>5,000,000</td><td>45,800,000</td></tr><tr><td>2019-06-15</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AC003</td><td>C</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>c</td><td>15.93</td><td>71,681,415.93</td><td>475,198.09</td><td>1,234,584</td><td>9.16</td><td>123,473</td><td>71,681,415.93</td><td>9,318,584.07</td><td>0.13</td><td>18</td><td>81,000,000</td><td>10,393,805.31</td><td>12,345,695</td><td>2,150,442.48</td><td>4,500,000</td><td>41,220,000</td></tr><tr><td>2020-01-05</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>9.29</td><td>102,212,389.38</td><td>787,993.27</td><td>1,234,585</td><td>4.7</td><td>123,474</td><td>102,212,389.38</td><td>13,287,610.62</td><td>0.13</td><td>10.5</td><td>115,500,000</td><td>14,105,309.73</td><td>12,345,696</td><td>2,044,247.79</td><td>11,000,000</td><td>51,700,000</td></tr><tr><td>2020-01-30</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>b</td><td>9.29</td><td>120,796,460.18</td><td>931,264.78</td><td>1,234,586</td><td>4.7</td><td>123,475</td><td>120,796,460.18</td><td>15,703,539.82</td><td>0.13</td><td>10.5</td><td>136,500,000</td><td>16,669,911.5</td><td>12,345,697</td><td>2,415,929.2</td><td>13,000,000</td><td>61,100,000</td></tr><tr><td>2020-02-10</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>9.29</td><td>92,920,353.98</td><td>716,357.52</td><td>1,234,587</td><td>4.7</td><td>123,476</td><td>92,920,353.98</td><td>12,079,646.02</td><td>0.13</td><td>10.5</td><td>105,000,000</td><td>12,823,008.85</td><td>12,345,698</td><td>1,858,407.08</td><td>10,000,000</td><td>47,000,000</td></tr><tr><td>2020-02-20</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>a</td><td>9.29</td><td>27,876,106.19</td><td>214,907.26</td><td>1,234,588</td><td>4.7</td><td>123,477</td><td>27,876,106.19</td><td>3,623,893.81</td><td>0.13</td><td>10.5</td><td>31,500,000</td><td>3,846,902.65</td><td>12,345,699</td><td>557,522.12</td><td>3,000,000</td><td>14,100,000</td></tr><tr><td>2020-03-08</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>退货</td><td>b</td><td>9.29</td><td>-278,761.06</td><td>-2,149.07</td><td>1,234,589</td><td>4.7</td><td>123,478</td><td>-278,761.06</td><td>-36,238.94</td><td>0.13</td><td>10.5</td><td>-315,000</td><td>-38,469.03</td><td>12,345,700</td><td>-5,575.22</td><td>-30,000</td><td>-141,000</td></tr><tr><td>2020-04-06</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司1</td><td>盒</td><td>发货</td><td>b</td><td>9.29</td><td>74,336,283.19</td><td>573,086.02</td><td>1,234,590</td><td>4.7</td><td>123,479</td><td>74,336,283.19</td><td>9,663,716.81</td><td>0.13</td><td>10.5</td><td>84,000,000</td><td>10,258,407.08</td><td>12,345,701</td><td>1,486,725.66</td><td>8,000,000</td><td>37,600,000</td></tr><tr><td>2020-05-05</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司2</td><td>盒</td><td>发货</td><td>a</td><td>9.29</td><td>83,628,318.58</td><td>605,409.77</td><td>1,234,591</td><td>4.98</td><td>123,480</td><td>83,628,318.58</td><td>10,871,681.42</td><td>0.13</td><td>10.5</td><td>94,500,000</td><td>11,540,707.96</td><td>12,345,702</td><td>1,672,566.37</td><td>9,000,000</td><td>44,820,000</td></tr><tr><td>2020-06-15</td><td>非处方药</td><td>感冒药1</td><td>10袋</td><td>呼吸类</td><td>AB002</td><td>B</td><td>京津</td><td>子公司2</td><td>盒</td><td>发货</td><td>b</td><td>9.29</td><td>92,920,353.98</td><td>672,677.52</td><td>1,234,592</td><td>4.98</td><td>123,481</td><td>92,920,353.98</td><td>12,079,646.02</td><td>0.13</td><td>10.5</td><td>105,000,000</td><td>12,823,008.85</td><td>12,345,703</td><td>1,858,407.08</td><td>10,000,000</td><td>49,800,000</td></tr><tr><td>2020-01-03</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>a</td><td>15.93</td><td>12,743,362.83</td><td>81,484.46</td><td>1,234,593</td><td>9.4</td><td>123,482</td><td>12,743,362.83</td><td>1,656,637.17</td><td>0.13</td><td>18</td><td>14,400,000</td><td>1,758,584.07</td><td>12,345,704</td><td>254,867.26</td><td>800,000</td><td>7,520,000</td></tr><tr><td>2020-04-08</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>b</td><td>15.93</td><td>14,336,283.19</td><td>91,670.02</td><td>1,234,594</td><td>9.4</td><td>123,483</td><td>14,336,283.19</td><td>1,863,716.81</td><td>0.13</td><td>18</td><td>16,200,000</td><td>1,978,407.08</td><td>12,345,705</td><td>286,725.66</td><td>900,000</td><td>8,460,000</td></tr><tr><td>2020-05-03</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>a</td><td>15.93</td><td>12,743,362.83</td><td>81,484.46</td><td>1,234,595</td><td>9.4</td><td>123,484</td><td>12,743,362.83</td><td>1,656,637.17</td><td>0.13</td><td>18</td><td>14,400,000</td><td>1,758,584.07</td><td>12,345,706</td><td>254,867.26</td><td>800,000</td><td>7,520,000</td></tr><tr><td>2020-06-08</td><td>非处方药</td><td>感冒药2</td><td>20袋</td><td>呼吸类</td><td>AA001</td><td>A</td><td>京津</td><td>子公司3</td><td>盒</td><td>发货</td><td>b</td><td>15.93</td><td>14,336,283.19</td><td>91,670.02</td><td>1,234,596</td><td>9.4</td><td>123,485</td><td>14,336,283.19</td><td>1,863,716.81</td><td>0.13</td><td>18</td><td>16,200,000</td><td>1,978,407.08</td><td>12,345,707</td><td>286,725.66</td><td>900,000</td><td>8,460,000</td></tr></tbody></table><ol><li>添加计算字段 ，字段名称为【其他成本】，公式为：SUM_AGG(总成本)-SUM_AGG(人力成本)。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b0092c21-fb17-4225-184e-8f5d04240a00/public"                      width = "600"                ><ol start="2"><li>选择【多系列柱形图】，将【产品名称】字段拖入到横轴，将【总成本】、【其他成本】、【人力成本】拖入到纵轴。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/40adadd7-0e1c-4d9d-659a-ff13b15aeb00/public"                      width = "600"                ><ol start="3"><li>为纵轴中的【其他成本】、【人力成本】 【开启堆积】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/adcee882-ec27-41af-962e-cf85f511df00/public"                      width = "600"                ><h4 id="对比柱形图"><a href="#对比柱形图" class="headerlink" title="对比柱形图"></a>对比柱形图</h4><h5 id="对比柱形图示例"><a href="#对比柱形图示例" class="headerlink" title="对比柱形图示例"></a>对比柱形图示例</h5><p>对比柱状图是一种以背靠背形式的条形图，主要用于展示同一维度下，两个指标的对比分析，便于更直观地看出对比差距。下图显示了美国大选各大洲得票情况对比，红色代表共和党，蓝色代表民主党，对比效果如图所示：</p><p>能清晰地比较出当前维度下不同指标的数据量差距，最常用于（有相反含义）的两个指标做对比。</p><p>但是只适用于维度不多的数据，不适用于维度太多的场景。</p><p>美国大选投票数据</p><table><thead><tr><th>votes  democrat</th><th>votes republican</th><th>rep vs dem custom bins</th><th>variance from national margin  labels</th><th>variance - skew dem or rep</th><th>Row type</th><th>Row densified</th><th>Column</th><th>Percent of year’s vote</th><th>记录数</th><th>Row densified (bin)</th><th>Row</th><th>State (Sheet1)</th><th>State</th><th>Swing left vs right</th><th>Table Name</th><th>Total votes - democrat</th><th>Total votes - republican</th><th>Year</th><th>dem vs rep %</th><th>variance from national margin</th></tr></thead><tbody><tr><td>0.34</td><td>0.62</td><td>rep +25-30%</td><td>0.3</td><td>more right</td><td>real</td><td>1</td><td>8</td><td>8e-3</td><td>1</td><td>1</td><td>7</td><td>Alabama</td><td>Alabama</td><td>more right</td><td>swingdata3.csv</td><td>729,547</td><td>1,318,255</td><td>2,016</td><td>0.28</td><td>0.3</td></tr><tr><td>0.38</td><td>0.61</td><td>rep +20-25%</td><td>0.26</td><td>more right</td><td>real</td><td>1</td><td>8</td><td>8e-3</td><td>1</td><td>1</td><td>7</td><td>Alabama</td><td>Alabama</td><td>more right</td><td>swingdata3.csv</td><td>795,696</td><td>1,255,925</td><td>2,012</td><td>0.22</td><td>0.26</td></tr><tr><td>0.39</td><td>0.6</td><td>rep +20-25%</td><td>0.29</td><td>more right</td><td>real</td><td>1</td><td>8</td><td>8e-3</td><td>1</td><td>1</td><td>7</td><td>Alabama</td><td>Alabama</td><td>more right</td><td>swingdata3.csv</td><td>813,479</td><td>1,266,546</td><td>2,008</td><td>0.22</td><td>0.29</td></tr><tr><td>0.37</td><td>0.62</td><td>rep +25-30%</td><td>0.23</td><td>more right</td><td>real</td><td>1</td><td>8</td><td>8e-3</td><td>1</td><td>1</td><td>7</td><td>Alabama</td><td>Alabama</td><td>more right</td><td>swingdata3.csv</td><td>693,933</td><td>1,176,394</td><td>2,004</td><td>0.26</td><td>0.23</td></tr><tr><td>0.42</td><td>0.56</td><td>rep +10-15%</td><td>0.15</td><td>more right</td><td>real</td><td>1</td><td>8</td><td>8e-3</td><td>1</td><td>1</td><td>7</td><td>Alabama</td><td>Alabama</td><td>more right</td><td>swingdata3.csv</td><td>692,611</td><td>941,173</td><td>2,000</td><td>0.15</td><td>0.15</td></tr><tr><td>0.43</td><td>0.5</td><td>rep +5-10%</td><td>0.15</td><td>more right</td><td>real</td><td>1</td><td>8</td><td>8e-3</td><td>1</td><td>1</td><td>7</td><td>Alabama</td><td>Alabama</td><td>more right</td><td>swingdata3.csv</td><td>662,165</td><td>769,044</td><td>1,996</td><td>0.07</td><td>0.15</td></tr><tr><td>0.41</td><td>0.48</td><td>rep +5-10%</td><td>0.12</td><td>more right</td><td>real</td><td>1</td><td>8</td><td>8e-3</td><td>1</td><td>1</td><td>7</td><td>Alabama</td><td>Alabama</td><td>more right</td><td>swingdata3.csv</td><td>690,080</td><td>804,283</td><td>1,992</td><td>0.07</td><td>0.12</td></tr><tr><td>0.4</td><td>0.59</td><td>rep +15-20%</td><td>0.12</td><td>more right</td><td>real</td><td>1</td><td>8</td><td>8e-3</td><td>1</td><td>1</td><td>7</td><td>Alabama</td><td>Alabama</td><td>more right</td><td>swingdata3.csv</td><td>549,506</td><td>815,576</td><td>1,988</td><td>0.19</td><td>0.12</td></tr><tr><td>0.37</td><td>0.51</td><td>rep +10-15%</td><td>0.17</td><td>more right</td><td>real</td><td>1</td><td>1</td><td>1e-3</td><td>1</td><td>1</td><td>1</td><td>Alaska</td><td>Alaska</td><td>more right</td><td>swingdata3.csv</td><td>116,454</td><td>163,387</td><td>2,016</td><td>0.15</td><td>0.17</td></tr><tr><td>0.41</td><td>0.55</td><td>rep +10-15%</td><td>0.18</td><td>more right</td><td>real</td><td>1</td><td>1</td><td>1e-3</td><td>1</td><td>1</td><td>1</td><td>Alaska</td><td>Alaska</td><td>more right</td><td>swingdata3.csv</td><td>122,640</td><td>164,676</td><td>2,012</td><td>0.14</td><td>0.18</td></tr><tr><td>0.38</td><td>0.59</td><td>rep +20-25%</td><td>0.29</td><td>more right</td><td>real</td><td>1</td><td>1</td><td>1e-3</td><td>1</td><td>1</td><td>1</td><td>Alaska</td><td>Alaska</td><td>more right</td><td>swingdata3.csv</td><td>123,594</td><td>193,841</td><td>2,008</td><td>0.22</td><td>0.29</td></tr><tr><td>0.36</td><td>0.61</td><td>rep +25-30%</td><td>0.23</td><td>more right</td><td>real</td><td>1</td><td>1</td><td>1e-3</td><td>1</td><td>1</td><td>1</td><td>Alaska</td><td>Alaska</td><td>more right</td><td>swingdata3.csv</td><td>111,025</td><td>190,889</td><td>2,004</td><td>0.26</td><td>0.23</td></tr><tr><td>0.28</td><td>0.59</td><td>rep +30-40%</td><td>0.32</td><td>more right</td><td>real</td><td>1</td><td>1</td><td>1e-3</td><td>1</td><td>1</td><td>1</td><td>Alaska</td><td>Alaska</td><td>more right</td><td>swingdata3.csv</td><td>79,004</td><td>167,398</td><td>2,000</td><td>0.31</td><td>0.32</td></tr><tr><td>0.33</td><td>0.51</td><td>rep +15-20%</td><td>0.26</td><td>more right</td><td>real</td><td>1</td><td>1</td><td>1e-3</td><td>1</td><td>1</td><td>1</td><td>Alaska</td><td>Alaska</td><td>more right</td><td>swingdata3.csv</td><td>80,380</td><td>122,746</td><td>1,996</td><td>0.18</td><td>0.26</td></tr><tr><td>0.3</td><td>0.39</td><td>rep +5-10%</td><td>0.15</td><td>more right</td><td>real</td><td>1</td><td>1</td><td>1e-3</td><td>1</td><td>1</td><td>1</td><td>Alaska</td><td>Alaska</td><td>more right</td><td>swingdata3.csv</td><td>78,294</td><td>102,000</td><td>1,992</td><td>0.09</td><td>0.15</td></tr><tr><td>0.36</td><td>0.6</td><td>rep +20-25%</td><td>0.16</td><td>more right</td><td>real</td><td>1</td><td>1</td><td>1e-3</td><td>1</td><td>1</td><td>1</td><td>Alaska</td><td>Alaska</td><td>more right</td><td>swingdata3.csv</td><td>72,584</td><td>119,251</td><td>1,988</td><td>0.23</td><td>0.16</td></tr><tr><td>0.45</td><td>0.49</td><td>rep +2-5%</td><td>0.06</td><td>more right</td><td>real</td><td>1</td><td>3</td><td>9e-3</td><td>1</td><td>1</td><td>6</td><td>Arizona</td><td>Arizona</td><td>more right</td><td>swingdata3.csv</td><td>1,161,167</td><td>1,252,401</td><td>2,016</td><td>0.04</td><td>0.06</td></tr><tr><td>0.45</td><td>0.54</td><td>rep +5-10%</td><td>0.13</td><td>more right</td><td>real</td><td>1</td><td>3</td><td>9e-3</td><td>1</td><td>1</td><td>6</td><td>Arizona</td><td>Arizona</td><td>more right</td><td>swingdata3.csv</td><td>1,025,232</td><td>1,233,654</td><td>2,012</td><td>0.09</td><td>0.13</td></tr><tr><td>0.45</td><td>0.54</td><td>rep +5-10%</td><td>0.16</td><td>more right</td><td>real</td><td>1</td><td>3</td><td>9e-3</td><td>1</td><td>1</td><td>6</td><td>Arizona</td><td>Arizona</td><td>more right</td><td>swingdata3.csv</td><td>1,034,707</td><td>1,230,111</td><td>2,008</td><td>0.09</td><td>0.16</td></tr><tr><td>0.44</td><td>0.55</td><td>rep +10-15%</td><td>0.08</td><td>more right</td><td>real</td><td>1</td><td>3</td><td>8e-3</td><td>1</td><td>1</td><td>6</td><td>Arizona</td><td>Arizona</td><td>more right</td><td>swingdata3.csv</td><td>893,524</td><td>1,104,294</td><td>2,004</td><td>0.1</td><td>0.08</td></tr><tr><td>0.45</td><td>0.51</td><td>rep +5-10%</td><td>0.07</td><td>more right</td><td>real</td><td>1</td><td>3</td><td>7e-3</td><td>1</td><td>1</td><td>6</td><td>Arizona</td><td>Arizona</td><td>more right</td><td>swingdata3.csv</td><td>685,341</td><td>781,652</td><td>2,000</td><td>0.06</td><td>0.07</td></tr><tr><td>0.47</td><td>0.44</td><td>dem +2-5%</td><td>0.06</td><td>more right</td><td>real</td><td>1</td><td>3</td><td>7e-3</td><td>1</td><td>1</td><td>6</td><td>Arizona</td><td>Arizona</td><td>more right</td><td>swingdata3.csv</td><td>653,288</td><td>622,073</td><td>1,996</td><td>-0.02</td><td>0.06</td></tr><tr><td>0.37</td><td>0.38</td><td>rep +0-2%</td><td>0.08</td><td>more right</td><td>real</td><td>1</td><td>3</td><td>7e-3</td><td>1</td><td>1</td><td>6</td><td>Arizona</td><td>Arizona</td><td>more right</td><td>swingdata3.csv</td><td>543,050</td><td>572,086</td><td>1,992</td><td>0.02</td><td>0.08</td></tr><tr><td>0.39</td><td>0.6</td><td>rep +20-25%</td><td>0.13</td><td>more right</td><td>real</td><td>1</td><td>3</td><td>6e-3</td><td>1</td><td>1</td><td>6</td><td>Arizona</td><td>Arizona</td><td>more right</td><td>swingdata3.csv</td><td>454,029</td><td>702,541</td><td>1,988</td><td>0.21</td><td>0.13</td></tr><tr><td>0.34</td><td>0.61</td><td>rep +25-30%</td><td>0.29</td><td>more right</td><td>real</td><td>1</td><td>6</td><td>4e-3</td><td>1</td><td>1</td><td>6</td><td>Arkansas</td><td>Arkansas</td><td>more right</td><td>swingdata3.csv</td><td>380,494</td><td>684,872</td><td>2,016</td><td>0.27</td><td>0.29</td></tr><tr><td>0.37</td><td>0.61</td><td>rep +20-25%</td><td>0.27</td><td>more right</td><td>real</td><td>1</td><td>6</td><td>4e-3</td><td>1</td><td>1</td><td>6</td><td>Arkansas</td><td>Arkansas</td><td>more right</td><td>swingdata3.csv</td><td>394,409</td><td>647,744</td><td>2,012</td><td>0.24</td><td>0.27</td></tr><tr><td>0.39</td><td>0.59</td><td>rep +15-20%</td><td>0.27</td><td>more right</td><td>real</td><td>1</td><td>6</td><td>4e-3</td><td>1</td><td>1</td><td>6</td><td>Arkansas</td><td>Arkansas</td><td>more right</td><td>swingdata3.csv</td><td>422,310</td><td>638,017</td><td>2,008</td><td>0.2</td><td>0.27</td></tr><tr><td>0.45</td><td>0.54</td><td>rep +5-10%</td><td>0.07</td><td>more right</td><td>real</td><td>1</td><td>6</td><td>4e-3</td><td>1</td><td>1</td><td>6</td><td>Arkansas</td><td>Arkansas</td><td>more right</td><td>swingdata3.csv</td><td>469,953</td><td>572,898</td><td>2,004</td><td>0.1</td><td>0.07</td></tr><tr><td>0.46</td><td>0.51</td><td>rep +5-10%</td><td>0.06</td><td>more right</td><td>real</td><td>1</td><td>6</td><td>4e-3</td><td>1</td><td>1</td><td>6</td><td>Arkansas</td><td>Arkansas</td><td>more right</td><td>swingdata3.csv</td><td>422,768</td><td>472,940</td><td>2,000</td><td>0.05</td><td>0.06</td></tr><tr><td>0.54</td><td>0.37</td><td>dem +15-20%</td><td>0.08</td><td>more left</td><td>real</td><td>1</td><td>6</td><td>5e-3</td><td>1</td><td>1</td><td>6</td><td>Arkansas</td><td>Arkansas</td><td>more left</td><td>swingdata3.csv</td><td>475,171</td><td>325,416</td><td>1,996</td><td>-0.17</td><td>-0.08</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bb1b194c-fb35-4b02-23c9-fe64b5ce0800/public"                      width = "600"                ><h5 id="对比柱形图制作"><a href="#对比柱形图制作" class="headerlink" title="对比柱形图制作"></a>对比柱形图制作</h5><ol><li>将【State】(州)字段拖入到【维度】中，【Total votes - democrat】(民主党总票数)、【Total votes - republican】(共和党总票数)字段拖入到【指标】中，在图表类型下选择【对比柱形图】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/27342614-103f-4d57-cf06-e06d2b36ce00/public"                      width = "600"                ><ol start="2"><li>更改组件颜色，更改组件标题为【对比柱形图】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8e15b36b-3f61-4d31-4f48-03bead0c6400/public"                      width = "600"                ><h4 id="瀑布图"><a href="#瀑布图" class="headerlink" title="瀑布图"></a>瀑布图</h4><h5 id="瀑布图示例"><a href="#瀑布图示例" class="headerlink" title="瀑布图示例"></a>瀑布图示例</h5><p>瀑布图采用绝对值与相对值结合的方式，来表达数个特定数值之间的数量变化关系。这种效果的图形能够在反映数据多少的同时，直观反映出数据的增减变化过程。</p><p>在实际的应用场景中，瀑布图常用于经营情况分析，解释从一个数字到另一个数字的变化过程。比如评估公司利润、比较产品收益、突出显示项目的预算变更、分析一段时间内的库存或销售情况 、显示一段时间内产品价值变化等。</p><p>瀑布图展示两个数据点之间的演变过程，还可以展示数据是如何累计的。但是使用场景有限。</p><p>工资组成</p><table><thead><tr><th>项目</th><th>数据</th></tr></thead><tbody><tr><td>基本工资</td><td>460</td></tr><tr><td>绩效工资</td><td>120</td></tr><tr><td>加班工资</td><td>80</td></tr><tr><td>应发工资</td><td>660</td></tr><tr><td>保险</td><td>-45</td></tr><tr><td>公积金</td><td>-80</td></tr><tr><td>个税</td><td>-23</td></tr><tr><td>实发工资</td><td>512</td></tr></tbody></table><p>数据间关系为：</p><ul><li>基本工资+绩效工资+加班工资&#x3D;应发工资</li><li>应发工资-保险-公积金-个税&#x3D;实发工资</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/138ae06c-e9a5-4420-5e14-a1e107865b00/public"                      width = "600"                ><h5 id="瀑布图制作-数据处理"><a href="#瀑布图制作-数据处理" class="headerlink" title="瀑布图制作-数据处理"></a>瀑布图制作-数据处理</h5><ol><li>【新增公式列】 添加字段为 【累计值准备】选择【新增公式列】。【应发工资】和【实发工资】数据变为 0 ，其他数据保持不变。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2e65caab-8b17-4f0b-4935-e757356bca00/public"                      width = "600"                ><ol start="2"><li>选择【新增汇总列】。对】【累计值准备】字段进行累加。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ea81c577-d4af-4c3c-a3af-f3823dfbb300/public"                      width = "600"                ><ol start="3"><li>选择【新增公式列】。求出每根柱子在 y 轴上对应的【起点】。最后保存并预览数据图表</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/95d585a7-0183-47b8-150a-ee2c8b66fb00/public"                      width = "600"                ><h5 id="瀑布图制作-组件制作"><a href="#瀑布图制作-组件制作" class="headerlink" title="瀑布图制作-组件制作"></a>瀑布图制作-组件制作</h5><ol><li>将【项目】字段拖入到维度中，【y轴】」、【数据】字段拖入到指标中。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b668bf15-584f-43c3-e4db-bead533a9900/public"                      width = "600"                ><ol start="2"><li>【项目】字段自定义排序。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/31616c28-584d-40c6-b3bb-ab89915e9900/public"                      width = "600"                ><ol start="3"><li>瀑布图组件美化，将【数据】字段拖入到【标签】【颜色】栏等。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/93837573-439a-4863-1407-cf36049c4e00/public"                      width = "600"                ><ol start="4"><li>去除图例，点击【组件样式】&gt;【图例】，取消勾选【显示全部图例】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d905ed81-0861-4af7-40e5-ed5ab6548f00/public"                      width = "600"                ><h4 id="分区折线图"><a href="#分区折线图" class="headerlink" title="分区折线图"></a>分区折线图</h4><h5 id="分区折线图示例"><a href="#分区折线图示例" class="headerlink" title="分区折线图示例"></a>分区折线图示例</h5><p>分区折线图用于分区域分指标查看数据的变化趋势。如下图显示了两个城市在同一时段风速走势的对比情况：、</p><p>分区折线图能清晰地展现出当前维度下不同指标的增减趋势、增减的速率、增减的规律、峰值等特征，适合展现较大数据集，不会多条线条叠加在一起。但是不适合展示多类别数据。</p><p>风速对比</p><table><thead><tr><th>时间</th><th>A城市</th><th>B城市</th></tr></thead><tbody><tr><td>1&#x2F;01&#x2F;2020 0:00</td><td>4.3</td><td>0</td></tr><tr><td>2&#x2F;01&#x2F;2020 0:00</td><td>5.1</td><td>0</td></tr><tr><td>3&#x2F;01&#x2F;2020 0:00</td><td>4.3</td><td>0</td></tr><tr><td>4&#x2F;01&#x2F;2020 0:00</td><td>5.2</td><td>0</td></tr><tr><td>5&#x2F;01&#x2F;2020 0:00</td><td>5.4</td><td>0</td></tr><tr><td>6&#x2F;01&#x2F;2020 0:00</td><td>4.7</td><td>0</td></tr><tr><td>7&#x2F;01&#x2F;2020 0:00</td><td>3.5</td><td>0</td></tr><tr><td>8&#x2F;01&#x2F;2020 0:00</td><td>4.1</td><td>0</td></tr><tr><td>9&#x2F;01&#x2F;2020 0:00</td><td>5.6</td><td>0.1</td></tr><tr><td>10&#x2F;01&#x2F;2020 0:00</td><td>7.4</td><td>0</td></tr><tr><td>11&#x2F;01&#x2F;2020 0:00</td><td>6.9</td><td>0.3</td></tr><tr><td>12&#x2F;01&#x2F;2020 0:00</td><td>7.1</td><td>0</td></tr><tr><td>13&#x2F;01&#x2F;2020 0:00</td><td>7.9</td><td>0</td></tr><tr><td>14&#x2F;01&#x2F;2020 0:00</td><td>7.9</td><td>0.4</td></tr><tr><td>15&#x2F;01&#x2F;2020 0:00</td><td>7.5</td><td>0</td></tr><tr><td>16&#x2F;01&#x2F;2020 0:00</td><td>6.7</td><td>0.1</td></tr><tr><td>17&#x2F;01&#x2F;2020 0:00</td><td>7.7</td><td>0</td></tr><tr><td>18&#x2F;01&#x2F;2020 0:00</td><td>7.7</td><td>0</td></tr><tr><td>19&#x2F;01&#x2F;2020 0:00</td><td>7.4</td><td>0</td></tr><tr><td>20&#x2F;01&#x2F;2020 0:00</td><td>7</td><td>0</td></tr><tr><td>21&#x2F;01&#x2F;2020 0:00</td><td>7.1</td><td>0</td></tr><tr><td>22&#x2F;01&#x2F;2020 0:00</td><td>5.8</td><td>0</td></tr><tr><td>23&#x2F;01&#x2F;2020 0:00</td><td>5.9</td><td>0</td></tr><tr><td>24&#x2F;01&#x2F;2020 0:00</td><td>7.4</td><td>0</td></tr><tr><td>25&#x2F;01&#x2F;2020 0:00</td><td>8.2</td><td>0</td></tr><tr><td>26&#x2F;01&#x2F;2020 0:00</td><td>8.5</td><td>0.6</td></tr><tr><td>27&#x2F;01&#x2F;2020 0:00</td><td>9.4</td><td>1.2</td></tr><tr><td>28&#x2F;01&#x2F;2020 0:00</td><td>8.1</td><td>1.7</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f252cfc5-5d10-4f58-4d1a-eb609972ab00/public"                      width = "600"                ><h5 id="分区折线图制作"><a href="#分区折线图制作" class="headerlink" title="分区折线图制作"></a>分区折线图制作</h5><ol><li>在图表类型下选择【分区折线图】，将【时间】字段拖入到横轴中，【A城市】、【B城市】字段拖入到纵轴中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/87af8687-eb46-42c3-29ed-03910e626100/public"                      width = "600"                ><ol start="2"><li>将待分析区域维度下的【指标名称】拖入颜色栏中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/659c2231-c755-4a7c-a0bf-aaef3abf5600/public"                      width = "600"                ><ol start="3"><li>组件样式设置，点击【连线】，选择线形为曲线，并取消显示标记点：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f9d2bbe6-012d-42cf-05fe-9c58b9127e00/public"                      width = "600"                ><ol start="4"><li>点击【组件样式】，选择自适应显示下拉，选整体适应。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/20988429-102d-410b-700e-cb54500f6600/public"                      width = "600"                ><h4 id="多系列折线图"><a href="#多系列折线图" class="headerlink" title="多系列折线图"></a>多系列折线图</h4><h5 id="多系列折线图示例"><a href="#多系列折线图示例" class="headerlink" title="多系列折线图示例"></a>多系列折线图示例</h5><p>多系列折线图用于在同一区域查看指标的变化趋势，能直观看出趋势对比。</p><p>效果如下图所示，该图展现了自 1800 年至 2017 年全世界能源消耗情况，图中不同颜色的折线代表不同的能源类型（固态、液态、燃气等）：多系列清晰地展现出当前维度下不同指标的增减趋势、增减的速率、增减的规律、峰值等特征，适合展现较大数据集。但是线条数目一般不适合超过 4 条。</p><p>CO2-by-source</p><table><thead><tr><th>Entity</th><th>Code</th><th>Year</th><th>Cement</th><th>Flaring</th><th>Oil</th><th>Coal</th><th>Gas</th></tr></thead><tbody><tr><td>Afghanistan</td><td>AFG</td><td>1949</td><td>0</td><td>0</td><td>0</td><td>14656</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1950</td><td>0</td><td>0</td><td>65952</td><td>21984</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1951</td><td>0</td><td>0</td><td>65952</td><td>25648</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1952</td><td>0</td><td>0</td><td>62288</td><td>32976</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1953</td><td>0</td><td>0</td><td>65952</td><td>36640</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1954</td><td>0</td><td>0</td><td>65952</td><td>43968</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1955</td><td>0</td><td>0</td><td>91600</td><td>62288</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1956</td><td>0</td><td>0</td><td>120912</td><td>62288</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1957</td><td>0</td><td>0</td><td>216176</td><td>76944</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1958</td><td>0</td><td>0</td><td>238160</td><td>91600</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1959</td><td>18320</td><td>0</td><td>256480</td><td>109920</td><td>0</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1960</td><td>18012</td><td></td><td>268760</td><td>127120</td><td></td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1961</td><td>21806</td><td></td><td>293120</td><td>175870</td><td></td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1962</td><td>29074</td><td></td><td>362740</td><td>296780</td><td></td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1963</td><td>50880</td><td></td><td>392050</td><td>263810</td><td></td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1964</td><td>61783</td><td></td><td>476320</td><td>300450</td><td></td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1965</td><td>83589</td><td></td><td>542270</td><td>381060</td><td></td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1966</td><td>87223</td><td></td><td>575250</td><td>428690</td><td></td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1967</td><td>65417</td><td></td><td>556930</td><td>399380</td><td>260140</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1968</td><td>47105</td><td></td><td>496820</td><td>332430</td><td>347040</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1969</td><td>50880</td><td></td><td>527620</td><td>362740</td><td></td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1970</td><td>47350</td><td>297440</td><td>671990</td><td>436970</td><td>216650</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1971</td><td>43611</td><td>304110</td><td>747460</td><td>359070</td><td>439680</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1972</td><td>47246</td><td>366400</td><td>626540</td><td>190530</td><td>300450</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1973</td><td>68897</td><td>223010</td><td>701920</td><td>310740</td><td>332680</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1974</td><td>72825</td><td>367100</td><td>770910</td><td>304690</td><td>400140</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1975</td><td>72561</td><td>303590</td><td>874190</td><td>398690</td><td>475500</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1976</td><td>82609</td><td>293120</td><td>883020</td><td>425020</td><td>300450</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1977</td><td>67434</td><td>381060</td><td>974620</td><td>450670</td><td>512960</td></tr><tr><td>Afghanistan</td><td>AFG</td><td>1978</td><td>59713</td><td>282610</td><td>935910</td><td>576230</td><td>300960</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/84fe62bf-05dc-43c5-f681-1d4b0ea0f900/public"                      width = "600"                ><h5 id="多系列折线图制作"><a href="#多系列折线图制作" class="headerlink" title="多系列折线图制作"></a>多系列折线图制作</h5><ol><li>修改字段类型，数据表上传后，选择字段类型设置中的【Year】为【文本】，点击【确定】按钮。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cee202f7-322f-4806-de2c-7f5709e43500/public"                      width = "600"                ><ol start="2"><li>将待分析区域维度下的字段【Year】拖入维度中，将指标下的字段【Cement】(水泥)、【Coal】(煤)、【Flaring】、【Gas】(气体)、【Oil】(油)拖入指标中，在图表类型中选择【多系列折线图】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f3eed368-b788-435c-63e6-c7f188436100/public"                      width = "600"                ><ol start="3"><li>组件样式设置，选择【组件样式】，点击【自适应显示】，选择【整体适应】，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0313a939-de84-4596-0956-5559cbc0a400/public"                      width = "600"                ><ol start="4"><li>点击 Cement 字段的下拉框，选择【数值格式】，设置数量单位为亿。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9475c3cd-f9c7-409d-c91b-4a3eda5fc600/public"                      width = "600"                ><ol start="5"><li>点击 Cement 字段的下拉框，选择【设置值轴(左值轴)】，点击【自定义】，设置最小值为 0 ，取消勾选【显示轴标题】，点击【确定】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/72d12eb6-02d9-4dd9-915e-d091ec299500/public"                      width = "600"                ><h4 id="折线雷达图"><a href="#折线雷达图" class="headerlink" title="折线雷达图"></a>折线雷达图</h4><h5 id="折线雷达图示例"><a href="#折线雷达图示例" class="headerlink" title="折线雷达图示例"></a>折线雷达图示例</h5><p>雷达图（Radar Chart），又可称为戴布拉图、蜘蛛网图（Spider Chart），每个分类都拥有自己的数值坐标轴，这些坐标轴由中心向外辐射，并用折线将同一系列的值连接。</p><p>用以显示独立的数据系列之间，以及某个特定的系列与其他系列的整体之间的关系。</p><p>雷达图适合展现某个数据集的多个关键特征并进行比对，适合比较多条数据在多个维度上的取值。但是不适合展示多类别数据。</p><p>手机参数对比</p><table><thead><tr><th>特征</th><th>手机A</th><th>手机B</th></tr></thead><tbody><tr><td>外观</td><td>85</td><td>90</td></tr><tr><td>屏幕</td><td>90</td><td>95</td></tr><tr><td>性能</td><td>90</td><td>85</td></tr><tr><td>系统</td><td>95</td><td>95</td></tr><tr><td>拍照</td><td>90</td><td>85</td></tr></tbody></table><p>可以用雷达图展现两款手机 A、B 之间的性能对照，如下图所示案例表：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dd98af43-cd27-4d71-acac-df6d6e038b00/public"                      width = "600"                ><h5 id="折线雷达图制作"><a href="#折线雷达图制作" class="headerlink" title="折线雷达图制作"></a>折线雷达图制作</h5><p>在图表类型下选择【折线雷达图】，将左侧【特征】、【手机A】、【手机B】字段拖入到右侧分析区域中。</p><p>如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e4419258-6d20-4903-15bc-da9fdee80d00/public"                      width = "600"                ><h4 id="范围面积图"><a href="#范围面积图" class="headerlink" title="范围面积图"></a>范围面积图</h4><h5 id="范围面积图示例"><a href="#范围面积图示例" class="headerlink" title="范围面积图示例"></a>范围面积图示例</h5><p>范围面积图用来展示持续性数据，可很好地表示趋势、累积、减少以及变化。</p><p>范围面积图适合展现同一个分类维度在同一间隔内两个连续变量的变化趋势。但是不适合展现多个分类数据。</p><p>访问统计事实表</p><table><thead><tr><th>统计日期</th><th>地区ID</th><th>访问ID</th><th>访问平台</th><th>渠道ID</th><th>用户ID</th><th>访问次数</th><th>浏览量</th><th>跳出次数</th><th>总停留时间</th></tr></thead><tbody><tr><td>2015-09-01</td><td>3299</td><td>379</td><td>Android</td><td>QD1004</td><td>USER0115</td><td>6</td><td>10</td><td>4</td><td>1,656</td></tr><tr><td>2015-09-01</td><td>4417</td><td>380</td><td>IOS</td><td>QD1015</td><td>USER0116</td><td>5</td><td>6</td><td>4</td><td>648</td></tr><tr><td>2015-09-01</td><td>1101</td><td>381</td><td>Android</td><td>QD1013</td><td>USER0117</td><td>5</td><td>14</td><td>4</td><td>1,512</td></tr><tr><td>2015-09-01</td><td>2201</td><td>382</td><td>IOS</td><td>QD1015</td><td>USER0118</td><td>2</td><td>12</td><td>4</td><td>1,728</td></tr><tr><td>2015-09-01</td><td>2113</td><td>383</td><td>IOS</td><td>QD1003</td><td>USER0119</td><td>5</td><td>9</td><td>4</td><td>1,548</td></tr><tr><td>2015-09-01</td><td>3712</td><td>384</td><td>移动浏览器</td><td>QD1006</td><td>USER0120</td><td>3</td><td>12</td><td>4</td><td>1,440</td></tr><tr><td>2015-09-02</td><td>3299</td><td>385</td><td>Android</td><td>QD1014</td><td>USER0121</td><td>3</td><td>12</td><td>4</td><td>1,008</td></tr><tr><td>2015-09-02</td><td>4420</td><td>386</td><td>Android</td><td>QD1020</td><td>USER0122</td><td>2</td><td>15</td><td>4</td><td>1,260</td></tr><tr><td>2015-09-03</td><td>6211</td><td>387</td><td>Android</td><td>QD1011</td><td>USER0123</td><td>2</td><td>10</td><td>4</td><td>396</td></tr><tr><td>2015-09-03</td><td>4418</td><td>388</td><td>IOS</td><td>QD1011</td><td>USER0124</td><td>2</td><td>8</td><td>4</td><td>432</td></tr><tr><td>2015-09-03</td><td>4420</td><td>389</td><td>IOS</td><td>QD1009</td><td>USER0125</td><td>3</td><td>14</td><td>4</td><td>1,116</td></tr><tr><td>2015-09-03</td><td>6203</td><td>390</td><td>IOS</td><td>QD1003</td><td>USER0126</td><td>5</td><td>12</td><td>4</td><td>288</td></tr><tr><td>2015-09-03</td><td>6110</td><td>391</td><td>移动浏览器</td><td>QD1009</td><td>USER0127</td><td>6</td><td>8</td><td>4</td><td>756</td></tr><tr><td>2015-09-04</td><td>3412</td><td>392</td><td>IOS</td><td>QD1019</td><td>USER0128</td><td>1</td><td>10</td><td>4</td><td>648</td></tr><tr><td>2015-09-04</td><td>7110</td><td>393</td><td>Android</td><td>QD1020</td><td>USER0129</td><td>1</td><td>14</td><td>4</td><td>792</td></tr><tr><td>2015-09-04</td><td>2112</td><td>394</td><td>Android</td><td>QD1016</td><td>USER0130</td><td>5</td><td>6</td><td>4</td><td>396</td></tr><tr><td>2015-09-04</td><td>4418</td><td>395</td><td>IOS</td><td>QD1011</td><td>USER0131</td><td>5</td><td>10</td><td>4</td><td>1,584</td></tr><tr><td>2015-09-04</td><td>2312</td><td>396</td><td>Android</td><td>QD1020</td><td>USER0132</td><td>5</td><td>6</td><td>4</td><td>720</td></tr><tr><td>2015-09-04</td><td>3713</td><td>397</td><td>IOS</td><td>QD1005</td><td>USER0133</td><td>2</td><td>11</td><td>4</td><td>720</td></tr><tr><td>2015-09-04</td><td>4417</td><td>398</td><td>IOS</td><td>QD1018</td><td>USER0134</td><td>5</td><td>7</td><td>4</td><td>1,800</td></tr><tr><td>2015-09-04</td><td>4117</td><td>399</td><td>IOS</td><td>QD1016</td><td>USER0135</td><td>5</td><td>14</td><td>4</td><td>792</td></tr><tr><td>2015-09-04</td><td>4117</td><td>400</td><td>IOS</td><td>QD1020</td><td>USER0136</td><td>1</td><td>11</td><td>4</td><td>324</td></tr><tr><td>2015-09-04</td><td>3405</td><td>401</td><td>移动浏览器</td><td>QD1016</td><td>USER0137</td><td>4</td><td>9</td><td>5</td><td>360</td></tr><tr><td>2015-09-05</td><td>6212</td><td>402</td><td>IOS</td><td>QD1005</td><td>USER0138</td><td>5</td><td>9</td><td>4</td><td>792</td></tr><tr><td>2015-09-05</td><td>4115</td><td>403</td><td>Android</td><td>QD1008</td><td>USER0139</td><td>4</td><td>9</td><td>4</td><td>216</td></tr><tr><td>2015-09-05</td><td>3301</td><td>404</td><td>Android</td><td>QD1003</td><td>USER0140</td><td>6</td><td>10</td><td>4</td><td>396</td></tr><tr><td>2015-09-05</td><td>4451</td><td>405</td><td>Android</td><td>QD1006</td><td>USER0141</td><td>3</td><td>11</td><td>4</td><td>828</td></tr><tr><td>2015-09-05</td><td>4452</td><td>406</td><td>Android</td><td>QD1001</td><td>USER0142</td><td>4</td><td>10</td><td>4</td><td>864</td></tr><tr><td>2015-09-05</td><td>3715</td><td>407</td><td>IOS</td><td>QD1015</td><td>USER0143</td><td>4</td><td>6</td><td>4</td><td>756</td></tr><tr><td>2015-09-05</td><td>2305</td><td>408</td><td>IOS</td><td>QD1020</td><td>USER0144</td><td>6</td><td>9</td><td>4</td><td>72</td></tr></tbody></table><p>已知网页的访问次数和跳出次数，两条线勾勒出的范围非跳出次数的变化量趋势，如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3ede842b-575e-4d2c-e944-42d735d13b00/public"                      width = "600"                ><h5 id="范围面积图制作"><a href="#范围面积图制作" class="headerlink" title="范围面积图制作"></a>范围面积图制作</h5><ol><li>图表类型下选择【范围面积图】，将待分析区域维度下的字段【统计日期】拖入横轴中，将指标下的字段【访问次数】、【跳出次数】拖入纵轴中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/23fffcde-dd9d-4222-f108-6437f5d6fd00/public"                      width = "600"                ><ol start="2"><li>点击【统计日期(年月日)】字段下拉框，选择【年月】，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6ebae0b1-931d-44b6-0544-9c47b5f2fd00/public"                      width = "600"                ><ol start="3"><li>在【访问次数(求和)】或【跳出次数(求和)】字段下点击下拉，选择【设置值轴(左值轴)】，在轴标签设置中取消显示轴标签，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e4701dbf-60c6-4da6-e735-5d1150e7f200/public"                      width = "600"                ><h4 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h4><h5 id="仪表盘示例"><a href="#仪表盘示例" class="headerlink" title="仪表盘示例"></a>仪表盘示例</h5><p>【多指针仪表盘】像一个钟表或者可读盘，它有刻度和指针，其中刻度表示度量，指针表示维度，指针角度表示数值，指针指向当前数值。利用多指针的仪表盘，可以直观地表现出某个指标的进度或实际情况。</p><p>供应商产品表</p><table><thead><tr><th>产品名称</th><th>单位数量</th><th>中止</th><th>产品ID</th><th>单价</th><th>订购量</th><th>供应商ID</th><th>库存量</th><th>类别ID</th><th>再订购量</th></tr></thead><tbody><tr><td>苹果汁</td><td>每箱24瓶</td><td>是</td><td>1</td><td>18</td><td>0</td><td>1</td><td>39</td><td>1</td><td>10</td></tr><tr><td>牛奶</td><td>每箱24瓶</td><td>否</td><td>2</td><td>19</td><td>40</td><td>1</td><td>17</td><td>1</td><td>25</td></tr><tr><td>蕃茄酱</td><td>每箱12瓶</td><td>否</td><td>3</td><td>10</td><td>70</td><td>1</td><td>13</td><td>2</td><td>25</td></tr><tr><td>盐</td><td>每箱12瓶</td><td>否</td><td>4</td><td>22</td><td>0</td><td>2</td><td>53</td><td>2</td><td>0</td></tr><tr><td>麻油</td><td>每箱12瓶</td><td>是</td><td>5</td><td>21.35</td><td>0</td><td>2</td><td>0</td><td>2</td><td>0</td></tr><tr><td>酱油</td><td>每箱12瓶</td><td>否</td><td>6</td><td>25</td><td>0</td><td>3</td><td>120</td><td>2</td><td>25</td></tr><tr><td>海鲜粉</td><td>每箱30盒</td><td>否</td><td>7</td><td>30</td><td>0</td><td>3</td><td>15</td><td>7</td><td>10</td></tr><tr><td>胡椒粉</td><td>每箱30盒</td><td>否</td><td>8</td><td>40</td><td>1</td><td>3</td><td>6</td><td>2</td><td>0</td></tr><tr><td>鸡</td><td>每袋500克</td><td>是</td><td>9</td><td>97</td><td>3</td><td>4</td><td>29</td><td>6</td><td>0</td></tr><tr><td>蟹</td><td>每袋500克</td><td>否</td><td>10</td><td>31</td><td>0</td><td>4</td><td>31</td><td>8</td><td>0</td></tr><tr><td>大众奶酪</td><td>每袋6包</td><td>否</td><td>11</td><td>21</td><td>30</td><td>5</td><td>22</td><td>4</td><td>30</td></tr><tr><td>德国奶酪</td><td>每箱12瓶</td><td>否</td><td>12</td><td>38</td><td>3</td><td>5</td><td>86</td><td>4</td><td>0</td></tr><tr><td>龙虾</td><td>每袋500克</td><td>否</td><td>13</td><td>6</td><td>0</td><td>6</td><td>24</td><td>8</td><td>5</td></tr><tr><td>沙茶</td><td>每箱12瓶</td><td>否</td><td>14</td><td>23.25</td><td>0</td><td>6</td><td>35</td><td>7</td><td>0</td></tr><tr><td>味精</td><td>每箱30盒</td><td>否</td><td>15</td><td>15.5</td><td>0</td><td>6</td><td>39</td><td>2</td><td>5</td></tr><tr><td>饼干</td><td>每箱30盒</td><td>否</td><td>16</td><td>17.45</td><td>0</td><td>7</td><td>29</td><td>3</td><td>10</td></tr><tr><td>猪肉</td><td>每袋500克</td><td>是</td><td>17</td><td>39</td><td>0</td><td>7</td><td>0</td><td>6</td><td>0</td></tr><tr><td>墨鱼</td><td>每袋500克</td><td>否</td><td>18</td><td>62.5</td><td>4</td><td>9</td><td>42</td><td>8</td><td>0</td></tr><tr><td>糖果</td><td>每箱30盒</td><td>否</td><td>19</td><td>9.2</td><td>0</td><td>8</td><td>25</td><td>3</td><td>5</td></tr><tr><td>桂花糕</td><td>每箱30盒</td><td>否</td><td>20</td><td>81</td><td>0</td><td>8</td><td>40</td><td>3</td><td>6</td></tr><tr><td>花生</td><td>每箱30包</td><td>否</td><td>21</td><td>10</td><td>40</td><td>8</td><td>3</td><td>3</td><td>5</td></tr><tr><td>糯米</td><td>每袋3公斤</td><td>否</td><td>22</td><td>21</td><td>0</td><td>9</td><td>104</td><td>5</td><td>25</td></tr><tr><td>燕麦</td><td>每袋3公斤</td><td>否</td><td>23</td><td>9</td><td>0</td><td>9</td><td>61</td><td>5</td><td>25</td></tr><tr><td>汽水</td><td>每箱12瓶</td><td>是</td><td>24</td><td>4.5</td><td>0</td><td>10</td><td>20</td><td>1</td><td>0</td></tr><tr><td>巧克力</td><td>每箱30盒</td><td>否</td><td>25</td><td>14</td><td>0</td><td>11</td><td>76</td><td>3</td><td>30</td></tr><tr><td>棉花糖</td><td>每箱30盒</td><td>否</td><td>26</td><td>31.23</td><td>0</td><td>11</td><td>15</td><td>3</td><td>0</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/77af9f47-cbc4-4617-10a9-fc1b1931b300/public"                      width = "600"                ><h5 id="多指针仪表盘"><a href="#多指针仪表盘" class="headerlink" title="多指针仪表盘"></a>多指针仪表盘</h5><ol><li>在图表类型下选择【仪表盘】，图形属性下选择第一个子类型。将【库存量】、【订购量】字段拖入到指针值处。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5d318481-31db-423d-8df5-be7b9216ba00/public"                      width = "600"                ><h5 id="百分比仪表盘"><a href="#百分比仪表盘" class="headerlink" title="百分比仪表盘"></a>百分比仪表盘</h5><p>【百分比仪表盘】，有两种样式：百分比圆环仪表盘、百分比刻度槽型仪表盘。可以直观地表现出某一项数据占总量的占比，可以展示销售完成率、产品合格率等，也可以作为一个进度百分比展示。但是，只能展示一个指标数据，展示信息有限。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1e0260e7-ca46-48c1-c5d9-edef5b3e2100/public"                      width = "600"                ><h6 id="百分比仪表盘制作"><a href="#百分比仪表盘制作" class="headerlink" title="百分比仪表盘制作"></a>百分比仪表盘制作</h6><ol><li>假设总库存容量是4000，新增一个计算字段库存百分比，自定义百分比数据。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/10ad5013-7528-457c-ce7a-1ffce547d000/public"                      width = "600"                ><ol start="2"><li>在图表类型下选择【仪表盘】，图形属性下选择第三个子类型，将【百分比】字段拖入到指针值处。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f8e74872-e95b-4ee8-9a7c-7ac9bfabd500/public"                      width = "600"                ><ol start="3"><li>点击【目标值】，设置目标值为 1 。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/59a55a3d-8c81-4aaf-fe5f-942e5ba65600/public"                      width = "600"                ><ol start="4"><li>将【百分比】字段拖入到【标签栏】，设置数值格式为【百分比】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/01b96b8e-48e2-4578-8880-022ca81c5a00/public"                      width = "600"                ><ol start="5"><li>点击【标签】栏，点击内容格式右下角【编辑】按钮。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/41f3627a-93ad-4c6f-1f3d-0d50a89ead00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2d00fdb3-d3c9-4844-835a-bc02a74f3700/public"                      width = "600"                ><h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><h5 id="饼图示例"><a href="#饼图示例" class="headerlink" title="饼图示例"></a>饼图示例</h5><p>饼图用于分析数据的占比，用户可通过饼图很直观的看到每一个部分在整体中所占的比例。</p><p>地区数据分析</p><table><thead><tr><th>合同签约时间</th><th>国家</th><th>省份</th><th>城市</th><th>客户名称</th><th>合同金额</th><th>回款金额</th></tr></thead><tbody><tr><td>2016-01-18</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>浙江臻善科技有限公司</td><td>1,200,000</td><td>1,200,000</td></tr><tr><td>2016-08-01</td><td>中国</td><td>河南省</td><td>郑州市</td><td>杭州明佑电子有限公司</td><td>100,800</td><td>100,800</td></tr><tr><td>2016-04-01</td><td>中国</td><td>陕西省</td><td>西安市</td><td>西北工业大学</td><td>430,000</td><td>430,000</td></tr><tr><td>2016-01-18</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>浙江网新恩普软件有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-08</td><td>中国</td><td>北京市</td><td>北京市</td><td>北京瑞翔科技有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-14</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海捷穗软件有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-05-05</td><td>中国</td><td>重庆市</td><td>重庆市</td><td>重庆格力销售中心</td><td>285,000</td><td>285,000</td></tr><tr><td>2016-04-21</td><td>中国</td><td>江苏省</td><td>南京市</td><td>江苏邮政同达科技</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-06-01</td><td>中国</td><td>上海市</td><td>上海市</td><td>95856部队</td><td>520,000</td><td>520,000</td></tr><tr><td>2016-04-29</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海创业投资有限公司</td><td>240,000</td><td>240,000</td></tr><tr><td>2016-04-29</td><td>中国</td><td>上海市</td><td>上海市</td><td>智动营销策划咨询（上海）有限公司</td><td>450,000</td><td>450,000</td></tr><tr><td>2016-04-25</td><td>中国</td><td>江苏省</td><td>盐城市</td><td>盐城邮政局</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-05-04</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>杭州银行</td><td>1,200,000</td><td>1,080,000</td></tr><tr><td>2016-04-27</td><td>中国</td><td>北京市</td><td>北京市</td><td>建信金融租赁股份有限公司</td><td>600,000</td><td>600,000</td></tr></tbody></table><p>通常能明确显示数据的比例情况。用来描述量、频率或百分比之间的相对关系。但是不适合较大的数据集（分类）展现，当比例接近时，人眼很难准确判别。如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/417cfb40-b415-43da-9ad4-b9f5595ee300/public"                      width = "600"                ><h5 id="饼图制作"><a href="#饼图制作" class="headerlink" title="饼图制作"></a>饼图制作</h5><ol><li>将【合同签约时间】字段拖入维度，【合同金额】字段拖入指标，【合同签约时间】字段显示格式改为【年】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/53960855-4d2d-4fe9-5b33-33170c423000/public"                      width = "600"                ><ol start="2"><li>在图表类型下选择【饼图】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/30083bbe-fbcf-42e4-ac1a-4a74a3bcae00/public"                      width = "600"                ><ol start="3"><li>将【合同签约时间】、【合同金额】拖入【标签】内，使其在图形中显示，【合同签约时间】字段显示格式改为【年】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ce3726cd-5376-4e3e-40dc-39cb3cb52e00/public"                      width = "600"                ><ol start="4"><li>【合同金额】字段下拉点击【快速计算&gt;占比】，显示饼图各部分占比。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3808cf5b-d8b7-48c6-9d8b-ff7260d0e500/public"                      width = "600"                ><ol start="5"><li>点击【组件样式】&gt;【图例】，取消勾选显示全部图例按钮。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9cb7dc55-0ac3-41dc-06bb-f25c1e0c9400/public"                      width = "600"                ><h4 id="玫瑰图"><a href="#玫瑰图" class="headerlink" title="玫瑰图"></a>玫瑰图</h4><h5 id="玫瑰图示例"><a href="#玫瑰图示例" class="headerlink" title="玫瑰图示例"></a>玫瑰图示例</h5><p>玫瑰图通过扇形的面积和半径显示数据的占比情况，可以展示每一数值相对于总数值的大小、数据在某一时间段的变化，也可以用来比较各项数据间的情况等。玫瑰图适合突出显示不同分类的大小差异。但是玫瑰图将数据量之间的差别夸大显示了，相差 1% 表现在面积上，视觉差别是超过 1% 的，不好用于展示具体的差值数量。</p><p>地区数据分析</p><table><thead><tr><th>合同签约时间</th><th>国家</th><th>省份</th><th>城市</th><th>客户名称</th><th>合同金额</th><th>回款金额</th></tr></thead><tbody><tr><td>2016-01-18</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>浙江臻善科技有限公司</td><td>1,200,000</td><td>1,200,000</td></tr><tr><td>2016-08-01</td><td>中国</td><td>河南省</td><td>郑州市</td><td>杭州明佑电子有限公司</td><td>100,800</td><td>100,800</td></tr><tr><td>2016-04-01</td><td>中国</td><td>陕西省</td><td>西安市</td><td>西北工业大学</td><td>430,000</td><td>430,000</td></tr><tr><td>2016-01-18</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>浙江网新恩普软件有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-08</td><td>中国</td><td>北京市</td><td>北京市</td><td>北京瑞翔科技有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-14</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海捷穗软件有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-05-05</td><td>中国</td><td>重庆市</td><td>重庆市</td><td>重庆格力销售中心</td><td>285,000</td><td>285,000</td></tr><tr><td>2016-04-21</td><td>中国</td><td>江苏省</td><td>南京市</td><td>江苏邮政同达科技</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-06-01</td><td>中国</td><td>上海市</td><td>上海市</td><td>95856部队</td><td>520,000</td><td>520,000</td></tr><tr><td>2016-04-29</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海创业投资有限公司</td><td>240,000</td><td>240,000</td></tr><tr><td>2016-04-29</td><td>中国</td><td>上海市</td><td>上海市</td><td>智动营销策划咨询（上海）有限公司</td><td>450,000</td><td>450,000</td></tr><tr><td>2016-04-25</td><td>中国</td><td>江苏省</td><td>盐城市</td><td>盐城邮政局</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-05-04</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>杭州银行</td><td>1,200,000</td><td>1,080,000</td></tr><tr><td>2016-04-27</td><td>中国</td><td>北京市</td><td>北京市</td><td>建信金融租赁股份有限公司</td><td>600,000</td><td>600,000</td></tr><tr><td>2015-03-22</td><td>中国</td><td>江苏省</td><td>南京市</td><td>南京星友田科技发展有限公司</td><td>400,000</td><td>400,000</td></tr><tr><td>2016-06-19</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海万序计算机科技有限公司</td><td>480,000</td><td>480,000</td></tr><tr><td>2016-05-25</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海万序计算机科技有限公司</td><td>480,000</td><td>480,000</td></tr><tr><td>2016-05-26</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海巨一科技发展有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-05-20</td><td>中国</td><td>北京市</td><td>北京市</td><td>北京英诺威尔科技股份有限公司</td><td>875,000</td><td>787,500</td></tr><tr><td>2016-05-20</td><td>中国</td><td>北京市</td><td>北京市</td><td>北京普天太力通信科技有限公司</td><td>1,400,000</td><td>700,000</td></tr><tr><td>2016-05-31</td><td>中国</td><td>北京市</td><td>北京市</td><td>健康在线教育培训有限公司</td><td>280,000</td><td>280,000</td></tr><tr><td>2016-10-11</td><td>中国</td><td>江苏省</td><td>南京市</td><td>南京益康信达</td><td>350,000</td><td>350,000</td></tr><tr><td>2012-06-02</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海欣能信息科技发展有限公司</td><td>1,576,000</td><td>1,400,000</td></tr><tr><td>2016-06-22</td><td>中国</td><td>北京市</td><td>北京市</td><td>埃而塔（北京）管理技术有限公司</td><td>300,000</td><td>300,000</td></tr><tr><td>2016-06-24</td><td>中国</td><td>广西壮族自治区</td><td>来宾市</td><td>柳州欧莱普信息技术有限公司</td><td>250,000</td><td>250,000</td></tr><tr><td>2016-06-09</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海普元信息技术股份有限公司</td><td>0</td><td>200,000</td></tr><tr><td>2016-06-15</td><td>中国</td><td>四川省</td><td>成都市</td><td>成都启冠代理记账有限公司</td><td>60,000</td><td>60,000</td></tr><tr><td>2016-06-08</td><td>中国</td><td>福建省</td><td>厦门市</td><td>厦门农商银行</td><td>280,000</td><td>280,000</td></tr></tbody></table><p>如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5db8046a-8268-484b-4874-db562e490600/public"                      width = "600"                ><h5 id="玫瑰图制作"><a href="#玫瑰图制作" class="headerlink" title="玫瑰图制作"></a>玫瑰图制作</h5><ol><li>将【合同签约时间】拖入维度中，【合同金额】、【回款金额】拖入指标中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/647873be-e2cb-479f-b48a-a86084814300/public"                      width = "600"                ><ol start="2"><li><p>在图表类型下选择【玫瑰图】，可以看到回款金额的大小映射到玫瑰图的半径上，合同金额的大小映射到玫瑰图的角度上。</p><p>如下图所示:</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1e0f69de-52c8-4cf1-4be9-e36269155600/public"                      width = "600"                >  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p>该玫瑰图必须在横纵轴中有1个维度、2个指标字段才能选择，否则图表类型下的玫瑰图将灰化无法点击。</p>  </div><ol start="3"><li>点击颜色栏中的【合同签约时间】字段，选择【年月】显示。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b78840c3-89cd-4a44-0b74-566fcc359d00/public"                      width = "600"                ><ol start="4"><li>点击【半径】栏，设置内径占比到 0% 。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ad585616-94d2-4ae8-bbe3-6a9cefc17300/public"                      width = "600"                ><ol start="5"><li>点击颜色栏中的【合同签约时间】下拉，选择升序排序，按【回款金额(求和)】进行排序。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/70b38171-d73c-4b23-f928-d699e8b93500/public"                      width = "600"                ><h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><h5 id="散点图示例"><a href="#散点图示例" class="headerlink" title="散点图示例"></a>散点图示例</h5><p>散点图（Scatter Chart）是科研绘图中最常见的图形类型之一，通常用于显示和比较数值，使用一系列的散点在直角坐标系中展示变量的数值分布，可以通过观察发现两者的关系与相关性。散点图可以展示数据的分布和聚合情况，适合展示较大的数据集。但是主要用于观测相关、分布和聚合，其他信息均不能很好展现。</p><p>身高体重分布</p><table><thead><tr><th>序号</th><th>性别</th><th>身高</th><th>体重</th></tr></thead><tbody><tr><td>1</td><td>女</td><td>161.2</td><td>51.6</td></tr><tr><td>2</td><td>女</td><td>170</td><td>59</td></tr><tr><td>3</td><td>女</td><td>172.5</td><td>55.2</td></tr><tr><td>4</td><td>女</td><td>147.2</td><td>49.8</td></tr><tr><td>5</td><td>女</td><td>159.5</td><td>50.6</td></tr><tr><td>6</td><td>女</td><td>174</td><td>54.5</td></tr><tr><td>7</td><td>女</td><td>154.4</td><td>46.2</td></tr><tr><td>8</td><td>女</td><td>162.1</td><td>53.6</td></tr><tr><td>9</td><td>女</td><td>168.9</td><td>62.3</td></tr><tr><td>10</td><td>女</td><td>167.6</td><td>58.3</td></tr><tr><td>11</td><td>女</td><td>167.6</td><td>61</td></tr><tr><td>12</td><td>女</td><td>168.3</td><td>54.8</td></tr><tr><td>13</td><td>女</td><td>156</td><td>52.7</td></tr><tr><td>14</td><td>女</td><td>162</td><td>54.7</td></tr><tr><td>15</td><td>女</td><td>151.1</td><td>48.7</td></tr><tr><td>16</td><td>女</td><td>164</td><td>55.7</td></tr><tr><td>17</td><td>女</td><td>170</td><td>69.4</td></tr><tr><td>18</td><td>女</td><td>163.2</td><td>59.8</td></tr><tr><td>19</td><td>女</td><td>161.4</td><td>63.4</td></tr></tbody></table><p>如下图展示了一组人群身高体重的分布数据，红色代表女性，蓝色代表男性：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/540529aa-957b-41c1-df4b-feb9c0cc2d00/public"                      width = "600"                ><h5 id="散点图制作"><a href="#散点图制作" class="headerlink" title="散点图制作"></a>散点图制作</h5><ol><li>先进行【数据处理】，将【序号】的数据类型改为【文本类型】在图表类型下选择【散点图】，将【身高】字段拖入到横轴，【体重】字段拖入到纵轴，【性别】字段拖入【图形属性】&gt;【颜色】，【序号】字段拖入到【图形属性】&gt;【细粒度】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d85332a0-fe37-41e3-3573-94f66553c800/public"                      width = "600"                ><ol start="3"><li>点击颜色栏，分别设置男女性别显示颜色，效果如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/98937fa0-5622-4b98-20c4-ae021cb32800/public"                      width = "600"                ><ol start="4"><li>点击身高(求和)下拉框，选择数值格式，设置单位后缀为cm，点击确定：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/418f647d-2c15-44aa-8684-978d4afc0300/public"                      width = "600"                ><ol start="4"><li>点击身高(求和)下拉框，选择设置值轴(下值轴)，显示范围选择自定义，设置最小值为MIN(身高(求和))-5，最大值为MAX(身高(求和))+5，点击确定：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/10b041c5-bd9f-4e71-7c03-d508c366bf00/public"                      width = "600"                ><ol start="5"><li>点击体重(求和)下拉框，选择数值格式，设置单位后缀为kg，点击确定：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d99bdafa-d26d-4b6a-b984-a886a6ea8800/public"                      width = "600"                ><ol start="5"><li>点击体重(求和)下拉框，选择设置值轴(下值轴)，显示范围选择自定义，设置最小值为MIN(体重(求和))-5，最大值为MAX(体重(求和))+5，点击确定：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4096f02a-cdd5-494b-159a-a575a4d29400/public"                      width = "600"                ><h4 id="热力区域图"><a href="#热力区域图" class="headerlink" title="热力区域图"></a>热力区域图</h4><h5 id="热力区域图示例"><a href="#热力区域图示例" class="headerlink" title="热力区域图示例"></a>热力区域图示例</h5><p>热力区域图以特殊高亮的方式展示坐标范围内各个点的权重情况，通过颜色高亮程度展示指标数据的差异。可应用在：</p><p>某地区每月的 24 小时平均气温分布情况。</p><p>近几年雨水在 12 个月的分布情况。</p><p>能清晰地呈现数据在两个维度之间的分布、频率或密度情况。但是效果过于柔化，不适合用作数据的精确表达。</p><p>全年气温</p><table><thead><tr><th>日期</th><th>时间</th><th>温度</th></tr></thead><tbody><tr><td>1&#x2F;01&#x2F;2013</td><td>0</td><td>1.3</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>1</td><td>1.4</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>2</td><td>1.6</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>3</td><td>2</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>4</td><td>2.4</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>5</td><td>2.9</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>6</td><td>3.1</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>7</td><td>2.8</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>8</td><td>2.8</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>9</td><td>2.7</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>10</td><td>3.4</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>11</td><td>2.6</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>12</td><td>2.4</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>13</td><td>2.9</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>15</td><td>2.8</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>14</td><td>2.8</td></tr><tr><td>1&#x2F;01&#x2F;2013</td><td>16</td><td>2.2</td></tr></tbody></table><p>如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/27fcc8fd-c3e0-4f1f-376f-b1989e30e800/public"                      width = "600"                ><h5 id="热力区域图制作"><a href="#热力区域图制作" class="headerlink" title="热力区域图制作"></a>热力区域图制作</h5><ol><li>上传后，将【时间】字段的数据类型改为【文本】，在图表类型下点击【自定义图表】，将【日期」】段拖入横轴，【时间】字段拖入纵轴。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/565540e9-449b-406f-c01a-380351a2d200/public"                      width = "600"                ><ol start="2"><li>将【日期】的分组改为【年月】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f20f4caa-867e-45ce-ac80-289b472de200/public"                      width = "600"                ><ol start="3"><li>在图表类型下选择【热力区域图】，将【温度】拖入热力色栏。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0a359bb6-b6df-45d1-0fee-d28412f16b00/public"                      width = "600"                ><ol start="4"><li>展示温度平均值。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/435c7e3f-5753-4033-bee7-2993b4523900/public"                      width = "600"                ><ol start="5"><li>点击【自适应显示】，选择【整体适应】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/21fbbaad-75d9-45bd-f07c-d505187c6a00/public"                      width = "600"                ><h3 id="地图类"><a href="#地图类" class="headerlink" title="地图类"></a>地图类</h3><h4 id="区域地图"><a href="#区域地图" class="headerlink" title="区域地图"></a>区域地图</h4><h5 id="地图示例"><a href="#地图示例" class="headerlink" title="地图示例"></a>地图示例</h5><p>【区域地图】是一种使用不同深浅的颜色来展示数据的大小和分布范围的可视化图形。适合展示数据在地理区块空间的分布状况，使用颜色深浅来区分数值大小。</p><p>客户维度表</p><table><thead><tr><th>国家</th><th>省份</th><th>城市</th><th>客户规模</th></tr></thead><tbody><tr><td>中国</td><td>陕西省</td><td>西安市</td><td>50-150人</td></tr><tr><td>中国</td><td>浙江省</td><td>杭州市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>湖北省</td><td>武汉市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>北京市</td><td>北京市</td><td>50-150人</td></tr><tr><td>中国</td><td>北京市</td><td>北京市</td><td>50-150人</td></tr><tr><td>中国</td><td>北京市</td><td>北京市</td><td>50-150人</td></tr><tr><td>中国</td><td>广东省</td><td>深圳市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>上海市</td><td>上海市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>北京市</td><td>北京市</td><td>150-500人</td></tr><tr><td>中国</td><td>上海市</td><td>上海市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>辽宁省</td><td>大连市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>吉林省</td><td>长春市</td><td>50-150人</td></tr><tr><td>中国</td><td>浙江省</td><td>温州市</td><td>50-150人</td></tr><tr><td>中国</td><td>福建省</td><td>福州市</td><td>150-500人</td></tr><tr><td>中国</td><td>北京市</td><td>北京市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>湖南省</td><td>湘西市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>广东省</td><td>广州市</td><td>&gt;500人</td></tr><tr><td>中国</td><td>北京市</td><td>北京市</td><td>&gt;500人</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/30901771-4a62-4817-59ab-68e7ba449900/public"                      width = "600"                ><h5 id="地图制作"><a href="#地图制作" class="headerlink" title="地图制作"></a>地图制作</h5><ol><li>将待分析区域维度下的字段【省份】转化为地理角色。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/72addeb1-6726-4ddb-f325-cab2ba8f9400/public"                      width = "600"                ><ol start="2"><li>在图表类型下选择【区域地图】，将【省份（经度）】字段拖入横轴，【省份（纬度）字段】拖入纵轴。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f7146d52-f0b9-459c-a0b5-dbe1adafea00/public"                      width = "600"                ><ol start="3"><li>将【记录数】拖入颜色栏中，点击【颜色】框体，修改渐变颜色。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0b17aee4-a08b-4730-a4d8-c935e27e1b00/public"                      width = "600"                ><ol start="4"><li>设置背景为【幻影黑】 。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a9474146-cbe0-40de-b327-e4622c475600/public"                      width = "600"                ><ol start="5"><li>【钻取目录】用户可根据实际需求可以实现由省到市的逐级钻取，并对不同省份和区域的数据进行展示，创建从省份钻取到城市的客户分布数据，选择维度下的【省份】字段，将其转换为地理角色</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c61bb3ca-df33-4e75-d068-d74dbf0d1c00/public"                      width = "600"                ><ol start="6"><li>选择【城市】字段转换为地理角色，生成城市的经纬度字段，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/186f751c-7e88-45ed-e261-a2b168da8d00/public"                      width = "600"                ><ol start="7"><li><p>经纬度字段转化好以后，将城市字段拖至省份字段处，创建【省份-城市】的钻取目录，自动生成钻取目录的名称，点击确定保存省份和城市将会自动生成经纬度的钻取目录</p></li><li><p>图表中显示了客户覆盖的省份，但还没能实现钻取的效果，需要我们将创建的钻取目录字段拖至图形属性下:【颜色、标签、提示、细粒度】中的其中任意一个即可。如将该字段拖至细粒度下，如下图所示：</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1de5816c-8f8f-4c4c-74b8-fbcc9907b400/public"                      width = "600"                ><h3 id="点地图"><a href="#点地图" class="headerlink" title="点地图"></a>点地图</h3><h4 id="点地图示例"><a href="#点地图示例" class="headerlink" title="点地图示例"></a>点地图示例</h4><p>【点地图】用于在地理坐标系范围内，将数据生成为几何图形点，主要用于展示地理区域内的空间分布，适合展示一组或多组数据在地理空间的分布状况。</p><p>地区数据分析1</p><table><thead><tr><th>合同签约时间</th><th>国家</th><th>省份</th><th>城市</th><th>客户名称</th><th>合同金额</th><th>回款金额</th></tr></thead><tbody><tr><td>2016-01-18</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>浙江臻善科技有限公司</td><td>1,200,000</td><td>1,200,000</td></tr><tr><td>2016-08-01</td><td>中国</td><td>河南省</td><td>郑州市</td><td>杭州明佑电子有限公司</td><td>100,800</td><td>100,800</td></tr><tr><td>2016-04-01</td><td>中国</td><td>陕西省</td><td>西安市</td><td>西北工业大学</td><td>430,000</td><td>430,000</td></tr><tr><td>2016-01-18</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>浙江网新恩普软件有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-08</td><td>中国</td><td>北京市</td><td>北京市</td><td>北京瑞翔科技有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-14</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海捷穗软件有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-05-05</td><td>中国</td><td>重庆市</td><td>重庆市</td><td>重庆格力销售中心</td><td>285,000</td><td>285,000</td></tr><tr><td>2016-04-21</td><td>中国</td><td>江苏省</td><td>南京市</td><td>江苏邮政同达科技</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-06-01</td><td>中国</td><td>上海市</td><td>上海市</td><td>95856部队</td><td>520,000</td><td>520,000</td></tr><tr><td>2016-04-29</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海创业投资有限公司</td><td>240,000</td><td>240,000</td></tr><tr><td>2016-04-29</td><td>中国</td><td>上海市</td><td>上海市</td><td>智动营销策划咨询（上海）有限公司</td><td>450,000</td><td>450,000</td></tr><tr><td>2016-04-25</td><td>中国</td><td>江苏省</td><td>盐城市</td><td>盐城邮政局</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-05-04</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>杭州银行</td><td>1,200,000</td><td>1,080,000</td></tr><tr><td>2016-04-27</td><td>中国</td><td>北京市</td><td>北京市</td><td>建信金融租赁股份有限公司</td><td>600,000</td><td>600,000</td></tr><tr><td>2015-03-22</td><td>中国</td><td>江苏省</td><td>南京市</td><td>南京星友田科技发展有限公司</td><td>400,000</td><td>400,000</td></tr><tr><td>2016-06-19</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海万序计算机科技有限公司</td><td>480,000</td><td>480,000</td></tr><tr><td>2016-05-25</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海万序计算机科技有限公司</td><td>480,000</td><td>480,000</td></tr><tr><td>2016-05-26</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海巨一科技发展有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-05-20</td><td>中国</td><td>北京市</td><td>北京市</td><td>北京英诺威尔科技股份有限公司</td><td>875,000</td><td>787,500</td></tr><tr><td>2016-05-20</td><td>中国</td><td>北京市</td><td>北京市</td><td>北京普天太力通信科技有限公司</td><td>1,400,000</td><td>700,000</td></tr><tr><td>2016-05-31</td><td>中国</td><td>北京市</td><td>北京市</td><td>健康在线教育培训有限公司</td><td>280,000</td><td>280,000</td></tr><tr><td>2016-10-11</td><td>中国</td><td>江苏省</td><td>南京市</td><td>南京益康信达</td><td>350,000</td><td>350,000</td></tr><tr><td>2012-06-02</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海欣能信息科技发展有限公司</td><td>1,576,000</td><td>1,400,000</td></tr><tr><td>2016-06-22</td><td>中国</td><td>北京市</td><td>北京市</td><td>埃而塔（北京）管理技术有限公司</td><td>300,000</td><td>300,000</td></tr><tr><td>2016-06-24</td><td>中国</td><td>广西壮族自治区</td><td>来宾市</td><td>柳州欧莱普信息技术有限公司</td><td>250,000</td><td>250,000</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/090716cc-456c-4877-55cc-60a2a9629700/public"                      width = "600"                ><h4 id="点地图制作"><a href="#点地图制作" class="headerlink" title="点地图制作"></a>点地图制作</h4><ol><li>将待分析区域维度下的字段城市转化为【地理角色】，详细操作请参见 维度转化为地理角色，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b987b08b-3d16-4319-cb40-a3a04a1e1500/public"                      width = "600"                ><ol start="2"><li>选择【点地图】，将城市(经度)和城市(纬度)拖入横轴纵轴栏。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/10fd4fed-0ad7-4cd2-6d33-a33965c37700/public"                      width = "600"                ><ol start="3"><li>将【合同金额】指标拖入到【颜色】，合同金额越大，颜色越深。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/09de1436-593d-47f8-d02d-031f23a8c800/public"                      width = "600"                ><ol start="4"><li>点击【颜色】框中的【合同金额】右边的倒三角，设置闪烁动画。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dcdbcbd6-eae3-4906-bb78-107cb58a5300/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a74642f4-afd7-4658-4114-7f1abc116e00/public"                      width = "600"                ><ol start="5"><li>将【合同金额】指标拖入到【大小】，合同金额越大，点的面积越大。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a34a5501-0ec3-4733-6dde-fb2926c01500/public"                      width = "600"                ><ol start="6"><li>选择【组件样式】，取消勾选【显示全部图例】按钮。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/efd34f87-ec45-4096-b08b-27a712cbc700/public"                      width = "600"                ><ol start="7"><li>在【组件样式】&gt;【背景】中，设置组件背景GIS为【自定义】&gt;【深蓝】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2154648e-0291-4cd1-2db5-4ca004016300/public"                      width = "600"                ><h3 id="流向地图"><a href="#流向地图" class="headerlink" title="流向地图"></a>流向地图</h3><h4 id="流向地图示例"><a href="#流向地图示例" class="headerlink" title="流向地图示例"></a>流向地图示例</h4><p>流向地图在地图上显示信息或物体从一个位置到另一个位置的移动及其数量。通常用来显示人物、动物和产品的迁移数据。单一流向线所代表的移动规模或数量由其粗细度表示，有助显示迁移活动的地理分布。</p><p>流向地图多应用于区际贸易、交通流向、人口迁移、购物消费行为、通讯信息流动、航空线路等场景，也可应用企业货物运输，供应链管理。</p><p>流向地图适合展现地理空间内事物发生位置移动时所对应数据的变化情况。但是不适合展示精确数值。</p><p>春运迁徙数据</p><table><thead><tr><th>迁徙线路</th><th>编号</th><th>城市</th><th>迁徙人数</th></tr></thead><tbody><tr><td>南京市-三亚市</td><td>0</td><td>南京市</td><td>57665</td></tr><tr><td>南京市-三亚市</td><td>1</td><td>三亚市</td><td>57665</td></tr><tr><td>南京市-中卫市</td><td>0</td><td>南京市</td><td>38596</td></tr><tr><td>南京市-中卫市</td><td>1</td><td>中卫市</td><td>38596</td></tr><tr><td>南京市-丽水市</td><td>0</td><td>南京市</td><td>374853</td></tr><tr><td>南京市-丽水市</td><td>1</td><td>丽水市</td><td>374853</td></tr><tr><td>南京市-乌鲁木齐市</td><td>0</td><td>南京市</td><td>13755</td></tr><tr><td>南京市-乌鲁木齐市</td><td>1</td><td>乌鲁木齐市</td><td>13755</td></tr><tr><td>南京市-九江市</td><td>0</td><td>南京市</td><td>4596</td></tr><tr><td>南京市-九江市</td><td>1</td><td>九江市</td><td>4596</td></tr><tr><td>南京市-伊春市</td><td>0</td><td>南京市</td><td>5769</td></tr><tr><td>南京市-伊春市</td><td>1</td><td>伊春市</td><td>5769</td></tr><tr><td>南京市-保定市</td><td>0</td><td>南京市</td><td>42457</td></tr><tr><td>南京市-保定市</td><td>1</td><td>保定市</td><td>42457</td></tr><tr><td>南京市-克拉玛依市</td><td>0</td><td>南京市</td><td>3755</td></tr><tr><td>南京市-克拉玛依市</td><td>1</td><td>克拉玛依市</td><td>3755</td></tr><tr><td>南京市-包头市</td><td>0</td><td>南京市</td><td>58533</td></tr><tr><td>南京市-包头市</td><td>1</td><td>包头市</td><td>58533</td></tr><tr><td>南京市-十堰市</td><td>0</td><td>南京市</td><td>36475</td></tr><tr><td>南京市-十堰市</td><td>1</td><td>十堰市</td><td>36475</td></tr><tr><td>南京市-南平市</td><td>0</td><td>南京市</td><td>47584</td></tr><tr><td>南京市-南平市</td><td>1</td><td>南平市</td><td>47584</td></tr><tr><td>南京市-台州市</td><td>0</td><td>南京市</td><td>36586</td></tr><tr><td>南京市-台州市</td><td>1</td><td>台州市</td><td>36586</td></tr></tbody></table><p>例如，春运迁徙人员的运动路径如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/647123ff-ec7e-4007-da1f-77b2725cb400/public"                      width = "600"                ><h4 id="流向地图制作"><a href="#流向地图制作" class="headerlink" title="流向地图制作"></a>流向地图制作</h4><ol><li>制作地图组件都需要有地理字段，选择【城市下拉】&gt;【地理角色】&gt;【城市】，将【城市】字段与系统的地理信息相匹配。点击【确定】</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7359cdcd-01cf-4701-70b0-a03d0e2cda00/public"                      width = "600"                ><ol start="2"><li><p>选择图表类型为【流向地图】，将城市经度字段拖入到横轴，城市纬度字段拖入到纵轴，编号字段拖入到连线属性，迁徙线路和城市字段拖入到细粒度属性。</p><p>如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/45cd81aa-dad8-4402-659d-18708122f800/public"                      width = "600"                ></li></ol>  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p>细粒度栏中，【迁徙路线】必须在【城市】上方。</p>  </div><ol start="3"><li>将【迁徙人数】拖入颜色栏中，并将渐变方案更改为【极光】，如此迁徙人数的多少就可以映射到连线的颜色上。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3fa4d11c-02ef-4b42-ca81-cbe233101600/public"                      width = "600"                ><ol start="4"><li>点击【连线】栏，设置连线为【曲线】，标记点为【无】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c33e569c-ea38-458b-e3fd-5e7966e5fe00/public"                      width = "600"                ><ol start="5"><li>对连线属性下的【编号】字段选择【下拉】&gt;【特殊显示】&gt;【闪烁动】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4ae4ef46-c144-4e0c-d16c-ce091f4f1500/public"                      width = "600"                ><ol start="6"><li>点击【添加】，选择闪烁的时间间隔为 8 秒，点击【确定】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9987cb44-8b17-40ae-8b15-4e619e2c8400/public"                      width = "600"                ><ol start="7"><li>点开【背景】，将 GIS 背景改为深蓝。如下图所示</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4bb05cf1-0744-43cf-af6e-795bd275d600/public"                      width = "600"                ><h3 id="热力地图"><a href="#热力地图" class="headerlink" title="热力地图"></a>热力地图</h3><h4 id="热力地图示例"><a href="#热力地图示例" class="headerlink" title="热力地图示例"></a>热力地图示例</h4><p>热力地图用于在地理坐标系范围内，将数据转换成颜色色调，并通过颜色变化程度直观反应出热点分布、区域聚集等数据信息。如下图显示了全国各地区环境监测 PM2.5 的数值高低：</p><p>全国环境监测数据</p><table><thead><tr><th>监测城市</th><th>监测点名称</th><th>PM值</th></tr></thead><tbody><tr><td>北京市</td><td>万寿西宫</td><td>397</td></tr><tr><td>北京市</td><td>定陵</td><td>207</td></tr><tr><td>北京市</td><td>东四</td><td>365</td></tr><tr><td>北京市</td><td>天坛</td><td>352</td></tr><tr><td>北京市</td><td>农展馆</td><td>341</td></tr><tr><td>北京市</td><td>官园</td><td>343</td></tr><tr><td>天津市</td><td>勤俭路</td><td>322</td></tr><tr><td>天津市</td><td>前进路</td><td>273</td></tr><tr><td>天津市</td><td>北辰科技园</td><td>325</td></tr><tr><td>天津市</td><td>跃进路</td><td>278</td></tr><tr><td>天津市</td><td>第四大街</td><td>215</td></tr><tr><td>石家庄市</td><td>职工医院</td><td>448</td></tr><tr><td>石家庄市</td><td>高新区</td><td>473</td></tr><tr><td>石家庄市</td><td>西北水源</td><td>545</td></tr><tr><td>石家庄市</td><td>西南高教</td><td>492</td></tr><tr><td>石家庄市</td><td>世纪公园</td><td>513</td></tr><tr><td>唐山市</td><td>供销社</td><td>297</td></tr><tr><td>唐山市</td><td>雷达站</td><td>333</td></tr><tr><td>唐山市</td><td>物资局</td><td>319</td></tr><tr><td>唐山市</td><td>十二中</td><td>321</td></tr><tr><td>秦皇岛市</td><td>第一关</td><td>255</td></tr><tr><td>秦皇岛市</td><td>市政府</td><td>224</td></tr><tr><td>秦皇岛市</td><td>建设大厦</td><td>275</td></tr><tr><td>邯郸市</td><td>环保局</td><td>395</td></tr><tr><td>邯郸市</td><td>东污水处理厂</td><td>352</td></tr><tr><td>邯郸市</td><td>矿院</td><td>287</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0db317dd-f93a-4cf1-96ad-b391acc4a700/public"                      width = "600"                ><h4 id="热力地图制作"><a href="#热力地图制作" class="headerlink" title="热力地图制作"></a>热力地图制作</h4><ol><li>将待分析区域维度下的字段监测城市转化为地理角色，详细操作请参见 维度转化为地理角色。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2af9be78-4d68-4dec-7705-cd55801a2b00/public"                      width = "600"                ><ol start="2"><li>在图表类型下选择【热力地图】，将【监测城市（经度）】字段拖入横轴，【监测城市（纬度）】字段拖入纵轴。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/23874e7d-2fc4-44e8-2054-a68e70808800/public"                      width = "600"                ><ol start="3"><li>将需要展示的【PM值】指标拖入热力色，【监测点名称】拖入细粒度。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4648814a-f0ac-47e4-179e-df42875e5000/public"                      width = "600"                ><ol start="4"><li>点击【热力色】框体，在弹出的渐变方案中，选择【秋落】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/12d20f23-1eb2-47f9-3846-d938472eb800/public"                      width = "600"                ><h3 id="聚合气泡图"><a href="#聚合气泡图" class="headerlink" title="聚合气泡图"></a>聚合气泡图</h3><h4 id="聚合气泡图示例"><a href="#聚合气泡图示例" class="headerlink" title="聚合气泡图示例"></a>聚合气泡图示例</h4><p>【聚合气泡图】采用力学图的形式展示气泡，可以用来观察数据的分布，将数据映射到气泡的面积大小上。聚合气泡图展示效果如下图所示，用户根据下图可以直观观察出「江苏、上海、山西」的录取人数最多。适用于处理值的分布和数据点的分簇。但是不适合用来查看具体数值，只适合看数据分布。</p><p>各省招生人数表</p><table><thead><tr><th>地区</th><th>年份</th><th>计划招生</th><th>实际录取</th></tr></thead><tbody><tr><td>北京市</td><td>2009年</td><td>63</td><td>47</td></tr><tr><td>北京市</td><td>2010年</td><td>50</td><td>48</td></tr><tr><td>北京市</td><td>2011年</td><td>69</td><td>42</td></tr><tr><td>北京市</td><td>2012年</td><td>54</td><td>43</td></tr><tr><td>北京市</td><td>2013年</td><td>58</td><td>40</td></tr><tr><td>北京市</td><td>2014年</td><td>66</td><td>47</td></tr><tr><td>北京市</td><td>2015年</td><td>64</td><td>41</td></tr><tr><td>北京市</td><td>2016年</td><td>61</td><td>47</td></tr><tr><td>北京市</td><td>2017年</td><td>62</td><td>47</td></tr><tr><td>北京市</td><td>2018年</td><td>58</td><td>44</td></tr><tr><td>天津市</td><td>2009年</td><td>74</td><td>44</td></tr><tr><td>天津市</td><td>2010年</td><td>54</td><td>39</td></tr><tr><td>天津市</td><td>2011年</td><td>66</td><td>49</td></tr><tr><td>天津市</td><td>2012年</td><td>57</td><td>46</td></tr><tr><td>天津市</td><td>2013年</td><td>56</td><td>48</td></tr><tr><td>天津市</td><td>2014年</td><td>59</td><td>38</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/54be10b0-2b10-4779-9259-7c02ccc6e500/public"                      width = "600"                ><h4 id="聚合气泡图制作"><a href="#聚合气泡图制作" class="headerlink" title="聚合气泡图制作"></a>聚合气泡图制作</h4><ol><li>将待分析区域维度下的字段地区拖入维度中，将指标下的字段实际录取拖入指标中，再到图表类型中【选择聚合气泡图】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/35c2ac25-4091-494c-a73f-b57598a8b100/public"                      width = "600"                ><ol start="2"><li>将维度字段地区拖入到颜色栏，使不同分类的数据点显示为不同的颜色</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/074a2451-cc88-4068-1cbe-d3908bd65b00/public"                      width = "600"                ><ol start="3"><li>选择组件样式，取消显示图例，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/28ae554f-242e-4891-8c36-6f9273205800/public"                      width = "600"                ><ol start="4"><li>点击组件样式的大小栏中的【实际录取(求和)】字段，在下拉中选择特殊显示，选择注释，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/75478c6f-4141-4454-ec87-ad272eba9a00/public"                      width = "600"                ><ol start="5"><li>点击添加条件(且)，选择实际录取(求和)最大的N个，在N&#x3D;中填入3，并到右侧+按钮中选择显示【地区】字段：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b770ec85-aa52-4f57-2b8c-309b5becf700/public"                      width = "600"                ><h3 id="变色表格"><a href="#变色表格" class="headerlink" title="变色表格"></a>变色表格</h3><h4 id="变色表格示例"><a href="#变色表格示例" class="headerlink" title="变色表格示例"></a>变色表格示例</h4><p>颜色表格用于展示对应不同维度分类的不同文字颜色，可以用清晰的颜色显示不同维度的数值。但是不适用于维度太多的场景。如下方的合同类型表，使用不同的颜色展示合同是否已经交货，效果如下图所示：</p><p>合同事实表</p><table><thead><tr><th>合同签约时间</th><th>注册时间</th><th>合同ID</th><th>合同付款类型</th><th>合同类型</th><th>客户ID</th><th>是否已经交货</th><th>购买的产品</th><th>购买数量</th><th>合同金额</th></tr></thead><tbody><tr><td>2017-03-07</td><td>2016-07-28</td><td>00115727-e145-44c0-9102-110523699369</td><td>一次性付款</td><td>购买合同</td><td>ff61dfee-1c56-48b6-9f7b-21abef64c96f</td><td>否</td><td>6</td><td>1</td><td>90,000</td></tr><tr><td>2017-07-09</td><td>2016-08-24</td><td>03374c0e-59d1-4158-8ab5-67b48d80d84e</td><td>一次性付款</td><td>购买合同</td><td>d9c85691-1c10-4ef9-8b42-98e1637cab77</td><td>是</td><td>5</td><td>1</td><td>180,000</td></tr><tr><td>2017-09-19</td><td>2017-09-19</td><td>04289ab3-08e3-49d3-9582-4dbb945233e7</td><td>一次性付款</td><td>购买合同</td><td>901aa1ba-ff07-4ff7-a836-4821219c9aae</td><td>是</td><td>2</td><td>1</td><td>180,000</td></tr><tr><td>2017-03-30</td><td>2016-08-11</td><td>04897502-5828-4273-8184-553aa0562930</td><td>一次性付款</td><td>购买合同</td><td>88d567a8-feab-4ce5-8b8a-0cb7f5840179</td><td>是</td><td>2</td><td>1</td><td>260,000</td></tr><tr><td>2017-07-27</td><td>2016-10-24</td><td>056c2ca7-a186-40a4-a8a6-01b38151df57</td><td>一次性付款</td><td>购买合同</td><td>9d7ce8a7-5f9a-4087-be3e-2ed0edf53709</td><td>否</td><td>2</td><td>1</td><td>500,000</td></tr><tr><td>2016-09-21</td><td>2017-09-26</td><td>05bf042a-27f8-4e66-bc0c-9638145fd756</td><td>分期付款</td><td>购买合同</td><td>74643073-3ca1-4cf4-b921-af3e9c83702b</td><td>否</td><td>2</td><td>1</td><td>600,000</td></tr><tr><td>2016-04-07</td><td>2017-08-03</td><td>0692a164-8159-4dda-901b-4003f432d41c</td><td>一次性付款</td><td>购买合同</td><td>de4b48c5-93b6-4af1-abd9-bc4e4499fb11</td><td>是</td><td>1</td><td>1</td><td>130,000</td></tr><tr><td>2017-03-27</td><td>2017-05-06</td><td>080a241d-7372-4921-b171-b9ed2d4a9dd6</td><td>一次性付款</td><td>服务协议</td><td>0e4cf623-44dd-470a-8a39-5bc705c5faf5</td><td>是</td><td>6</td><td>1</td><td>210,000</td></tr><tr><td>2017-08-05</td><td>2017-08-17</td><td>080cd368-af54-447a-a3ae-051425c84bc1</td><td>一次性付款</td><td>购买合同</td><td>6370dee7-6d96-4881-9014-2ba42b674051</td><td>否</td><td>3</td><td>1</td><td>720,000</td></tr><tr><td>2016-03-12</td><td>2017-08-09</td><td>087bab2a-7b5e-4304-808a-830b68556cee</td><td>一次性付款</td><td>购买合同</td><td>ec8cec0b-012f-4b58-84ff-0c889e98f1a0</td><td>是</td><td>5</td><td>1</td><td>150,000</td></tr><tr><td>2017-05-13</td><td>2016-08-25</td><td>08ce15be-bbfd-4c9b-b18f-39eb03e471ca</td><td>分期付款</td><td>购买合同</td><td>456419b5-d3c7-499b-b07b-b868cc68634e</td><td>是</td><td>5</td><td>1</td><td>320,000</td></tr><tr><td>2016-08-05</td><td>2016-08-17</td><td>0a392e38-b72f-46ad-b713-a19e06f6f46e</td><td>一次性付款</td><td>购买合同</td><td>ef35dd55-5306-4380-88ff-5db8847f07be</td><td>否</td><td>3</td><td>1</td><td>200,000</td></tr><tr><td>2017-01-05</td><td>2016-08-12</td><td>0a481a95-5f8f-4a2f-acac-711dcd77ed80</td><td>一次性付款</td><td>长期协议订单</td><td>e210c77c-f1c3-44d2-ad08-fb1b36a8499f</td><td>是</td><td>1</td><td>3</td><td>270,000</td></tr><tr><td>2017-10-15</td><td>2016-11-15</td><td>0c6e4368-0572-40e6-978e-de72b8997d15</td><td>分期付款</td><td>购买合同</td><td>1fb823f6-209e-4484-9919-8844e2e09135</td><td>否</td><td>3</td><td>1</td><td>350,000</td></tr><tr><td>2016-05-25</td><td>2016-08-23</td><td>0cdfd271-6a40-432a-ac04-fcf0e3e029dd</td><td>一次性付款</td><td>购买合同</td><td>5917ef9b-f554-4364-b0ba-524bc7eee0db</td><td>是</td><td>3</td><td>1</td><td>100,000</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7886ce71-07bb-4808-d593-e0bb67273b00/public"                      width = "600"                ><h4 id="颜色表格制作"><a href="#颜色表格制作" class="headerlink" title="颜色表格制作"></a>颜色表格制作</h4><ol><li>将待分析区域维度下的字段【合同类型】、【合同付款类型】拖入维度中，将指标下的字段【合同金额】拖入指标中，并在图表类型下选择【颜色表格】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b4c12686-363a-4c45-b5a8-7bbe930fec00/public"                      width = "600"                ><h3 id="迷你图"><a href="#迷你图" class="headerlink" title="迷你图"></a>迷你图</h3><h4 id="迷你图示例示例"><a href="#迷你图示例示例" class="headerlink" title="迷你图示例示例"></a>迷你图示例示例</h4><p>迷你图可以直观清晰的展现各分类的对应指标数值大小，且简单易行，用于突出显示变量数据的特征。但是变化较为单一，只适合显示单变量。比如下图展示的各访问渠道的浏览量大小。如下图所示</p><p>互联网渠道统计数据</p><table><thead><tr><th>统计日期</th><th>地区</th><th>二级渠道名</th><th>三级渠道名</th><th>一级渠道名</th><th>用户名称</th><th>访问次数</th><th>浏览量</th><th>跳出次数</th><th>总停留时间</th></tr></thead><tbody><tr><td>2015-09-01</td><td>不详市</td><td>基础上线工作</td><td>AppStore</td><td>线上渠道</td><td>雪莉尔</td><td>6</td><td>10</td><td>4</td><td>1,656</td></tr><tr><td>2015-09-01</td><td>阳江市</td><td>微信推广</td><td>微信互推</td><td>新媒体营销</td><td>Benedicte</td><td>5</td><td>6</td><td>4</td><td>648</td></tr><tr><td>2015-09-01</td><td>市辖区</td><td>微博推广</td><td>内容推广</td><td>新媒体营销</td><td>Abigale</td><td>5</td><td>14</td><td>4</td><td>1,512</td></tr><tr><td>2015-09-01</td><td>长春市</td><td>微信推广</td><td>微信互推</td><td>新媒体营销</td><td>Katherine</td><td>2</td><td>12</td><td>4</td><td>1,728</td></tr><tr><td>2015-09-01</td><td>朝阳市</td><td>基础上线工作</td><td>Wap</td><td>线上渠道</td><td>Adalin</td><td>5</td><td>9</td><td>4</td><td>1,548</td></tr><tr><td>2015-09-01</td><td>莱芜市</td><td>品牌基础推广</td><td>百科类</td><td>新媒体营销</td><td>Poppy</td><td>3</td><td>12</td><td>4</td><td>1,440</td></tr><tr><td>2015-09-02</td><td>不详市</td><td>微博推广</td><td>活动推广</td><td>新媒体营销</td><td>Dark Comet</td><td>3</td><td>12</td><td>4</td><td>1,008</td></tr><tr><td>2015-09-02</td><td>中山市</td><td>水货刷机</td><td>水货刷机</td><td>线下渠道</td><td>Ada</td><td>2</td><td>15</td><td>4</td><td>1,260</td></tr><tr><td>2015-09-03</td><td>定西市</td><td>轮台、贴吧推广</td><td>魔趣网</td><td>新媒体营销</td><td>Adah</td><td>2</td><td>10</td><td>4</td><td>396</td></tr><tr><td>2015-09-03</td><td>清远市</td><td>轮台、贴吧推广</td><td>魔趣网</td><td>新媒体营销</td><td>Brewster</td><td>2</td><td>8</td><td>4</td><td>432</td></tr><tr><td>2015-09-03</td><td>中山市</td><td>轮台、贴吧推广</td><td>机锋论坛</td><td>新媒体营销</td><td>Bunny</td><td>3</td><td>14</td><td>4</td><td>1,116</td></tr><tr><td>2015-09-03</td><td>金昌市</td><td>基础上线工作</td><td>Wap</td><td>线上渠道</td><td>Bryana</td><td>5</td><td>12</td><td>4</td><td>288</td></tr><tr><td>2015-09-03</td><td>商洛市</td><td>轮台、贴吧推广</td><td>机锋论坛</td><td>新媒体营销</td><td>Beatrice</td><td>6</td><td>8</td><td>4</td><td>756</td></tr><tr><td>2015-09-04</td><td>阜阳市</td><td>手机厂商预装</td><td>手机厂商预装</td><td>线下渠道</td><td>Bethel</td><td>1</td><td>10</td><td>4</td><td>648</td></tr><tr><td>2015-09-04</td><td>新竹市</td><td>水货刷机</td><td>水货刷机</td><td>线下渠道</td><td>Abrianna</td><td>1</td><td>14</td><td>4</td><td>792</td></tr><tr><td>2015-09-04</td><td>铁岭市</td><td>微信推广</td><td>小号积累</td><td>新媒体营销</td><td>Caitlin</td><td>5</td><td>6</td><td>4</td><td>396</td></tr><tr><td>2015-09-04</td><td>清远市</td><td>轮台、贴吧推广</td><td>魔趣网</td><td>新媒体营销</td><td>希尔顿</td><td>5</td><td>10</td><td>4</td><td>1,584</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3f8b2168-c130-42ac-50e4-4b293b140100/public"                      width = "600"                ><h4 id="迷你图制作"><a href="#迷你图制作" class="headerlink" title="迷你图制作"></a>迷你图制作</h4><ol><li>将待分析区域维度下的字段【一级渠道名】、【二级渠道名】拖入维度中，将指标下的字段浏览量拖入指标中，在图表类型下选择【迷你图】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/151c421a-4c26-42d4-24a0-d53fd241bf00/public"                      width = "600"                ><ol start="2"><li>选择该图表类型后，【浏览量】字段被添加到大小属性中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a25888aa-4495-4f8a-5b26-ecf30f55b000/public"                      width = "600"                ><ol start="3"><li>点击形状，可以为数据点选择不同的形状。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/022ca887-dc93-4e9e-bbd0-02e58d8fc500/public"                      width = "600"                ><h3 id="矩形树图"><a href="#矩形树图" class="headerlink" title="矩形树图"></a>矩形树图</h3><h4 id="矩形树图示例"><a href="#矩形树图示例" class="headerlink" title="矩形树图示例"></a>矩形树图示例</h4><p>矩形树图是用来描述层次结构数据的占比关系，能够进行逐级钻取显示下层数据情况。用于展示具有层级关系的数据，能够直观体现同级之间的比较，但是不适合层级关系不明确或者分类较多的数据</p><p>例如展示合同金额的情况：同一种颜色表示一个年份，同一种颜色种的每一个方块代表一类产品。哪一年哪一种产品的合同金额的大小可以通过矩形块的大小直观展示。效果如下图所示：</p><p>KPI指标项</p><table><thead><tr><th>合同签约时间</th><th>产品名称</th><th>购买数量</th><th>合同金额</th><th>回款金额</th></tr></thead><tbody><tr><td>2016-01-18</td><td>宝钢罗泾预矫直机</td><td>1</td><td>1,200,000</td><td>1,200,000</td></tr><tr><td>2016-08-01</td><td>梅钢1650连铸</td><td>1</td><td>100,800</td><td>100,800</td></tr><tr><td>2016-04-01</td><td>宝钢罗泾预矫直机</td><td>1</td><td>430,000</td><td>430,000</td></tr><tr><td>2016-01-18</td><td>梅钢1650连铸</td><td>1</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-08</td><td>俄罗斯N钢牌坊</td><td>1</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-14</td><td>梅钢1650连铸</td><td>1</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-05-05</td><td>俄罗斯N钢牌坊</td><td>1</td><td>285,000</td><td>285,000</td></tr><tr><td>2016-04-21</td><td>宝钢罗泾预矫直机</td><td>1</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-06-01</td><td>涟钢RH氧枪备件</td><td>1</td><td>520,000</td><td>520,000</td></tr><tr><td>2016-04-29</td><td>梅钢1650连铸</td><td>1</td><td>240,000</td><td>240,000</td></tr><tr><td>2016-04-29</td><td>俄罗斯N钢牌坊</td><td>1</td><td>450,000</td><td>450,000</td></tr><tr><td>2016-04-25</td><td>宝钢罗泾预矫直机</td><td>1</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-05-04</td><td>福建福欣热轧</td><td>1</td><td>1,200,000</td><td>1,080,000</td></tr><tr><td>2016-04-27</td><td>宝钢罗泾预矫直机</td><td>1</td><td>600,000</td><td>600,000</td></tr><tr><td>2015-03-22</td><td>俄罗斯N钢牌坊</td><td>1</td><td>400,000</td><td>400,000</td></tr><tr><td>2016-06-19</td><td>俄罗斯N钢牌坊</td><td>1</td><td>480,000</td><td>480,000</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3715b0df-16db-48e5-7933-eaf983d14d00/public"                      width = "600"                ><h4 id="矩形树图制作"><a href="#矩形树图制作" class="headerlink" title="矩形树图制作"></a>矩形树图制作</h4><ol><li>将待分析区域维度下的合同签约时间、产品名称拖入维度中，将指标下的字段合同金额拖入指标中：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ac3d3cbf-66db-4741-59c0-3715a91b1600/public"                      width = "600"                ><ol start="2"><li>在图表类型下选择【矩形树图】，选择该图表类型后，维度字段按照顺序被添加到细粒度中，指标字段添加到大小属性中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b6a9cdc8-f744-48c1-ce34-99f406ee2700/public"                      width = "600"                ><ol start="3"><li>将【合同签约时间】移动至颜色栏，点击下拉箭头，切换至年显示，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bce0ac41-66ad-41e3-8195-6e0fec602e00/public"                      width = "600"                >  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p>此处矩形树图的排列逻辑为：从左上到右下，依次表示数值从大到小。在没有大小比较时，排列顺序为总是选择矩形块长宽比接近于1的方式排布，排序方式默认不支持更改。</p>  </div><h3 id="词云"><a href="#词云" class="headerlink" title="词云"></a>词云</h3><h4 id="词云示例"><a href="#词云示例" class="headerlink" title="词云示例"></a>词云示例</h4><p>词云是一种直观展示数据频率的图表类型，可以对出现频率较高的「关键词」予以视觉上的突出，形成「关键词云层」，从而过滤掉大量的文本信息，使浏览者只要一眼扫过文本就可以领略重点。适合展现数据量区分度较大的多分类文字数据，直观地表现出现高词频内容。但是不适合展示数据区分度不大的数据。</p><p>可应用于制作用户画像，对用户进行聚类，分析话题热度，实现精细化营销等。如下图所示：</p><p>搜索词汇统计表</p><table><thead><tr><th>搜索词</th><th>搜索次数</th></tr></thead><tbody><tr><td>FineBI</td><td>3,266</td></tr><tr><td>Spider</td><td>3,044</td></tr><tr><td>帆软</td><td>1,710</td></tr><tr><td>仪表板</td><td>455</td></tr><tr><td>数据挖掘</td><td>512</td></tr><tr><td>快速挖掘</td><td>220</td></tr><tr><td>R语言分析</td><td>313</td></tr><tr><td>时序预测</td><td>248</td></tr><tr><td>聚类</td><td>280</td></tr><tr><td>分类</td><td>175</td></tr><tr><td>行业化</td><td>654</td></tr><tr><td>生态圈</td><td>1,110</td></tr><tr><td>数据决策系统</td><td>477</td></tr><tr><td>矩形树图</td><td>436</td></tr><tr><td>数据库</td><td>387</td></tr><tr><td>论坛</td><td>1,510</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f96fb3c9-395f-4bd2-10ee-79b669dd7800/public"                      width = "600"                ><h4 id="词云制作"><a href="#词云制作" class="headerlink" title="词云制作"></a>词云制作</h4><ol><li>将【搜索词】字段拖入维度栏中，【搜索次数】字段拖入指标栏中，在图表类型下选择【词云】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9559972b-78a4-46f2-3e57-d86dfc109600/public"                      width = "600"                ><ol start="2"><li>选择词云图表类型后，【搜索次数】字段被添加到大小属性中，【搜索词】字段被添加到文本字段中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a47b0aeb-8131-4489-69a3-920c56ec1200/public"                      width = "600"                ><ol start="3"><li>将【搜索次数】字段拖入到颜色属性栏中，渐变类型选择【区域渐变】，渐变方案选择【极光】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/77339bec-6f8e-48b5-5c3c-42173ebee300/public"                      width = "600"                ><ol start="4"><li>点击【大小】栏，可以调整词云文字的字号大小。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/20da42f2-d9fd-429d-5b1d-4c6d84f51f00/public"                      width = "600"                ><h3 id="漏斗图"><a href="#漏斗图" class="headerlink" title="漏斗图"></a>漏斗图</h3><h4 id="漏斗图示例"><a href="#漏斗图示例" class="headerlink" title="漏斗图示例"></a>漏斗图示例</h4><p>漏斗图是一种直观表现业务流程中转化情况的分析工具。</p><p>漏斗图适用于业务流程比较规范、周期长、环节多的流程分析，使用梯形面积表示某个环节业务量与上一个环节之间的差异。适用于展示随流程变化的分类数据。但是不适合表示无逻辑顺序的分类对比。</p><p>漏斗图从上到下，有逻辑上的顺序关系，表现了随着业务流程的推进业务目标完成的情况。如下图所示：</p><p>漏斗图示例数据</p><table><thead><tr><th>步骤</th><th>人数</th></tr></thead><tbody><tr><td>查看商品</td><td>12452</td></tr><tr><td>试用商品</td><td>7832</td></tr><tr><td>咨询价格</td><td>5678</td></tr><tr><td>发送合同</td><td>4563</td></tr><tr><td>购买商品</td><td>2354</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/52e5589d-cbdf-44da-e663-e7aecc4f0700/public"                      width = "600"                ><h4 id="漏斗图制作"><a href="#漏斗图制作" class="headerlink" title="漏斗图制作"></a>漏斗图制作</h4><ol><li>将【步骤】字段拖入到维度中，将【人数】字段拖入到指标中。再到图表类型下选择【漏斗图】。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8d892b41-bbe1-4e2a-6161-76274db92600/public"                      width = "600"                ><ol start="2"><li>在细粒度栏对【步骤】按人数进行降序。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bcf94bb2-399c-45f3-4247-23f6557e5e00/public"                      width = "600"                ><ol start="3"><li>设置标签，在标签栏拖入【步骤】、【人数】字段。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d95534df-49c5-419b-7ca4-b94e03434d00/public"                      width = "600"                ><h3 id="箱形图-箱线图"><a href="#箱形图-箱线图" class="headerlink" title="箱形图&#x2F;箱线图"></a>箱形图&#x2F;箱线图</h3><h4 id="箱形图-箱线图示例"><a href="#箱形图-箱线图示例" class="headerlink" title="箱形图&#x2F;箱线图示例"></a>箱形图&#x2F;箱线图示例</h4><p>箱形图（Box-plot）又称为盒须图、盒式图或箱线图，是一种用作显示一组数据分散情况资料的统计图，因形状如箱子而得名。在各种领域也经常被使用，常见于品质管理。它主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比较。通过箱形图我们可以观察数据是否有偏向性、是否对称、数据是否有异常值、数据分布是否太过密集等。</p><p>当需要了解数据分布特征或需要查看数据中的异常值时，可以使用箱形图进行数据分析。箱形图最常见用于质量管理、人事测评、探索性数据分析等统计分析活动。</p><p>箱型图通常用于显示一组连续型数据分布情况的统计图。但是不适用批量较大的数据；不适用于表示趋势或者百分比的数据。</p><p>箱型图最大的优点就是不受异常值的影响，能准确稳定地描绘出数据的离散分布情况。</p><p>箱形图构成：<br>箱子的中间有一条线，代表了数据的中位数( Q2 )。箱子的上下底，分别是数据的上四分位数（Q3）和下四分位数（Q1），这意味着箱体包含了 50% 的数据。</p><p>有关箱形图 Q1、Q2、Q3 这三个指标的介绍和计算方法，详情参见统计学概念 四分位数 </p><p>因此，箱子的高度在一定程度上反映了数据的波动程度。上下边缘则代表了该组数据的最大值和最小值。超出最大值和低于最小值的点，可以理解为数据中的“异常值”。</p><p>销量表</p><table><thead><tr><th>省份</th><th>城市</th><th>销量</th></tr></thead><tbody><tr><td>河南省</td><td>郑州</td><td>130987</td></tr><tr><td>河南省</td><td>驻马店</td><td>119234</td></tr><tr><td>江苏省</td><td>南京</td><td>143567</td></tr><tr><td>江苏省</td><td>无锡</td><td>167890</td></tr><tr><td>浙江省</td><td>杭州市</td><td>245671</td></tr><tr><td>浙江省</td><td>宁波市</td><td>198764</td></tr><tr><td>湖南省</td><td>长沙市</td><td>167893</td></tr><tr><td>湖南省</td><td>岳阳市</td><td>123456</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/db4522a7-8bd9-4735-54d4-69dae4a94400/public"                      width = "600"                ><h4 id="箱形图-箱线图制作"><a href="#箱形图-箱线图制作" class="headerlink" title="箱形图&#x2F;箱线图制作"></a>箱形图&#x2F;箱线图制作</h4><h5 id="案例一-不显示异常值"><a href="#案例一-不显示异常值" class="headerlink" title="案例一 不显示异常值"></a>案例一 不显示异常值</h5><ol><li>在图表类型下选择【箱形图】，将【省份】字段拖入到横轴中，【销量】字段拖入到纵轴中，【城市】字段拖入到细粒度中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7e02d761-50dc-450d-bc36-fae333361100/public"                      width = "600"                ><ol start="2"><li>将【省份】字段拖入到颜色栏中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f43109fd-a873-412e-23a3-99dcb855d800/public"                      width = "600"                ><h5 id="案例二-显示异常值"><a href="#案例二-显示异常值" class="headerlink" title="案例二 显示异常值"></a>案例二 显示异常值</h5><p>合同事实表1</p><table><thead><tr><th>合同签约时间</th><th>注册时间</th><th>合同ID</th><th>合同付款类型</th><th>合同类型</th><th>客户ID</th><th>是否已经交货</th><th>购买的产品</th><th>购买数量</th><th>总金额</th></tr></thead><tbody><tr><td>2017-03-07</td><td>2016-07-28</td><td>00115727-e145-44c0-9102-110523699369</td><td>一次性付款</td><td>购买合同</td><td>ff61dfee-1c56-48b6-9f7b-21abef64c96f</td><td>否</td><td>6</td><td>1</td><td>90,000</td></tr><tr><td>2017-07-09</td><td>2016-08-24</td><td>03374c0e-59d1-4158-8ab5-67b48d80d84e</td><td>一次性付款</td><td>购买合同</td><td>d9c85691-1c10-4ef9-8b42-98e1637cab77</td><td>是</td><td>5</td><td>1</td><td>180,000</td></tr><tr><td>2017-09-19</td><td>2017-09-19</td><td>04289ab3-08e3-49d3-9582-4dbb945233e7</td><td>一次性付款</td><td>购买合同</td><td>901aa1ba-ff07-4ff7-a836-4821219c9aae</td><td>是</td><td>2</td><td>1</td><td>180,000</td></tr><tr><td>2017-03-30</td><td>2016-08-11</td><td>04897502-5828-4273-8184-553aa0562930</td><td>一次性付款</td><td>购买合同</td><td>88d567a8-feab-4ce5-8b8a-0cb7f5840179</td><td>是</td><td>2</td><td>1</td><td>260,000</td></tr><tr><td>2017-07-27</td><td>2016-10-24</td><td>056c2ca7-a186-40a4-a8a6-01b38151df57</td><td>一次性付款</td><td>购买合同</td><td>9d7ce8a7-5f9a-4087-be3e-2ed0edf53709</td><td>否</td><td>2</td><td>1</td><td>500,000</td></tr><tr><td>2016-09-21</td><td>2017-09-26</td><td>05bf042a-27f8-4e66-bc0c-9638145fd756</td><td>分期付款</td><td>购买合同</td><td>74643073-3ca1-4cf4-b921-af3e9c83702b</td><td>否</td><td>2</td><td>1</td><td>600,000</td></tr><tr><td>2016-04-07</td><td>2017-08-03</td><td>0692a164-8159-4dda-901b-4003f432d41c</td><td>一次性付款</td><td>购买合同</td><td>de4b48c5-93b6-4af1-abd9-bc4e4499fb11</td><td>是</td><td>1</td><td>1</td><td>130,000</td></tr><tr><td>2017-03-27</td><td>2017-05-06</td><td>080a241d-7372-4921-b171-b9ed2d4a9dd6</td><td>一次性付款</td><td>服务协议</td><td>0e4cf623-44dd-470a-8a39-5bc705c5faf5</td><td>是</td><td>6</td><td>1</td><td>210,000</td></tr><tr><td>2017-08-05</td><td>2017-08-17</td><td>080cd368-af54-447a-a3ae-051425c84bc1</td><td>一次性付款</td><td>购买合同</td><td>6370dee7-6d96-4881-9014-2ba42b674051</td><td>否</td><td>3</td><td>1</td><td>720,000</td></tr><tr><td>2016-03-12</td><td>2017-08-09</td><td>087bab2a-7b5e-4304-808a-830b68556cee</td><td>一次性付款</td><td>购买合同</td><td>ec8cec0b-012f-4b58-84ff-0c889e98f1a0</td><td>是</td><td>5</td><td>1</td><td>150,000</td></tr><tr><td>2017-05-13</td><td>2016-08-25</td><td>08ce15be-bbfd-4c9b-b18f-39eb03e471ca</td><td>分期付款</td><td>购买合同</td><td>456419b5-d3c7-499b-b07b-b868cc68634e</td><td>是</td><td>5</td><td>1</td><td>320,000</td></tr><tr><td>2016-08-05</td><td>2016-08-17</td><td>0a392e38-b72f-46ad-b713-a19e06f6f46e</td><td>一次性付款</td><td>购买合同</td><td>ef35dd55-5306-4380-88ff-5db8847f07be</td><td>否</td><td>3</td><td>1</td><td>200,000</td></tr><tr><td>2017-01-05</td><td>2016-08-12</td><td>0a481a95-5f8f-4a2f-acac-711dcd77ed80</td><td>一次性付款</td><td>长期协议订单</td><td>e210c77c-f1c3-44d2-ad08-fb1b36a8499f</td><td>是</td><td>1</td><td>3</td><td>270,000</td></tr><tr><td>2017-10-15</td><td>2016-11-15</td><td>0c6e4368-0572-40e6-978e-de72b8997d15</td><td>分期付款</td><td>购买合同</td><td>1fb823f6-209e-4484-9919-8844e2e09135</td><td>否</td><td>3</td><td>1</td><td>350,000</td></tr><tr><td>2016-05-25</td><td>2016-08-23</td><td>0cdfd271-6a40-432a-ac04-fcf0e3e029dd</td><td>一次性付款</td><td>购买合同</td><td>5917ef9b-f554-4364-b0ba-524bc7eee0db</td><td>是</td><td>3</td><td>1</td><td>100,000</td></tr></tbody></table><ol><li>图表类型下选择【自定义图表】，将【合同类型】字段拖入横轴，【购买的产品】字段拖进纵轴两次。图形属性下，两个指标字段，图表类型分别选择【箱形图】和【点】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6aa248cd-b6db-4ab3-64f6-02807a10cf00/public"                      width = "600"                ><ol start="2"><li>图形属性下，点开【全部】，将【客户ID】字段拖入细粒度中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/49e386fe-6771-466f-b3ab-2f78df1da300/public"                      width = "600"                ><ol start="3"><li>在图形属性下，点开对应点类型的指标字段，调整点大小。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b915060a-33d0-4b26-7b5b-adc535525b00/public"                      width = "600"                ><ol start="4"><li>设置纵轴最大值为 60 ，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/76da75a2-0f57-41f9-a711-8871f3203400/public"                      width = "600"                ><p>结论：购买合同和长期协议订单，存在异常点，需要对异常值进行关注</p><h3 id="桑基图"><a href="#桑基图" class="headerlink" title="桑基图"></a>桑基图</h3><h4 id="桑基图示例"><a href="#桑基图示例" class="headerlink" title="桑基图示例"></a>桑基图示例</h4><p>桑基图多用于表示数据的流向。用两组数据构成多个坐标点，考察坐标点的分布，判断多变量之间是否存在某种关联或总结坐标点的分布模式。通常应用于能源、材料成分、金融和网站用户流量等数据的可视化分析。桑基图使人们易于发现系统流程中的细节；帮助识别主要的组成部分和低效的地方。但是不适用于起始流量和结束流量不同的数据</p><p>例如，有一家做海鲜批发生意的供应商，给全国各地的门店根据订单要求发货。商家想要预测未来哪些海鲜需要多补充库存，但不知道订单的情况，到底哪些海鲜的订单较多，都卖到了哪里。</p><p>现在想分析一下销售最好的5款海鲜是哪几个，都是在哪些门店卖出去的。我们通过桑基图，能看到每个产品，流向的门店，线的粗细，代表流向的多少。如下图所示：【区域地图】是一种使用不同深浅的颜色来展示数据的大小和分布范围的可视化图形。适合展示数据在地理区块空间的分布状况，使用颜色深浅来区分数值大小。</p><p>订单销售明细表</p><table><thead><tr><th>订单日期</th><th>发货日期</th><th>产品编码</th><th>产品名称</th><th>门店编号</th><th>门店名称</th><th>订单编号</th><th>订单金额</th><th>实付金额</th></tr></thead><tbody><tr><td>2022-01-01</td><td>2022-01-01</td><td>B012</td><td>龙虾</td><td>A0005</td><td>杭州店</td><td>10,130,478,523</td><td>3,739</td><td>3,176</td></tr><tr><td>2022-01-01</td><td>2022-01-01</td><td>B015</td><td>黄鱼</td><td>A0001</td><td>深圳店</td><td>10,130,478,536</td><td>497</td><td>371</td></tr><tr><td>2022-01-01</td><td>2022-01-01</td><td>B002</td><td>鱿鱼</td><td>A0003</td><td>北京店</td><td>10,130,478,559</td><td>986</td><td>677</td></tr><tr><td>2022-01-01</td><td>2022-01-04</td><td>B011</td><td>墨鱼</td><td>A0001</td><td>深圳店</td><td>10,130,478,576</td><td>2,020</td><td>1,727</td></tr><tr><td>2022-01-01</td><td>2022-01-01</td><td>B017</td><td>干贝</td><td>A0005</td><td>杭州店</td><td>10,130,478,578</td><td>322</td><td>267</td></tr><tr><td>2022-01-01</td><td>2022-01-02</td><td>B009</td><td>虾米</td><td>A0001</td><td>深圳店</td><td>10,130,478,582</td><td>180</td><td>152</td></tr><tr><td>2022-01-01</td><td>2022-01-01</td><td>B011</td><td>墨鱼</td><td>A0004</td><td>广州店</td><td>10,130,478,635</td><td>813</td><td>547</td></tr><tr><td>2022-01-01</td><td>2022-01-05</td><td>B017</td><td>干贝</td><td>A0003</td><td>北京店</td><td>10,130,478,640</td><td>705</td><td>511</td></tr><tr><td>2022-01-02</td><td>2022-01-04</td><td>B009</td><td>虾米</td><td>A0001</td><td>深圳店</td><td>10,130,478,666</td><td>220</td><td>154</td></tr><tr><td>2022-01-02</td><td>2022-01-03</td><td>B004</td><td>盐水鸭</td><td>A0003</td><td>北京店</td><td>10,130,478,673</td><td>169</td><td>127</td></tr><tr><td>2022-01-02</td><td>2022-01-02</td><td>B001</td><td>猪肉</td><td>A0002</td><td>上海店</td><td>10,130,478,681</td><td>779</td><td>499</td></tr><tr><td>2022-01-02</td><td>2022-01-02</td><td>B007</td><td>蟹</td><td>A0004</td><td>广州店</td><td>10,130,478,691</td><td>6,833</td><td>5,257</td></tr><tr><td>2022-01-02</td><td>2022-01-03</td><td>B016</td><td>海参</td><td>A0004</td><td>广州店</td><td>10,130,478,693</td><td>6,149</td><td>3,877</td></tr><tr><td>2022-01-02</td><td>2022-01-03</td><td>B001</td><td>猪肉</td><td>A0001</td><td>深圳店</td><td>10,130,478,714</td><td>403</td><td>379</td></tr><tr><td>2022-01-02</td><td>2022-01-03</td><td>B012</td><td>龙虾</td><td>A0001</td><td>深圳店</td><td>10,130,478,732</td><td>4,913</td><td>4,712</td></tr><tr><td>2022-01-02</td><td>2022-01-02</td><td>B008</td><td>虾子</td><td>A0005</td><td>杭州店</td><td>10,130,478,734</td><td>633</td><td>396</td></tr></tbody></table><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/14e17a38-850a-4536-e829-1fcef3616500/public"                      width = "600"                ><h4 id="桑基图制作"><a href="#桑基图制作" class="headerlink" title="桑基图制作"></a>桑基图制作</h4><ol><li>在图表类型下选择「桑基图」，将「产品名称」字段拖入到起点栏，「门店名称」字段拖入到终点栏，「订单金额」字段拖入到大小栏。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/29e2ebfa-7a61-4eec-58d2-111f9e44a000/public"                      width = "600"                >  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p>数据表中的 0 值或负值会过滤不绘制。</p>  </div><ol start="2"><li>下拉【产品名称】，添加过滤条件，过滤出【订单金额】最大的 5 个产品。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1c357910-779b-4ea8-91b2-ea581f534900/public"                      width = "600"                ><ol start="3"><li>用不同颜色区分不同产品流向。将【产品名称】字段拖入到颜色栏中。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ec0a1b92-7061-4d81-a06f-e419d93c6600/public"                      width = "600"                ><ol start="4"><li>添加起点终点的图形标签。点击【标签设置】&gt;【显示节点名称】。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9aabca02-34e3-4a82-0699-387ccc1a8d00/public"                      width = "600"                ><h5 id="多节点示例"><a href="#多节点示例" class="headerlink" title="多节点示例"></a>多节点示例</h5><p>桑基图</p><table><thead><tr><th>source</th><th>target</th><th>人数</th></tr></thead><tbody><tr><td>男</td><td>华为</td><td>1,100</td></tr><tr><td>男</td><td>苹果</td><td>730</td></tr><tr><td>男</td><td>小米</td><td>680</td></tr><tr><td>男</td><td>OPPO</td><td>630</td></tr><tr><td>男</td><td>vivo</td><td>530</td></tr><tr><td>男</td><td>其他</td><td>1,630</td></tr><tr><td>女</td><td>华为</td><td>680</td></tr><tr><td>女</td><td>苹果</td><td>1,080</td></tr><tr><td>女</td><td>小米</td><td>370</td></tr><tr><td>女</td><td>OPPO</td><td>850</td></tr><tr><td>女</td><td>vivo</td><td>630</td></tr><tr><td>女</td><td>其他</td><td>1,090</td></tr><tr><td>华为</td><td>45岁以上</td><td>135</td></tr><tr><td>华为</td><td>35-44岁</td><td>319</td></tr><tr><td>华为</td><td>25-34岁</td><td>986</td></tr></tbody></table><ul><li><p>source：表示数据流出的起点</p></li><li><p>target：表示数据流向的终点</p></li><li><p>人数：衡量流量的大小</p></li></ul><p>例如，从【性别&gt;使用的手机品牌&gt;年龄】的手机使用人群的流量分析。手机品牌既是起点也是终点，在【source】(来源）会存在多次数据。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ee719bbe-2e93-4de1-d4cd-d81be407f900/public"                      width = "600"                ><ol start="2"><li>依次拖入【source、target、人】」字段。因为人数是从 source 流向 target ，所以 source 在前面。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8bb28c46-064a-46b9-8ce5-b448debc4400/public"                      width = "600"                ><ol start="3"><li>点击【桑基图】，自动生成图表，字段调整到对应位置。这样就生成了多节点桑基图如下图所示：</li></ol><p>​若希望显示节点名称，在【图表属性】点击【标签】设置【显示节点名称】即可。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a771cce2-e188-4a5d-b412-cd9b7d348000/public"                      width = "600"                ><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h4 id="分组表"><a href="#分组表" class="headerlink" title="分组表"></a>分组表</h4><h5 id="分组表示例"><a href="#分组表示例" class="headerlink" title="分组表示例"></a>分组表示例</h5><p>分组表是有一个【行表头维度】和【数值指标数据】组成的分组报表，没有列表头。</p><p>集团销售总表</p><table><thead><tr><th>日期</th><th>城市</th><th>单据编码</th><th>门店编码</th><th>门店名称</th><th>商品编码</th><th>商品类别</th><th>商品名称</th><th>省份</th><th>成本额</th><th>数量</th><th>销售额</th></tr></thead><tbody><tr><td>2020-01-01</td><td>白山市</td><td>SMDBJ18000010</td><td>D010112</td><td>白山店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>鹤岗市</td><td>SMDBJ18000014</td><td>D010114</td><td>鹤岗店</td><td>62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6</td><td>零食</td><td>三全960g奶香馒头</td><td>黑龙江省</td><td>998.56</td><td>120</td><td>2,461.54</td></tr><tr><td>2020-01-01</td><td>鹤岗市</td><td>SMDBJ18000014</td><td>D010114</td><td>鹤岗店</td><td>BE2DA7F0-1E24-4729-BED3-3CDC0A2E4918</td><td>零食</td><td>嘉士利115g威化饼</td><td>黑龙江省</td><td>1,033.47</td><td>100</td><td>3,119.66</td></tr><tr><td>2020-01-01</td><td>辽源市</td><td>SMDBJ18000015</td><td>D010115</td><td>辽源店</td><td>62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6</td><td>零食</td><td>三全960g奶香馒头</td><td>吉林省</td><td>1,664.27</td><td>200</td><td>4,102.56</td></tr><tr><td>2020-01-01</td><td>辽源市</td><td>SMDBJ18000015</td><td>D010115</td><td>辽源店</td><td>AE451BC0-8615-4F8C-8126-05E0C01DDF24</td><td>零食</td><td>丽芝士散装系列</td><td>吉林省</td><td>950.36</td><td>100</td><td>2,948.72</td></tr><tr><td>2020-01-01</td><td>辽源市</td><td>SMDBJ18000015</td><td>D010115</td><td>辽源店</td><td>77DA67A0-ED8C-4FB3-8E04-E9EA7DD96BE8</td><td>零食</td><td>养乐多100ml*5乳酸菌</td><td>吉林省</td><td>573.88</td><td>50</td><td>2,094.02</td></tr><tr><td>2020-01-01</td><td>辽源市</td><td>SMDBJ18000015</td><td>D010115</td><td>辽源店</td><td>BE2DA7F0-1E24-4729-BED3-3CDC0A2E4918</td><td>零食</td><td>嘉士利115g威化饼</td><td>吉林省</td><td>516.73</td><td>50</td><td>1,559.83</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>12EF7049-C847-4A7F-A5B4-C0BEDDADAA81</td><td>生鲜</td><td>西红柿</td><td>吉林省</td><td>240.17</td><td>12</td><td>605.13</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>59F35931-24BA-46DC-9551-6744A16FC87B</td><td>生鲜</td><td>本地小白菜</td><td>吉林省</td><td>542.68</td><td>40</td><td>2,017.09</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>E5EA2E2A-DC19-4D47-BF0F-F29CC467A5C0</td><td>日用品</td><td>家之寓圆形24夹晒架</td><td>吉林省</td><td>252</td><td>100</td><td>1,025.64</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>E5EA2E2A-DC19-4D47-BF0F-F29CC467A5C0</td><td>日用品</td><td>家之寓圆形24夹晒架</td><td>吉林省</td><td>26.23</td><td>10</td><td>135.9</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6</td><td>零食</td><td>三全960g奶香馒头</td><td>吉林省</td><td>1,248.2</td><td>150</td><td>3,076.92</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>AE451BC0-8615-4F8C-8126-05E0C01DDF24</td><td>零食</td><td>丽芝士散装系列</td><td>吉林省</td><td>1,425.54</td><td>150</td><td>4,423.08</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>77DA67A0-ED8C-4FB3-8E04-E9EA7DD96BE8</td><td>零食</td><td>养乐多100ml*5乳酸菌</td><td>吉林省</td><td>1,342.88</td><td>117</td><td>4,900</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>CBB40A41-178E-44F7-BD5E-9ECD8B73978A</td><td>零食</td><td>格力高55g草莓味百奇</td><td>吉林省</td><td>309.43</td><td>21</td><td>807.69</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr></tbody></table><p>分组表按照行表头拖拽的维度分组，对指标内的数据进行汇总统计。如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c3ae870c-c976-4101-87f8-2601e0d2b200/public"                      width = "600"                ><h5 id="分组表制作"><a href="#分组表制作" class="headerlink" title="分组表制作"></a>分组表制作</h5><ol><li>在图表类型中选择【分组表】，将【品类描述】、【店风格】字段拖入维度区域，将【销售额】、【记录数】字段拖入指标区域，并在【组件样式&gt;格式】中，【展开行表头节点】，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9209c38f-00f0-47a5-59bd-640564313100/public"                      width = "600"                ><h5 id="创建毛利额字段"><a href="#创建毛利额字段" class="headerlink" title="创建毛利额字段"></a>创建毛利额字段</h5><ol start="2"><li>点击【…】,【添加计算字段】，创建毛利额字段，公式如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c755e460-2b76-4cd9-d9ce-61aed3a6e300/public"                      width = "600"                ><h5 id="设置组件样式"><a href="#设置组件样式" class="headerlink" title="设置组件样式"></a>设置组件样式</h5><ol start="3"><li>若需要设置表格的展示方式，可选择【组件样式】，根据自己的需求设置，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/592381cd-954e-4c39-7caa-c159fa315a00/public"                      width = "600"                ><h5 id="修改组件名称"><a href="#修改组件名称" class="headerlink" title="修改组件名称"></a>修改组件名称</h5><ol start="4"><li>在组件编辑下方重命名组件标题，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/04699dec-0675-4dfb-711d-5be19755f100/public"                      width = "600"                ><h4 id="交叉表"><a href="#交叉表" class="headerlink" title="交叉表"></a>交叉表</h4><h5 id="交叉表示例"><a href="#交叉表示例" class="headerlink" title="交叉表示例"></a>交叉表示例</h5><p>交叉表是指由「行维度」、「列维度」以及「数值区域」组成的较为复杂的报表。</p><p>用户多用来显示表中某个字段的汇总值，并将它们分组。其中一组为行维度-在数据表的左侧，另一组列维度-在数据表的上部。行和列的交叉处即「数值区域」可以对数据进行多种汇总计算，比如求和、平均值、记数、最大值、最小值等。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1b6caa7c-ff5b-473a-972d-27caa9929c00/public"                      width = "600"                ><p>合同事实表：</p><table><thead><tr><th>合同ID</th><th>客户ID</th><th>合同类型</th><th>合同金额</th><th>合同付款类型</th><th>注册时间</th><th>购买数量</th><th>合同签约时间</th><th>购买的产品</th><th>是否已经交货</th></tr></thead><tbody><tr><td>00115727-e145-44c0-9102-110523699369</td><td>ff61dfee-1c56-48b6-9f7b-21abef64c96f</td><td>购买合同</td><td>90,000</td><td>一次性付款</td><td>2016-07-28</td><td>1</td><td>2017-03-07</td><td>6</td><td>否</td></tr><tr><td>03374c0e-59d1-4158-8ab5-67b48d80d84e</td><td>d9c85691-1c10-4ef9-8b42-98e1637cab77</td><td>购买合同</td><td>180,000</td><td>一次性付款</td><td>2016-08-24</td><td>1</td><td>2017-07-09</td><td>5</td><td>是</td></tr><tr><td>04289ab3-08e3-49d3-9582-4dbb945233e7</td><td>901aa1ba-ff07-4ff7-a836-4821219c9aae</td><td>购买合同</td><td>180,000</td><td>一次性付款</td><td>2017-09-19</td><td>1</td><td>2017-09-19</td><td>2</td><td>是</td></tr><tr><td>04897502-5828-4273-8184-553aa0562930</td><td>88d567a8-feab-4ce5-8b8a-0cb7f5840179</td><td>购买合同</td><td>260,000</td><td>一次性付款</td><td>2016-08-11</td><td>1</td><td>2017-03-30</td><td>2</td><td>是</td></tr><tr><td>056c2ca7-a186-40a4-a8a6-01b38151df57</td><td>9d7ce8a7-5f9a-4087-be3e-2ed0edf53709</td><td>购买合同</td><td>500,000</td><td>一次性付款</td><td>2016-10-24</td><td>1</td><td>2017-07-27</td><td>2</td><td>否</td></tr><tr><td>05bf042a-27f8-4e66-bc0c-9638145fd756</td><td>74643073-3ca1-4cf4-b921-af3e9c83702b</td><td>购买合同</td><td>600,000</td><td>分期付款</td><td>2017-09-26</td><td>1</td><td>2016-09-21</td><td>2</td><td>否</td></tr><tr><td>0692a164-8159-4dda-901b-4003f432d41c</td><td>de4b48c5-93b6-4af1-abd9-bc4e4499fb11</td><td>购买合同</td><td>130,000</td><td>一次性付款</td><td>2017-08-03</td><td>1</td><td>2016-04-07</td><td>1</td><td>是</td></tr><tr><td>080a241d-7372-4921-b171-b9ed2d4a9dd6</td><td>0e4cf623-44dd-470a-8a39-5bc705c5faf5</td><td>服务协议</td><td>210,000</td><td>一次性付款</td><td>2017-05-06</td><td>1</td><td>2017-03-27</td><td>6</td><td>是</td></tr><tr><td>080cd368-af54-447a-a3ae-051425c84bc1</td><td>6370dee7-6d96-4881-9014-2ba42b674051</td><td>购买合同</td><td>720,000</td><td>一次性付款</td><td>2017-08-17</td><td>1</td><td>2017-08-05</td><td>3</td><td>否</td></tr><tr><td>087bab2a-7b5e-4304-808a-830b68556cee</td><td>ec8cec0b-012f-4b58-84ff-0c889e98f1a0</td><td>购买合同</td><td>150,000</td><td>一次性付款</td><td>2017-08-09</td><td>1</td><td>2016-03-12</td><td>5</td><td>是</td></tr><tr><td>08ce15be-bbfd-4c9b-b18f-39eb03e471ca</td><td>456419b5-d3c7-499b-b07b-b868cc68634e</td><td>购买合同</td><td>320,000</td><td>分期付款</td><td>2016-08-25</td><td>1</td><td>2017-05-13</td><td>5</td><td>是</td></tr><tr><td>0a392e38-b72f-46ad-b713-a19e06f6f46e</td><td>ef35dd55-5306-4380-88ff-5db8847f07be</td><td>购买合同</td><td>200,000</td><td>一次性付款</td><td>2016-08-17</td><td>1</td><td>2016-08-05</td><td>3</td><td>否</td></tr><tr><td>0a481a95-5f8f-4a2f-acac-711dcd77ed80</td><td>e210c77c-f1c3-44d2-ad08-fb1b36a8499f</td><td>长期协议订单</td><td>270,000</td><td>一次性付款</td><td>2016-08-12</td><td>3</td><td>2017-01-05</td><td>1</td><td>是</td></tr><tr><td>0c6e4368-0572-40e6-978e-de72b8997d15</td><td>1fb823f6-209e-4484-9919-8844e2e09135</td><td>购买合同</td><td>350,000</td><td>分期付款</td><td>2016-11-15</td><td>1</td><td>2017-10-15</td><td>3</td><td>否</td></tr><tr><td>0cdfd271-6a40-432a-ac04-fcf0e3e029dd</td><td>5917ef9b-f554-4364-b0ba-524bc7eee0db</td><td>购买合同</td><td>100,000</td><td>一次性付款</td><td>2016-08-23</td><td>1</td><td>2016-05-25</td><td>3</td><td>是</td></tr><tr><td>0dc1c555-2eb2-4d8e-9ee4-50e96688e6a6</td><td>0ef33a04-1464-417a-a976-01f41ba0b97e</td><td>长期协议</td><td>0</td><td>分期付款</td><td>2016-08-24</td><td>0</td><td>2016-09-01</td><td>5</td><td>是</td></tr><tr><td>0e2329e4-af5e-4bbc-8ea2-2b13d7f4b4eb</td><td>7ec522c2-ad8f-4018-8744-290b34bc175e</td><td>购买合同</td><td>50,000</td><td>一次性付款</td><td>2016-08-23</td><td>1</td><td>2017-06-19</td><td>3</td><td>是</td></tr><tr><td>0fb2bba0-ea35-42b0-8e03-1750962d64c1</td><td>16dcafcf-97b2-4380-967a-0058fccdd9fd</td><td>购买合同</td><td>380,000</td><td>分期付款</td><td>2017-01-26</td><td>1</td><td>2016-12-22</td><td>2</td><td>是</td></tr></tbody></table><h5 id="交叉表制作"><a href="#交叉表制作" class="headerlink" title="交叉表制作"></a>交叉表制作</h5><ol><li>在图表类型选择「交叉表」，将待分析区域的「合同类型」、「合同签约时间」拖入行维度；「合同付款类型」拖入列维度；「合同金额」拖入指标栏，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9a2e5bb1-16a8-4393-06ae-ca06136bd500/public"                      width = "600"                ><h5 id="创建字段"><a href="#创建字段" class="headerlink" title="创建字段"></a>创建字段</h5><ol start="2"><li>点击合同签约时间字段下拉框，选择按「年」分组显示，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9efd73ea-72ae-4cc3-f756-47655bce3e00/public"                      width = "600"                ><h5 id="设置组件样式-1"><a href="#设置组件样式-1" class="headerlink" title="设置组件样式"></a>设置组件样式</h5><ol start="3"><li>表格属性为设置表格中指定文字颜色和文字旁的图标标记，包括颜色和形状<ul><li>颜色修改：<ul><li>【表格属性】&gt;【颜色】可设置指定范围内的指标颜色。例如，将【合同金额】拖入表格属性下的颜色栏，并点击【颜色】栏，添加条件。设置值在【2000000-无限制】之间的【合同金额】显示为红色，如下图所示：</li></ul></li></ul></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9dc4f48b-e463-4f89-4e01-0889f9bd2f00/public"                      width = "600"                ><ol start="4"><li>形状修改：【表格属性】&gt;【形状】可设置字段旁的图标标记，可设置根据不同条件来显示不同标记及颜色。例如，将拖入表格属性下的形状栏中，并点击「形状」栏，设置形状和数值如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7d3fd7c6-794a-4d5f-1dce-9c33e7c7e800/public"                      width = "600"                ><h4 id="明细表"><a href="#明细表" class="headerlink" title="明细表"></a>明细表</h4><p>明细表，用于展示报表明细数据</p><p>特点：</p><ul><li>可以展示数据的详细信息</li><li>不适合展示多维度数据</li><li>不支持数据汇总</li></ul><h5 id="明细表示例"><a href="#明细表示例" class="headerlink" title="明细表示例"></a>明细表示例</h5><p>集团销售总表</p><table><thead><tr><th>日期</th><th>城市</th><th>单据编码</th><th>门店编码</th><th>门店名称</th><th>商品编码</th><th>商品类别</th><th>商品名称</th><th>省份</th><th>成本额</th><th>数量</th><th>销售额</th></tr></thead><tbody><tr><td>2020-01-01</td><td>白山市</td><td>SMDBJ18000010</td><td>D010112</td><td>白山店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>鹤岗市</td><td>SMDBJ18000014</td><td>D010114</td><td>鹤岗店</td><td>62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6</td><td>零食</td><td>三全960g奶香馒头</td><td>黑龙江省</td><td>998.56</td><td>120</td><td>2,461.54</td></tr><tr><td>2020-01-01</td><td>鹤岗市</td><td>SMDBJ18000014</td><td>D010114</td><td>鹤岗店</td><td>BE2DA7F0-1E24-4729-BED3-3CDC0A2E4918</td><td>零食</td><td>嘉士利115g威化饼</td><td>黑龙江省</td><td>1,033.47</td><td>100</td><td>3,119.66</td></tr><tr><td>2020-01-01</td><td>辽源市</td><td>SMDBJ18000015</td><td>D010115</td><td>辽源店</td><td>62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6</td><td>零食</td><td>三全960g奶香馒头</td><td>吉林省</td><td>1,664.27</td><td>200</td><td>4,102.56</td></tr><tr><td>2020-01-01</td><td>辽源市</td><td>SMDBJ18000015</td><td>D010115</td><td>辽源店</td><td>AE451BC0-8615-4F8C-8126-05E0C01DDF24</td><td>零食</td><td>丽芝士散装系列</td><td>吉林省</td><td>950.36</td><td>100</td><td>2,948.72</td></tr><tr><td>2020-01-01</td><td>辽源市</td><td>SMDBJ18000015</td><td>D010115</td><td>辽源店</td><td>77DA67A0-ED8C-4FB3-8E04-E9EA7DD96BE8</td><td>零食</td><td>养乐多100ml*5乳酸菌</td><td>吉林省</td><td>573.88</td><td>50</td><td>2,094.02</td></tr><tr><td>2020-01-01</td><td>辽源市</td><td>SMDBJ18000015</td><td>D010115</td><td>辽源店</td><td>BE2DA7F0-1E24-4729-BED3-3CDC0A2E4918</td><td>零食</td><td>嘉士利115g威化饼</td><td>吉林省</td><td>516.73</td><td>50</td><td>1,559.83</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>12EF7049-C847-4A7F-A5B4-C0BEDDADAA81</td><td>生鲜</td><td>西红柿</td><td>吉林省</td><td>240.17</td><td>12</td><td>605.13</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>59F35931-24BA-46DC-9551-6744A16FC87B</td><td>生鲜</td><td>本地小白菜</td><td>吉林省</td><td>542.68</td><td>40</td><td>2,017.09</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>E5EA2E2A-DC19-4D47-BF0F-F29CC467A5C0</td><td>日用品</td><td>家之寓圆形24夹晒架</td><td>吉林省</td><td>252</td><td>100</td><td>1,025.64</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>E5EA2E2A-DC19-4D47-BF0F-F29CC467A5C0</td><td>日用品</td><td>家之寓圆形24夹晒架</td><td>吉林省</td><td>26.23</td><td>10</td><td>135.9</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6</td><td>零食</td><td>三全960g奶香馒头</td><td>吉林省</td><td>1,248.2</td><td>150</td><td>3,076.92</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>AE451BC0-8615-4F8C-8126-05E0C01DDF24</td><td>零食</td><td>丽芝士散装系列</td><td>吉林省</td><td>1,425.54</td><td>150</td><td>4,423.08</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>77DA67A0-ED8C-4FB3-8E04-E9EA7DD96BE8</td><td>零食</td><td>养乐多100ml*5乳酸菌</td><td>吉林省</td><td>1,342.88</td><td>117</td><td>4,900</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>CBB40A41-178E-44F7-BD5E-9ECD8B73978A</td><td>零食</td><td>格力高55g草莓味百奇</td><td>吉林省</td><td>309.43</td><td>21</td><td>807.69</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>松原市</td><td>SMDBJ18000016</td><td>D010116</td><td>松原店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>吉林省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>鞍山市</td><td>SMDBJ18000024</td><td>D010120</td><td>鞍山店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>辽宁省</td><td>598.29</td><td>28</td><td>1,005.13</td></tr><tr><td>2020-01-01</td><td>鞍山市</td><td>SMDBJ18000024</td><td>D010120</td><td>鞍山店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>辽宁省</td><td>170.94</td><td>8</td><td>287.18</td></tr><tr><td>2020-01-01</td><td>鞍山市</td><td>SMDBJ18000024</td><td>D010120</td><td>鞍山店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>辽宁省</td><td>512.82</td><td>24</td><td>861.54</td></tr><tr><td>2020-01-01</td><td>苏州市</td><td>SMDSH18000071</td><td>D010229</td><td>苏州店</td><td>5DDCE422-6782-43D2-9AC6-0E28ABA93636</td><td>生鲜</td><td>西域香妃蜜瓜</td><td>江苏省</td><td>318.55</td><td>5</td><td>1,102.56</td></tr><tr><td>2020-01-01</td><td>苏州市</td><td>SMDSH18000071</td><td>D010229</td><td>苏州店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>江苏省</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>上海市</td><td>SMDSH18000075</td><td>D010231</td><td>上海店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>上海市</td><td>213.68</td><td>10</td><td>358.97</td></tr><tr><td>2020-01-01</td><td>上海市</td><td>SMDSH18000090</td><td>D010231</td><td>上海店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>上海市</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>上海市</td><td>SMDSH18000090</td><td>D010231</td><td>上海店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>上海市</td><td>427.35</td><td>20</td><td>717.95</td></tr><tr><td>2020-01-01</td><td>上海市</td><td>SMDSH18000093</td><td>D010231</td><td>上海店</td><td>BC639DE8-B503-437C-9B6B-F0B598052A65</td><td>日用品</td><td>微爽日用245mm</td><td>上海市</td><td>641.03</td><td>30</td><td>1,076.92</td></tr><tr><td>2020-01-01</td><td>温州市</td><td>SMDSH18000336</td><td>D010243</td><td>温州店</td><td>62CF9CFA-1E86-4960-B7CA-F077A8BDD5A6</td><td>零食</td><td>三全960g奶香馒头</td><td>浙江省</td><td>1,579.64</td><td>170</td><td>3,487.18</td></tr></tbody></table><p>如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8dcb4174-56bc-49f3-7b84-8f177ff3cb00/public"                      width = "600"                ><h5 id="明细表制作"><a href="#明细表制作" class="headerlink" title="明细表制作"></a>明细表制作</h5><ol><li>选择图表类型为【明细表】，再将左侧的字段拖入数据栏，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d03f0233-41e6-4c69-5ed8-b58b57955900/public"                      width = "600"                ><h5 id="设置分页行数"><a href="#设置分页行数" class="headerlink" title="设置分页行数"></a>设置分页行数</h5><ol start="2"><li>有时用户希望能自定义明细表分页行数、或者希望能实现点击翻页查看数据，可在「组件样式&gt;格式」中直接输入希望设置的分页行数即可进行调整，输入 1000，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5a21d24d-24e4-42ff-5a76-11e036114b00/public"                      width = "600"                ><h3 id="指标卡"><a href="#指标卡" class="headerlink" title="指标卡"></a>指标卡</h3><h4 id="指标卡图例"><a href="#指标卡图例" class="headerlink" title="指标卡图例"></a>指标卡图例</h4><p>KPI 指标卡为直观展示 KPI 数值的组件，可直接显示所选字段的数值，比如展示销售额、毛利、毛利率等指标数值。</p><p>特点：适合突出显示重要指标，但是仅能展示文本</p><p>效果如下图所示：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6095a37a-7c06-4a89-ac25-8a678ca6a100/public"                      width = "600"                ><p>地区数据分析</p><table><thead><tr><th>合同签约时间</th><th>国家</th><th>省份</th><th>城市</th><th>客户名称</th><th>合同金额</th><th>回款金额</th></tr></thead><tbody><tr><td>2016-01-18</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>浙江臻善科技有限公司</td><td>1,200,000</td><td>1,200,000</td></tr><tr><td>2016-08-01</td><td>中国</td><td>河南省</td><td>郑州市</td><td>杭州明佑电子有限公司</td><td>100,800</td><td>100,800</td></tr><tr><td>2016-04-01</td><td>中国</td><td>陕西省</td><td>西安市</td><td>西北工业大学</td><td>430,000</td><td>430,000</td></tr><tr><td>2016-01-18</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>浙江网新恩普软件有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-08</td><td>中国</td><td>北京市</td><td>北京市</td><td>北京瑞翔科技有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-04-14</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海捷穗软件有限公司</td><td>200,000</td><td>200,000</td></tr><tr><td>2016-05-05</td><td>中国</td><td>重庆市</td><td>重庆市</td><td>重庆格力销售中心</td><td>285,000</td><td>285,000</td></tr><tr><td>2016-04-21</td><td>中国</td><td>江苏省</td><td>南京市</td><td>江苏邮政同达科技</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-06-01</td><td>中国</td><td>上海市</td><td>上海市</td><td>95856部队</td><td>520,000</td><td>520,000</td></tr><tr><td>2016-04-29</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海创业投资有限公司</td><td>240,000</td><td>240,000</td></tr><tr><td>2016-04-29</td><td>中国</td><td>上海市</td><td>上海市</td><td>智动营销策划咨询（上海）有限公司</td><td>450,000</td><td>450,000</td></tr><tr><td>2016-04-25</td><td>中国</td><td>江苏省</td><td>盐城市</td><td>盐城邮政局</td><td>120,000</td><td>120,000</td></tr><tr><td>2016-05-04</td><td>中国</td><td>浙江省</td><td>杭州市</td><td>杭州银行</td><td>1,200,000</td><td>1,080,000</td></tr><tr><td>2016-04-27</td><td>中国</td><td>北京市</td><td>北京市</td><td>建信金融租赁股份有限公司</td><td>600,000</td><td>600,000</td></tr><tr><td>2015-03-22</td><td>中国</td><td>江苏省</td><td>南京市</td><td>南京星友田科技发展有限公司</td><td>400,000</td><td>400,000</td></tr><tr><td>2016-06-19</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海万序计算机科技有限公司</td><td>480,000</td><td>480,000</td></tr><tr><td>2016-05-25</td><td>中国</td><td>上海市</td><td>上海市</td><td>上海万序计算机科技有限公司</td><td>480,000</td><td>480,000</td></tr></tbody></table><h4 id="指标卡制作"><a href="#指标卡制作" class="headerlink" title="指标卡制作"></a>指标卡制作</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f12bf4be-9967-49cb-a3ca-ce6708428b00/public"                      width = "600"                ><h4 id="设置指标卡样式"><a href="#设置指标卡样式" class="headerlink" title="设置指标卡样式"></a>设置指标卡样式</h4><ol start="2"><li>在【文本】处新增了【固定字体大小】，且默认勾选，显示效果为 KPI 指标卡默认显示效果。用户也可不勾选该按钮，自定义内容显示效果，根据自己的需求进行设置，如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3c56d91b-62a3-4f5f-d72a-0a4890b95500/public"                      width = "600"                ><ol start="3"><li>点击【文本】栏，可设置形状，并用条件属性控制形状及形状颜色的显示。如下图所示：</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7b913302-d099-44d6-0133-4f2a81a43f00/public"                      width = "600"                >]]></content>
    
    
    <summary type="html">FineBI 组件用法</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="FineBI" scheme="https://www.yiuhangblog.com/tags/FineBI/"/>
    
    <category term="数据处理" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    <category term="组件" scheme="https://www.yiuhangblog.com/tags/%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>常用函数(FineBI)</title>
    <link href="https://www.yiuhangblog.com/2020/06/05/20200605FineBI%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yiuhangblog.com/2020/06/05/20200605FineBI%E5%87%BD%E6%95%B0/</id>
    <published>2020-06-04T23:55:42.000Z</published>
    <updated>2024-02-28T10:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FineBI函数介绍"><a href="#FineBI函数介绍" class="headerlink" title="FineBI函数介绍"></a>FineBI函数介绍</h2><p>在FineBI中，函数用于处理数据和实现简单或者复杂的计算和分析。比如以下场景中我们可能会用到函数:</p><p>【数值计算】例如求和、平均、最大值、最小值以及计算出业务指标等;</p><p>【时间计算】比如获取当前日期、计算时间差、改变时间单位(取年或月)、格式转换</p><p>【文本处理】比如拆分合并文本、格式规范</p><p>函数的价值在于它们能够简化一些数据处理和分析的过程，并且可以实现复杂的计算和数据转换。通过使用函数，我们可以将多个步骤合并成一个， 减少了繁琐的手工操作，同时也降低了出错的可能性。</p><h2 id="FineBI函数的使用位置"><a href="#FineBI函数的使用位置" class="headerlink" title="FineBI函数的使用位置"></a>FineBI函数的使用位置</h2><p>1：【数据编辑】中的 【新增公式列】</p><p>2：【组件】中的添加 【计算字段】</p><p>3：【过滤】中的【添加公式】条件</p><h2 id="FineBI常用函数"><a href="#FineBI常用函数" class="headerlink" title="FineBI常用函数"></a>FineBI常用函数</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/695c36b8-1339-4bbf-26d4-3e5a45ffad00/public"                      width = "600"                ><h3 id="IF-函数-判断条件"><a href="#IF-函数-判断条件" class="headerlink" title="IF 函数 判断条件"></a>IF 函数 判断条件</h3><p>语法规则： <code>if (boolean,number1/string1,number2/string2)</code></p><p>示例数据： 合同事实表.xlsx</p><p>​例：用户需要将【合同类型】改为代号显示，【购买合同】改为 1 ，【服务协议】改为 2 ，其他两个协议改为 0。</p><p>语法设置： <code>if(合同类型=&quot;购买合同&quot;,1,if(合同类型=&quot;服务协议&quot;,2,0))</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/630acefc-0ce4-44b3-c1b8-3cb01c687500/public"                      width = "600"                ><h3 id="ABS-函数-求绝对值"><a href="#ABS-函数-求绝对值" class="headerlink" title="ABS 函数 求绝对值"></a>ABS 函数 求绝对值</h3><p>语法规则: <code>abs(number)</code></p><p>示例数据： 股票买卖数据.xlsx</p><p>​例：使用示例数据计算买入-卖出差额后，需要将差额进行绝对值处理。</p><p>语法设置： <code>ABS(差值)</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/433e89f2-a034-48c0-242c-e67e88d8c600/public"                      width = "600"                ><h3 id="ROUND函数-保留几位小数"><a href="#ROUND函数-保留几位小数" class="headerlink" title="ROUND函数 保留几位小数"></a>ROUND函数 保留几位小数</h3><p>语法规则： <code>ROUND(number,num_digits)</code></p><p>示例数据： 商品销售明细表.xlsx</p><p>​例：使用示例数据「商品销售明细表」，需要将「销售额」数值统一为保留小数点后一位。</p><p>语法设置：<code>ROUND(销售额,1)</code></p>  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p><code>num_digits</code>按此位数进行舍入，小于0，则在小数点左侧进行舍入。等于0，则舍入到最接近的整数。大于0，则舍入到指定的小数位。</p>  </div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/abb203ec-c376-42f3-0e1d-85f0170b8700/public"                      width = "600"                ><h3 id="INT-函数-抽取数据"><a href="#INT-函数-抽取数据" class="headerlink" title="INT 函数 抽取数据"></a>INT 函数 抽取数据</h3><p>语法规则: <code>int(number)</code> 向下取整,往更小的值取整</p><p>示例数据： 集团商品销售总表.xlsx</p><p>​例：使用示例数据对销售额进行向下取整。</p><p>语法设置： <code>INT(销售额)</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c8e85c66-093f-4563-1353-8b42693c0e00/public"                      width = "600"                ><h2 id="FineBI函数类型"><a href="#FineBI函数类型" class="headerlink" title="FineBI函数类型"></a>FineBI函数类型</h2><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/697912cc-5fa8-4739-0b30-1500ab01e800/public"                      width = "600"                ><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4c046269-bfea-48c0-d000-78bf8fd2b900/public"                      width = "600"                ><h3 id="文本函数"><a href="#文本函数" class="headerlink" title="文本函数"></a>文本函数</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c68b79d4-c035-4f10-73af-651f94202b00/public"                      width = "600"                ><h3 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/04aff24a-b8c4-418f-e9e3-5e40aa0a0600/public"                      width = "600"                ><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fb5077eb-cd62-4927-a770-3e7eed5e4200/public"                      width = "600"                ><p>聚合函数可以对一组数据进行汇总，一般使用聚合函数汇总后的值进行再计算。</p><p>公司的销售额合计是多少（求和：<code>SUM_AGG(销售额)</code>)</p><p>商品的平均售价是多少（平均值：<code>AVG_AGG(售价)</code>）</p><p>总共有多少个会员（去重计数：<code>COUNT_AGG(会员)</code>）</p><p>昨日的最大交易订单金额是多少（最大值：<code>MAX_AGG(订单金额)</code>）</p><ol><li><p>聚合函数的使用场景是什么?</p><p>一般我们会使用聚合汇总后的值达行再计算。随着分析维度的切换，计算字段会自动跟随维度动态调整。</p></li><li><p>为什么在组件中才可以使用聚合函数?</p><p>编辑数据中都是针对个体的行级别的计算，组件中可以指定维度进行聚合计算</p></li><li><p>SUM_ AGG (A&#x2F;B) 和SUM_ AGG(A)&#x2F;SUM_ AGG(B)有什么区别呢?</p><p>先相除再汇总 和 先分别汇总得到各自的总值再相除</p></li></ol><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c4bd7b6d-00b8-4b43-bb52-f00e11c98c00/public"                      width = "600"                ><h2 id="FineBI函数最佳实践技巧"><a href="#FineBI函数最佳实践技巧" class="headerlink" title="FineBI函数最佳实践技巧"></a>FineBI函数最佳实践技巧</h2><p><strong>01 [明确业务需要] :</strong></p><p>​场景背景:某网站的运营人员想要就用户的激活登录信息分析出网站的用户留存情况，来制定接下来的用户运营策略。现有一-张“用户登录信息”表，运营人员想要通过该表分析出用户的每日的新增用户数、当日留存率、次日留存率、三周留存率…..</p><p>​指标定义:</p><p>​留存率&#x3D;新增用户中登录用户数&#x2F;新增用户数*100%</p><p>​N日留存人数:指新增用户日(T)之后的第N日，依然登录的用户数</p><p>​N周内留存率:指新增用户日之后，“注册(激活)登录时间差”为1~7N(含)天的登录用户数&#x2F;新增用户日总</p><p>​人数</p><p>​注:一般情况下登录时间晚于注册时间，但是可能会存在部分”游客”用户先登录体验后注册身份。</p><p><strong>02 [梳理计算步骤]</strong></p><p>​①梳理字段，有登录时间、激活时间…等字段，各字段所代表的含是…..<br>​②是否需要规范字段&#x2F;数据清洗<br>​③求出每日的新增用户数，求时间差，求新增用户中登录的用户数<br>​④相除求留存率<br>​…..</p><p><strong>03 [找到合适的函数]</strong></p><p>​计算日期差(日)函数用DATESUBDATE&#x2F;DATEDIF函数或者使用快捷功能“时间差” ;<br>​计算去重用户数用COUNTD_AGG函数或者用记录数(去重)</p><p><strong>04 [正确使用函数]</strong></p><p><strong>05 [函数校验]</strong></p><h2 id="FineBI函数书写注意事项"><a href="#FineBI函数书写注意事项" class="headerlink" title="FineBI函数书写注意事项"></a>FineBI函数书写注意事项</h2><p><strong>【1】公式中的字段能手动输入注意：</strong></p><p>​输入字段名部分文字或首字母FineBI能自动匹配对应字段，选择字段即可。也支持在左侧的字段选择框中选择。<br>​添加的字段名要和表内字段匹配上,添加的字段为蓝色。如果为黑色则无效,取不到字段内数据。</p><p><strong>【2】 BI 里的「不等于」表示法: !&#x3D;</strong></p><p><strong>【3】公式里书写文本的表达式</strong><br>    在文本表达式左右需要增加「双引号」</p><p><strong>【4】新增公式列不支持直接输出聚合函数</strong><br>    因为聚合函数是对不同行进行汇总的计算。编辑数据是行级别的明细计算。如果想直接输出聚合函数，可以在组件中计算。如果在数据编辑中进行聚合，公式需要使用def函数嵌套,或者直接使用新增汇总列。</p><p><strong>【5】公式报错「不合法」?</strong><br>    公式不合法原因排查</p>]]></content>
    
    
    <summary type="html">常用函数，帆软BI软件基本操作</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="FineBI" scheme="https://www.yiuhangblog.com/tags/FineBI/"/>
    
    <category term="函数" scheme="https://www.yiuhangblog.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据处理 (FineBI)</title>
    <link href="https://www.yiuhangblog.com/2020/05/15/20200515%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://www.yiuhangblog.com/2020/05/15/20200515%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2020-05-14T23:55:42.000Z</published>
    <updated>2024-02-28T10:49:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字段图表含义"><a href="#字段图表含义" class="headerlink" title="字段图表含义"></a>字段图表含义</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2f706126-e7ab-46da-172a-57d8a6ef7600/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0debdd30-c5f7-444a-62f8-4eafd4206700/public"                      width = "600"                ><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>所谓的【数据清洗】就是提前对数据进行一系列的操作,为满足实际业务场景中数据的处理需求。这些操作能够从杂乱无章的数据中整理出有序的、可靠的数据，为后续的分析和决策提供有力支持。</p><p>场景一:</p><p>临近放假,老师准备对全班的同学成绩进行一些分析.于是找来了之前录入的考试成绩表,但是在开始分析前就遇到了一个难题,如图所示</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/16ac64f8-85eb-4909-0d1c-e4cc47d9d000/public"                      width = "600"                ><h2 id="常见数据处理顺序"><a href="#常见数据处理顺序" class="headerlink" title="常见数据处理顺序"></a>常见数据处理顺序</h2><p>很多数据由于未经过处理，不方便用来直接制作图表。</p><p>我们可以将数据添加到主题后，在主题中先对数据进行分析，然后用分析后的数据再制作图表会比使用原数据表更方便。</p><p>以数据成绩表 1 为例</p><table><thead><tr><th>姓名</th><th>考试结果</th><th>录入时间</th></tr></thead><tbody><tr><td>滑玛</td><td>语文90 数学80 英语80</td><td>2&#x2F;12&#x2F;2020 16:30</td></tr><tr><td>阿里和卓</td><td>语文91 数学 英语85</td><td>2&#x2F;12&#x2F;2020 16:31</td></tr><tr><td>福伦</td><td>语文54 数学78 英语66</td><td>2&#x2F;12&#x2F;2020 16:32</td></tr><tr><td>令妃</td><td>语文78 数学63 英语95</td><td>2&#x2F;12&#x2F;2020 16:43</td></tr><tr><td></td><td>语文73 数学75 英语88</td><td>2&#x2F;12&#x2F;2020 17:57</td></tr><tr><td>滑玛</td><td>语文90 数学88 英语80</td><td>2&#x2F;12&#x2F;2020 17:30</td></tr></tbody></table><ol><li>首先进入我的分析</li><li>创建新的文件夹<code>数据处理_测试</code></li><li>接着导入<code>成绩表1.xls</code>的数据并创建新的分析主题</li><li>修改分析主题名称<code>数据处理1</code>后进入编辑</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ac215b02-188f-4897-bc57-fc35145c6a00/public"                      width = "600"                >  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>误操作可以通过右边数据来源进行删除回溯</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dd0b69fe-8b43-4c4b-8624-22893470a000/public"                      width = "600"                >    </div>  </div><h3 id="重复行操作"><a href="#重复行操作" class="headerlink" title="重复行操作"></a>重复行操作</h3><ol><li>系统的一些问题带来的两条完全一样的数据，直接去重</li><li>有业务含义的，需要有选择的去重，先【排序】再【删除重复行】。</li></ol><p>​例：姓名是唯一字段，相同的姓名只留下一条</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/afe9203d-ee3c-4b1a-576e-339879d99700/public"                      width = "600"                >  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>删除时,是删除处在下方的数据,以更新成绩为例：</p><p>假设同一个人的成绩第一次登记的作废,需要留下第二次输入的,那么可以将时间设置为【降序】，这时先登记的成绩在下，后更新的成绩在上，这样就能保证数据的准确性。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4ac13c88-ce8d-4ba2-1ac8-5473678a5300/public"                      width = "600"                >    </div>  </div><h3 id="删除空值"><a href="#删除空值" class="headerlink" title="删除空值"></a>删除空值</h3><p>空值作为一个必定会遇到的问题，在不同的业务场景下会有截然不同的处理方式。</p><ol><li>“大海里的一滴水”，放着不管，问题不大</li><li>害群之马不可留”，通过过滤，删除含null的数据</li><li>灵活分析要保留，有业务含义时，打上【标签】，方便分析时过滤：</li></ol><ul><li>方式一: 【新增公式列】</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/33ad6b6f-a9a2-43a8-7efa-7e0338b29000/public"                      width = "600"                ><ul><li>方式二: 【条件标签列】</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c4348881-bb49-4db2-090b-a0155119d200/public"                      width = "600"                ><h4 id="示例-1-删除空值行"><a href="#示例-1-删除空值行" class="headerlink" title="示例 1 删除空值行"></a>示例 1 删除空值行</h4><p>点击上方功能栏的过滤进行筛选操作</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/46871964-2b1b-435b-415b-5b984c95b800/public"                      width = "600"                ><h4 id="示例-2-快捷删除空值列"><a href="#示例-2-快捷删除空值列" class="headerlink" title="示例 2 快捷删除空值列"></a>示例 2 快捷删除空值列</h4><p>点击表头右侧的三角形表示进行快捷过滤</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1a91a27b-3104-49fc-cf59-df1f5180d900/public"                      width = "600"                ><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>调整数据结构:</p><p>​把数据处理成要分析的维度和指标</p><p>​相关功能:【更多】中找到【拆分行列】、【行列转换】，进行字段设置</p><h4 id="示例-1-拆分考试结果"><a href="#示例-1-拆分考试结果" class="headerlink" title="示例 1 拆分考试结果"></a>示例 1 拆分考试结果</h4><p>使用拆分行列，行列转换，字段设置对考试结果进行处理</p><ol><li>首先使用拆分行把成绩按照空格进行第一次拆分</li><li>随后使用拆分列对结果按照字符数为2进行拆分，生成前两列</li><li>然后通过字符设置对不用的列和不符合属性的列进行隐藏和修改</li><li>最后对语数英三列进行列转行即可</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0a45f98b-cce5-4d0d-9109-3fafdf843000/public"                      width = "600"                >  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>通过新增公式列对于需要保留的空缺列可以添加标识行例如<br><code>IF(${数学}=null||${语文}=null||${英语}=null,&quot;缺考&quot;,&quot;出席&quot;)</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0513846a-1f5b-444e-c3d9-8b1c4bca5f00/public"                      width = "600"                >    </div>  </div><h3 id="多表合并分析"><a href="#多表合并分析" class="headerlink" title="多表合并分析"></a>多表合并分析</h3><p>场景二:</p><p>在完成数据处理后，老师觉得只分析自己班游局限性，又要来了同年级另外两个班的数据…..</p><p>年级主任还补充,近几年鼓励学生全面发展,现在把体育,美术,课外实践也归纳成一门综合素质评定.</p><p>1）多个表格上下扩展，分析指标不变，只是行数增加，就用【上下合并】</p><p>2）多个表格左右扩展，分析指标变多，只是列数增加，先考虑【其他表添加列】也可以使用【左右合并】</p><h4 id="示例-1-上下合并（增加行）"><a href="#示例-1-上下合并（增加行）" class="headerlink" title="示例 1 上下合并（增加行）"></a>示例 1 上下合并（增加行）</h4><ol><li>在导入成绩表 2 后数据来源选中数据表 1 回溯操作到第一步</li></ol><table><thead><tr><th>姓名</th><th>考试结果</th><th>录入时间</th></tr></thead><tbody><tr><td>夏紫薇</td><td>语文90 数学80 英语80</td><td>2&#x2F;12&#x2F;2020 18:30</td></tr><tr><td>福尔康</td><td>语文91 数学 英语85</td><td>2&#x2F;12&#x2F;2020 18:31</td></tr><tr><td>永琪</td><td>语文54 数学78 英语66</td><td>2&#x2F;12&#x2F;2020 18:32</td></tr><tr><td>小燕子</td><td>语文78 数学63 英语95</td><td>2&#x2F;12&#x2F;2020 18:43</td></tr></tbody></table><ol start="2"><li><p>然后选中上下合并</p></li><li><p>选中数据来源最后的操作即可把合并后的数据按照原先的操作自动再操作一遍</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/28a309c7-77ce-47d1-0b31-424a00a98f00/public"                      width = "600"                ><h4 id="示例-2-左合并（增加列）"><a href="#示例-2-左合并（增加列）" class="headerlink" title="示例 2 左合并（增加列）"></a>示例 2 左合并（增加列）</h4><ol><li>首先导入产品成本表和产品销售表</li></ol><p>产品成本表：</p><table><thead><tr><th>产品</th><th>成本额</th></tr></thead><tbody><tr><td>苹果</td><td>40</td></tr><tr><td>香蕉</td><td>35</td></tr><tr><td>栗子</td><td>38</td></tr></tbody></table><p>产品销售表：</p><table><thead><tr><th>产品</th><th>销售额</th></tr></thead><tbody><tr><td>苹果</td><td>90</td></tr><tr><td>香蕉</td><td>70</td></tr><tr><td>橘子</td><td>70</td></tr></tbody></table><ol start="2"><li>以产品成本表为主表，产品列为依据，进行左合并，则合并产品销售表的所有销售额到产品成本表的最右列。<ul><li>如果合并表没有主表所包含的依据列则其值为空</li><li>如果主表没有合并表所包含的依据列则不合并该值</li></ul></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/dfd55ecb-0c44-45f5-74aa-2baab5e5a000/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ec9824f0-93c4-4697-a5c5-cd7fd33c1000/public"                      width = "600"                ><h4 id="示例-3-右合并（增加列）"><a href="#示例-3-右合并（增加列）" class="headerlink" title="示例 3 右合并（增加列）"></a>示例 3 右合并（增加列）</h4><ol><li>以产品成本表为主表，产品列为依据，进行右合并，则合并产品销售表的所有销售额到产品成本表的最右列。<ul><li>如果主表没有合并表所包含的依据列则其值为空</li><li>如果合并表没有主表所包含的依据列则不合并该值</li></ul></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9432ec0f-3bb9-438a-45f1-0f99cca91800/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/72a54241-2fc4-432c-d1a1-8d0824bd1300/public"                      width = "600"                ><h4 id="示例-4-并集合并（增加列）"><a href="#示例-4-并集合并（增加列）" class="headerlink" title="示例 4 并集合并（增加列）"></a>示例 4 并集合并（增加列）</h4><ol><li>以产品成本表为主表，产品列为依据，进行并集合并，则合并产品销售表的所有销售额到产品成本表的最右列。<ul><li>合并所有的值</li><li>如果主表没有合并表所包含的依据列则其值为空</li><li>如果合并表没有主表所包含的依据列则其值为空</li></ul></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c79e69d3-e5b7-46aa-e382-602fc7f9a400/public"                      width = "600"                ><h4 id="示例-5-交集合并（增加列）"><a href="#示例-5-交集合并（增加列）" class="headerlink" title="示例 5 交集合并（增加列）"></a>示例 5 交集合并（增加列）</h4><ol><li>以产品成本表为主表，产品列为依据，进行交集合并，则合并产品销售表的所有销售额到产品成本表的最右列。<ul><li>合并共有的值</li><li>如果主表没有合并表所包含的依据列则不合并该值</li><li>如果合并表没有主表所包含的依据列则不合并该值</li></ul></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9e3c6bc8-8114-4600-519c-b91e62f21500/public"                      width = "600"                ><h4 id="示例-6-左右合并（增加列）"><a href="#示例-6-左右合并（增加列）" class="headerlink" title="示例 6 左右合并（增加列）"></a>示例 6 左右合并（增加列）</h4><p>导入学生信息表数据</p><table><thead><tr><th>姓名</th><th>性别</th><th>年龄</th><th>班级</th></tr></thead><tbody><tr><td>滑玛</td><td>男</td><td>14</td><td>六年1班</td></tr><tr><td>阿里和卓</td><td>男</td><td>14</td><td>六年1班</td></tr><tr><td>福伦</td><td>男</td><td>14</td><td>六年1班</td></tr><tr><td>令妃</td><td>女</td><td>14</td><td>六年1班</td></tr><tr><td>容嬷嬷</td><td>女</td><td>14</td><td>六年2班</td></tr><tr><td>明月</td><td>女</td><td>12</td><td>六年2班</td></tr><tr><td>彩霞</td><td>女</td><td>12</td><td>六年2班</td></tr><tr><td>小凳子</td><td>男</td><td>12</td><td>六年2班</td></tr><tr><td>小桌子</td><td>男</td><td>12</td><td>六年2班</td></tr><tr><td>夏紫薇</td><td>女</td><td>12</td><td>六年3班</td></tr><tr><td>福尔康</td><td>男</td><td>13</td><td>六年3班</td></tr><tr><td>永琪</td><td>男</td><td>13</td><td>六年3班</td></tr><tr><td>小燕子</td><td>女</td><td>12</td><td>六年3班</td></tr><tr><td>含香</td><td>女</td><td>12</td><td>六年3班</td></tr><tr><td>蒙丹</td><td>男</td><td>13</td><td>六年3班</td></tr></tbody></table><ol><li>以学生信息表为主表合并处理过的成绩表 1 </li><li>进行左合并</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a48d89da-937d-483e-1fd0-a15d2e4fcb00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7cd0fc07-715b-4a07-4072-de89b91d9500/public"                      width = "600"                ><h4 id="示例-7-快捷合并依据列唯一（增加列）"><a href="#示例-7-快捷合并依据列唯一（增加列）" class="headerlink" title="示例 7 快捷合并依据列唯一（增加列）"></a>示例 7 快捷合并依据列唯一（增加列）</h4><ol><li>进入在数据工具列进入成绩表 1</li><li>在上方工具栏使用其他表添加列功能</li><li>结果类似左合并</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e79e17ca-5c79-4759-f302-e74b25e67f00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bbdcf2a6-cb90-41cc-1892-3bb370e75600/public"                      width = "600"                ><h4 id="示例-7-快捷合并依据列不唯一（增加列）"><a href="#示例-7-快捷合并依据列不唯一（增加列）" class="headerlink" title="示例 7 快捷合并依据列不唯一（增加列）"></a>示例 7 快捷合并依据列不唯一（增加列）</h4><ol><li>导入综合素质成绩表的数据</li></ol><table><thead><tr><th>姓名</th><th>科目</th><th>综合素质成绩</th></tr></thead><tbody><tr><td>滑玛</td><td>体育 (30%)</td><td>30</td></tr><tr><td>滑玛</td><td>美术 (30%)</td><td>30</td></tr><tr><td>滑玛</td><td>社会实践 (40%)</td><td>40</td></tr><tr><td>阿里和卓</td><td>体育 (30%)</td><td>30</td></tr><tr><td>阿里和卓</td><td>美术 (30%)</td><td>20</td></tr><tr><td>阿里和卓</td><td>社会实践 (40%)</td><td>40</td></tr><tr><td>福伦</td><td>体育 (30%)</td><td>20</td></tr><tr><td>福伦</td><td>美术 (30%)</td><td>20</td></tr><tr><td>福伦</td><td>社会实践 (40%)</td><td>29</td></tr><tr><td>令妃</td><td>体育 (30%)</td><td>10</td></tr><tr><td>令妃</td><td>美术 (30%)</td><td>18</td></tr><tr><td>令妃</td><td>社会实践 (40%)</td><td>10</td></tr><tr><td>容嬷嬷</td><td>体育 (30%)</td><td>30</td></tr><tr><td>容嬷嬷</td><td>美术 (30%)</td><td>5</td></tr><tr><td>容嬷嬷</td><td>社会实践 (40%)</td><td>10</td></tr><tr><td>明月</td><td>体育 (30%)</td><td>30</td></tr><tr><td>明月</td><td>美术 (30%)</td><td>5</td></tr><tr><td>明月</td><td>社会实践 (40%)</td><td>12</td></tr><tr><td>彩霞</td><td>体育 (30%)</td><td>30</td></tr><tr><td>彩霞</td><td>美术 (30%)</td><td>10</td></tr><tr><td>彩霞</td><td>社会实践 (40%)</td><td>4</td></tr><tr><td>小凳子</td><td>体育 (30%)</td><td>10</td></tr><tr><td>小凳子</td><td>美术 (30%)</td><td>10</td></tr><tr><td>小凳子</td><td>社会实践 (40%)</td><td>10</td></tr><tr><td>小桌子</td><td>体育 (30%)</td><td>11</td></tr><tr><td>小桌子</td><td>美术 (30%)</td><td>12</td></tr><tr><td>小桌子</td><td>社会实践 (40%)</td><td>13</td></tr><tr><td>夏紫薇</td><td>体育 (30%)</td><td>5</td></tr><tr><td>夏紫薇</td><td>美术 (30%)</td><td>30</td></tr><tr><td>夏紫薇</td><td>社会实践 (40%)</td><td>30</td></tr><tr><td>福尔康</td><td>体育 (30%)</td><td>30</td></tr><tr><td>福尔康</td><td>美术 (30%)</td><td>29</td></tr><tr><td>福尔康</td><td>社会实践 (40%)</td><td>40</td></tr><tr><td>永琪</td><td>体育 (30%)</td><td>30</td></tr><tr><td>永琪</td><td>美术 (30%)</td><td>29</td></tr><tr><td>永琪</td><td>社会实践 (40%)</td><td>40</td></tr><tr><td>小燕子</td><td>体育 (30%)</td><td>30</td></tr><tr><td>小燕子</td><td>美术 (30%)</td><td>6</td></tr><tr><td>小燕子</td><td>社会实践 (40%)</td><td>36</td></tr><tr><td>含香</td><td>体育 (30%)</td><td>5</td></tr><tr><td>含香</td><td>美术 (30%)</td><td>30</td></tr><tr><td>含香</td><td>社会实践 (40%)</td><td>38</td></tr><tr><td>蒙丹</td><td>体育 (30%)</td><td>30</td></tr><tr><td>蒙丹</td><td>美术 (30%)</td><td>6</td></tr><tr><td>蒙丹</td><td>社会实践 (40%)</td><td>32</td></tr></tbody></table><ol start="2"><li>使用其它表添加列功能添加总和素质成绩表的求和值</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a36d12ae-6bd2-4492-87e9-521d46f5f900/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0ddde676-f514-4d3f-4b6c-4fdde9b88400/public"                      width = "600"                ><h3 id="新增分析指标"><a href="#新增分析指标" class="headerlink" title="新增分析指标"></a>新增分析指标</h3><p>场景三:</p><p>经过各种处理,我们已经可以基于现有的数据做分析了,但现有的指标还是比较单调的,如果我们希望有更多的指标呢?</p><p>比如各年级的,各班的三科总分时多少,各科平均分是多少,多少学生在平均分之上…</p><p>假设需要的指标非常的多，则需要如下操作</p><p>1）要写公式的:【新增公式列】</p><p>2）要算汇总值的:【新增汇总列】</p><p>3）要写多重if嵌套的，直接用:【条件标签列】</p>  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p>真正的数据处理还是要根据实际的业务场景区处理，以上只是大概的处理步骤</p>  </div><h3 id="调整字段"><a href="#调整字段" class="headerlink" title="调整字段"></a>调整字段</h3><p>通过字段设置，可以选择需要保留或排除的字段，快速调整字段位置、重命名字段，从而快速整理数据。</p><p>1）删除多余列</p><p>​有一些不需要参与分析或者空白列，点击字段表头，下拉删除列</p><p>2）转化字段类型</p><p>​分析的时候，会按照字段类型进行分类，用维度衡量指标。需要调整类型不正确的字段。例如1号产品和2号产品不等于3号产品</p><p>3）重命名、翻译字段</p><p>​将一些不规范的字段名进行重命名。例如将英文字段转化为中文</p><h2 id="切换数据源"><a href="#切换数据源" class="headerlink" title="切换数据源"></a>切换数据源</h2><p>当我们已经做了很多分析步骤,但是这时候想要换源数据表。这时候，若我们不想要重新再做一遍这些分析步骤，只需要在第一步【切换数据】即可。系统会自动将当前表和要更换的目标表【字段名称相同的字段】进行匹配。</p>  <div class="note p-4 mb-4 rounded-small orange fa-circle-exclamation 注意">    <p>必须在历史记录的第一步上切换</p>  </div><p>如图所示: A 为切换数据源</p><p>​ B 为数据操作步骤的第一步,且鼠标悬停在B处可查看数据来源</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/09047ac9-6fed-4df1-de97-401529853400/public"                      width = "600"                ><h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><p>计算过程中，我们需要一边分析一边校验查看,查看数据是否跟预期的一样</p><p>点击一个字段，预览下方会自动出现校验数据，帮助用户快速发现问题，快速调整计算。如下图所示：</p><p>1）点击数值字段，显示该列「求和」、「平均」数值</p><p>2）点击文本&#x2F;日期字段，显示该列「去重计数」数值</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3436e139-ca2a-4861-e7e2-1da564e6fd00/public"                      width = "600"                ><p>3）点击下拉框，可以检查该字段中每个字段的计数值，帮助用户检查</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f71de480-b693-4aa6-6b9a-3ee0c51adb00/public"                      width = "600"                >]]></content>
    
    
    <summary type="html">数据处理，帆软BI软件基本操作</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="FineBI" scheme="https://www.yiuhangblog.com/tags/FineBI/"/>
    
    <category term="数据处理" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据分析工具基础 (FineBI)</title>
    <link href="https://www.yiuhangblog.com/2020/05/11/20200511%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.yiuhangblog.com/2020/05/11/20200511%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-11T01:12:43.000Z</published>
    <updated>2024-02-28T10:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一  概念"></a>一  概念</h2><ul><li>数据： 是数据分析的首要材料，它可以是汇总后的数据，也可以是未汇总的原始数据</li><li>数据分析：指的是适当的统计分析方法对收集来的大量数据进行分析，将它们加以汇总和理解并消化，以求最大化开发数据的功能，发挥数据的作用</li><li>数据分析的目的：为了提取有用的信息和形成结论对数据加以详细研究和概括总结的过程，说白了就是以数据为中心，运用各种分析方法和分析手段得到自己的结论</li></ul><h2 id="二-数据分析模式对比"><a href="#二-数据分析模式对比" class="headerlink" title="二  数据分析模式对比"></a>二  数据分析模式对比</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4c8e9c82-f42c-481f-53a5-e26398105e00/public"                      width = "600"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d5d87f32-9f8d-4e88-eb34-e81719f9a100/public"                      width = "600"                ><p>分析模式有两种：</p><p>• 传统分析模式：数据准备可能不够充分，沟通成本大，对业务人员的限制大，工作效率低下，成本大<br>• 自助分析模式: 业务人员能够自主分析，降低沟通成本，效率高</p><h2 id="三-FineBI商业智能工具"><a href="#三-FineBI商业智能工具" class="headerlink" title="三 FineBI商业智能工具"></a>三 FineBI商业智能工具</h2><p>越来越多的企业采购开始偏好现代的、以业务用户为中心的自助服务数据分析平台。传统的以IT为主导的，高度集中化的工具正面临替换。</p><p>FineBI 作为新一代自助大数据分析的商业智能工具，旨在帮助企业快速搭建面向全员的自助分析BI平台，让每一个成员都能充分了解并利用他们的数据，可以自己处理数据、分析数据，从而辅助决策、提升业务效果。</p><p>FineBI 为企业提供了一站式商业智能解决方案，提供了从数据准备、数据处理、可视化分析、数据共享与管理于一体的完整解决方案，创造性地将各种“重科技”轻量化，使用户可以更加直观简便地获取信息、探索知识、共享知识。</p><h3 id="FineBI功能结构"><a href="#FineBI功能结构" class="headerlink" title="FineBI功能结构:"></a>FineBI功能结构:</h3><ul><li>数据层：设计用户创建数据源。</li><li>应用层：设计用户进行仪表板设计，管理用户配置用户和权限体系。</li><li>展示层：普通用户在前端进行可视化展示和分享来编辑和查看仪表板。</li></ul><h2 id="四-BI可视化概念"><a href="#四-BI可视化概念" class="headerlink" title="四 BI可视化概念"></a>四 BI可视化概念</h2><ul><li>商业智能 （Business Intelligence ，简称：BI），指用现代数据仓库技术、线上分析处理技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。</li><li>可视化 （Visualization），是指利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，从而清晰、有效的传达与沟通信息。</li></ul><h2 id="五-FineBI功能介绍"><a href="#五-FineBI功能介绍" class="headerlink" title="五 FineBI功能介绍"></a>五 FineBI功能介绍</h2><h3 id="FineBI分析思路"><a href="#FineBI分析思路" class="headerlink" title="FineBI分析思路"></a>FineBI分析思路</h3><p>FineBI提供分析主题概念，通过分析主题，将用户完成一个分析所需要的数据、组件、仪表板更紧密的联系在一起，通过简单明确的操作路径，实现沉浸式数据分析，轻松掌握分析技能</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/bc6412b1-ec3b-41e6-b5f0-c9ad893eec00/public"                      width = "600"                ><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><ol><li>数据接入，支持30种以上的大数据平台和SQL数据源，支持Excel文件数据集，支持多维数据库，程序数据集等更丰富的数据源。</li><li>数据空间，分为【公共数据】和【我的分析】两个模块。【公共数据】作为企业的数据资源，用户可基于【公共数据】来继续分析，同时用户可将自己的数据发布到【公共数据】中来为其他人提供数据分析的基础。【我的分析】主要用于进行个人数据分析制作仪表板等。</li><li>数据分类，FineBI 以文件夹的形式进行数据管理，让用户可以根据不同的业务包主题进行数据的分类。提供了数据相关的各种信息，让用户更好的了解自己所拥有的数据。</li><li>数据关联，FineBI提供的关联建模功能，让管理员能够在选择需要的数据之后，自动根据数据仓库的关联关系进行建模，同时也提供了手动的关联关系配置，支持组合主键的关联关系配置。基于这样的基础模型，分析用户在使用自助数据集进行自助取数时，可以直接对有关联的数据进行联合分析，而不需要分析用户再去梳理和配置关联关系。</li></ol><h3 id="数据编辑"><a href="#数据编辑" class="headerlink" title="数据编辑"></a>数据编辑</h3><p>FineBI 提供可视化的数据分析，能够快速直观的了解数据，发现数据问题。同时操作简单方便。以用户思维为主导的可视化分析模式能够根据用户选择的数据自动推荐可视化效果，使数据分析更高效</p><h3 id="超强函数"><a href="#超强函数" class="headerlink" title="超强函数"></a>超强函数</h3><p>FineBI除去支持部分常用计算的可视化配置外，还提供了公式来新增计算字段。计算字段允许利用数据源中已存在的数据创建新数据。创建计算字段时，本质上是在数据源中创建一个新字段（或列），其值或成员由所控制的计算来确定。此新计算字段将保存到 FineBI 中，并且可用于创建图表</p><h3 id="数据可视化管理"><a href="#数据可视化管理" class="headerlink" title="数据可视化管理"></a>数据可视化管理</h3><ol><li>多维度探索分析，FineBI 根据数据的类型，自动将数据识别为维度和指标，对于维度和指 标分别提供了丰富的分析功能，方便用户对基础数据进行分析和计算</li><li>可视化图表，基于图形语法设计改良，提供了无限的视觉分析可能。</li><li>仪表板，让用户将多个分析内容，分组组件组合成一个仪表板或者报告，是一个面向分析主题的数据呈现方式。</li></ol><h3 id="数据协作共享"><a href="#数据协作共享" class="headerlink" title="数据协作共享"></a>数据协作共享</h3><p>FineBI 支持【主题协作】【数据共享】【仪表板共享】三种数据协作共享模式。</p><ol><li>【主题协作】：FineBI 将自助数据集、组件、仪表板融合到分析主题中，通过实现分析主题的协作，从而实现了自助数据集，组件，仪表板的共享查看与共享编辑功能。</li><li>【数据共享】：FineBI 支持公共数据的独立模块，在公共数据中，不仅有管理员添加的基础数据集，如DB表，sql数据集等，也支持用户将我的分析中的自助数据集发布到公共数据中。经过用户申请发布数据集、管理员审核、审核通过发布至对应文件夹的流程，实现数据共享。</li><li>【仪表板共享】：在完成数据分析的仪表板以后，可以通过创建公共链接给别人访问、申请发布到目录节点或者直接分享给其他人查看</li></ol><h2 id="六-FineBI基本操作"><a href="#六-FineBI基本操作" class="headerlink" title="六 FineBI基本操作"></a>六 FineBI基本操作</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4fa6edd9-689a-4bf7-c38d-1792e4d02100/public"                      width = "600"                ><ol><li>FineBI主界面的功能选择区</li><li>FineBI功能目录区</li><li>FineBI数据处理主界面区</li></ol><p>注：切换不同的功能选区，功能目录也将跟随变化</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>【目录】主要分为目录区域和预览区域，通常的操作是完成分析报告后把分析报告挂载出来的地方，把分析报告挂载到目录上就可以给其他用户分享</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3856ca73-566b-4990-7cc8-716fec748e00/public"                      width = "600"                ><h4 id="我的分析"><a href="#我的分析" class="headerlink" title="我的分析"></a>我的分析</h4><p>【我的分析】是在BI中进行分析的容器，是我们学习的重点，所有的分析操作都是在【分析主题】中进行。同时【分析主题】支持不同用户之间进行协作编辑，极大的方便了用户对分析内容的共享。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/1a79ab56-97b8-4b06-57ac-8557c7975d00/public"                      width = "600"                ><h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><ul><li>方式一：点击【新建文件夹】或者点击【加号】，再到文件夹下添加相关的数据表和创建分析<ul><li>特点：从创建文件夹开始，所有相关分析表都将在一个文件夹下，更加体现整体关联性，适用于同主题的多个分析的情况</li></ul></li><li>方式二：点击【新建分析主题】<ul><li>特点：直接在分析目录下创建分析主题，分析主题将直接在【全部分析】中展示出来，更加直观的看到分析的结果,适用于分析主题比较单一的情况</li></ul></li><li>方式三: 选中【公共数据】中的数据表，操作界面的右上角有【创建分析主题】<ul><li>特点：直接对现有的数据进行分析</li></ul></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/908a8509-591f-4076-7c26-1ee5c5557600/public"                      width = "200"                ><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p>【选择数据】</p><ul><li>新建分析主题后，会自动进入分析主题内的【选择数据】界面<ul><li>方式一：【当前工程上】直接挑选自己需要的已上传到FineBI中的数据,此处的数据在学习时可以自己提前上传一份数据到【公共数据】中</li><li>方式二：【本地Excel文件】在自己电脑盘符上存放的数据表</li></ul></li><li>以上两种方式选择的数据表选择好之后【确定】上传</li></ul>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <ol><li>以上两种方式没有本质区别，【当前工程上】的数据也是要先从本地上传</li><li>FineBI可上传的表类型为 .csv、.xls、.xlsx 三种格式</li><li>若上传失败，可能是.cvs文件格式导致的,进入[管理系统]-&gt;[安全管理]-&gt;[安全防护]，关闭[文件上传校验]。若还上传失败,则具体问题具体分析</li></ol>    </div>  </div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/21fdff8f-1b19-4baf-8958-3abd6d8b7500/public"                      width = "600"                ><h4 id="公共数据"><a href="#公共数据" class="headerlink" title="公共数据"></a>公共数据</h4><p>【公共数据】顾名思义就是用户可以公共使用的数据存放的地方。管理员可以将复用度很高的表，添加或发布到公共数据集 。如果是个人使用，那我们更多时候的操作是直接在【我的分析】中操作了，对个人来说【公共数据】和【我的分析】其实是一个概念。对于企业来说，【公共数据】是由IT人员或者管理数据的人员来准备数据,我们只需要到这里找自己需要的数据去使用就行了</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8f8799c5-c8c7-4889-6c6b-9d7f05c65200/public"                      width = "600"                ><h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><p>管理系统为管理员进行数据决策系统管理的地方，支持目录、用户、外观、权限等的管理配置</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d27545c0-825d-496d-21af-99bece028400/public"                      width = "600"                ><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="FineBI工程上的数据来源"><a href="#FineBI工程上的数据来源" class="headerlink" title="FineBI工程上的数据来源"></a>FineBI工程上的数据来源</h4><p>数据来源有两种:</p><ul><li>第一种: 当前工程上的数据<ul><li>此种方式是企业一般为我们准备，在【公共数据】里已经添加并授权给我们需要使用的数据。我们可以直接添加即可。</li></ul></li><li>第二种: 本地Excel文件数据</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ba1017f2-cc5d-467e-95c3-55f5e5ab9b00/public"                      width = "300"                >  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>【本地Excel数据】方式的注意点:</p><ol><li>可上传的表类型为 csv、xls、xlsx 三种格式</li><li>在上传 csv 格式文件前，需要关闭「文件上传校验」，才能上传成功。<ul><li>关闭方式：进入【管理系统】-》【安全管理】-》【安全防护 】-》【文件上传校验】</li></ul></li><li>Excel表中首行不能有合并单元格<ul><li>在上传前要确认，添加的 Excel表时，首行不能有合并单元格，否则会上传失败。</li></ul></li><li>Excel表中不能有 Excel 函数计算的内容<ul><li>例如：vlookup(是种查找函数)，sumifs(是多条件求和函数) 函数等</li></ul></li></ol>    </div>  </div><h4 id="数据上传"><a href="#数据上传" class="headerlink" title="数据上传"></a>数据上传</h4><p>数据分析的基础是数据。因此，进入分析主题后的第一步，就是添加数据。<br>数据上传方式：</p><ul><li>方式一：创建分析主题后，会自动进入添加数据页面</li><li>方式二：点击【分析主题】界面的【加号】进入【选择数据】的界面,若需要对多张表进行操作,可点击【批量操作】</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/46c0a03b-4429-4b97-e311-ea252b1a2100/public"                      width = "600"                ><h4 id="上传后的数据存放位置查看"><a href="#上传后的数据存放位置查看" class="headerlink" title="上传后的数据存放位置查看"></a>上传后的数据存放位置查看</h4><p>在进行数据分析前，需要创建分析主题，在分析主题中，可以添加数据，用户进一步的分析。<br>在【我的分析】-&gt;【分析主题】-&gt;【数据】下存放着数据表</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/09a1639d-a505-46fc-5bb9-e04ae9199600/public"                      width = "600"                ><h4 id="数据处理界面"><a href="#数据处理界面" class="headerlink" title="数据处理界面"></a>数据处理界面</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d9def9b1-86df-4cec-9960-d0094549bf00/public"                      width = "600"                ><ul><li>黄色区域：管理主题内的数据表，可以添加，删除，保存，更新数据表等</li><li>绿色区域：数据预览区域</li><li>红色区域：编辑数据区域对数据进行分析，包括表头分析，以及添加分析步骤，分析历史记录等</li></ul><h4 id="数据编辑-1"><a href="#数据编辑-1" class="headerlink" title="数据编辑"></a>数据编辑</h4><p>数据上传成功后，我们可以直接编辑数据。</p><ul><li>如果数据质量好,那就直接进行可视化大屏制作</li><li>如果数据质量差,那就需要先进行数据处理</li></ul><p>[注]数据处理是为了能更快捷、更清晰地完成数据分析和可视化</p><h4 id="哪些情况需要进行数据处理"><a href="#哪些情况需要进行数据处理" class="headerlink" title="哪些情况需要进行数据处理"></a>哪些情况需要进行数据处理</h4><p>原始数据可能存在的问题：</p><ol><li>存在null值,会影响计算</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/223061a6-0f0a-4989-d8e4-95a4d8476200/public"                      width = "300"                ><ol start="2"><li>字段类型不正确时,影响分析<br>例: 数值类型的数字可以计算,但是文本类型的数字不可以计算数</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2e708628-a60e-43e8-5ba9-1a0483f76700/public"                      width = "500"                ><ol start="3"><li>数据的结构不清晰时,不方便分析</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a2e6781d-6b70-4357-6cc4-66b662c94900/public"                      width = "300"                >]]></content>
    
    
    <summary type="html">数据分析基本介绍，帆软BI软件基本介绍和操作</summary>
    
    
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="商务智能" scheme="https://www.yiuhangblog.com/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
    <category term="FineBI" scheme="https://www.yiuhangblog.com/tags/FineBI/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://www.yiuhangblog.com/2019/03/15/20190315%E8%AE%A4%E8%AF%86mysql/"/>
    <id>https://www.yiuhangblog.com/2019/03/15/20190315%E8%AE%A4%E8%AF%86mysql/</id>
    <published>2019-03-15T03:02:13.000Z</published>
    <updated>2024-02-28T10:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库（Database），简称DB，本质上是由一系列文件构成的集合，构建成一个用于存储数据的仓库。这种数据存储系统是建立在文件系统之上的，设计用来以特定格式组织、存储和管理数据。数据库使用户能够对数据执行一系列操作，如增加（Create）、删除（Delete）、修改（Update）和查询（Retrieve）等，从而有效地管理和操纵数据。可以将数据库比喻为哆啦A梦的百宝袋，其中存储的数据就像袋中的各种道具，可以根据需要被取出或存入。</p><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库基于关系模型，即数据以二维表格的形式进行组织。它由一系列具有固定结构（列）和可变数据项（行）的表格（数据表）及这些表格之间的关系所组成。核心元素包括：</p><ul><li><strong>数据行</strong>：代表一条记录，类似于Python中的一个对象。</li><li><strong>数据列</strong>：代表一个字段，相当于对象的属性。</li><li><strong>数据表</strong>：由数据行（记录）的集合构成，每个数据表存储一类相似的数据。</li><li><strong>数据库</strong>：由一个或多个相关数据表的集合构成，形成了数据的整体结构。</li></ul><p>常见的关系型数据库系统包括Oracle、DB2、Microsoft SQL Server、Microsoft Access、和MySQL等。</p><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p>非关系型数据库，也称为NoSQL（Not Only SQL）数据库，是指不仅仅支持SQL的分布式数据存储系统。它不依赖固定的表结构，允许存储无固定格式的数据，因此提供了更为灵活的数据模型，并能够处理大规模分布式数据的存储。非关系型数据库按数据模型可分为：</p><ul><li><strong>键值存储数据库</strong>：以键值对的方式存储数据，适用于快速查询和存储简单数据模型的场景。</li><li><strong>文档型数据库</strong>：存储文档格式数据（如JSON、XML），适用于存储结构化或半结构化的数据，便于开发者直接在应用程序中使用。</li><li><strong>列存储数据库</strong>：将数据以列簇方式存储在硬盘上，适用于分析大规模数据集，提高读写性能。</li><li><strong>图数据库</strong>：使用图结构存储实体及其关系，适合处理复杂的网络结构数据。</li></ul><p>常见的非关系型数据库系统包括NoSql、Cloudant、MongoDb、Redis、HBase等。</p><p>关系型数据库和非关系型数据库各有优势和适用场景。关系型数据库适合需要严格数据完整性和复杂查询的应用场景，而非关系型数据库则更适合于需要灵活数据模型、快速迭代和能够水平扩展处理大量数据的场景。在现代的数据架构设计中，根据应用需求选择合适的数据库类型是至关重要的。</p><h2 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL"></a>什么是MySQL</h2><p>数据库技术是计算机科学领域中发展最迅速且应用最为广泛的技术之一。它在现代信息社会扮演着核心角色，其应用范围覆盖了几乎所有行业和领域。个人身份信息、在线购物的登录、支付和购物车信息、旅行的订票和酒店预订信息、天气和交通信息，以及QQ、微信等通讯服务的数据，都是通过数据库进行记录、查询、修改和管理的。在大数据时代，数据库技术和大数据分析的结合更是释放了巨大的潜力，使得我们能够从庞杂的数据中提炼出难以直接观察到的信息规律和价值，进一步促进了决策制定和创新。</p><p>数据库技术不仅快速发展、应用范围广泛，而且具有高度的信息价值挖掘能力。全球许多最大及发展最快的组织，如Facebook、Twitter、Booking.com、Verizon等，都依赖于MySQL这类数据库管理系统来支撑他们的高容量网站、关键业务系统和软件产品。MySQL数据库，从其诞生之初的完全开源，发展至今已经衍生出了免费的社区版以及收费的标准版和企业版，满足了不同用户和组织的需求。</p><p>随着信息技术的不断进步和大数据技术的应用，数据库技术的发展未来仍然充满广阔的前景。它不仅是现代信息领域从业人员的必备技能，也是推动社会信息化进程、实现数据驱动决策的重要基础。因此，深入理解数据库技术的原理、掌握其应用和管理的技巧，对于追求事业发展和技术创新的专业人士来说至关重要。</p><p>MySQL数据库的结构可以被分解为几个关键的组件，每个组件都扮演着特定的角色，确保数据库能够高效且安全地存储和处理数据。</p><h3 id="形式结构"><a href="#形式结构" class="headerlink" title="形式结构"></a>形式结构</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    Client[客户端] --&gt;|发出请求| LoadBalancer[负载均衡]</span><br><span class="line">    LoadBalancer --&gt;|分发请求| Server1[服务器1]</span><br><span class="line">    LoadBalancer --&gt;|分发请求| Server2[服务器2]</span><br><span class="line">    LoadBalancer --&gt;|分发请求| Server3[服务器3]</span><br><span class="line"></span><br><span class="line">    Server1 --&gt;|读写请求| MySQLMaster[MySQL 主服务器]</span><br><span class="line">    Server2 --&gt;|读写请求| MySQLMaster</span><br><span class="line">    Server3 --&gt;|只读请求| MySQLSlave[MySQL 从服务器]</span><br><span class="line"></span><br><span class="line">    MySQLMaster --&gt;|数据复制| MySQLSlave</span><br><span class="line"></span><br><span class="line">    classDef server fill:#f96,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef database fill:#9f6,stroke:#333,stroke-width:2px;</span><br><span class="line"></span><br><span class="line">    class LoadBalancer,Server1,Server2,Server3 server;</span><br><span class="line">    class MySQLMaster,MySQLSlave database;</span><br></pre></td></tr></table></figure></div><p>客户端发送请求到负载均衡器，负载均衡器将请求分发到多个服务器。服务器对 MySQL 主服务器进行读写操作，而对从服务器进行只读操作。MySQL 主服务器将数据复制到从服务器，以保持数据的一致性。</p><h3 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    Client --&gt;|发送查询| LoadBalancer</span><br><span class="line">    LoadBalancer --&gt;|读请求| Slave1[MySQL 从服务器1]</span><br><span class="line">    LoadBalancer --&gt;|读请求| Slave2[MySQL 从服务器2]</span><br><span class="line">    LoadBalancer --&gt;|写请求| Master[MySQL 主服务器]</span><br><span class="line"></span><br><span class="line">    Master --&gt;|复制日志| Slave1</span><br><span class="line">    Master --&gt;|复制日志| Slave2</span><br><span class="line"></span><br><span class="line">    classDef read fill:#9f6,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef write fill:#f96,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef database fill:#ff6,stroke:#333,stroke-width:2px;</span><br><span class="line"></span><br><span class="line">    class LoadBalancer read;</span><br><span class="line">    class Master write;</span><br><span class="line">    class Slave1,Slave2 database;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>客户端发送查询到负载均衡器。</li><li>负载均衡器根据查询类型将读请求分发到从服务器，将写请求发送到主服务器。</li><li>主服务器处理写请求，并将更改通过复制日志发送到从服务器，确保数据的一致性。</li></ul><h2 id="语句类型"><a href="#语句类型" class="headerlink" title="语句类型"></a>语句类型</h2><p>MySQL作为一款流行的关系型数据库管理系统，提供了一套丰富的语句类型来管理和操作数据库。这些语句类型可以分为四大类：数据定义语言（DDL）、数据操纵语言（DML）、数据查询语言（DQL）和数据控制语言（DCL），每种语言类型都承担着不同的职责和功能。</p><ol><li><strong>数据定义语言（DDL）</strong>：DDL语句用于定义和修改数据库的结构。这包括创建、修改、删除数据库和其中的对象，如表、视图、索引、触发器、存储过程等。DDL操作通常是自动提交的，这意味着一旦执行，就不能回滚。主要的DDL语句包括：<ul><li><code>CREATE</code>：用于创建新的数据库、表、索引等对象。</li><li><code>ALTER</code>：用于修改现有数据库对象的结构。</li><li><code>DROP</code>：用于删除数据库对象。</li><li><code>TRUNCATE</code>：用于删除表中的所有记录，但不删除表本身，这通常比删除每一行要快得多。</li></ul></li><li><strong>数据操纵语言（DML）</strong>：DML语句用于数据库记录的添加、删除、更新，并检查数据的完整性。它们直接影响到数据库中的数据，但不改变数据库的结构。DML主要的语句包括：<ul><li><code>INSERT</code>：用于向表中添加新的记录。</li><li><code>UPDATE</code>：用于修改表中的现有记录。</li><li><code>DELETE</code>：用于从表中删除记录。</li><li><code>SELECT</code>：虽然通常被分类为DQL，但有时也被视为DML的一部分，用于检索数据。</li></ul></li><li><strong>数据查询语言（DQL）</strong>：DQL主要是指<code>SELECT</code>语句，用于查询数据库中表的记录。通过<code>SELECT</code>语句，可以读取一个或多个表中的数据，支持复杂的查询，包括联结、分组和排序等操作。<code>SELECT</code>语句的灵活性和强大功能是数据库交互中最常用的部分之一。</li><li><strong>数据控制语言（DCL）</strong>：DCL语句用于定义或改变数据库的访问权限和安全级别。DCL提供了管理数据库安全性的机制，包括授权用户访问和操作数据库的权限。主要的DCL语句包括：<ul><li><code>GRANT</code>：用于给用户分配权限。</li><li><code>REVOKE</code>：用于撤销用户的权限。</li></ul></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>MySQL 支持所有标准 SQL 数值数据类型。</p><p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。</p><p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p><p>BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。</p><p>作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><hr><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01&#x2F;9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’&#x2F;‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901&#x2F;2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><hr><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255 bytes</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 bytes</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255 bytes</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255 bytes</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535 bytes</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535 bytes</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215 bytes</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215 bytes</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295 bytes</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295 bytes</td><td align="left">极大文本数据</td></tr></tbody></table><p><strong>注意</strong>：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p><p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p><hr><h3 id="枚举与集合类型（Enumeration-and-Set-Types）"><a href="#枚举与集合类型（Enumeration-and-Set-Types）" class="headerlink" title="枚举与集合类型（Enumeration and Set Types）"></a>枚举与集合类型（Enumeration and Set Types）</h3><ul><li><strong>ENUM</strong>: 枚举类型，用于存储单一值，可以选择一个预定义的集合。</li><li><strong>SET</strong>: 集合类型，用于存储多个值，可以选择多个预定义的集合。</li></ul><hr><h3 id="空间数据类型（Spatial-Data-Types）"><a href="#空间数据类型（Spatial-Data-Types）" class="headerlink" title="空间数据类型（Spatial Data Types）"></a>空间数据类型（Spatial Data Types）</h3><p>GEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION: 用于存储空间数据（地理信息、几何图形等）。</p><h2 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h2><p>MySQL数据库通过使用不同类型的约束来保证数据的完整性、准确性以及关系的一致性。约束是施加在表列上的规则，用于限制存入表中的数据类型。以下是MySQL中常见的约束类型，它们各自承担着不同的职责和作用：</p><ol><li><strong>主键约束（Primary Key）</strong>：主键约束确保表中的每一行都有一个唯一标识。因此，被标记为主键的列不允许有重复值，且不能为NULL。一个表中只能有一个主键，该主键可以包含一个或多个列（复合主键）。</li><li><strong>自增约束（Auto Increment）</strong>：自增约束通常与主键一起使用，用于在新记录插入表时自动生成一个唯一的数字。这对于用户不需要手动输入且需保证唯一性的ID非常有用。自增字段通常是整数类型，每当向表中添加新行时，该字段的值会自动递增。</li><li><strong>唯一约束（Unique）</strong>：唯一约束保证表中一列的所有值都是唯一的。这意味着在该列中，两行不能有相同的值。一个表可以有多个唯一约束，但唯一约束允许含有空值（NULL），并且每个唯一约束可以包含多个列。</li><li><strong>非空约束（NOT NULL）</strong>：非空约束确保列中的值不能为NULL。这适用于那些必须有实际值的场合，确保数据的完整性。</li><li><strong>默认约束（Default）</strong>：默认约束为列定义一个默认值。当插入记录时，如果没有为该列提供值，就会使用默认值。这对于定义某些列的典型值非常有用，例如，可以为布尔字段指定默认值<code>false</code>。</li><li><strong>外键约束（Foreign Key）</strong>：外键约束用于建立两个表之间的关系，确保关系的一致性。外键在一个表中的字段（或多个字段）上定义，用于指向另一个表的主键。这保证了在子表中不能添加不存在于父表主键列中的值。如果尝试插入或更新不存在的值，或者删除在子表中仍被引用的父表中的记录，操作会失败并抛出异常。</li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看所有的数据库 </span><br><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/83c6323f-5e2f-4657-3adc-6029a1ca1100/public"                      width = "300"                ><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除数据库 </span><br><span class="line">DROP DATABASE DEMO;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建数据库 </span><br><span class="line">CREATE DATABASE DEMO;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#选择数据库 </span><br><span class="line">USE DEMO;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建数据表</span><br><span class="line">CREATE TABLE class(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    class_name VARCHAR(30),</span><br><span class="line">    class_id INT UNSIGNED DEFAULT 101</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol><li><strong><code>id</code></strong>: 该字段为表的主键，数据类型为整数(<code>INT</code>)。使用了<code>AUTO_INCREMENT</code>属性，意味着每次向表中插入新行时，MySQL会自动为这个字段生成一个唯一的递增数字。这样做确保了表中每条记录的<code>id</code>都是唯一的，便于快速检索和引用。</li><li><strong><code>class_name</code></strong>: 此字段用于存储班级或课程的名称，数据类型为变长字符串(<code>VARCHAR</code>)，最大长度为30个字符。这允许存储各种班级名称，从而为用户提供灵活的命名选项。</li><li><strong><code>class_id</code></strong>: 该字段用于表示班级或课程的唯一标识符，数据类型为无符号整数(<code>INT UNSIGNED</code>)，默认值为101。使用无符号整数意味着这个字段只能存储正数或零，适用于标识符这样的数据。默认值101意味着，如果在插入记录时没有指定<code>class_id</code>的值，它将自动设为101。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/09006e80-e49c-404b-4209-67ba6124e200/public"                      width = "300"                ><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看表结构</span><br><span class="line">DESC class;</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ba6a51e3-2d13-42c8-6706-08229a919900/public"                      width = "600"                ><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> #创建数据表</span><br><span class="line">CREATE TABLE `学生表`(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    stu_name VARCHAR(30),</span><br><span class="line">    age INT UNSIGNED DEFAULT 18,</span><br><span class="line">    `身高` DECIMAL(5,2),</span><br><span class="line">    `性别` ENUM(&#x27;男&#x27;, &#x27;女&#x27;, &#x27;保密&#x27;),</span><br><span class="line">    class_id INT UNSIGNED DEFAULT 101,</span><br><span class="line">    date_id DATE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol><li><strong><code>id</code></strong>: 这是表的主键字段，数据类型为整数(<code>INT</code>)。该字段使用了<code>AUTO_INCREMENT</code>属性，意味着每当向表中插入新行时，MySQL会自动为这个字段生成一个唯一的递增数字，确保每条记录都能通过一个唯一标识符(<code>id</code>)来区分。这对于快速检索、更新或删除特定记录非常有用。</li><li><strong><code>stu_name</code></strong>: 存储学生名称的字段，数据类型为变长字符串(<code>VARCHAR</code>)，最大长度为30个字符。这意味着可以存储最多30个字符的学生名字。</li><li><strong><code>age</code></strong>: 存储学生年龄的字段，使用了无符号整数(<code>INT UNSIGNED</code>)类型，且默认值为18。无符号意味着这个字段只能存储正数或零，适用于年龄这种不会有负值的数据。</li><li><strong><code>身高</code></strong>: 存储学生身高的字段，使用了十进制数(<code>DECIMAL</code>)类型，最大值为999.99（因为定义为<code>(5,2)</code>，意味着总共5位数字，其中2位为小数）。这种类型适用于需要精确表示的数值，如身高。</li><li><strong><code>性别</code></strong>: 用于存储学生性别的字段，数据类型为枚举(<code>ENUM</code>)，只允许三个值：<code>&#39;男&#39;</code>、<code>&#39;女&#39;</code>或<code>&#39;保密&#39;</code>。枚举类型限制了字段可能的值，确保数据的准确性和一致性。</li><li><strong><code>class_id</code></strong>: 表示学生所在班级的ID，使用了无符号整数(<code>INT UNSIGNED</code>)类型，并且默认值为101。这个字段可能用于关联到另一张表（如<code>class</code>表），用于存储班级相关信息。</li><li><strong><code>date_id</code></strong>: 存储日期的字段，数据类型为<code>DATE</code>。这可能用于记录学生入学日期或其他重要日期。<code>DATE</code>类型的格式为<code>YYYY-MM-DD</code>。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2c014804-3d60-4599-562d-7c0ff9f12400/public"                      width = "300"                ><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#删除表</span><br><span class="line">DROP TABLE class;</span><br><span class="line">DROP TABLE `学生表`;</span><br></pre></td></tr></table></figure></div><h2 id="字段操作"><a href="#字段操作" class="headerlink" title="字段操作"></a>字段操作</h2><h3 id="添加新的字段"><a href="#添加新的字段" class="headerlink" title="添加新的字段"></a>添加新的字段</h3><ul><li><p><strong>基本添加</strong>: 使用<code>ADD</code>关键字向表中添加新字段。基本语法如下:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [约束条件];</span><br></pre></td></tr></table></figure></div></li><li><p><strong>在开头添加字段</strong>: 如果需要将新字段添加到表的开始位置，使用<code>FIRST</code>关键字。语法如下:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [约束条件] <span class="keyword">FIRST</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>在中间添加字段</strong>: 要在已存在的字段之后添加新字段，使用<code>AFTER</code>关键字。语法如下:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [约束条件] AFTER <span class="operator">&lt;</span>已经存在的字段名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="修改字段属性-数值类型"><a href="#修改字段属性-数值类型" class="headerlink" title="修改字段属性&#x2F;数值类型"></a>修改字段属性&#x2F;数值类型</h3><ul><li><strong>修改字段类型</strong>: 使用<code>MODIFY</code>关键字修改字段的数据类型或约束。语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> MODIFY <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新数据类型<span class="operator">&gt;</span> [新约束条件];</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="修改字段名称"><a href="#修改字段名称" class="headerlink" title="修改字段名称"></a>修改字段名称</h3><ul><li><strong>修改字段名称和类型</strong>: 使用<code>CHANGE</code>关键字同时更改字段的名称和数据类型。语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> CHANGE <span class="operator">&lt;</span>旧字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新数据类型<span class="operator">&gt;</span> [新约束条件];</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><ul><li><strong>删除字段</strong>: 使用<code>DROP</code>关键字从表中删除字段。语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="添加表数据"><a href="#添加表数据" class="headerlink" title="添加表数据"></a>添加表数据</h3><ul><li><p><strong>基本插入</strong>: 使用<code>INSERT INTO</code>关键字向表中添加数据。基本语法如下:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3.</span>..);</span><br></pre></td></tr></table></figure></div></li><li><p><strong>批量插入示例</strong>: 向<code>students</code>表中插入多条记录。示例如下:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="number">1.82</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">001</span>, <span class="string">&#x27;2019-09-01&#x27;</span>),</span><br><span class="line">...</span><br><span class="line">(<span class="number">17</span>, <span class="string">&#x27;熊二&#x27;</span>, <span class="number">21</span>, <span class="number">1.90</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">002</span>, <span class="string">&#x27;2020-09-01&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><ul><li><strong>基本更新</strong>: 使用<code>UPDATE</code>关键字更新表中的数据。基本语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 数据表名 <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>新值, 字段<span class="number">2</span><span class="operator">=</span>新值 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li><p><strong>物理删除</strong>: 使用<code>DELETE FROM</code>关键字从表中删除数据。基本语法如下:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure></div></li><li><p><strong>逻辑删除</strong>: 通过添加一个字段并改变其值来隐藏数据，而不是物理删除。这样，数据仍然存在于表中，但在查询时不会显示。示例如下:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段 <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><ol><li><p><strong>将id为3的年龄修改为22并且性别为女</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">22</span>, 性别<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>将张三的名字改成怪兽</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> stu_name<span class="operator">=</span><span class="string">&#x27;怪兽&#x27;</span> <span class="keyword">WHERE</span> stu_name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>将女生的名字都修改为rose</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> stu_name<span class="operator">=</span><span class="string">&#x27;rose&#x27;</span> <span class="keyword">WHERE</span> 性别<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>男生的名字修改为jake</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> stu_name<span class="operator">=</span><span class="string">&#x27;jake&#x27;</span> <span class="keyword">WHERE</span> 性别<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li></ol><h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><h3 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h3><ul><li><strong>查询所有字段</strong>: 使用<code>SELECT * FROM 表名;</code>。<code>*</code>代表所有字段，可以根据需要替换为特定的字段名。</li></ul><h3 id="查询指定字段并重命名-AS"><a href="#查询指定字段并重命名-AS" class="headerlink" title="查询指定字段并重命名 (AS)"></a>查询指定字段并重命名 (AS)</h3><ul><li><strong>字段重命名</strong>: 使用<code>AS</code>关键字给查询结果中的列赋予一个新的名称。语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span> <span class="keyword">AS</span> <span class="string">&#x27;新列名1&#x27;</span>, 列名<span class="number">2</span> <span class="keyword">AS</span> <span class="string">&#x27;新列名2&#x27;</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="查询指定字段并去重-DISTINCT"><a href="#查询指定字段并去重-DISTINCT" class="headerlink" title="查询指定字段并去重 (DISTINCT)"></a>查询指定字段并去重 (DISTINCT)</h3><ul><li><p><strong>去重查询</strong>: 使用<code>DISTINCT</code>关键字去除查询结果中的重复项。语法如下:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="行条件查询-WHERE"><a href="#行条件查询-WHERE" class="headerlink" title="行条件查询 (WHERE)"></a>行条件查询 (WHERE)</h3><ul><li><strong>条件查询</strong>: 使用<code>WHERE</code>子句过滤符合特定条件的记录。语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="常见的SQL运算符"><a href="#常见的SQL运算符" class="headerlink" title="常见的SQL运算符"></a>常见的SQL运算符</h4><ol><li><p><strong>算术运算符</strong>:</p><ul><li><code>+</code> (加): 对两个数值进行加法运算。</li><li><code>-</code> (减): 对两个数值进行减法运算或表示一个负数。</li><li><code>*</code> (乘): 对两个数值进行乘法运算。</li><li><code>/</code> (除): 对两个数值进行除法运算。</li><li><code>%</code> (模): 返回两个数相除后的余数。</li></ul></li><li><p><strong>比较运算符</strong>:</p><ul><li><code>=</code> (等于): 检查两个表达式的值是否相等。</li><li><code>!=</code> 或 <code>&lt;&gt;</code> (不等于): 检查两个表达式的值是否不相等。</li><li><code>&gt;</code> (大于): 检查左边表达式的值是否大于右边的值。</li><li><code>&lt;</code> (小于): 检查左边表达式的值是否小于右边的值。</li><li><code>&gt;=</code> (大于等于): 检查左边表达式的值是否大于或等于右边的值。</li><li><code>&lt;=</code> (小于等于): 检查左边表达式的值是否小于或等于右边的值。</li></ul></li><li><p><strong>逻辑运算符</strong>:</p><ul><li><code>AND</code>: 如果所有给定的条件都为真，则返回真。</li><li><code>OR</code>: 如果任一给定的条件为真，则返回真。</li><li><code>NOT</code>: 如果给定的条件为假，则返回真。</li></ul></li><li><p><strong>位运算符</strong>:</p><ul><li><code>&amp;</code>: 按位与操作。</li><li><code>|</code>: 按位或操作。</li><li><code>^</code>: 按位异或操作。</li><li><code>~</code>: 按位非操作。</li></ul></li><li><p><strong>赋值运算符</strong>:</p><ul><li><code>=</code>: 将表达式的值赋给变量或表的列。</li></ul></li></ol><h4 id="使用场景示例"><a href="#使用场景示例" class="headerlink" title="使用场景示例"></a>使用场景示例</h4><ul><li><p><strong>算术运算符</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary, salary <span class="operator">*</span> <span class="number">0.10</span> <span class="keyword">AS</span> bonus <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>比较运算符</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>逻辑运算符</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>位运算符</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> flags, flags <span class="operator">|</span> <span class="number">1</span> <span class="keyword">FROM</span> permissions;</span><br></pre></td></tr></table></figure></div></li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <ol><li><p><strong>优先级</strong>: SQL运算符有不同的优先级，比如算术运算符的优先级高于比较运算符，比较运算符的优先级又高于逻辑运算符。使用括号<code>()</code>可以改变执行顺序。</p></li><li><p><strong>类型兼容性</strong>: 在进行运算时，确保参与运算的数据类型兼容，否则可能会导致错误或不预期的结果。</p></li><li><p><strong>性能考虑</strong>: 在使用逻辑运算符时，尤其是在大型数据集上，应注意其对查询性能的影响。合理使用索引和优化查询条件可以显著提高性能。</p></li><li><p><strong>NULL值的处理</strong>: SQL中的NULL表示一个未知值。在使用比较运算符时，任何包含NULL的比较操作都会返回NULL。使用<code>IS NULL</code>或<code>IS NOT NULL</code>来检查NULL值。</p></li></ol>    </div>  </div><h3 id="模糊查询-LIKE"><a href="#模糊查询-LIKE" class="headerlink" title="模糊查询 (LIKE)"></a>模糊查询 (LIKE)</h3><ul><li><strong>模糊匹配</strong>: 使用<code>LIKE</code>关键字进行模糊查询，<code>%</code>表示任意多个字符，<code>_</code>表示单个任意字符。例如:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">LIKE</span> <span class="string">&#x27;a%&#x27;</span>;  <span class="comment">-- 以a开头的</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;  <span class="comment">-- 包含a的</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">LIKE</span> <span class="string">&#x27;_a&#x27;</span>;   <span class="comment">-- 以任意字符开头，后接a的</span></span><br></pre></td></tr></table></figure></div></li></ul><h3 id="非连续查询-IN"><a href="#非连续查询-IN" class="headerlink" title="非连续查询 (IN)"></a>非连续查询 (IN)</h3><ul><li><strong>指定范围查询</strong>: 使用<code>IN</code>关键字查询列值在指定列表中的记录。语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">IN</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="连续查询-BETWEEN…AND…"><a href="#连续查询-BETWEEN…AND…" class="headerlink" title="连续查询 (BETWEEN…AND…)"></a>连续查询 (BETWEEN…AND…)</h3><ul><li><strong>范围查询</strong>: 使用<code>BETWEEN...AND...</code>查询列值在某个连续范围内的记录。语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">BETWEEN</span> 值<span class="number">1</span> <span class="keyword">AND</span> 值<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="空判断-IS-NULL-IS-NOT-NULL"><a href="#空判断-IS-NULL-IS-NOT-NULL" class="headerlink" title="空判断 (IS NULL, IS NOT NULL)"></a>空判断 (IS NULL, IS NOT NULL)</h3><ul><li><strong>空值查询</strong>: 使用<code>IS NULL</code>或<code>IS NOT NULL</code>检查列值是否为空。语法如下:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><p><strong>查询出所有女生</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p><strong>查询出年龄为18和20和22的学生</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 年龄 <span class="keyword">IN</span> (<span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure></div><p><strong>查询年龄在20到24的学生</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 年龄 <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">24</span>;</span><br></pre></td></tr></table></figure></div><p><strong>查询姓王的学生</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 名字 <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p><strong>查询出所有男生的信息</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p><strong>查询名字带有”王”字的学生</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 名字 <span class="keyword">LIKE</span> <span class="string">&#x27;%王%&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><p>字符函数在SQL中用于对字符串类型的数据进行操作，包括获取长度、拼接、拆分、大小写转换、搜索、裁剪和替换等。以下是一些常用的MySQL字符函数及其应用实例。</p><h3 id="1-获取字符串长度-LENGTH"><a href="#1-获取字符串长度-LENGTH" class="headerlink" title="1. 获取字符串长度: LENGTH()"></a>1. 获取字符串长度: <code>LENGTH()</code></h3><ul><li><strong>作用</strong>: 返回字符串的字节数。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;linli&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="2-拼接字符串-CONCAT"><a href="#2-拼接字符串-CONCAT" class="headerlink" title="2. 拼接字符串: CONCAT()"></a>2. 拼接字符串: <code>CONCAT()</code></h3><ul><li><strong>作用</strong>: 将多个字符串值连接成一个字符串。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(字段<span class="number">1</span>, <span class="string">&#x27; &#x27;</span>, 字段<span class="number">2</span>) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="3-拆分字符串-SUBSTRING-INDEX"><a href="#3-拆分字符串-SUBSTRING-INDEX" class="headerlink" title="3. 拆分字符串: SUBSTRING_INDEX()"></a>3. 拆分字符串: <code>SUBSTRING_INDEX()</code></h3><ul><li><strong>作用</strong>: 根据指定的分隔符拆分字符串，并返回请求的部分。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  SUBSTRING_INDEX(字段, <span class="string">&#x27;分隔符&#x27;</span>, <span class="number">1</span>) <span class="keyword">AS</span> 新字段名<span class="number">1</span>,</span><br><span class="line">  SUBSTRING_INDEX(字段, <span class="string">&#x27;分隔符&#x27;</span>, <span class="number">-1</span>) <span class="keyword">AS</span> 新字段名<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="4-字符串转大写-UPPER"><a href="#4-字符串转大写-UPPER" class="headerlink" title="4. 字符串转大写: UPPER()"></a>4. 字符串转大写: <code>UPPER()</code></h3><ul><li><strong>作用</strong>: 将字符串转换为大写字母。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(<span class="string">&#x27;linli&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(字段) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段 <span class="operator">=</span> <span class="built_in">UPPER</span>(字段);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="5-字符串转小写-LOWER"><a href="#5-字符串转小写-LOWER" class="headerlink" title="5. 字符串转小写: LOWER()"></a>5. 字符串转小写: <code>LOWER()</code></h3><ul><li><strong>作用</strong>: 将字符串转换为小写字母。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(<span class="string">&#x27;linli&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(字段) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段 <span class="operator">=</span> <span class="built_in">LOWER</span>(字段);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="6-字符串中字符首次出现的位置-INSTR"><a href="#6-字符串中字符首次出现的位置-INSTR" class="headerlink" title="6. 字符串中字符首次出现的位置: INSTR()"></a>6. 字符串中字符首次出现的位置: <code>INSTR()</code></h3><ul><li><strong>作用</strong>: 返回子字符串在字符串中第一次出现的位置。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;abcdf&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="7-去除字符串两端的空白-TRIM"><a href="#7-去除字符串两端的空白-TRIM" class="headerlink" title="7. 去除字符串两端的空白: TRIM()"></a>7. 去除字符串两端的空白: <code>TRIM()</code></h3><ul><li><strong>作用</strong>: 去除字符串两端的空格或指定的字符。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(<span class="string">&#x27; abc &#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;aaaaaaaa林里aaaa&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="8-字符串左-右填充-LPAD-RPAD"><a href="#8-字符串左-右填充-LPAD-RPAD" class="headerlink" title="8. 字符串左&#x2F;右填充: LPAD()&#x2F;RPAD()"></a>8. 字符串左&#x2F;右填充: <code>LPAD()</code>&#x2F;<code>RPAD()</code></h3><ul><li><strong>作用</strong>: 使用指定的字符串对原字符串进行左填充或右填充到指定长度。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="string">&#x27;林里&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">&#x27;林里&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="9-替换字符串中的所有指定子串-REPLACE"><a href="#9-替换字符串中的所有指定子串-REPLACE" class="headerlink" title="9. 替换字符串中的所有指定子串: REPLACE()"></a>9. 替换字符串中的所有指定子串: <code>REPLACE()</code></h3><ul><li><strong>作用</strong>: 在字符串中替换所有出现的指定子串。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;周芷若张无忌爱上周芷若&#x27;</span>, <span class="string">&#x27;周芷若&#x27;</span>, <span class="string">&#x27;赵敏&#x27;</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段 <span class="operator">=</span> REPLACE(字段, <span class="string">&#x27;可替换数值&#x27;</span>, <span class="string">&#x27;待替换数值&#x27;</span>) <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>MySQL提供了多种数学函数，用于处理数值数据。这些函数可以执行从基本算术到复杂数学计算的各种操作。</p><h3 id="1-四舍五入-ROUND"><a href="#1-四舍五入-ROUND" class="headerlink" title="1. 四舍五入: ROUND()"></a>1. 四舍五入: <code>ROUND()</code></h3><ul><li><strong>作用</strong>: 对数值进行四舍五入到指定的小数位数。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(数值<span class="operator">/</span>字段, x) <span class="keyword">FROM</span> 表名; <span class="comment">-- x为要保留的小数位数，当x为0时保留整数位</span></span><br></pre></td></tr></table></figure></div></li></ul><h3 id="2-向上取整-CEIL"><a href="#2-向上取整-CEIL" class="headerlink" title="2. 向上取整: CEIL()"></a>2. 向上取整: <code>CEIL()</code></h3><ul><li><strong>作用</strong>: 向上取整，即取大于等于该数的最小整数。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">1.02</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">-1.59</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="3-向下取整-FLOOR"><a href="#3-向下取整-FLOOR" class="headerlink" title="3. 向下取整: FLOOR()"></a>3. 向下取整: <code>FLOOR()</code></h3><ul><li><strong>作用</strong>: 向下取整，即取小于等于该数的最大整数。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">1.02</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">-1.02</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="4-截断-TRUNCATE"><a href="#4-截断-TRUNCATE" class="headerlink" title="4. 截断: TRUNCATE()"></a>4. 截断: <code>TRUNCATE()</code></h3><ul><li><strong>作用</strong>: 将数值截断到指定的小数位数，不进行四舍五入。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.699999</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">69999.999999</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="5-取余-MOD"><a href="#5-取余-MOD" class="headerlink" title="5. 取余: MOD()"></a>5. 取余: <code>MOD()</code></h3><ul><li><strong>作用</strong>: 返回两个数相除的余数。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="6-生成随机数-RAND"><a href="#6-生成随机数-RAND" class="headerlink" title="6. 生成随机数: RAND()"></a>6. 生成随机数: <code>RAND()</code></h3><ul><li><strong>作用</strong>: 生成一个0到1之间的随机浮点数。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RAND();</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h2><p><strong>生成随机整数</strong>:</p><ul><li>生成1到10之间的随机整数:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">10</span>) <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div></li><li>生成-10到10之间的随机整数:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">21</span>) <span class="operator">-</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p>MySQL的日期函数允许对日期和时间值进行操作，包括提取日期部分、转换日期格式等。</p><h3 id="1-获取当前日期和时间-NOW"><a href="#1-获取当前日期和时间-NOW" class="headerlink" title="1. 获取当前日期和时间: NOW()"></a>1. 获取当前日期和时间: <code>NOW()</code></h3><ul><li><strong>作用</strong>: 返回当前的日期和时间。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NOW();</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="2-获取当前日期-CURDATE"><a href="#2-获取当前日期-CURDATE" class="headerlink" title="2. 获取当前日期: CURDATE()"></a>2. 获取当前日期: <code>CURDATE()</code></h3><ul><li><strong>作用</strong>: 返回当前的日期。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CURDATE();</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="3-获取当前时间-CURTIME"><a href="#3-获取当前时间-CURTIME" class="headerlink" title="3. 获取当前时间: CURTIME()"></a>3. 获取当前时间: <code>CURTIME()</code></h3><ul><li><strong>作用</strong>: 返回当前的时间。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CURTIME();</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="4-提取日期部分"><a href="#4-提取日期部分" class="headerlink" title="4. 提取日期部分"></a>4. 提取日期部分</h3><ul><li>获取年份: <code>YEAR()</code></li><li>获取月份: <code>MONTH()</code></li><li>获取日: <code>DAY()</code></li><li>获取星期几: <code>DAYNAME()</code></li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(字段), <span class="keyword">MONTH</span>(字段), <span class="keyword">DAY</span>(字段), DAYNAME(字段) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="5-日期格式转换-STR-TO-DATE"><a href="#5-日期格式转换-STR-TO-DATE" class="headerlink" title="5. 日期格式转换: STR_TO_DATE()"></a>5. 日期格式转换: <code>STR_TO_DATE()</code></h3><ul><li><p><strong>作用</strong>: 将字符串转换为日期格式。</p></li><li><p><strong>示例</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;1998-3-2&#x27;</span>, <span class="string">&#x27;%Y-%c-%d&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 日期列 <span class="operator">=</span> STR_TO_DATE(<span class="string">&#x27;4-3-1992&#x27;</span>, <span class="string">&#x27;%m-%d-%Y&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="6-日期差异函数-DATEDIFF"><a href="#6-日期差异函数-DATEDIFF" class="headerlink" title="6. 日期差异函数: DATEDIFF()"></a>6. 日期差异函数: <code>DATEDIFF()</code></h3><p><code>DATEDIFF()</code>函数在MySQL中用来计算两个日期之间的天数差异。</p><p><strong>示例:</strong></p><ul><li><p>计算两个指定日期之间的天数差:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2022-12-31&#x27;</span>, <span class="string">&#x27;2022-12-01&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li><li><p>计算某个列中的日期与另一个日期之间的天数差，并为结果指定一个新列名:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, DATEDIFF(日期列<span class="number">1</span>, 日期列<span class="number">2</span>) <span class="keyword">AS</span> 新列名 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li><li><p>计算与当前系统日期的天数差:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2022-12-31&#x27;</span>, CURDATE());</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>聚合函数用于执行对一组值的计算，并返回单个值。在MySQL中，常用的聚合函数包括<code>COUNT()</code>, <code>MAX()</code>, <code>MIN()</code>, <code>SUM()</code>, 和<code>AVG()</code>。</p><p><strong>示例:</strong></p><ul><li><p><strong>总数</strong> (<code>COUNT()</code>): 计算表中符合条件的行数。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(字段) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>最大值</strong> (<code>MAX()</code>): 查找字段的最大值。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(字段) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>最小值</strong> (<code>MIN()</code>): 查找字段的最小值。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(字段) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>求和</strong> (<code>SUM()</code>): 计算字段值的总和。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(字段) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>平均值</strong> (<code>AVG()</code>): 计算字段值的平均值。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(字段) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2><ul><li><p>查询女生的人数:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询年龄为18岁的人数:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 年龄 <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询年纪最大的男生:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(年龄) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询女生的最大id:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(id) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询年纪最小的女生:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(年龄) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询男生的最小id:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(id) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询女生的年龄和:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(年龄) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询男生的id和:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(id) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询男生的平均年龄，保留两位小数:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(年龄), <span class="number">2</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="排序和分组"><a href="#排序和分组" class="headerlink" title="排序和分组"></a>排序和分组</h2><h3 id="排序-ORDER-BY"><a href="#排序-ORDER-BY" class="headerlink" title="排序: ORDER BY"></a>排序: <code>ORDER BY</code></h3><p><code>ORDER BY</code>子句用于根据一个或多个列的数值大小或字母顺序对查询结果进行排序，默认为升序排序。</p><ul><li><p><strong>基本排序</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>, 字段<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>升序排序</strong> (<code>ASC</code>):</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>降序排序</strong> (<code>DESC</code>):</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>显示指定行数</strong> (<code>LIMIT</code>):</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 LIMIT <span class="number">1</span>, <span class="number">4</span>; <span class="comment">-- 显示从第二行开始的四行数据</span></span><br></pre></td></tr></table></figure></div></li></ul><h3 id="分组-GROUP-BY"><a href="#分组-GROUP-BY" class="headerlink" title="分组: GROUP BY"></a>分组: <code>GROUP BY</code></h3><p><code>GROUP BY</code>子句按照对应的字段进行分组，查询结果会根据指定的列进行分组，相同值的行将被合并到同一个分组中。</p><ul><li><p><strong>基本分组</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>, 字段<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>分组并计数</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>), 字段<span class="number">1</span>, 字段<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>分组并使用聚合函数</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>), GROUP_CONCAT(字段<span class="number">1</span>), 字段<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>分组汇总</strong> (<code>WITH ROLLUP</code>):</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段 <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="条件筛选-HAVING和WHERE"><a href="#条件筛选-HAVING和WHERE" class="headerlink" title="条件筛选: HAVING和WHERE"></a>条件筛选: <code>HAVING</code>和<code>WHERE</code></h3><ul><li><strong><code>WHERE</code></strong>: 在分组前对数据进行过滤。</li><li><strong><code>HAVING</code></strong>: 在分组后对分组的结果进行条件筛选。</li></ul><h2 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h2><ul><li><p>如果男生或者女生的平均年龄超过18岁就输出他们的平均年龄和性别:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 性别, <span class="built_in">AVG</span>(年龄) <span class="keyword">AS</span> 平均年龄 <span class="keyword">FROM</span> 表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 性别 <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(年龄) <span class="operator">&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询年龄在18-26岁之间的男生，年龄从小到大排序:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">AND</span> 年龄 <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">26</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> 年龄 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查询年龄从18到20的女生，id从低到高排序:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 性别 <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">AND</span> 年龄 <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询是嵌套在另一个查询中的查询，用于提供外部查询使用的条件或数据。</p><ul><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stuname, height <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> height <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(height) <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div></li></ul><p>在这个示例中，<code>(SELECT MAX(height) FROM students WHERE gender = 1)</code>是一个子查询，它先找出所有男生中身高最高的值，然后外部查询使用这个结果来找出具有该身高的学生信息。</p><h2 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h2><p>在数据库中，表连接是用来组合来自两个或多个表的行的过程。根据连接的类型，可以选择不同的方法来组合这些行。</p><h3 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接 (INNER JOIN)"></a>内连接 (INNER JOIN)</h3><ul><li><strong>定义</strong>: 内连接返回两个表中满足连接条件的记录。只有在两个表中都有匹配时，记录才会被包含在结果集中。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 表<span class="number">1.</span>字段<span class="number">1</span>, 表<span class="number">1.</span>字段<span class="number">2</span>, 表<span class="number">2.</span>字段<span class="number">1</span> </span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>字段<span class="number">1</span> <span class="operator">=</span> 表<span class="number">2.</span>字段<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接返回一个表中的所有记录和另一个表中的匹配记录。如果某侧表中的行在另一侧表中没有匹配，结果集中这些行的缺失侧将包含NULL。</p><ul><li><p><strong>左外连接 (LEFT JOIN)</strong>:</p><ul><li><strong>定义</strong>: 返回左表的所有记录和右表中符合连接条件的记录。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 表<span class="number">1.</span>字段<span class="number">1</span>, 表<span class="number">1.</span>字段<span class="number">2</span>, 表<span class="number">2.</span>字段<span class="number">1</span> </span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>字段<span class="number">1</span> <span class="operator">=</span> 表<span class="number">2.</span>字段<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li></ul></li><li><p><strong>右外连接 (RIGHT JOIN)</strong>:</p><ul><li><strong>定义</strong>: 返回右表的所有记录和左表中符合连接条件的记录。</li><li><strong>示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 表<span class="number">1.</span>字段<span class="number">1</span>, 表<span class="number">1.</span>字段<span class="number">2</span>, 表<span class="number">2.</span>字段<span class="number">1</span> </span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>字段<span class="number">1</span> <span class="operator">=</span> 表<span class="number">2.</span>字段<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li></ul></li></ul><h2 id="表连接的区别"><a href="#表连接的区别" class="headerlink" title="表连接的区别"></a>表连接的区别</h2><ul><li><strong>内连接</strong> (<code>INNER JOIN</code>) 只返回两个表中关联字段相匹配的行。</li><li><strong>外连接</strong> (<code>LEFT JOIN</code>, <code>RIGHT JOIN</code>) 除了返回匹配的行外，还会返回左表或右表中未匹配的行，并用NULL填充未匹配的另一侧表的列。</li></ul><h2 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h2><p>假设有一个<code>students</code>表和<code>class</code>表，<code>students</code>表中有学生的信息，包括他们报名的班级，而<code>class</code>表包含班级信息。</p><h3 id="统计两个班各有多少人报名"><a href="#统计两个班各有多少人报名" class="headerlink" title="统计两个班各有多少人报名"></a>统计两个班各有多少人报名</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class.class_name, <span class="built_in">COUNT</span>(students.id) <span class="keyword">AS</span> enrolment_count</span><br><span class="line"><span class="keyword">FROM</span> class</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students <span class="keyword">ON</span> class.id <span class="operator">=</span> students.class_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class.class_name;</span><br></pre></td></tr></table></figure></div><h3 id="统计出他们的在校时间"><a href="#统计出他们的在校时间" class="headerlink" title="统计出他们的在校时间"></a>统计出他们的在校时间</h3><p>这个查询需要有学生的入学时间和当前日期来计算在校时间，假设<code>students</code>表中有一个<code>admission_date</code>字段：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class.class_name, students.id, DATEDIFF(CURDATE(), students.admission_date) <span class="keyword">AS</span> days_in_school</span><br><span class="line"><span class="keyword">FROM</span> class</span><br><span class="line"><span class="keyword">JOIN</span> students <span class="keyword">ON</span> class.id <span class="operator">=</span> students.class_id;</span><br></pre></td></tr></table></figure></div><h3 id="查询出报名了大数据分析基础班的女生人数"><a href="#查询出报名了大数据分析基础班的女生人数" class="headerlink" title="查询出报名了大数据分析基础班的女生人数"></a>查询出报名了大数据分析基础班的女生人数</h3><p>假设<code>students</code>表中有<code>gender</code>字段表示性别：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> female_students_count</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">JOIN</span> class <span class="keyword">ON</span> students.class_id <span class="operator">=</span> class.id</span><br><span class="line"><span class="keyword">WHERE</span> class.class_name <span class="operator">=</span> <span class="string">&#x27;大数据分析基础班&#x27;</span> <span class="keyword">AND</span> students.gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="查询报名了大数据分析全栈在18岁到20岁之间有多少人"><a href="#查询报名了大数据分析全栈在18岁到20岁之间有多少人" class="headerlink" title="查询报名了大数据分析全栈在18岁到20岁之间有多少人"></a>查询报名了大数据分析全栈在18岁到20岁之间有多少人</h3><p>假设<code>students</code>表中有<code>age</code>字段表示年龄：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> students_count</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">JOIN</span> class <span class="keyword">ON</span> students.class_id <span class="operator">=</span> class.id</span><br><span class="line"><span class="keyword">WHERE</span> class.class_name <span class="operator">=</span> <span class="string">&#x27;大数据分析全栈&#x27;</span> <span class="keyword">AND</span> students.age <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div><h2 id="多表连接与高级数据库操作"><a href="#多表连接与高级数据库操作" class="headerlink" title="多表连接与高级数据库操作"></a>多表连接与高级数据库操作</h2><h3 id="1-多表连接"><a href="#1-多表连接" class="headerlink" title="1. 多表连接"></a>1. 多表连接</h3><p>在数据库设计中，多表连接是一种常用的数据查询方式，允许我们从不同的表中提取并合并信息。通过<code>JOIN</code>语句，我们可以实现内连接、左连接、右连接等，以满足不同的数据合并需求。</p><h3 id="2-临时表"><a href="#2-临时表" class="headerlink" title="2. 临时表"></a>2. 临时表</h3><ul><li><strong>定义</strong>: MySQL中的临时表用于存储会话或事务中的临时数据。这些表仅在创建它们的数据库会话中可见，并在会话结束时自动删除。</li><li><strong>应用场景</strong>: 临时表适用于存储查询过程中的临时结果，这对于复杂的数据处理操作特别有用。</li><li><strong>创建临时表</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_table_name (</span><br><span class="line">  column1 datatype,</span><br><span class="line">  column2 datatype,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></li><li><strong>使用示例</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建临时表</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_orders <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询临时表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> temp_orders;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据到临时表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_orders (order_id, customer_id, order_date)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="number">1</span>, <span class="string">&#x27;2023-01-05&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="3-流程控制函数"><a href="#3-流程控制函数" class="headerlink" title="3. 流程控制函数"></a>3. 流程控制函数</h3><p>流程控制函数在SQL查询中用于根据条件返回不同的结果，这提高了SQL语句的灵活性和表达能力。</p><ul><li><p><strong>IF函数</strong>:</p><ul><li>语法: <code>IF(condition, true_value, false_value)</code></li><li>示例: <code>SELECT IF(score &gt;= 60, &#39;Passed&#39;, &#39;Failed&#39;) AS result FROM grades;</code></li></ul></li><li><p><strong>CASE表达式</strong>:</p><ul><li>语法:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,</span><br><span class="line">       <span class="keyword">CASE</span> </span><br><span class="line">           <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> <span class="string">&#x27;result1&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> <span class="string">&#x27;result2&#x27;</span></span><br><span class="line">           <span class="keyword">ELSE</span> <span class="string">&#x27;resultN&#x27;</span></span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></div></li><li>示例:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, </span><br><span class="line">       <span class="keyword">CASE</span> </span><br><span class="line">           <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">&#x27;Excellent&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">&#x27;Good&#x27;</span></span><br><span class="line">           <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">&#x27;Pass&#x27;</span></span><br><span class="line">           <span class="keyword">ELSE</span> <span class="string">&#x27;Fail&#x27;</span></span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">AS</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">FROM</span> scores;</span><br></pre></td></tr></table></figure></div></li></ul></li></ul><h3 id="4-MySQL正则表达式"><a href="#4-MySQL正则表达式" class="headerlink" title="4. MySQL正则表达式"></a>4. MySQL正则表达式</h3><p>MySQL正则表达式提供了一种强大的工具来进行复杂的模式匹配和数据检索。通过使用正则表达式，你可以在SQL查询中执行高级文本匹配，从而筛选出满足特定模式的数据行。这在处理文本数据时尤其有用，比如搜索日志、验证数据格式或提取特定格式的信息等场景。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>在MySQL中，<code>REGEXP</code>或<code>RLIKE</code>运算符用于正则表达式匹配，检查左侧的字符串是否匹配右侧的正则表达式模式。</p><ul><li><strong>语法</strong>:<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> REGEXP <span class="keyword">pattern</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h4><ul><li><code>^</code>: 匹配输入字符串的开始位置。</li><li><code>$</code>: 匹配输入字符串的结束位置。</li><li><code>.</code>: 匹配除“\n”之外的任何单个字符。</li><li><code>*</code>: 匹配前面的字符零次或多次。</li><li><code>+</code>: 匹配前面的字符一次或多次。</li><li><code>?</code>: 匹配前面的字符零次或一次。</li><li><code>[...]</code>: 匹配方括号内的任意字符。</li><li><code>|</code>: 选择，匹配<code>|</code>前后的任一模式。</li><li><code>(..)</code>: 分组标记，将<code>()</code>内的作为一个整体进行处理。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><p><strong>匹配以特定字符开始的字符串</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> REGEXP <span class="string">&#x27;^abc&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>匹配包含特定字符的字符串</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> REGEXP <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>匹配以特定字符结束的字符串</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> REGEXP <span class="string">&#x27;abc$&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>匹配任意位置包含数字的字符串</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> REGEXP <span class="string">&#x27;[0-9]&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>匹配包含两个连续相同字符的字符串</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> REGEXP <span class="string">&#x27;(.)\\1&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h4><ul><li><p><strong>分组和选择</strong>:<br>使用分组<code>()</code>和选择<code>|</code>可以构造更复杂的匹配模式。例如，匹配包含<code>abc</code>或<code>def</code>的字符串：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> REGEXP <span class="string">&#x27;abc|def&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>字符类</strong>:<br>使用字符类<code>[...]</code>可以匹配指定范围内的字符。例如，匹配任何小写字母：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> REGEXP <span class="string">&#x27;[a-z]&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li></ul><p>MySQL的正则表达式功能提供了灵活而强大的数据匹配能力，使得对于复杂文本数据的查询和分析变得更加高效和精确。通过合理利用正则表达式，可以极大地提升数据处理的能力和效率。</p><h3 id="5-UNION操作"><a href="#5-UNION操作" class="headerlink" title="5. UNION操作"></a>5. UNION操作</h3><ul><li><p><strong>定义</strong>: <code>UNION</code>操作符用于合并两个或多个<code>SELECT</code>语句的结果集，并默认去除重复行。</p></li><li><p><strong>语法</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>示例</strong>:</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_name <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> teacher_name <span class="keyword">FROM</span> teachers;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>UNION ALL</strong>: 如果希望保留重复行，可以使用<code>UNION ALL</code>。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure></div></li></ul><p>这些高级功能和操作提供了强大的工具，用于管理和查询数据库中的数据，允许进行复杂的数据分析和处理。通过灵活使用这些工具，可以有效地解决多种数据处理的需求。</p><h2 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h2><p>围绕一个学校的数据库模型，涉及学生(Student)、课程(Course)、教师(Teacher)和成绩(Scores)四个主要表。</p><h3 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h3><ol><li><p><strong>学生表(Student)</strong></p><ul><li>S (VARCHAR(10)): 学生编号</li><li>Sname (VARCHAR(10)): 学生姓名</li><li>Sage (DATETIME): 学生出生日期</li><li>Ssex (VARCHAR(10)): 学生性别</li></ul></li><li><p><strong>课程表(Course)</strong></p><ul><li>C (VARCHAR(10)): 课程编号</li><li>Cname (VARCHAR(10)): 课程名称</li><li>T (VARCHAR(10)): 教师编号</li></ul></li><li><p><strong>教师表(Teacher)</strong></p><ul><li>T (VARCHAR(10)): 教师编号</li><li>Tname (VARCHAR(10)): 教师姓名</li></ul></li><li><p><strong>成绩表(SC)</strong></p><ul><li>S (VARCHAR(10)): 学生编号</li><li>C (VARCHAR(10)): 课程编号</li><li>score (DECIMAL(18,1)): 成绩</li></ul></li></ol><h3 id="查询需求及SQL实现"><a href="#查询需求及SQL实现" class="headerlink" title="查询需求及SQL实现"></a>查询需求及SQL实现</h3><ol><li><p><strong>查询”01”课程比”02”课程成绩高的学生的信息及课程分数</strong></p><p>思路：使用自连接查询<code>SC</code>表，比较同一学生的两门课成绩。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.S, Sname, s1.score <span class="keyword">AS</span> <span class="string">&#x27;01_Score&#x27;</span>, s2.score <span class="keyword">AS</span> <span class="string">&#x27;02_Score&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> SC s1</span><br><span class="line"><span class="keyword">JOIN</span> SC s2 <span class="keyword">ON</span> s1.S <span class="operator">=</span> s2.S <span class="keyword">AND</span> s1.C <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> <span class="keyword">AND</span> s2.C <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span></span><br><span class="line"><span class="keyword">JOIN</span> Student <span class="keyword">ON</span> Student.S <span class="operator">=</span> s1.S</span><br><span class="line"><span class="keyword">WHERE</span> s1.score <span class="operator">&gt;</span> s2.score;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询同时选修01和02课程的情况</strong></p><p>思路：查找同时在<code>SC</code>表中存在课程编号为”01”和”02”记录的学生。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s.S, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student s</span><br><span class="line"><span class="keyword">JOIN</span> SC sc1 <span class="keyword">ON</span> s.S <span class="operator">=</span> sc1.S <span class="keyword">AND</span> sc1.C <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="keyword">JOIN</span> SC sc2 <span class="keyword">ON</span> s.S <span class="operator">=</span> sc2.S <span class="keyword">AND</span> sc2.C <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询存在”01”课程但可能不存在”02”课程的情况</strong></p><p>思路：使用左连接确保”01”课程存在，而”02”课程可能不存在。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s.S, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student s</span><br><span class="line"><span class="keyword">JOIN</span> SC sc1 <span class="keyword">ON</span> s.S <span class="operator">=</span> sc1.S <span class="keyword">AND</span> sc1.C <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SC sc2 <span class="keyword">ON</span> s.S <span class="operator">=</span> sc2.S <span class="keyword">AND</span> sc2.C <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> sc2.S <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询不存在”01”课程但存在”02”课程的情况</strong></p><p>思路：反转第3题的逻辑，使用左连接确保”02”课程存在，而”01”课程不存在。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s.S, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student s</span><br><span class="line"><span class="keyword">JOIN</span> SC sc2 <span class="keyword">ON</span> s.S <span class="operator">=</span> sc2.S <span class="keyword">AND</span> sc2.C <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SC sc1 <span class="keyword">ON</span> s.S <span class="operator">=</span> sc1.S <span class="keyword">AND</span> sc1.C <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> sc1.S <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</strong></p><p>思路：对<code>SC</code>表进行分组聚合查询，计算每个学生的平均成绩。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.S, Sname, <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> Avg_Score</span><br><span class="line"><span class="keyword">FROM</span> Student s</span><br><span class="line"><span class="keyword">JOIN</span> SC <span class="keyword">ON</span> s.S <span class="operator">=</span> SC.S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s.S, Sname</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(score) <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询SC表存在成绩的学生信息</strong></p><p>思路：查询<code>SC</code>表中有成绩记录的学生信息。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Student.S, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.S <span class="operator">=</span> SC.S;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩</strong></p><p>思路：对<code>SC</code>表进行分组聚合查询，同时计算选课总数和成绩总和。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.S, Sname, <span class="built_in">COUNT</span>(SC.C) <span class="keyword">AS</span> Course_Count, <span class="built_in">SUM</span>(SC.score) <span class="keyword">AS</span> Total_Score</span><br><span class="line"><span class="keyword">FROM</span> Student s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> s.S <span class="operator">=</span> SC.S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s.S, Sname;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查没有成绩的学生信息</strong></p><p>思路：查询<code>Student</code>表中不存在于<code>SC</code>表中的学生信息。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> S <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> S <span class="keyword">FROM</span> SC);</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询「李」姓老师的数量</strong></p><p>思路：根据教师姓名筛选并计数。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> Li_Teachers</span><br><span class="line"><span class="keyword">FROM</span> Teacher</span><br><span class="line"><span class="keyword">WHERE</span> Tname <span class="keyword">LIKE</span> <span class="string">&#x27;李%&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询学过「张三」老师授课的同学的信息</strong></p><p>思路：先找到「张三」老师的课程，再查询选修这些课程的学生信息。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Student.S, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.S <span class="operator">=</span> SC.S</span><br><span class="line"><span class="keyword">JOIN</span> Course <span class="keyword">ON</span> SC.C <span class="operator">=</span> Course.C</span><br><span class="line"><span class="keyword">JOIN</span> Teacher <span class="keyword">ON</span> Course.T <span class="operator">=</span> Teacher.T</span><br><span class="line"><span class="keyword">WHERE</span> Teacher.Tname <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询没有学全所有课程的同学的信息</strong></p><p>思路：需要比较学生选修的课程数量和课程表中课程总数。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.S, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student s</span><br><span class="line"><span class="keyword">JOIN</span> SC <span class="keyword">ON</span> s.S <span class="operator">=</span> SC.S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s.S, Sname</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> SC.C) <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Course);</span><br></pre></td></tr></table></figure></div></li><li><p><strong>查询至少有一门课与学号为”01”的同学所学相同的同学的信息</strong></p><p>思路：首先找出学号为”01”的同学所学的课程，然后查找至少选修了这些课程之一的其他同学。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Student.S, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.S <span class="operator">=</span> SC.S</span><br><span class="line"><span class="keyword">WHERE</span> SC.C <span class="keyword">IN</span> (<span class="keyword">SELECT</span> SC.C <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> S <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span>) <span class="keyword">AND</span> Student.S <span class="operator">!=</span> <span class="string">&#x27;01&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li></ol><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>本项目通过分析广州的wassup网店在12月份的用户交易情况和产品情况，目的是为了提供数据支持，帮助店主更好地经营小店。通过对产品情况表<code>product_tb</code>和销售数据表<code>sales_tb</code>的查询分析，以下是从五个关键方面的详细分析和查询实现。</p><h3 id="产品情况表-product-tb"><a href="#产品情况表-product-tb" class="headerlink" title="产品情况表 (product_tb)"></a>产品情况表 (<code>product_tb</code>)</h3><ul><li><strong>表结构</strong>：<ul><li><code>item_id</code> (VARCHAR(30)): 商品的具体货号。</li><li><code>style_id</code> (VARCHAR(30)): 商品的款号。</li><li><code>tag_price</code> (INT): 商品的标签价格。</li><li><code>inventory</code> (INT): 商品的库存量。</li></ul></li><li><strong>示例数据</strong>：<ul><li>商品范围从A001到C002，覆盖三个不同的款式（A、B、C）。</li><li>每个款式下有不同的货号，价格和库存量各不相同。</li></ul></li></ul><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_tb(item_id <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">                        style_id <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">                        tag_price <span class="type">INT</span>,</span><br><span class="line">                        inventory <span class="type">INT</span>);</span><br><span class="line">                        </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_tb <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;A001&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">100</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="string">&#x27;A002&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">120</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="string">&#x27;A003&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">200</span>,<span class="number">15</span>),</span><br><span class="line">(<span class="string">&#x27;B001&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">130</span>,<span class="number">18</span>),</span><br><span class="line">(<span class="string">&#x27;B002&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">150</span>,<span class="number">22</span>),</span><br><span class="line">(<span class="string">&#x27;B003&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">125</span>,<span class="number">10</span>),</span><br><span class="line">(<span class="string">&#x27;B004&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">155</span>,<span class="number">12</span>),</span><br><span class="line">(<span class="string">&#x27;C001&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="number">260</span>,<span class="number">25</span>),</span><br><span class="line">(<span class="string">&#x27;C002&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="number">280</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure></div><h3 id="销售数据表-sales-tb"><a href="#销售数据表-sales-tb" class="headerlink" title="销售数据表 (sales_tb)"></a>销售数据表 (<code>sales_tb</code>)</h3><ul><li><strong>表结构</strong>：<ul><li><code>sales_date</code> (DATE): 销售日期。</li><li><code>user_id</code> (INT): 用户编号。</li><li><code>item_id</code> (VARCHAR(30)): 销售的商品货号。</li><li><code>sales_num</code> (INT): 销售数量。</li><li><code>sales_price</code> (INT): 销售结算金额。</li></ul></li><li><strong>示例数据</strong>：<ul><li>销售记录从2023-12-01到2023-12-06，涵盖了多个用户对不同货号商品的购买行为。</li><li>销售数据包含销售数量和销售结算金额，可以通过这些数据分析商品的销售情况和用户购买偏好。</li></ul></li></ul><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales_tb(sales_date <span class="type">DATE</span>,</span><br><span class="line">                      user_id <span class="type">INT</span>,</span><br><span class="line">                      item_id <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">                      sales_num <span class="type">INT</span>,</span><br><span class="line">                      sales_price <span class="type">INT</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales_tb <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;2023-12-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;A001&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">90</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-01&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;A002&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="number">220</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-01&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;B001&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">120</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-02&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;C001&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="number">500</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-02&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;B001&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">120</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-03&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;C001&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">240</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-03&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;C002&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">270</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-04&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;A003&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">180</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-04&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;B002&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">140</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-04&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;B001&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">125</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-04&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;B003&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">120</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-05&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;B004&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">150</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-05&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;A003&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">180</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-06&#x27;</span>,<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;B003&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">120</span>),</span><br><span class="line">(<span class="string">&#x27;2023-12-06&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;B004&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">150</span>);</span><br></pre></td></tr></table></figure></div><h3 id="问题1-查询每款的SPU（货号）数量及排序"><a href="#问题1-查询每款的SPU（货号）数量及排序" class="headerlink" title="问题1: 查询每款的SPU（货号）数量及排序"></a>问题1: 查询每款的SPU（货号）数量及排序</h3><ul><li><strong>目的</strong>：了解店铺的产品种类和每个款式下具体货号的数量。</li><li><strong>SQL 查询</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> style_id, <span class="built_in">COUNT</span>(item_id) <span class="keyword">AS</span> SPU </span><br><span class="line"><span class="keyword">FROM</span> product_tb </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> style_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">COUNT</span>(item_id) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="问题2-查询实际总销售额与客单价"><a href="#问题2-查询实际总销售额与客单价" class="headerlink" title="问题2: 查询实际总销售额与客单价"></a>问题2: 查询实际总销售额与客单价</h3><ul><li><strong>目的</strong>：分析用户的平均消费金额，以及总销售额。</li><li><strong>SQL 查询</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="built_in">SUM</span>(sales_price) <span class="keyword">AS</span> `销售总额`,</span><br><span class="line">  ROUND(<span class="built_in">SUM</span>(sales_price)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id), <span class="number">2</span>) <span class="keyword">AS</span> `客单价`</span><br><span class="line"><span class="keyword">FROM</span> sales_tb;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="问题3-查询折扣率"><a href="#问题3-查询折扣率" class="headerlink" title="问题3: 查询折扣率"></a>问题3: 查询折扣率</h3><ul><li><strong>目的</strong>：分析店铺的促销效果，了解整体和各款式、各货号的折扣情况。</li><li><strong>总的折扣率查询</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(</span><br><span class="line">  (<span class="number">1</span> <span class="operator">-</span> <span class="built_in">SUM</span>(sales_price) <span class="operator">/</span> <span class="built_in">SUM</span>(sales_tb.sales_num <span class="operator">*</span> product_tb.tag_price)) <span class="operator">*</span> <span class="number">100</span>, <span class="string">&#x27;%&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> `折扣率`</span><br><span class="line"><span class="keyword">FROM</span> sales_tb</span><br><span class="line"><span class="keyword">JOIN</span> product_tb <span class="keyword">ON</span> sales_tb.item_id <span class="operator">=</span> product_tb.item_id;</span><br></pre></td></tr></table></figure></div></li><li><strong>每个款号的折扣率查询</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_tb.style_id, CONCAT(</span><br><span class="line">  ((<span class="built_in">SUM</span>(sales_tb.sales_num <span class="operator">*</span> product_tb.tag_price) <span class="operator">-</span> <span class="built_in">SUM</span>(sales_tb.sales_price))</span><br><span class="line">  <span class="operator">/</span> <span class="built_in">SUM</span>(sales_tb.sales_num <span class="operator">*</span> product_tb.tag_price)) <span class="operator">*</span> <span class="number">100</span>, <span class="string">&#x27;%&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> `折扣率`</span><br><span class="line"><span class="keyword">FROM</span> sales_tb</span><br><span class="line"><span class="keyword">JOIN</span> product_tb <span class="keyword">ON</span> sales_tb.item_id <span class="operator">=</span> product_tb.item_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_tb.style_id;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="问题4-查询每款的动销率与售罄率"><a href="#问题4-查询每款的动销率与售罄率" class="headerlink" title="问题4: 查询每款的动销率与售罄率"></a>问题4: 查询每款的动销率与售罄率</h3><ul><li><strong>目的</strong>：了解每款产品的销售情况，包括动销率和售罄率，以评估库存和销售效率。</li><li><strong>SQL 查询</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   a.style_id,                                            </span><br><span class="line">   ROUND(b.sum_num<span class="operator">/</span>(a.sum_inv<span class="operator">-</span>b.sum_num)<span class="operator">*</span><span class="number">100</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;pin_rate(%)&#x27;</span>,   </span><br><span class="line">   ROUND(b.GMV<span class="operator">/</span>a.sum_pri<span class="operator">*</span><span class="number">100</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;sell-through_rate(%)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">   (<span class="keyword">SELECT</span> style_id, <span class="built_in">SUM</span>(inventory) <span class="keyword">AS</span> sum_inv, <span class="built_in">SUM</span>(tag_price <span class="operator">*</span> inventory) <span class="keyword">AS</span> sum_pri</span><br><span class="line">    <span class="keyword">FROM</span> product_tb</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> style_id) <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">   (<span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(item_id, <span class="number">1</span>) <span class="keyword">AS</span> style_id, <span class="built_in">SUM</span>(sales_num) <span class="keyword">AS</span> sum_num, <span class="built_in">SUM</span>(sales_price) <span class="keyword">AS</span> GMV</span><br><span class="line">    <span class="keyword">FROM</span> sales_tb</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> style_id) <span class="keyword">AS</span> b </span><br><span class="line"><span class="keyword">ON</span> a.style_id <span class="operator">=</span> b.style_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.style_id;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="问题5-查询连续2天及以上在该店铺购物的用户及其对应的次数"><a href="#问题5-查询连续2天及以上在该店铺购物的用户及其对应的次数" class="headerlink" title="问题5: 查询连续2天及以上在该店铺购物的用户及其对应的次数"></a>问题5: 查询连续2天及以上在该店铺购物的用户及其对应的次数</h3><ul><li><strong>目的</strong>：分析用户消费频率与粘性，特别是连续购物行为的用户。</li><li><strong>SQL 查询</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   user_id,</span><br><span class="line">   <span class="built_in">COUNT</span>(rn)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span></span><br><span class="line">      <span class="keyword">DISTINCT</span> user_id,</span><br><span class="line">      sales_date,</span><br><span class="line">      <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sales_date) rn</span><br><span class="line">   <span class="keyword">FROM</span> sales_tb) <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id, DATE_SUB(sales_date, <span class="type">INTERVAL</span> rn <span class="keyword">DAY</span>)</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div></li></ul><p>以上分析从产品种类和数量、销售额和客单价、促销折扣率、产品动销率和售罄率、以及用户消费频率和粘性五个方面全面分析了wassup网店的12月份经营情况。这些数据分析可以为店铺</p>]]></content>
    
    
    <summary type="html">MySQL的认识操作，可视化图表创建</summary>
    
    
    
    <category term="数据库" scheme="https://www.yiuhangblog.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据库" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="SQL" scheme="https://www.yiuhangblog.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib</title>
    <link href="https://www.yiuhangblog.com/2018/12/06/20181206Matplotlib/"/>
    <id>https://www.yiuhangblog.com/2018/12/06/20181206Matplotlib/</id>
    <published>2018-12-06T08:39:37.000Z</published>
    <updated>2024-03-19T11:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>Matplotlib 是一个广泛用于 Python 中的绘图库，它可以帮助我们创建各种图表和图形，适用于数据可视化。</p><h3 id="安装-Matplotlib"><a href="#安装-Matplotlib" class="headerlink" title="安装 Matplotlib"></a>安装 Matplotlib</h3><p>为了安装 Matplotlib，我们首先确保 Python 和 pip（Python 的包安装器）已经安装在系统上。接着可以通过下面的命令来安装或更新 Matplotlib：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先，更新 pip 到最新版本</span></span><br><span class="line">python -m pip install --upgrade pip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后，使用 pip 安装 Matplotlib</span></span><br><span class="line">python -m pip install matplotlib</span><br></pre></td></tr></table></figure></div><p>注意，如果使用的是 Linux 或 macOS 系统，可能需要使用 <code>python3</code> 和 <code>pip3</code> 命令替代 <code>python</code> 和 <code>pip</code>。</p><h3 id="导入-Matplotlib"><a href="#导入-Matplotlib" class="headerlink" title="导入 Matplotlib"></a>导入 Matplotlib</h3><p>安装完成后，我们可以通过以下方式导入 Matplotlib：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br></pre></td></tr></table></figure></div><p>实际上，更常见的做法是导入 <code>matplotlib.pyplot</code>，这是一个提供了类似 MATLAB 接口的绘图模块：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></div><h3 id="Matplotlib-Pyplot-常用函数"><a href="#Matplotlib-Pyplot-常用函数" class="headerlink" title="Matplotlib Pyplot 常用函数"></a>Matplotlib Pyplot 常用函数</h3><p>Pyplot 模块提供了很多用于创建和操作图形的函数。以下是一些常用的 Pyplot 函数：</p><ul><li><p><code>plot()</code>：这是最常用的函数之一，用于绘制点和线。例如，<code>plt.plot(x, y)</code> 会绘制 x 对 y 的图。</p></li><li><p><code>scatter()</code>：这个函数专门用于创建散点图。例如，<code>plt.scatter(x, y)</code> 会创建 x 和 y 数据点的散点图。</p></li><li><p><code>bar()</code>：这个函数用来创建条形图。例如，<code>plt.bar(x, height)</code> 会在 x 的位置创建条形图，其中 height 是条形的高度。</p></li><li><p><code>hist()</code>：此函数用于绘制直方图，是数据分布可视化的重要工具。例如，<code>plt.hist(data)</code> 会绘制 data 的直方图。</p></li><li><p><code>pie()</code>：这个函数用于绘制饼图，常用于显示部分整体的比例关系。例如，<code>plt.pie(sizes)</code> 会根据 sizes 的比例绘制一个饼图。</p></li><li><p><code>imshow()</code>：这个函数常用于显示图像，特别是在处理图像数据的时候。例如，<code>plt.imshow(image)</code> 会显示一个图像数组。</p></li><li><p><code>subplots()</code>：此函数用于创建一个包含多个子图的图形。例如，<code>fig, ax = plt.subplots()</code> 创建一个新的图形和一个子图。</p></li></ul><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>下面是一个简单的 Matplotlib Pyplot 使用示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建图表</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制线图</span></span><br><span class="line">plt.plot(x, y, label=<span class="string">&#x27;Line&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">plt.scatter(x, y, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;Scatter&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加标题和标签</span></span><br><span class="line">plt.title(<span class="string">&#x27;Sample Plot&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X Axis&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y Axis&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图例</span></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><ul><li><p><strong>图形风格</strong>：Matplotlib 允许选择多种预设的风格，例如 <code>plt.style.use(&#39;ggplot&#39;)</code>。</p></li><li><p><strong>保存图形</strong>：可以使用 <code>plt.savefig(&#39;filename.png&#39;)</code> 将图形保存到文件中。</p></li><li><p><strong>交互式模式</strong>：Matplotlib 还可以创建交互式图形，使用 <code>plt.ion()</code> 开启交互模式。</p></li></ul><h2 id="完整制作示例"><a href="#完整制作示例" class="headerlink" title="完整制作示例"></a>完整制作示例</h2><p>制作图表是数据分析中一项重要的工作，它有助于从视觉上展现和理解数据。提供的步骤是图表制作的基本流程，包括了从导入库到设置xy轴数据，以及绘制和显示图形。现在我们就来细化这个流程，并添加一些细节和扩展，使其更为完整和专业。</p><h3 id="步骤1：导入必要的库"><a href="#步骤1：导入必要的库" class="headerlink" title="步骤1：导入必要的库"></a>步骤1：导入必要的库</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure></div><p>这一步导入了创建图表所需的主要 Python 库：<code>matplotlib</code> 用于绘图，<code>numpy</code> 用于处理数值数据，<code>pandas</code> 用于读取和处理数据文件。</p><h3 id="步骤2：设置xy轴数据"><a href="#步骤2：设置xy轴数据" class="headerlink" title="步骤2：设置xy轴数据"></a>步骤2：设置xy轴数据</h3><h4 id="方法1：使用-Numpy-创建数据"><a href="#方法1：使用-Numpy-创建数据" class="headerlink" title="方法1：使用 Numpy 创建数据"></a>方法1：使用 Numpy 创建数据</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xpoints = np.array([<span class="number">0</span>, <span class="number">6</span>])</span><br><span class="line">ypoints = np.array([<span class="number">0</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure></div><p>这个方法是手动创建数据，适合理解绘图的基础概念或当有一些固定的数据点时使用。</p><h4 id="方法2：从数据文件导入"><a href="#方法2：从数据文件导入" class="headerlink" title="方法2：从数据文件导入"></a>方法2：从数据文件导入</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 CSV 文件中读取数据</span></span><br><span class="line">open_df = pd.read_csv(<span class="string">&#x27;./财务差旅人员费用分析.csv&#x27;</span>)</span><br><span class="line">xpoints = open_df[<span class="string">&#x27;姓名&#x27;</span>]</span><br><span class="line">ypoints = open_df[<span class="string">&#x27;金额&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个例子</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./年龄段借款情况.csv&#x27;</span>)</span><br><span class="line">xpoints = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">ypoints = df[<span class="string">&#x27;已还清&#x27;</span>]</span><br></pre></td></tr></table></figure></div><p>在实际应用中，数据通常来源于数据集，因此使用 Pandas 读取和处理数据是非常常见的。</p><h3 id="步骤3：绘制图形"><a href="#步骤3：绘制图形" class="headerlink" title="步骤3：绘制图形"></a>步骤3：绘制图形</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制基础的线图</span></span><br><span class="line">plt.plot(xpoints, ypoints)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表的标题和轴标签</span></span><br><span class="line">plt.title(<span class="string">&#x27;Loan Status by Age&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loans Paid Off&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图例</span></span><br><span class="line">plt.legend([<span class="string">&#x27;Loans Paid Off&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在图表中添加网格</span></span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置轴的范围</span></span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>这一步创建了图形，并对其进行了一些基础的格式设置，包括添加标题、轴标签、图例和网格，这使图表更易于理解和分析。</p><h3 id="扩展和细节"><a href="#扩展和细节" class="headerlink" title="扩展和细节"></a>扩展和细节</h3><ul><li><p><strong>样式定制</strong>：可以通过添加颜色、线型和标记样式来定制图形的外观，如 <code>plt.plot(xpoints, ypoints, &#39;o:r&#39;)</code>，表示圆圈标记、虚线和红色。</p></li><li><p><strong>多系列绘制</strong>：可以在同一个图中绘制多个数据系列，以对比不同数据集，如通过多次调用 <code>plt.plot()</code>。</p></li><li><p><strong>子图</strong>：使用 <code>plt.subplots()</code> 创建一个包含多个子图的图形布局。</p></li><li><p><strong>保存图形</strong>：使用 <code>plt.savefig(&#39;filename.png&#39;)</code> 将图形保存到文件中。</p></li><li><p><strong>其他图形类型</strong>：除了线图，还可以使用 <code>plt.bar()</code>, <code>plt.scatter()</code>, <code>plt.hist()</code> 等函数来创建条形图、散点图和直方图等。</p></li></ul><p>通过以上步骤，我们可以创建一个简单但完整的图表。在实践中，可能需要根据数据的具体情况和分析目的进行更多的定制和调整。使用 Matplotlib，可以灵活地制作出满足不同需求的图表。</p><p>图表的属性能够帮助我们创建更为精细和吸引人的视觉效果，这对于数据的呈现和解释非常重要。以下是有关如何使用 Matplotlib 的一些详细和专业的笔记，涵盖了图表窗口的创建和自定义，以及如何使用标记来突出数据点。</p><h2 id="图表属性"><a href="#图表属性" class="headerlink" title="图表属性"></a>图表属性</h2><h3 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的图形窗口并设置尺寸</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>), dpi=<span class="number">150</span>, facecolor=<span class="string">&#x27;white&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>, tight_layout=<span class="literal">True</span>, num=<span class="string">&#x27;Window 1&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>画布属性说明：</p><ul><li><code>figsize</code>: 设置图形窗口的尺寸，单位为英寸。更大的尺寸可以让图表更清晰地显示更多的细节。</li><li><code>dpi</code>: 分辨率（每英寸点数），默认通常为 100 或 80。增加此值可以获得更高清的图形。</li><li><code>facecolor</code> 和 <code>edgecolor</code>: 分别用于设置图形窗口的背景色和边框颜色。</li><li><code>tight_layout</code>: 当设置为 <code>True</code> 时，它会自动调整子图参数，以便子图填满图形窗口的整个画布区域。</li><li><code>num</code>: 当你需要创建多个图形窗口时，使用此参数给图形命名或编号。</li></ul><h3 id="Marker"><a href="#Marker" class="headerlink" title="Marker"></a>Marker</h3><p>在 <code>plt.plot()</code> 中使用 <code>marker</code> 参数可以突出显示每个数据点，提高图表的可读性，特别是在绘制散点图或者需要标示数据点的场景中。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xpoints = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">ypoints = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制带有自定义标记的线图</span></span><br><span class="line">plt.plot(xpoints, ypoints, marker=<span class="string">&#x27;o&#x27;</span>, ms=<span class="number">20</span>, mfc=<span class="string">&#x27;r&#x27;</span>, mec=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>Marker 相关属性说明：</p><ul><li><code>marker</code>: 定义数据点的标记类型，如 <code>&#39;o&#39;</code> 表示圆圈。</li><li><code>ms</code> (markersize): 标记的大小。</li><li><code>mfc</code> (markerfacecolor): 标记内部的颜色。</li><li><code>mec</code> (markeredgecolor): 标记边框的颜色。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6dae7a6b-6f7a-4223-16c8-744561ac4200/public"                      width = "600"                ><h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><ul><li><p><strong>线条样式</strong>: 通过 <code>linestyle</code> 或简写 <code>ls</code> 参数定义线条的样式，如 <code>&#39;--&#39;</code> 表示虚线。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(xpoints, ypoints, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>线条宽度</strong>: 使用 <code>linewidth</code> 或简写 <code>lw</code> 参数定义线条的宽度。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(xpoints, ypoints, linewidth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>颜色</strong>: 通过 <code>color</code> 参数指定线条的颜色。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(xpoints, ypoints, color=<span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>文本和注释</strong>: 使用 <code>plt.text()</code> 在图表中添加文本，使用 <code>plt.annotate()</code> 在图表中添加注释。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.text(<span class="number">1</span>, <span class="number">15</span>, <span class="string">&#x27;Sample Text&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">plt.annotate(<span class="string">&#x27;Important Point&#x27;</span>, xy=(<span class="number">2</span>, <span class="number">4</span>), xytext=(<span class="number">3</span>, <span class="number">5</span>), arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">&#x27;-&gt;&#x27;</span>))</span><br></pre></td></tr></table></figure></div></li><li><p><strong>坐标轴范围</strong>: 使用 <code>plt.xlim()</code> 和 <code>plt.ylim()</code> 设置坐标轴的范围。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>坐标轴标签</strong>: 使用 <code>plt.xlabel()</code> 和 <code>plt.ylabel()</code> 给坐标轴添加标签。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&#x27;X Axis Label&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y Axis Label&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>图表标题</strong>: 使用 <code>plt.title()</code> 添加图表的标题。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">&#x27;Chart Title&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li></ul><p>在 Matplotlib 中，线条样式和宽度是定义图表外观的关键属性，它们可以帮助我们区分图中的不同数据系列或者强调某些数据点。下面详细说明了如何设置线条样式和宽度。</p><h2 id="线条样式"><a href="#线条样式" class="headerlink" title="线条样式"></a>线条样式</h2><p><code>linestyle</code> 或简写 <code>ls</code> 参数用来定义线条的样式。这个参数可以接受多种不同的值，以改变线条的显示方式。</p><h4 id="linestyle-的可用样式"><a href="#linestyle-的可用样式" class="headerlink" title="linestyle 的可用样式:"></a><code>linestyle</code> 的可用样式:</h4><ul><li><code>&#39;-&#39;</code> 或 <code>&#39;solid&#39;</code>: 实线</li><li><code>&#39;--&#39;</code> 或 <code>&#39;dashed&#39;</code>: 虚线</li><li><code>&#39;-.&#39;</code> 或 <code>&#39;dashdot&#39;</code>: 点划线</li><li><code>&#39;:&#39;</code> 或 <code>&#39;dotted&#39;</code>: 点线</li><li><code>&#39;&#39;</code> 或 <code>&#39;None&#39;</code>: 无线条</li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">xpoints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ypoints = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用点线样式</span></span><br><span class="line">plt.plot(xpoints, ypoints, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2ead837c-5000-4251-438f-bfd515a5ee00/public"                      width = "600"                ><h3 id="线条宽度"><a href="#线条宽度" class="headerlink" title="线条宽度"></a>线条宽度</h3><p><code>linewidth</code> 或简写 <code>lw</code> 参数用来定义线条的宽度，可以是任何浮点数。线宽越大，线条越粗。</p><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用线宽为10的实线</span></span><br><span class="line">plt.plot(xpoints, ypoints, linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">10</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>请注意，<code>linewidth</code> 的值不应该是字符串，因此 <code>lw=&#39;10&#39;</code> 需要改为 <code>lw=10</code>。</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>除了线条样式和宽度，我们还可以通过 <code>color</code> 参数来定义线条的颜色。颜色可以是 CSS 颜色的名称（如 <code>&#39;blue&#39;</code>、<code>&#39;green&#39;</code> 等），也可以是十六进制颜色代码（如 <code>&#39;#008000&#39;</code>）或 RGB 元组（如 <code>(0, 0.5, 0)</code>）。</p><h4 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用绿色线条</span></span><br><span class="line">plt.plot(xpoints, ypoints, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h3 id="扩展属性-1"><a href="#扩展属性-1" class="headerlink" title="扩展属性"></a>扩展属性</h3><ul><li><p><strong>坐标轴刻度</strong>: 使用 <code>plt.xticks()</code> 和 <code>plt.yticks()</code> 设置坐标轴的刻度。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">plt.yticks([<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>])</span><br></pre></td></tr></table></figure></div></li><li><p><strong>网格线</strong>: 使用 <code>plt.grid()</code> 添加网格线，提高图表的可读性。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>保存图表</strong>: 使用 <code>plt.savefig()</code> 保存图表到文件，支持多种格式，如 PNG、JPEG、SVG、PDF 等。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;my_plot.png&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li></ul><p>在 Matplotlib 中，色彩、多线条绘制、图表的标签和标题都是用来增强图表表达能力的重要元素。以下是对你所提供内容的整理和扩展。</p><h2 id="颜色（Color）"><a href="#颜色（Color）" class="headerlink" title="颜色（Color）"></a>颜色（Color）</h2><p><code>color</code> 参数用于定义线条的颜色。可以使用多种方法来指定颜色，例如使用预定义的颜色码（如 <code>&#39;r&#39;</code> 表示红色）或者 CSS 颜色名称。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/67c99c0c-c0a7-4261-edcc-038878636100/public"                      width = "600"                ><h4 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(xpoints, ypoints, color=<span class="string">&#x27;red&#x27;</span>) <span class="comment"># 或者使用 &#x27;r&#x27;</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h2 id="多线条（Multiple-Lines）"><a href="#多线条（Multiple-Lines）" class="headerlink" title="多线条（Multiple Lines）"></a>多线条（Multiple Lines）</h2><p>在同一个图表中绘制多条线可以帮助我们比较不同数据集之间的关系。</p><h4 id="示例代码：-4"><a href="#示例代码：-4" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(xpoints, ypoints1, marker=<span class="string">&#x27;o&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>, linewidth=<span class="number">1</span>, label=<span class="string">&#x27;Paid Off&#x27;</span>)</span><br><span class="line">plt.plot(xpoints, ypoints2, marker=<span class="string">&#x27;o&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>, linewidth=<span class="number">1</span>, label=<span class="string">&#x27;Overdue&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/baecb3b6-6d65-483a-b9e5-a593a9218900/public"                      width = "600"                ><p>这里，每条 <code>plot</code> 命令绘制了一组数据点，<code>label</code> 参数用于定义每条线的图例名称。</p><h2 id="标签和标题（Labels-and-Title）"><a href="#标签和标题（Labels-and-Title）" class="headerlink" title="标签和标题（Labels and Title）"></a>标签和标题（Labels and Title）</h2><p>使用 <code>xlabel()</code>, <code>ylabel()</code>, 和 <code>title()</code> 方法来设置 x 轴、y 轴标签和图表的标题。</p><h4 id="标题与标签的定位："><a href="#标题与标签的定位：" class="headerlink" title="标题与标签的定位："></a>标题与标签的定位：</h4><p>可以指定标题和标签在轴上的位置，以提高图表的美观度或强调某部分内容。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">&quot;Title&quot;</span>, loc=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;X Label&quot;</span>, loc=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Y Label&quot;</span>, loc=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p><code>loc</code> 参数用于设置对齐方式。</p><h2 id="标签设置（Setting-Line-Labels）"><a href="#标签设置（Setting-Line-Labels）" class="headerlink" title="标签设置（Setting Line Labels）"></a>标签设置（Setting Line Labels）</h2><p>为了区分图中的多条线，我们可以给每条线添加标签，然后用 <code>legend()</code> 方法显示图例。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(xpoints, ypoints1, label=<span class="string">&#x27;Paid Off&#x27;</span>)</span><br><span class="line">plt.plot(xpoints, ypoints2, label=<span class="string">&#x27;Overdue&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h4 id="扩展和细节："><a href="#扩展和细节：" class="headerlink" title="扩展和细节："></a>扩展和细节：</h4><ul><li><p><strong>字体大小和样式</strong>：可以通过 <code>fontsize</code> 和 <code>fontweight</code> 参数来调整标签和标题的字体大小和粗细。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">&quot;Title&quot;</span>, loc=<span class="string">&#x27;left&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>图例位置和样式</strong>：<code>legend()</code> 方法接受 <code>loc</code> 参数来指定图例的位置，例如 <code>&#39;upper right&#39;</code>、<code>&#39;lower left&#39;</code> 等。还可以设置边框和背景。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, frameon=<span class="literal">False</span>)  <span class="comment"># frameon=False 去除图例边框</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong>设置网格</strong>：<code>grid()</code> 函数可用于添加网格线，提高图表的可读性。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.grid(color=<span class="string">&#x27;gray&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>坐标轴刻度格式</strong>：可以使用 <code>xticks()</code> 和 <code>yticks()</code> 方法来定制轴刻度的显示方式。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(rotation=<span class="number">45</span>)  <span class="comment"># X轴刻度标签旋转45度</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong>坐标轴范围</strong>：使用 <code>xlim()</code> 和 <code>ylim()</code> 设置轴的范围，更精确地控制图表中显示的数据范围。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>保存图表</strong>：使用 <code>savefig()</code> 方法，可以将图表保存到文件中，如 PNG、PDF、SVG等格式。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;my_chart.png&#x27;</span>, dpi=<span class="number">300</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="多图布局"><a href="#多图布局" class="headerlink" title="多图布局"></a>多图布局</h2><h3 id="创建多图"><a href="#创建多图" class="headerlink" title="创建多图"></a>创建多图</h3><p>在Python的matplotlib库中，<code>subplot()</code>和<code>subplots()</code>方法是绘制多图布局中非常重要的工具。这些方法允许我们在一个画布(canvas)上创建多个子图(subplots)。下面，我将对你提供的笔记进行整理和修正，确保其内容既准确又专业。</p><h4 id="subplot"><a href="#subplot" class="headerlink" title="subplot()"></a>subplot()</h4><p><code>subplot()</code>方法用于在画布上创建单个子图。其使用方式如下：</p><ul><li><code>subplot(nrows, ncols, index, **kwargs)</code>: 将画布分为<code>nrows</code>行和<code>ncols</code>列，<code>index</code>确定子图的位置。</li><li><code>subplot(pos, **kwargs)</code>: <code>pos</code>参数可以是三位数字，分别表示行数、列数和索引位置。</li><li><code>subplot(**kwargs)</code>: 直接通过关键字参数来指定布局和位置。</li><li><code>subplot(ax)</code>: 允许在已存在的轴对象<code>ax</code>上创建子图。</li></ul><p>在使用<code>subplot()</code>时，整个绘图区域被分成<code>nrows</code>行和<code>ncols</code>列，然后从左到右、从上到下对每个子区域进行编号（1到N）。左上的子区域编号为1，右下的区域编号为N。可以通过<code>index</code>参数指定子图的具体位置。</p><h3 id="创建多图示例"><a href="#创建多图示例" class="headerlink" title="创建多图示例"></a>创建多图示例</h3><h4 id="示例1-1x2布局"><a href="#示例1-1x2布局" class="headerlink" title="示例1: 1x2布局"></a>示例1: 1x2布局</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置画布大小和分辨率</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>), dpi=<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个子图：借款笔数占比</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y = df[<span class="string">&#x27;借款笔数占比&#x27;</span>]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.title(<span class="string">&quot;借款笔数占比&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个子图：已还清占比</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y = df[<span class="string">&#x27;已还清占比&#x27;</span>]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.title(<span class="string">&quot;已还清占比&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">&quot;借款情况分析&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h4 id="示例2-2x2布局"><a href="#示例2-2x2布局" class="headerlink" title="示例2: 2x2布局"></a>示例2: 2x2布局</h4><p>在2x2的布局中，我们可以创建4个子图：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置画布大小和分辨率</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>), dpi=<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个子图：年龄段已还清人数</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y = df[<span class="string">&#x27;已还清&#x27;</span>]</span><br><span class="line">plt.plot(x, y, marker=<span class="string">&#x27;v&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>, ls=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;年龄段已还清人数&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个子图：年龄段历史借款次数</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y = df[<span class="string">&#x27;历史成功借款次数&#x27;</span>]</span><br><span class="line">plt.plot(x, y, marker=<span class="string">&#x27;v&#x27;</span>, color=<span class="string">&#x27;purple&#x27;</span>, ls=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;年龄段历史借款次数&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个子图：年龄段正常还款</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y = df[<span class="string">&#x27;正常还款中&#x27;</span>]</span><br><span class="line">plt.plot(x, y, marker=<span class="string">&#x27;x&#x27;</span>, color=<span class="string">&#x27;brown&#x27;</span>, ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;年龄段正常还款&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四个子图：年龄段借款金额</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y = df[<span class="string">&#x27;借款金额&#x27;</span>]</span><br><span class="line">plt.plot(x, y, marker=<span class="string">&#x27;X&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>, ls=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;年龄段借款金额&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">&quot;年龄段借款情况&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>在上述示例中，<code>plt.figure()</code>用于设置整个画布的大小和分辨率，而<code>plt.subplot()</code>用于创建并定位子图。我们可以通过调整<code>marker</code>、<code>color</code>和<code>ls</code>（线型）参数来美化图表。</p><p>接下来，我们将讨论如何在Matplotlib中共享x轴以及调整多图之间的间距，这对于创建清晰、易于理解的视觉表示特别重要。</p><h3 id="共享X轴"><a href="#共享X轴" class="headerlink" title="共享X轴"></a>共享X轴</h3><p>在某些情况下，我们可能需要在同一图表中显示两组数据，这些数据共享x轴但有不同的y轴。这可以通过使用<code>ax.twinx()</code>方法来实现，它允许我们为同一个x轴创建一个新的y轴。</p><h4 id="单图示例"><a href="#单图示例" class="headerlink" title="单图示例"></a>单图示例</h4><p>在单个图表中展示两组数据，共享x轴：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第一个轴对象</span></span><br><span class="line">ax1 = plt.subplot()</span><br><span class="line">ax2 = ax1.twinx()  <span class="comment"># 创建共享x轴的第二个轴对象</span></span><br><span class="line"></span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y1 = df[<span class="string">&#x27;已还清&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第一个轴上绘制数据</span></span><br><span class="line">ax1.plot(x, y1, marker=<span class="string">&#x27;v&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>, ls=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;已还清&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y2 = df[<span class="string">&#x27;历史成功借款次数&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第二个轴上绘制数据</span></span><br><span class="line">ax2.plot(x, y2, marker=<span class="string">&#x27;v&#x27;</span>, color=<span class="string">&#x27;purple&#x27;</span>, ls=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;历史成功借款次数&#x27;</span>, color=<span class="string">&#x27;purple&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置共享x轴的标签</span></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;年龄&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h4 id="多图示例"><a href="#多图示例" class="headerlink" title="多图示例"></a>多图示例</h4><p>在一个画布上绘制两个图表，每个图表中都展示两组数据，共享x轴：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个图表</span></span><br><span class="line">ax1 = plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line"></span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y1 = df[<span class="string">&#x27;已还清&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ax1.plot(x, y1, marker=<span class="string">&#x27;v&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>, ls=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;已还清&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y2 = df[<span class="string">&#x27;历史成功借款次数&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ax2.plot(x, y2, marker=<span class="string">&#x27;v&#x27;</span>, color=<span class="string">&#x27;purple&#x27;</span>, ls=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;历史成功借款次数&#x27;</span>, color=<span class="string">&#x27;purple&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;年龄&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个图表</span></span><br><span class="line">ax1 = plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line"></span><br><span class="line">y1 = df[<span class="string">&#x27;借款金额&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ax1.plot(x, y1, marker=<span class="string">&#x27;v&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>, ls=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;借款金额&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y2 = df[<span class="string">&#x27;逾期中&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ax2.plot(x, y2, marker=<span class="string">&#x27;v&#x27;</span>, color=<span class="string">&#x27;purple&#x27;</span>, ls=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;逾期中&#x27;</span>, color=<span class="string">&#x27;purple&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;年龄&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><p>注意：在第二个图表中，y轴的标签需要根据实际数据进行相应的修改。</p><h3 id="调整多图之间的间距"><a href="#调整多图之间的间距" class="headerlink" title="调整多图之间的间距"></a>调整多图之间的间距</h3><p>当在一个画布上绘制多个子图时，可能需要调整它们之间的间距以避免标签和图表元素的相互重叠。这可以通过<code>plt.subplots_adjust()</code>方法实现：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调整子图之间的水平间距</span></span><br><span class="line">plt.subplots_adjust(wspace=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整子图之间的垂直间距</span></span><br><span class="line">plt.subplots_adjust(hspace=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></div><p><code>wspace</code>和<code>hspace</code>参数控制子图之间的宽度和高度的间距，值为比例（相对于子图宽度和高度的比例）。</p><p>柱状图是数据可视化中常用的图表类型，适用于展示不同类别间的比较。在Matplotlib中，使用<code>plt.bar()</code>和<code>plt.barh()</code>可以分别绘制垂直和水平的柱状图。以下是如何在Matplotlib中创建和自定义柱状图的详细说明。</p><h3 id="基础柱状图"><a href="#基础柱状图" class="headerlink" title="基础柱状图"></a>基础柱状图</h3><p>创建一个基础柱状图，用于展示不同年龄段的已还清金额：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">10</span>), dpi=<span class="number">120</span>)</span><br><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y = df[<span class="string">&#x27;已还清&#x27;</span>]</span><br><span class="line">plt.bar(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><p>可以通过传递不同的参数来自定义柱状图的外观。</p><ul><li><p><strong>修改颜色</strong>：通过<code>color</code>参数设置柱子的颜色。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(x, y, color=<span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>修改柱宽</strong>：使用<code>width</code>参数调整柱的宽度。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(x, y, width=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>水平柱状图</strong>：<code>plt.barh()</code>用于绘制水平柱状图。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.barh(x, y)</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="堆叠柱状图"><a href="#堆叠柱状图" class="headerlink" title="堆叠柱状图"></a>堆叠柱状图</h3><p>堆叠柱状图适用于展示不同组数据在相同类别中的分布情况。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line">y1 = df[<span class="string">&#x27;已还清&#x27;</span>]</span><br><span class="line">y2 = df[<span class="string">&#x27;正常还款中&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.bar(x, y1)</span><br><span class="line">plt.bar(x, y2, bottom=y1)</span><br><span class="line">plt.legend([<span class="string">&#x27;已还清&#x27;</span>, <span class="string">&#x27;正常还款中&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h4 id="显示数值"><a href="#显示数值" class="headerlink" title="显示数值"></a>显示数值</h4><p>在柱状图的柱子上显示数值，可以更直观地展示数据的具体数值。</p><ul><li><p><strong>单独柱子显示数值</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.bar_label(plt.bar(x, y1), labels=x, label_type=<span class="string">&#x27;edge&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><strong>堆叠柱状图显示数值</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bar1 = plt.bar(x, y1)</span><br><span class="line">plt.bar_label(bar1, labels=y1, label_type=<span class="string">&#x27;edge&#x27;</span>)</span><br><span class="line">bar2 = plt.bar(x, y2, bottom=y1)</span><br><span class="line">plt.bar_label(bar2, labels=y2, label_type=<span class="string">&#x27;edge&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;已还清&#x27;</span>, <span class="string">&#x27;正常还款中&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div></li></ul><p>这里，<code>label_type=&#39;center&#39;</code>将标签放在柱子的中心位置，而<code>label_type=&#39;edge&#39;</code>则将标签放在柱子的边缘位置。这些自定义选项使得柱状图不仅能够提供数据的视觉比较，还能提供精确的数值信息，使得数据的解读更加直观明了。</p>]]></content>
    
    
    <summary type="html">Python Matplotlib包</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Matplotlib" scheme="https://www.yiuhangblog.com/tags/Matplotlib/"/>
    
    <category term="可视化" scheme="https://www.yiuhangblog.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://www.yiuhangblog.com/2018/11/28/20181128JavaScript/"/>
    <id>https://www.yiuhangblog.com/2018/11/28/20181128JavaScript/</id>
    <published>2018-11-27T21:25:02.000Z</published>
    <updated>2024-03-06T11:32:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a>JavaScript介绍</h2><p>JavaScript是一种高级的、解释型的编程语言，它在Web开发中扮演着至关重要的角色。与HTML和CSS共同，JavaScript构成了Web世界的三大核心技术。HTML负责结构的定义，CSS负责表现的样式，而JavaScript则添加了交互性，使得网页变得“活”起来。</p><h3 id="JavaScript的特点"><a href="#JavaScript的特点" class="headerlink" title="JavaScript的特点"></a>JavaScript的特点</h3><ul><li><strong>动态性</strong>：JavaScript允许动态修改HTML和CSS，实现网页内容的动态更新，无需重新加载页面。</li><li><strong>易于学习</strong>：相对于其他编程语言，JavaScript的入门门槛较低，但它也支持复杂的功能，适用于从初学者到专业开发者。</li><li><strong>跨平台</strong>：JavaScript可以在几乎所有的现代浏览器上运行，无需特定平台的依赖。</li><li><strong>事件驱动</strong>：JavaScript能够响应用户操作，如点击、滑动、按键等事件，实现丰富的交互效果。</li><li><strong>支持多种编程范式</strong>：包括命令式、函数式和面向对象编程。</li></ul><h3 id="JavaScript与HTML和CSS的关系"><a href="#JavaScript与HTML和CSS的关系" class="headerlink" title="JavaScript与HTML和CSS的关系"></a>JavaScript与HTML和CSS的关系</h3><ul><li><strong>HTML</strong>：定义了网页的结构和内容。它是网页的骨架，用于组织和展示静态内容。</li><li><strong>CSS</strong>：负责网页的布局和视觉效果。通过CSS，开发者可以改变网页的布局、颜色、字体和动画等，使页面美观和用户友好。</li><li><strong>JavaScript</strong>：添加动态行为到网页上。JavaScript可以读取和修改HTML元素和CSS样式，控制DOM元素，实现页面内容的动态变化。此外，它还可以处理事件和用户交互，进行数据验证，以及与Web服务器进行异步通信（如Ajax）。</li></ul><h3 id="JavaScript在Web开发中的应用"><a href="#JavaScript在Web开发中的应用" class="headerlink" title="JavaScript在Web开发中的应用"></a>JavaScript在Web开发中的应用</h3><ul><li><strong>页面动态效果</strong>：如轮播图、下拉菜单、模态框等。</li><li><strong>表单验证</strong>：检查用户输入的有效性，如电子邮件格式、密码强度等。</li><li><strong>异步加载内容</strong>：通过Ajax从服务器获取数据，无需刷新页面即可更新网页内容。</li><li><strong>Web应用程序</strong>：开发单页应用（SPA），如React、Angular和Vue等前端框架所展现的富客户端应用。</li><li><strong>服务器端开发</strong>：通过Node.js，JavaScript也可以用于服务器端编程。</li></ul><p>JavaScript的普及和发展，推动了Web技术的快速进步，使得现代网页不仅仅是静态的信息展示，而是提供了丰富的交互和动态内容，极大地丰富了用户的网上冲浪体验。随着时间的发展，JavaScript的生态系统不断壮大，它的重要性和影响力在当今的Web开发领域中仍在不断增长。</p><p>JavaScript的使用方法主要可以分为两类：内联JavaScript代码和外部JavaScript文件。了解这两种方法的使用场景和优缺点，能帮助开发者更高效地编写和管理JavaScript代码。</p><h2 id="JavaScript使用方法"><a href="#JavaScript使用方法" class="headerlink" title="JavaScript使用方法"></a>JavaScript使用方法</h2><h3 id="1-内联JavaScript代码"><a href="#1-内联JavaScript代码" class="headerlink" title="1. 内联JavaScript代码"></a>1. 内联JavaScript代码</h3><p>将JavaScript代码直接写在HTML文档中，通常是放在<code>&lt;script&gt;</code>标签内。这种方法适合少量的JavaScript代码，可以快速实现简单的逻辑和交互。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>在<code>&lt;body&gt;</code>标签的底部添加<code>&lt;script&gt;</code>标签：</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 网页内容 --&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在这里写JavaScript逻辑代码</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, JavaScript!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>优点</strong>：</p><ul><li>简单，易于实现小规模的交互效果。</li><li>不需要额外的文件请求，减少加载时间（对于非常小的脚本）。</li></ul><p><strong>缺点</strong>：</p><ul><li>随着代码量增加，HTML文件会变得臃肿，难以维护。</li><li>多个页面如果需要相同的JavaScript逻辑，需要在每个页面中重复相同的代码，增加了维护成本。</li></ul><h3 id="2-外部JavaScript文件"><a href="#2-外部JavaScript文件" class="headerlink" title="2. 外部JavaScript文件"></a>2. 外部JavaScript文件</h3><p>将JavaScript代码写在一个单独的<code>.js</code>文件中，然后通过在HTML文档的<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>部分引入这个文件。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>在<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>的底部引入外部JavaScript文件：</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/your-script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>或者，为了页面加载性能优化，推荐在<code>&lt;body&gt;</code>标签的底部引入：</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 网页内容 --&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/your-script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>优点</strong>：</p><ul><li>代码更加组织化，易于维护。</li><li>可以在多个页面共享同一个<code>.js</code>文件，减少代码冗余。</li><li>浏览器可以缓存外部JavaScript文件，提高页面加载速度。</li></ul><p><strong>缺点</strong>：</p><ul><li>页面必须等待外部JavaScript文件加载完成，可能会影响页面渲染速度（尤其是在网络条件不佳时）。</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>对于小的项目或简单的脚本，可以使用内联JavaScript代码。</li><li>对于大型项目，推荐使用外部JavaScript文件，并在HTML文档的<code>&lt;body&gt;</code>标签底部引入，以提高页面加载速度和代码的可维护性。</li><li>使用现代Web开发工具和技术（如模块化JavaScript、Webpack等），可以进一步优化代码组织和性能。</li></ul><h2 id="JavaScript输出"><a href="#JavaScript输出" class="headerlink" title="JavaScript输出"></a>JavaScript输出</h2><p>JavaScript提供了多种输出数据的方式，其中最常用的是<code>console.log</code>和<code>alert</code>函数。这些方法在调试代码、向用户显示信息或简单的数据交互中非常有用。了解它们的使用场景和特点，可以帮助你更有效地在JavaScript开发中进行信息输出和调试。</p><h3 id="1-console-log：在控制台输出"><a href="#1-console-log：在控制台输出" class="headerlink" title="1. console.log：在控制台输出"></a>1. <code>console.log</code>：在控制台输出</h3><p><code>console.log</code>是开发者在日常开发过程中最频繁使用的JavaScript输出方法之一。它将信息输出到浏览器的控制台中，这对于调试代码和查看变量的当前状态非常有帮助。</p><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello JavaScript!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>注意</strong>：</p><ul><li>输出的内容只能在浏览器的开发者工具中的控制台(Console)看到。</li><li><code>console.log</code>不会对用户界面产生任何影响，因此它主要用于开发调试。</li></ul><h3 id="2-alert：在网页中弹出对话框"><a href="#2-alert：在网页中弹出对话框" class="headerlink" title="2. alert：在网页中弹出对话框"></a>2. <code>alert</code>：在网页中弹出对话框</h3><p><code>alert</code>函数会在网页上显示一个警告对话框，显示指定的文本内容，并在用户点击”确定”按钮之前阻止任何其他操作。</p><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&#x27;Hello JavaScript!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>注意</strong>：</p><ul><li>对话框会立即在加载包含<code>alert</code>函数的网页时弹出。</li><li><code>alert</code>对话框是模态的，这意味着它会暂停代码的执行，并阻止用户与网页上的其他元素交互，直到对话框被关闭。</li><li>使用<code>alert</code>过于频繁可能会影响用户体验，因为它强制用户进行交互才能继续浏览网页。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>**<code>console.log</code>**：主要用于开发过程中的调试。它允许开发者在开发者工具的控制台中查看变量值、调试信息或任何其他输出，而不会影响用户的正常使用。</li><li>**<code>alert</code>**：可用于向用户显示重要消息，如表单验证反馈、操作确认等。但应谨慎使用，以避免打扰用户体验。</li></ul><h2 id="JavaScript注释"><a href="#JavaScript注释" class="headerlink" title="JavaScript注释"></a>JavaScript注释</h2><p>在JavaScript中，注释是对代码的解释和说明，它们能帮助开发者理解代码的功能和目的。注释对于代码的执行没有任何影响，因此可以自由地添加解释性的文字来帮助你和其他开发者更好地理解和维护代码。JavaScript支持两种类型的注释：单行注释和多行注释。</p><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>单行注释以双斜杠<code>//</code>开头，仅对其后的内容进行注释，直到行末。单行注释通常用于对代码行的简短说明或临时禁用某行代码。</p><h4 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 这是一个单行注释</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&#x27;Hello JavaScript!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>多行注释以<code>/*</code>开始，以<code>*/</code>结束。它可以跨越多行，用于注释掉多行代码或提供更详细的说明。</p><h4 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 这是一个多行注释</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     可以跨越多行</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     很适合写更多的注释内容 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&#x27;Hello JavaScript!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>在许多开发环境和代码编辑器中，可以使用快捷键<code>Ctrl+/</code>（在Mac上通常是<code>Cmd+/</code>）来快速添加或移除单行注释。这个快捷键可以提高编写和管理注释的效率。</p><h3 id="注释的作用"><a href="#注释的作用" class="headerlink" title="注释的作用"></a>注释的作用</h3><ol><li><strong>解释性说明</strong>：注释可以解释代码的功能和目的，使代码更易于理解。</li><li><strong>代码调试</strong>：在调试过程中，你可以通过注释掉一部分代码来帮助定位问题。</li><li><strong>文档记录</strong>：在复杂的项目中，注释可以作为代码的文档记录，说明特定功能的开发者、开发日期和修改历史等。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用注释时应保持适度，避免过多或过少。过多的注释可能会让代码变得难以阅读，而过少的注释则可能导致代码的意图和逻辑不够清晰。</li><li>对于自解释性强的代码，简洁明了的注释或者不注释可能是更好的选择。</li><li>保持注释的更新。随着代码的修改和迭代，应该相应地更新注释内容，避免出现注释与代码不一致的情况。</li></ul><p>注释是代码的重要组成部分，恰当地使用注释能够大大提高代码的可读性和可维护性。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在JavaScript中，变量是用来存储数据值的容器。通过使用变量，你可以在代码中引用和操作这些值。JavaScript提供了几种不同的方式来声明变量，包括<code>var</code>、<code>let</code>和<code>const</code>。这里我们将重点讨论<code>let</code>和<code>const</code>，因为它们提供了比<code>var</code>更强大的功能和更好的作用域控制。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>使用<code>let</code>关键字来声明一个变量。这告诉JavaScript你正在创建一个新的变量。</p><h4 id="示例代码：-4"><a href="#示例代码：-4" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 小皮;</span><br></pre></td></tr></table></figure></div><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>一旦声明了变量，你就可以给它赋值了。赋值是通过等号<code>=</code>完成的，等号左边是变量名，右边是要赋给变量的值。</p><h4 id="示例代码：-5"><a href="#示例代码：-5" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小皮 = <span class="string">&#x27;我家的一条狗&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="变量声明并赋值"><a href="#变量声明并赋值" class="headerlink" title="变量声明并赋值"></a>变量声明并赋值</h3><p>你也可以在声明变量的同时给它赋值。这是最常见的做法，因为它可以减少代码量并提高效率。</p><h4 id="示例代码：-6"><a href="#示例代码：-6" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> 小皮 = <span class="string">&#x27;我家的一条狗&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(小皮); <span class="comment">// 在控制台输出变量的值</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="let-vs-const"><a href="#let-vs-const" class="headerlink" title="let vs const"></a><code>let</code> vs <code>const</code></h3><ul><li>**<code>let</code>**：用于声明一个可以重新赋值的变量。如果你的变量值在后面的代码中需要改变，应该使用<code>let</code>。</li><li>**<code>const</code>**：用于声明一个常量，即一旦赋值后就不能再改变的变量。如果你知道变量的值在整个程序中都不会改变，使用<code>const</code>更合适。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>尽量使用<code>const</code>来声明变量，除非你知道变量的值会改变，这样可以帮助避免程序中的错误。</li><li>避免使用<code>var</code>进行变量声明，因为它的作用域规则（函数作用域）与<code>let</code>和<code>const</code>的块级作用域相比，更容易导致错误。</li><li>变量命名应遵循JavaScript的命名规则，尽量使用描述性的名称，避免使用保留字。</li><li>JavaScript是大小写敏感的，因此<code>小皮</code>和<code>小皮</code>是两个不同的变量。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript是一种动态类型语言，意味着变量不直接指定数据类型。变量的数据类型会在脚本运行时动态决定。JavaScript有五种基本数据类型（也称为原始类型）：字符串（String）、数值（Number）、布尔（Boolean）、未定义（Undefined）、空（Null）；以及一种复杂数据类型：对象（Object）。此外，ES6引入了Symbol作为新的原始数据类型。</p><h3 id="字符串型-String"><a href="#字符串型-String" class="headerlink" title="字符串型 (String)"></a>字符串型 (String)</h3><p>字符串用于表示文本数据。它是字符的序列，可以使用单引号<code>&#39;</code>、双引号<code>&quot;</code>或者ES6中的模板字符串&#96;&#96;&#96;（反引号）。</p><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;我是一个字符串a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&quot;我是一个字符串b&quot;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="数值型-Number"><a href="#数值型-Number" class="headerlink" title="数值型 (Number)"></a>数值型 (Number)</h3><p>Number类型用于表示整数或浮点数（小数）。JavaScript不区分整数类型和浮点数类型，所有的数字在JavaScript中都是Number类型。</p><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>; <span class="comment">// 整数</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">10.25</span>; <span class="comment">// 浮点数</span></span><br></pre></td></tr></table></figure></div><h3 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型 (Boolean)"></a>布尔型 (Boolean)</h3><p>布尔类型只有两个值：<code>true</code>（真）和<code>false</code>（假），用于执行逻辑操作。</p><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span>; <span class="comment">// 真</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">false</span>; <span class="comment">// 假</span></span><br></pre></td></tr></table></figure></div><h3 id="未定义-Undefined"><a href="#未定义-Undefined" class="headerlink" title="未定义 (Undefined)"></a>未定义 (Undefined)</h3><p>当一个变量被声明了但没有被赋值时，它的值就是<code>undefined</code>。</p><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure></div><h3 id="空-Null"><a href="#空-Null" class="headerlink" title="空 (Null)"></a>空 (Null)</h3><p><code>null</code>用于表示一个明确的空值。通常用于初始化一个变量，可能稍后会被赋予一个对象值。</p><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h3><p><code>typeof</code>运算符用于检查一个变量的数据类型。它是确定基本数据类型的一个有效工具，但对于<code>null</code>值会返回<code>&quot;object&quot;</code>，这是一个历史遗留问题。</p><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;我是字符串类型&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> d = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> e = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> c); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> d); <span class="comment">// object, 特殊情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> e); <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure></div><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符用于基本的数学运算。它们可以应用于字面量数值、变量中的数值，以及任何返回数值的表达式。</p><ul><li>**加法 (+)**：计算两个操作数的和。</li><li>**减法 (-)**：从第一个操作数中减去第二个操作数。</li><li>*<em>乘法 (</em>)**：计算两个操作数的乘积。</li><li>**除法 (&#x2F;)**：将第一个操作数除以第二个操作数。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + b); <span class="comment">// 结果: 50</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a - b); <span class="comment">// 结果: 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a * b); <span class="comment">// 结果: 600</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a / b); <span class="comment">// 结果: 1.5</span></span><br></pre></td></tr></table></figure></div><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符用于将值赋给JavaScript变量。</p><ul><li>**<code>= (赋值)</code>**：将右侧的值赋给左侧的变量。</li><li>**<code>+= (加后赋值)</code>**：将右侧的值加上左侧的变量的当前值，然后将结果赋给左侧的变量。</li><li>**<code>-= (减后赋值)</code>**：从左侧变量的当前值中减去右侧的值，然后将结果赋给左侧的变量。</li></ul><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a = <span class="number">100</span>); <span class="comment">// 结果: 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a += b); <span class="comment">// a = a + b 结果：120</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a -= b); <span class="comment">// a = a - b 结果: 100</span></span><br></pre></td></tr></table></figure></div><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符用于比较两个值，根据比较结果返回布尔值（<code>true</code>或<code>false</code>）。</p><ul><li>**<code>== (等于)</code>**：检查两个操作数的值是否相等，如果相等返回<code>true</code>。</li><li>**<code>!= (不等于)</code>**：检查两个操作数的值是否不相等，如果不相等返回<code>true</code>。</li><li>**<code>=== (全等于)</code>**：检查两个操作数的值和类型是否完全相同，如果完全相同返回<code>true</code>。</li><li>**<code>!== (全不等于)</code>**：检查两个操作数的值和类型是否完全不相同，如果完全不相同返回<code>true</code>。</li></ul><h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;30&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b); <span class="comment">// 结果: true (因为值相等)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a != b); <span class="comment">// 结果: false (因为值相等)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b); <span class="comment">// 结果: false (因为值相等但类型不同)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a !== b); <span class="comment">// 结果: true (因为值相等但类型不同)</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">JavaScript基本介绍</summary>
    
    
    
    <category term="前端" scheme="https://www.yiuhangblog.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="JavaScript" scheme="https://www.yiuhangblog.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://www.yiuhangblog.com/2018/11/24/20181124CSS/"/>
    <id>https://www.yiuhangblog.com/2018/11/24/20181124CSS/</id>
    <published>2018-11-24T09:16:34.000Z</published>
    <updated>2024-03-06T11:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是CSS"><a href="#什么是CSS" class="headerlink" title="什么是CSS"></a>什么是CSS</h2><p>CSS代表“层叠样式表”（Cascading Style Sheets）。它是一种用于控制网页布局和设计的技术，允许网页开发者和设计师为HTML（超文本标记语言）元素指定字体、颜色、间距、布局以及各种视觉效果。CSS可以提高网页的表现力，使其更加丰富和吸引人，同时也可以使内容与表现分离，从而简化网页的维护和更新。</p><p>通过使用CSS，开发者可以为不同的设备（如桌面显示器、手机、打印机等）创建特定的样式，以确保网页在各种浏览环境中都能以最佳方式呈现。CSS的“层叠”特性允许多个样式表按照一定的优先级顺序应用于同一个HTML文档，这意味着可以根据需要轻松地覆盖和修改样式。</p><p>CSS的使用不仅提升了网页的美观性和可用性，还有助于提高网页的加载速度和搜索引擎优化（SEO）。因为它允许开发者将结构（HTML）与设计（CSS）分离，从而使HTML代码更加简洁和清晰，更易于搜索引擎理解。随着Web技术的发展，CSS也在不断进化，CSS3是最新的版本，引入了更多的布局选项、动画和其他视觉效果。</p><h2 id="为什么使用CSS"><a href="#为什么使用CSS" class="headerlink" title="为什么使用CSS"></a>为什么使用CSS</h2><p>使用CSS（层叠样式表）的原因非常多样，它改变了网页开发和设计的方式。以下是使用CSS的一些主要原因：</p><ol><li><p><strong>分离内容与样式</strong>：CSS允许开发者将网页的设计样式与内容分离。这意味着可以独立修改HTML文档的结构和CSS样式表的设计，而无需重写整个页面，从而提高了网站的维护效率和灵活性。</p></li><li><p><strong>节省时间和资源</strong>：通过使用CSS，可以在多个网页中重复使用同一样式表。当需要更改网站的设计时，只需修改一个CSS文件，网站上的所有页面都会自动更新，这大大节省了时间和资源。</p></li><li><p><strong>提高页面加载速度</strong>：将样式信息保存在外部样式表中可以减少每个页面的HTML代码量。因为样式表只需要在首次访问网站时加载一次，然后就可以被缓存起来用于后续页面，这样可以减少数据传输量，加快页面加载速度。</p></li><li><p><strong>增强网页的可访问性</strong>：CSS提供了更多的布局和设计选项，可以创建更易于阅读和导航的网页布局。这对于包括视觉障碍人士在内的所有用户都非常重要。</p></li><li><p><strong>提升网站的兼容性</strong>：通过使用CSS，可以针对不同的浏览器、设备和屏幕尺寸创建特定的样式。这意味着无论用户使用什么设备访问网站，都可以提供最佳的浏览体验。</p></li><li><p><strong>支持高级用户界面和动画</strong>：CSS3引入了许多新特性，如动画、过渡、形状、渐变等，这些都可以用来创建吸引人的视觉效果和动态用户界面，而无需依赖于重量级的JavaScript或Flash插件。</p></li><li><p><strong>提高搜索引擎优化（SEO）</strong>：通过使用CSS，可以创建更加语义化的HTML结构，这有助于搜索引擎更好地理解页面内容的结构和重要性，从而提高网站在搜索结果中的排名。</p></li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>CSS（层叠样式表）的作用在网页开发和设计中至关重要，它具有以下主要功能和作用：</p><ol><li><p><strong>样式控制</strong>：CSS允许开发者精确控制网页中文本、图像和元素的样式。这包括字体样式、颜色、大小、行间距、文本对齐、链接表现等。</p></li><li><p><strong>布局设计</strong>：CSS使得布局设计成为可能，不再依赖于HTML表格或其他传统方法。使用CSS，可以实现多栏布局、网格布局和弹性布局等复杂设计，以适应不同的屏幕大小和设备。</p></li><li><p><strong>响应式网页设计</strong>：通过使用媒体查询（Media Queries），CSS可以根据不同的屏幕尺寸和设备特性来应用不同的样式规则。这使得创建响应式网站成为可能，确保网站在各种设备上都能提供良好的用户体验。</p></li><li><p><strong>视觉效果</strong>：CSS提供了一系列视觉效果的实现方法，如阴影、圆角、透明度、过渡和动画效果，使得网页具有更加吸引人的视觉表现。</p></li><li><p><strong>页面性能优化</strong>：使用外部样式表可以减少页面的代码冗余，因为样式信息可以被缓存并在多个页面之间共享。这可以减少页面加载时间，提升用户体验。</p></li><li><p><strong>提升网站的可访问性</strong>：CSS允许开发者为不同的浏览设备（包括屏幕阅读器）提供更加适合的样式，提高网站的可访问性。</p></li><li><p><strong>提高网站的可维护性</strong>：通过将样式信息从HTML中分离出来，CSS简化了网站的维护。当需要改变网站的视觉风格时，只需修改样式表，而不必触及HTML代码。</p></li><li><p><strong>增强网站的互动性和动态效果</strong>：CSS3引入的动画和过渡效果使得无需使用JavaScript或Flash等技术，就能在用户与网页交互时产生动态效果，增强用户体验。</p></li></ol><p>CSS通过提供这些功能和作用，使得网页开发者和设计师能够创建出既美观又功能强大的网站，同时确保内容的可访问性、网站的响应性以及维护的便捷性。</p><h2 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h2><p>CSS（Cascading Style Sheets）的应用方式主要分为三种：内部样式、行内样式和外部样式。每种方式有其适用场景和优先级，根据具体需求选择合适的引用方式是开发高质量网页的关键。下面是对这三种方式的详细说明和示例：</p><h3 id="1-内部样式（内联样式表）"><a href="#1-内部样式（内联样式表）" class="headerlink" title="1. 内部样式（内联样式表）"></a>1. 内部样式（内联样式表）</h3><p>内部样式通过在HTML文档的<code>&lt;head&gt;</code>部分放置<code>&lt;style&gt;</code>标签并在其中编写CSS代码来实现。这种方式适用于单个页面的样式定义，当样式仅在当前页面中有效时非常有用。</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 在这里写CSS代码 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="2-行内样式"><a href="#2-行内样式" class="headerlink" title="2. 行内样式"></a>2. 行内样式</h3><p>行内样式是通过在HTML元素的<code>style</code>属性中直接写入CSS代码来定义样式的方法。这种方式适用于对单个元素进行快速样式调整，但不推荐用于大规模样式定义，因为这样做会增加HTML代码的复杂性和维护难度。</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 14px;&quot;</span>&gt;</span>这是行内样式的示例文本。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="3-外部样式（外联样式表）"><a href="#3-外部样式（外联样式表）" class="headerlink" title="3. 外部样式（外联样式表）"></a>3. 外部样式（外联样式表）</h3><p>外部样式通过创建一个单独的CSS文件（例如<code>styles.css</code>），然后在HTML文档的<code>&lt;head&gt;</code>部分使用<code>&lt;link&gt;</code>标签引入这个CSS文件来实现。这是最推荐的方法，因为它有利于样式的复用和维护，同时也减少了页面的加载时间。</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="CSS应用方式的优先级"><a href="#CSS应用方式的优先级" class="headerlink" title="CSS应用方式的优先级"></a>CSS应用方式的优先级</h3><p>当多种样式同时作用于同一个HTML元素时，CSS的应用方式决定了它们的优先级：<strong>行内样式 &gt; 内部样式 &gt; 外部样式</strong>。此外，样式表的优先级还受到CSS选择器权重、继承和<code>!important</code>声明的影响。在实际开发中，了解并正确应用这些原则是非常重要的，它们帮助开发者高效地管理和维护网页的样式。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>CSS选择器是CSS中的一种模式，用于选择需要应用样式的元素。它们是CSS规则的关键组成部分，使开发者能够精确地定位到HTML文档中的元素。以下是关于常用CSS选择器的详细说明：</p><h3 id="1-标签选择器（元素选择器）"><a href="#1-标签选择器（元素选择器）" class="headerlink" title="1. 标签选择器（元素选择器）"></a>1. 标签选择器（元素选择器）</h3><p>标签选择器，也称为元素选择器，使用HTML标签的名称作为选择器。它将样式应用于所有具有该标签名称的元素。这种选择器非常适合应用全局样式。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 所有的div元素都将应用以下样式 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="2. 类选择器"></a>2. 类选择器</h3><p>类选择器使用点（<code>.</code>）作为前缀，后面跟上自定义的类名。通过HTML元素的<code>class</code>属性来应用对应的样式。类选择器非常灵活，因为同一个类可以应用于多个元素，同时一个元素也可以有多个类。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 所有class为&quot;name&quot;的元素都将应用以下样式 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.name</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>我是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>我是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>我是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="3-ID选择器"><a href="#3-ID选择器" class="headerlink" title="3. ID选择器"></a>3. ID选择器</h3><p>ID选择器使用井号（<code>#</code>）作为前缀，后面跟上自定义的ID名称。通过HTML元素的<code>id</code>属性来应用对应的样式。ID选择器是唯一的，一个页面中的一个ID只能用于一个元素。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* ID为&quot;name&quot;的元素将应用以下样式 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#name</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span>我是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="使用建议和注意事项"><a href="#使用建议和注意事项" class="headerlink" title="使用建议和注意事项"></a>使用建议和注意事项</h3><ul><li><strong>标签选择器</strong>适用于定义全局样式和元素的默认样式。</li><li><strong>类选择器</strong>非常灵活，适用于组件和重复元素的样式设计，支持复用。</li><li><strong>ID选择器</strong>用于特定元素的唯一样式，但应谨慎使用，因为ID具有高优先级，可能导致样式覆盖问题。</li></ul><p>在实际开发中，合理地组合使用这些选择器，可以创建出既美观又具有良好结构的网页。了解每种选择器的特点和使用场景，可以帮助开发者更高效地编写CSS代码，实现精确的样式控制。</p><p>CSS（Cascading Style Sheets）提供了丰富的属性用于控制网页上的元素样式。在这里，我们将聚焦于字体属性，它们是调整文本外观的重要工具，包括<code>font-size</code>、<code>font-weight</code>和<code>font-family</code>。通过合理应用这些属性，可以大幅提升网页内容的可读性和美观性。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h3><h4 id="1-font-size"><a href="#1-font-size" class="headerlink" title="1. font-size"></a>1. <code>font-size</code></h4><p><code>font-size</code>属性用于设置字体的大小，可以使用不同的单位，如像素(px)、em、rem等。</p><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="comment">/* 设置字体大小为16像素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-font-weight"><a href="#2-font-weight" class="headerlink" title="2. font-weight"></a>2. <code>font-weight</code></h4><p><code>font-weight</code>属性用于设置字体的粗细。它可以取多个值，如<code>normal</code>、<code>bold</code>、或具体的数值（400对应<code>normal</code>，700对应<code>bold</code>）。</p><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold; <span class="comment">/* 设置字体为粗体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="3-font-family"><a href="#3-font-family" class="headerlink" title="3. font-family"></a>3. <code>font-family</code></h4><p><code>font-family</code>属性用于设置元素的字体。可以指定一个字体列表，浏览器将按列表顺序尝试使用，直到找到可用的字体。</p><h4 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Arial&quot;</span>, <span class="string">&quot;Helvetica&quot;</span>, sans-serif; <span class="comment">/* 如果Arial不可用，则尝试Helvetica，依此类推 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>完整示例</p><p>在下面的示例中，我们将展示如何在HTML文档的<code>&lt;head&gt;</code>部分使用内部样式来定义ID选择器<code>#name</code>的字体样式。</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#name</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">20px</span>; <span class="comment">/* 设置字体大小为20像素 */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-weight</span>: <span class="number">400</span>; <span class="comment">/* 设置字体粗细为400，即正常粗细 */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: <span class="string">&#x27;仿宋&#x27;</span>, <span class="string">&#x27;宋体&#x27;</span>, serif; <span class="comment">/* 设置字体为仿宋，如果不可用，则尝试宋体 */</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span>我是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>通过这个示例，我们可以看到如何利用CSS字体属性来改善网页上文本的表现。记住，在实际开发中选择字体时要考虑到字体的可用性和版权问题，特别是在使用非标准或商业字体时。正确使用字体属性不仅能够提升网页的视觉效果，还能改善用户的阅读体验。</p><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><p>在CSS中，处理文本的外观和布局是常见的需求。<code>line-height</code>和<code>text-align</code>是两个重要的文本属性，它们分别控制文本的行高和水平对齐方式。理解并正确应用这些属性对于改善网页的可读性和美观性至关重要。</p><h4 id="1-line-height（行高）"><a href="#1-line-height（行高）" class="headerlink" title="1. line-height（行高）"></a>1. <code>line-height</code>（行高）</h4><ul><li><strong>含义</strong>：<code>line-height</code>属性用于设置行间的距离，即一行文本的底部到下一行文本顶部的距离。它决定了文本的垂直间距，对提高文本的可读性非常重要。</li><li><strong>单位</strong>：可以使用不同的单位来设置<code>line-height</code>，包括像素(px)、百分比(%)、em、或没有单位的数值（相对于当前字体大小的倍数）。使用没有单位的数值可以保持字体大小与行高之间的相对关系，即使字体大小发生变化。</li></ul><h4 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>; <span class="comment">/* 设置行高为字体大小的1.5倍 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-text-align（水平对齐）"><a href="#2-text-align（水平对齐）" class="headerlink" title="2. text-align（水平对齐）"></a>2. <code>text-align</code>（水平对齐）</h4><ul><li><strong>含义</strong>：<code>text-align</code>属性用于设置文本的水平对齐方式。它可以控制文本在其包含块内的对齐方式。</li><li><strong>取值</strong>：<ul><li><code>left</code>：文本左对齐。</li><li><code>center</code>：文本居中对齐。</li><li><code>right</code>：文本右对齐。</li><li><code>justify</code>：文本两端对齐，自动调整单词间的间距来实现这一效果。</li></ul></li></ul><h4 id="示例代码：-4"><a href="#示例代码：-4" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center; <span class="comment">/* 文本居中对齐 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h4><p>结合<code>line-height</code>和<code>text-align</code>，可以控制文本的垂直间距和水平对齐方式，从而创建出既舒适又美观的文本布局。</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">1.6</span>; <span class="comment">/* 提高行间距，增强可读性 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: justify; <span class="comment">/* 文本两端对齐，提升文档的正式性 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">20px</span>; <span class="comment">/* 增加段落周围的空间 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. Cras elementum ultrices diam. Maecenas ligula massa, varius a, semper congue, euismod non, mi.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>通过合理设置这些文本属性，可以大大提升网页内容的阅读体验。</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><ul><li><strong><code>color</code></strong>: 用于设置文本的颜色。可以使用颜色名（如<code>red</code>）、十六进制值（如<code>#FF0000</code>）、RGB（如<code>rgb(255, 0, 0)</code>）、RGBA（如<code>rgba(255, 0, 0, 0.5)</code>）、HSL（如<code>hsl(0, 100%, 50%)</code>）等方式指定颜色。</li><li><strong><code>background-color</code></strong>: 用于设置元素的背景颜色。颜色的指定方式同<code>color</code>属性。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f7f2f2</span>; <span class="comment">/* 设置文本颜色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: red; <span class="comment">/* 设置背景颜色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>在CSS中，每个元素都被视为一个盒子，这些盒子共同构成了网页的布局。盒子模型包括几个关键的组成部分：内容（Content）、内边距（Padding）、边框（Border）、外边距（Margin），以及可选的背景信息。</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul><li><strong><code>width</code></strong> 和 <strong><code>height</code></strong>: 分别设置盒子的宽度和高度。默认情况下，这些尺寸仅包括内容区域，不包含内边距、边框或外边距。</li><li><strong><code>border</code></strong>: 设置元素的边框样式、宽度和颜色。</li><li><strong><code>padding</code></strong>: 设置元素内容与边框之间的空间，即内边距。</li><li><strong><code>margin</code></strong>: 设置元素与其他元素之间的空间，即外边距。</li><li><strong><code>border-radius</code></strong>: 设置边框角的圆滑度。当设置为50%时，如果盒子的宽度和高度相等，盒子将呈现为圆形。</li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>; <span class="comment">/* 边框为1px黑色实线 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="comment">/* 内边距 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>; <span class="comment">/* 外边距 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>; <span class="comment">/* 边框圆角 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="清除默认的内外边距"><a href="#清除默认的内外边距" class="headerlink" title="清除默认的内外边距"></a>清除默认的内外边距</h3><p>网页元素默认带有内外边距，这有时会影响布局效果。使用CSS可以全局重置这些默认值，以确保页面在不同浏览器中具有一致的外观。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>; <span class="comment">/* 清除外边距 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/* 清除内边距 */</span></span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 当设置width和height时，元素的边框和内边距的空间也包含在内 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>行内块（Inline-Block）与行内（Inline）元素</strong></p><ul><li><p><strong><code>div</code>（行内块元素的使用场景）</strong>：默认情况下，<code>div</code>是一个块级元素，用于布局和容纳其他元素。通过将<code>div</code>的<code>display</code>属性设置为<code>inline-block</code>，可以使其同时拥有行内元素和块级元素的特性。这意味着它可以像行内元素一样在文本流中不换行显示，同时又可以设置宽度和高度。</p></li><li><p><strong><code>span</code>（行内元素）</strong>：<code>span</code>是一个典型的行内元素，主要用于对文本的小块进行样式设置。默认情况下，行内元素不能设置宽度和高度，因为它们的尺寸由内容决定。但是，通过将<code>span</code>或其他行内元素的<code>display</code>属性改为<code>inline-block</code>，可以使其支持宽度和高度的设置。</p></li></ul><p><strong>盒子居中</strong></p><p>使用<code>margin: 0 auto;</code>是一个常用的技巧，用于将块级元素在其父容器中水平居中。为了使这个技巧有效，元素必须有一个指定的宽度。</p><p>示例代码：</p><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.centered-div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* 指定宽度 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto; <span class="comment">/* 上下边距为0，左右自动调整以居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>清除浏览器的默认内外边距</strong></p><p>浏览器为许多HTML元素提供了默认的内外边距，这可能会影响到布局。使用通配符（<code>*</code>）选择器设置所有元素的<code>margin</code>和<code>padding</code>为0是一个常见的做法，用来重置这些默认样式，以保证跨浏览器的一致性。</p><p>示例代码：</p><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 添加box-sizing以包含边框和内边距在元素的宽度和高度内 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，代码中的<code>box-sizing: border-box;</code>是一个有用的补充，它更改了盒子模型的工作方式，使元素的宽度和高度包含其边框和内边距，这样做可以简化布局的计算。</p>    </div>  </div><p>CSS中的<code>:hover</code>伪类选择器用于定义当鼠标悬停在元素上时的样式。这是一种常用的技术，用于增强网页的交互性和视觉反馈。通过使用<code>:hover</code>，你可以指定元素在用户鼠标悬停时的不同样式，例如改变背景颜色、文字颜色、边框等。这里，我们将详细说明如何使用<code>:hover</code>来创建移入效果，并给出一个具体的示例。</p><h2 id="移入效果"><a href="#移入效果" class="headerlink" title="移入效果"></a>移入效果</h2><h3 id="使用-hover创建移入效果"><a href="#使用-hover创建移入效果" class="headerlink" title="使用:hover创建移入效果"></a>使用<code>:hover</code>创建移入效果</h3><p><code>:hover</code>伪类可以应用于任何元素，不仅限于链接。当元素处于悬停状态（即鼠标指针悬浮在元素上方）时，<code>:hover</code>伪类就会被激活，元素的样式将根据<code>:hover</code>后定义的规则改变。</p><h3 id="示例：改变背景色和文字颜色"><a href="#示例：改变背景色和文字颜色" class="headerlink" title="示例：改变背景色和文字颜色"></a>示例：改变背景色和文字颜色</h3><p>假设有一个类名为<code>.box2</code>的元素，你想要在鼠标悬停时改变其背景色和文字颜色，可以这样编写CSS：</p><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">85</span>, <span class="number">219</span>, <span class="number">61</span>); <span class="comment">/* 鼠标悬停时的背景颜色 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>; <span class="comment">/* 鼠标悬停时的文字颜色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>在这个示例中，<code>.box2</code>是一个<code>div</code>元素的类名。当用户将鼠标指针移动到这个<code>div</code>上时，它的背景色将变为绿色（RGB(85, 219, 61)），文字颜色变为白色（#fff）。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用<code>:hover</code>时，确保选择的颜色或样式变化在视觉上有明显区别，以便用户可以清楚地看到效果变化。</li><li>虽然<code>:hover</code>主要用于鼠标悬停效果，但在触摸设备上，这种效果可能会有所不同。在设计时应考虑到这一点，确保网站或应用在不同设备上的可用性。</li></ul><p>通过合理使用<code>:hover</code>伪类，可以在不增加JavaScript代码的情况下，仅通过CSS就能创建出丰富的交互效果，提升用户体验。</p><p>在CSS中，定位（Positioning）是一种强大的布局工具，允许你控制元素的位置。通过使用<code>position</code>属性，你可以定义元素是如何在页面上定位的。这里我们将探讨<code>position</code>属性的几种不同类型：<code>relative</code>、<code>absolute</code>、和<code>fixed</code>，以及如何使用它们。</p><h2 id="定位-Position"><a href="#定位-Position" class="headerlink" title="定位 Position"></a>定位 Position</h2><h3 id="1-相对定位（Relative-Positioning）"><a href="#1-相对定位（Relative-Positioning）" class="headerlink" title="1. 相对定位（Relative Positioning）"></a>1. 相对定位（Relative Positioning）</h3><p>当元素设置为相对定位（<code>position: relative;</code>）时，它将相对于其原始（正常流）位置进行定位。你可以使用<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>属性来指定元素应该移动的距离。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2-绝对定位（Absolute-Positioning）"><a href="#2-绝对定位（Absolute-Positioning）" class="headerlink" title="2. 绝对定位（Absolute Positioning）"></a>2. 绝对定位（Absolute Positioning）</h3><p>绝对定位的元素（<code>position: absolute;</code>）是相对于最近的已定位的祖先元素进行定位的。如果没有已定位的祖先元素，那么它将相对于文档的<code>&lt;html&gt;</code>元素进行定位。绝对定位使元素脱离正常文档流。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="comment">/* 父元素设置为相对定位 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">10px</span>; <span class="comment">/* 距离父元素底部10px */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>; <span class="comment">/* 距离父元素左边20px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-固定定位（Fixed-Positioning）"><a href="#3-固定定位（Fixed-Positioning）" class="headerlink" title="3. 固定定位（Fixed Positioning）"></a>3. 固定定位（Fixed Positioning）</h3><p>固定定位（<code>position: fixed;</code>）的元素是相对于浏览器窗口进行定位的，即使页面滚动，元素也会保持在指定的位置。这通常用于创建始终可见的导航栏。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>; <span class="comment">/* 距离浏览器窗口顶部是0px */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>; <span class="comment">/* 距离浏览器窗口左边是0px */</span></span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li><strong>脱离文档流</strong>：使用<code>absolute</code>和<code>fixed</code>定位的元素会从正常的文档流中脱离出来，这意味着它们不会影响其他元素的布局。</li><li><strong>块级和行内元素</strong>：定位属性可应用于块级和行内元素。</li><li><strong>祖先元素的影响</strong>：对于绝对定位，元素的位置是相对于最近的已定位祖先元素确定的。如果没有这样的祖先，那么它相对于初始包含块定位。</li></ul><h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><p>Flex布局，也称为弹性布局，自2009年由W3C提出以来，已经成为现代网页设计中不可或缺的布局解决方案。它旨在提供一种更高效、更灵活的方式来设计、布置和分配容器内项目的空间，无论容器的大小如何变化。Flex布局特别适用于响应式设计和复杂组件布局中。现在，Flex布局已获得所有现代浏览器的广泛支持，可以安全地在生产环境中使用。</p><h3 id="何为Flex布局"><a href="#何为Flex布局" class="headerlink" title="何为Flex布局"></a>何为Flex布局</h3><p>Flex布局即“弹性布局”，它允许容器内的子元素能够按照指定的方向排列，并且这些子元素的尺寸可以根据额外空间的多少进行伸缩。使用Flex布局，开发者可以轻松实现各种复杂的布局结构，同时保持代码的简洁性和可维护性。</p><h3 id="使用Flex布局"><a href="#使用Flex布局" class="headerlink" title="使用Flex布局"></a>使用Flex布局</h3><p>要使用Flex布局，首先需要在父容器上设置<code>display: flex;</code>属性。这一步将该容器指定为Flex容器，其直接子元素将成为Flex项目（Flex items），并开始遵循Flex布局的规则。</p><h4 id="示例代码：-5"><a href="#示例代码：-5" class="headerlink" title="示例代码："></a>示例代码：</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box_hz</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box_hz&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box_hz&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="响应式Flex项目"><a href="#响应式Flex项目" class="headerlink" title="响应式Flex项目"></a>响应式Flex项目</h3><p>在Flex布局中，可以通过<code>flex</code>属性来控制Flex项目的伸缩性。<code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。通过调整这些值，可以控制Flex项目如何增长（占据更多空间）或收缩（占据较少空间），以及它们在默认情况下应该有多大。</p><p>设置<code>flex: 1</code>意味着所有子元素将等分容器的空间，如果空间不足，它们也会等比例缩小以适应容器。</p><h4 id="增强的示例代码："><a href="#增强的示例代码：" class="headerlink" title="增强的示例代码："></a>增强的示例代码：</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box_hz</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 使子盒子响应式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过上述设置，<code>.box_hz</code>中的每个子元素将平等地分配<code>.box</code>容器的空间，从而实现了响应式设计。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flex布局极大地简化了复杂布局的实现过程，使得开发者可以更加专注于内容和功能的实现，而不必担心布局问题。通过使用Flex布局，可以创建出灵活、适应性强且易于维护的网页布局，从而提升用户体验和开发效率。</p><p>Flex布局中的容器属性是管理和控制Flex容器内部元素排列的关键。特别是<code>justify-content</code>和<code>align-items</code>属性，它们分别控制容器内项目沿主轴（x轴）和交叉轴（y轴）的对齐方式。下面是这些属性的详细说明及示例，帮助你更好地理解和使用Flex布局。</p><h2 id="Flex容器"><a href="#Flex容器" class="headerlink" title="Flex容器"></a>Flex容器</h2><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><h4 id="1-justify-content：沿主轴（水平方向）的对齐方式"><a href="#1-justify-content：沿主轴（水平方向）的对齐方式" class="headerlink" title="1. justify-content：沿主轴（水平方向）的对齐方式"></a>1. <code>justify-content</code>：沿主轴（水平方向）的对齐方式</h4><ul><li>**<code>flex-start</code>**（默认）：项目位于容器的开始位置。</li><li>**<code>center</code>**：项目位于容器的中心。</li><li>**<code>flex-end</code>**：项目位于容器的末尾。</li><li>**<code>space-between</code>**：项目之间的间隔相等，第一个项目在容器的开始位置，最后一个项目在容器的末尾。</li><li>**<code>space-around</code>**：项目周围的间隔相等。每个项目两侧的空间相等。</li><li>**<code>space-evenly</code>**：项目和容器边缘之间的空间以及项目之间的空间都相等。</li></ul><h4 id="2-align-items：沿交叉轴（垂直方向）的对齐方式"><a href="#2-align-items：沿交叉轴（垂直方向）的对齐方式" class="headerlink" title="2. align-items：沿交叉轴（垂直方向）的对齐方式"></a>2. <code>align-items</code>：沿交叉轴（垂直方向）的对齐方式</h4><ul><li>**<code>flex-start</code>**：项目位于容器的起始边缘。</li><li>**<code>center</code>**：项目位于容器的中心。</li><li>**<code>flex-end</code>**：项目位于容器的末端。</li><li>**<code>baseline</code>**：项目的基线对齐。</li><li>**<code>stretch</code>**（默认）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>下面的示例展示了一个Flex容器（<code>.box1</code>），它将内部的两个Flex项目（<code>.box2</code>）在水平和垂直方向上居中对齐。</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 沿主轴居中对齐 */</span></span></span><br><span class="line"><span class="language-css">  <span class="attribute">align-items</span>: center; <span class="comment">/* 沿交叉轴居中对齐 */</span></span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">10px</span>; <span class="comment">/* 为了更清楚地展示两个项目，添加了margin */</span></span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>.box1</code>是一个Flex容器，它通过设置<code>justify-content: center;</code>和<code>align-items: center;</code>属性来确保所有子项目（<code>.box2</code>）在容器中水平和垂直居中对齐。这是创建中心对齐布局的常用方法，特别适合于制作登录页面、居中卡片等布局结构。</p><p>理解和掌握<code>justify-content</code>和<code>align-items</code>这两个属性，对于使用Flex布局来说是非常重要的，它们提供了强大的对齐控制能力，使得布局变得既简单又灵活。</p>]]></content>
    
    
    <summary type="html">CSS基本介绍</summary>
    
    
    
    <category term="前端" scheme="https://www.yiuhangblog.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="CSS" scheme="https://www.yiuhangblog.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="https://www.yiuhangblog.com/2018/11/13/20181113HTML/"/>
    <id>https://www.yiuhangblog.com/2018/11/13/20181113HTML/</id>
    <published>2018-11-13T13:09:16.000Z</published>
    <updated>2024-03-06T10:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h2><p>HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签，通过这些标签可以将网络上的文档格式统一。简单来说，网页就是用HTML语言制作的。HTML是一门描述性语言，是一门非常容易入门的语言。</p><h2 id="HTML的作用"><a href="#HTML的作用" class="headerlink" title="HTML的作用"></a>HTML的作用</h2><ol><li><strong>内容结构化</strong>：HTML通过标签（tags）来组织和格式化网页上的信息，如段落、标题、链接、图片等，使得文本不仅仅是一串字符，而是具有特定结构和意义的内容。</li><li><strong>创建超链接</strong>：HTML的一个核心功能是能够创建超文本链接，这些链接不仅可以链接到同一个网站内的不同页面，还可以链接到其他网站的页面。这种链接性是互联网互联互通的基础。</li><li><strong>嵌入媒体</strong>：HTML允许开发者在网页上嵌入图片、音频、视频等多媒体资源，使网页内容更加丰富和动态。</li><li><strong>表单功能</strong>：HTML提供了创建表单的功能，允许用户输入数据，如用户名、密码、评论等。这些数据可以被网站收集和处理，用于各种互动和功能，比如搜索、用户注册、评论等。</li><li><strong>与CSS和JavaScript协作</strong>：虽然HTML本身主要负责网页的结构和内容，但它可以与CSS（层叠样式表）和JavaScript协同工作，分别负责网页的样式和行为。通过这种分工合作，开发者可以创建出既美观又功能丰富的网页应用。</li></ol><h2 id="网页的组成部分"><a href="#网页的组成部分" class="headerlink" title="网页的组成部分"></a>网页的组成部分</h2><p>网页的组成部分主要包括以下几个方面：</p><ol><li><strong>HTML (HyperText Markup Language)</strong>: HTML 是网页的基础，用于创建和组织网页内容的结构。它包含了一系列的标记（tags）来定义文本、链接、图片、列表、表格等元素。</li><li><strong>CSS (Cascading Style Sheets)</strong>: CSS 用于设置网页的布局和样式。它允许开发者控制文字大小、颜色、间距、布局、背景图像等样式属性，从而使网页更加美观和用户友好。</li><li><strong>JavaScript</strong>: JavaScript 是一种脚本语言，用于创建动态内容和交互式效果。通过JavaScript，可以实现用户事件处理、动画、数据验证、与服务器的通信等功能。</li><li><strong>图片和多媒体内容</strong>: 网页中可能包含图片、视频、音频等多媒体内容，用于增强信息传达和用户体验。</li><li><strong>字体和图标</strong>: 自定义字体和图标可以提高网页的视觉吸引力和品牌识别度。</li><li><strong>数据和API (Application Programming Interface)</strong>: 现代网页可能会与服务器进行数据交换，通过API获取动态数据，实现网页内容的实时更新和用户个性化体验。</li><li><strong>Meta标签</strong>: Meta标签提供了网页的元数据信息，如网页描述、关键词、作者等，这些信息虽然不直接显示给用户，但对搜索引擎优化（SEO）非常重要。</li><li><strong>网页框架和库</strong>: 如React, Vue, Angular等，这些现代的JavaScript框架和库提供了构建复杂、高效、响应式网页应用的工具和组件。</li></ol><p>每个部分都扮演着重要的角色，共同工作以创建富有功能、用户友好和视觉吸引力的网页。</p><h2 id="结构介绍"><a href="#结构介绍" class="headerlink" title="结构介绍"></a>结构介绍</h2><h3 id="生成结构"><a href="#生成结构" class="headerlink" title="生成结构"></a>生成结构</h3><p>Visual Studio Code 可以通过<code>shift + ! 然后回车</code>生产html结构</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0cf1e892-66a5-4ffb-5411-26ea8b0bf600/public"                      width = "600"                ><h3 id="结构详情介绍"><a href="#结构详情介绍" class="headerlink" title="结构详情介绍"></a>结构详情介绍</h3><ul><li>html由标签和属性构成。</li><li>标签：长在尖角号后面的第一个单词就是标签</li><li>属性：长在标签后面的并且用空格隔开的，称作 属性</li><li>结构标签介绍</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- html为根标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- head包裹的称为头部区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 网页采用utf-8的编码格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 网页标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- body包裹的称为内容区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>在HTML（HyperText Markup Language，超文本标记语言）中，<code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, 和 <code>&lt;body&gt;</code> 标签扮演着构建网页的基础框架的角色。它们每一个都有特定的用途和重要性：</p><h3 id="标签"><a href="#标签" class="headerlink" title="&lt;html&gt; 标签"></a><code>&lt;html&gt;</code> 标签</h3><ul><li><code>&lt;html&gt;</code> 标签是一个HTML文档的根元素。它包含了整个页面的内容，包括<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>两个部分。</li><li>它告诉浏览器页面的内容是HTML，确保浏览器正确解析页面内容。</li><li>通常，一个HTML文档的开始和结束都会被<code>&lt;html&gt;</code>标签包围。</li></ul><h3 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;head&gt; 标签"></a><code>&lt;head&gt;</code> 标签</h3><ul><li><code>&lt;head&gt;</code> 标签包含了一系列的元信息（meta-information）关于HTML文档，这些信息不会直接显示在页面上。</li><li>它通常包含标题(<code>&lt;title&gt;</code>)、样式表(<code>&lt;link&gt;</code>标签，用于链接CSS文件)、脚本(<code>&lt;script&gt;</code>标签，用于包含JavaScript)、元数据(<code>&lt;meta&gt;</code>标签，用于指定字符集、页面描述、关键词等)等。</li><li><code>&lt;title&gt;</code> 标签定义的文本会显示在浏览器的标题栏或页面的标签上。</li><li><code>&lt;head&gt;</code>标签是必须的，尽管有些情况下浏览器可以推断出它的存在。</li></ul><h3 id="标签-2"><a href="#标签-2" class="headerlink" title="&lt;body&gt; 标签"></a><code>&lt;body&gt;</code> 标签</h3><ul><li><code>&lt;body&gt;</code> 标签包含了所有可见的页面内容，比如文本、图片、视频、游戏、可播放的音频等。</li><li>实际上，用户在浏览器中看到的一切，除了一些由浏览器插件（如工具栏）生成的内容外，都是放在<code>&lt;body&gt;</code>标签内的。</li><li>它是HTML文档的主要部分，通常只有一个<code>&lt;body&gt;</code>标签。</li></ul><p>简而言之，<code>&lt;html&gt;</code>标签定义了整个HTML文档的范围，<code>&lt;head&gt;</code>标签包含了文档的元信息和引用资源，而<code>&lt;body&gt;</code>标签则包含了实际呈现给用户看到的内容。</p><h2 id="网页中常见的标签"><a href="#网页中常见的标签" class="headerlink" title="网页中常见的标签"></a>网页中常见的标签</h2><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p>HTML中的标题标签用于定义文档的标题和子标题，有六级，从<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>。这些标签不仅用于视觉上区分不同层次的标题和子标题，而且对于搜索引擎优化（SEO）也非常重要，因为搜索引擎利用这些标签来理解页面的结构和内容的重点。</p><h4 id="标签-3"><a href="#标签-3" class="headerlink" title="&lt;h1&gt;标签"></a><code>&lt;h1&gt;</code>标签</h4><ul><li>通常用于页面的主标题。</li><li>每个页面上建议只使用一次<code>&lt;h1&gt;</code>标签，以便清楚地传达页面的主要主题。</li><li>对于SEO来说，<code>&lt;h1&gt;</code>标签是非常重要的，它告诉搜索引擎哪部分内容是页面上最重要的。</li></ul><h4 id="到标签"><a href="#到标签" class="headerlink" title="&lt;h2&gt;到&lt;h6&gt;标签"></a><code>&lt;h2&gt;</code>到<code>&lt;h6&gt;</code>标签</h4><ul><li>用于定义从次要标题到最不重要的标题。</li><li>这些标签帮助创建内容的层次结构，使得信息易于理解和导航。</li><li>使用这些标签时，最好按顺序使用，不要跳跃使用（例如，直接从<code>&lt;h1&gt;</code>跳到<code>&lt;h3&gt;</code>，跳过<code>&lt;h2&gt;</code>），以保持内容的结构清晰。</li></ul><h4 id="SEO和可访问性"><a href="#SEO和可访问性" class="headerlink" title="SEO和可访问性"></a>SEO和可访问性</h4><ul><li>标题标签在帮助搜索引擎理解页面内容方面发挥着关键作用。通过合理使用标题标签，可以提高网站的搜索引擎排名。</li><li>对于屏幕阅读器用户，合理的标题层次也非常重要，因为它们依赖于这些标签来导航内容。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>页面主标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>主要部分标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>次级部分标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>小节标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>更细小节标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>最小节标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b7c2f968-d2de-4692-7443-7044ac9da300/public"                      width = "600"                ><p>在实际使用中，应该根据内容的重要性和结构来选择合适级别的标题标签，以帮助用户和搜索引擎更好地理解和导航内容。</p><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><p>在HTML中，段落标签<code>&lt;p&gt;</code>用于定义文本的段落。这是最常用的标签之一，用于组织和展示网页上的文本内容。段落标签帮助创建清晰的文本结构，使得内容易于阅读和理解。</p><h4 id="使用标签"><a href="#使用标签" class="headerlink" title="使用&lt;p&gt;标签"></a>使用<code>&lt;p&gt;</code>标签</h4><ul><li>当你需要在网页上添加一段文字时，你应该将这段文字放在<code>&lt;p&gt;</code>标签之间。</li><li>浏览器会自动在段落的前后添加一些垂直空间（上下边距），以便区分相邻的段落和其他元素。</li><li><code>&lt;p&gt;</code>标签是块级元素，这意味着它通常会显示为新的一行开始，并且占据其父元素的全部宽度。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落，它包含了一些文本内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落，用于展示如何在HTML中创建多个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/94aea098-a577-4951-ed9b-fafa76aa3c00/public"                      width = "600"                ><h4 id="样式和结构"><a href="#样式和结构" class="headerlink" title="样式和结构"></a>样式和结构</h4><ul><li>尽管<code>&lt;p&gt;</code>标签主要用于文本内容，但可以通过CSS来改变它的外观，比如修改字体、大小、颜色、行高以及边距等。</li><li>使用段落标签而不是通过连续的<code>&lt;br&gt;</code>标签来创建新行是一种更好的实践。这样做不仅符合HTML的语义，而且使得内容的结构更清晰，也便于通过CSS进行全局样式的控制。</li><li>为了提高内容的可访问性和SEO效果，建议合理使用段落标签来组织文本，使其结构化和易于理解。</li></ul><h4 id="与其他文本元素的关系"><a href="#与其他文本元素的关系" class="headerlink" title="与其他文本元素的关系"></a>与其他文本元素的关系</h4><ul><li><code>&lt;p&gt;</code>标签通常与标题标签（<code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>）一起使用，标题标签定义了各个部分的标题，而段落标签则用于包含实际的内容文本。</li><li>在段落内部，你还可以使用其他标签，如加强标签<code>&lt;strong&gt;</code>和强调标签<code>&lt;em&gt;</code>，来提高文本的可读性和表达特定的语义。</li></ul><h3 id="强调标签"><a href="#强调标签" class="headerlink" title="强调标签"></a>强调标签</h3><p>在HTML中，用于强调文本的标签主要包括<code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>，它们各自表达不同程度的强调意义，同时也对搜索引擎优化（SEO）有一定的影响，因为这些标签能帮助搜索引擎理解哪些词语或短语是重要的。</p><h4 id="标签-4"><a href="#标签-4" class="headerlink" title="&lt;em&gt;标签"></a><code>&lt;em&gt;</code>标签</h4><ul><li><p><code>&lt;em&gt;</code>标签用于表示文本的强调，通常表现为斜体。</p></li><li><p>这种强调是为了改变单词或短语的语气，类似于我们在说话时通过语音的变化来强调某些词。</p></li><li><p>使用示例：</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我真的<span class="tag">&lt;<span class="name">em</span>&gt;</span>非常喜欢<span class="tag">&lt;/<span class="name">em</span>&gt;</span>这部电影。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li><li><p>在这个例子中，”非常喜欢”这个短语会以斜体显示，以突出强调。</p></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8f0cf5f2-c659-45f9-59e0-3fb464f84600/public"                      width = "600"                ><h4 id="标签-5"><a href="#标签-5" class="headerlink" title="&lt;strong&gt;标签"></a><code>&lt;strong&gt;</code>标签</h4><ul><li><p><code>&lt;strong&gt;</code>标签用于表示文本的重要性，通常表现为加粗。</p></li><li><p>这种标记不仅改变了文本的外观，更重要的是，它传达了内容的重要性，可以用于突出显示关键信息或重点。</p></li><li><p>使用示例：</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>重要：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>明天的会议取消了。<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li><li><p>在这个例子中，”明天的会议取消了”这个短语会被加粗显示，以强调其重要性。</p></li></ul><h3 id="语义和搜索引擎优化（SEO）"><a href="#语义和搜索引擎优化（SEO）" class="headerlink" title="语义和搜索引擎优化（SEO）"></a>语义和搜索引擎优化（SEO）</h3><ul><li><code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>标签不仅仅是为了改变文本的外观，它们具有语义的意义，表示文本的某部分比周围的文本更加重要或需要强调。</li><li>从SEO的角度看，合理使用这些标签可以帮助搜索引擎识别出页面中的关键信息，从而可能影响搜索结果的排名。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>尽管这些标签在视觉上可能与使用CSS样式（如<code>font-style: italic;</code>或<code>font-weight: bold;</code>）达到的效果相似，但它们的目的是传达语义，而不仅仅是外观。</li><li>应当谨慎使用这些标签，以确保不会过度强调文本，从而分散了读者的注意力或降低了页面的可读性。</li></ul><p>通过合理利用<code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>标签，开发者不仅能提高网页内容的表现力，还能增强其语义结构，对提高用户体验和优化搜索引擎排名都有积极作用。</p><h3 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h3><ul><li>br标签</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">窗前明月光<span class="tag">&lt;<span class="name">br</span>&gt;</span>疑是地上霜<span class="tag">&lt;<span class="name">br</span>&gt;</span>举头望明月<span class="tag">&lt;<span class="name">br</span>&gt;</span>低头思故乡</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="hr标签"><a href="#hr标签" class="headerlink" title="hr标签"></a>hr标签</h3><p>作用：标签变成分割线</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">你好呀</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">哈哈</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h3><ul><li>div标签 是用来布局的，并没有语义，只是一个区块</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">这是个盒子</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="span标签"><a href="#span标签" class="headerlink" title="span标签"></a>span标签</h3><ul><li>没有语义，一般用来包裹文字,让文字更好被选中。</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这是个盒子<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="img标签-图片标签"><a href="#img标签-图片标签" class="headerlink" title="img标签(图片标签)"></a>img标签(图片标签)</h3><ul><li>作用：插入图片</li><li>属性<ul><li>src: 引入图片路径</li><li>alt: 对图片的描述</li><li>height: 设置图片的高</li><li>width: 设置图片的宽度</li></ul></li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 可以链接引入</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://image.baidu.com/search/detail?</span></span></span><br><span class="line"><span class="string"><span class="tag">ct=503316480&amp;z=undefined&amp;tn=baiduimagedetail&amp;ipn=d&amp;word=csdn&amp;step_word=&amp;ie=u</span></span></span><br><span class="line"><span class="string"><span class="tag">tf-</span></span></span><br><span class="line"><span class="string"><span class="tag">8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefi</span></span></span><br><span class="line"><span class="string"><span class="tag">ned&amp;cs=3710574112,2880096239&amp;os=1416383172,4248936337&amp;simid=3710574112,28800</span></span></span><br><span class="line"><span class="string"><span class="tag">96239&amp;pn=2&amp;rn=1&amp;di=7214885350303334401&amp;ln=1613&amp;fr=&amp;fmq=1684939880586_R&amp;fm=&amp;i</span></span></span><br><span class="line"><span class="string"><span class="tag">c=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face</span></span></span><br><span class="line"><span class="string"><span class="tag">=undefined&amp;is=0,0&amp;istype=0&amp;ist=&amp;jit=&amp;bdtype=0&amp;spn=0&amp;pi=0&amp;gsm=1e&amp;objurl=https</span></span></span><br><span class="line"><span class="string"><span class="tag">%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%253A%252F%252Fdingyue.ws.126.net%25</span></span></span><br><span class="line"><span class="string"><span class="tag">2F2021%252F1228%252F42dd5c8ej00r4t6c6000ld200u000iug00u000iu.jpg%26thumbnail</span></span></span><br><span class="line"><span class="string"><span class="tag">%3D660x2147483647%26quality%3D80%26type%3Djpg&amp;rpstart=0&amp;rpnum=0&amp;adpicid=0&amp;no</span></span></span><br><span class="line"><span class="string"><span class="tag">jc=undefined&amp;dyTabStr=MCw2LDEsNCw1LDMsMiw3LDgsOQ%3D%3D&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">// 也可以本地引入</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./图片.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><ul><li>作用:点击跳转到另一个网页</li><li>href：指定访问资源的URL</li><li>target:指定打开资源的方式<ul><li>_self：默认值，在当前页面打开</li><li>_blank：在空白页面打开</li></ul></li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://baidu.com&quot;</span>&gt;</span>点击当前页面跳转到百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点击重新打开页面跳转到百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><ul><li>有序列表 ol li</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>无序列表 ul li</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p>在网页中主要负责数据采集功能<br>表单项(元素)：不同类型的input元素、下拉列表、文本域等</p><ul><li><p>input 标签</p><ul><li><p>type属性：</p><ul><li>text: 默认值、定义单行输入字段</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>password：定义密码字段</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>radio：定义单选框</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--单选框--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--想要多个单选按钮互斥，需要把他们的name设为一样的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要格外注意加value及对应的值，这样提交以后会把这个值提交进去，从而区分</span></span><br><span class="line"><span class="comment">是男是女--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> &gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> &gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>checkbox：复选框</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>阅读</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>button: 按钮</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;一个普通按钮&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>一个普通按钮的第二个写法<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>file：会将头像文件上传</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--上传文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li></ul></li><li><p>select :定义下拉列表，option定义列表项</p></li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>黄色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>textarea ：文本域</li></ul><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">HTML基本介绍</summary>
    
    
    
    <category term="前端" scheme="https://www.yiuhangblog.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="HTML" scheme="https://www.yiuhangblog.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Pandas</title>
    <link href="https://www.yiuhangblog.com/2018/11/12/20181112Pandas/"/>
    <id>https://www.yiuhangblog.com/2018/11/12/20181112Pandas/</id>
    <published>2018-11-12T02:23:47.000Z</published>
    <updated>2024-03-19T09:53:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pandas简介"><a href="#Pandas简介" class="headerlink" title="Pandas简介"></a>Pandas简介</h2><h3 id="文件的读取与数据创建"><a href="#文件的读取与数据创建" class="headerlink" title="文件的读取与数据创建"></a>文件的读取与数据创建</h3><h4 id="读取CSV文件"><a href="#读取CSV文件" class="headerlink" title="读取CSV文件"></a>读取CSV文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件（基本）</span></span><br><span class="line">df = pd.read_csv(</span><br><span class="line">    <span class="string">&quot;./路径/文件.csv&quot;</span>,</span><br><span class="line">    encoding=<span class="string">&#x27;utf-8&#x27;</span>,  <span class="comment"># 指定文件编码</span></span><br><span class="line">    index_col=<span class="literal">None</span>,    <span class="comment"># 指定索引列，None表示不将任何列用作索引</span></span><br><span class="line">    sep=<span class="string">&#x27;,&#x27;</span>,           <span class="comment"># 指定字段分隔符，逗号(,)是默认值</span></span><br><span class="line">    usecols=<span class="literal">None</span>,      <span class="comment"># 指定要读取的列，None表示读取所有列</span></span><br><span class="line">    names=<span class="literal">None</span>         <span class="comment"># 指定列名，None表示使用文件第一行作为列名</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取TSV文件（制表符分隔的文件）</span></span><br><span class="line">df_tsv = pd.read_csv(</span><br><span class="line">    <span class="string">&quot;./路径/文件.tsv&quot;</span>,</span><br><span class="line">    sep=<span class="string">&#x27;\t&#x27;</span>  <span class="comment"># 制表符作为字段分隔符</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文本文件，指定分隔符，列名和没有标题行</span></span><br><span class="line">df_txt = pd.read_csv(</span><br><span class="line">    <span class="string">&#x27;./路径/文件.txt&#x27;</span>,</span><br><span class="line">    sep=<span class="string">&#x27;\t&#x27;</span>,          <span class="comment"># 制表符作为字段分隔符</span></span><br><span class="line">    header=<span class="number">0</span>,          <span class="comment"># 指定标题所在行的索引，0表示第一行</span></span><br><span class="line">    names=[<span class="string">&#x27;字段1&#x27;</span>, <span class="string">&#x27;字段2&#x27;</span>]  <span class="comment"># 指定列名</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h4 id="存储CSV文件"><a href="#存储CSV文件" class="headerlink" title="存储CSV文件"></a>存储CSV文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储为CSV文件（基本）</span></span><br><span class="line">df.to_csv(<span class="string">&quot;./路径/文件.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储为TSV文件（制表符分隔的文件）</span></span><br><span class="line">df.to_csv(</span><br><span class="line">    <span class="string">&quot;./路径/文件.tsv&quot;</span>,</span><br><span class="line">    sep=<span class="string">&#x27;\t&#x27;</span>,  <span class="comment"># 指定制表符作为字段分隔符</span></span><br><span class="line">    index=<span class="literal">False</span>  <span class="comment"># 不保存索引列到文件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储为文本文件，使用制表符作为分隔符，不保存索引</span></span><br><span class="line">df.to_csv(</span><br><span class="line">    <span class="string">&quot;./路径/文件.txt&quot;</span>,</span><br><span class="line">    sep=<span class="string">&#x27;\t&#x27;</span>,   <span class="comment"># 指定制表符作为字段分隔符</span></span><br><span class="line">    index=<span class="literal">False</span>  <span class="comment"># 不保存索引列到文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>对于处理Excel文件、JSON数据、以及与MySQL数据库交互的操作，我们可以整理和规范化代码示例，以提供清晰的指导。</p><h3 id="处理Excel文件"><a href="#处理Excel文件" class="headerlink" title="处理Excel文件"></a>处理Excel文件</h3><h4 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取Excel文件</span></span><br><span class="line">df = pd.read_excel(</span><br><span class="line">    <span class="string">&quot;./路径/文件.xlsx&quot;</span>,</span><br><span class="line">    engine=<span class="string">&quot;openpyxl&quot;</span>,    <span class="comment"># 指定读取引擎，对于.xlsx文件推荐使用&#x27;openpyxl&#x27;</span></span><br><span class="line">    sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>,  <span class="comment"># 指定工作表名称</span></span><br><span class="line">    header=<span class="number">0</span>              <span class="comment"># 指定标题所在行的索引，0表示第一行，None时不将任何行用作列名</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h4 id="存储为Excel文件"><a href="#存储为Excel文件" class="headerlink" title="存储为Excel文件"></a>存储为Excel文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储DataFrame为Excel文件</span></span><br><span class="line">df.to_excel(</span><br><span class="line">    <span class="string">&#x27;./路径/文件.xlsx&#x27;</span>,</span><br><span class="line">    sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>,  <span class="comment"># 指定工作表名称</span></span><br><span class="line">    index=<span class="literal">False</span>           <span class="comment"># 不保存索引列到文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h3 id="处理JSON数据"><a href="#处理JSON数据" class="headerlink" title="处理JSON数据"></a>处理JSON数据</h3><h4 id="读取JSON数据"><a href="#读取JSON数据" class="headerlink" title="读取JSON数据"></a>读取JSON数据</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件读取JSON数据</span></span><br><span class="line">df_from_file = pd.read_json(<span class="string">&#x27;./路径/文件.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从URL直接读取JSON数据</span></span><br><span class="line">URL = <span class="string">&#x27;https://example.com/data.json&#x27;</span></span><br><span class="line">df_from_url = pd.read_json(URL)</span><br></pre></td></tr></table></figure></div><h4 id="存储为JSON文件"><a href="#存储为JSON文件" class="headerlink" title="存储为JSON文件"></a>存储为JSON文件</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储DataFrame为JSON文件</span></span><br><span class="line">df.to_json(<span class="string">&#x27;./路径/文件.json&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="与MySQL数据库交互"><a href="#与MySQL数据库交互" class="headerlink" title="与MySQL数据库交互"></a>与MySQL数据库交互</h3><h4 id="读取MySQL数据库数据"><a href="#读取MySQL数据库数据" class="headerlink" title="读取MySQL数据库数据"></a>读取MySQL数据库数据</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接MySQL数据库</span></span><br><span class="line">cnx = mysql.connector.connect(</span><br><span class="line">    user=<span class="string">&#x27;用户名&#x27;</span>, </span><br><span class="line">    password=<span class="string">&#x27;密码&#x27;</span>, </span><br><span class="line">    host=<span class="string">&#x27;主机地址&#x27;</span>, </span><br><span class="line">    database=<span class="string">&#x27;数据库名&#x27;</span>,</span><br><span class="line">    charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用SQL查询读取数据</span></span><br><span class="line">query = <span class="string">&quot;SELECT * FROM 表名&quot;</span></span><br><span class="line">df = pd.read_sql(query, cnx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure></div><h4 id="存储数据到MySQL数据库"><a href="#存储数据到MySQL数据库" class="headerlink" title="存储数据到MySQL数据库"></a>存储数据到MySQL数据库</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库连接引擎</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;mysql+mysqlconnector://用户名:密码@主机地址/数据库名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储DataFrame到MySQL表中</span></span><br><span class="line">df.to_sql(</span><br><span class="line">    <span class="string">&#x27;tablename&#x27;</span>,         <span class="comment"># 指定数据库表名</span></span><br><span class="line">    con=engine,          <span class="comment"># 指定数据库连接</span></span><br><span class="line">    if_exists=<span class="string">&#x27;replace&#x27;</span>, <span class="comment"># 如果表存在，替换原数据</span></span><br><span class="line">    index=<span class="literal">False</span>          <span class="comment"># 不将DataFrame的索引列存入数据库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>对于创建Pandas Series的基础知识和示例代码，我们可以进行以下整理以提供清晰、规范的说明和操作步骤。</p><h2 id="创建Pandas-Series"><a href="#创建Pandas-Series" class="headerlink" title="创建Pandas Series"></a>创建Pandas Series</h2><h3 id="Series的特点"><a href="#Series的特点" class="headerlink" title="Series的特点"></a>Series的特点</h3><ul><li><strong>索引(Index)</strong>: 每个Series对象都有一个索引，用于标识每个数据点。索引的类型可以是整数、字符串、日期等。如果创建Series时未显式指定索引，Pandas会自动生成一个从0开始的整数索引。</li><li><strong>数据类型(Datatype)</strong>: Series可以包含各种类型的数据（整数、浮点数、字符串等）。Pandas允许Series内的数据类型不同，但通常情况下，为了效率，Series中的数据类型会保持一致。</li><li><strong>灵活性</strong>: Series支持多种操作，包括数学运算、索引&#x2F;选择、数据对齐等。</li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>创建Series的基础语法如下：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.Series(data=<span class="literal">None</span>, index=<span class="literal">None</span>, dtype=<span class="literal">None</span>, name=<span class="literal">None</span>, copy=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></div><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><strong>data</strong>: 可以是列表、数组等形式的数据集合。这是Series中存储的主要数据。</li><li><strong>index</strong>: 与数据同长度的索引标签列表。如果未指定，将自动生成从0开始的整数索引。</li><li><strong>dtype</strong>: 数据的类型（如<code>int</code>, <code>float</code>, <code>str</code>等）。如果未指定，dtype将自动推断。</li><li><strong>name</strong>: 为Series指定一个名称，便于理解和输出显示。</li><li><strong>copy</strong>: 是否复制输入数据，默认为<code>False</code>。设置为<code>True</code>可以避免修改原始数据。</li></ul><h3 id="创建Series示例"><a href="#创建Series示例" class="headerlink" title="创建Series示例"></a>创建Series示例</h3><h4 id="示例1-使用列表创建Series"><a href="#示例1-使用列表创建Series" class="headerlink" title="示例1: 使用列表创建Series"></a>示例1: 使用列表创建Series</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">series = pd.Series(data)</span><br><span class="line"><span class="built_in">print</span>(series)</span><br></pre></td></tr></table></figure></div><h4 id="示例2-使用NumPy数组创建Series"><a href="#示例2-使用NumPy数组创建Series" class="headerlink" title="示例2: 使用NumPy数组创建Series"></a>示例2: 使用NumPy数组创建Series</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">series = pd.Series(data)</span><br><span class="line"><span class="built_in">print</span>(series)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/83d8b41c-07d4-46c2-2877-c9aa0d0cd900/public"                      width = "300"                ><p>在这两个示例中，我们创建了包含三个整数的Series对象。由于未指定索引，Pandas自动生成了从0开始的整数索引。这些示例展示了如何从基本的数据结构（列表或NumPy数组）创建Series，并展示了Series的基础属性，如自动索引和数据类型推断。</p><p>使用Pandas Series时，索引是一个强大的特性，允许快速访问、修改数据。以下是如何使用索引获取数据和指定索引的整理和示例。</p><h3 id="使用索引获取数据"><a href="#使用索引获取数据" class="headerlink" title="使用索引获取数据"></a>使用索引获取数据</h3><p>当创建一个Pandas Series对象时，每个元素都会自动分配一个索引。这个索引可以是默认的整数索引，也可以是自定义的索引。</p><h4 id="示例1-使用默认整数索引获取数据"><a href="#示例1-使用默认整数索引获取数据" class="headerlink" title="示例1: 使用默认整数索引获取数据"></a>示例1: 使用默认整数索引获取数据</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Series</span></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">series = pd.Series(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引获取数据</span></span><br><span class="line"><span class="built_in">print</span>(series[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></div><p>此代码会输出Series中索引为1的元素，即<code>2</code>。</p><h4 id="指定索引"><a href="#指定索引" class="headerlink" title="指定索引"></a>指定索引</h4><p>可以在创建Series时通过<code>index</code>参数自定义索引。</p><h5 id="示例2-使用自定义索引"><a href="#示例2-使用自定义索引" class="headerlink" title="示例2: 使用自定义索引"></a>示例2: 使用自定义索引</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Series，指定索引</span></span><br><span class="line">data = [<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line">series = pd.Series(data, index=[<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出整个Series</span></span><br><span class="line"><span class="built_in">print</span>(series)</span><br></pre></td></tr></table></figure></div><p>输出结果将展示一个Series，其中每个元素都由指定的索引标记：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x    Google</span><br><span class="line">y    Runoob</span><br><span class="line">z     Wiki</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure></div><p>在这个例子中，字符串<code>&quot;Google&quot;</code>, <code>&quot;Runoob&quot;</code>, <code>&quot;Wiki&quot;</code>分别被赋予了自定义索引<code>&quot;x&quot;</code>, <code>&quot;y&quot;</code>, <code>&quot;z&quot;</code>。通过指定索引，可以提高数据检索的可读性和灵活性。</p><p>当创建Pandas Series时，指定索引和使用键值对（类似于字典）作为数据源是两种常见的方法。这提供了灵活的数据结构创建和数据访问方式。下面是对这些概念的整理和示例说明。</p><h5 id="示例3-使用自定义索引访问数据"><a href="#示例3-使用自定义索引访问数据" class="headerlink" title="示例3: 使用自定义索引访问数据"></a>示例3: 使用自定义索引访问数据</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Series并指定索引</span></span><br><span class="line">data = [<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line">series = pd.Series(data, index=[<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用指定的索引访问数据</span></span><br><span class="line"><span class="built_in">print</span>(series[<span class="string">&quot;y&quot;</span>])</span><br></pre></td></tr></table></figure></div><p>此代码段会输出索引为<code>&quot;y&quot;</code>的元素，即<code>&quot;Runoob&quot;</code>。</p><h3 id="使用字典创建Series"><a href="#使用字典创建Series" class="headerlink" title="使用字典创建Series"></a>使用字典创建Series</h3><p>当使用字典创建Series时，字典的键自动成为Series的索引，而字典的值成为Series的数据。</p><h4 id="示例1-从字典创建Series"><a href="#示例1-从字典创建Series" class="headerlink" title="示例1: 从字典创建Series"></a>示例1: 从字典创建Series</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典创建Series</span></span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">series = pd.Series(sites)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出Series</span></span><br><span class="line"><span class="built_in">print</span>(series)</span><br></pre></td></tr></table></figure></div><p>这段代码创建了一个Series，其中字典的键（1, 2, 3）自动成为了Series的索引。</p><h4 id="示例2-指定索引过滤数据"><a href="#示例2-指定索引过滤数据" class="headerlink" title="示例2: 指定索引过滤数据"></a>示例2: 指定索引过滤数据</h4><p>如果在使用字典创建Series时还指定了<code>index</code>参数，那么只有在<code>index</code>参数中指定的键会被包含在Series中。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典创建Series，并指定索引</span></span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">series = pd.Series(sites, index=[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出Series</span></span><br><span class="line"><span class="built_in">print</span>(series)</span><br></pre></td></tr></table></figure></div><p>这段代码将只输出键为1和2的数据项，即<code>&quot;Google&quot;</code>和<code>&quot;Runoob&quot;</code>，因为在创建Series时我们通过<code>index</code>参数指定了只包含这些键。</p><p>在处理Pandas Series时，了解如何设置名称、执行基本操作、进行基本运算、以及使用属性和方法是非常重要的。以下是对这些概念的整理和示例说明。</p><h2 id="设置Series名称参数"><a href="#设置Series名称参数" class="headerlink" title="设置Series名称参数"></a>设置Series名称参数</h2><p>可以在创建Series时通过<code>name</code>参数为Series设置一个名称，这有助于标识Series代表的数据集。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Series并设置名称</span></span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar = pd.Series(sites, index=[<span class="number">1</span>, <span class="number">2</span>], name=<span class="string">&quot;RUNOOB-Series-TEST&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br></pre></td></tr></table></figure></div><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用索引获取单个值</span></span><br><span class="line">value = myvar[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片获取多个值</span></span><br><span class="line">subset = myvar[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 注意: 切片操作在使用显式索引时是包含结束索引的</span></span><br></pre></td></tr></table></figure></div><h4 id="遍历Series"><a href="#遍历Series" class="headerlink" title="遍历Series"></a>遍历Series</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引和值的遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> myvar.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;index&#125;</span>, Value: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对Series中的每个元素进行乘法运算</span></span><br><span class="line">result = myvar * <span class="number">2</span></span><br></pre></td></tr></table></figure></div><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用条件过滤Series中的元素</span></span><br><span class="line">filtered_series = myvar[myvar &gt; <span class="number">2</span>]</span><br></pre></td></tr></table></figure></div><h4 id="应用数学函数"><a href="#应用数学函数" class="headerlink" title="应用数学函数"></a>应用数学函数</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对Series中的每个元素应用平方根函数</span></span><br><span class="line">result = np.sqrt(myvar)</span><br></pre></td></tr></table></figure></div><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><h4 id="获取索引和值"><a href="#获取索引和值" class="headerlink" title="获取索引和值"></a>获取索引和值</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取Series的索引</span></span><br><span class="line">index = myvar.index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Series的值</span></span><br><span class="line">values = myvar.values</span><br></pre></td></tr></table></figure></div><h4 id="描述统计"><a href="#描述统计" class="headerlink" title="描述统计"></a>描述统计</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对DataFrame中的数值列进行描述性统计</span></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Emily&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: [<span class="number">90</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">95</span>],</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: [<span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">stats = df.describe()</span><br><span class="line"><span class="built_in">print</span>(stats)</span><br></pre></td></tr></table></figure></div><h4 id="获取最大值和最小值的索引"><a href="#获取最大值和最小值的索引" class="headerlink" title="获取最大值和最小值的索引"></a>获取最大值和最小值的索引</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取Series中最大值和最小值的索引</span></span><br><span class="line">max_index = myvar.idxmax()</span><br><span class="line">min_index = myvar.idxmin()</span><br></pre></td></tr></table></figure></div><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>Pandas的<code>DataFrame</code>是一个二维的、大小可变的、潜在的异构表格数据结构，带有标记的轴（行和列）。理解<code>DataFrame</code>的基础语法和创建方法是使用Pandas进行数据分析和数据处理的基础。</p><h3 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h3><p>创建<code>DataFrame</code>的基础语法如下：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.DataFrame(data=<span class="literal">None</span>, index=<span class="literal">None</span>, columns=<span class="literal">None</span>, dtype=<span class="literal">None</span>, copy=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></div><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><strong>data</strong>: 接受多种类型的输入，包括但不限于<code>ndarray</code>、<code>Series</code>、<code>map</code>、<code>lists</code>、<code>dict</code>等。这是<code>DataFrame</code>中存储的主要数据。</li><li><strong>index</strong>: 行标签。如果没有指定，就像在<code>Series</code>中一样，Pandas会默认创建从0开始的整数索引。</li><li><strong>columns</strong>: 列标签，默认为<code>RangeIndex (0, 1, 2, …, n)</code>。如果数据输入是字典，则默认列标签是字典键排序后的顺序。</li><li><strong>dtype</strong>: 数据类型。可以为整个<code>DataFrame</code>指定一个统一的数据类型。如果不指定，则会自动推断。</li><li><strong>copy</strong>: 是否复制输入数据，默认为<code>False</code>。如果为<code>True</code>，则复制，这可以避免修改到原始数据。</li></ul><h3 id="创建DataFrame示例"><a href="#创建DataFrame示例" class="headerlink" title="创建DataFrame示例"></a>创建DataFrame示例</h3><h4 id="通过列表创建DataFrame"><a href="#通过列表创建DataFrame" class="headerlink" title="通过列表创建DataFrame"></a>通过列表创建<code>DataFrame</code></h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据列表</span></span><br><span class="line">data = [[<span class="string">&#x27;Google&#x27;</span>, <span class="number">10</span>], [<span class="string">&#x27;Runoob&#x27;</span>, <span class="number">12</span>], [<span class="string">&#x27;Wiki&#x27;</span>, <span class="number">13</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;Site&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>], dtype=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印DataFrame</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><p>输出结果将是一个<code>DataFrame</code>，包含两列<code>Site</code>和<code>Age</code>，数据类型被设置为浮点数：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     Site   Age</span><br><span class="line">0  Google  10.0</span><br><span class="line">1  Runoob  12.0</span><br><span class="line">2    Wiki  13.0</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>data</code>是一个列表，其中包含三个子列表，每个子列表代表一行数据。通过<code>columns</code>参数指定了列名为<code>Site</code>和<code>Age</code>，通过<code>dtype</code>参数将所有数值数据类型指定为浮点数。</p><p>在Pandas中，<code>DataFrame</code>是用于存储和操作结构化数据的主要数据结构。以下内容整理了<code>DataFrame</code>的创建、基本操作、属性和方法，以及如何从外部数据源创建<code>DataFrame</code>的相关信息。</p><h4 id="通过ndarrays或列表的字典创建"><a href="#通过ndarrays或列表的字典创建" class="headerlink" title="通过ndarrays或列表的字典创建"></a>通过ndarrays或列表的字典创建</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典创建DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Site&#x27;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Wiki&#x27;</span>], <span class="string">&#x27;Age&#x27;</span>: [<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><p>输出结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     Site  Age</span><br><span class="line">0  Google   10</span><br><span class="line">1  Runoob   12</span><br><span class="line">2    Wiki   13</span><br></pre></td></tr></table></figure></div><h4 id="通过字典列表创建"><a href="#通过字典列表创建" class="headerlink" title="通过字典列表创建"></a>通过字典列表创建</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字典列表创建DataFrame</span></span><br><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><p>输出结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   a   b     c</span><br><span class="line">0  1   2   NaN</span><br><span class="line">1  5  10  20.0</span><br></pre></td></tr></table></figure></div><p>注意：缺失的数据部分为<code>NaN</code>，而非<code>NULL</code>。</p><h3 id="loc-属性返回指定行的数据"><a href="#loc-属性返回指定行的数据" class="headerlink" title="loc 属性返回指定行的数据"></a><strong>loc</strong> 属性返回指定行的数据</h3><p>首先，导入Pandas库，并创建一个包含数据的字典，然后将其载入到<code>DataFrame</code>对象中。默认情况下，如果没有指定索引，Pandas会自动创建一个从0开始的整数索引。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure></div><h4 id="返回单行数据"><a href="#返回单行数据" class="headerlink" title="返回单行数据"></a>返回单行数据</h4><p>使用<code>loc</code>属性，可以通过指定行索引来返回对应的数据行。此时，返回的结果是一个Pandas <code>Series</code>数据类型。</p><ul><li>返回第一行数据：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div><ul><li>返回第二行数据：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></div><h4 id="返回多行数据"><a href="#返回多行数据" class="headerlink" title="返回多行数据"></a>返回多行数据</h4><p><code>loc</code>同样可以用于返回多行数据，通过传递一个包含多个索引的列表作为参数。</p><ul><li>返回第一行和第二行数据：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.loc[[<span class="number">0</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure></div><h4 id="使用自定义索引"><a href="#使用自定义索引" class="headerlink" title="使用自定义索引"></a>使用自定义索引</h4><p>Pandas允许为<code>DataFrame</code>对象的行设置自定义索引。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(data, index = [<span class="string">&quot;day1&quot;</span>, <span class="string">&quot;day2&quot;</span>, <span class="string">&quot;day3&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><p>使用自定义索引后，可以使用这些索引值来检索数据行。</p><ul><li>使用<code>loc</code>属性返回自定义索引对应的某一行：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&quot;day2&quot;</span>])</span><br></pre></td></tr></table></figure></div><p>在这个例子中，我们首先设置了自定义索引（”day1”, “day2”, “day3”），然后通过这些索引来检索数据。当使用<code>loc</code>与自定义索引时，指定的索引值必须存在于<code>DataFrame</code>的索引中，否则会引发<code>KeyError</code>。</p><p>在使用Pandas处理数据时，<code>DataFrame</code>是一个非常核心的数据结构，它允许以表格的形式存储和操作结构化数据。以下是对提供的代码和概念的整理和解释，帮助更好地理解如何使用<code>DataFrame</code>进行基本操作、属性和方法的调用、数据操作技巧，以及如何从外部数据源创建<code>DataFrame</code>。</p><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="获取列"><a href="#获取列" class="headerlink" title="获取列"></a>获取列</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_column = df[<span class="string">&#x27;Name&#x27;</span>]</span><br></pre></td></tr></table></figure></div><h4 id="获取行"><a href="#获取行" class="headerlink" title="获取行"></a>获取行</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_row = df.loc[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div><h4 id="选择多列"><a href="#选择多列" class="headerlink" title="选择多列"></a>选择多列</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subset = df[[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]]</span><br></pre></td></tr></table></figure></div><h4 id="过滤行"><a href="#过滤行" class="headerlink" title="过滤行"></a>过滤行</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filtered_rows = df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]</span><br></pre></td></tr></table></figure></div><h3 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h3><h4 id="获取列名"><a href="#获取列名" class="headerlink" title="获取列名"></a>获取列名</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">columns = df.columns</span><br></pre></td></tr></table></figure></div><h4 id="获取形状（行数和列数）"><a href="#获取形状（行数和列数）" class="headerlink" title="获取形状（行数和列数）"></a>获取形状（行数和列数）</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape = df.shape</span><br></pre></td></tr></table></figure></div><h4 id="获取索引"><a href="#获取索引" class="headerlink" title="获取索引"></a>获取索引</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = df.index</span><br></pre></td></tr></table></figure></div><h4 id="获取描述统计信息"><a href="#获取描述统计信息" class="headerlink" title="获取描述统计信息"></a>获取描述统计信息</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stats = df.describe()</span><br></pre></td></tr></table></figure></div><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="添加新列"><a href="#添加新列" class="headerlink" title="添加新列"></a>添加新列</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Salary&#x27;</span>] = [<span class="number">50000</span>, <span class="number">60000</span>, <span class="number">70000</span>]</span><br></pre></td></tr></table></figure></div><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop(<span class="string">&#x27;City&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by=<span class="string">&#x27;Age&#x27;</span>, ascending=<span class="literal">False</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h4 id="重命名列"><a href="#重命名列" class="headerlink" title="重命名列"></a>重命名列</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.rename(columns=&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Full Name&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h3 id="从外部数据源创建-DataFrame"><a href="#从外部数据源创建-DataFrame" class="headerlink" title="从外部数据源创建 DataFrame"></a>从外部数据源创建 DataFrame</h3><h4 id="从CSV文件创建"><a href="#从CSV文件创建" class="headerlink" title="从CSV文件创建"></a>从CSV文件创建</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_csv = pd.read_csv(<span class="string">&#x27;example.csv&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="从Excel文件创建"><a href="#从Excel文件创建" class="headerlink" title="从Excel文件创建"></a>从Excel文件创建</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_excel = pd.read_excel(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="从字典列表创建"><a href="#从字典列表创建" class="headerlink" title="从字典列表创建"></a>从字典列表创建</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_list = [&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">25</span>&#125;, &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">30</span>&#125;]</span><br><span class="line">df_from_list = pd.DataFrame(data_list)</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <ul><li><strong>灵活性</strong>：<code>DataFrame</code>可以容纳不同数据类型的列（例如整数、浮点数、字符串等）。</li><li><strong>索引</strong>：列名和行索引可以是字符串、整数等。Pandas提供了丰富的索引功能，以便于数据选择和操作。</li><li><strong>数据操作</strong>：可以通过多种方式进行数据选择、过滤、修改和分析，这使得<code>DataFrame</code>非常适合数据清洗、转换、分析和可视化等工作。</li></ul>    </div>  </div><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="缺失率"><a href="#缺失率" class="headerlink" title="缺失率"></a>缺失率</h3><p>缺失率是指在数据集中缺失值所占的比例，通常用于数据清洗和预处理阶段，以评估数据的完整性。计算缺失率的基本公式如下：</p><p>$$ \text{缺失率 (%)} &#x3D; \left( \frac{\text{缺失值数量}}{\text{总值数量}} \right) \times 100 $$</p><p>其中，</p><ul><li>数据集中的缺失值数量是指那些空白或者NULL值的数量。</li><li>数据集中的总值数量是指数据集中所有可能的数据点的数量，包括有效值和缺失值。</li></ul><p>缺失率可以帮助我们了解数据缺失的严重程度，进而决定如何处理这些缺失值，比如通过删除缺失值、填补缺失值或者采用模型估计等方法。</p><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><p>在这个<code>DataFrame</code>中，包含了几个列：<code>id</code>、<code>date</code>、<code>city</code>、<code>age</code>、<code>category</code>，以及<code>price</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: [<span class="number">1001</span>, <span class="number">1002</span>, <span class="number">1003</span>, <span class="number">1004</span>, <span class="number">1005</span>, <span class="number">1006</span>], </span><br><span class="line">    <span class="string">&quot;date&quot;</span>: pd.date_range(<span class="string">&#x27;20130102&#x27;</span>, periods=<span class="number">6</span>),</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: [<span class="string">&#x27;Beijing &#x27;</span>, <span class="string">&#x27;SH&#x27;</span>, <span class="string">&#x27; guangzhou &#x27;</span>, <span class="string">&#x27;Shenzhen&#x27;</span>, <span class="string">&#x27;shanghai&#x27;</span>, <span class="string">&#x27;BEIJING &#x27;</span>],</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: [<span class="number">23</span>, <span class="number">44</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">32</span>],</span><br><span class="line">    <span class="string">&quot;category&quot;</span>: [<span class="string">&#x27;100-A&#x27;</span>, <span class="string">&#x27;100-B&#x27;</span>, <span class="string">&#x27;110-A&#x27;</span>, <span class="string">&#x27;110-C&#x27;</span>, <span class="string">&#x27;210-A&#x27;</span>, <span class="string">&#x27;130-F&#x27;</span>],</span><br><span class="line">    <span class="string">&quot;price&quot;</span>: [<span class="number">1200</span>, np.nan, <span class="number">2133</span>, <span class="number">5433</span>, np.nan, <span class="number">4432</span>]</span><br><span class="line">&#125;, columns=[<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;category&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;price&#x27;</span>])</span><br></pre></td></tr></table></figure></div><p>这段代码首先导入了必要的库：<code>pandas</code>和<code>numpy</code>。<code>numpy</code>在这里的用途是提供<code>np.nan</code>来表示缺失值，这在处理真实世界的数据时非常常见。</p><ul><li><code>id</code>列包含唯一标识符。</li><li><code>date</code>列使用<code>pd.date_range</code>函数生成了一个日期范围。</li><li><code>city</code>列包含了一些城市名称，注意这些城市名称前后可能包含空格。</li><li><code>age</code>列包含了年龄。</li><li><code>category</code>列包含了分类代码。</li><li><code>price</code>列包含了价格，使用<code>np.nan</code>表示某些价格未知或缺失。</li></ul><p>通过指定<code>columns</code>参数，确保了<code>DataFrame</code>列的顺序按照<code>id</code>、<code>date</code>、<code>city</code>、<code>category</code>、<code>age</code>、<code>price</code>的顺序排列，即使在字典中的顺序不是这样的。</p><h4 id="数据概览"><a href="#数据概览" class="headerlink" title="数据概览"></a>数据概览</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><pre><code>     id       date         city category  age   price0  1001 2013-01-02     Beijing     100-A   23  1200.01  1002 2013-01-03           SH    100-B   44     NaN2  1003 2013-01-04   guangzhou     110-A   54  2133.03  1004 2013-01-05     Shenzhen    110-C   32  5433.04  1005 2013-01-06     shanghai    210-A   34     NaN5  1006 2013-01-07     BEIJING     130-F   32  4432.0</code></pre><h4 id="每列缺失值的数量"><a href="#每列缺失值的数量" class="headerlink" title="每列缺失值的数量"></a>每列缺失值的数量</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每列缺失值的数量</span></span><br><span class="line">missing_values_count = df.isnull().<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(missing_values_count)</span><br></pre></td></tr></table></figure></div><pre><code>id          0date        0city        0category    0age         0price       2dtype: int64</code></pre>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显示所有的数据</span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="literal">None</span>)  <span class="comment"># 显示所有行</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="literal">None</span>)  <span class="comment"># 显示所有列</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;expand_frame_repr&#x27;</span>, <span class="literal">False</span>)  <span class="comment"># 不自动换行</span></span><br></pre></td></tr></table></figure></div>    </div>  </div><h4 id="缺失率-1"><a href="#缺失率-1" class="headerlink" title="缺失率"></a>缺失率</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算缺失率</span></span><br><span class="line">missing_rate = (missing_values_count / <span class="built_in">len</span>(df)) * <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(missing_rate)</span><br></pre></td></tr></table></figure></div><pre><code>id           0.000000date         0.000000city         0.000000category     0.000000age          0.000000price       33.333333dtype: float64</code></pre><h2 id="DataFrame常规操作"><a href="#DataFrame常规操作" class="headerlink" title="DataFrame常规操作"></a>DataFrame常规操作</h2><h3 id="修改index、columns"><a href="#修改index、columns" class="headerlink" title="修改index、columns"></a>修改index、columns</h3><h4 id="修改DataFrame的索引（index）"><a href="#修改DataFrame的索引（index）" class="headerlink" title="修改DataFrame的索引（index）"></a>修改DataFrame的索引（<code>index</code>）</h4><p>在Pandas中，修改DataFrame的索引是一个常见操作，可以帮助更好地定位和引用数据行。下面是如何修改DataFrame索引的步骤和示例：</p><ol><li><p><strong>设置默认显示行数</strong>：首先，我们可以通过<code>pd.set_option</code>来设置Pandas默认显示的行数。这里未展示设置方法，但可以通过<code>print(df.head())</code>来显示前几行数据，其中<code>df</code>是DataFrame变量名。</p></li><li><p><strong>直接修改索引</strong>：可以通过直接赋值给<code>df.index</code>属性来修改整个DataFrame的索引。例如，如果有一个DataFrame <code>row</code>，并且想要将索引修改为<code>[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]</code>，需要确保索引的长度与DataFrame的行数相匹配。如果不匹配，会导致错误。</p></li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row.index = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br></pre></td></tr></table></figure></div><h4 id="读取文件时只处理部分行"><a href="#读取文件时只处理部分行" class="headerlink" title="读取文件时只处理部分行"></a>读取文件时只处理部分行</h4><p>当处理大型文件时，为了测试或其他目的，可能只想读取文件的一部分。使用<code>pd.read_csv</code>时，可以通过<code>nrows</code>参数来限制读取的行数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;./LCIS.csv&#x27;</span>, nrows=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><h4 id="修改DataFrame的列名（columns）"><a href="#修改DataFrame的列名（columns）" class="headerlink" title="修改DataFrame的列名（columns）"></a>修改DataFrame的列名（<code>columns</code>）</h4><p>修改列名可以通过直接赋值给<code>df.columns</code>属性或使用<code>rename</code>方法。</p><ol><li><strong>直接修改所有列名</strong>：通过直接赋值给<code>df.columns</code>属性，可以为所有列设置新的列名。</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row.columns = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br></pre></td></tr></table></figure></div><ol start="2"><li><strong>使用<code>rename</code>方法修改列名</strong>：如果只想修改某些列的名称，可以使用<code>rename</code>方法，并通过<code>columns</code>参数传入一个字典，字典的键是旧列名，值是新列名。使用<code>inplace=True</code>可以直接在原DataFrame上进行修改，而不是返回一个新的DataFrame。</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row.rename(columns=&#123;<span class="string">&#x27;ListingId&#x27;</span>: <span class="string">&#x27;ID&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h4 id="单独修改一个索引或列名"><a href="#单独修改一个索引或列名" class="headerlink" title="单独修改一个索引或列名"></a>单独修改一个索引或列名</h4><p>同样，使用<code>rename</code>方法也可以修改单个索引或列名，方法与修改列名类似。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row.rename(index=&#123;<span class="number">0</span>: <span class="string">&#x27;A&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><p>现在，让我们通过一个综合示例来展示如何实际应用上述操作，并提供预期的输出结果。</p><h5 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;LCIS.csv&#x27;</span>,nrows=<span class="number">5</span>, usecols=<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">row = pd.DataFrame(df)</span><br></pre></td></tr></table></figure></div><h5 id="修改索引前的输出"><a href="#修改索引前的输出" class="headerlink" title="修改索引前的输出"></a>修改索引前的输出</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改索引前:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(row.head())</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改索引前:</span><br><span class="line">   ListingId   借款金额  借款期限  借款利率     借款成功日期 初始评级 借款类型 是否首标  年龄 性别</span><br><span class="line">0    1693100   3629     6    12  2015/1/28   AA   普通    否  31  男</span><br><span class="line">1    1713229   3000    12    12  2015/1/30   AA   普通    是  24  男</span><br><span class="line">2    1904026   3629    12    12   2015/3/7   AA   普通    否  27  男</span><br><span class="line">3    2158281   3919    12    18  2015/4/14    C   普通    否  28  男</span><br><span class="line">4    2257194  14000    12    18  2015/4/23    C   普通    否  46  男</span><br></pre></td></tr></table></figure></div><h5 id="修改索引后的输出"><a href="#修改索引后的输出" class="headerlink" title="修改索引后的输出"></a>修改索引后的输出</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改索引</span></span><br><span class="line">row.index = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n修改索引后:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(row.head())</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改索引后:</span><br><span class="line">   ListingId   借款金额  借款期限  借款利率     借款成功日期 初始评级 借款类型 是否首标  年龄 性别</span><br><span class="line">x    1693100   3629     6    12  2015/1/28   AA   普通    否  31  男</span><br><span class="line">y    1713229   3000    12    12  2015/1/30   AA   普通    是  24  男</span><br><span class="line">z    1904026   3629    12    12   2015/3/7   AA   普通    否  27  男</span><br><span class="line">a    2158281   3919    12    18  2015/4/14    C   普通    否  28  男</span><br><span class="line">b    2257194  14000    12    18  2015/4/23    C   普通    否  46  男</span><br></pre></td></tr></table></figure></div><h5 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改列名</span></span><br><span class="line">row.columns = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n修改列名后:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(row.head())</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改列名后:</span><br><span class="line">         A      B   C   D          E   F   G  H   I  J</span><br><span class="line">x  1693100   3629   6  12  2015/1/28  AA  普通  否  31  男</span><br><span class="line">y  1713229   3000  12  12  2015/1/30  AA  普通  是  24  男</span><br><span class="line">z  1904026   3629  12  12   2015/3/7  AA  普通  否  27  男</span><br><span class="line">a  2158281   3919  12  18  2015/4/14   C  普通  否  28  男</span><br><span class="line">b  2257194  14000  12  18  2015/4/23   C  普通  否  46  男</span><br></pre></td></tr></table></figure></div><h5 id="使用rename方法重命名列"><a href="#使用rename方法重命名列" class="headerlink" title="使用rename方法重命名列"></a>使用rename方法重命名列</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用rename方法重命名列</span></span><br><span class="line">row.rename(columns=&#123;<span class="string">&#x27;A&#x27;</span>: <span class="string">&#x27;ID&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n使用rename方法修改列名后:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用rename方法修改列名后:</span><br><span class="line">        ID      B   C   D          E   F   G  H   I  J</span><br><span class="line">x  1693100   3629   6  12  2015/1/28  AA  普通  否  31  男</span><br><span class="line">y  1713229   3000  12  12  2015/1/30  AA  普通  是  24  男</span><br><span class="line">z  1904026   3629  12  12   2015/3/7  AA  普通  否  27  男</span><br><span class="line">a  2158281   3919  12  18  2015/4/14   C  普通  否  28  男</span><br><span class="line">b  2257194  14000  12  18  2015/4/23   C  普通  否  46  男</span><br></pre></td></tr></table></figure></div><h5 id="单独修改一个索引"><a href="#单独修改一个索引" class="headerlink" title="单独修改一个索引"></a>单独修改一个索引</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单独修改一个索引</span></span><br><span class="line">row.rename(index=&#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n单独修改一个索引后:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单独修改一个索引后:</span><br><span class="line">        ID      B   C   D          E   F   G  H   I  J</span><br><span class="line">A  1693100   3629   6  12  2015/1/28  AA  普通  否  31  男</span><br><span class="line">y  1713229   3000  12  12  2015/1/30  AA  普通  是  24  男</span><br><span class="line">z  1904026   3629  12  12   2015/3/7  AA  普通  否  27  男</span><br><span class="line">a  2158281   3919  12  18  2015/4/14   C  普通  否  28  男</span><br><span class="line">b  2257194  14000  12  18  2015/4/23   C  普通  否  46  男</span><br></pre></td></tr></table></figure></div><h3 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h3><h4 id="concat-函数概览"><a href="#concat-函数概览" class="headerlink" title="concat()函数概览"></a><code>concat()</code>函数概览</h4><p><code>pd.concat()</code>可以沿着一条轴将多个对象堆叠到一起。主要参数包括：</p><ul><li><code>objs</code>：一个序列或映射，表示要合并的pandas对象。</li><li><code>axis</code>：默认为0，表示沿着行合并；设置为1表示沿着列合并。</li><li><code>ignore_index</code>：如果为True，不使用索引标签进行连接；这将对结果DataFrame使用默认整数索引。</li></ul><p>在Pandas中，<code>pd.concat()</code>函数是合并数据的一个非常有用的工具，它允许沿着特定的轴将多个DataFrame合并在一起。下面，我们将通过具体的示例来展示如何使用<code>pd.concat()</code>进行数据合并，包括沿着列(axis&#x3D;1)和沿着行(axis&#x3D;0)的合并。每个案例都将提供代码示例和预期的输出结果。</p><h5 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h5><h6 id="选择性读取行"><a href="#选择性读取行" class="headerlink" title="选择性读取行"></a>选择性读取行</h6><p>有时候，在读取文件创建DataFrame时，可能想要跳过某些行或只读取特定的行。可以通过<code>skiprows</code>和<code>nrows</code>参数来实现这一点：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;./LCIS.csv&#x27;</span>, skiprows=<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>), nrows=<span class="number">3</span>, usecols=<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>))</span><br><span class="line">res = pd.DataFrame(df)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></div><p>这里，<code>skiprows=range(1, 4)</code>跳过了文件的第1到第3行（注意行数是从0开始计数的），而<code>nrows=3</code>指定了之后只读取3行。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">借款期限  借款利率     借款成功日期 初始评级</span><br><span class="line">0    12    18  2015/4/14    C</span><br><span class="line">1    12    18  2015/4/23    C</span><br><span class="line">2     6    15  2015/4/29    B</span><br></pre></td></tr></table></figure></div><p>首先，让我们定义两个DataFrame，<code>row</code>和<code>res</code>，以便进行合并操作。假设这些DataFrame已经根据上文中的说明进行了加载和修改：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设这是从文件中读取的DataFrame</span></span><br><span class="line">row = pd.read_csv(<span class="string">&#x27;LCIS.csv&#x27;</span>, skiprows=<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>), header=<span class="number">0</span>, nrows=<span class="number">10</span>, usecols=<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设res是另一个文件中读取DataFrame</span></span><br><span class="line">res = pd.read_csv(<span class="string">&#x27;LCIS.csv&#x27;</span>,skiprows=<span class="built_in">range</span>(<span class="number">12</span>, <span class="number">20</span>), header=<span class="number">0</span>, nrows=<span class="number">10</span>, usecols=<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;row DataFrame&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(row)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;res DataFrame&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">row DataFrame</span><br><span class="line">   ListingId   借款金额  借款期限  借款利率     借款成功日期 初始评级 借款类型 是否首标  年龄 性别</span><br><span class="line">0    2526671   5115    12  12.0  2015/5/23   AA   普通    否  34  男</span><br><span class="line">1    2707322   5000     3  10.0   2015/6/5   AA   普通    否  35  男</span><br><span class="line">2    2722356   3132    12  20.0  2015/6/13    D   普通    否  30  男</span><br><span class="line">3    2828736   3000    12  12.0  2015/6/19   AA   普通    是  24  男</span><br><span class="line">4    2850335  17640    18  16.0  2015/6/18    B   其他    是  28  男</span><br><span class="line">5    3155520   7008    10  11.0  2015/7/12   AA   普通    否  34  男</span><br><span class="line">6    3207478  19928    12  16.0  2015/7/14    B   其他    是  22  男</span><br><span class="line">7    3617672   7000    12  11.5  2015/8/12   AA   普通    是  43  男</span><br><span class="line">8    3637812   4000     6  10.5  2015/8/17   AA   其他    是  24  男</span><br><span class="line">9    3705094   1000    12  11.5  2015/8/21   AA   普通    是  26  男</span><br><span class="line">=============================================</span><br><span class="line">res DataFrame</span><br><span class="line">   ListingId   借款金额  借款期限  借款利率     借款成功日期 初始评级 借款类型 是否首标  年龄 性别</span><br><span class="line">0    1693100   3629     6    12  2015/1/28   AA   普通    否  31  男</span><br><span class="line">1    1713229   3000    12    12  2015/1/30   AA   普通    是  24  男</span><br><span class="line">2    1904026   3629    12    12   2015/3/7   AA   普通    否  27  男</span><br><span class="line">3    2158281   3919    12    18  2015/4/14    C   普通    否  28  男</span><br><span class="line">4    2257194  14000    12    18  2015/4/23    C   普通    否  46  男</span><br><span class="line">5    2272036  40000     6    15  2015/4/29    B   电商    是  32  男</span><br><span class="line">6    2315058   3200     3    10  2015/4/29   AA   普通    否  25  男</span><br><span class="line">7    2332817   3000     6    12   2015/5/6   AA   普通    是  38  男</span><br><span class="line">8    2365175   4260     7    12   2015/5/6   AA   普通    否  25  男</span><br><span class="line">9    2370723  11987    12    16   2015/5/7    B   其他    否  33  女</span><br></pre></td></tr></table></figure></div><h5 id="沿着列合并DataFrame"><a href="#沿着列合并DataFrame" class="headerlink" title="沿着列合并DataFrame"></a>沿着列合并DataFrame</h5><p>当想要将两个DataFrame按列拼接（即并排放置），可以设置<code>axis=1</code>。这通常用于合并具有相同索引的DataFrame，但列不同的情况。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = pd.concat([row, res], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure></div><p>预期输出是<code>row</code>和<code>res</code>DataFrame并排放置的结果，这里由于<code>row</code>和<code>res</code>的行数相同，因此可以直接并排合并。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   ListingId   借款金额  借款期限  借款利率     借款成功日期 初始评级 借款类型 是否首标  年龄 性别  ListingId  \</span><br><span class="line">0    2526671   5115    12  12.0  2015/5/23   AA   普通    否  34  男    1693100   </span><br><span class="line">1    2707322   5000     3  10.0   2015/6/5   AA   普通    否  35  男    1713229   </span><br><span class="line">2    2722356   3132    12  20.0  2015/6/13    D   普通    否  30  男    1904026   </span><br><span class="line">3    2828736   3000    12  12.0  2015/6/19   AA   普通    是  24  男    2158281   </span><br><span class="line">4    2850335  17640    18  16.0  2015/6/18    B   其他    是  28  男    2257194   </span><br><span class="line">5    3155520   7008    10  11.0  2015/7/12   AA   普通    否  34  男    2272036   </span><br><span class="line">6    3207478  19928    12  16.0  2015/7/14    B   其他    是  22  男    2315058   </span><br><span class="line">7    3617672   7000    12  11.5  2015/8/12   AA   普通    是  43  男    2332817   </span><br><span class="line">8    3637812   4000     6  10.5  2015/8/17   AA   其他    是  24  男    2365175   </span><br><span class="line">9    3705094   1000    12  11.5  2015/8/21   AA   普通    是  26  男    2370723   </span><br><span class="line"></span><br><span class="line">    借款金额  借款期限  借款利率     借款成功日期 初始评级 借款类型 是否首标  年龄 性别  </span><br><span class="line">0   3629     6    12  2015/1/28   AA   普通    否  31  男  </span><br><span class="line">1   3000    12    12  2015/1/30   AA   普通    是  24  男  </span><br><span class="line">2   3629    12    12   2015/3/7   AA   普通    否  27  男  </span><br><span class="line">3   3919    12    18  2015/4/14    C   普通    否  28  男  </span><br><span class="line">4  14000    12    18  2015/4/23    C   普通    否  46  男  </span><br><span class="line">5  40000     6    15  2015/4/29    B   电商    是  32  男  </span><br><span class="line">6   3200     3    10  2015/4/29   AA   普通    否  25  男  </span><br><span class="line">7   3000     6    12   2015/5/6   AA   普通    是  38  男  </span><br><span class="line">8   4260     7    12   2015/5/6   AA   普通    否  25  男  </span><br><span class="line">9  11987    12    16   2015/5/7    B   其他    否  33  女  </span><br></pre></td></tr></table></figure></div><h5 id="沿着行合并DataFrame"><a href="#沿着行合并DataFrame" class="headerlink" title="沿着行合并DataFrame"></a>沿着行合并DataFrame</h5><p>如果想将两个DataFrame上下拼接，可以设置<code>axis=0</code>。这通常用于合并具有相同列的DataFrame，或者即使列不完全相同也可以合并，Pandas会自动处理不匹配的列。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = pd.concat([row, res], axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure></div><p>在这个例子中，由于<code>res</code>仅包含<code>row</code>的部分列，合并结果会展示所有列，不在<code>res</code>中的列对应的行会显示为NaN。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   ListingId   借款金额  借款期限  借款利率     借款成功日期 初始评级 借款类型 是否首标  年龄 性别</span><br><span class="line">0    2526671   5115    12  12.0  2015/5/23   AA   普通    否  34  男</span><br><span class="line">1    2707322   5000     3  10.0   2015/6/5   AA   普通    否  35  男</span><br><span class="line">2    2722356   3132    12  20.0  2015/6/13    D   普通    否  30  男</span><br><span class="line">3    2828736   3000    12  12.0  2015/6/19   AA   普通    是  24  男</span><br><span class="line">4    2850335  17640    18  16.0  2015/6/18    B   其他    是  28  男</span><br><span class="line">5    3155520   7008    10  11.0  2015/7/12   AA   普通    否  34  男</span><br><span class="line">6    3207478  19928    12  16.0  2015/7/14    B   其他    是  22  男</span><br><span class="line">7    3617672   7000    12  11.5  2015/8/12   AA   普通    是  43  男</span><br><span class="line">8    3637812   4000     6  10.5  2015/8/17   AA   其他    是  24  男</span><br><span class="line">9    3705094   1000    12  11.5  2015/8/21   AA   普通    是  26  男</span><br><span class="line">0    1693100   3629     6  12.0  2015/1/28   AA   普通    否  31  男</span><br><span class="line">1    1713229   3000    12  12.0  2015/1/30   AA   普通    是  24  男</span><br><span class="line">2    1904026   3629    12  12.0   2015/3/7   AA   普通    否  27  男</span><br><span class="line">3    2158281   3919    12  18.0  2015/4/14    C   普通    否  28  男</span><br><span class="line">4    2257194  14000    12  18.0  2015/4/23    C   普通    否  46  男</span><br><span class="line">5    2272036  40000     6  15.0  2015/4/29    B   电商    是  32  男</span><br><span class="line">6    2315058   3200     3  10.0  2015/4/29   AA   普通    否  25  男</span><br><span class="line">7    2332817   3000     6  12.0   2015/5/6   AA   普通    是  38  男</span><br><span class="line">8    2365175   4260     7  12.0   2015/5/6   AA   普通    否  25  男</span><br><span class="line">9    2370723  11987    12  16.0   2015/5/7    B   其他    否  33  女</span><br></pre></td></tr></table></figure></div><h5 id="重置索引以避免索引重复"><a href="#重置索引以避免索引重复" class="headerlink" title="重置索引以避免索引重复"></a>重置索引以避免索引重复</h5><p>在进行行合并时，如果不希望保留原始的索引，可以设置<code>ignore_index=True</code>，以避免索引重复的问题。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = pd.concat([row, res], axis=<span class="number">0</span>, ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure></div><p>这会创建一个新的DataFrame，其中索引是重新生成的，从0开始，避免了任何索引重复的问题。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    ListingId   借款金额  借款期限  借款利率     借款成功日期 初始评级 借款类型 是否首标  年龄 性别</span><br><span class="line">0     2526671   5115    12  12.0  2015/5/23   AA   普通    否  34  男</span><br><span class="line">1     2707322   5000     3  10.0   2015/6/5   AA   普通    否  35  男</span><br><span class="line">2     2722356   3132    12  20.0  2015/6/13    D   普通    否  30  男</span><br><span class="line">3     2828736   3000    12  12.0  2015/6/19   AA   普通    是  24  男</span><br><span class="line">4     2850335  17640    18  16.0  2015/6/18    B   其他    是  28  男</span><br><span class="line">5     3155520   7008    10  11.0  2015/7/12   AA   普通    否  34  男</span><br><span class="line">6     3207478  19928    12  16.0  2015/7/14    B   其他    是  22  男</span><br><span class="line">7     3617672   7000    12  11.5  2015/8/12   AA   普通    是  43  男</span><br><span class="line">8     3637812   4000     6  10.5  2015/8/17   AA   其他    是  24  男</span><br><span class="line">9     3705094   1000    12  11.5  2015/8/21   AA   普通    是  26  男</span><br><span class="line">10    1693100   3629     6  12.0  2015/1/28   AA   普通    否  31  男</span><br><span class="line">11    1713229   3000    12  12.0  2015/1/30   AA   普通    是  24  男</span><br><span class="line">12    1904026   3629    12  12.0   2015/3/7   AA   普通    否  27  男</span><br><span class="line">13    2158281   3919    12  18.0  2015/4/14    C   普通    否  28  男</span><br><span class="line">14    2257194  14000    12  18.0  2015/4/23    C   普通    否  46  男</span><br><span class="line">15    2272036  40000     6  15.0  2015/4/29    B   电商    是  32  男</span><br><span class="line">16    2315058   3200     3  10.0  2015/4/29   AA   普通    否  25  男</span><br><span class="line">17    2332817   3000     6  12.0   2015/5/6   AA   普通    是  38  男</span><br><span class="line">18    2365175   4260     7  12.0   2015/5/6   AA   普通    否  25  男</span><br><span class="line">19    2370723  11987    12  16.0   2015/5/7    B   其他    否  33  女</span><br></pre></td></tr></table></figure></div><h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a><code>merge()</code></h4><p>在Pandas中，<code>pd.merge()</code>函数提供了一个强大的方式来合并两个DataFrame，基于一个或多个共同的键。下面，将详细介绍如何使用<code>pd.merge()</code>进行数据合并，包括基于相同列的简单合并、处理行的选择性读取、以及基于不同列名进行合并。每个案例都会提供代码示例和预期的输出。</p><h5 id="示例数据-1"><a href="#示例数据-1" class="headerlink" title="示例数据"></a>示例数据</h5><p>使用concat()示例中同样的数据</p><h5 id="基于共同列合并DataFrame"><a href="#基于共同列合并DataFrame" class="headerlink" title="基于共同列合并DataFrame"></a>基于共同列合并DataFrame</h5><p>当两个DataFrame具有至少一个共同的列时，可以使用这个共同列作为合并的基础。以下是如何根据共同列<code>&#39;借款期限&#39;</code>合并两个DataFrame的示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设row和res是concat()示例中已经加载的DataFrame，且它们有一个共同列&#x27;借款期限&#x27;</span></span><br><span class="line">num = pd.merge(row, res, on=<span class="string">&#x27;借款期限&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure></div><p>在这个示例中，<code>pd.merge()</code>通过<code>on=&#39;借款期限&#39;</code>参数指定了合并的基础列。这将只保留那些在两个DataFrame中都存在的<code>&#39;借款期限&#39;</code>值的行。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">    ListingId_x  借款金额_x  借款期限  借款利率_x   借款成功日期_x 初始评级_x 借款类型_x 是否首标_x  年龄_x  \</span><br><span class="line">0       2526671    5115    12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">1       2526671    5115    12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">2       2526671    5115    12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">3       2526671    5115    12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">4       2526671    5115    12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">5       2722356    3132    12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">6       2722356    3132    12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">7       2722356    3132    12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">8       2722356    3132    12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">9       2722356    3132    12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">10      2828736    3000    12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">11      2828736    3000    12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">12      2828736    3000    12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">13      2828736    3000    12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">14      2828736    3000    12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">15      3207478   19928    12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">16      3207478   19928    12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">17      3207478   19928    12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">18      3207478   19928    12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">19      3207478   19928    12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">20      3617672    7000    12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">21      3617672    7000    12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">22      3617672    7000    12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">23      3617672    7000    12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">24      3617672    7000    12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">25      3705094    1000    12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">26      3705094    1000    12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">27      3705094    1000    12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">28      3705094    1000    12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">29      3705094    1000    12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">30      2707322    5000     3    10.0   2015/6/5     AA     普通      否    35   </span><br><span class="line">31      3637812    4000     6    10.5  2015/8/17     AA     其他      是    24   </span><br><span class="line">32      3637812    4000     6    10.5  2015/8/17     AA     其他      是    24   </span><br><span class="line">33      3637812    4000     6    10.5  2015/8/17     AA     其他      是    24   </span><br><span class="line"></span><br><span class="line">   性别_x  ListingId_y  借款金额_y  借款利率_y   借款成功日期_y 初始评级_y 借款类型_y 是否首标_y  年龄_y  \</span><br><span class="line">0     男      1713229    3000      12  2015/1/30     AA     普通      是    24   </span><br><span class="line">1     男      1904026    3629      12   2015/3/7     AA     普通      否    27   </span><br><span class="line">2     男      2158281    3919      18  2015/4/14      C     普通      否    28   </span><br><span class="line">3     男      2257194   14000      18  2015/4/23      C     普通      否    46   </span><br><span class="line">4     男      2370723   11987      16   2015/5/7      B     其他      否    33   </span><br><span class="line">5     男      1713229    3000      12  2015/1/30     AA     普通      是    24   </span><br><span class="line">6     男      1904026    3629      12   2015/3/7     AA     普通      否    27   </span><br><span class="line">7     男      2158281    3919      18  2015/4/14      C     普通      否    28   </span><br><span class="line">8     男      2257194   14000      18  2015/4/23      C     普通      否    46   </span><br><span class="line">9     男      2370723   11987      16   2015/5/7      B     其他      否    33   </span><br><span class="line">10    男      1713229    3000      12  2015/1/30     AA     普通      是    24   </span><br><span class="line">11    男      1904026    3629      12   2015/3/7     AA     普通      否    27   </span><br><span class="line">12    男      2158281    3919      18  2015/4/14      C     普通      否    28   </span><br><span class="line">13    男      2257194   14000      18  2015/4/23      C     普通      否    46   </span><br><span class="line">14    男      2370723   11987      16   2015/5/7      B     其他      否    33   </span><br><span class="line">15    男      1713229    3000      12  2015/1/30     AA     普通      是    24   </span><br><span class="line">16    男      1904026    3629      12   2015/3/7     AA     普通      否    27   </span><br><span class="line">17    男      2158281    3919      18  2015/4/14      C     普通      否    28   </span><br><span class="line">18    男      2257194   14000      18  2015/4/23      C     普通      否    46   </span><br><span class="line">19    男      2370723   11987      16   2015/5/7      B     其他      否    33   </span><br><span class="line">20    男      1713229    3000      12  2015/1/30     AA     普通      是    24   </span><br><span class="line">21    男      1904026    3629      12   2015/3/7     AA     普通      否    27   </span><br><span class="line">22    男      2158281    3919      18  2015/4/14      C     普通      否    28   </span><br><span class="line">23    男      2257194   14000      18  2015/4/23      C     普通      否    46   </span><br><span class="line">24    男      2370723   11987      16   2015/5/7      B     其他      否    33   </span><br><span class="line">25    男      1713229    3000      12  2015/1/30     AA     普通      是    24   </span><br><span class="line">26    男      1904026    3629      12   2015/3/7     AA     普通      否    27   </span><br><span class="line">27    男      2158281    3919      18  2015/4/14      C     普通      否    28   </span><br><span class="line">28    男      2257194   14000      18  2015/4/23      C     普通      否    46   </span><br><span class="line">29    男      2370723   11987      16   2015/5/7      B     其他      否    33   </span><br><span class="line">30    男      2315058    3200      10  2015/4/29     AA     普通      否    25   </span><br><span class="line">31    男      1693100    3629      12  2015/1/28     AA     普通      否    31   </span><br><span class="line">32    男      2272036   40000      15  2015/4/29      B     电商      是    32   </span><br><span class="line">33    男      2332817    3000      12   2015/5/6     AA     普通      是    38   </span><br><span class="line"></span><br><span class="line">   性别_y  </span><br><span class="line">0     男  </span><br><span class="line">1     男  </span><br><span class="line">2     男  </span><br><span class="line">3     男  </span><br><span class="line">4     女  </span><br><span class="line">5     男  </span><br><span class="line">6     男  </span><br><span class="line">7     男  </span><br><span class="line">8     男  </span><br><span class="line">9     女  </span><br><span class="line">10    男  </span><br><span class="line">11    男  </span><br><span class="line">12    男  </span><br><span class="line">13    男  </span><br><span class="line">14    女  </span><br><span class="line">15    男  </span><br><span class="line">16    男  </span><br><span class="line">17    男  </span><br><span class="line">18    男  </span><br><span class="line">19    女  </span><br><span class="line">20    男  </span><br><span class="line">21    男  </span><br><span class="line">22    男  </span><br><span class="line">23    男  </span><br><span class="line">24    女  </span><br><span class="line">25    男  </span><br><span class="line">26    男  </span><br><span class="line">27    男  </span><br><span class="line">28    男  </span><br><span class="line">29    女  </span><br><span class="line">30    男  </span><br><span class="line">31    男  </span><br><span class="line">32    男  </span><br><span class="line">33    男  </span><br></pre></td></tr></table></figure></div><h5 id="基于不同列名的合并"><a href="#基于不同列名的合并" class="headerlink" title="基于不同列名的合并"></a>基于不同列名的合并</h5><p>如果两个DataFrame要合并的列名不同，可以分别使用<code>left_on</code>和<code>right_on</code>参数来指定各自的列名：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = pd.merge(row, res, left_on=<span class="string">&#x27;借款期限&#x27;</span>, right_on=<span class="string">&#x27;借款利率&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure></div><p>在这个例子中，尽管<code>row</code>和<code>res</code>中要合并的列名不同，但通过<code>left_on</code>和<code>right_on</code>参数，我们能够指定如何将两个DataFrame基于对应列的值进行合并。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">    ListingId_x  借款金额_x  借款期限_x  借款利率_x   借款成功日期_x 初始评级_x 借款类型_x 是否首标_x  年龄_x  \</span><br><span class="line">0       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">1       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">2       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">3       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">4       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">5       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">6       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">7       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">8       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">9       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">10      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">11      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">12      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">13      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">14      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">15      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">16      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">17      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">18      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">19      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">20      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">21      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">22      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">23      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">24      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">25      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">26      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">27      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">28      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">29      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">30      2850335   17640      18    16.0  2015/6/18      B     其他      是    28   </span><br><span class="line">31      2850335   17640      18    16.0  2015/6/18      B     其他      是    28   </span><br><span class="line">32      3155520    7008      10    11.0  2015/7/12     AA     普通      否    34   </span><br><span class="line"></span><br><span class="line">   性别_x  ListingId_y  借款金额_y  借款期限_y  借款利率_y   借款成功日期_y 初始评级_y 借款类型_y 是否首标_y  \</span><br><span class="line">0     男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">1     男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">2     男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">3     男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">4     男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">5     男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">6     男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">7     男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">8     男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">9     男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">10    男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">11    男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">12    男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">13    男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">14    男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">15    男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">16    男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">17    男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">18    男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">19    男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">20    男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">21    男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">22    男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">23    男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">24    男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">25    男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">26    男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">27    男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">28    男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">29    男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">30    男      2158281    3919      12      18  2015/4/14      C     普通      否   </span><br><span class="line">31    男      2257194   14000      12      18  2015/4/23      C     普通      否   </span><br><span class="line">32    男      2315058    3200       3      10  2015/4/29     AA     普通      否   </span><br><span class="line"></span><br><span class="line">    年龄_y 性别_y  </span><br><span class="line">0     31    男  </span><br><span class="line">1     24    男  </span><br><span class="line">2     27    男  </span><br><span class="line">3     38    男  </span><br><span class="line">4     25    男  </span><br><span class="line">5     31    男  </span><br><span class="line">6     24    男  </span><br><span class="line">7     27    男  </span><br><span class="line">8     38    男  </span><br><span class="line">9     25    男  </span><br><span class="line">10    31    男  </span><br><span class="line">11    24    男  </span><br><span class="line">12    27    男  </span><br><span class="line">13    38    男  </span><br><span class="line">14    25    男  </span><br><span class="line">15    31    男  </span><br><span class="line">16    24    男  </span><br><span class="line">17    27    男  </span><br><span class="line">18    38    男  </span><br><span class="line">19    25    男  </span><br><span class="line">20    31    男  </span><br><span class="line">21    24    男  </span><br><span class="line">22    27    男  </span><br><span class="line">23    38    男  </span><br><span class="line">24    25    男  </span><br><span class="line">25    31    男  </span><br><span class="line">26    24    男  </span><br><span class="line">27    27    男  </span><br><span class="line">28    38    男  </span><br><span class="line">29    25    男  </span><br><span class="line">30    28    男  </span><br><span class="line">31    46    男  </span><br><span class="line">32    25    男  </span><br></pre></td></tr></table></figure></div><h5 id="指定合并方式"><a href="#指定合并方式" class="headerlink" title="指定合并方式"></a>指定合并方式</h5><p><code>pd.merge()</code>允许通过<code>how</code>参数来指定合并方式，包括<code>&#39;inner&#39;</code>（内连接）、<code>&#39;outer&#39;</code>（外连接）、<code>&#39;left&#39;</code>（左连接）和<code>&#39;right&#39;</code>（右连接）：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = pd.merge(row, res, left_on=<span class="string">&#x27;借款期限&#x27;</span>, right_on=<span class="string">&#x27;借款利率&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure></div><p>这里，<code>how=&#39;inner&#39;</code>意味着结果中只包含那些两个DataFrame在指定列上都有匹配值的行。不同的<code>how</code>值可以根据需要选择，以实现不同的合并逻辑。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">    ListingId_x  借款金额_x  借款期限_x  借款利率_x   借款成功日期_x 初始评级_x 借款类型_x 是否首标_x  年龄_x  \</span><br><span class="line">0       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">1       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">2       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">3       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">4       2526671    5115      12    12.0  2015/5/23     AA     普通      否    34   </span><br><span class="line">5       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">6       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">7       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">8       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">9       2722356    3132      12    20.0  2015/6/13      D     普通      否    30   </span><br><span class="line">10      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">11      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">12      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">13      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">14      2828736    3000      12    12.0  2015/6/19     AA     普通      是    24   </span><br><span class="line">15      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">16      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">17      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">18      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">19      3207478   19928      12    16.0  2015/7/14      B     其他      是    22   </span><br><span class="line">20      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">21      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">22      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">23      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">24      3617672    7000      12    11.5  2015/8/12     AA     普通      是    43   </span><br><span class="line">25      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">26      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">27      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">28      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">29      3705094    1000      12    11.5  2015/8/21     AA     普通      是    26   </span><br><span class="line">30      2850335   17640      18    16.0  2015/6/18      B     其他      是    28   </span><br><span class="line">31      2850335   17640      18    16.0  2015/6/18      B     其他      是    28   </span><br><span class="line">32      3155520    7008      10    11.0  2015/7/12     AA     普通      否    34   </span><br><span class="line"></span><br><span class="line">   性别_x  ListingId_y  借款金额_y  借款期限_y  借款利率_y   借款成功日期_y 初始评级_y 借款类型_y 是否首标_y  \</span><br><span class="line">0     男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">1     男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">2     男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">3     男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">4     男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">5     男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">6     男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">7     男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">8     男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">9     男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">10    男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">11    男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">12    男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">13    男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">14    男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">15    男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">16    男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">17    男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">18    男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">19    男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">20    男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">21    男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">22    男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">23    男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">24    男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">25    男      1693100    3629       6      12  2015/1/28     AA     普通      否   </span><br><span class="line">26    男      1713229    3000      12      12  2015/1/30     AA     普通      是   </span><br><span class="line">27    男      1904026    3629      12      12   2015/3/7     AA     普通      否   </span><br><span class="line">28    男      2332817    3000       6      12   2015/5/6     AA     普通      是   </span><br><span class="line">29    男      2365175    4260       7      12   2015/5/6     AA     普通      否   </span><br><span class="line">30    男      2158281    3919      12      18  2015/4/14      C     普通      否   </span><br><span class="line">31    男      2257194   14000      12      18  2015/4/23      C     普通      否   </span><br><span class="line">32    男      2315058    3200       3      10  2015/4/29     AA     普通      否   </span><br><span class="line"></span><br><span class="line">    年龄_y 性别_y  </span><br><span class="line">0     31    男  </span><br><span class="line">1     24    男  </span><br><span class="line">2     27    男  </span><br><span class="line">3     38    男  </span><br><span class="line">4     25    男  </span><br><span class="line">5     31    男  </span><br><span class="line">6     24    男  </span><br><span class="line">7     27    男  </span><br><span class="line">8     38    男  </span><br><span class="line">9     25    男  </span><br><span class="line">10    31    男  </span><br><span class="line">11    24    男  </span><br><span class="line">12    27    男  </span><br><span class="line">13    38    男  </span><br><span class="line">14    25    男  </span><br><span class="line">15    31    男  </span><br><span class="line">16    24    男  </span><br><span class="line">17    27    男  </span><br><span class="line">18    38    男  </span><br><span class="line">19    25    男  </span><br><span class="line">20    31    男  </span><br><span class="line">21    24    男  </span><br><span class="line">22    27    男  </span><br><span class="line">23    38    男  </span><br><span class="line">24    25    男  </span><br><span class="line">25    31    男  </span><br><span class="line">26    24    男  </span><br><span class="line">27    27    男  </span><br><span class="line">28    38    男  </span><br><span class="line">29    25    男  </span><br><span class="line">30    28    男  </span><br><span class="line">31    46    男  </span><br><span class="line">32    25    男  </span><br></pre></td></tr></table></figure></div><p>通过上述示例，可以看到<code>pd.merge()</code>在Pandas中合并数据时的灵活性和强大功能。这些基础知识使得在进行数据分析和处理时，能够根据实际需求选择合适的合并策略。</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a><code>join()</code></h4><p>在Pandas中，<code>join()</code>函数是用于将两个或多个DataFrame按照索引合并。这个函数默认执行的是左连接操作，即以调用<code>join()</code>的DataFrame的索引为基准。不过，可以通过<code>how</code>参数来指定连接类型，包括<code>left</code>（左连接）、<code>right</code>（右连接）、<code>inner</code>（内连接）和<code>outer</code>（外连接）。</p>  <div class="note-large red">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-bug"></i><p>警告</p>    </div>    <div class="notel-content">      <p>在尝试使用<code>join()</code>合并两个DataFrame时，两个DataFrame中存在相同名称的列。<code>join()</code>方法默认通过索引来合并数据，如果合并的DataFrame中有重叠的列名（即非索引列），则需要指定后缀来区分这些重叠的列，否则会抛出<code>ValueError</code>。</p><p>为了解决这个问题，可以使用<code>lsuffix</code>和<code>rsuffix</code>参数来为左右DataFrame中重叠的列名分别添加后缀。这样，即使列名相同，添加了后缀之后也能区分开来。</p><p>下面的代码展示了如何使用这些参数来避免错误：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用lsuffix和rsuffix添加后缀</span></span><br><span class="line">result_right = row.join(res, how=<span class="string">&#x27;right&#x27;</span>, lsuffix=<span class="string">&#x27;_left&#x27;</span>, rsuffix=<span class="string">&#x27;_right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result_right)</span><br><span class="line"></span><br><span class="line">result_outer = row.join(res, how=<span class="string">&#x27;outer&#x27;</span>, lsuffix=<span class="string">&#x27;_left&#x27;</span>, rsuffix=<span class="string">&#x27;_right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result_outer)</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>lsuffix=&#39;_left&#39;</code>会给左侧DataFrame的重叠列名添加后缀<code>_left</code>，<code>rsuffix=&#39;_right&#39;</code>会给右侧DataFrame的重叠列名添加后缀<code>_right</code>。这样，即便原始列名相同，通过添加的后缀也能将它们区分开来，从而避免了错误。</p><p>如果目标是基于某些列值而不是索引来合并DataFrame，可能<code>merge()</code>方法更适合需求，因为它提供了更灵活的列合并选项。</p>    </div>  </div><h5 id="左连接（Left-Join）"><a href="#左连接（Left-Join）" class="headerlink" title="左连接（Left Join）"></a>左连接（Left Join）</h5><p>左连接会保留左侧DataFrame的所有行，即使在右侧DataFrame中没有匹配的索引。如果右侧DataFrame中存在匹配的索引，则相应的列会被添加到结果中。如果不存在，则结果中这些列的值会设置为NaN。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左连接</span></span><br><span class="line">result_left = row.join(res, how=<span class="string">&#x27;left&#x27;</span>, lsuffix=<span class="string">&#x27;_left&#x27;</span>, rsuffix=<span class="string">&#x27;_right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result_left)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   ListingId_left  借款金额_left  借款期限_left  借款利率_left 借款成功日期_left 初始评级_left  \</span><br><span class="line">0         2526671       5115         12       12.0   2015/5/23        AA   </span><br><span class="line">1         2707322       5000          3       10.0    2015/6/5        AA   </span><br><span class="line">2         2722356       3132         12       20.0   2015/6/13         D   </span><br><span class="line">3         2828736       3000         12       12.0   2015/6/19        AA   </span><br><span class="line">4         2850335      17640         18       16.0   2015/6/18         B   </span><br><span class="line">5         3155520       7008         10       11.0   2015/7/12        AA   </span><br><span class="line">6         3207478      19928         12       16.0   2015/7/14         B   </span><br><span class="line">7         3617672       7000         12       11.5   2015/8/12        AA   </span><br><span class="line">8         3637812       4000          6       10.5   2015/8/17        AA   </span><br><span class="line">9         3705094       1000         12       11.5   2015/8/21        AA   </span><br><span class="line"></span><br><span class="line">  借款类型_left 是否首标_left  年龄_left 性别_left  ListingId_right  借款金额_right  \</span><br><span class="line">0        普通         否       34       男          1693100        3629   </span><br><span class="line">1        普通         否       35       男          1713229        3000   </span><br><span class="line">2        普通         否       30       男          1904026        3629   </span><br><span class="line">3        普通         是       24       男          2158281        3919   </span><br><span class="line">4        其他         是       28       男          2257194       14000   </span><br><span class="line">5        普通         否       34       男          2272036       40000   </span><br><span class="line">6        其他         是       22       男          2315058        3200   </span><br><span class="line">7        普通         是       43       男          2332817        3000   </span><br><span class="line">8        其他         是       24       男          2365175        4260   </span><br><span class="line">9        普通         是       26       男          2370723       11987   </span><br><span class="line"></span><br><span class="line">   借款期限_right  借款利率_right 借款成功日期_right 初始评级_right 借款类型_right 是否首标_right  \</span><br><span class="line">0           6          12    2015/1/28         AA         普通          否   </span><br><span class="line">1          12          12    2015/1/30         AA         普通          是   </span><br><span class="line">2          12          12     2015/3/7         AA         普通          否   </span><br><span class="line">3          12          18    2015/4/14          C         普通          否   </span><br><span class="line">4          12          18    2015/4/23          C         普通          否   </span><br><span class="line">5           6          15    2015/4/29          B         电商          是   </span><br><span class="line">6           3          10    2015/4/29         AA         普通          否   </span><br><span class="line">7           6          12     2015/5/6         AA         普通          是   </span><br><span class="line">8           7          12     2015/5/6         AA         普通          否   </span><br><span class="line">9          12          16     2015/5/7          B         其他          否   </span><br><span class="line"></span><br><span class="line">   年龄_right 性别_right  </span><br><span class="line">0        31        男  </span><br><span class="line">1        24        男  </span><br><span class="line">2        27        男  </span><br><span class="line">3        28        男  </span><br><span class="line">4        46        男  </span><br><span class="line">5        32        男  </span><br><span class="line">6        25        男  </span><br><span class="line">7        38        男  </span><br><span class="line">8        25        男  </span><br><span class="line">9        33        女  </span><br></pre></td></tr></table></figure></div><h5 id="右连接（Right-Join）"><a href="#右连接（Right-Join）" class="headerlink" title="右连接（Right Join）"></a>右连接（Right Join）</h5><p>右连接与左连接相反，它会保留右侧DataFrame的所有行，即使在左侧DataFrame中没有匹配的索引。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 右连接</span></span><br><span class="line">result_right = row.join(res, how=<span class="string">&#x27;right&#x27;</span>, lsuffix=<span class="string">&#x27;_left&#x27;</span>, rsuffix=<span class="string">&#x27;_right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result_right)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   ListingId_left  借款金额_left  借款期限_left  借款利率_left 借款成功日期_left 初始评级_left  \</span><br><span class="line">0         2526671       5115         12       12.0   2015/5/23        AA   </span><br><span class="line">1         2707322       5000          3       10.0    2015/6/5        AA   </span><br><span class="line">2         2722356       3132         12       20.0   2015/6/13         D   </span><br><span class="line">3         2828736       3000         12       12.0   2015/6/19        AA   </span><br><span class="line">4         2850335      17640         18       16.0   2015/6/18         B   </span><br><span class="line">5         3155520       7008         10       11.0   2015/7/12        AA   </span><br><span class="line">6         3207478      19928         12       16.0   2015/7/14         B   </span><br><span class="line">7         3617672       7000         12       11.5   2015/8/12        AA   </span><br><span class="line">8         3637812       4000          6       10.5   2015/8/17        AA   </span><br><span class="line">9         3705094       1000         12       11.5   2015/8/21        AA   </span><br><span class="line"></span><br><span class="line">  借款类型_left 是否首标_left  年龄_left 性别_left  ListingId_right  借款金额_right  \</span><br><span class="line">0        普通         否       34       男          1693100        3629   </span><br><span class="line">1        普通         否       35       男          1713229        3000   </span><br><span class="line">2        普通         否       30       男          1904026        3629   </span><br><span class="line">3        普通         是       24       男          2158281        3919   </span><br><span class="line">4        其他         是       28       男          2257194       14000   </span><br><span class="line">5        普通         否       34       男          2272036       40000   </span><br><span class="line">6        其他         是       22       男          2315058        3200   </span><br><span class="line">7        普通         是       43       男          2332817        3000   </span><br><span class="line">8        其他         是       24       男          2365175        4260   </span><br><span class="line">9        普通         是       26       男          2370723       11987   </span><br><span class="line"></span><br><span class="line">   借款期限_right  借款利率_right 借款成功日期_right 初始评级_right 借款类型_right 是否首标_right  \</span><br><span class="line">0           6          12    2015/1/28         AA         普通          否   </span><br><span class="line">1          12          12    2015/1/30         AA         普通          是   </span><br><span class="line">2          12          12     2015/3/7         AA         普通          否   </span><br><span class="line">3          12          18    2015/4/14          C         普通          否   </span><br><span class="line">4          12          18    2015/4/23          C         普通          否   </span><br><span class="line">5           6          15    2015/4/29          B         电商          是   </span><br><span class="line">6           3          10    2015/4/29         AA         普通          否   </span><br><span class="line">7           6          12     2015/5/6         AA         普通          是   </span><br><span class="line">8           7          12     2015/5/6         AA         普通          否   </span><br><span class="line">9          12          16     2015/5/7          B         其他          否   </span><br><span class="line"></span><br><span class="line">   年龄_right 性别_right  </span><br><span class="line">0        31        男  </span><br><span class="line">1        24        男  </span><br><span class="line">2        27        男  </span><br><span class="line">3        28        男  </span><br><span class="line">4        46        男  </span><br><span class="line">5        32        男  </span><br><span class="line">6        25        男  </span><br><span class="line">7        38        男  </span><br><span class="line">8        25        男  </span><br><span class="line">9        33        女  </span><br></pre></td></tr></table></figure></div><h5 id="外连接（Outer-Join）"><a href="#外连接（Outer-Join）" class="headerlink" title="外连接（Outer Join）"></a>外连接（Outer Join）</h5><p>外连接会保留左右两侧DataFrame中的所有行。如果某些行在另一侧没有匹配的索引，则结果DataFrame中这些行的相应列会被设置为NaN。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外连接</span></span><br><span class="line">result_outer = row.join(res, how=<span class="string">&#x27;outer&#x27;</span>, lsuffix=<span class="string">&#x27;_left&#x27;</span>, rsuffix=<span class="string">&#x27;_right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result_outer)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   ListingId_left  借款金额_left  借款期限_left  借款利率_left 借款成功日期_left 初始评级_left  \</span><br><span class="line">0         2526671       5115         12       12.0   2015/5/23        AA   </span><br><span class="line">1         2707322       5000          3       10.0    2015/6/5        AA   </span><br><span class="line">2         2722356       3132         12       20.0   2015/6/13         D   </span><br><span class="line">3         2828736       3000         12       12.0   2015/6/19        AA   </span><br><span class="line">4         2850335      17640         18       16.0   2015/6/18         B   </span><br><span class="line">5         3155520       7008         10       11.0   2015/7/12        AA   </span><br><span class="line">6         3207478      19928         12       16.0   2015/7/14         B   </span><br><span class="line">7         3617672       7000         12       11.5   2015/8/12        AA   </span><br><span class="line">8         3637812       4000          6       10.5   2015/8/17        AA   </span><br><span class="line">9         3705094       1000         12       11.5   2015/8/21        AA   </span><br><span class="line"></span><br><span class="line">  借款类型_left 是否首标_left  年龄_left 性别_left  ListingId_right  借款金额_right  \</span><br><span class="line">0        普通         否       34       男          1693100        3629   </span><br><span class="line">1        普通         否       35       男          1713229        3000   </span><br><span class="line">2        普通         否       30       男          1904026        3629   </span><br><span class="line">3        普通         是       24       男          2158281        3919   </span><br><span class="line">4        其他         是       28       男          2257194       14000   </span><br><span class="line">5        普通         否       34       男          2272036       40000   </span><br><span class="line">6        其他         是       22       男          2315058        3200   </span><br><span class="line">7        普通         是       43       男          2332817        3000   </span><br><span class="line">8        其他         是       24       男          2365175        4260   </span><br><span class="line">9        普通         是       26       男          2370723       11987   </span><br><span class="line"></span><br><span class="line">   借款期限_right  借款利率_right 借款成功日期_right 初始评级_right 借款类型_right 是否首标_right  \</span><br><span class="line">0           6          12    2015/1/28         AA         普通          否   </span><br><span class="line">1          12          12    2015/1/30         AA         普通          是   </span><br><span class="line">2          12          12     2015/3/7         AA         普通          否   </span><br><span class="line">3          12          18    2015/4/14          C         普通          否   </span><br><span class="line">4          12          18    2015/4/23          C         普通          否   </span><br><span class="line">5           6          15    2015/4/29          B         电商          是   </span><br><span class="line">6           3          10    2015/4/29         AA         普通          否   </span><br><span class="line">7           6          12     2015/5/6         AA         普通          是   </span><br><span class="line">8           7          12     2015/5/6         AA         普通          否   </span><br><span class="line">9          12          16     2015/5/7          B         其他          否   </span><br><span class="line"></span><br><span class="line">   年龄_right 性别_right  </span><br><span class="line">0        31        男  </span><br><span class="line">1        24        男  </span><br><span class="line">2        27        男  </span><br><span class="line">3        28        男  </span><br><span class="line">4        46        男  </span><br><span class="line">5        32        男  </span><br><span class="line">6        25        男  </span><br><span class="line">7        38        男  </span><br><span class="line">8        25        男  </span><br><span class="line">9        33        女  </span><br></pre></td></tr></table></figure></div><h5 id="内连接（Inner-Join）"><a href="#内连接（Inner-Join）" class="headerlink" title="内连接（Inner Join）"></a>内连接（Inner Join）</h5><p>内连接只保留两个DataFrame中都有匹配的行。如果某行在另一侧没有匹配的索引，则这行不会出现在结果DataFrame中。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内连接通常使用merge()而不是join(), 因为join()默认基于索引连接</span></span><br><span class="line"><span class="comment"># result_inner = row.join(res, how=&#x27;inner&#x27;) # 不适用</span></span><br></pre></td></tr></table></figure></div><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>在的例子中，使用<code>join()</code>可能不会直接给出期望的结果，因为<code>join()</code>默认是按索引进行合并的。如果DataFrame没有设置索引或者两个DataFrame的索引并不完全匹配，那么合并的结果可能不会是期望的。在这种情况下，使用<code>merge()</code>函数可能更为合适，因为它允许指定合并的列。</p><p>不过，如果仍想使用<code>join()</code>并基于列进行合并，可能需要先将某个列设置为索引，然后再进行连接操作。这里给出的代码示例直接使用<code>join()</code>，假设已经有了适当的索引设置。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设df和res是要合并的DataFrame</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./LCIS.csv&#x27;</span>, nrows=<span class="number">5</span>, usecols=<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">6</span>))</span><br><span class="line">res = pd.DataFrame(df)</span><br><span class="line"><span class="comment"># 尝试使用右连接和外连接，展示效果</span></span><br><span class="line"><span class="built_in">print</span>(row.join(res, how=<span class="string">&#x27;right&#x27;</span>, lsuffix=<span class="string">&#x27;_left&#x27;</span>, rsuffix=<span class="string">&#x27;_right&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(row.join(res, how=<span class="string">&#x27;outer&#x27;</span>, lsuffix=<span class="string">&#x27;_left&#x27;</span>, rsuffix=<span class="string">&#x27;_right&#x27;</span>))</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   ListingId   借款金额  借款期限  借款利率_left 借款成功日期_left 初始评级_left 借款类型 是否首标  年龄 性别  \</span><br><span class="line">0    2526671   5115    12       12.0   2015/5/23        AA   普通    否  34  男   </span><br><span class="line">1    2707322   5000     3       10.0    2015/6/5        AA   普通    否  35  男   </span><br><span class="line">2    2722356   3132    12       20.0   2015/6/13         D   普通    否  30  男   </span><br><span class="line">3    2828736   3000    12       12.0   2015/6/19        AA   普通    是  24  男   </span><br><span class="line">4    2850335  17640    18       16.0   2015/6/18         B   其他    是  28  男   </span><br><span class="line"></span><br><span class="line">   借款利率_right 借款成功日期_right 初始评级_right  </span><br><span class="line">0          12    2015/1/28         AA  </span><br><span class="line">1          12    2015/1/30         AA  </span><br><span class="line">2          12     2015/3/7         AA  </span><br><span class="line">3          18    2015/4/14          C  </span><br><span class="line">4          18    2015/4/23          C  </span><br><span class="line">   ListingId   借款金额  借款期限  借款利率_left 借款成功日期_left 初始评级_left 借款类型 是否首标  年龄 性别  \</span><br><span class="line">0    2526671   5115    12       12.0   2015/5/23        AA   普通    否  34  男   </span><br><span class="line">1    2707322   5000     3       10.0    2015/6/5        AA   普通    否  35  男   </span><br><span class="line">2    2722356   3132    12       20.0   2015/6/13         D   普通    否  30  男   </span><br><span class="line">3    2828736   3000    12       12.0   2015/6/19        AA   普通    是  24  男   </span><br><span class="line">4    2850335  17640    18       16.0   2015/6/18         B   其他    是  28  男   </span><br><span class="line">5    3155520   7008    10       11.0   2015/7/12        AA   普通    否  34  男   </span><br><span class="line">6    3207478  19928    12       16.0   2015/7/14         B   其他    是  22  男   </span><br><span class="line">7    3617672   7000    12       11.5   2015/8/12        AA   普通    是  43  男   </span><br><span class="line">8    3637812   4000     6       10.5   2015/8/17        AA   其他    是  24  男   </span><br><span class="line">9    3705094   1000    12       11.5   2015/8/21        AA   普通    是  26  男   </span><br><span class="line"></span><br><span class="line">   借款利率_right 借款成功日期_right 初始评级_right  </span><br><span class="line">0        12.0    2015/1/28         AA  </span><br><span class="line">1        12.0    2015/1/30         AA  </span><br><span class="line">2        12.0     2015/3/7         AA  </span><br><span class="line">3        18.0    2015/4/14          C  </span><br><span class="line">4        18.0    2015/4/23          C  </span><br><span class="line">5         NaN          NaN        NaN  </span><br><span class="line">6         NaN          NaN        NaN  </span><br><span class="line">7         NaN          NaN        NaN  </span><br><span class="line">8         NaN          NaN        NaN  </span><br><span class="line">9         NaN          NaN        NaN  </span><br></pre></td></tr></table></figure></div><p>如果DataFrame没有公共列作为索引，可能需要先使用<code>.set_index()</code>方法来设置索引。</p><h4 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h4><p>当处理数据集时，删除不需要的列或行是常见的数据清理步骤。在Pandas中，可以通过<code>del</code>语句或<code>DataFrame.drop</code>方法来实现。下面是如何使用这两种方法来删除数据的详细说明和示例：</p><h5 id="使用del语句删除列"><a href="#使用del语句删除列" class="headerlink" title="使用del语句删除列"></a>使用<code>del</code>语句删除列</h5><p><code>del</code>语句是Python的一个内置功能，它可以从DataFrame中直接删除指定的列。使用<code>del</code>语句时，更改是立即生效的，并且直接在原DataFrame上进行，不返回新的DataFrame。</p><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> row[<span class="string">&#x27;ListingId&#x27;</span>]</span><br></pre></td></tr></table></figure></div><p>这行代码会从<code>row</code> DataFrame中删除名为<code>&#39;ListingId&#39;</code>的列。</p><h5 id="使用drop方法删除数据"><a href="#使用drop方法删除数据" class="headerlink" title="使用drop方法删除数据"></a>使用<code>drop</code>方法删除数据</h5><p><code>drop</code>方法在Pandas中更加灵活，可以用于删除行或列，且可以控制是直接在原DataFrame上进行修改还是返回一个新的DataFrame。</p><h6 id="删除行："><a href="#删除行：" class="headerlink" title="删除行："></a>删除行：</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(row.drop(<span class="number">0</span>))  <span class="comment"># 删除索引为0的行，不修改原DataFrame，除非指定inplace=True</span></span><br><span class="line"><span class="built_in">print</span>(row.drop([<span class="number">1</span>, <span class="number">2</span>], inplace=<span class="literal">False</span>))  <span class="comment"># 删除索引为1和2的行，不修改原DataFrame</span></span><br></pre></td></tr></table></figure></div><h6 id="删除列："><a href="#删除列：" class="headerlink" title="删除列："></a>删除列：</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(row.drop([<span class="string">&#x27;ListingId&#x27;</span>], axis=<span class="number">1</span>))  <span class="comment"># 删除名为&#x27;ListingId&#x27;的列，不修改原DataFrame，除非指定inplace=True</span></span><br></pre></td></tr></table></figure></div><p>在使用<code>drop</code>方法时，重要的参数包括：</p><ul><li><code>labels</code>: 指定要删除的行标签或列名称。</li><li><code>axis</code>: 通过设置<code>0</code>或<code>1</code>指定删除行或列。<code>0</code>代表行，<code>1</code>代表列。</li><li><code>inplace</code>: 通过设置<code>True</code>或<code>False</code>指定是否在原地修改DataFrame。<code>True</code>表示在原DataFrame上修改，<code>False</code>（默认值）表示返回一个新的DataFrame，原DataFrame不变。</li></ul><h2 id="Pandas数据清洗"><a href="#Pandas数据清洗" class="headerlink" title="Pandas数据清洗"></a>Pandas数据清洗</h2><p>在数据分析过程中，经常会遇到包含重复行的数据集，这可能会对分析结果产生不利影响。Pandas提供了方便的工具来帮助识别和删除这些重复的数据。下面是如何在Pandas中清洗重复数据的详细说明和示例：</p><h3 id="清洗重复数据"><a href="#清洗重复数据" class="headerlink" title="清洗重复数据"></a>清洗重复数据</h3><h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><p>首先，我们通过读取一个CSV文件来创建一个DataFrame，作为处理重复数据的示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取50行数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./LCIS.csv&#x27;</span>, nrows=<span class="number">50</span>)</span><br><span class="line">row = pd.DataFrame(df)</span><br></pre></td></tr></table></figure></div><h4 id="检查重复行"><a href="#检查重复行" class="headerlink" title="检查重复行"></a>检查重复行</h4><p>使用<code>DataFrame.duplicated()</code>方法可以检查DataFrame中的重复行。此方法返回一个布尔系列，其中<code>True</code>表示对应的行是重复的，而<code>False</code>表示行是唯一的。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(row.duplicated())</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">0     False</span><br><span class="line">1     False</span><br><span class="line">2     False</span><br><span class="line">3     False</span><br><span class="line">4     False</span><br><span class="line">5     False</span><br><span class="line">6     False</span><br><span class="line">7     False</span><br><span class="line">8     False</span><br><span class="line">9     False</span><br><span class="line">10    False</span><br><span class="line">11    False</span><br><span class="line">12    False</span><br><span class="line">13    False</span><br><span class="line">14    False</span><br><span class="line">15    False</span><br><span class="line">16    False</span><br><span class="line">17    False</span><br><span class="line">18    False</span><br><span class="line">19    False</span><br><span class="line">20    False</span><br><span class="line">21    False</span><br><span class="line">22    False</span><br><span class="line">23    False</span><br><span class="line">24    False</span><br><span class="line">25    False</span><br><span class="line">26    False</span><br><span class="line">27    False</span><br><span class="line">28    False</span><br><span class="line">29    False</span><br><span class="line">30    False</span><br><span class="line">31    False</span><br><span class="line">32    False</span><br><span class="line">33    False</span><br><span class="line">34    False</span><br><span class="line">35    False</span><br><span class="line">36    False</span><br><span class="line">37    False</span><br><span class="line">38    False</span><br><span class="line">39    False</span><br><span class="line">40    False</span><br><span class="line">41    False</span><br><span class="line">42    False</span><br><span class="line">43    False</span><br><span class="line">44    False</span><br><span class="line">45    False</span><br><span class="line">46    False</span><br><span class="line">47    False</span><br><span class="line">48    False</span><br><span class="line">49    False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure></div><p>此外，还可以通过对一个简单的DataFrame进行操作来理解重复值的检查：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">        <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计重复行的个数</span></span><br><span class="line">df_count = df.duplicated().<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(df_count)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></div><h4 id="删除重复行"><a href="#删除重复行" class="headerlink" title="删除重复行"></a>删除重复行</h4><p>使用<code>DataFrame.drop_duplicates()</code>方法可以删除DataFrame中的重复行。如果设置<code>inplace=True</code>，则会在原地修改DataFrame，而不是返回一个新的DataFrame。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除重复行，并在原地修改DataFrame</span></span><br><span class="line">row.drop_duplicates(inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(row)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================================&quot;</span>)</span><br><span class="line"><span class="comment"># 对于之前创建的简单DataFrame，也删除重复行</span></span><br><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">    ListingId   借款金额  借款期限  借款利率     借款成功日期 初始评级   借款类型 是否首标  年龄 性别  ...  \</span><br><span class="line">0     1693100   3629     6  12.0  2015/1/28   AA     普通    否  31  男  ...   </span><br><span class="line">1     1713229   3000    12  12.0  2015/1/30   AA     普通    是  24  男  ...   </span><br><span class="line">2     1904026   3629    12  12.0   2015/3/7   AA     普通    否  27  男  ...   </span><br><span class="line">3     2158281   3919    12  18.0  2015/4/14    C     普通    否  28  男  ...   </span><br><span class="line">4     2257194  14000    12  18.0  2015/4/23    C     普通    否  46  男  ...   </span><br><span class="line">5     2272036  40000     6  15.0  2015/4/29    B     电商    是  32  男  ...   </span><br><span class="line">6     2315058   3200     3  10.0  2015/4/29   AA     普通    否  25  男  ...   </span><br><span class="line">7     2332817   3000     6  12.0   2015/5/6   AA     普通    是  38  男  ...   </span><br><span class="line">8     2365175   4260     7  12.0   2015/5/6   AA     普通    否  25  男  ...   </span><br><span class="line">9     2370723  11987    12  16.0   2015/5/7    B     其他    否  33  女  ...   </span><br><span class="line">10    2526671   5115    12  12.0  2015/5/23   AA     普通    否  34  男  ...   </span><br><span class="line">11    2707322   5000     3  10.0   2015/6/5   AA     普通    否  35  男  ...   </span><br><span class="line">12    2722356   3132    12  20.0  2015/6/13    D     普通    否  30  男  ...   </span><br><span class="line">13    2828736   3000    12  12.0  2015/6/19   AA     普通    是  24  男  ...   </span><br><span class="line">14    2850335  17640    18  16.0  2015/6/18    B     其他    是  28  男  ...   </span><br><span class="line">15    3155520   7008    10  11.0  2015/7/12   AA     普通    否  34  男  ...   </span><br><span class="line">16    3207478  19928    12  16.0  2015/7/14    B     其他    是  22  男  ...   </span><br><span class="line">17    3617672   7000    12  11.5  2015/8/12   AA     普通    是  43  男  ...   </span><br><span class="line">18    3637812   4000     6  10.5  2015/8/17   AA     其他    是  24  男  ...   </span><br><span class="line">19    3705094   1000    12  11.5  2015/8/21   AA     普通    是  26  男  ...   </span><br><span class="line">20    3846919   5719     6  18.0  2015/8/26    C     普通    否  34  男  ...   </span><br><span class="line">21    7285364   8000    12  20.0   2016/1/6    C     普通    否  26  男  ...   </span><br><span class="line">22    7447346   4650    12  22.0   2016/1/9    C     普通    否  29  男  ...   </span><br><span class="line">23    7760072   9000    12  20.0  2016/1/21    C     其他    是  37  男  ...   </span><br><span class="line">24    7777242   9000    12  20.0  2016/1/21    C     普通    是  29  女  ...   </span><br><span class="line">25    7966976   8500    12  20.0  2016/1/24    C     普通    否  43  男  ...   </span><br><span class="line">26    8148541  13500    12  20.0  2016/1/28    C     普通    否  32  女  ...   </span><br><span class="line">27    8260540   6500    12  20.0  2016/1/30    C     普通    否  26  男  ...   </span><br><span class="line">28    8297477   6500    12  22.0  2016/1/31    C     普通    否  35  男  ...   </span><br><span class="line">29    8359807   8000    12  18.0   2016/2/3    B     普通    是  27  男  ...   </span><br><span class="line">30    8377465  11500    12  20.0   2016/2/2    C     普通    否  46  男  ...   </span><br><span class="line">31    8883343  25000    12  20.0  2016/2/23    C     普通    否  27  男  ...   </span><br><span class="line">32    8978256   8000    12  18.0  2016/2/25    B  APP闪电    是  23  男  ...   </span><br><span class="line">33    8987694   5000     6  20.0  2016/2/26    C     普通    否  42  男  ...   </span><br><span class="line">34    9045950   4000     6  18.0  2016/2/28    B  APP闪电    是  21  男  ...   </span><br><span class="line">35    9182372   8000    12  18.0   2016/3/2    B  APP闪电    是  46  男  ...   </span><br><span class="line">36    9482974   3300     6  20.0  2016/3/11    C     普通    否  36  女  ...   </span><br><span class="line">37    9581580   7000    12  18.0  2016/3/12    B  APP闪电    是  23  女  ...   </span><br><span class="line">38    9597362   1000     6  10.0  2016/3/17   AA     普通    是  23  男  ...   </span><br><span class="line">39    9601032   3000    12  18.0  2016/3/13    B  APP闪电    是  25  女  ...   </span><br><span class="line">40    9602590   1200    12  12.0  2016/3/13   AA  APP闪电    是  24  男  ...   </span><br><span class="line">41    9809712   4000    12  16.0  2016/3/20    A  APP闪电    是  21  女  ...   </span><br><span class="line">42    9993691   3000    12  18.0  2016/3/26    B  APP闪电    是  26  男  ...   </span><br><span class="line">43   10240655   2725    12  18.0   2016/4/4    B     普通    否  32  男  ...   </span><br><span class="line">44   10259916   1500    12  20.0  2016/3/29    C  APP闪电    是  22  女  ...   </span><br><span class="line">45   10410378   4497     6  18.0   2016/4/1    B     其他    否  31  女  ...   </span><br><span class="line">46   10604020   2055     6  18.0   2016/4/6    B     普通    否  25  男  ...   </span><br><span class="line">47   10646264   2000    12  12.0   2016/4/7   AA  APP闪电    是  25  女  ...   </span><br><span class="line">48   10829990   5782    12  20.0  2016/4/12    C     其他    否  32  男  ...   </span><br><span class="line">49   11055233   4139    12  22.0  2016/4/17    C     普通    否  36  男  ...   </span><br><span class="line"></span><br><span class="line">    待还利息 标当前逾期天数  标当前状态      上次还款日期  上次还款本金 上次还款利息    下次计划还款日期  下次计划还款本金  \</span><br><span class="line">0   0.00       0    已还清   2015/7/28   34.20   0.30         NaN       NaN   </span><br><span class="line">1   0.00       0    已还清  2015/10/19  173.39   1.05         NaN       NaN   </span><br><span class="line">2   0.00       0    已还清    2016/3/6   44.04   0.38         NaN       NaN   </span><br><span class="line">3   0.00       0    已还清   2015/5/19   92.34   0.22         NaN       NaN   </span><br><span class="line">4   9.92     589    逾期中         NaN     NaN    NaN   2015/5/23      7.66   </span><br><span class="line">5   0.00       0    已还清  2015/10/27   35.43   0.42         NaN       NaN   </span><br><span class="line">6   0.00       0    已还清   2015/7/17  134.45   1.11         NaN       NaN   </span><br><span class="line">7   0.00       0    已还清   2015/11/6    8.74   0.05         NaN       NaN   </span><br><span class="line">8   0.00       0    已还清    2015/8/5   29.59   0.00         NaN       NaN   </span><br><span class="line">9   0.00       0    已还清   2016/1/22   35.16   0.18         NaN       NaN   </span><br><span class="line">10  0.00       0    已还清   2016/5/22    3.58   0.00         NaN       NaN   </span><br><span class="line">11  0.00       0    已还清    2015/9/5   63.20   0.51         NaN       NaN   </span><br><span class="line">12  0.00       0    已还清   2015/7/20    7.31   0.00         NaN       NaN   </span><br><span class="line">13  0.00       0    已还清   2016/4/21   52.54   0.01         NaN       NaN   </span><br><span class="line">14  0.25       0  正常还款中  2016/12/15    1.14   0.11   2017/1/18      1.16   </span><br><span class="line">15  0.00       0    已还清   2016/5/12   52.11   0.44         NaN       NaN   </span><br><span class="line">16  0.00       0    已还清  2016/12/13   26.74   0.28         NaN       NaN   </span><br><span class="line">17  0.00       0    已还清  2015/10/18   43.94   0.36         NaN       NaN   </span><br><span class="line">18  0.00       0    已还清   2015/9/14  300.00   2.45         NaN       NaN   </span><br><span class="line">19  0.00       0    已还清   2016/8/20   13.22   0.07         NaN       NaN   </span><br><span class="line">20  0.00       0    已还清  2015/11/15   33.84   0.32         NaN       NaN   </span><br><span class="line">21  2.02     179    逾期中    2016/6/6    4.05   0.58    2016/7/6      4.12   </span><br><span class="line">22  0.00       0    已还清  2016/11/25    9.14   0.05         NaN       NaN   </span><br><span class="line">23  0.02       0  正常还款中  2016/12/20    4.48   0.15   2017/1/21      4.61   </span><br><span class="line">24  0.02       0  正常还款中  2016/12/20    4.48   0.15   2017/1/21      4.61   </span><br><span class="line">25  0.02       0  正常还款中  2016/12/24    4.48   0.15   2017/1/24      4.61   </span><br><span class="line">26  0.00       0    已还清   2016/8/26   22.08   0.00         NaN       NaN   </span><br><span class="line">27  0.17       2    逾期中  2016/11/30    4.40   0.23  2016/12/30      4.48   </span><br><span class="line">28  0.04       0  正常还款中  2016/12/31    4.51   0.16   2017/1/31      4.63   </span><br><span class="line">29  0.04       0  正常还款中   2016/12/3    1.40   0.06    2017/1/3      1.42   </span><br><span class="line">30  0.02       0  正常还款中  2016/12/18    4.48   0.15    2017/2/2      4.61   </span><br><span class="line">31  0.00       0    已还清  2016/12/23    4.61   0.02         NaN       NaN   </span><br><span class="line">32  0.14       0  正常还款中  2016/12/30    4.38   0.20   2017/1/25      4.44   </span><br><span class="line">33  0.00       0    已还清   2016/6/29   17.24   0.00         NaN       NaN   </span><br><span class="line">34  0.00       0    已还清   2016/8/23    8.68   0.09         NaN       NaN   </span><br><span class="line">35  0.34       0  正常还款中   2016/12/1    4.31   0.27    2017/1/2      4.38   </span><br><span class="line">36  0.00       0    已还清    2016/9/3    8.71   0.11         NaN       NaN   </span><br><span class="line">37  0.34       0  正常还款中  2016/12/10    4.31   0.27   2017/1/12      4.38   </span><br><span class="line">38  0.00       0    已还清   2016/9/17   85.08   0.70         NaN       NaN   </span><br><span class="line">39  0.34       0  正常还款中  2016/12/11    4.31   0.27   2017/1/13      4.38   </span><br><span class="line">40  2.55       0  正常还款中  2016/12/14   42.68   1.74   2017/1/13     43.11   </span><br><span class="line">41  0.30       0  正常还款中  2016/12/23    4.30   0.23   2017/1/20      4.35   </span><br><span class="line">42  0.00       0    已还清  2016/12/23    4.58   0.00         NaN       NaN   </span><br><span class="line">43  0.14       0  正常还款中  2016/12/28    4.38   0.20    2017/3/4      4.44   </span><br><span class="line">44  0.40       0  正常还款中  2016/12/29    4.33   0.30   2017/1/29      4.40   </span><br><span class="line">45  0.00       0    已还清   2016/8/29    8.68   0.00         NaN       NaN   </span><br><span class="line">46  0.00       0    已还清   2016/8/28   17.19   0.16         NaN       NaN   </span><br><span class="line">47  1.66       0  正常还款中   2016/12/8   16.90   0.86    2017/1/7      0.00   </span><br><span class="line">48  0.81       0  正常还款中  2016/12/10    4.94   0.43   2017/1/12      5.02   </span><br><span class="line">49  0.00       0    已还清  2016/10/24   26.38   0.09         NaN       NaN   </span><br><span class="line"></span><br><span class="line">    下次计划还款利息  recorddate  </span><br><span class="line">0        NaN  2016/12/31  </span><br><span class="line">1        NaN  2016/12/31  </span><br><span class="line">2        NaN  2016/12/31  </span><br><span class="line">3        NaN  2016/12/31  </span><br><span class="line">4       1.50  2016/12/31  </span><br><span class="line">5        NaN  2016/12/31  </span><br><span class="line">6        NaN  2016/12/31  </span><br><span class="line">7        NaN  2016/12/31  </span><br><span class="line">8        NaN  2016/12/31  </span><br><span class="line">9        NaN  2016/12/31  </span><br><span class="line">10       NaN  2016/12/31  </span><br><span class="line">11       NaN  2016/12/31  </span><br><span class="line">12       NaN  2016/12/31  </span><br><span class="line">13       NaN  2016/12/31  </span><br><span class="line">14      0.09  2016/12/31  </span><br><span class="line">15       NaN  2016/12/31  </span><br><span class="line">16       NaN  2016/12/31  </span><br><span class="line">17       NaN  2016/12/31  </span><br><span class="line">18       NaN  2016/12/31  </span><br><span class="line">19       NaN  2016/12/31  </span><br><span class="line">20       NaN  2016/12/31  </span><br><span class="line">21      0.51  2016/12/31  </span><br><span class="line">22       NaN  2016/12/31  </span><br><span class="line">23      0.02  2016/12/31  </span><br><span class="line">24      0.02  2016/12/31  </span><br><span class="line">25      0.02  2016/12/31  </span><br><span class="line">26       NaN  2016/12/31  </span><br><span class="line">27      0.15  2016/12/31  </span><br><span class="line">28      0.04  2016/12/31  </span><br><span class="line">29      0.04  2016/12/31  </span><br><span class="line">30      0.02  2016/12/31  </span><br><span class="line">31       NaN  2016/12/31  </span><br><span class="line">32      0.14  2016/12/31  </span><br><span class="line">33       NaN  2016/12/31  </span><br><span class="line">34       NaN  2016/12/31  </span><br><span class="line">35      0.20  2016/12/31  </span><br><span class="line">36       NaN  2016/12/31  </span><br><span class="line">37      0.20  2016/12/31  </span><br><span class="line">38       NaN  2016/12/31  </span><br><span class="line">39      0.20  2016/12/31  </span><br><span class="line">40      1.31  2016/12/31  </span><br><span class="line">41      0.18  2016/12/31  </span><br><span class="line">42       NaN  2016/12/31  </span><br><span class="line">43      0.14  2016/12/31  </span><br><span class="line">44      0.23  2016/12/31  </span><br><span class="line">45       NaN  2016/12/31  </span><br><span class="line">46       NaN  2016/12/31  </span><br><span class="line">47      0.00  2016/12/31  </span><br><span class="line">48      0.35  2016/12/31  </span><br><span class="line">49       NaN  2016/12/31  </span><br><span class="line"></span><br><span class="line">[50 rows x 37 columns]</span><br><span class="line">=============================================</span><br><span class="line">   A  B</span><br><span class="line">0  1  a</span><br><span class="line">2  2  b</span><br><span class="line">3  3  c</span><br></pre></td></tr></table></figure></div><p>通过这种方式，可以有效地清理数据集中的重复项，确保进行数据分析时数据的准确性和可靠性。在实际的数据处理中，根据数据的具体情况和需求，合理地使用这些方法可以大大提高数据分析的质量和效率。</p><h3 id="清洗空值"><a href="#清洗空值" class="headerlink" title="清洗空值"></a>清洗空值</h3><p>在数据处理和分析中，处理缺失值是一个重要的步骤，因为缺失值可能会影响数据分析的结果。Pandas 提供了多种方法来处理 DataFrame 中的缺失值。下面我们将详细探讨如何统计空值，计算缺失率，删除含有空值的行或列，以及填充空值的不同方法。</p><h4 id="统计空值和计算缺失率"><a href="#统计空值和计算缺失率" class="headerlink" title="统计空值和计算缺失率"></a>统计空值和计算缺失率</h4><h5 id="统计空值数量"><a href="#统计空值数量" class="headerlink" title="统计空值数量"></a>统计空值数量</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./LCIS.csv&#x27;</span>, nrows=<span class="number">50</span>)</span><br><span class="line">row = pd.DataFrame(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各列空值的数量</span></span><br><span class="line">res = row.isnull().<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ListingId      0</span><br><span class="line">借款金额           0</span><br><span class="line">借款期限           0</span><br><span class="line">借款利率           0</span><br><span class="line">借款成功日期         0</span><br><span class="line">初始评级           0</span><br><span class="line">借款类型           0</span><br><span class="line">是否首标           0</span><br><span class="line">年龄             0</span><br><span class="line">性别             0</span><br><span class="line">手机认证           0</span><br><span class="line">户口认证           0</span><br><span class="line">视频认证           0</span><br><span class="line">学历认证           0</span><br><span class="line">征信认证           0</span><br><span class="line">淘宝认证           0</span><br><span class="line">历史成功借款次数       0</span><br><span class="line">历史成功借款金额       0</span><br><span class="line">总待还本金          0</span><br><span class="line">历史正常还款期数       0</span><br><span class="line">历史逾期还款期数       0</span><br><span class="line">我的投资金额         0</span><br><span class="line">当前到期期数         0</span><br><span class="line">当前还款期数         0</span><br><span class="line">已还本金           0</span><br><span class="line">已还利息           0</span><br><span class="line">待还本金           0</span><br><span class="line">待还利息           0</span><br><span class="line">标当前逾期天数        0</span><br><span class="line">标当前状态          0</span><br><span class="line">上次还款日期         1</span><br><span class="line">上次还款本金         1</span><br><span class="line">上次还款利息         1</span><br><span class="line">下次计划还款日期      30</span><br><span class="line">下次计划还款本金      30</span><br><span class="line">下次计划还款利息      30</span><br><span class="line">recorddate     0</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></div><h5 id="计算缺失率"><a href="#计算缺失率" class="headerlink" title="计算缺失率"></a>计算缺失率</h5><ul><li>计算各列的缺失率：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算各列的缺失率，并保留两位小数</span></span><br><span class="line">res = <span class="built_in">round</span>((row.isnull().<span class="built_in">sum</span>() / <span class="built_in">len</span>(row) * <span class="number">100</span>), <span class="number">2</span>)</span><br><span class="line">row = pd.DataFrame(&#123;<span class="string">&#x27;列名&#x27;</span>: res.index, <span class="string">&#x27;缺失值占比&#x27;</span>: res.values&#125;)</span><br><span class="line"><span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">            列名  缺失值占比</span><br><span class="line">0    ListingId    0.0</span><br><span class="line">1         借款金额    0.0</span><br><span class="line">2         借款期限    0.0</span><br><span class="line">3         借款利率    0.0</span><br><span class="line">4       借款成功日期    0.0</span><br><span class="line">5         初始评级    0.0</span><br><span class="line">6         借款类型    0.0</span><br><span class="line">7         是否首标    0.0</span><br><span class="line">8           年龄    0.0</span><br><span class="line">9           性别    0.0</span><br><span class="line">10        手机认证    0.0</span><br><span class="line">11        户口认证    0.0</span><br><span class="line">12        视频认证    0.0</span><br><span class="line">13        学历认证    0.0</span><br><span class="line">14        征信认证    0.0</span><br><span class="line">15        淘宝认证    0.0</span><br><span class="line">16    历史成功借款次数    0.0</span><br><span class="line">17    历史成功借款金额    0.0</span><br><span class="line">18       总待还本金    0.0</span><br><span class="line">19    历史正常还款期数    0.0</span><br><span class="line">20    历史逾期还款期数    0.0</span><br><span class="line">21      我的投资金额    0.0</span><br><span class="line">22      当前到期期数    0.0</span><br><span class="line">23      当前还款期数    0.0</span><br><span class="line">24        已还本金    0.0</span><br><span class="line">25        已还利息    0.0</span><br><span class="line">26        待还本金    0.0</span><br><span class="line">27        待还利息    0.0</span><br><span class="line">28     标当前逾期天数    0.0</span><br><span class="line">29       标当前状态    0.0</span><br><span class="line">30      上次还款日期    2.0</span><br><span class="line">31      上次还款本金    2.0</span><br><span class="line">32      上次还款利息    2.0</span><br><span class="line">33    下次计划还款日期   60.0</span><br><span class="line">34    下次计划还款本金   60.0</span><br><span class="line">35    下次计划还款利息   60.0</span><br><span class="line">36  recorddate    0.0</span><br></pre></td></tr></table></figure></div><ul><li>计算总的缺失率：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设df是已经加载的DataFrame</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./LCIS.csv&#x27;</span>)  <span class="comment"># 示例代码，根据实际路径加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算至少含有一个空值的行数</span></span><br><span class="line">rows_with_na = df.isnull().<span class="built_in">any</span>(axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总缺失率，这里的“总缺失”是指含有至少一个空值的行占总行数的比例</span></span><br><span class="line">total_missing_rate = <span class="built_in">round</span>((rows_with_na / <span class="built_in">len</span>(df) * <span class="number">100</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总缺失率: <span class="subst">&#123;total_missing_rate&#125;</span>%&quot;</span>)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总缺失率: 45.15%</span><br></pre></td></tr></table></figure></div><h4 id="删除含有空值的行或列"><a href="#删除含有空值的行或列" class="headerlink" title="删除含有空值的行或列"></a>删除含有空值的行或列</h4><p>使用 <code>dropna()</code> 方法可以根据不同的需求删除含有空值的行或列。</p><h5 id="DataFrame-dropna-参数说明："><a href="#DataFrame-dropna-参数说明：" class="headerlink" title="DataFrame.dropna 参数说明："></a><code>DataFrame.dropna</code> 参数说明：</h5><ul><li><p><strong><code>axis</code></strong>: 控制删除含有缺失值的行或列。默认值为 <code>0</code>，意味着删除任何含有缺失值的行。如果设置为 <code>1</code>，则删除任何含有缺失值的列。</p></li><li><p><strong><code>how</code></strong>: 定义了行或列被删除的条件。默认为 <code>&#39;any&#39;</code>，表示如果行或列中存在任何缺失值，就将其删除。如果设置为 <code>&#39;all&#39;</code>，则只有当行或列中的所有值都是缺失值时，才删除该行或列。</p></li><li><p><strong><code>thresh</code></strong>: 指定一个行或列中非缺失值的最小数量，只有当非缺失值的数量达到这个阈值时，该行或列才会被保留。</p></li><li><p><strong><code>subset</code></strong>: 用于指定一个列的子集来检查缺失值。这可以是单个列名，或者是多个列名组成的列表。只有在这个子集中检查到缺失值时，相应的行或列才会根据<code>how</code>参数的设置被删除。</p></li><li><p><strong><code>inplace</code></strong>: 用于指定是否在原地修改DataFrame。如果设置为<code>True</code>，则原地修改DataFrame并返回<code>None</code>；如果设置为<code>False</code>（默认），则返回修改后的新DataFrame，原DataFrame不变。</p></li><li><p>删除含有任何空值的行：</p></li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row.dropna(axis=<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><ul><li>删除含有任何空值的列：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row.dropna(axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h4 id="填充空值"><a href="#填充空值" class="headerlink" title="填充空值"></a>填充空值</h4><p>在很多情况下，直接删除含有空值的数据可能会导致信息的大量丢失，特别是在数据量不是很大的情况下。此时，填充空值成为了一种更好的选择。</p><ul><li>使用固定值填充所有空值：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用0填充所有空值</span></span><br><span class="line">row.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><ul><li>针对特定列使用不同的填充值：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以1234填充&#x27;下次计划还款日期&#x27;列的空值</span></span><br><span class="line">row[<span class="string">&#x27;下次计划还款日期&#x27;</span>].fillna(<span class="number">1234</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><ul><li>使用列的统计值（均值、中位数、众数）填充空值：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用均值填充</span></span><br><span class="line">mean_val = row[<span class="string">&#x27;下次计划还款利息&#x27;</span>].mean()</span><br><span class="line">row[<span class="string">&#x27;下次计划还款利息&#x27;</span>].fillna(mean_val, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用中位数填充</span></span><br><span class="line">median_val = row[<span class="string">&#x27;下次计划还款利息&#x27;</span>].median()</span><br><span class="line">row[<span class="string">&#x27;下次计划还款利息&#x27;</span>].fillna(median_val, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用众数填充（注意：众数可能返回多个值）</span></span><br><span class="line">mode_val = row[<span class="string">&#x27;下次计划还款利息&#x27;</span>].mode()[<span class="number">0</span>] <span class="comment"># 选取第一个众数</span></span><br><span class="line">row[<span class="string">&#x27;下次计划还款利息&#x27;</span>].fillna(mode_val, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h3 id="错误数据清洗"><a href="#错误数据清洗" class="headerlink" title="错误数据清洗"></a>错误数据清洗</h3><p>在数据处理和分析中，清洗数据是一项基础而重要的任务，用于修正或删除数据集中的错误或不一致的数据。Pandas 是一个强大的 Python 数据分析库，它提供了多种方法来清洗错误数据。</p><h4 id="替换错误数据"><a href="#替换错误数据" class="headerlink" title="替换错误数据"></a>替换错误数据</h4><h4 id="直接替换特定错误数据"><a href="#直接替换特定错误数据" class="headerlink" title="直接替换特定错误数据"></a>直接替换特定错误数据</h4><p>如果已知特定数据项错误，可以直接替换它。例如，如果我们知道某个人的年龄被错误地录入为12345，而正确的年龄应为30，可以直接修改这个值：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>],</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">12345</span>]  <span class="comment"># 12345 是错误的年龄数据</span></span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接替换错误数据</span></span><br><span class="line">df.loc[<span class="number">2</span>, <span class="string">&#x27;age&#x27;</span>] = <span class="number">30</span>  <span class="comment"># 将年龄12345改为30</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><h4 id="基于条件的批量替换"><a href="#基于条件的批量替换" class="headerlink" title="基于条件的批量替换"></a>基于条件的批量替换</h4><p>在某些情况下，我们可能需要根据条件批量替换数据。例如，将所有大于120岁的年龄替换为120岁：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>],</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: [<span class="number">50</span>, <span class="number">200</span>, <span class="number">12345</span>]    </span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件替换</span></span><br><span class="line">df.loc[df[<span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">120</span>, <span class="string">&#x27;age&#x27;</span>] = <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><h4 id="删除错误数据"><a href="#删除错误数据" class="headerlink" title="删除错误数据"></a>删除错误数据</h4><p>有时，与其修正错误的数据，不如直接将其删除。例如，删除年龄大于120岁的记录：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>],</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">12345</span>]  <span class="comment"># 12345 是错误的年龄数据</span></span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除错误数据</span></span><br><span class="line">df = df[df[<span class="string">&#x27;age&#x27;</span>] &lt;= <span class="number">120</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><h4 id="数据格式错误处理"><a href="#数据格式错误处理" class="headerlink" title="数据格式错误处理"></a>数据格式错误处理</h4><p>假设我们有一个包含日期和持续时间的数据集，但日期的格式不统一，这可能会导致分析时出现问题。以下是如何使用 Pandas 来解决这一问题的示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设数据集中的日期格式不统一，第三个日期格式错误</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;Date&quot;</span>: [<span class="string">&#x27;2020/12/01&#x27;</span>, <span class="string">&#x27;2020/12/02&#x27;</span>, <span class="string">&#x27;20201226&#x27;</span>],  <span class="comment"># 第三个日期格式与其他两个不同</span></span><br><span class="line">    <span class="string">&quot;Duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典创建 DataFrame</span></span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&quot;day1&quot;</span>, <span class="string">&quot;day2&quot;</span>, <span class="string">&quot;day3&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将日期列的格式统一转换为 datetime 格式</span></span><br><span class="line">df[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;Date&#x27;</span>], errors=<span class="string">&#x27;coerce&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;%Y/%m/%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><h5 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h5><ol><li><strong>导入 Pandas 库</strong>：首先，我们需要导入 Pandas 库，这是进行数据分析和数据清洗的基础。</li><li><strong>创建 DataFrame</strong>：我们通过传递一个包含数据的字典（包括不一致的日期格式）来创建一个 <code>DataFrame</code>。这个 <code>DataFrame</code> 包括一个日期列和一个持续时间列。</li><li><strong>转换日期格式</strong>：使用 <code>pd.to_datetime()</code> 方法将日期列转换为统一的 datetime 格式。这个方法非常强大，能够自动识别和转换多种日期格式。如果存在无法识别的格式，<code>errors=&#39;coerce&#39;</code> 参数会将这些无法转换的日期替换为 <code>NaT</code> (时间戳数据的缺失值)。<code>format=&#39;%Y/%m/%d&#39;</code> 参数是尝试按照这种格式解析日期，但不一定所有日期都能完全匹配此格式，故 <code>errors=&#39;coerce&#39;</code> 在这里起着兜底的作用。</li></ol><h5 id="扩展和改进"><a href="#扩展和改进" class="headerlink" title="扩展和改进"></a>扩展和改进</h5><ul><li><strong>处理转换错误</strong>：在转换过程中，如果存在无法识别的日期格式，我们可以通过 <code>errors=&#39;coerce&#39;</code> 参数来处理这些错误，将它们转换为 <code>NaT</code>，然后根据需要进行进一步处理，比如填充缺失值或者删除包含缺失值的行。</li><li><strong>格式化输出</strong>：在完成日期格式的统一后，我们还可以根据需要对日期进行格式化，比如将所有日期转换为特定的字符串格式。</li><li><strong>其他数据清洗任务</strong>：除了解决日期格式问题外，数据清洗可能还包括诸如删除重复值、处理缺失值、数据类型转换等任务。Pandas 提供了丰富的函数和方法来处理这些问题，比如 <code>drop_duplicates()</code>、<code>fillna()</code> 或 <code>replace()</code> 方法。</li></ul><p>数据统计和运算是数据分析的基础，它涉及到对数据集进行概括性描述和数学计算的过程。Pandas 是一个强大的 Python 数据分析库，提供了一系列方便的数据统计和运算工具，帮助我们快速对数据进行处理和分析。以下是一些使用 Pandas 进行数据统计和运算的常用方法及其应用示例。</p><h2 id="数据统计和运算"><a href="#数据统计和运算" class="headerlink" title="数据统计和运算"></a>数据统计和运算</h2><p>数据统计和运算是数据分析的基础，它涉及到对数据集进行概括性描述和数学计算的过程。Pandas 是一个强大的 Python 数据分析库，提供了一系列方便的数据统计和运算工具，帮助我们快速对数据进行处理和分析。以下是一些使用 Pandas 进行数据统计和运算的常用方法及其应用示例。</p><h3 id="最大值和最小值：max-和-min"><a href="#最大值和最小值：max-和-min" class="headerlink" title="最大值和最小值：max() 和 min()"></a>最大值和最小值：<code>max()</code> 和 <code>min()</code></h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;./LCIS.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取&#x27;借款金额&#x27;列的最大值</span></span><br><span class="line">max_value = df[<span class="string">&#x27;借款金额&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取&#x27;借款金额&#x27;列的最小值</span></span><br><span class="line">min_value = df[<span class="string">&#x27;借款金额&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最大借款金额:&quot;</span>, max_value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最小借款金额:&quot;</span>, min_value)</span><br></pre></td></tr></table></figure></div><p>这段代码展示了如何读取一个 CSV 文件，并计算某一列（例如“借款金额”）的最大值和最小值。</p><h3 id="非缺失值的数量：count"><a href="#非缺失值的数量：count" class="headerlink" title="非缺失值的数量：count()"></a>非缺失值的数量：<code>count()</code></h3><p><code>df.count(axis=0, level=None, numeric_only=False)</code> </p><ul><li><code>axis</code>：指定计算的方向，0 表示按列计算，1 表示按行计算，默认为 0。 </li><li><code>level</code>：用于 MultiIndex 的级别，在多层索引 DataFrame 中指定要计算的级别。 </li><li><code>numeric_only</code>：布尔值，表示是否只计算数值型列（int、float）的非缺失值，默认为 False，表示计算所有列的非缺失值数量。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;./LCIS.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每列的非缺失值数量</span></span><br><span class="line">column_non_missing_count = df.count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每行的非缺失值数量</span></span><br><span class="line">row_non_missing_count = df.count(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(column_non_missing_count)</span><br><span class="line"><span class="built_in">print</span>(row_non_missing_count)</span><br></pre></td></tr></table></figure></div><p>此代码展示了如何计算 DataFrame 中每列或每行的非缺失值（非 NaN 值）的数量。可以通过设置 <code>axis</code> 参数为 0（默认）计算每列的非缺失值数量，或设置为 1 计算每行的非缺失值数量。</p><h3 id="求和与累加：sum-和-cumsum"><a href="#求和与累加：sum-和-cumsum" class="headerlink" title="求和与累加：sum() 和 cumsum()"></a>求和与累加：<code>sum()</code> 和 <code>cumsum()</code></h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求和</span></span><br><span class="line">total = df[<span class="string">&#x27;借款金额&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;借款金额总和:&quot;</span>, total)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 累加</span></span><br><span class="line">df[<span class="string">&#x27;累计借款金额&#x27;</span>] = df[<span class="string">&#x27;借款金额&#x27;</span>].cumsum()</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><p>这部分代码用于计算特定列的总和（<code>sum()</code>）和累加值（<code>cumsum()</code>）。<code>cumsum()</code> 方法在原有数据的基础上添加了一个累加列，显示到当前行为止的累计总和。</p><h3 id="排序：sort-values-和-sort-index"><a href="#排序：sort-values-和-sort-index" class="headerlink" title="排序：sort_values() 和 sort_index()"></a>排序：<code>sort_values()</code> 和 <code>sort_index()</code></h3><h4 id="按列值排序"><a href="#按列值排序" class="headerlink" title="按列值排序"></a>按列值排序</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照&#x27;借款金额&#x27;列的值进行升序排序</span></span><br><span class="line">df.sort_values(<span class="string">&#x27;借款金额&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据&#x27;借款金额&#x27;进行升序排序，&#x27;年龄&#x27;进行降序排序</span></span><br><span class="line">df.sort_values([<span class="string">&#x27;借款金额&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>], ascending=[<span class="literal">True</span>, <span class="literal">False</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><p>这些例子展示了如何按照一个或多个列的值对 DataFrame 进行排序。可以通过 <code>ascending</code> 参数控制排序的方向（升序或降序）。</p><h4 id="按索引排序"><a href="#按索引排序" class="headerlink" title="按索引排序"></a>按索引排序</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照索引进行排序</span></span><br><span class="line">df.sort_index(inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><p>如果需要根据行索引进行排序，可以使用 <code>sort_index()</code> 方法。这在重置数据顺序时特别有用。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><strong>计算缺失值</strong>：利用 <code>count()</code> 方法的结果可以间接计算出某列或整个 DataFrame 的缺失值数量。例如，DataFrame 总行数减去 <code>count()</code> 方法返回的非缺失值数量即为缺失值数量。</li><li><strong>设置列名</strong>：当从函数返回一个 Series 或需要更改 DataFrame 的列名时，可以直接通过修改 <code>columns</code> 属性或者在创建 DataFrame 时指定列名。</li><li><strong>读取部分数据</strong>：对于大型数据集，可以使用 <code>pd.read_csv()</code> 函数的 <code>nrows</code> 参数仅读取前 N 行数据，有助于快速测试代码或减少内存消耗。</li></ul><h2 id="数据分组和聚合"><a href="#数据分组和聚合" class="headerlink" title="数据分组和聚合"></a>数据分组和聚合</h2><h3 id="df-groupby-column-name"><a href="#df-groupby-column-name" class="headerlink" title="df.groupby(column_name)"></a>df.groupby(column_name)</h3><p><code>groupby()</code> 方法是用来对数据进行分组的，特别是当你想要按照某个（或某些）列的值对整个数据集进行分组时。分组后，可以对每个分组应用聚合函数，比如求和、平均、最大值和最小值等。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照&#x27;年龄&#x27;列分组，并计算每个年龄组的数量</span></span><br><span class="line">age_group_count = df.groupby(<span class="string">&#x27;年龄&#x27;</span>).count()</span><br><span class="line"><span class="built_in">print</span>(age_group_count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只统计不同年龄组的&#x27;借款金额&#x27;总和</span></span><br><span class="line">age_group_loan_sum = df.groupby(<span class="string">&#x27;年龄&#x27;</span>)[<span class="string">&#x27;借款金额&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(age_group_loan_sum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个年龄组的&#x27;借款金额&#x27;的最大值、最小值和平均值</span></span><br><span class="line">age_group_loan_max = df.groupby(<span class="string">&#x27;年龄&#x27;</span>)[<span class="string">&#x27;借款金额&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">age_group_loan_min = df.groupby(<span class="string">&#x27;年龄&#x27;</span>)[<span class="string">&#x27;借款金额&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">age_group_loan_mean = df.groupby(<span class="string">&#x27;年龄&#x27;</span>)[<span class="string">&#x27;借款金额&#x27;</span>].mean()</span><br><span class="line"><span class="built_in">print</span>(age_group_loan_max)</span><br><span class="line"><span class="built_in">print</span>(age_group_loan_min)</span><br><span class="line"><span class="built_in">print</span>(age_group_loan_mean)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照&#x27;性别&#x27;分组，并计算&#x27;借款金额&#x27;的最大值、最小值和平均值</span></span><br><span class="line">gender_group_loan_max = df.groupby(<span class="string">&#x27;性别&#x27;</span>)[<span class="string">&#x27;借款金额&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">gender_group_loan_min = df.groupby(<span class="string">&#x27;性别&#x27;</span>)[<span class="string">&#x27;借款金额&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">gender_group_loan_mean = df.groupby(<span class="string">&#x27;性别&#x27;</span>)[<span class="string">&#x27;借款金额&#x27;</span>].mean()</span><br><span class="line"><span class="built_in">print</span>(gender_group_loan_max)</span><br><span class="line"><span class="built_in">print</span>(gender_group_loan_min)</span><br><span class="line"><span class="built_in">print</span>(gender_group_loan_mean)</span><br></pre></td></tr></table></figure></div><h3 id="df-aggregate-function-name"><a href="#df-aggregate-function-name" class="headerlink" title="df.aggregate(function_name)"></a>df.aggregate(function_name)</h3><p><code>aggregate()</code> 方法允许你对整个 DataFrame 或某些选定的列应用一个或多个聚合函数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对整个 DataFrame 应用多个聚合函数</span></span><br><span class="line">agg_results = df.aggregate([<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(agg_results) <span class="comment"># 可能会报错，因为字符类型的列不能进行数学计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对指定列应用聚合函数</span></span><br><span class="line">agg_specific = df.aggregate(&#123;<span class="string">&#x27;借款金额&#x27;</span>: <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>: <span class="string">&#x27;mean&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(agg_specific)</span><br></pre></td></tr></table></figure></div><p>如果数据集中包含非数值类型（如字符串），直接应用 <code>sum</code> 或 <code>mean</code> 会导致错误。为了避免这种情况，你应该指定要应用聚合函数的列，或者通过 <code>numeric_only=True</code> 参数来排除非数值列。</p><h3 id="df-pivot-table-values-index-columns-aggfunc"><a href="#df-pivot-table-values-index-columns-aggfunc" class="headerlink" title="df.pivot_table(values, index, columns, aggfunc)"></a>df.pivot_table(values, index, columns, aggfunc)</h3><p><code>pivot_table()</code> 方法是用来创建透视表的，这在你想要对数据进行多维度的分组聚合时特别有用。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建透视表，将&#x27;性别&#x27;作为索引，对&#x27;借款金额&#x27;进行求和</span></span><br><span class="line">gender_loan_pivot_table = df.pivot_table(values=<span class="string">&#x27;借款金额&#x27;</span>, index=<span class="string">&#x27;性别&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gender_loan_pivot_table)</span><br></pre></td></tr></table></figure></div><p>在透视表中，<code>values</code> 参数是你想要聚合的列，<code>index</code> 参数是你想要作为行索引的列，<code>columns</code> 参数（可选）是你想要作为列索引的列，<code>aggfunc</code> 是定义聚合函数的参数。</p><p>这些方法不仅可以帮助你从数据集中提取有意义的统计信息，还可以根据你的特定需求进行高度定制化的数据处理和分析。通过使用这些工具，你可以轻松地对数据进行分组和聚合，从而提取出关键的洞见。</p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><h3 id="数据导入与演示"><a href="#数据导入与演示" class="headerlink" title="数据导入与演示"></a>数据导入与演示</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./LCIS.csv&#x27;</span>)  </span><br><span class="line"><span class="comment"># 显示所有的数据</span></span><br><span class="line"><span class="comment"># pd.set_option(&#x27;display.max_rows&#x27;, None)  # 显示所有行</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="literal">None</span>)  <span class="comment"># 显示所有列</span></span><br><span class="line"><span class="comment"># pd.set_option(&#x27;expand_frame_repr&#x27;, False)  # 不自动换行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><pre><code>        ListingId   借款金额  借款期限  借款利率      借款成功日期 初始评级 借款类型 是否首标  年龄 性别   手机认证  \0         1693100   3629     6  12.0   2015/1/28   AA   普通    否  31  男   成功认证   1         1713229   3000    12  12.0   2015/1/30   AA   普通    是  24  男   成功认证   2         1904026   3629    12  12.0    2015/3/7   AA   普通    否  27  男   成功认证   3         2158281   3919    12  18.0   2015/4/14    C   普通    否  28  男   成功认证   4         2257194  14000    12  18.0   2015/4/23    C   普通    否  46  男   成功认证   ...           ...    ...   ...   ...         ...  ...  ...  ...  .. ..    ...   292534   29087298   7193    12  22.0  2016/12/29    C   普通    否  48  男   成功认证   292535   29995173   3241    12  22.0    2017/1/5    C   其他    否  25  女   成功认证   292536   30355195   3004    12  22.0    2017/1/8    C   其他    否  28  男  未成功认证   292537   30649717   2082    12  22.0   2017/1/11    C   普通    否  52  男   成功认证   292538   31620657  10000    12  22.0   2017/1/20    D   普通    是  24  女  未成功认证            户口认证   视频认证   学历认证   征信认证   淘宝认证  历史成功借款次数  历史成功借款金额     总待还本金  \0       未成功认证  未成功认证  未成功认证  未成功认证  未成功认证       1.0    3000.0   1313.46   1       未成功认证  未成功认证  未成功认证  未成功认证  未成功认证       0.0       0.0      0.00   2       未成功认证  未成功认证  未成功认证  未成功认证  未成功认证       1.0    3000.0    878.58   3        成功认证  未成功认证  未成功认证  未成功认证  未成功认证       4.0   13800.0   6523.11   4       未成功认证  未成功认证  未成功认证  未成功认证  未成功认证      11.0   54840.0  11491.04   ...       ...    ...    ...    ...    ...       ...       ...       ...   292534  未成功认证  未成功认证  未成功认证  未成功认证  未成功认证       1.0    3500.0    306.54   292535  未成功认证  未成功认证   成功认证  未成功认证  未成功认证       1.0    5000.0   1758.28   292536  未成功认证  未成功认证  未成功认证  未成功认证  未成功认证       1.0    2200.0   1495.67   292537  未成功认证  未成功认证  未成功认证  未成功认证  未成功认证       6.0   22064.0   5747.77   292538  未成功认证  未成功认证   成功认证  未成功认证  未成功认证       0.0       0.0      0.00           历史正常还款期数  历史逾期还款期数  我的投资金额  当前到期期数  当前还款期数    已还本金   已还利息    待还本金  \0              2         2     200       6       6  200.00   7.00    0.00   1              0         0     500      12       9  500.00  29.80    0.00   2              5         0     500      12      12  500.00  33.04    0.00   3             25         0     100      12       2  100.00   1.72    0.00   4             53         0     100      12       0    0.00   0.00  100.00   ...          ...       ...     ...     ...     ...     ...    ...     ...   292534        11         0      55       2       2    8.35   1.94   46.65   292535         3         3      50       1       1    3.76   0.91   46.24   292536         4         0      50       1       1    3.76   0.91   46.24   292537        39         6      55       1       1    4.13   1.01   50.87   292538         0         0      73       1       1    5.49   1.34   67.51           待还利息  标当前逾期天数  标当前状态      上次还款日期  上次还款本金  上次还款利息   下次计划还款日期  下次计划还款本金  \0       0.00        0    已还清   2015/7/28   34.20    0.30        NaN       NaN   1       0.00        0    已还清  2015/10/19  173.39    1.05        NaN       NaN   2       0.00        0    已还清    2016/3/6   44.04    0.38        NaN       NaN   3       0.00        0    已还清   2015/5/19   92.34    0.22        NaN       NaN   4       9.92      589    逾期中         NaN     NaN     NaN  2015/5/23      7.66   ...      ...      ...    ...         ...     ...     ...        ...       ...   292534  4.83        0  正常还款中   2017/2/26    4.22    0.93  2017/3/28      4.29   292535  5.24        0  正常还款中    2017/2/9    3.76    0.91   2017/3/5      3.83   292536  5.24        0  正常还款中    2017/2/8    3.76    0.91   2017/3/8      3.83   292537  5.76        0  正常还款中   2017/2/10    4.13    1.01  2017/3/10      4.22   292538  7.64        0  正常还款中   2017/2/20    5.49    1.34  2017/3/20      5.59           下次计划还款利息  recorddate  0            NaN  2016/12/31  1            NaN  2016/12/31  2            NaN  2016/12/31  3            NaN  2016/12/31  4           1.50  2016/12/31  ...          ...         ...  292534      0.86   2017/2/28  292535      0.85   2017/2/28  292536      0.85   2017/2/28  292537      0.93   2017/2/28  292538      1.24   2017/2/28  [292539 rows x 37 columns]</code></pre><h3 id="总缺失率"><a href="#总缺失率" class="headerlink" title="总缺失率"></a>总缺失率</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算至少含有一个空值的行数</span></span><br><span class="line">rows_with_na = df.isnull().<span class="built_in">any</span>(axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总缺失率，这里的“总缺失”是指含有至少一个空值的行占总行数的比例</span></span><br><span class="line">total_missing_rate = <span class="built_in">round</span>((rows_with_na / <span class="built_in">len</span>(df) * <span class="number">100</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总缺失率: <span class="subst">&#123;total_missing_rate&#125;</span>%&quot;</span>)</span><br></pre></td></tr></table></figure></div><pre><code>总缺失率: 45.15%</code></pre><h3 id="手机认证用户借贷笔数"><a href="#手机认证用户借贷笔数" class="headerlink" title="手机认证用户借贷笔数"></a>手机认证用户借贷笔数</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手机认证借贷笔数 </span></span><br><span class="line">loan_phone = df[df[<span class="string">&#x27;手机认证&#x27;</span>] == <span class="string">&#x27;成功认证&#x27;</span>].shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(loan_phone)</span><br></pre></td></tr></table></figure></div><pre><code>153453</code></pre><h3 id="户门认证用户借贷情况"><a href="#户门认证用户借贷情况" class="headerlink" title="户门认证用户借贷情况"></a>户门认证用户借贷情况</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选户口认证为“成功认证”的用户</span></span><br><span class="line">df_hukou_success = df[df[<span class="string">&#x27;户口认证&#x27;</span>] == <span class="string">&#x27;成功认证&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均借款金额</span></span><br><span class="line">avg_loan_amount_hukou_success = df_hukou_success[<span class="string">&#x27;借款金额&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均借款期限</span></span><br><span class="line">avg_loan_duration_hukou_success = df_hukou_success[<span class="string">&#x27;借款期限&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均借款利率</span></span><br><span class="line">avg_interest_rate_hukou_success = df_hukou_success[<span class="string">&#x27;借款利率&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均年龄</span></span><br><span class="line">avg_age_hukou_success = df_hukou_success[<span class="string">&#x27;年龄&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;户口认证成功的用户平均借款金额: <span class="subst">&#123;avg_loan_amount_hukou_success:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;户口认证成功的用户平均借款期限: <span class="subst">&#123;avg_loan_duration_hukou_success:<span class="number">.2</span>f&#125;</span> 个月&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;户口认证成功的用户平均借款利率: <span class="subst">&#123;avg_interest_rate_hukou_success:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;户口认证成功的用户平均年龄: <span class="subst">&#123;avg_age_hukou_success:<span class="number">.2</span>f&#125;</span> 岁&quot;</span>)</span><br></pre></td></tr></table></figure></div><pre><code>户口认证成功的用户平均借款金额: 36955.01户口认证成功的用户平均借款期限: 10.04 个月户口认证成功的用户平均借款利率: 17.15%户口认证成功的用户平均年龄: 31.42 岁</code></pre><h3 id="征信认证用户借贷情况"><a href="#征信认证用户借贷情况" class="headerlink" title="征信认证用户借贷情况"></a>征信认证用户借贷情况</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选出征信认证为成功认证的行</span></span><br><span class="line">df_credit_approved = df[df[<span class="string">&#x27;征信认证&#x27;</span>] == <span class="string">&#x27;成功认证&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均借款金额</span></span><br><span class="line">avg_loan_amount_credit_approved = df_credit_approved[<span class="string">&#x27;借款金额&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均借款期限</span></span><br><span class="line">avg_loan_duration_credit_approved = df_credit_approved[<span class="string">&#x27;借款期限&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均借款利率</span></span><br><span class="line">avg_interest_rate_credit_approved = df_credit_approved[<span class="string">&#x27;借款利率&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均年龄</span></span><br><span class="line">avg_age_credit_approved = df_credit_approved[<span class="string">&#x27;年龄&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;征信认证成功的用户平均借款金额: <span class="subst">&#123;avg_loan_amount_credit_approved:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;征信认证成功的用户平均借款期限: <span class="subst">&#123;avg_loan_duration_credit_approved:<span class="number">.2</span>f&#125;</span> 个月&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;征信认证成功的用户平均借款利率: <span class="subst">&#123;avg_interest_rate_credit_approved:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;征信认证成功的用户平均年龄: <span class="subst">&#123;avg_age_credit_approved:<span class="number">.2</span>f&#125;</span> 岁&quot;</span>)</span><br></pre></td></tr></table></figure></div><pre><code>征信认证成功的用户平均借款金额: 9138.00征信认证成功的用户平均借款期限: 10.59 个月征信认证成功的用户平均借款利率: 18.27%征信认证成功的用户平均年龄: 29.79 岁</code></pre><h3 id="性别认证用户还款情况"><a href="#性别认证用户还款情况" class="headerlink" title="性别认证用户还款情况"></a>性别认证用户还款情况</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保性别列存在并且不为空</span></span><br><span class="line">df_with_gender = df[df[<span class="string">&#x27;性别&#x27;</span>].notna()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按性别分组，并计算各项指标的平均值</span></span><br><span class="line">repayment_status = df_with_gender.groupby(<span class="string">&#x27;性别&#x27;</span>).agg(&#123;</span><br><span class="line">    <span class="string">&#x27;借款金额&#x27;</span>: <span class="string">&#x27;mean&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;历史成功借款次数&#x27;</span>: <span class="string">&#x27;mean&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;历史逾期还款期数&#x27;</span>: <span class="string">&#x27;mean&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;总待还本金&#x27;</span>: <span class="string">&#x27;mean&#x27;</span></span><br><span class="line">&#125;).reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名列以更清晰地表示它们的内容</span></span><br><span class="line">repayment_status.columns = [<span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;平均借款金额&#x27;</span>, <span class="string">&#x27;平均历史成功借款次数&#x27;</span>, <span class="string">&#x27;平均历史逾期还款期数&#x27;</span>, <span class="string">&#x27;平均待还本金&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(repayment_status)</span><br></pre></td></tr></table></figure></div><pre><code>  性别       平均借款金额  平均历史成功借款次数  平均历史逾期还款期数       平均待还本金0  女  6896.238214    2.651062   17.975806  4706.6314301  男  9385.546621    2.547655   18.575870  4388.516472</code></pre><h3 id="不同性别用户还款占比情况"><a href="#不同性别用户还款占比情况" class="headerlink" title="不同性别用户还款占比情况"></a>不同性别用户还款占比情况</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义正常还款状态</span></span><br><span class="line">normal_repayment_statuses = [<span class="string">&#x27;已还清&#x27;</span>, <span class="string">&#x27;正常还款中&#x27;</span>]</span><br><span class="line"></span><br><span class="line">df_per_gender = df</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新列，用于标记是否正常还款</span></span><br><span class="line">df_per_gender[<span class="string">&#x27;是否正常还款&#x27;</span>] = df_per_gender[<span class="string">&#x27;标当前状态&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="string">&#x27;正常还款&#x27;</span> <span class="keyword">if</span> x <span class="keyword">in</span> normal_repayment_statuses <span class="keyword">else</span> <span class="string">&#x27;未还清&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个性别的还款占比</span></span><br><span class="line">repayment_by_gender = df_per_gender.groupby(<span class="string">&#x27;性别&#x27;</span>)[<span class="string">&#x27;是否正常还款&#x27;</span>].value_counts(normalize=<span class="literal">True</span>).unstack().fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将占比转换为百分比</span></span><br><span class="line">repayment_by_gender_percentage = repayment_by_gender * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(repayment_by_gender_percentage)</span><br></pre></td></tr></table></figure></div><pre><code>是否正常还款       未还清       正常还款性别                         女       3.216114  96.783886男       3.948184  96.051816</code></pre><h3 id="学历认证用户还款情况"><a href="#学历认证用户还款情况" class="headerlink" title="学历认证用户还款情况"></a>学历认证用户还款情况</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df_sty_auth = df[df[<span class="string">&#x27;学历认证&#x27;</span>] == <span class="string">&#x27;成功认证&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析学历认证用户的还款情况</span></span><br><span class="line"><span class="comment"># 计算历史正常还款期数和历史逾期还款期数的平均值</span></span><br><span class="line">avg_normal_re = df_sty_auth[<span class="string">&#x27;历史正常还款期数&#x27;</span>].mean()</span><br><span class="line">avg_dishor_re = df_sty_auth[<span class="string">&#x27;历史逾期还款期数&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算已还本金、已还利息的总和</span></span><br><span class="line">org_done_total = df_sty_auth[<span class="string">&#x27;已还本金&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">fee_done_total = df_sty_auth[<span class="string">&#x27;已还利息&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;学历认证用户平均历史正常还款期数: <span class="subst">&#123;avg_normal_re&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;学历认证用户平均历史逾期还款期数: <span class="subst">&#123;avg_dishor_re&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;学历认证用户总已还本金: <span class="subst">&#123;org_done_total&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;学历认证用户总已还利息: <span class="subst">&#123;fee_done_total&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div><pre><code>学历认证用户平均历史正常还款期数: 78.98516016370341学历认证用户平均历史逾期还款期数: 13.045753352616355学历认证用户总已还本金: 6445238.179999999学历认证用户总已还利息: 499930.52000000014</code></pre><h3 id="学历认证用户还款占比情况"><a href="#学历认证用户还款占比情况" class="headerlink" title="学历认证用户还款占比情况"></a>学历认证用户还款占比情况</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选学历认证成功的用户</span></span><br><span class="line">df_education_certified = df[df[<span class="string">&#x27;学历认证&#x27;</span>] == <span class="string">&#x27;成功认证&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算各状态下的用户数量</span></span><br><span class="line">status_counts = df_education_certified[<span class="string">&#x27;标当前状态&#x27;</span>].value_counts()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总数，用于计算比例</span></span><br><span class="line">total_certified = df_education_certified.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算占比</span></span><br><span class="line">status_proportions = status_counts / total_certified</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(status_proportions)</span><br></pre></td></tr></table></figure></div><pre><code>标当前状态正常还款中    0.692517已还清      0.279435逾期中      0.0270970        0.0006200.7      0.0000402.35     0.0000200.62     0.0000135.76     0.0000131.16     0.0000131.07     0.0000134.73     0.0000071.33     0.0000070.2      0.0000072.82     0.0000070.4      0.0000070.34     0.0000072.95     0.0000073.15     0.0000072.6      0.0000072.66     0.0000075.5      0.0000072.65     0.0000070.11     0.0000075.81     0.0000071.17     0.0000071.74     0.0000070.77     0.0000074.92     0.0000072.46     0.0000070.38     0.0000076.47     0.0000071.78     0.0000070.76     0.0000073.42     0.0000070.13     0.0000071.51     0.0000070.73     0.0000070.48     0.0000073.76     0.0000074.83     0.0000070.49     0.0000073.39     0.000007Name: count, dtype: float64</code></pre><h3 id="不同年龄段用户借款统计"><a href="#不同年龄段用户借款统计" class="headerlink" title="不同年龄段用户借款统计"></a>不同年龄段用户借款统计</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义年龄段</span></span><br><span class="line">bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">65</span>, <span class="number">75</span>]</span><br><span class="line">labels = [<span class="string">&#x27;18-24&#x27;</span>, <span class="string">&#x27;25-34&#x27;</span>, <span class="string">&#x27;35-44&#x27;</span>, <span class="string">&#x27;45-54&#x27;</span>, <span class="string">&#x27;55-64&#x27;</span>, <span class="string">&#x27;65-74&#x27;</span>]</span><br><span class="line">age_df = df</span><br><span class="line">age_df[<span class="string">&#x27;年龄段&#x27;</span>] = pd.cut(age_df[<span class="string">&#x27;年龄&#x27;</span>], bins=bins, labels=labels, right=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个年龄段的借款统计</span></span><br><span class="line">age_group_stats = df.groupby(<span class="string">&#x27;年龄段&#x27;</span>).agg(&#123;</span><br><span class="line">    <span class="string">&#x27;借款金额&#x27;</span>: [<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;count&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">age_group_stats.columns = [<span class="string">&#x27;借款金额总和&#x27;</span>, <span class="string">&#x27;平均借款金额&#x27;</span>, <span class="string">&#x27;借款次数&#x27;</span>]</span><br><span class="line">age_group_stats = age_group_stats.reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line"><span class="built_in">print</span>(age_group_stats)</span><br></pre></td></tr></table></figure></div><pre><code>     年龄段      借款金额总和         平均借款金额    借款次数0  18-24   296139563    4755.963239   622671  25-34  1554537910    8642.275290  1798762  35-44   527141564   12732.272934   414023  45-54   106455104   12088.928458    88064  55-64     4524174   24722.262295     1835  65-74     2500000  500000.000000       5</code></pre><h3 id="不同年龄段用户还款占比统计"><a href="#不同年龄段用户还款占比统计" class="headerlink" title="不同年龄段用户还款占比统计"></a>不同年龄段用户还款占比统计</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加年龄段分类</span></span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">24</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">54</span>, <span class="number">100</span>]</span><br><span class="line">labels = [<span class="string">&#x27;&lt;25&#x27;</span>, <span class="string">&#x27;25-34&#x27;</span>, <span class="string">&#x27;35-44&#x27;</span>, <span class="string">&#x27;45-54&#x27;</span>, <span class="string">&#x27;55+&#x27;</span>]</span><br><span class="line">age_per_df = df</span><br><span class="line">age_per_df[<span class="string">&#x27;年龄段&#x27;</span>] = pd.cut(age_per_df[<span class="string">&#x27;年龄&#x27;</span>], bins=bins, labels=labels, right=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个年龄段的已还本金总额</span></span><br><span class="line">repayment_by_age_group = df.groupby(<span class="string">&#x27;年龄段&#x27;</span>)[<span class="string">&#x27;已还本金&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总的已还本金以确定占比</span></span><br><span class="line">total_repayment = df[<span class="string">&#x27;已还本金&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算占比</span></span><br><span class="line">repayment_ratio = (repayment_by_age_group / total_repayment * <span class="number">100</span>).reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置新的列名以改进展示</span></span><br><span class="line">repayment_ratio.columns = [<span class="string">&#x27;年龄段&#x27;</span>, <span class="string">&#x27;已还本金占比（%）&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(repayment_ratio)</span><br></pre></td></tr></table></figure></div><pre><code>     年龄段  已还本金占比（%）0    &lt;25  14.2783371  25-34  62.2344542  35-44  18.7928483  45-54   4.5361814    55+   0.158180</code></pre><h2 id="数据分析常用函数"><a href="#数据分析常用函数" class="headerlink" title="数据分析常用函数"></a>数据分析常用函数</h2><h3 id="数据筛选"><a href="#数据筛选" class="headerlink" title="数据筛选"></a>数据筛选</h3><p>如果是筛选行列的话，通常有以下几种方法：<br>有时我们需要按条件选择部分列、部分行，一般常用的方法有：</p><table><thead><tr><th align="center">操作</th><th align="center">语法</th><th align="center">返回结果</th></tr></thead><tbody><tr><td align="center">选择列</td><td align="center">df[col]</td><td align="center">Series</td></tr><tr><td align="center">按索引选择行</td><td align="center">df.loc[label]</td><td align="center">Series</td></tr><tr><td align="center">按数字索引选择行</td><td align="center">df.iloc[loc]</td><td align="center">Series</td></tr><tr><td align="center">使用切片选择行</td><td align="center">df[:5]</td><td align="center">DataFrame</td></tr><tr><td align="center">用表达式筛选行[3]</td><td align="center">df[bool_vec]</td><td align="center">DataFrame</td></tr></tbody></table><p>除此以外，还有很多方法&#x2F;函数可以用于“数据筛选”</p><h3 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h3><p>对于探索性数据分析来说，做数据分析前需要先看一下数据的总体概况。</p><ul><li><code>info()</code>方法用来查看数据集信息</li><li><code>describe()</code>方法将返回描述性统计信息，这两个函数大家应该都很熟悉了。</li><li><code>describe</code>方法默认只给出数值型变量的常用统计量，要想对DataFrame中的每个变量进行汇总统计，可以将其中的参数<code>include</code>设为<code>all</code>。<code>head()</code>方法显示数据集的前n行</li><li><code>tail()</code> 方法显示数据集的后n行。</li><li><code>sample()</code>方法随机看N行的数据。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sample(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><ul><li><code>df.dtypes</code> 检查数据中各列的数据类型。</li><li><code>df.columns</code> 查看所有的列名 。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.dtypes</span><br><span class="line">df.columns</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index([&#x27;日期&#x27;, &#x27;销量&#x27;], dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure></div><p><code>.dfshape()</code> 获得数据集的大小（长宽）。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.shape</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(5, 2)</span><br></pre></td></tr></table></figure></div><ul><li><code>len(df)</code>可以查看总个数</li><li><code>df.count()</code>则可以查看有效个数，不包含无效值（Nan）</li></ul><h3 id="缺失值与重复值"><a href="#缺失值与重复值" class="headerlink" title="缺失值与重复值"></a>缺失值与重复值</h3><p>Pandas清洗数据时，判断缺失值一般采用<code>isnull()</code>方法。<br><code>isnull().any()</code>会判断哪些”列”存在缺失值。<br><code>isnull().sum()</code>用于将列中为空的个数统计出来。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.isnull().<span class="built_in">any</span>()</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日期 False</span><br><span class="line">销量 True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure></div><p>发现“销量”这列存在缺失值后，处理办法要么删除<code>dropna()</code> ，要么填充<code>fillna()</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(<span class="number">50</span>)</span><br></pre></td></tr></table></figure></div><ul><li>Pandas清洗数据时，判断重复值一般采用<code>duplicated()</code>方法。</li><li>如果想要直接删除重复值，可以使用<code>drop_duplicates()</code> 方法。</li></ul><h3 id="数据值操作"><a href="#数据值操作" class="headerlink" title="数据值操作"></a>数据值操作</h3><p>在数值数据操作中，<code>apply()</code>函数的功能是将一个自定义函数作用于DataFrame的行或者列；<code>applymap()</code>函数的功能是将自定义函数作用于DataFrame的所有元素。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;数量&quot;</span>].apply(<span class="keyword">lambda</span> x: x+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/7d5c4497-e90c-4da1-278e-f54017a56e00/public"                      width = "500"                ><p>数据批量替换的情况，<code>replace()</code>是很好的解决方法。它既支持替换全部或者某一行，也支持替换指定的某个或指定的多个数值（用字典的形式）。还可以使用正则表达式替换。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;编号&quot;</span>].replace(<span class="string">r&#x27;BA.$&#x27;</span>, value=<span class="string">&#x27;NEW&#x27;</span>, regex=<span class="literal">True</span>, inplace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ae4b4a6a-7f4f-43d1-e3cf-dce673bb6b00/public"                      width = "500"                ><p>调⽤<code>rank()</code>⽅法可以实现数据排名。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;排名&quot;</span>] = df.rank(method=<span class="string">&quot;dense&quot;</span>).astype(<span class="string">&quot;int&quot;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a2a0b9b7-41e3-46d5-c053-28aedaf97700/public"                      width = "500"                ><p><code>rank()</code>⽅法中的<code>method</code>参数，它有5个常⽤选项，可以帮助我们实现不同情况下的排名。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/caa0bb9f-5fdd-40af-1d11-5e3504552400/public"                      width = "500"                ><p>唯一值，<code>unique()</code>是以数组形式返回列的所有唯一值，而<code>nunique()</code>返回的是唯一值的个数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;gender&quot;</span>].unique()</span><br><span class="line">df[<span class="string">&quot;gender&quot;</span>].nunique()</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/ff43ed8b-8cda-46d5-ff98-a024e0ab2f00/public"                      width = "500"                ><p><code>clip()</code>方法，用于对超过或者低于某些数的数值进行截断[1]，来保证数值在一定范围。比如每月的迟到天数一定是在0-31天之间。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;迟到天数&quot;</span>] = df[<span class="string">&quot;迟到天数&quot;</span>].clip(<span class="number">0</span>,<span class="number">31</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d49d14b3-820f-4017-8cc2-4e6bd2386900/public"                      width = "500"                ><h3 id="行-列操作"><a href="#行-列操作" class="headerlink" title="行&#x2F;列操作"></a>行&#x2F;列操作</h3><p><code>rename()</code>重命名用于更改行列的标签，即行列的索引。可以传入一个字典或者一个函数。在数据预处理中，比较常用。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.rename(columns=&#123;<span class="string">&#x27;mark&#x27;</span>: <span class="string">&#x27;sell&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/28770c41-d7cb-41a0-58ca-2021fd057f00/public"                      width = "500"                ><p>数据清洗时，会将带空值的行删除，此时DataFrame或Series类型的数据不再是连续的索引，可以使用<code>reset_index()</code>重置索引。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/b50c5bd9-d858-46e2-7719-ff6243beea00/public"                      width = "500"                ><p>删除行列，可以使用<code>drop()</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop(columns=[<span class="string">&quot;mark&quot;</span>])</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/98784bcb-e940-4dd4-446e-357c71cbf700/public"                      width = "500"                ><p>行列转置，我们可以使用<code>T</code>属性获得转置后的DataFrame。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.T</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a54d21ce-1686-4feb-7e8b-b8b1f0d85000/public"                      width = "500"                ><p><code>melt()</code>方法可以将宽表转长表，即表格型数据转为树形数据。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.melt(id_vars=<span class="string">&quot;姓名&quot;</span>, var_name=<span class="string">&quot;科目&quot;</span>, value_name=<span class="string">&quot;成绩&quot;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3619a44d-5c76-4152-24be-518f9b4eb400/public"                      width = "500"                ><p><code>pivot()</code>方法可以将长表转宽表，即树形数据转为表格型数据。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot(index=<span class="string">&#x27;姓名&#x27;</span>, columns=<span class="string">&#x27;科目&#x27;</span>, values=<span class="string">&#x27;成绩&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3f978462-5366-4c4e-0c9a-5b8eed105000/public"                      width = "500"                ><p>数据分组与数据透视表更是一个常见的需求，<code>groupby()</code>方法可以用于数据分组。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&quot;科目&quot;</span>).mean()</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/6e9032a0-eac0-4cb0-22f1-aade19634000/public"                      width = "500"                ><p><code>pivot_table()</code>数据透视表</p><h3 id="数值数据统计运算"><a href="#数值数据统计运算" class="headerlink" title="数值数据统计运算"></a>数值数据统计运算</h3><p>在对数值型的数据进行统计运算时，除了有算术运算、比较预算还有各种常见的汇总统计运行函数，具体如下表所示</p><table><thead><tr><th align="center">函数方法</th><th align="center">用法释义</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">非NaN数据项计数</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr><tr><td align="center">mean</td><td align="center">平均值</td></tr><tr><td align="center">median</td><td align="center">中位数</td></tr><tr><td align="center">mode</td><td align="center">众数</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">std</td><td align="center">标准差</td></tr><tr><td align="center">var</td><td align="center">方差</td></tr><tr><td align="center">quantile</td><td align="center">分位数</td></tr><tr><td align="center">skew</td><td align="center">返回偏态系数</td></tr><tr><td align="center">kurt</td><td align="center">返回峰态系数</td></tr></tbody></table><p>累加<code>cumsum()</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;累计销量&quot;</span>] = df[<span class="string">&quot;销量&quot;</span>].cumsum()</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/288019bf-0614-443b-af05-cadf7e3ba800/public"                      width = "500"                ><h3 id="文本数据操作"><a href="#文本数据操作" class="headerlink" title="文本数据操作"></a>文本数据操作</h3><p>在对文本型的数据进行处理时，我们会大量应用字符串的函数，来实现对一列文本数据进行操作。</p><table><thead><tr><th align="center">函数方法</th><th align="center">用法释义</th></tr></thead><tbody><tr><td align="center">cat</td><td align="center">字符串的拼接</td></tr><tr><td align="center">contains</td><td align="center">判断某个字符串是否包含给定字符</td></tr><tr><td align="center">startswith&#x2F;endswith</td><td align="center">判断某个字符串是否以…开头&#x2F;结尾</td></tr><tr><td align="center">get</td><td align="center">获取指定位置的字符串</td></tr><tr><td align="center">len</td><td align="center">计算字符串长度</td></tr><tr><td align="center">upper、lower</td><td align="center">英文大小写转换</td></tr><tr><td align="center">pad&#x2F;center</td><td align="center">在字符串的左边、右边或左右两边添加给定字符</td></tr><tr><td align="center">repeat</td><td align="center">重复字符串几次</td></tr><tr><td align="center">slice_replace</td><td align="center">使用给定的字符串，替换指定的位置的字符</td></tr><tr><td align="center">split</td><td align="center">分割字符串，将一列扩展为多列</td></tr><tr><td align="center">strip、rstrip、lstrip</td><td align="center">去除空白符、换行符</td></tr><tr><td align="center">findall</td><td align="center">利用正则表达式，去字符串中匹配，返回查找结果的列表</td></tr><tr><td align="center">extract、extractall</td><td align="center">接受正则表达式，抽取匹配的字符串(一定要加上括号)</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Python Pandas包</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.yiuhangblog.com/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>NumPy</title>
    <link href="https://www.yiuhangblog.com/2018/10/22/20181022NumPy/"/>
    <id>https://www.yiuhangblog.com/2018/10/22/20181022NumPy/</id>
    <published>2018-10-22T08:02:56.000Z</published>
    <updated>2024-02-28T10:49:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NumPy简介"><a href="#NumPy简介" class="headerlink" title="NumPy简介"></a>NumPy简介</h2><p>NumPy（Numerical Python）是一个开源的Python库，它提供了高性能的多维数组对象和一系列用于处理这些数组的函数。这使得NumPy成为执行许多科学计算和数据分析任务的基础库之一。NumPy的核心功能是围绕着一个强大的N维数组对象<code>ndarray</code>展开的，这个对象允许进行高效的数组计算。此外，NumPy还包括：</p><ul><li><strong>广播功能函数</strong>，它支持不同大小数组之间的运算。</li><li><strong>整合C&#x2F;C++&#x2F;Fortran代码的工具</strong>，这些底层算法的设计初衷就是要提供优异的性能，使NumPy在执行数值计算时比纯Python代码高效得多。</li><li><strong>线性代数、傅里叶变换、随机数生成等功能</strong>，这些是执行科学计算的常用工具。</li></ul><p>NumPy的主要对象是同种元素的多维数组。这是一个表格，所有元素类型相同，每个元素都通过一个正整数元组进行索引。在NumPy中，数组的维度称为“轴”，轴的数量称为“秩”。</p><p>更专业地补充，NumPy的设计哲学强调数组的重要性，它通过以下特点体现了这一点：</p><ul><li><strong>内存效率</strong>：NumPy的数组对象直接映射到内存中，减少了Python解释器的开销，提高了数据处理的效率。</li><li><strong>广播机制</strong>：这是一种强大的功能，允许NumPy在执行数组运算时自动扩展维度，简化了代码的复杂度，提高了开发效率。</li><li><strong>矢量化操作</strong>：NumPy允许用户对数组进行批量操作而无需编写循环语句，这不仅使代码更简洁，也利用了底层优化，提升了性能。</li><li><strong>底层语言接口</strong>：NumPy提供了API，使得在C、C++或Fortran编写的代码可以轻松集成进Python程序中，进一步提升了执行效率。</li><li><strong>科学计算工具集成</strong>：NumPy是许多高级科学计算库（如SciPy、Pandas、Matplotlib）的基石，为复杂的数据处理和分析提供了强大的支持。</li></ul><p>以上特性使NumPy成为科学计算、数据分析、机器学习等领域不可或缺的工具，它的高效、灵活和易于使用的特性，为Python在科学计算领域的流行提供了坚实的基础。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/d96a31a8-ade9-4034-113f-a3b02a2c8b00/public"                      width = "1000"                ><h2 id="导入NumPy库"><a href="#导入NumPy库" class="headerlink" title="导入NumPy库"></a>导入NumPy库</h2><p><code>import numpy as np</code></p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>NumPy库提供了多种方法来读取数据，其中<code>np.loadtxt</code>是一种非常高效且简便的方式，特别适合于读取CSV（逗号分隔值）文件。这个函数允许用户定制化地读取数据，通过指定函数参数来适应不同格式的数据文件。下面是对<code>np.loadtxt</code>方法参数的进一步解释和扩展，以提供更全面的理解：</p><ul><li><p><strong><code>path</code></strong>: 这是一个必需的参数，用于指定要读取的文件的路径。这个路径可以是相对路径或绝对路径。相对路径是相对于当前工作目录的路径，而绝对路径是从根目录开始的完整路径。例如，<code>&#39;./data/myfile.csv&#39;</code>是一个相对路径，它指向当前目录下的<code>data</code>文件夹中的<code>myfile.csv</code>文件。</p></li><li><p><strong><code>delimiter</code></strong>: 用于指定文件中用于分隔数据列的字符。在CSV文件中，最常见的分隔符是逗号(<code>&#39;,&#39;</code>)，但有时也可能使用制表符(<code>&#39;\t&#39;</code>)、空格或其他字符。正确指定分隔符是确保数据正确读取的关键。</p></li><li><p><strong><code>skiprows</code></strong>: 该参数允许用户指定在开始读取数据之前应跳过的行数。这对于忽略文件头部的标题行或注释行非常有用。例如，<code>skiprows=1</code>会跳过文件的第一行。</p></li><li><p><strong><code>dtype</code></strong>: 默认情况下，<code>np.loadtxt</code>尝试将读取的数据转换为浮点数。但是，如果数据集中包含非数值数据（如字符串或日期），则需要通过<code>dtype</code>参数指定数据类型。例如，<code>dtype=&#39;str&#39;</code>会将所有数据读取为字符串类型。</p></li><li><p><strong><code>encoding</code></strong>: 当处理非英文字符的文件时，指定正确的文件编码是必要的，以防止编码错误。<code>encoding=&#39;utf-8&#39;</code>是一个常见的选项，适用于包含UTF-8编码字符的文件。</p></li></ul>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>进阶用法和注意事项：</p><ul><li><p><strong>处理非数值数据</strong>: 除了<code>dtype</code>参数，NumPy提供了<code>converters</code>参数，允许对特定列应用转换函数，以处理文件中的非标准数据，如将日期字符串转换为日期对象。</p></li><li><p><strong>读取部分列</strong>: 使用<code>usecols</code>参数可以指定一个列索引列表，只读取感兴趣的列，提高读取效率。</p></li><li><p><strong>内存管理</strong>: 对于大型文件，<code>np.loadtxt</code>可能会消耗大量内存。在这种情况下，考虑使用<code>np.genfromtxt</code>，它提供了更灵活的数据加载机制，包括处理缺失值。</p></li><li><p><strong>Excel文件</strong>: 正如笔记中提到的，NumPy不能直接读取Excel（<code>.xlsx</code>）文件。需要先将Excel文件转换为CSV格式或使用专门的库（如<code>pandas</code>）来读取Excel文件。</p></li></ul>    </div>  </div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># path = &#x27;./工作/8.Advertising.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy读入</span></span><br><span class="line">df = np.loadtxt(<span class="string">&#x27;./LC.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">skiprows=<span class="number">1</span>,dtype=<span class="string">&#x27;str&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 那我们是不是可以直接把括号里面的path直接换成路径呢？</span></span><br><span class="line"><span class="comment"># 其次注意numpy不能直接读取excel文件，就是xlsx后缀的文件，得先将文件存储为csv文件</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0cffed97-a64f-404c-bd4a-7d3a9d805300/public"                      width = "600"                ><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>NumPy的<code>array()</code>函数是创建数组的基础工具，它允许从多种数据结构（如列表、元组、数组、生成器等）创建数组。此功能的强大之处在于它提供了一种高效的方式来存储和操作大量数据，这是NumPy库核心功能之一。</p><p>NumPy数组可以包含多种数据类型（<code>dtype</code>），如<code>int</code>（整数）、<code>float</code>（浮点数）、<code>str</code>（字符串）等。在创建数组时，可以通过<code>dtype</code>参数显式指定数组的数据类型，这对于优化内存使用和提高计算效率至关重要。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/55141816-d5eb-4db3-72bb-4f0df4b02d00/public"                      width = "1000"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/07048e72-390e-4103-5e3c-df4fbe1c4800/public"                      width = "600"                ><h3 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h3><ul><li><p><strong>直接从列表或元组创建</strong>：通过传递一个列表或元组给<code>np.array()</code>函数，可以创建一个一维数组。数组的数据类型会根据列表或元组中的元素自动确定，但也可以通过<code>dtype</code>参数显式指定。<code>array()</code>函数创建，括号内可以是列表、元祖、数组、生成器等</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></div><p>输出的数组<code>a</code>是一个一维数组，包含了三个整数元素。</p></li><li><p><strong>使用数组属性</strong>：</p><ul><li><code>a.ndim</code>：显示数组的维数。对于一维数组，此属性值为1。</li><li><code>a.shape</code>：返回一个表示数组形状的元组，对于一维数组，形状会显示为<code>(n,)</code>，其中<code>n</code>是数组中元素的数量。</li><li><code>a.size</code>：表示数组中元素的总数。</li><li><code>a.dtype</code>：显示数组元素的数据类型，例如<code>int64</code>。</li><li><code>a.itemsize</code>：数组中每个元素的字节大小。</li><li><code>a.data</code>：指向数组数据的内存缓冲区。</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/fe214859-02e5-4f0e-d20b-6c6da4da5d00/public"                      width = "600"                ></li></ul><h4 id="创建数组的其他方式"><a href="#创建数组的其他方式" class="headerlink" title="创建数组的其他方式"></a>创建数组的其他方式</h4><ul><li><p><strong>直接传入列表的方式</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a= np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure></div></li><li><p><strong>通过<code>range</code>生成序列</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure></div><p>这会创建一个包含0到4的整数的一维数组。</p></li><li><p><strong>使用<code>np.linspace()</code>生成等间距数值</strong>：</p><p><code>np.linspace()</code>函数用于在指定的区间内生成等间隔的数值。它接受起始值、终止值和数值数量作为输入，并生成一个一维数组。如果<code>endpoint</code>参数设置为True（默认值），则包含终止值；如果为False，则不包含。</p><p>参数解释：</p><ul><li>start：序列的起始值。</li><li>stop：序列的结束值。</li><li>num：生成的样本数，默认为 50。</li><li>endpoint：如果为 True（默认），则包括停止值；如果为 False，则不包括停止值。</li><li>retstep：如果为 True，则返回</li><li>(samples, step)，其中</li><li>step 是样本之间的间距。</li><li>dtype：输出数组的数据类型。</li><li>axis：生成数组的轴。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>, axis=<span class="number">0</span>)</span><br><span class="line">arr = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure></div><p>这将在0到10之间均匀分布生成5个数值的数组。</p></li></ul>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <h4 id="高级创建数组方法"><a href="#高级创建数组方法" class="headerlink" title="高级创建数组方法"></a>高级创建数组方法</h4><p>除了上述方法，NumPy还提供了其他函数来创建特殊数组：</p><ul><li>**<code>np.zeros()</code>**：创建一个所有元素都为0的数组。</li><li>**<code>np.ones()</code>**：创建一个所有元素都为1的数组。</li><li>**<code>np.empty()</code>**：创建一个未初始化的数组，其元素值不确定。</li><li>**<code>np.arange()</code>**：类似于Python的<code>range</code>，但返回的是数组。</li><li>**<code>np.full()</code>**：创建一个所有元素都设定为指定值的数组。</li></ul>    </div>  </div><h3 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h3><h4 id="列表嵌套转换为ndarray"><a href="#列表嵌套转换为ndarray" class="headerlink" title="列表嵌套转换为ndarray"></a>列表嵌套转换为ndarray</h4><p>使用numpy库可以方便地将嵌套列表转换为二维数组。这是一种常见的创建二维数组的方法，适用于已经有一个列表数据结构，希望将其转换为numpy的<code>ndarray</code>格式进行更高效的数值计算。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建列表</span></span><br><span class="line">lst = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为numpy的二维数组</span></span><br><span class="line">num1 = np.array(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印二维数组</span></span><br><span class="line"><span class="built_in">print</span>(num1)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/aa20a6ac-2d3e-4957-c9ab-cee32b32a900/public"                      width = "400"                ><h4 id="使用元组创建浮点型二维数组"><a href="#使用元组创建浮点型二维数组" class="headerlink" title="使用元组创建浮点型二维数组"></a>使用元组创建浮点型二维数组</h4><p>通过将元组传递给<code>np.array()</code>函数，可以直接创建二维数组。如果元组中包含浮点数，则数组的数据类型会自动适应为浮点型，这对于需要进行浮点数计算的场景非常有用。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用元组创建，并指定为浮点型</span></span><br><span class="line">num2 = np.array([(<span class="number">1.5</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印二维数组</span></span><br><span class="line"><span class="built_in">print</span>(num2)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/032fd774-c83e-4ad1-1127-8b62a9825900/public"                      width = "400"                ><h3 id="各种类型的数组创建"><a href="#各种类型的数组创建" class="headerlink" title="各种类型的数组创建"></a>各种类型的数组创建</h3><p>Numpy提供了灵活的方式来创建数组，这些方法可以满足不同场景的需求。</p><ol><li><p><strong>使用<code>np.array()</code>创建一维数组</strong>：</p><ul><li>从<code>range()</code>创建数组</li><li>直接传递单个数值创建零维数组（标量）</li><li>传递列表创建一维数组</li><li>传递嵌套列表创建二维数组</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">ar1 = np.array(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">ar2 = np.array(<span class="number">10</span>)</span><br><span class="line">ar3 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">ar4 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ar1)</span><br><span class="line"><span class="built_in">print</span>(ar2)</span><br><span class="line"><span class="built_in">print</span>(ar3)</span><br><span class="line"><span class="built_in">print</span>(ar4)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/2efb2479-34ec-4ecb-3637-a64bbc656100/public"                      width = "400"                ></li><li><p><strong>使用<code>np.arange()</code>创建数组</strong>：</p><p><code>np.arange()</code>是一个非常有用的函数，它在指定的间隔内返回等间隔的值。它类似于Python内置的<code>range()</code>函数，但<code>np.arange()</code>可以生成浮点数序列，并且可以直接用于创建numpy数组。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">10</span>))  <span class="comment"># 整型，0到9</span></span><br><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">10.0</span>))  <span class="comment"># 浮点型，0.0到9.0</span></span><br><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">5</span>, <span class="number">15</span>))  <span class="comment"># 5到14</span></span><br><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">5.0</span>, <span class="number">12.0</span>, <span class="number">2</span>))  <span class="comment"># 5.0到11.0，步长为2</span></span><br><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">100000000</span>))  <span class="comment"># 大数组，numpy自动优化显示</span></span><br></pre></td></tr></table></figure></div></li></ol><h3 id="数组的数据类型"><a href="#数组的数据类型" class="headerlink" title="数组的数据类型"></a>数组的数据类型</h3><p>在创建数组时，numpy会根据提供的数据自动确定数组的数据类型，但也可以通过<code>dtype</code>参数显式指定数据类型。这对于需要控制数据存储和计算精度的应用场景非常重要。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建整型数组</span></span><br><span class="line">arr_int = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建浮点型数组</span></span><br><span class="line">arr_float = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr_int.dtype)</span><br><span class="line"><span class="built_in">print</span>(arr_float.dtype)</span><br></pre></td></tr></table></figure></div><p>三维数组在NumPy中是一种非常有用的数据结构，它可以被视为一个由多个二维数组（矩阵）组成的数据立方体。这种结构非常适合表示多维数据集，比如时间序列数据、空间数据或多通道图像数据（例如彩色图像的RGB通道）。</p><h3 id="创建三维数组"><a href="#创建三维数组" class="headerlink" title="创建三维数组"></a>创建三维数组</h3><p>三维数组的创建可以通过直接传递一个三层嵌套的列表（或元组）给<code>np.array()</code>函数，也可以使用特定的NumPy函数如<code>np.zeros()</code>, <code>np.ones()</code>, <code>np.empty()</code>, 或<code>np.random.rand()</code>等，来创建具有特定形状的三维数组。</p><h4 id="通过列表创建三维数组"><a href="#通过列表创建三维数组" class="headerlink" title="通过列表创建三维数组"></a>通过列表创建三维数组</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个三维数组</span></span><br><span class="line"><span class="comment"># 这里可以看成是由3个2x2的矩阵组成</span></span><br><span class="line">lst_3d = [[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], [[<span class="number">9</span>, <span class="number">10</span>], [<span class="number">11</span>, <span class="number">12</span>]]]</span><br><span class="line">arr_3d = np.array(lst_3d)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr_3d)</span><br></pre></td></tr></table></figure></div><h4 id="使用NumPy函数创建三维数组"><a href="#使用NumPy函数创建三维数组" class="headerlink" title="使用NumPy函数创建三维数组"></a>使用NumPy函数创建三维数组</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用np.zeros创建一个3x2x2的三维数组，所有元素初始化为0</span></span><br><span class="line">arr_zeros = np.zeros((<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用np.ones创建一个3x3x3的三维数组，所有元素初始化为1</span></span><br><span class="line">arr_ones = np.ones((<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用np.random.rand创建一个3x4x2的三维数组，所有元素为随机数</span></span><br><span class="line">arr_random = np.random.rand(<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Zeros:\n&quot;</span>, arr_zeros)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ones:\n&quot;</span>, arr_ones)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Random:\n&quot;</span>, arr_random)</span><br></pre></td></tr></table></figure></div><h4 id="访问三维数组元素"><a href="#访问三维数组元素" class="headerlink" title="访问三维数组元素"></a>访问三维数组元素</h4><p>访问三维数组的元素类似于访问二维数组，但需要指定三个索引：第一个索引表示哪一个二维数组（矩阵），第二和第三个索引分别表示该二维数组中的行和列。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问第一个二维数组的第二行第一列的元素</span></span><br><span class="line">element = arr_3d[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(element)</span><br></pre></td></tr></table></figure></div><h4 id="三维数组的应用"><a href="#三维数组的应用" class="headerlink" title="三维数组的应用"></a>三维数组的应用</h4><p>三维数组在科学计算、数据分析、图像处理等领域有广泛的应用。例如，在图像处理中，彩色图像可以表示为一个三维数组，其中两个维度对应于图像的宽度和高度，第三个维度用于表示颜色通道（如RGB）。</p><h2 id="数学函数和统计函数"><a href="#数学函数和统计函数" class="headerlink" title="数学函数和统计函数"></a>数学函数和统计函数</h2><h3 id="NumPy数组操作实例"><a href="#NumPy数组操作实例" class="headerlink" title="NumPy数组操作实例"></a>NumPy数组操作实例</h3><p>首先，这是创建和打印NumPy数组的基础代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">88</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">11</span>])</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br></pre></td></tr></table></figure></div><h4 id="基本统计操作"><a href="#基本统计操作" class="headerlink" title="基本统计操作"></a>基本统计操作</h4><ul><li><p><strong>最大值和最小值</strong></p><ul><li><code>arr1.max()</code>返回数组中的最大值。</li><li><code>arr1.min()</code>返回数组中的最小值。</li></ul></li><li><p><strong>平均值和中位数</strong></p><ul><li><code>arr1.mean()</code>计算数组所有元素的平均值。</li><li><code>np.median(arr1)</code>计算数组中的中位数，注意是使用<code>np.median()</code>而不是<code>arr1.median()</code>。</li></ul></li><li><p><strong>索引操作</strong></p><ul><li><code>arr1.argmax()</code>返回数组中最大值的索引。</li><li><code>arr1.argmin()</code>返回数组中最小值的索引。</li><li><code>np.argwhere(arr1 &gt; 20)</code>返回数组中所有大于20的元素的索引。</li></ul></li></ul><h4 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h4><ul><li><p><strong>总和和累积总和</strong></p><ul><li><code>np.sum(arr1)</code>计算数组元素的总和。</li><li><code>np.cumsum(arr1)</code>计算数组元素的累积总和，即每个元素是原数组到该位置的所有元素的总和。</li></ul></li></ul><h4 id="分散度测量"><a href="#分散度测量" class="headerlink" title="分散度测量"></a>分散度测量</h4><ul><li><p><strong>标准差和方差</strong></p><ul><li><code>np.std(arr1)</code>计算数组的标准差，衡量数据的分散程度。</li><li><code>np.var(arr1)</code>计算数组的方差，方差越大，数据的分散程度越高。</li></ul></li></ul><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><ul><li><p><strong>指数和对数</strong></p><ul><li><code>np.exp(arr1)</code>计算数组中所有元素的指数。</li><li><code>np.log(arr1)</code>计算数组中所有元素的自然对数。注意，对数运算要求数组中的所有元素都必须大于0。</li></ul></li></ul>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>扩展信息</strong></p><ul><li><p><strong>数据归一化</strong></p><p>在数据处理中，经常需要对数据进行归一化处理，以便将数据限制在特定的范围内。使用NumPy可以轻松实现这一点，例如通过将数组的每个元素减去数组的最小值然后除以数组的范围（最大值-最小值）来实现归一化。</p></li><li><p><strong>条件选择</strong></p><p>NumPy允许使用条件表达式选择数组中的元素，这对于数据分析和预处理非常有用。例如，<code>arr1[arr1 &gt; 10]</code>将返回<code>arr1</code>中所有大于10的元素组成的数组。</p></li><li><p><strong>多维数组操作</strong></p><p>虽然这里主要讨论的是一维数组的操作，但NumPy的真正强大之处在于它可以无缝地处理多维数组（如二维数组或三维数组）。许多上述操作（如求和、最大值、最小值等）都可以沿指定轴在多维数组上执行。</p></li></ul>    </div>  </div><h4 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h4><h5 id="整数随机数"><a href="#整数随机数" class="headerlink" title="整数随机数"></a>整数随机数</h5><p>NumPy的<code>np.random.randint()</code>函数用于生成指定范围内的随机整数。生成一个4行5列的随机整数数组，其中整数范围是从0（包含）到10（不包含）。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr2 = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br></pre></td></tr></table></figure></div><h5 id="浮点数随机数"><a href="#浮点数随机数" class="headerlink" title="浮点数随机数"></a>浮点数随机数</h5><p>与此同时，<code>np.random.uniform()</code>函数用于生成一个给定范围内的浮点数随机数组。展示了如何创建一个4行5列的数组，并且如何使用<code>np.around()</code>函数来保留结果至指定的小数位数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr2 = np.random.uniform(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line">arr2_rounded = np.around(arr2, decimals=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2_rounded)</span><br></pre></td></tr></table></figure></div><h4 id="计算平均值"><a href="#计算平均值" class="headerlink" title="计算平均值"></a>计算平均值</h4><p>计算数组的平均值是数据分析中的基本操作，<code>axis</code>参数允许指定沿哪个轴计算平均值。</p><ul><li><strong>列平均值</strong> (<code>axis=0</code>): 计算每列的平均值。</li><li><strong>行平均值</strong> (<code>axis=1</code>): 计算每行的平均值。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列平均值</span></span><br><span class="line"><span class="built_in">print</span>(arr2.mean(axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 行平均值</span></span><br><span class="line"><span class="built_in">print</span>(arr2.mean(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure></div><h4 id="数组连接与拆分"><a href="#数组连接与拆分" class="headerlink" title="数组连接与拆分"></a>数组连接与拆分</h4><h5 id="连接数组"><a href="#连接数组" class="headerlink" title="连接数组"></a>连接数组</h5><p><code>numpy.concatenate()</code>函数是连接两个或多个数组的工具。提供了列对齐和行对齐连接的示例，这非常有助于理解如何根据实际需求选择合适的<code>axis</code>参数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列对齐连接</span></span><br><span class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">result = np.concatenate((arr1, arr2), axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 行对齐连接</span></span><br><span class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">result = np.concatenate((arr1, arr2), axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></div><h5 id="拆分数组"><a href="#拆分数组" class="headerlink" title="拆分数组"></a>拆分数组</h5><p><code>numpy.split()</code>函数提供了一种灵活的方式来拆分数组。它可以根据指定的段数均匀拆分数组，也可以根据提供的索引数组来拆分。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 均匀拆分一维数组</span></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">result = np.split(arr, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照索引拆分</span></span><br><span class="line">result = np.split(arr, [<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组的拆分</span></span><br><span class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">result = np.split(arr1, <span class="number">2</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>扩展信息</strong></p><ul><li><p><strong>多维数组的连接与拆分</strong>：<code>numpy.concatenate()</code>和<code>numpy.split()</code>不仅限于处理一维或二维数组，它们也可以用于更高维度的数组。当处理多维数组时，选择正确的<code>axis</code>参数变得尤为重要。</p></li><li><p><strong>其他数组操作函数</strong>：NumPy提供了其他函数如<code>np.vstack()</code>（垂直栈）、<code>np.hstack()</code>（水平栈）以及<code>np.array_split()</code>（允许不等量的分割），这些函数提供了更多</p></li></ul><p>灵活性在数组的操作上。</p><ul><li><strong>随机数种子</strong>：为了使随机数生成的结果可复现，可以通过<code>np.random.seed()</code>函数设置随机数生成的种子。</li></ul>    </div>  </div><h3 id="NumPy数组的shape属性"><a href="#NumPy数组的shape属性" class="headerlink" title="NumPy数组的shape属性"></a>NumPy数组的<code>shape</code>属性</h3><ul><li><strong>获取数组形状</strong>：<code>shape</code>属性是NumPy数组的内置属性，用于返回数组的维度信息。这是理解和操作多维数组的基础。<ul><li>对于一维数组，<code>shape</code>返回的是一个元组，其中只有一个元素，表示数组中的元素数量。</li><li>对于二维数组，<code>shape</code>返回的是两个元素的元组，分别表示数组的行数和列数。</li><li>对于高维数组，<code>shape</code>将以此类推，返回每个维度的大小。</li></ul></li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例代码</span></span><br><span class="line"><span class="built_in">print</span>(arr1.shape)  <span class="comment"># 打印arr1的形状</span></span><br><span class="line"><span class="built_in">print</span>(arr2.shape)  <span class="comment"># 打印arr2的形状</span></span><br></pre></td></tr></table></figure></div><h3 id="数组类型的转换"><a href="#数组类型的转换" class="headerlink" title="数组类型的转换"></a>数组类型的转换</h3><ul><li><strong>使用<code>astype</code>方法</strong>：<code>astype</code>方法用于数组的数据类型转换。这个方法返回数组的一个新副本，其中的元素已转换为指定的类型。</li><li><strong>更新的数据类型表示</strong>：在新版本的NumPy中，建议使用Python标准的数据类型名称，如<code>float</code>代替<code>np.float</code>，以避免弃用警告或错误。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例代码</span></span><br><span class="line">arr3 = arr1.astype(<span class="built_in">float</span>)  <span class="comment"># 将arr1的数据类型转换为float</span></span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="built_in">print</span>(arr3.dtype)  <span class="comment"># 查看转换后的数据类型</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>数据类型和显示方式</strong>：转换为浮点数后，即使是0值也会显示为0.0，这是浮点数表示法的一部分，并不影响值的实际大小或精度。</li></ul><h3 id="NumPy数据类型概览"><a href="#NumPy数据类型概览" class="headerlink" title="NumPy数据类型概览"></a>NumPy数据类型概览</h3><ul><li><strong>布尔型</strong>：<code>bool</code>，表示真值<code>True</code>或<code>False</code>，使用一个字节存储。</li><li><strong>整型</strong>：包括<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>及其无符号版本<code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>，分别对应不同的大小范围。</li><li><strong>浮点型</strong>：<code>float16</code>, <code>float32</code>, <code>float64</code>（或简写为<code>float</code>），用于表示小数，具有不同的精度和表示范围。</li><li><strong>复数型</strong>：<code>complex64</code>, <code>complex128</code>（或简写为<code>complex</code>），用于表示复数，其中实部和虚部分别由浮点数表示。</li></ul><h3 id="创建特殊数组"><a href="#创建特殊数组" class="headerlink" title="创建特殊数组"></a>创建特殊数组</h3><h4 id="全零数组"><a href="#全零数组" class="headerlink" title="全零数组"></a>全零数组</h4><ul><li><code>np.zeros()</code>函数非常适用于初始化固定大小的数组。全零数组在算法初期的数据准备阶段特别有用，可以作为数据容器的起点。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维全零数组</span></span><br><span class="line">zeros_array = np.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(zeros_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维全零数组</span></span><br><span class="line">zeros_array = np.zeros((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(zeros_array)</span><br></pre></td></tr></table></figure></div><h4 id="全一数组"><a href="#全一数组" class="headerlink" title="全一数组"></a>全一数组</h4><ul><li><code>np.ones()</code>函数创建的是全一数组，这在需要初始化为特定值的数组时非常有用，例如在某些算法中初始化权重。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维全一数组</span></span><br><span class="line">ones_array = np.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(ones_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维全一数组</span></span><br><span class="line">ones_array = np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(ones_array)</span><br></pre></td></tr></table></figure></div><h4 id="未初始化数组"><a href="#未初始化数组" class="headerlink" title="未初始化数组"></a>未初始化数组</h4><ul><li><code>np.empty()</code>函数用于创建未初始化的数组。这种数组的内容是内存中的随机值，因此<code>np.empty()</code>比<code>np.zeros()</code>或<code>np.ones()</code>更快，但使用时需要注意其值是不确定的。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维未初始化数组</span></span><br><span class="line">empty_array = np.empty(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(empty_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维未初始化数组</span></span><br><span class="line">empty_array = np.empty((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(empty_array)</span><br></pre></td></tr></table></figure></div><h3 id="数组结构的变化"><a href="#数组结构的变化" class="headerlink" title="数组结构的变化"></a>数组结构的变化</h3><h4 id="获取数组形状"><a href="#获取数组形状" class="headerlink" title="获取数组形状"></a>获取数组形状</h4><ul><li>使用<code>.shape</code>属性而不是<code>.shape()</code>方法来获取数组的形状。这是一个常见的误区。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar1 = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(ar1.shape)</span><br></pre></td></tr></table></figure></div><h4 id="转置操作"><a href="#转置操作" class="headerlink" title="转置操作"></a>转置操作</h4><ul><li><code>.T</code>属性用于数组的转置。对于二维数组，它会交换数组的行和列。对于一维数组，<code>.T</code>不会改变数组。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar2 = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(ar2)</span><br><span class="line"><span class="built_in">print</span>(ar2.T)</span><br></pre></td></tr></table></figure></div><h4 id="改变数组形状"><a href="#改变数组形状" class="headerlink" title="改变数组形状"></a>改变数组形状</h4><ul><li><code>np.reshape()</code>函数用于在不改变数据的前提下改变数组的形状。重塑后的数组元素总数必须与原始数组相同。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">88</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">11</span>])</span><br><span class="line">reshaped_arr = np.reshape(arr1, (<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(reshaped_arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把二维变一维</span></span><br><span class="line">reshaped_arr = np.reshape(arr1, (<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(reshaped_arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用arange生成的一维数组变成二维</span></span><br><span class="line">arr2 = np.reshape(np.arange(<span class="number">20</span>), (<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>进阶提示</strong></p><ul><li><p><strong>数组重塑的灵活性</strong>：<code>np.reshape()</code>可以接受一个参数为<code>-1</code>，这意味着该维度的大小将自动计算。这在将多维数组平坦化为一维数组时非常有用，或者在不知道某个维度具体大小但知道总元素数量时使用。</p></li><li><p><strong>内存顺序</strong>：<code>order</code>参数在<code>np.zeros()</code>, <code>np.ones()</code>, <code>np.empty()</code>函数中指定了数组在内存中的布局。<code>&#39;C&#39;</code>代表C语言风格，即行优先；<code>&#39;F&#39;</code>代表Fortran风格，即列优先。了解这一点对于性能优化尤其重要。</p></li></ul>    </div>  </div><h2 id="NumPy数组的操作与迭代"><a href="#NumPy数组的操作与迭代" class="headerlink" title="NumPy数组的操作与迭代"></a>NumPy数组的操作与迭代</h2><h3 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h3><h4 id="数组的切片和索引"><a href="#数组的切片和索引" class="headerlink" title="数组的切片和索引"></a>数组的切片和索引</h4><h4 id="一维数组的索引"><a href="#一维数组的索引" class="headerlink" title="一维数组的索引"></a>一维数组的索引</h4><p>一维数组的索引相对简单直观。通过指定下标，可以访问数组中的特定元素或子数组。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">ar = np.arange(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(ar)  <span class="comment"># 打印数组中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引下标取值</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">4</span>])  <span class="comment"># 获取下标为4的元素</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">3</span>:<span class="number">6</span>])  <span class="comment"># 获取下标为3到5的元素，注意这里是左闭右开区间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用步长进行索引</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">2</span>:<span class="number">8</span>:<span class="number">2</span>])  <span class="comment"># 从下标2开始到下标7结束，步长为2</span></span><br></pre></td></tr></table></figure></div><p><strong>负值索引</strong>: 负数索引允许从数组的末尾开始计数，例如，-1代表最后一个元素，-2代表倒数第二个元素，依此类推。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(ar[-<span class="number">1</span>])  <span class="comment"># 获取最后一个元素</span></span><br><span class="line"><span class="built_in">print</span>(ar[-<span class="number">1</span>:-<span class="number">8</span>:-<span class="number">1</span>])  <span class="comment"># 获取最后一个到倒数第八个元素，步长为-1</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">9</span>:<span class="number">0</span>:-<span class="number">1</span>])  <span class="comment"># 从下标9开始到1（不包括0），步长为-1</span></span><br></pre></td></tr></table></figure></div><p>注意，当使用负数步长时，起始索引应该大于结束索引。</p><p><strong>完整数组索引</strong>:</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(ar[:])  <span class="comment"># 获取数组的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(ar[:<span class="number">9</span>])  <span class="comment"># 获取从开始到下标8的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">9</span>:])  <span class="comment"># 获取从下标9到数组结束的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(ar[::-<span class="number">1</span>])  <span class="comment"># 获取数组的所有元素，反向</span></span><br></pre></td></tr></table></figure></div><h4 id="二维数组索引"><a href="#二维数组索引" class="headerlink" title="二维数组索引"></a>二维数组索引</h4><p>二维数组的索引更加复杂，涉及行和列的概念。NumPy数组的索引遵循[行, 列]的格式。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(ar)  <span class="comment"># 打印二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行取值</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">2</span>:<span class="number">3</span>])  <span class="comment"># 获取第3行的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列取值</span></span><br><span class="line"><span class="built_in">print</span>(ar[:,<span class="number">2</span>:<span class="number">3</span>])  <span class="comment"># 获取第3列的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂索引示例</span></span><br><span class="line"><span class="comment"># 如果想取出1，2，5，6，9，10，13，14这些值</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">0</span>:<span class="number">4</span>, <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想取出10，11，14，15这些值</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">2</span>:, <span class="number">2</span>:])</span><br></pre></td></tr></table></figure></div><p>注意，在二维数组中，<code>:</code>用于表示选取该维度的所有数据。</p><h4 id="三维数组索引"><a href="#三维数组索引" class="headerlink" title="三维数组索引"></a>三维数组索引</h4><p>三维数组的索引引入了更多层次，通常表示为[深度, 行, 列]。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">27</span>).reshape(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)  <span class="comment"># 创建一个三维数组</span></span><br><span class="line"><span class="built_in">print</span>(ar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一个二维数组</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">0</span>,:,:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有二维数组中的第一行</span></span><br><span class="line"><span class="built_in">print</span>(ar[:,<span class="number">0</span>,:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有二维数组中的第一列</span></span><br><span class="line"><span class="built_in">print</span>(ar[:,:,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更复杂的索引</span></span><br><span class="line"><span class="comment"># 获取第二个二维数组中，第二行及之后的数据</span></span><br><span class="line"><span class="built_in">print</span>(ar[<span class="number">1</span>, <span class="number">1</span>:,:])</span><br></pre></td></tr></table></figure></div><p>在三维数组中，可以通过指定每个维度的索引来访问特定的元素、行、列或子数组。这些示例展示了如何通过多维索引来操作和访问数组中的数据。</p><h3 id="数据的排序"><a href="#数据的排序" class="headerlink" title="数据的排序"></a>数据的排序</h3><p>排序是数据处理中的一个基本操作，它按照一定的顺序重新排列数据元素。NumPy提供了<code>numpy.sort()</code>函数来执行数组的排序。</p><h4 id="NumPy排序函数"><a href="#NumPy排序函数" class="headerlink" title="NumPy排序函数"></a>NumPy排序函数</h4><p><code>numpy.sort()</code>是NumPy中用于排序的函数，它的参数如下：</p><ul><li><strong>a</strong>: 要排序的数组。</li><li><strong>axis</strong>: 指定沿着哪个轴进行排序。默认值为<code>-1</code>，意味着沿最后一个轴排序。</li><li><strong>kind</strong>: 选择排序算法。可选值包括<code>&#39;quicksort&#39;</code>、<code>&#39;mergesort&#39;</code>、<code>&#39;heapsort&#39;</code>。默认为<code>&#39;quicksort&#39;</code>。</li><li><strong>order</strong>: 当数组是结构化数组时，这个参数可以指定根据哪个字段进行排序。</li></ul><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line">sorted_arr = np.sort(arr)  <span class="comment"># 默认使用快速排序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_arr)  <span class="comment"># 输出：[1 2 3 4]</span></span><br><span class="line"></span><br><span class="line">sorted_arr = np.sort(arr, kind=<span class="string">&#x27;mergesort&#x27;</span>)  <span class="comment"># 使用归并排序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_arr)  <span class="comment"># 输出：[1 2 3 4]</span></span><br></pre></td></tr></table></figure></div><h4 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h4><p>归并排序是一种分治策略的算法，通过递归地将数组分割成更小的数组，直到每个子数组只有一个元素，然后将这些数组合并成一个有序数组。</p><p><strong>归并排序的步骤</strong>:</p><ol><li><strong>分割（Divide）</strong>: 将数组不断二分，直到每个子数组只包含一个元素。</li><li><strong>合并（Merge）</strong>: 将分割后的子数组合并，过程中将它们排序。</li></ol><p>Python实现示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分割数组</span></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left_arr = arr[:mid]</span><br><span class="line">    right_arr = arr[mid:]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序左右两部分</span></span><br><span class="line">    left_arr = merge_sort(left_arr)</span><br><span class="line">    right_arr = merge_sort(right_arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并排序后的两部分</span></span><br><span class="line">    <span class="keyword">return</span> merge(left_arr, right_arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left_arr, right_arr</span>):</span><br><span class="line">    result = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_arr) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_arr):</span><br><span class="line">        <span class="keyword">if</span> left_arr[i] &lt; right_arr[j]:</span><br><span class="line">            result.append(left_arr[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_arr[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将剩余元素添加到结果数组中</span></span><br><span class="line">    result.extend(left_arr[i:])</span><br><span class="line">    result.extend(right_arr[j:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试归并排序</span></span><br><span class="line">arr = [<span class="number">38</span>, <span class="number">27</span>, <span class="number">43</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">82</span>, <span class="number">10</span>]</span><br><span class="line">sorted_arr = merge_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组：&quot;</span>, sorted_arr)</span><br></pre></td></tr></table></figure></div><p>这份笔记概述了在NumPy中进行二维数组排序、使用结构化数据以及特殊函数<code>numpy.argsort()</code>的基本应用。我将对这些主题进行扩展和细化，以提供更加全面和专业的视角。</p><hr><h3 id="二维数组排序"><a href="#二维数组排序" class="headerlink" title="二维数组排序"></a>二维数组排序</h3><p>在NumPy中，对二维数组进行排序可以根据指定轴进行。这意味着可以按行或按列对数组中的元素进行排序。</p><h4 id="沿着指定轴排序"><a href="#沿着指定轴排序" class="headerlink" title="沿着指定轴排序"></a>沿着指定轴排序</h4><p>通过设置<code>axis</code>参数，<code>numpy.sort()</code>允许指定沿数组的哪个轴进行排序：</p><ul><li><strong>axis&#x3D;0</strong>: 沿着第一个轴（垂直方向，即列）进行排序，即对每一列的元素进行排序。</li><li><strong>axis&#x3D;1</strong>: 沿着第二个轴（水平方向，即行）进行排序，即对每一行的元素进行排序。</li></ul><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">4</span>]])</span><br><span class="line">sorted_arr_axis0 = np.sort(arr, axis=<span class="number">0</span>)  <span class="comment"># 沿着第一个轴（行）排序</span></span><br><span class="line">sorted_arr_axis1 = np.sort(arr, axis=<span class="number">1</span>)  <span class="comment"># 沿着第二个轴（列）排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sorted_arr_axis0)  <span class="comment"># 输出：[[2 1] [3 4]]</span></span><br><span class="line"><span class="built_in">print</span>(sorted_arr_axis1)  <span class="comment"># 输出：[[1 3] [2 4]]</span></span><br></pre></td></tr></table></figure></div><h4 id="数组结构优化：结构化数据"><a href="#数组结构优化：结构化数据" class="headerlink" title="数组结构优化：结构化数据"></a>数组结构优化：结构化数据</h4><p>NumPy支持创建结构化数组，这种数组可以包含不同类型的数据，类似于数据库表或Excel电子表格中的数据。</p><h4 id="结构化数组的排序"><a href="#结构化数组的排序" class="headerlink" title="结构化数组的排序"></a>结构化数组的排序</h4><p>使用结构化数组时，<code>numpy.sort()</code>函数允许通过<code>order</code>参数指定根据哪个字段进行排序。</p><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">dtype = [(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S10&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="built_in">int</span>)]</span><br><span class="line">values = [(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">25</span>), (<span class="string">&#x27;Kate&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;John&#x27;</span>, <span class="number">30</span>)]</span><br><span class="line">arr = np.array(values, dtype=dtype)</span><br><span class="line">sorted_arr = np.sort(arr, order=<span class="string">&#x27;age&#x27;</span>)  <span class="comment"># 按照 &#x27;age&#x27; 字段排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sorted_arr)  <span class="comment"># 输出按照年龄升序排列的结构化数组</span></span><br></pre></td></tr></table></figure></div><h4 id="访问结构化数组中的数据"><a href="#访问结构化数组中的数据" class="headerlink" title="访问结构化数组中的数据"></a>访问结构化数组中的数据</h4><p>可以通过字段名访问结构化数组中的数据，这使得操作结构化数据变得非常方便。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出所有人的姓名和年龄</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有人的姓名：&quot;</span>, arr[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有人的年龄：&quot;</span>, arr[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问特定位置的姓名和年龄</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二个人的姓名：&quot;</span>, arr[<span class="number">1</span>][<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第三个人的年龄：&quot;</span>, arr[<span class="number">2</span>][<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure></div><p>这份笔记已经概述了NumPy中一些特殊函数的使用，包括<code>numpy.argsort()</code>, <code>numpy.lexsort()</code>, <code>numpy.insert()</code>, <code>numpy.delete()</code>, 和<code>numpy.unique()</code>等函数，以及数组堆叠的基本概念。下面我将对这些主题进行扩展和细化，以提供更加全面和专业的视角。</p><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><h4 id="numpy-argsort"><a href="#numpy-argsort" class="headerlink" title="numpy.argsort()"></a><code>numpy.argsort()</code></h4><ul><li><strong>功能</strong>: 返回数组排序后的索引。</li><li><strong>语法</strong>: <code>numpy.argsort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)</code><ul><li><strong>a</strong>: 要排序的数组。</li><li><strong>axis</strong>: 沿着哪个轴排序，默认为 <code>-1</code>，表示沿最后一个轴排序。</li><li><strong>kind</strong>: 排序算法，可选<code>&#39;quicksort&#39;</code>、<code>&#39;mergesort&#39;</code>、<code>&#39;heapsort&#39;</code>，默认为 <code>&#39;quicksort&#39;</code>。</li><li><strong>order</strong>: 结构化数组排序时指定字段。</li></ul></li></ul><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一维数组示例</span></span><br><span class="line">arr = np.array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line">sorted_indices = np.argsort(arr)</span><br><span class="line"><span class="built_in">print</span>(sorted_indices)  <span class="comment"># 输出：[1 2 0 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组示例</span></span><br><span class="line">ar = np.reshape(np.arange(<span class="number">16</span>), (<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">sorted_indices = np.argsort(ar)</span><br><span class="line"><span class="built_in">print</span>(sorted_indices)  <span class="comment"># 输出每行元素排序后的索引</span></span><br></pre></td></tr></table></figure></div><h4 id="numpy-lexsort"><a href="#numpy-lexsort" class="headerlink" title="numpy.lexsort()"></a><code>numpy.lexsort()</code></h4><ul><li><strong>功能</strong>: 对多个序列进行间接排序。</li><li><strong>语法</strong>: <code>numpy.lexsort(keys, axis=-1)</code><ul><li><strong>keys</strong>: 排序的键值对，多个序列的元组或数组。</li><li><strong>axis</strong>: 排序轴，默认为 <code>-1</code>。</li></ul></li></ul><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Kate&#x27;</span>, <span class="string">&#x27;John&#x27;</span>])</span><br><span class="line">ages = np.array([<span class="number">25</span>, <span class="number">22</span>, <span class="number">30</span>])</span><br><span class="line">sorted_indices = np.lexsort((names, ages))  <span class="comment"># 先按ages排序，若相同则按names排序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_indices)  <span class="comment"># 输出：[1 0 2]</span></span><br></pre></td></tr></table></figure></div><h3 id="数据的添加"><a href="#数据的添加" class="headerlink" title="数据的添加"></a>数据的添加</h3><p>在你的笔记中，你提到了使用<code>np.append()</code>函数在NumPy数组中添加元素的不同情况，包括未指定轴时的行为以及如何沿特定轴添加元素。下面，我将对这部分内容进行更专业和详细的整理，同时纠正一些错误用法。</p><h4 id="numpy-append"><a href="#numpy-append" class="headerlink" title="numpy.append()"></a><code>numpy.append()</code></h4><p><code>np.append()</code> 函数用于在数组的末尾添加元素。这个函数可以处理不同维度的数组，但其行为会根据是否指定<code>axis</code>参数而改变。</p><h5 id="未指定轴（默认行为）"><a href="#未指定轴（默认行为）" class="headerlink" title="未指定轴（默认行为）"></a>未指定轴（默认行为）</h5><p>当未指定<code>axis</code>参数时，<code>np.append()</code>会先将输入数组扁平化为一维数组，然后再添加元素。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr0 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 未指定轴，结果为一维数组</span></span><br><span class="line">result = np.append(arr0, [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [1 2 3 4 5 6 7 8 9]</span></span><br></pre></td></tr></table></figure></div><p>这说明，如果没有明确指定<code>axis</code>，无论原数组的维度如何，结果都会是一维数组。</p><h5 id="指定轴进行添加"><a href="#指定轴进行添加" class="headerlink" title="指定轴进行添加"></a>指定轴进行添加</h5><ul><li><strong>沿着行添加（<code>axis=0</code>）</strong></li></ul><p>当指定<code>axis=0</code>时，元素或数组将会作为新行添加到原数组中。这要求新添加的数组在非指定轴的维度上与原数组相匹配。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沿着行（axis=0）添加</span></span><br><span class="line">result = np.append(arr0, [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]], axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  </span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]</span></span><br><span class="line"><span class="comment">#  [7 8 9]]</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>沿着列添加（<code>axis=1</code>）</strong></li></ul><p>沿列添加要求新添加的行数与原数组匹配。下面是一个正确的例子，展示了如何沿列正确添加元素：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沿着列（axis=1）正确添加</span></span><br><span class="line">result = np.append(arr0, [[<span class="number">7</span>], [<span class="number">8</span>]], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [[1 2 3 7]</span></span><br><span class="line"><span class="comment">#  [4 5 6 8]]</span></span><br></pre></td></tr></table></figure></div><p>注意，在尝试沿着列添加时，你需要确保添加的数组在行的数量上与原数组一致。下面是一个修正的示例，正确展示了如何沿列添加多个元素：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确的沿列添加</span></span><br><span class="line">result = np.append(arr0, [[<span class="number">7</span>, <span class="number">10</span>], [<span class="number">8</span>, <span class="number">11</span>], [<span class="number">9</span>, <span class="number">12</span>]], axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [[ 1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6]</span></span><br><span class="line"><span class="comment">#  [ 7 10]</span></span><br><span class="line"><span class="comment">#  [ 8 11]</span></span><br><span class="line"><span class="comment">#  [ 9 12]]</span></span><br></pre></td></tr></table></figure></div><h4 id="numpy-insert"><a href="#numpy-insert" class="headerlink" title="numpy.insert()"></a><code>numpy.insert()</code></h4><ul><li><strong>功能</strong>: 在指定位置插入元素。</li><li><strong>语法</strong>: <code>numpy.insert(arr, obj, values, axis=None)</code><ul><li><strong>arr</strong>: 输入数组。</li><li><strong>obj</strong>: 插入的索引位置。</li><li><strong>values</strong>: 要插入的值或数组。</li><li><strong>axis</strong>: 指定的轴向。</li></ul></li></ul><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组示例</span></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">arr = np.insert(arr, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;插入后的数组：&quot;</span>, arr)  <span class="comment"># 输出：[1 2 10 3 4 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组示例</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">arr = np.insert(arr, <span class="number">1</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)  <span class="comment"># 在第1行后插入一行[7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><h3 id="数据的删除与去重"><a href="#数据的删除与去重" class="headerlink" title="数据的删除与去重"></a>数据的删除与去重</h3><p>这份笔记已经概述了<code>numpy.delete()</code>函数的使用，<code>numpy.unique()</code>函数的多个功能，以及如何使用<code>numpy.hstack()</code>和<code>numpy.vstack()</code>进行数组的堆叠。我将对这些内容进行更详细的整理和补充，以提供一个全面的视角。</p><h4 id="numpy-delete-函数"><a href="#numpy-delete-函数" class="headerlink" title="numpy.delete()函数"></a><code>numpy.delete()</code>函数</h4><p><code>numpy.delete()</code>用于删除数组中的元素。</p><ul><li><p><strong>语法</strong>: <code>numpy.delete(arr, obj, axis=None)</code></p><ul><li><strong>arr</strong>: 输入数组。</li><li><strong>obj</strong>: 表示要删除的子数组的索引。</li><li><strong>axis</strong>: 指定要从哪个轴删除元素。如果不指定，输入数组将会被展平。</li></ul></li></ul><p>示例</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数组</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 未指定轴，数组被展平后删除指定索引的元素</span></span><br><span class="line"><span class="built_in">print</span>(np.delete(a, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第二行</span></span><br><span class="line"><span class="built_in">print</span>(np.delete(a, <span class="number">1</span>, axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第二列</span></span><br><span class="line"><span class="built_in">print</span>(np.delete(a, <span class="number">1</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引删除多列</span></span><br><span class="line">a = np.delete(a, [<span class="number">0</span>, <span class="number">2</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引删除多行</span></span><br><span class="line">a = np.delete(a, [<span class="number">0</span>], axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></div><h4 id="numpy-unique-函数"><a href="#numpy-unique-函数" class="headerlink" title="numpy.unique()函数"></a><code>numpy.unique()</code>函数</h4><p><code>numpy.unique()</code>用于找出数组中的唯一值并返回已排序的结果。</p><ul><li><p><strong>语法</strong>: <code>numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None)</code></p><ul><li><strong>ar</strong>: 输入数组。</li><li><strong>return_index</strong>: 如果为<code>True</code>，返回唯一值的原始索引。</li><li><strong>return_inverse</strong>: 如果为<code>True</code>，返回重构原数组的索引数组。</li><li><strong>return_counts</strong>: 如果为<code>True</code>，返回每个唯一值的出现次数。</li></ul></li></ul><p>示例</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line">u = np.unique(a)</span><br><span class="line"><span class="built_in">print</span>(u)  <span class="comment"># 返回唯一值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回唯一值及其原始索引</span></span><br><span class="line">u, indices = np.unique(a, return_index=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(indices)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回唯一值及其出现次数</span></span><br><span class="line">u, counts = np.unique(a, return_counts=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(counts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回重构原数组的索引数组</span></span><br><span class="line">u, inverse = np.unique(a, return_inverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(inverse)</span><br></pre></td></tr></table></figure></div><h3 id="数组的堆叠"><a href="#数组的堆叠" class="headerlink" title="数组的堆叠"></a>数组的堆叠</h3><ul><li>**<code>numpy.hstack()</code>**：水平堆叠数组。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">ar1 = np.hstack((a, b))</span><br><span class="line"><span class="built_in">print</span>(ar1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于一维数组</span></span><br><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">b = np.arange(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line">ar1 = np.hstack((a, b))</span><br><span class="line"><span class="built_in">print</span>(ar1)</span><br></pre></td></tr></table></figure></div><ul><li>**<code>numpy.vstack()</code>**：垂直堆叠数组。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">ar2 = np.vstack((a, b))</span><br><span class="line"><span class="built_in">print</span>(ar2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形状不同的数组也可以垂直堆叠</span></span><br><span class="line">a = np.array([[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]])</span><br><span class="line">b = np.array([[<span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>]])</span><br><span class="line">ar2 = np.vstack((a, b))</span><br><span class="line"><span class="built_in">print</span>(ar2, ar2.shape)</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <ul><li>当使用<code>np.vstack()</code>和<code>np.hstack()</code>进行堆叠时，形状的兼容性是关键：对于<code>np.hstack()</code>，输入数组必须在除了第一个轴以外的维度上有相同的形状；对于<code>np.vstack()</code>，则是在第一个轴以外的其他轴必须形状相同。</li><li>当形状不完全匹配时，可以通过调整数组形状或使用不同的堆叠函数（如<code>np.concatenate()</code>）来实现堆叠。</li></ul>    </div>  </div>]]></content>
    
    
    <summary type="html">Python NumPy包</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="NumPy" scheme="https://www.yiuhangblog.com/tags/NumPy/"/>
    
    <category term="数据分析" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>迭代器和生成器, 数据结构</title>
    <link href="https://www.yiuhangblog.com/2018/10/18/20181018%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://www.yiuhangblog.com/2018/10/18/20181018%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2018-10-18T06:04:36.000Z</published>
    <updated>2024-02-28T10:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><p>在 Python 中，推导式（Comprehensions）提供了一种简洁且高效的方式来创建和操作数据集合。推导式可以应用于列表（list）、字典（dict）、集合（set）以及元组（tuple，仅在 Python 3.8 及以上版本中以生成器表达式的形式支持）。通过使用推导式，可以从一个已存在的数据序列生成一个新的数据序列，同时还可以在过程中对数据进行过滤和转换。</p><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>列表推导式是最常用的推导式类型之一，它允许快速生成列表，格式如下：</p><ul><li><p><strong>基本形式</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表]</span><br></pre></td></tr></table></figure></div><p>其中，<code>表达式</code>为每个元素的生成公式，<code>for 变量 in 列表</code>部分则是迭代原列表中的每一个元素。</p></li><li><p><strong>带有条件的形式</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br></pre></td></tr></table></figure></div><p>在这种形式中，<code>if 条件</code>用于筛选符合条件的元素，仅对这些元素应用表达式生成新的列表元素。</p></li></ul><p>在 Python 中，除了列表推导式之外，还支持字典推导式、集合推导式和元组推导式（实际上是生成器表达式）。这些推导式提供了一种高效、简洁的方式来生成新的集合数据类型。以下是对这些推导式的详细介绍和示例。</p><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><p>字典推导式用于创建字典，基本格式如下：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection&#125;</span><br></pre></td></tr></table></figure></div><p>或者，如果需要根据条件过滤元素：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure></div><ul><li>**<code>key_expr</code>**：键表达式，定义如何生成字典的键。</li><li>**<code>value_expr</code>**：值表达式，定义如何生成字典的值。</li><li>**<code>collection</code>**：一个可迭代对象，如列表、元组、集合等。</li><li>**<code>condition</code>**：一个布尔表达式，用于过滤哪些元素应该被包含在新字典中。</li></ul><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><p>集合推导式用于创建集合，基本格式如下：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span>&#125;</span><br></pre></td></tr></table></figure></div><p>或者，带有条件的形式：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional&#125;</span><br></pre></td></tr></table></figure></div><p>集合推导式类似于列表推导式，但它生成的是集合，因此结果中自动去除了重复元素。</p><h3 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h3><p>虽然通常称之为元组推导式，但实际上 Python 使用的是生成器表达式来生成元组。生成器表达式返回一个生成器对象，而不是一个立即执行的集合。基本格式如下：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span>)</span><br></pre></td></tr></table></figure></div><p>或者，带有条件的形式：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional)</span><br></pre></td></tr></table></figure></div><p>生成器表达式使用圆括号<code>()</code>，与列表推导式的中括号<code>[]</code>和字典、集合推导式的大括号<code>&#123;&#125;</code>相区分。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h3 id="推导式示例"><a href="#推导式示例" class="headerlink" title="推导式示例"></a>推导式示例</h3><ul><li><p><strong>列表推导式示例</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure></div></li><li><p><strong>字典推导式示例</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">square_dict = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>集合推导式示例</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">square_set = &#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>元组（生成器）推导式示例</strong>：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">square_gen = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>python中的迭代器是访问集合的一种方式，每次访问记住遍历的位置。</p><p>迭代（Iteration）是指重复执行某个过程的行为，每次都在基于上一次的结果进行操作。在编程中，迭代通常用于遍历数据结构中的元素，例如列表、字典等。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p><ul><li>迭代器通过 iter()将一个可迭代对象变成迭代器，例如list tuple  dict set  str等，还有就是后面讲到的生成器（generator） 都是可迭代对象</li><li>通过next()或者for循环访问迭代的数据</li></ul><p>Python中常见的<a class="link"   href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020" >迭代器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>有：</p><ol><li>列表迭代器：使用<strong>for</strong>循环遍历列表。</li><li>字典迭代器：使用<strong>for</strong>循环遍历字典的键、值或键值对。</li><li>文件迭代器：使用<strong>for</strong>循环遍历文件中的行。</li><li>生成器：使用<strong>yield</strong>语句来生成迭代器，可以节省内存空间和计算资源。</li><li>itertools模块中的迭代器：包括<strong>count</strong>、<strong>cycle</strong>、<strong>repeat</strong>、<strong>chain</strong>、<strong>zip_longest</strong>、<strong>islice</strong>、<strong>takewhile</strong>、<strong>dropwhile</strong>等。这些迭代器可以实现更加复杂的迭代操作</li></ol><p><strong>语法和参数说明</strong></p><p>iter函数是一个内置函数，用于创建一个迭代器对象。迭代器是一种特殊的对象，可以通过调用next()函数来逐个访问其中的元素。iter函数接受一个可迭代对象作为参数，并返回一个迭代器对象</p><p>iter函数的语法如下所示：</p><p><code>iter(iterable)</code> </p><p>其中，iterable是一个可迭代对象，比如列表、元组、字符串等</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在 Python 中，使用了 <strong>yield</strong> 的函数被称为生成器（generator）。</p><p><strong>yield</strong> 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>当在生成器函数中使用 <strong>yield</strong> 语句时，函数的执行将会暂停，并将 <strong>yield</strong> 后面的表达式作为当前迭代的值返回。</p><p>然后，每次调用生成器的 <strong>next()</strong> 方法或使用 <strong>for</strong> 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 <strong>yield</strong> 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><p>下面是一个简单的示例，展示了生成器函数的使用：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):    </span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:        </span><br><span class="line">        <span class="keyword">yield</span> n        </span><br><span class="line">        n -= <span class="number">1</span>  </span><br><span class="line"><span class="comment"># 创建生成器对象 </span></span><br><span class="line">generator = countdown(<span class="number">5</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过迭代生成器获取值 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3  </span></span><br><span class="line"><span class="comment"># 使用 for 循环迭代生成器 </span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> generator:    </span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 2 1</span></span><br></pre></td></tr></table></figure></div><p>上实例中，<strong>countdown</strong> 函数是一个生成器函数。它使用 yield 语句逐步产生从 n 到 1 的倒数数字。在每次调用 yield 语句时，函数会返回当前的倒数值，并在下一次调用时从上次暂停的地方继续执行。</p><p>通过创建生成器对象并使用 next() 函数或 for 循环迭代生成器，我们可以逐步获取生成器函数产生的值。在这个例子中，我们首先使用 next() 函数获取前三个倒数值，然后通过 for 循环获取剩下的两个倒数值。</p><p>生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。此外，生成器还可以与其他迭代工具（如for循环）无缝配合使用，提供简洁和高效的迭代方式。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在网络上储存了各种形式的数据，当数据量大了的时候，我们对数据进行 增、减、改、查都是建立在数据结构上的。 pthon的数据结构有四种，分别是：列表、字典、元组、集合。这四种代表四种储存数据的方式。</p><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p>Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能，列表是Python中最基本的数据结构。列表的方法如<code>append()</code>, <code>count()</code>, <code>extend()</code>, <code>index()</code>, <code>insert()</code>, <code>pop()</code>, <code>remove()</code>, <code>reverse()</code>, 和 <code>sort()</code> 提供了丰富的操作，使得列表成为处理序列数据的强大工具。</p><p>以下是 Python 中列表的方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a class="link"   href="https://www.runoob.com/python/att-list-append.html" >list.append(obj) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 在列表末尾添加新的对象</td></tr><tr><td align="left">2</td><td align="left"><a class="link"   href="https://www.runoob.com/python/att-list-count.html" >list.count(obj) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 统计某个元素在列表中出现的次数</td></tr><tr><td align="left">3</td><td align="left"><a class="link"   href="https://www.runoob.com/python/att-list-extend.html" >list.extend(seq) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left">4</td><td align="left"><a class="link"   href="https://www.runoob.com/python/att-list-index.html" >list.index(obj) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left">5</td><td align="left"><a class="link"   href="https://www.runoob.com/python/att-list-insert.html" >list.insert(index, obj) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 将对象插入列表</td></tr><tr><td align="left">6</td><td align="left">[list.pop(<a class="link"   href="https://www.runoob.com/python/att-list-pop.html" >index&#x3D;-1]) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left">7</td><td align="left"><a class="link"   href="https://www.runoob.com/python/att-list-remove.html" >list.remove(obj) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 移除列表中某个值的第一个匹配项</td></tr><tr><td align="left">8</td><td align="left"><a class="link"   href="https://www.runoob.com/python/att-list-reverse.html" >list.reverse() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 反向列表中元素</td></tr><tr><td align="left">9</td><td align="left"><a class="link"   href="https://www.runoob.com/python/att-list-sort.html" >list.sort(cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 对原列表进行排序</td></tr></tbody></table><h3 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h3><p>列表切片提供了一种灵活访问列表部分元素的方法。通过指定索引范围，可以轻松获取、修改或删除列表的一部分，这是处理和分析数据时常用的技术。</p><p>list&#x3D;[1,2,3,4,5] 列表是可以切片的，就像我们切面包一样，你想要中间的面包就切中间，要左边就切左边。这个功能有什么用呢，主要作用就是能够让我们对列表中的数值进行索引。</p><p>我们要先将列表中的元素进行排序，排序从0开始，如[1,2,3,4,5]分别对应0,1,2,3,4 ,然后通过list&#x3D;[元素序号:元素序号]进行索引，或者直接填入位置编号。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/aaba4e3b-f63c-41ec-7dad-ee839398ea00/public"                      width = "400"                ><h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><p><strong>建立字典</strong></p><p>字典是一种映射类型，它存储键值对，其中键是唯一的。字典的直观性和快速访问特性使它成为存储和操作关联数据的理想选择。创建和访问字典都非常简单高效，是处理复杂数据结构时常用的数据类型。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myInformation=&#123;<span class="string">&quot;myName&quot;</span>:<span class="string">&quot;zhangzexiang&quot;</span>&#125; <span class="comment">#&quot;myName&quot;就是键，&quot;zhangzexiang&quot;就是值。</span></span><br><span class="line"><span class="built_in">print</span>(myInformation)</span><br><span class="line"></span><br><span class="line">myInformation=&#123;<span class="string">&quot;MyName&quot;</span>:<span class="string">&quot;zhangzexiang&quot;</span>,<span class="string">&quot;Sex&quot;</span>:<span class="string">&quot;man&quot;</span>,<span class="string">&quot;Age&quot;</span>:<span class="string">&quot;100&quot;</span>&#125; <span class="comment">#包含了姓名、性别、年龄</span></span><br><span class="line"><span class="built_in">print</span>(myInformation)</span><br></pre></td></tr></table></figure></div><h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><p>元组是不可变的序列类型，这意味着一旦创建，元组中的元素不能被修改。元组的不可变性使其成为存储不应改变数据的理想选择，例如函数的参数列表。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></div><h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p>集合是一个无序的、不包含重复元素的集。它提供了许多标准的集合操作，如并集、交集、差集等。集合的独特性和操作使其成为处理非重复项集时的理想选择。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.add(<span class="number">6</span>)  <span class="comment">#添加</span></span><br><span class="line">a.discard(<span class="number">1</span>)  <span class="comment">#删除</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></div><p>让我们通过具体的Python代码示例深入理解堆栈和队列的实现及其应用。</p><h3 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h3><p>堆栈是一种遵循后进先出（LIFO）原则的数据结构。在Python中，列表的<code>append()</code>方法用于添加元素到列表的末尾，而<code>pop()</code>方法用于移除列表末尾的元素。这两个方法使得列表可以非常方便地被用作堆栈。</p><p><strong>示例：使用列表实现堆栈</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向堆栈添加元素</span></span><br><span class="line">stack.append(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">stack.append(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">stack.append(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Initial stack:&quot;</span>, stack)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出堆栈顶的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Popped element:&quot;</span>, stack.pop())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Stack after popping:&quot;</span>, stack)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次弹出堆栈顶的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Popped element:&quot;</span>, stack.pop())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Stack after popping:&quot;</span>, stack)</span><br></pre></td></tr></table></figure></div><p>在这个示例中，我们首先创建了一个空列表<code>stack</code>作为堆栈。然后，我们通过<code>append()</code>方法向堆栈中添加了三个元素。通过调用<code>pop()</code>方法，我们移除了堆栈顶的元素，并打印了每次弹出操作后堆栈的状态。</p><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列是一种遵循先进先出（FIFO）原则的数据结构。尽管可以使用列表来实现队列，但在列表的开始位置插入或删除元素的效率较低。因此，Python的<code>collections</code>模块提供了<code>deque</code>（双端队列），它是为两端都可以高效操作（添加和删除元素）而设计的。</p><p><strong>示例：使用<code>collections.deque</code>实现队列</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的双端队列</span></span><br><span class="line">queue = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向队列中添加元素</span></span><br><span class="line">queue.append(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">queue.append(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">queue.append(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Initial queue:&quot;</span>, <span class="built_in">list</span>(queue))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列中移除元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Popped element:&quot;</span>, queue.popleft())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Queue after popping:&quot;</span>, <span class="built_in">list</span>(queue))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次从队列中移除元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Popped element:&quot;</span>, queue.popleft())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Queue after popping:&quot;</span>, <span class="built_in">list</span>(queue))</span><br></pre></td></tr></table></figure></div><p>在这个示例中，我们首先导入了<code>collections.deque</code>，然后创建了一个名为<code>queue</code>的双端队列。我们通过<code>append()</code>方法在队列末尾添加了元素，并通过<code>popleft()</code>方法从队列的开始位置移除了元素。每次操作后，我们打印了队列的当前状态，以展示队列的先进先出特性。</p>]]></content>
    
    
    <summary type="html">Python 迭代器和生成器基础, 数据结构</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="基本语法" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    <category term="迭代器" scheme="https://www.yiuhangblog.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="生成器" scheme="https://www.yiuhangblog.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    <category term="数据结构" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://www.yiuhangblog.com/2018/10/12/20181012%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.yiuhangblog.com/2018/10/12/20181012%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2018-10-12T10:24:40.000Z</published>
    <updated>2024-02-28T10:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在Python中，正则表达式的功能通过 <code>re</code> 模块提供。这个模块包含了各种基于正则表达式的操作，比如匹配、查找、替换等。</p><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h3><p><code>re.match()</code> 方法用于从字符串的开始位置匹配一个模式。如果匹配成功，返回一个匹配对象；如果不匹配，返回 <code>None</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;Hello&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match found:&quot;</span>, <span class="keyword">match</span>.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No match&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>这个例子中，<code>pattern</code> 是我们要查找的模式（”Hello”），而 <code>string</code> 是我们要搜索的字符串（”Hello World”）。由于 “Hello World” 以 “Hello” 开头，所以 <code>re.match()</code> 会找到一个匹配。</p><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h3><p><code>re.search()</code> 方法在整个字符串中搜索模式的第一个匹配项。如果找到匹配项，返回一个匹配对象；如果没有找到，返回 <code>None</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;World&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">search = re.search(pattern, string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> search:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match found:&quot;</span>, search.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No match&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>在这个例子中，尽管 “World” 不是字符串 “Hello World” 的开始部分，<code>re.search()</code> 依然可以找到匹配项。</p><h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall()"></a>re.findall()</h3><p><code>re.findall()</code> 方法在字符串中找到正则表达式所匹配的所有子串，并返回一个列表。如果没有找到匹配的，则返回一个空列表。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;l&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">findall = re.findall(pattern, string)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Matches found:&quot;</span>, findall)</span><br></pre></td></tr></table></figure></div><p>这里，<code>re.findall()</code> 查找 “Hello World” 中所有的 “l” 字符。因此，它会返回 <code>[&#39;l&#39;, &#39;l&#39;]</code>。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>正则表达式是一个复杂的主题，有很多特殊字符和模式，如特殊字符 <code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;&#125;</code>，以及字符类 <code>[]</code> 等。</li><li>在使用 <code>re</code> 模块时，通常建议使用原始字符串（如 <code>r&quot;Hello&quot;</code>），这样可以避免Python对字符串中的反斜杠进行转义。</li><li>返回的匹配对象有多个方法，如 <code>group()</code>，可以用来获取匹配的特定部分。</li></ul><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th>元字符</th><th>描述</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任何单个字符（除换行符）</td><td><code>&quot;.a&quot;</code></td><td>匹配 ‘ca’ 在 “cat” 中</td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td><td><code>&quot;^Hello&quot;</code></td><td>匹配 ‘Hello’ 在 “Hello World” 的开始</td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td><td><code>&quot;World$&quot;</code></td><td>匹配 ‘World’ 在 “Hello World” 的结束</td></tr><tr><td><code>*</code></td><td>匹配0次或多次前面的字符</td><td><code>&quot;ho*&quot;</code></td><td>匹配 ‘hooo’ 在 “hoooray” 中</td></tr><tr><td><code>+</code></td><td>匹配1次或多次前面的字符</td><td><code>&quot;ho+&quot;</code></td><td>匹配 ‘hooo’ 在 “hoooray” 中</td></tr><tr><td><code>?</code></td><td>匹配0次或1次前面的字符</td><td><code>&quot;ho?&quot;</code></td><td>匹配 ‘ho’ 在 “hoooray” 中</td></tr><tr><td><code>&#123;m,n&#125;</code></td><td>匹配至少 m 次，最多 n 次前面的字符</td><td><code>&quot;(ho)&#123;1,2&#125;&quot;</code></td><td>匹配 ‘hoho’ 在 “hohohooray” 中</td></tr><tr><td><code>[]</code></td><td>匹配方括号中的任意一个字符</td><td><code>&quot;[Hh]ello&quot;</code></td><td>匹配 ‘hello’ 在 “hello” 中</td></tr><tr><td><code>[^]</code></td><td>匹配不在方括号中的任意一个字符</td><td><code>&quot;[^abc]&quot;</code></td><td>匹配 ‘g’ 在 “g” 中</td></tr><tr><td>&#96;</td><td>&#96;</td><td>“或” 操作，匹配符号左或右的字符</td><td>&#96;”cat</td></tr><tr><td><code>()</code></td><td>创建捕获组</td><td>&#96;”(hello</td><td>hi) (world</td></tr><tr><td><code>\d</code></td><td>匹配任何十进制数字</td><td><code>&quot;\d+&quot;</code></td><td>匹配 ‘1234’ 在 “Room number: 1234” 中</td></tr><tr><td><code>\D</code></td><td>匹配任何非数字字符</td><td><code>&quot;\D+&quot;</code></td><td>匹配 ‘ABC’ 在 “1234ABC” 中</td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符</td><td><code>&quot;\s&quot;</code></td><td>匹配空格在 “Hello World” 中</td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符</td><td><code>&quot;\S+&quot;</code></td><td>匹配 ‘Hello’ 在 “ Hello World” 中</td></tr><tr><td><code>\w</code></td><td>匹配任何字母数字字符</td><td><code>&quot;\w+&quot;</code></td><td>匹配 ‘_hello123’ 在 “_hello123” 中</td></tr><tr><td><code>\W</code></td><td>匹配任何非字母数字字符</td><td><code>&quot;\W+&quot;</code></td><td>匹配 ‘,’ 在 “Hello, World!” 中</td></tr><tr><td><code>\b</code></td><td>匹配一个单词边界</td><td><code>&quot;\bWorld\b&quot;</code></td><td>匹配 ‘World’ 在 “Hello World!” 中</td></tr><tr><td><code>\B</code></td><td>匹配非单词边界</td><td><code>&quot;\BWorld\B&quot;</code></td><td>在 “HelloWorld!” 中不匹配</td></tr></tbody></table><h3 id="点号"><a href="#点号" class="headerlink" title="点号 (.)"></a>点号 (.)</h3><p>表示任何单个字符（除了换行符）。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;.a&quot;</span></span><br><span class="line">string = <span class="string">&quot;cat&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: ca</span></span><br></pre></td></tr></table></figure></div><h3 id="脱字符"><a href="#脱字符" class="headerlink" title="脱字符 (^)"></a>脱字符 (^)</h3><p>匹配字符串的开头。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;^Hello&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: Hello</span></span><br></pre></td></tr></table></figure></div><h3 id="美元符号"><a href="#美元符号" class="headerlink" title="美元符号 ($)"></a>美元符号 ($)</h3><p>匹配字符串的结尾。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;World$&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: World</span></span><br></pre></td></tr></table></figure></div><h3 id="星号"><a href="#星号" class="headerlink" title="星号 (*)"></a>星号 (*)</h3><p>表示0次或多次匹配前面的字符。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;ho*&quot;</span></span><br><span class="line">string = <span class="string">&quot;hoooray&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: hooo</span></span><br></pre></td></tr></table></figure></div><h3 id="加号"><a href="#加号" class="headerlink" title="加号 (+)"></a>加号 (+)</h3><p>表示1次或多次匹配前面的字符。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;ho+&quot;</span></span><br><span class="line">string = <span class="string">&quot;hoooray&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: hooo</span></span><br></pre></td></tr></table></figure></div><h3 id="问号"><a href="#问号" class="headerlink" title="问号 (?)"></a>问号 (?)</h3><p>表示0次或1次匹配前面的字符。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;ho?&quot;</span></span><br><span class="line">string = <span class="string">&quot;hoooray&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: ho</span></span><br></pre></td></tr></table></figure></div><h3 id="花括号-m-n"><a href="#花括号-m-n" class="headerlink" title="花括号 ({m,n})"></a>花括号 ({m,n})</h3><p>表示至少 m 次，最多 n 次匹配前面的字符。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;(ho)&#123;1,2&#125;&quot;</span></span><br><span class="line">string = <span class="string">&quot;hohohooray&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: hoho</span></span><br></pre></td></tr></table></figure></div><h3 id="方括号"><a href="#方括号" class="headerlink" title="方括号 ([])"></a>方括号 ([])</h3><p>用于表示一组字符中的任何一个字符。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;[Hh]ello&quot;</span></span><br><span class="line">string = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: hello</span></span><br></pre></td></tr></table></figure></div><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠 ()"></a>反斜杠 ()</h3><p>用于转义特殊字符或表示特殊序列。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;\d&quot;</span>  <span class="comment"># \d 表示任何数字</span></span><br><span class="line">string = <span class="string">&quot;number 5&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure></div><h3 id="竖杠"><a href="#竖杠" class="headerlink" title="竖杠 (|)"></a>竖杠 (|)</h3><p>表示“或”操作。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;cat|dog&quot;</span></span><br><span class="line">string = <span class="string">&quot;I like cats&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: cat</span></span><br></pre></td></tr></table></figure></div><h3 id="小括号"><a href="#小括号" class="headerlink" title="小括号 (())"></a>小括号 (())</h3><p>用于创建捕获组。</p><p><strong>示例：</strong></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;(hello|hi) (world|earth)&quot;</span></span><br><span class="line">string = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: hello world</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">1</span>)) <span class="comment"># 输出: hello</span></span><br></pre></td></tr></table></figure></div><h3 id="数字和字母的特殊序列"><a href="#数字和字母的特殊序列" class="headerlink" title="数字和字母的特殊序列"></a>数字和字母的特殊序列</h3><ul><li><p><code>\d</code>: 匹配任何十进制数字，等同于 <code>[0-9]</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;\d+&quot;</span></span><br><span class="line">string = <span class="string">&quot;Room number: 1234&quot;</span></span><br><span class="line"><span class="built_in">print</span>(re.search(pattern, string).group())  <span class="comment"># 输出: 1234</span></span><br></pre></td></tr></table></figure></div></li><li><p><code>\D</code>: 匹配任何非数字字符，等同于 <code>[^0-9]</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;\D+&quot;</span></span><br><span class="line">string = <span class="string">&quot;1234ABC&quot;</span></span><br><span class="line"><span class="built_in">print</span>(re.search(pattern, string).group())  <span class="comment"># 输出: ABC</span></span><br></pre></td></tr></table></figure></div></li><li><p><code>\s</code>: 匹配任何空白字符。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;\s&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(re.search(pattern, string).group())  <span class="comment"># 输出: （空格字符）</span></span><br></pre></td></tr></table></figure></div></li><li><p><code>\S</code>: 匹配任何非空白字符。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;\S+&quot;</span></span><br><span class="line">string = <span class="string">&quot; Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(re.search(pattern, string).group())  <span class="comment"># 输出: Hello</span></span><br></pre></td></tr></table></figure></div></li><li><p><code>\w</code>: 匹配任何字母数字字符，等同于 <code>[a-zA-Z0-9_]</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;\w+&quot;</span></span><br><span class="line">string = <span class="string">&quot;_hello123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(re.search(pattern, string).group())  <span class="comment"># 输出: _hello123</span></span><br></pre></td></tr></table></figure></div></li><li><p><code>\W</code>: 匹配任何非字母数字字符，等同于 <code>[^a-zA-Z0-9_]</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;\W+&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(re.search(pattern, string).group())  <span class="comment"># 输出: , </span></span><br></pre></td></tr></table></figure></div></li></ul><h3 id="边界匹配符"><a href="#边界匹配符" class="headerlink" title="边界匹配符"></a>边界匹配符</h3><ul><li><p>\A 和 \Z</p><p><code>\A</code> 和 <code>\Z</code> 分别用于匹配字符串的开头和结尾。它们类似于 <code>^</code> 和 <code>$</code>，但主要区别在于，<code>\A</code> 和 <code>\Z</code> 不受多行模式的影响，而 <code>^</code> 和 <code>$</code> 在多行模式（<code>re.MULTILINE</code>）下分别匹配每一行的开头和结尾。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># \A 匹配字符串开头</span></span><br><span class="line">pattern = <span class="string">r&quot;\AHello&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \Z 匹配字符串结尾</span></span><br><span class="line">pattern = <span class="string">r&quot;World\Z&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: World</span></span><br></pre></td></tr></table></figure></div></li><li><p><code>\b</code>: 匹配一个单词边界，即单词和空格之间的位置。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配单词边界</span></span><br><span class="line">pattern = <span class="string">r&quot;\bWorld\b&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: World</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不匹配非边界位置</span></span><br><span class="line">pattern = <span class="string">r&quot;\bWorld\b&quot;</span></span><br><span class="line">string = <span class="string">&quot;HelloWorld!&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>)  <span class="comment"># 输出: None</span></span><br></pre></td></tr></table></figure></div></li><li><p><code>\B</code>: 匹配非单词边界。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配非单词边界</span></span><br><span class="line">pattern = <span class="string">r&quot;\BWorld\B&quot;</span></span><br><span class="line">string = <span class="string">&quot;HelloWorld!&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: World</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不匹配单词边界位置</span></span><br><span class="line">pattern = <span class="string">r&quot;\BWorld\B&quot;</span></span><br><span class="line">string = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>)  <span class="comment"># 输出: None</span></span><br></pre></td></tr></table></figure></div></li></ul><h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><p> <code>r</code> 前缀在Python中用于表示原始字符串（raw string）。在正则表达式中，这个前缀非常重要，因为它确保了字符串中的特殊字符（如反斜杠 <code>\</code>）不会被Python解释器作为转义字符处理。在编写正则表达式时，建议总是使用原始字符串。</p><h3 id="为什么使用原始字符串？"><a href="#为什么使用原始字符串？" class="headerlink" title="为什么使用原始字符串？"></a>为什么使用原始字符串？</h3><p>在正则表达式中，反斜杠 <code>\</code> 用于指示特殊序列或作为转义字符。如果不使用原始字符串，Python解释器会首先解释这个反斜杠。例如，<code>\n</code> 在普通的Python字符串中表示换行符，但在正则表达式中可能表示一个特殊序列。使用原始字符串可以避免这种混淆。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>不使用原始字符串：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">&quot;\\bword\\b&quot;</span></span><br><span class="line">string = <span class="string">&quot;A word and another word.&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 这将不会工作如预期</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，每个 <code>\</code> 都必须写成 <code>\\</code>，因为Python字符串会尝试解释 <code>\b</code> 作为一个退格符。</p><p>使用原始字符串：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;\bword\b&quot;</span></span><br><span class="line">string = <span class="string">&quot;A word and another word.&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出: word</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，使用 <code>r</code> 前缀，所以 <code>\b</code> 被正确地解释为单词边界匹配符，而不是退格符。</p><p>当编写涉及到反斜杠的正则表达式时，总是使用原始字符串（如 <code>r&quot;\bword\b&quot;</code>）来确保反斜杠被正确处理。这样可以让正则表达式更易读，也减少了由于转义字符引起的错误。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="QQ邮箱"><a href="#QQ邮箱" class="headerlink" title="QQ邮箱"></a>QQ邮箱</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">mail = <span class="string">&quot;daf ghsegtw345 erw123445667@qq.com2342t ewsafc3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(re.findall(<span class="string">r&#x27;\d&#123;5,10&#125;@qq\.com&#x27;</span>, mail))</span><br></pre></td></tr></table></figure></div><h3 id="手机号"><a href="#手机号" class="headerlink" title="手机号"></a>手机号</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">phone = <span class="string">&quot;13312345678&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(re.findall(<span class="string">r&#x27;^1[3-9]\d&#123;9&#125;$&#x27;</span>, phone))</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">Python 正则表达式基础</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="基本语法" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    <category term="正则表达式" scheme="https://www.yiuhangblog.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    <category term="re模块" scheme="https://www.yiuhangblog.com/tags/re%E6%A8%A1%E5%9D%97/"/>
    
    <category term="元字符" scheme="https://www.yiuhangblog.com/tags/%E5%85%83%E5%AD%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="https://www.yiuhangblog.com/2018/10/05/20181005%E5%BC%82%E5%B8%B8/"/>
    <id>https://www.yiuhangblog.com/2018/10/05/20181005%E5%BC%82%E5%B8%B8/</id>
    <published>2018-10-05T00:15:10.000Z</published>
    <updated>2024-02-28T10:49:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a>异常（Exception）</h2><p>在Python中，异常（Exception）是程序执行过程中发生的错误事件。当Python检测到一个错误时，它会引发一个异常。异常是Python用来管理程序执行中错误的一种机制。</p><h3 id="异常的基本概念"><a href="#异常的基本概念" class="headerlink" title="异常的基本概念"></a>异常的基本概念</h3><ol><li><strong>异常 (Exception)</strong>: 这是程序执行中发生的异常事件。在Python中，异常是一个对象，表示一个错误。</li><li><strong>引发异常 (Raise an Exception)</strong>: 当Python解释器遇到一个错误时，它会”引发”一个异常。程序员也可以在代码中显式地引发异常。</li><li><strong>捕获异常 (Catch&#x2F;Handle an Exception)</strong>: 使用<code>try</code>和<code>except</code>语句来捕获并处理异常。这允许程序在发生异常时优雅地恢复，而不是完全崩溃。</li><li><strong>try块 (try block)</strong>: 这是用来测试可能引发异常的代码块。</li><li><strong>except块 (except block)</strong>: 当<code>try</code>块中的代码触发异常时执行的代码块。可以指定捕获特定类型的异常。</li><li><strong>finally块 (finally block)</strong>: 无论是否发生异常，<code>finally</code>块中的代码都会执行。常用于执行清理操作，如关闭文件。</li><li><strong>else块 (else block)</strong>: 如果<code>try</code>块没有引发异常，则执行<code>else</code>块中的代码。</li></ol><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><h4 id="ValueError"><a href="#ValueError" class="headerlink" title="ValueError"></a>ValueError</h4><p>当传递给函数的参数类型正确，但值不适当或不在预期范围内时，将引发<code>ValueError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_to_int</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(text)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请提供一个有效的整数字符串&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(convert_to_int(<span class="string">&quot;123&quot;</span>))  <span class="comment"># 输出: 123</span></span><br><span class="line"><span class="built_in">print</span>(convert_to_int(<span class="string">&quot;abc&quot;</span>))  <span class="comment"># 输出: 请提供一个有效的整数字符串</span></span><br></pre></td></tr></table></figure></div><h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p>当操作或函数应用于类型不正确的对象时，会引发<code>TypeError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;两个参数都必须是数字&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add_numbers(<span class="number">10</span>, <span class="number">20</span>))    <span class="comment"># 输出: 30</span></span><br><span class="line"><span class="built_in">print</span>(add_numbers(<span class="number">10</span>, <span class="string">&quot;20&quot;</span>))  <span class="comment"># 输出: 两个参数都必须是数字</span></span><br></pre></td></tr></table></figure></div><h4 id="IndexError"><a href="#IndexError" class="headerlink" title="IndexError"></a>IndexError</h4><p>当尝试访问序列中不存在的索引时，会引发<code>IndexError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(my_list[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;索引超出了列表的范围&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="KeyError"><a href="#KeyError" class="headerlink" title="KeyError"></a>KeyError</h4><p>当在字典中查找不存在的键时，会引发<code>KeyError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(my_dict[<span class="string">&quot;gender&quot;</span>])</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;键不存在&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="IOError"><a href="#IOError" class="headerlink" title="IOError"></a>IOError</h4><p>当尝试执行一个与输入&#x2F;输出相关的操作（如打开不存在的文件）时，会引发<code>IOError</code>（在Python 3中，通常是<code>OSError</code>或其子类）。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;nonexistent_file.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件打开失败&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="ZeroDivisionError"><a href="#ZeroDivisionError" class="headerlink" title="ZeroDivisionError"></a>ZeroDivisionError</h4><p>当尝试将一个数字除以零时，会引发<code>ZeroDivisionError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除以零错误&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="AttributeError"><a href="#AttributeError" class="headerlink" title="AttributeError"></a>AttributeError</h4><p>当尝试访问对象不存在的属性或方法时，会引发<code>AttributeError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;ChatGPT&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    obj = MyClass()</span><br><span class="line">    <span class="built_in">print</span>(obj.age)  <span class="comment"># obj没有定义age属性</span></span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;属性不存在&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError"></a>FileNotFoundError</h4><p>在尝试打开一个不存在的文件时，Python 3中会引发<code>FileNotFoundError</code>，这是<code>OSError</code>的一个子类。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;some_nonexistent_file.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件未找到&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="ImportError"><a href="#ImportError" class="headerlink" title="ImportError"></a>ImportError</h4><p>当尝试导入一个不存在的模块时，会引发<code>ImportError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> non_existent_module</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模块无法导入&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="OverflowError"><a href="#OverflowError" class="headerlink" title="OverflowError"></a>OverflowError</h4><p>当一个算术运算产生的结果太大而无法表示时，会引发<code>OverflowError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这可能会引发OverflowError</span></span><br><span class="line">    <span class="built_in">print</span>(math.exp(<span class="number">1000</span>))</span><br><span class="line"><span class="keyword">except</span> OverflowError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数值溢出&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="NameError"><a href="#NameError" class="headerlink" title="NameError"></a>NameError</h4><p>当尝试访问一个尚未声明&#x2F;定义的局部或全局变量时，会引发<code>NameError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(undefined_variable)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;变量未定义&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="RecursionError"><a href="#RecursionError" class="headerlink" title="RecursionError"></a>RecursionError</h4><p>当递归过深超过最大递归深度时，会引发<code>RecursionError</code>。这是<code>RuntimeError</code>的一个子类。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_function</span>():</span><br><span class="line">    recursive_function()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    recursive_function()</span><br><span class="line"><span class="keyword">except</span> RecursionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;递归过深&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>这些例子涵盖了Python中的一些其他常见异常类型。理解和处理这些异常对于编写稳健的Python程序至关重要。</p><h4 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h4><p>当Python解释器遇到语法错误时，会引发<code>SyntaxError</code>。这通常发生在代码编写不正确时。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;for i in range(5) print(i)&quot;</span>)  <span class="comment"># 缺少冒号</span></span><br><span class="line"><span class="keyword">except</span> SyntaxError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生了语法错误&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="IndentationError"><a href="#IndentationError" class="headerlink" title="IndentationError"></a>IndentationError</h4><p>当代码的缩进不正确时，会引发<code>IndentationError</code>，这是<code>SyntaxError</code>的一个子类。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;def foo():\nprint(&#x27;Hello&#x27;)&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> IndentationError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;缩进错误&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="AssertionError"><a href="#AssertionError" class="headerlink" title="AssertionError"></a>AssertionError</h4><p>当<code>assert</code>语句失败时，会引发<code>AssertionError</code>。<code>assert</code>用于调试阶段的自我检查。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span>, <span class="string">&quot;计算错误&quot;</span></span><br><span class="line"><span class="keyword">except</span> AssertionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;断言错误:&quot;</span>, e)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="KeyboardInterrupt"><a href="#KeyboardInterrupt" class="headerlink" title="KeyboardInterrupt"></a>KeyboardInterrupt</h4><p>当用户中断程序执行（通常是通过按Ctrl+C），会引发<code>KeyboardInterrupt</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序被用户中断&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="MemoryError"><a href="#MemoryError" class="headerlink" title="MemoryError"></a>MemoryError</h4><p>当程序运行时内存不足，无法执行操作时，会引发<code>MemoryError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    large_list = [<span class="number">0</span>] * <span class="number">10</span>**<span class="number">10</span></span><br><span class="line"><span class="keyword">except</span> MemoryError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;内存不足&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h4><p>在使用迭代器时，当没有更多的项可以返回时，会自动引发<code>StopIteration</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iterator = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">next</span>(iterator)  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">next</span>(iterator)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">next</span>(iterator)  <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">next</span>(iterator)  <span class="comment"># 迭代完毕</span></span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;迭代器没有更多元素&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="EnvironmentError"><a href="#EnvironmentError" class="headerlink" title="EnvironmentError"></a>EnvironmentError</h4><p><code>EnvironmentError</code>是在与外部环境（如操作系统）交互时可能遇到的错误的基类。在Python 3中，它被分为更具体的异常，如<code>OSError</code>。</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>这并不是一个完整的列表：</p><ul><li><code>ArithmeticError</code>: 所有数值计算错误的基类。</li><li><code>BufferError</code>: 与缓冲区相关的操作无法执行时。</li><li><code>EOFError</code>: 当<code>input()</code>遇到文件结束标记（EOF）时。</li><li><code>FloatingPointError</code>: 浮点计算错误。</li><li><code>LookupError</code>: 索引或键查询错误的基类，<code>IndexError</code>和<code>KeyError</code>是它的子类。</li><li><code>ReferenceError</code>: 当试图访问一个已经被垃圾回收器回收的资源时。</li><li><code>RuntimeError</code>: 通常发生在检测到不属于其他类别的错误时。</li><li><code>SystemError</code>: 解释器系统错误。</li><li><code>UnicodeError</code>: Unicode相关的错误，是<code>ValueError</code>的一个子类。</li><li><code>UnicodeEncodeError</code>: Unicode编码时的错误。</li><li><code>UnicodeDecodeError</code>: Unicode解码时的错误。</li><li><code>UnicodeTranslateError</code>: Unicode转换时的错误。</li></ul><h3 id="异常处理的语法"><a href="#异常处理的语法" class="headerlink" title="异常处理的语法"></a>异常处理的语法</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> ExceptionType1:</span><br><span class="line">    <span class="comment"># 处理ExceptionType1</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> ExceptionType2:</span><br><span class="line">    <span class="comment"># 处理ExceptionType2</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> (ExceptionType3, ExceptionType4):</span><br><span class="line">    <span class="comment"># 处理多种异常</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 处理未指定的其他异常</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果没有异常发生，则执行此处代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否有异常，都会执行此处代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><h4 id="捕获特定异常"><a href="#捕获特定异常" class="headerlink" title="捕获特定异常"></a>捕获特定异常</h4><p>在Python中，可以使用<code>try-except</code>块来捕获特定类型的异常。这允许您对特定错误进行专门的错误处理。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会引发异常的代码</span></span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;捕获到除以零的异常&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h4><p>捕获所有异常并且仅打印出错误信息，可以使用一个通用的 <code>except Exception as e</code> 块。这将捕获所有继承自 <code>Exception</code> 的错误（几乎包括了Python中所有的标准异常）</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会引发异常的代码</span></span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div><h4 id="使用finally块"><a href="#使用finally块" class="headerlink" title="使用finally块"></a>使用finally块</h4><p>无论是否发生异常，<code>finally</code>块中的代码都会被执行。这非常适合用来执行清理操作，如关闭文件或释放资源。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = file.read()</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取文件时发生错误：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件已关闭&quot;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h3><p>可以使用<code>raise</code>语句来主动引发异常。这在需要根据特定条件显式地触发错误时非常有用。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_age</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="keyword">if</span> age &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;年龄不能为负数&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;成年&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    check_age(-<span class="number">5</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;捕获到异常：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="使用断言（assert）"><a href="#使用断言（assert）" class="headerlink" title="使用断言（assert）"></a>使用断言（assert）</h3><p>断言是一种调试辅助工具，用于检查一个条件是否为真。如果条件为假，将引发<code>AssertionError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_age</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="keyword">assert</span> age &gt;= <span class="number">0</span>, <span class="string">&quot;年龄不能为负数&quot;</span></span><br><span class="line">    <span class="comment"># 其余处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    check_age(-<span class="number">5</span>)</span><br><span class="line"><span class="keyword">except</span> AssertionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;捕获到异常：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <ul><li><strong>断言</strong>：通常用于内部一致性检查，表示“这里不可能出错，除非程序内部逻辑有问题”。</li><li><strong>异常</strong>：更适合于处理程序执行过程中可能遇到的预期错误情况，例如不满足输入条件、资源不可用等。</li></ul>    </div>  </div>]]></content>
    
    
    <summary type="html">Python 异常处理基础</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="基本语法" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    <category term="异常" scheme="https://www.yiuhangblog.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
    <category term="断言" scheme="https://www.yiuhangblog.com/tags/%E6%96%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="https://www.yiuhangblog.com/2018/09/28/20180928%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.yiuhangblog.com/2018/09/28/20180928%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2018-09-28T10:08:12.000Z</published>
    <updated>2024-02-28T10:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>在Python中，持久化存储是指将数据保存到一个持久的存储介质（如硬盘）中，以便即使在程序结束后也能再次访问这些数据。Python提供了多种方式来实现数据的持久化存储，包括但不限于文件存储、使用数据库以及利用特定的数据序列化格式。以下是一些常见的Python数据持久化方法：</p><h4 id="1-使用文件系统"><a href="#1-使用文件系统" class="headerlink" title="1. 使用文件系统"></a>1. 使用文件系统</h4><p>最基本的持久化存储方法是直接读写文件。Python提供了多种方式来处理文件，包括文本文件和二进制文件。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入文本文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文本文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br></pre></td></tr></table></figure></div>  <div class="note-large red">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-bug"></i><p>警告</p>    </div>    <div class="notel-content">      <p>出现的 <code>UnicodeEncodeError</code> 错误通常与编码有关。当尝试将包含非ASCII字符的字符串写入文件时，在某些情况下，Python的默认编码（如cp1252）可能无法正确处理这些字符。要解决这个问题，可以在写入文件时明确指定一个能够处理这些字符的编码，如UTF-8。</p><p>可以通过在 <code>open</code> 函数中添加 <code>encoding=&#39;utf-8&#39;</code> 参数来修改代码。这将确保使用UTF-8编码来写入文件，UTF-8编码可以处理大多数字符集。</p>    </div>  </div><h4 id="2-数据序列化"><a href="#2-数据序列化" class="headerlink" title="2. 数据序列化"></a>2. 数据序列化</h4><p>Python提供了几种数据序列化（转换数据结构为可存储或传输的格式）的方法，例如JSON、Pickle等。</p><p><strong>JSON</strong>：用于将数据结构转换为JSON格式。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 序列化到文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json.dump(data, json_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件反序列化</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    data = json.load(json_file)</span><br></pre></td></tr></table></figure></div><p><strong>Pickle</strong>：用于Python对象的序列化，可以序列化几乎所有的Python对象类型。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化到文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> pkl_file:</span><br><span class="line">    pickle.dump(data, pkl_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件反序列化</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> pkl_file:</span><br><span class="line">    data = pickle.load(pkl_file)</span><br></pre></td></tr></table></figure></div><h4 id="3-使用数据库"><a href="#3-使用数据库" class="headerlink" title="3. 使用数据库"></a>3. 使用数据库</h4><p>对于复杂的数据持久化需求，常常会使用数据库。Python提供了许多连接和操作数据库的库，支持包括SQLite、MySQL、PostgreSQL等多种数据库。</p><ul><li><strong>SQLite</strong>（使用标准库<code>sqlite3</code>）：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到SQLite数据库</span></span><br><span class="line"><span class="comment"># 数据库文件是&#x27;data.db&#x27;</span></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;data.db&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Cursor对象</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一个查询</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;SELECT * FROM table_name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Cursor和Connection</span></span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></div><h4 id="4-ORM（对象关系映射）"><a href="#4-ORM（对象关系映射）" class="headerlink" title="4. ORM（对象关系映射）"></a>4. ORM（对象关系映射）</h4><p>ORM框架如SQLAlchemy或Django ORM允许开发者以面向对象的方式来操作数据库，而无需直接编写SQL语句。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">&#x27;sqlite:///data.db&#x27;</span>)</span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br><span class="line"></span><br><span class="line">new_user = User(name=<span class="string">&#x27;John Doe&#x27;</span>)</span><br><span class="line">session.add(new_user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Python的数据持久化选项非常多样，可以根据具体的应用场景和需求选择最合适的方法。对于简单的数据存储，文件读写或使用JSON、Pickle等序列化方式可能就足够了。对于更复杂的数据和需求，使用数据库和ORM框架可能是更好的选择</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="open-函数及其模式"><a href="#open-函数及其模式" class="headerlink" title="open 函数及其模式"></a>open 函数及其模式</h3><ul><li><code>&#39;r&#39;</code>模式：以只读方式打开文件。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br></pre></td></tr></table></figure></div><ul><li><code>&#39;w&#39;</code>模式：以写入方式打开文件，如果文件存在则覆盖，不存在则创建。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;Hello, World!&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li><code>&#39;a&#39;</code>模式：以写入方式打开文件，如果文件存在，则在文件末尾追加内容。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;Append content&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li><code>&#39;r+&#39;</code>模式：以读写方式打开文件。</li><li><code>&#39;w+&#39;</code>模式：以读写方式打开文件，如果文件存在则覆盖，不存在则创建。</li><li><code>&#39;a+&#39;</code>模式：以读写方式打开文件，如果文件存在，则在文件末尾追加内容。</li></ul><p>二进制模式（在模式字符串中加入<code>&#39;b&#39;</code>），例如<code>&#39;rb&#39;</code>, <code>&#39;wb&#39;</code>, <code>&#39;ab&#39;</code>, <code>&#39;rb+&#39;</code>, <code>&#39;wb+&#39;</code>, <code>&#39;ab+&#39;</code>，用于非文本文件。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>r</strong> - 这个模式代表“只读”模式。当你打开一个文件进行读取时，如果没有指定特定的模式，Python会默认使用这个模式。在这种模式下，只能从文件中读取数据，而不能写入或修改数据。如果文件不存在，尝试以这种模式打开文件会导致错误。</p>    </div>  </div><h3 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li><code>file.read()</code>：读取整个文件。</li><li><code>file.write()</code>：写入字符串到文件。</li><li><code>file.tell()</code>：返回文件的当前位置。</li><li><code>file.seek(offset)</code>：改变文件的当前位置。</li><li><code>file.close()</code>：关闭文件。通常与<code>with</code>语句一起使用，可以省略。</li></ul><h3 id="with-上下文管理器"><a href="#with-上下文管理器" class="headerlink" title="with 上下文管理器"></a>with 上下文管理器</h3><p>使用<code>with</code>上下文管理器可以保证即使在发生异常时文件资源也能被正确释放。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br></pre></td></tr></table></figure></div><h3 id="os-模块函数"><a href="#os-模块函数" class="headerlink" title="os 模块函数"></a>os 模块函数</h3><ul><li><code>os.getcwd()</code>：返回当前工作目录。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">cwd = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(cwd)</span><br></pre></td></tr></table></figure></div><ul><li><code>os.listdir()</code>：返回指定目录下的文件和子目录列表。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entries = os.listdir(cwd)</span><br><span class="line"><span class="built_in">print</span>(entries)</span><br></pre></td></tr></table></figure></div><ul><li><code>os.mkdir()</code>：创建新目录。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.mkdir(<span class="string">&#x27;new_directory&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li><code>os.rmdir()</code>：删除目录。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rmdir(<span class="string">&#x27;new_directory&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li><code>os.remove()</code>：删除文件。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.remove(<span class="string">&#x27;file.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li><code>os.rename()</code>：重命名文件或目录。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rename(<span class="string">&#x27;old_name.txt&#x27;</span>, <span class="string">&#x27;new_name.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/e3f44616-9e3e-42e0-34f7-e951ecfc7100/public"                      width = "500"                >]]></content>
    
    
    <summary type="html">Python 持久化存储 OS模块</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="基本语法" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    <category term="持久化存储" scheme="https://www.yiuhangblog.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    
    <category term="os模块" scheme="https://www.yiuhangblog.com/tags/os%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>New方法、单例模式、装饰器</title>
    <link href="https://www.yiuhangblog.com/2018/09/15/20180915New%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://www.yiuhangblog.com/2018/09/15/20180915New%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2018-09-15T09:24:27.000Z</published>
    <updated>2024-02-28T10:49:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类中的-new-魔术方法-构造器"><a href="#类中的-new-魔术方法-构造器" class="headerlink" title="类中的_ _new_ _(魔术方法&#x2F;构造器)"></a>类中的_ _new_ _(魔术方法&#x2F;构造器)</h2><p>在Python中，<code>__new__</code>方法确实是一个特别的方法，但它和<code>__init__</code>方法有着明显的区别。<code>__new__</code>是一个静态方法（虽然通常不明确地声明为静态方法），而<code>__init__</code>是一个实例方法。</p><h3 id="new-方法的作用"><a href="#new-方法的作用" class="headerlink" title="_ _new_ _方法的作用"></a>_ _new_ _方法的作用</h3><p><code>__new__</code>方法主要用于创建一个新的实例对象。它是类的一个静态方法，即便不明确声明也是如此。<code>__new__</code>在<code>__init__</code>方法之前被调用，用于生成实例对象。通常情况下，我们不需要自己编写<code>__new__</code>方法，但在某些特殊情况下，修改<code>__new__</code>方法能够提供额外的灵活性。</p><h3 id="new-方法的基本结构"><a href="#new-方法的基本结构" class="headerlink" title="_ _new_ _ 方法的基本结构"></a>_ _new_ _ 方法的基本结构</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 创建对象的逻辑</span></span><br><span class="line">        instance = <span class="built_in">super</span>(MyClass, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure></div><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="title class_ inherited__">object</span>):</span><br></pre></td></tr></table></figure></div><p>这行代码定义了一个名为<code>MyClass</code>的新类，它继承自Python内置的<code>object</code>类。在Python 3中，所有的类默认继承自<code>object</code>，所以即使不显式地继承，它仍然会继承自<code>object</code>。</p><h4 id="new-方法"><a href="#new-方法" class="headerlink" title="_ _new_ _ 方法"></a>_ _new_ _ 方法</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br></pre></td></tr></table></figure></div><p>这是<code>__new__</code>方法的定义。<code>__new__</code>是一个特殊方法，用于在一个对象实例化时创建并返回这个对象。</p><ul><li><code>cls</code>：这个参数是对当前类<code>MyClass</code>的引用，这与实例方法中的<code>self</code>参数类似，但<code>cls</code>是在对象创建之前使用的。</li><li><code>*args</code>和<code>**kwargs</code>：这两个参数允许传递任意数量的位置参数和关键字参数。这些参数将会被传递给<code>__init__</code>方法。</li></ul><h4 id="创建实例的逻辑"><a href="#创建实例的逻辑" class="headerlink" title="创建实例的逻辑"></a>创建实例的逻辑</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="built_in">super</span>(MyClass, cls).__new__(cls, *args, **kwargs)</span><br></pre></td></tr></table></figure></div><p>这行代码是创建类实例的核心。</p><ul><li><code>super(MyClass, cls)</code>：这部分调用了<code>MyClass</code>的父类的方法。在这个例子中，父类是<code>object</code>。<code>super</code>函数是用来获取父类定义，以便调用其方法的一种方式。</li><li><code>.__new__(cls, *args, **kwargs)</code>：这部分实际上调用了父类<code>object</code>的<code>__new__</code>方法，并传递了必要的参数。这个调用负责创建一个新的实例。</li><li><code>instance</code>：<code>__new__</code>方法返回的是一个实例对象，这里我们将其赋值给变量<code>instance</code>。</li></ul><h4 id="返回实例"><a href="#返回实例" class="headerlink" title="返回实例"></a>返回实例</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure></div><p>最后，<code>__new__</code>方法返回了新创建的实例<code>instance</code>。这个实例接下来将被用来调用<code>__init__</code>方法，以便进行进一步的初始化。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个<code>MyClass</code>类示例展示了如何在Python中自定义<code>__new__</code>方法。通常，不需要重写<code>__new__</code>，除非有改变实例创建方式的特殊需求，比如实现单例模式、返回一个不同的类的实例或者在创建实例之前做一些额外的操作。在大多数情况下，只需要关注<code>__init__</code>方法来初始化实例。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>__new__</code>方法通常在下面的情况下使用：</p><ol><li><strong>单例模式</strong>：确保一个类只有一个实例。</li><li><strong>不可变类型的子类</strong>：例如扩展某些内置不可变类型，如<code>tuple</code>或<code>str</code>。</li><li><strong>控制实例的创建</strong>：在某些复杂的情况下，可能需要在对象创建时进行额外的处理。</li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是一种常见的软件设计模式，其核心思想是确保一个类在应用程序中只有一个实例，并提供一个全局访问点来获取这个实例。这种模式在需要控制资源的访问或管理共享资源时特别有用，如数据库连接或文件系统的操作。</p><h3 id="单例模式的特点"><a href="#单例模式的特点" class="headerlink" title="单例模式的特点"></a>单例模式的特点</h3><ol><li><strong>唯一实例</strong>：单例类只允许创建一个实例。</li><li><strong>全局访问点</strong>：单例类提供一个全局访问的方法，全局的代码都可以通过这个方法访问到这个唯一实例。</li><li><strong>自我管理</strong>：单例类负责创建、初始化和管理自己的唯一实例。</li></ol><h3 id="Python中实现单例模式"><a href="#Python中实现单例模式" class="headerlink" title="Python中实现单例模式"></a>Python中实现单例模式</h3><p>在Python中，单例模式可以通过多种方法实现，如使用模块级别的变量、装饰器、元类或重写<code>__new__</code>方法等。以下是通过重写<code>__new__</code>方法实现单例模式的一个示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>:</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure></div><ul><li>类变量<code>_instance</code>用于存储类的唯一实例。</li><li>在<code>__new__</code>方法中，首先检查<code>_instance</code>是否已经被创建。如果没有，则创建一个新实例并将其赋值给<code>_instance</code>。</li><li>之后的所有实例化操作都将返回这个已创建的实例。</li></ul><h3 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h3><p>单例模式通常用于以下场景：</p><ul><li>管理共享资源，如数据库连接、日志记录、配置信息等。</li><li>控制资源的访问，确保资源的一致性和状态的同步。</li><li>减少资源的重复创建和销毁，提高效率。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>单例模式在多线程环境下可能需要特别的处理来保证线程安全。</li><li>过度使用单例模式可能导致代码间的耦合度过高，应当谨慎使用。</li><li>在分布式系统中，单例模式的使用需要考虑到进程间的通信和资源共享的问题。</li></ul><p>单例模式是一种简单但强大的设计模式，能够有效地管理共享资源和全局状态，但也需要注意其带来的限制和潜在问题。</p><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>在Python中，私有属性（Private Attributes）是指仅能在其所属的类内部访问的属性，而无法从类外部直接访问。这是面向对象编程中封装的一个重要概念，用于隐藏类的内部实现细节，并保护类的状态免受外部干扰。</p><h3 id="如何定义私有属性"><a href="#如何定义私有属性" class="headerlink" title="如何定义私有属性"></a>如何定义私有属性</h3><p>在Python中，私有属性通常是通过在属性名前加上双下划线（<code>__</code>）来定义的。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__private_attribute = <span class="number">42</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>__private_attribute</code>就是一个私有属性。由于它的名字以双下划线开头，它只能在<code>MyClass</code>内部访问。</p><h3 id="访问和修改私有属性"><a href="#访问和修改私有属性" class="headerlink" title="访问和修改私有属性"></a>访问和修改私有属性</h3><p>私有属性只能在定义它们的类的内部访问和修改。如果你试图从类外部访问或修改这些属性，将会导致<code>AttributeError</code>。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.__private_attribute)  <span class="comment"># 将引发错误</span></span><br></pre></td></tr></table></figure></div><p>要在类外部访问或修改私有属性的值，你需要在类内部提供公共的方法（例如getter和setter方法）。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__private_attribute = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_private_attribute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__private_attribute</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_private_attribute</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.__private_attribute = value</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.get_private_attribute())  <span class="comment"># 正确</span></span><br><span class="line">obj.set_private_attribute(<span class="number">100</span>)      <span class="comment"># 正确</span></span><br></pre></td></tr></table></figure></div><h3 id="名称改写（Name-Mangling）"><a href="#名称改写（Name-Mangling）" class="headerlink" title="名称改写（Name Mangling）"></a>名称改写（Name Mangling）</h3><p>在Python中，私有属性的名称实际上会被改写，这个过程称为名称改写（Name Mangling）。Python解释器自动地把属性名<code>__private_attribute</code>转换为<code>_MyClass__private_attribute</code>。这意味着理论上你可以通过改写过的名称来访问私有属性，但这并不是一个好的做法，因为它违反了封装的原则。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(obj._MyClass__private_attribute)  <span class="comment"># 可行，但不推荐</span></span><br></pre></td></tr></table></figure></div><h3 id="为什么使用私有属性"><a href="#为什么使用私有属性" class="headerlink" title="为什么使用私有属性"></a>为什么使用私有属性</h3><p>使用私有属性的主要理由是封装和抽象。通过限制对类内部状态的直接访问，你可以防止外部代码无意中破坏类的内部状态，从而保持对象的完整性和一致性。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>私有属性是面向对象编程中的一个重要概念，它有助于实现封装和数据隐藏。在Python中，私有属性通过在属性名前加双下划线来定义，并且只能通过类内部定义的方法进行访问和修改。尽管技术上可以通过名称改写访问私有属性，但这并不符合封装的原则，应当避免这样做</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器（Decorators）是Python中一个非常强大且有用的功能，它们允许程序员修改或增强函数和方法的行为，而不需要改变其本身的代码。装饰器在很多高级Python应用中都有广泛的使用，如Web框架、事件监听、日志处理等。</p><h3 id="装饰器的基本原理"><a href="#装饰器的基本原理" class="headerlink" title="装饰器的基本原理"></a>装饰器的基本原理</h3><p>在Python中，装饰器本质上是一个Python函数，它可以接收一个函数作为参数并返回一个新的函数。使用装饰器可以在不修改原函数的情况下，增加额外的功能。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening before the function is called.&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening after the function is called.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello = my_decorator(say_hello)</span><br></pre></td></tr></table></figure></div><p>在上面的例子中，<code>my_decorator</code>是一个装饰器，它在<code>say_hello</code>函数前后添加了额外的打印操作。</p><h3 id="使用-语法糖"><a href="#使用-语法糖" class="headerlink" title="使用@语法糖"></a>使用<code>@</code>语法糖</h3><p>Python提供了一个简单的方式来应用装饰器，即使用<code>@</code>符号，这也被称为语法糖。这让代码更加简洁易读。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>使用<code>@my_decorator</code>语法，上面的代码与之前例子中的功能完全相同。</p><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>装饰器也可以带参数，这需要在其外层再加一层函数。这种装饰器也称为装饰器工厂。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">number=<span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator_repeat</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number):</span><br><span class="line">                value = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator_repeat</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params">number=<span class="number">4</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>repeat</code>是一个带参数的装饰器，它接受一个参数<code>number</code>，指定了函数执行的次数。</p><h3 id="装饰器的用途"><a href="#装饰器的用途" class="headerlink" title="装饰器的用途"></a>装饰器的用途</h3><ul><li><strong>日志记录</strong>：添加日志功能，以跟踪函数的调用细节。</li><li><strong>性能测试</strong>：检测函数执行时间，用于性能优化。</li><li><strong>权限验证</strong>：检查用户是否有权执行某个操作。</li><li><strong>缓存</strong>：缓存函数的返回结果，提高程序性能。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>装饰器是Python中非常有用的工具，可以在不修改原有函数代码的情况下，给函数增加新的功能。它通过语法简单但功能强大的方式，提高了代码的可读性和可维护性。在Python的日常使用中，熟练运用装饰器是一个非常有价值的技能。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>在Python中，装饰器的实现通常依赖于闭包的概念。</p><p><strong>闭包（Closure）简介</strong></p><p>闭包是一种在动态编程语言中常见的概念，它指的是一个函数记住了它的词法作用域，即使这个函数在自己的词法作用域之外执行。在Python中，闭包表现为一个内嵌函数记住了其外部函数的状态或环境。</p><p><strong>装饰器中的闭包</strong></p><p>在装饰器中使用闭包，是为了在装饰器函数内创建一个包装函数（wrapper），这个包装函数能够记住并访问其外部函数（即装饰器函数）的变量和参数。这使得装饰器能够在不修改被装饰函数的情况下增加额外的功能。</p><ul><li><code>my_decorator</code> 是一个装饰器函数。</li><li><code>wrapper</code> 是一个内嵌函数，它是闭包的体现。<code>wrapper</code> 能够记住并访问<code>func</code>，即使在<code>my_decorator</code>函数的执行已经完成之后。</li><li>当我们使用<code>@my_decorator</code>装饰<code>say_hello</code>函数时，实际上是将<code>say_hello</code>作为参数传递给了<code>my_decorator</code>，并将返回的<code>wrapper</code>函数赋值给了<code>say_hello</code>。</li></ul><p><strong>闭包的作用</strong></p><p>闭包在装饰器中的主要作用是让我们能够延伸或修改函数的行为。闭包使得装饰器内部的包装函数能够访问到装饰器接收的原始函数，从而在不改变原始函数定义的前提下，对其进行包装，增加额外的操作和逻辑。</p><p><strong>总结</strong></p><p>简言之，装饰器中的闭包是Python中一种强大的函数式编程特性，它允许内嵌函数捕获并保持外部函数的状态，从而使得我们可以在不修改原函数的情况下，为其增加新的功能。这种特性在Python中广泛用于日志记录、性能测试、权限校验等场景。</p><p>详见函数篇<a class="button " href='https://www.yiuhangblog.com/2018/08/12/20180812%E5%87%BD%E6%95%B0/#%E9%97%AD%E5%8C%85-Closure' title='闭包'><i class='fa-solid fa-play-circle'></i> 闭包</a></p>    </div>  </div>]]></content>
    
    
    <summary type="html">Python New方法、单例模式、装饰器</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="基本语法" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    <category term="装饰器" scheme="https://www.yiuhangblog.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
    <category term="new方法" scheme="https://www.yiuhangblog.com/tags/new%E6%96%B9%E6%B3%95/"/>
    
    <category term="私有属性" scheme="https://www.yiuhangblog.com/tags/%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7/"/>
    
    <category term="单列模式" scheme="https://www.yiuhangblog.com/tags/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://www.yiuhangblog.com/2018/09/08/20180908%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.yiuhangblog.com/2018/09/08/20180908%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2018-09-08T04:13:23.000Z</published>
    <updated>2024-02-28T10:49:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，它使用“对象”来设计软件。这种方法不仅侧重于数据（即属性），还侧重于操作这些数据的代码（即方法）。面向对象编程基于几个核心概念，包括类、对象、继承、多态和封装。</p><ol><li><strong>类（Class）</strong>：类是创建对象的蓝图或模板。它定义了对象的属性和方法。属性是类中的变量，方法是类中的函数。类本身不占用内存空间，它只是定义了对象的结构。</li><li><strong>对象（Object）</strong>：对象是类的实例。当类被实例化时，会创建一个对象。对象具有类定义的属性和方法。每个对象都有自己的属性值，但共享相同的方法。</li><li><strong>继承（Inheritance）</strong>：继承允许一个类继承另一个类的属性和方法。这有助于代码重用，并实现多层次的分类。在继承关系中，有基类（父类）和派生类（子类）。</li><li><strong>多态（Polymorphism）</strong>：多态是指即使不同类的对象可能有不同的实现，但它们可以通过相同的接口进行交互。这意味着，可以用统一的方式来处理不同类的对象，即使它们具有不同的内部结构。</li><li><strong>封装（Encapsulation）</strong>：封装是隐藏对象内部实现细节的过程，仅公开必要的接口。这有助于防止外部代码随意更改对象内部状态，从而保护对象的完整性并简化接口。</li><li><strong>抽象（Abstraction）</strong>：抽象是将复杂的现实世界问题简化为模型的过程。在面向对象编程中，这通常意味着创建类，这些类代表了现实世界中的实体或概念，但只包括与当前问题相关的部分。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9a77d919-96a4-4946-8e20-2a0d6c3cb700/public"                      width="300"                ><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>模块化</strong>：OOP 促进了代码的模块化，使得不同模块可以独立开发和测试，提高了代码的可维护性和复用性。</li><li><strong>可扩展性</strong>：通过继承和多态，可以在现有代码的基础上添加新功能，而不必大幅修改现有代码。</li><li><strong>可维护性</strong>：封装提供了一种方式，使得代码更易于理解和维护。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>性能</strong>：相较于面向过程的编程，面向对象的程序可能在性能上稍微逊色，因为它需要额外的内存和处理。</li><li><strong>复杂性</strong>：面向对象的系统可能比简单的面向过程的系统更复杂。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>面向对象编程在软件工程中广泛应用，从桌面和移动应用程序到大型企业级系统。众多流行的编程语言，如 Java、C#、Python、Ruby 和 C++，都支持面向对象的编程范式。</p><h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类 (Class)"></a>类 (Class)</h2><p>类（Class）是面向对象编程（OOP）中的一个核心概念。在很多现代编程语言中，类作为一种构造，提供了一种封装数据和行为（即代码）的方式。它们允许开发者创建复杂的数据结构</p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>首先，我们定义一个名为<code>Car</code>的类：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="comment"># 这些是成员属性</span></span><br><span class="line">    brand = <span class="literal">None</span></span><br><span class="line">    color = <span class="literal">None</span></span><br><span class="line">    speed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个成员方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.brand&#125;</span>车启动了。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accelerate</span>(<span class="params">self, increase</span>):</span><br><span class="line">        self.speed += increase</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.brand&#125;</span>车加速到了<span class="subst">&#123;self.speed&#125;</span>公里/小时。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">brake</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.brand&#125;</span>车正在刹车。&quot;</span>)</span><br><span class="line">        self.speed = <span class="number">0</span></span><br></pre></td></tr></table></figure></div><p>在这个<code>Car</code>类中：</p><ul><li><strong>成员属性</strong>：<code>brand</code>（品牌）、<code>color</code>（颜色）和<code>speed</code>（速度）是类的属性。它们用来描述这个类的状态。</li><li><strong>成员方法</strong>：<code>start</code>、<code>accelerate</code> 和 <code>brake</code> 是类的方法。它们描述了<code>Car</code>可以执行的操作。</li></ul><h3 id="实例化类"><a href="#实例化类" class="headerlink" title="实例化类"></a>实例化类</h3><p>接下来，我们创建几个<code>Car</code>类的实例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">first_car = Car()  <span class="comment"># 实例化第一辆车</span></span><br><span class="line">first_car.brand = <span class="string">&#x27;Toyota&#x27;</span></span><br><span class="line">first_car.color = <span class="string">&#x27;红色&#x27;</span></span><br><span class="line">first_car.start()</span><br><span class="line">first_car.accelerate(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">second_car = Car() <span class="comment"># 实例化第二辆车</span></span><br><span class="line">second_car.brand = <span class="string">&#x27;Ford&#x27;</span></span><br><span class="line">second_car.color = <span class="string">&#x27;蓝色&#x27;</span></span><br><span class="line">second_car.start()</span><br><span class="line">second_car.accelerate(<span class="number">40</span>)</span><br></pre></td></tr></table></figure></div><p>每次调用<code>Car()</code>时，我们都创建了一个新的<code>Car</code>类的实例（即一个新的汽车对象）。通过为不同的实例分别设置属性（如<code>brand</code>和<code>color</code>），每辆车都有自己的特点。</p>  <div class="note-large green">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-question"></i><p>QA</p>    </div>    <div class="notel-content">      <p><strong>问：</strong></p><p>通过<code>类名()</code>可以实例化一个对象吗？</p><p><strong>答：</strong></p><p>在Python中，你可以通过调用类名并传递所需的参数（如果有的话）来创建（实例化）一个类的实例。例如，如果有一个名为 <code>MyClass</code> 的类，可以通过 <code>my_instance = MyClass()</code> 来创建这个类的一个实例。</p><p><strong>问：</strong></p><p>类具有属性和方法吗？</p><p><strong>答：</strong></p><p>在Python中，类可以拥有属性（有时称为数据成员）和方法（类内定义的函数）。属性用于保存数据值，而方法用于定义对象可以执行的操作。</p><p><strong>问：</strong></p><p>一个类只能创建一个对象吗？</p><p><strong>答：</strong></p><p>这个说法是错误的。一个类可以用来创建任意数量的对象。每个对象都是类的实例，拥有自己的属性集和方法。例如，如果有一个 <code>Dog</code> 类，可以用它来创建许多 <code>Dog</code> 实例，每个实例代表一个不同的狗。</p><p><strong>问：</strong></p><p>对象是一个实体吗？</p><p><strong>答：</strong></p><p>在编程中，对象通常指的是一个具体的实例，它由类创建。对象是类定义的实体的具体表现。它拥有类中定义的属性和方法。</p>    </div>  </div><h3 id="成员方法中的self"><a href="#成员方法中的self" class="headerlink" title="成员方法中的self"></a>成员方法中的<code>self</code></h3><p>在<code>Car</code>类的成员方法中，<code>self</code>关键字是对当前对象实例的引用。它用于访问对象的属性和调用其他方法。例如，在<code>accelerate</code>方法中，<code>self.speed += increase</code>表示将当前车辆的速度增加<code>increase</code>单位。</p><h3 id="init-初始化方法-魔术方法-构造器"><a href="#init-初始化方法-魔术方法-构造器" class="headerlink" title="_ _init_ _初始化方法(魔术方法&#x2F;构造器)"></a>_ _init_ _初始化方法(魔术方法&#x2F;构造器)</h3><p><code>__init__</code> 是一个在 Python 中特别重要的方法，它是类的一个特殊方法（有时被称为“魔术方法”或“构造器”）。当创建类的新实例时，<code>__init__</code> 方法被自动调用，用于为新创建的对象初始化其属性或执行其他必要的设置。以下是关于 <code>__init__</code> 方法的一些关键点：</p><ol><li><strong>构造器</strong>：<code>__init__</code> 方法可以看作是类的“构造器”。它在对象创建时立即执行，允许类接受参数并据此初始化对象的属性。</li><li><strong>self 参数</strong>：<code>__init__</code> 方法的第一个参数总是 <code>self</code>，它是对类实例本身的引用。通过 <code>self</code>，可以在方法内部访问类的属性和其他方法。</li><li><strong>初始化属性</strong>：可以在 <code>__init__</code> 方法中定义并初始化对象的属性。这样做的好处是，可以为不同的对象实例设置不同的初始状态。</li><li><strong>接受参数</strong>：<code>__init__</code> 方法可以接受参数（除了自身 <code>self</code> 参数外），这些参数在创建类实例时传递给它，用于设置对象的属性或进行其他操作。</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="comment"># 使用 __init__ 方法初始化成员属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, brand, color</span>):</span><br><span class="line">        self.brand = brand</span><br><span class="line">        self.color = color</span><br><span class="line">        self.speed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 成员方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.brand&#125;</span>车启动了。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accelerate</span>(<span class="params">self, increase</span>):</span><br><span class="line">        self.speed += increase</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.brand&#125;</span>车加速到了<span class="subst">&#123;self.speed&#125;</span>公里/小时。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">brake</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.brand&#125;</span>车正在刹车。&quot;</span>)</span><br><span class="line">        self.speed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 __init__ 方法实例化第一辆车</span></span><br><span class="line">first_car = Car(<span class="string">&#x27;Toyota&#x27;</span>, <span class="string">&#x27;红色&#x27;</span>)</span><br><span class="line">first_car.start()</span><br><span class="line">first_car.accelerate(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 __init__ 方法实例化第二辆车</span></span><br><span class="line">second_car = Car(<span class="string">&#x27;Ford&#x27;</span>, <span class="string">&#x27;蓝色&#x27;</span>)</span><br><span class="line">second_car.start()</span><br><span class="line">second_car.accelerate(<span class="number">40</span>)</span><br></pre></td></tr></table></figure></div><p>在这个例子中， <code>Car</code> 类中添加了 <code>__init__</code> 方法，它接受 <code>brand</code> 和 <code>color</code> 作为参数，并将它们分别赋值给实例的 <code>brand</code> 和 <code>color</code> 属性。现在，在创建 <code>Car</code> 类的实例时，我们需要提供品牌和颜色作为参数。这样一来，每个 <code>Car</code> 实例在创建时都会有自己的品牌和颜色属性。</p>  <div class="note-large green">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-question"></i><p>QA</p>    </div>    <div class="notel-content">      <p><strong>问：</strong>为什么accelerate不在<code>car(brand, color)</code>里直接写？</p><p><strong>答：</strong>将 <code>accelerate</code> 方法放在 <code>Car</code> 类的构造方法 (<code>__init__</code>) 中与放在类的外部作为一个独立的方法有不同的含义和用途。理解这一点，需要对面向对象编程中的一些基本概念有所了解：</p><ol><li><strong>构造方法 (<code>__init__</code>)</strong>: <code>__init__</code> 方法用于初始化新创建的对象的状态。它通常用于设置对象的初始属性值。构造方法在对象被创建时自动调用一次，用于设置对象的初始状态。</li><li><strong>成员方法</strong>: 类中定义的其他方法（如 <code>accelerate</code>）用于描述对象的行为。这些方法可以在对象的整个生命周期内被多次调用，并且通常用于执行特定的操作，比如修改对象的状态或者与其他对象进行交互。</li><li><strong>职责分离</strong>: 在面向对象设计中，通常推荐遵循单一职责原则。这意味着每个部分（如方法）应该只负责一项功能。将 <code>accelerate</code> 方法放在类的外部作为一个独立的方法，而不是在 <code>__init__</code> 中定义，可以使类的结构更加清晰，每个方法的职责更加明确。</li><li><strong>灵活性与可重用性</strong>: 将 <code>accelerate</code> 作为独立的方法可以在任何时候调用以改变对象的速度属性。如果它被放在 <code>__init__</code> 中，它只能在对象创建时执行，这限制了方法的用途。</li></ol><p>总结来说，<code>accelerate</code> 不放在 <code>__init__</code> 中是为了保持代码的清晰性和组织性，确保每个方法只负责一项特定的功能，并允许在对象的生命周期中多次调用 <code>accelerate</code> 方法。这是一种更灵活、可维护和符合面向对象设计原则的做法。</p><p><strong>问：</strong><code>self.speed = 0</code> 为什么在(<code>__init__</code>) 里？</p><p><strong>答：</strong>将 <code>self.speed = 0</code> 放在 <code>__init__</code> 方法中是为了初始化 <code>Car</code> 类的每个实例的速度属性。这是一种常见的做法，用于设定对象的初始状态。以下是放置这个语句在 <code>__init__</code> 中的几个理由：</p><ol><li><strong>初始状态设定</strong>：在面向对象编程中，构造方法（如 Python 中的 <code>__init__</code>）用于设定对象的初始状态。对于汽车来说，初始速度设为 0 是合理的，因为当汽车被“创建”（或实例化）时，它通常是静止的。</li><li><strong>统一属性管理</strong>：将所有属性的初始化集中在 <code>__init__</code> 方法中可以使代码更加清晰和易于维护。这样，可以在一个地方看到对象所有属性的初始值。</li><li><strong>确保属性存在</strong>：在 <code>__init__</code> 方法中初始化 <code>speed</code> 确保了每个 <code>Car</code> 实例都具有 <code>speed</code> 属性，并且有一个明确的初始值。这避免了在其他方法（如 <code>accelerate</code> 或 <code>brake</code>）中使用 <code>speed</code> 属性之前需要检查其是否存在的情况。</li><li><strong>避免未初始化的属性</strong>：如果不在 <code>__init__</code> 中初始化 <code>speed</code>，那么在调用 <code>accelerate</code> 方法之前，尝试访问 <code>speed</code> 属性可能会导致错误，因为 Python 不会自动创建这个属性。</li></ol><p>综上所述，将 <code>self.speed = 0</code> 放在 <code>__init__</code> 方法中是为了初始化对象的速度属性，保证对象的完整性，并为后续的操作（如加速或刹车）提供一个明确和稳定的起点。</p>    </div>  </div><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="类定义与初始化"><a href="#类定义与初始化" class="headerlink" title="类定义与初始化"></a>类定义与初始化</h5><p>首先，我们定义一个名为<code>Car</code>的类，并在其中使用<code>__init__</code>方法来初始化类的实例。<code>__init__</code>是一个特殊的方法，它在类的实例化时自动调用。我们可以通过它来设置初始的成员属性。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="comment"># 使用 __init__ 方法初始化成员属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, brand, color, weight</span>):</span><br><span class="line">        <span class="comment"># self.brand 创建了一个名为 brand 的属性</span></span><br><span class="line">        <span class="comment"># brand = None 的效果类似于此</span></span><br><span class="line">        <span class="comment"># self.brand = brand 用传入的参数 brand 初始化</span></span><br><span class="line">        self.brand = brand</span><br><span class="line">        <span class="comment"># 同理，为 color 和 weight 属性赋值</span></span><br><span class="line">        self.color = color</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个成员方法用于显示汽车的信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;这辆车是 <span class="subst">&#123;self.color&#125;</span>色的 <span class="subst">&#123;self.brand&#125;</span>，重 <span class="subst">&#123;self.weight&#125;</span>公斤。&quot;</span>)</span><br></pre></td></tr></table></figure></div><h5 id="实例化类-1"><a href="#实例化类-1" class="headerlink" title="实例化类"></a>实例化类</h5><p>当我们实例化这个类时，我们需要提供品牌、颜色和重量这三个参数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化 Car 类</span></span><br><span class="line">first_car = Car(<span class="string">&quot;Toyota&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">1500</span>)</span><br><span class="line"><span class="comment"># 调用方法显示信息</span></span><br><span class="line">first_car.display_info()</span><br></pre></td></tr></table></figure></div><p>这里，<code>first_car</code> 是 <code>Car</code> 类的一个实例，代表了一辆特定的汽车。我们给它赋予了“Toyota”品牌、“红色”颜色和1500公斤重量的属性，并通过<code>display_info</code>方法打印了这些信息。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过修改这个例子，我们可以看到如何在类中使用初始化方法（<code>__init__</code>）来设置对象的初始状态，并通过实例化这个类来创建具体的对象。每个对象都有自己的属性值，但它们共享相同的方法（如<code>display_info</code>）。</p>  <div class="note-large green">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-question"></i><p>QA</p>    </div>    <div class="notel-content">      <p><strong>问：</strong>以女娲造人为例子</p><ul><li>什么是类？</li><li>什么是实例化类？</li><li>什么是面向对象？</li></ul><p><strong>答：</strong></p><p><strong>什么是类？</strong></p><p>在女娲造人的故事中，女娲的想法或设计可以被看作是一个“类”（Class）。这个类是一个抽象的概念，它定义了人类将拥有的特征（如眼睛、鼻子、嘴巴）和行为（如走路、说话）。类是面向对象编程中定义数据结构和行为的蓝图或模板。</p><p><strong>什么是实例化类？</strong></p><p>当女娲根据她的想法创造出一个具体的人时，这个过程就像是在面向对象编程中的“实例化”（Instantiation）。实例化类的过程就是根据类的定义创建一个具体的对象（在这个故事中就是一个具体的人）。每个人（对象）都有类定义的特征和行为，但每个人也有自己的个性（即对象的状态可以独立于其他对象）。</p><p><strong>什么是面向对象？</strong></p><p>面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，它使用对象来模拟现实世界的实体。在女娲造人的故事中，整个造人过程（设计-创造-赋予行为）就类似于面向对象的过程。面向对象编程的核心是类和对象，以及它们之间的交互。</p><p><strong>问：</strong>面向对象的好处是什么？我们以后开发代码需要怎么做？</p><p><strong>答：</strong></p><p><strong>好处</strong></p><ol><li><strong>封装</strong>：面向对象允许封装数据和方法，提高数据安全性。</li><li><strong>继承</strong>：通过继承，新的类可以扩展现有类的功能。</li><li><strong>多态</strong>：相同的接口可以用在不同的对象上，提高代码的灵活性和可重用性。</li><li><strong>代码组织和可读性</strong>：OOP 提高了代码的组织性和可读性，使大型项目更易于管理。</li></ol><p><strong>开发时的做法</strong></p><ul><li>使用类和对象来模拟现实世界的实体和概念。</li><li>封装相关的属性和方法，确保数据安全性和减少外部干扰。</li><li>通过继承和多态性来重用代码和提高代码的灵活性。</li><li>关注对象之间的交互，而不仅仅是代码的执行流程。</li></ul><p><strong>问：</strong> <code>self</code> 在初始化<code>__init__</code>的作用是什么？ 在普通方法中的作用是什么？</p><p><strong>答：</strong></p><p><strong>在 <code>__init__</code> 方法中</strong></p><ul><li><code>self</code> 在 <code>__init__</code> 方法中代表新创建的对象本身。</li><li>它用于初始化对象的属性。</li><li>通过 <code>self</code>，可以将对象的属性与局部变量区分开来。</li></ul><p><strong>在普通方法中</strong></p><ul><li><code>self</code> 在类的其他方法中也代表对象本身。</li><li>它用于访问和修改对象的属性。</li><li>同样，<code>self</code> 用于调用对象的其他方法。</li></ul><p>简而言之，<code>self</code> 是类方法中的一个参数，它提供了对类实例本身的引用。这允许类的方法在操作对象时访问和修改对象的属性，以及调用其他方法。</p><p><strong>问：</strong>请根据闹钟 来写一个类 并创造三个闹钟</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> playsound <span class="keyword">import</span> playsound</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(current_time) 测试格式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alarm</span>:</span><br><span class="line">    <span class="comment"># 使用init方法初始化成员属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, time, music</span>):</span><br><span class="line">        self.time = time  <span class="comment"># time 是字符串格式 &#x27;HH:MM:SS&#x27;</span></span><br><span class="line">        self.music = music</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 成员方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 一些写音乐文件调用的逻辑</span></span><br><span class="line">        playsound(self.music)  <span class="comment"># 播放歌曲</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.music&#125;</span> has been played&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 调用当前当前时间</span></span><br><span class="line">        current_time = datetime.now().strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.time == current_time:</span><br><span class="line">            Alarm.sound(self)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.time&#125;</span>, time to wake up !&quot;</span>)  <span class="comment"># 起床</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Current time is <span class="subst">&#123;current_time&#125;</span>, wake up at <span class="subst">&#123;self.time&#125;</span>&quot;</span>)  <span class="comment"># 报时</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">first_alarm = Alarm(<span class="string">&#x27;15:46:25&#x27;</span>, <span class="string">&#x27;test1.mp3&#x27;</span>)</span><br><span class="line">second_alarm = Alarm(<span class="string">&#x27;22:06:50&#x27;</span>, <span class="string">&#x27;test2.mp3&#x27;</span>)</span><br><span class="line">third_alarm = Alarm(<span class="string">&#x27;05:10:33&#x27;</span>, <span class="string">&#x27;test3.mp3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 clock 方法</span></span><br><span class="line">first_alarm.clock()</span><br><span class="line">second_alarm.clock()</span><br><span class="line">third_alarm.clock()</span><br></pre></td></tr></table></figure></div>    </div>  </div><h2 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h2><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 (Encapsulation)"></a>封装 (Encapsulation)</h3><p>封装是面向对象编程中的一个核心概念，它指的是将对象的数据（属性）和行为（方法）组合在一起，形成一个独立的单元。在封装过程中，可以对对象的成员进行访问限制。</p><ul><li><p>私有属性 (Private Attributes)</p><p>属性名前加了两个下划线表示它是私有属性，只能在类的内部被访问。</p><p>作用: <code>不能被外部直接访问</code></p><ul><li><code>self.__资金 = 0</code>   私有属性，代表车辆的资金</li></ul></li><li><p>私有方法 (Private Methods)</p><p>方法名前加了两个下划线表示它是私有方法，只能在类的内部被调用。</p><p>作用: <code>不能被外部直接访问</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__start_engine</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;引擎启动，准备行驶&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li></ul><p>以汽车为例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, brand, engine, seats</span>):</span><br><span class="line">        <span class="comment"># 公有属性</span></span><br><span class="line">        self.brand = brand</span><br><span class="line">        self.engine = engine</span><br><span class="line">        self.seats = seats</span><br><span class="line">        <span class="comment"># 私有属性</span></span><br><span class="line">        self.__资金 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.brand&#125;</span> 正在行驶&#x27;</span>)</span><br><span class="line">        <span class="comment"># 在公有方法中使用私有方法</span></span><br><span class="line">        self.__start_engine()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__start_engine</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;引擎启动，准备行驶&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">my_car = Car(<span class="string">&#x27;宝马&#x27;</span>, <span class="string">&#x27;V6&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">my_car.drive()</span><br></pre></td></tr></table></figure></div><p>在类中，成员属性和成员方法可以通过在名称前加上两个下划线 <code>__</code> 来设为私有。这样做的好处是能够保证这些成员不会被外界直接访问，但它们仍然可以在类的内部通过 <code>self</code> 被访问。这种方式有助于隐藏数据和实现细节，提高了代码的安全性和健壮性。</p>  <div class="note-large green">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-question"></i><p>QA</p>    </div>    <div class="notel-content">      <p><strong>问：</strong>为什么<code>class AdvancedCar(Car)</code>不用<code>super()</code></p><p><strong>答：</strong><code>AdvancedCar</code> 类继承自 <code>Car</code> 类。在这个特定的情况下，<code>super()</code> 没有被使用，原因如下：</p><ol><li><strong>不需要覆盖父类的方法</strong>： 在 <code>AdvancedCar</code> 类中，我们添加了新的方法（<code>autopilot</code> 和 <code>advanced_navigation</code>），而没有修改或覆盖任何继承自 <code>Car</code> 类的方法。因此，没有必要使用 <code>super()</code> 来调用父类 <code>Car</code> 的任何方法。</li><li><strong>构造函数未被重写</strong>： 如果子类不重写父类的构造函数（<code>__init__</code> 方法），则默认调用父类的构造函数。在例子中，<code>AdvancedCar</code> 没有定义自己的 <code>__init__</code> 方法，因此它会自动使用父类 <code>Car</code> 的构造函数来初始化对象。如果在子类中重写了构造函数并且想要执行父类的构造函数，那么在子类的构造函数中使用 <code>super().__init__()</code> 是必要的。</li><li><strong>独立的新方法</strong>： <code>AdvancedCar</code> 类中新增的方法（<code>autopilot</code> 和 <code>advanced_navigation</code>）是独立的，它们不依赖于 <code>Car</code> 类中定义的任何方法，因此没有必要使用 <code>super()</code>。</li></ol><p>总结一下，<code>super()</code> 主要用于需要调用或扩展父类中定义的方法时。如果只是在子类中添加新的独立方法或属性，并且没有重写父类的构造函数，就不需要使用 <code>super()</code>。在例子中，由于这些条件都未满足，因此不使用 <code>super()</code> 是合理的。</p>    </div>  </div><h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 (Inheritance)"></a>继承 (Inheritance)</h3><p>在面向对象编程中，继承允许我们从一个已存在的类（称为父类）派生出一个新的类（称为子类）。子类会继承父类的所有属性和方法，并可以添加新的属性和方法或重写某些方法。</p><p>以汽车为例，我们可以从一个基本的汽车类派生出一个具有更多功能的特殊汽车类。</p><p>首先是父类，表示基本的汽车：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, brand, engine, seats</span>):</span><br><span class="line">        self.brand = brand</span><br><span class="line">        self.engine = engine</span><br><span class="line">        self.seats = seats</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_engine</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.brand&#125;</span> 的引擎启动了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.brand&#125;</span> 正在行驶&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p>然后是子类，这里我们假设有一个增强版的汽车，它除了有基本的汽车功能外，还增加了自动驾驶和先进的导航系统：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedCar</span>(<span class="title class_ inherited__">Car</span>):  <span class="comment"># 继承自 Car 类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">autopilot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.brand&#125;</span> 的自动驾驶系统已启动&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">advanced_navigation</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.brand&#125;</span> 正在使用先进的导航系统&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个增强版的汽车</span></span><br><span class="line">my_advanced_car = AdvancedCar(<span class="string">&#x27;特斯拉&#x27;</span>, <span class="string">&#x27;电动&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">my_advanced_car.start_engine()  <span class="comment"># 继承自 Car 类的方法</span></span><br><span class="line">my_advanced_car.drive()         <span class="comment"># 继承自 Car 类的方法</span></span><br><span class="line">my_advanced_car.autopilot()     <span class="comment"># AdvancedCar 类的新增方法</span></span><br><span class="line">my_advanced_car.advanced_navigation()  <span class="comment"># AdvancedCar 类的新增方法</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>AdvancedCar</code> 类继承了 <code>Car</code> 类的所有属性和方法（如 <code>start_engine</code> 和 <code>drive</code>），并新增了 <code>autopilot</code> 和 <code>advanced_navigation</code> 方法。这表明 <code>AdvancedCar</code> 不仅保留了基本汽车的特性，还加入了新的功能，充分展示了继承的实用性和灵活性。</p><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 (Polymorphism)"></a>多态 (Polymorphism)</h3><p>多态是面向对象编程中的一个重要概念，它允许不同类的对象对同一消息做出响应。即不同的对象可以通过相同的接口（方法或函数）执行不同的操作。这增加了程序的灵活性和可扩展性。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;汪汪！&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;喵喵！&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，接受不同的动物对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    <span class="comment"># 无论传入的是什么动物，调用相同的speak方法</span></span><br><span class="line">    <span class="built_in">print</span>(animal.speak())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化Dog和Cat</span></span><br><span class="line">dog = Dog()</span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用animal_sound函数，展示多态</span></span><br><span class="line">animal_sound(dog)  <span class="comment"># 输出: 汪汪！</span></span><br><span class="line">animal_sound(cat)  <span class="comment"># 输出: 喵喵！</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>Dog</code> 和 <code>Cat</code> 类都实现了同一个方法 <code>speak</code>，但它们以不同的方式响应（狗叫声和猫叫声）。函数 <code>animal_sound</code> 接受任何有 <code>speak</code> 方法的对象作为参数，然后调用这个方法。这就是多态的核心：通过同一接口，不同的对象可以执行各自不同的操作。</p><p>总结来说，多态允许我们编写更通用和可重用的代码，因为我们可以设计函数或方法，它们可以与任何符合特定接口（即实现特定方法）的对象交互，而不关心对象的具体类型。这样可以提高代码的灵活性和可扩展性。</p><h2 id="学生管理系统案例"><a href="#学生管理系统案例" class="headerlink" title="学生管理系统案例"></a>学生管理系统案例</h2><p>这个学员管理系统示例演示了面向对象编程的几个关键概念，如类的定义、初始化、封装、私有属性和方法的使用。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个名为StudentManagementSystem的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentManagementSystem</span>:</span><br><span class="line">    <span class="comment"># 类的构造函数，用于初始化对象的属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age</span>):</span><br><span class="line">        <span class="comment"># 公有属性，可以被外部访问</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="comment"># 私有属性，前面有两个下划线，仅在类内部可访问</span></span><br><span class="line">        self.__balance = <span class="number">1000</span>  <span class="comment"># 设置初始余额为1000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 私有方法，用于扣除费用，仅在类内部可调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__deduct_fee</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="comment"># 检查余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span> self.__balance &gt;= amount:</span><br><span class="line">            self.__balance -= amount</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;扣除<span class="subst">&#123;amount&#125;</span>元成功。&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;余额不足，无法扣款。&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有方法，用于展示学员信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 打印学员信息，包括私有属性余额</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名: <span class="subst">&#123;self.name&#125;</span>, 性别: <span class="subst">&#123;self.gender&#125;</span>, 年龄: <span class="subst">&#123;self.age&#125;</span>, 余额: <span class="subst">&#123;self.__balance&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公有方法，用于购买课程</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">purchase_course</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 输入价格，并尝试转换为整数</span></span><br><span class="line">            price = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入购买的价格:&#x27;</span>))</span><br><span class="line">            <span class="comment"># 调用私有方法扣款</span></span><br><span class="line">            self.__deduct_fee(price)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;请输入有效的价格。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 新增的公有方法，用于为学员账户充值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recharge</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="comment"># 增加学员余额</span></span><br><span class="line">        self.__balance += amount</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;已成功充值<span class="subst">&#123;amount&#125;</span>元。&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 新增的公有方法，用于学员对课程进行评价</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rate_course</span>(<span class="params">self, course, rating</span>):</span><br><span class="line">        <span class="comment"># 打印学员对课程的评分</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;学员<span class="subst">&#123;self.name&#125;</span>给课程<span class="subst">&#123;course&#125;</span>的评分是: <span class="subst">&#123;rating&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个StudentManagementSystem类的对象</span></span><br><span class="line">user = StudentManagementSystem(<span class="string">&#x27;用户&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;18&#x27;</span>)</span><br><span class="line">user.purchase_course()  <span class="comment"># 调用方法购买课程</span></span><br><span class="line">user.purchase_course()  <span class="comment"># 再次调用方法购买课程</span></span><br><span class="line">user.show_info()        <span class="comment"># 展示学员信息</span></span><br><span class="line">user.recharge(<span class="number">500</span>)      <span class="comment"># 调用方法充值500元</span></span><br><span class="line">user.rate_course(<span class="string">&quot;Python编程基础&quot;</span>, <span class="number">5</span>)  <span class="comment"># 对课程进行评分</span></span><br></pre></td></tr></table></figure></div><p>为了在现有的 <code>StudentManagementSystem</code> 类中引入继承和多态的特点，我们可以创建一个基类来表示一般的用户，然后让 <code>StudentManagementSystem</code> 类成为这个基类的子类。此外，我们可以定义一个接口（一个具有共同方法但没有具体实现的基类），来展示多态。</p><p>首先是基类和接口的定义：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基类 User，表示一般的用户</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名: <span class="subst">&#123;self.name&#125;</span>, 性别: <span class="subst">&#123;self.gender&#125;</span>, 年龄: <span class="subst">&#123;self.age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接口类 CourseConsumer，定义了一个没有具体实现的方法 purchase_course</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CourseConsumer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">purchase_course</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Subclass must implement this method&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>然后是修改后的 <code>StudentManagementSystem</code> 类，它继承自 <code>User</code> 并实现了 <code>CourseConsumer</code> 接口：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># StudentManagementSystem 类继承自 User 类并实现了 CourseConsumer 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentManagementSystem</span>(User, CourseConsumer):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, gender, age)  <span class="comment"># 调用父类的构造函数</span></span><br><span class="line">        self.__balance = <span class="number">1000</span>  <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__deduct_fee</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__balance &gt;= amount:</span><br><span class="line">            self.__balance -= amount</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;扣除<span class="subst">&#123;amount&#125;</span>元成功。&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;余额不足，无法扣款。&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写父类的 show_info 方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().show_info()  <span class="comment"># 调用父类方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;余额: <span class="subst">&#123;self.__balance&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现接口中定义的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">purchase_course</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            price = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入购买的价格:&#x27;</span>))</span><br><span class="line">            self.__deduct_fee(price)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;请输入有效的价格。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recharge</span>(<span class="params">self, amount</span>):</span><br><span class="line">        self.__balance += amount</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;已成功充值<span class="subst">&#123;amount&#125;</span>元。&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rate_course</span>(<span class="params">self, course, rating</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;学员<span class="subst">&#123;self.name&#125;</span>给课程<span class="subst">&#123;course&#125;</span>的评分是: <span class="subst">&#123;rating&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p>在这个修改后的版本中，<code>StudentManagementSystem</code> 类继承了 <code>User</code> 类，并且实现了 <code>CourseConsumer</code> 接口的 <code>purchase_course</code> 方法。这样的设计不仅引入了继承，还通过实现接口展示了多态。继承允许 <code>StudentManagementSystem</code> 类重用 <code>User</code> 类的代码，而多态则体现在 <code>StudentManagementSystem</code> 类能够以不同方式实现 <code>CourseConsumer</code> 接口中定义的方法。这样的设计使得代码更加灵活和可扩展。</p>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p>在面向对象编程中，<code>super()</code> 函数的使用通常出现在继承体系中，尤其是在子类需要调用父类的方法或构造函数时。以下是一些使用 <code>super()</code> 的典型情况：</p><ol><li><strong>在子类的构造函数中调用父类的构造函数</strong>： 当创建一个子类时，可能需要在子类中初始化一些继承自父类的属性。使用 <code>super()</code> 调用父类的构造函数可以确保这些属性被适当地初始化。</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Parent init&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 调用父类的 __init__ 方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Child init&quot;</span>)</span><br></pre></td></tr></table></figure></div><ol start="2"><li><strong>在子类中覆盖父类的方法时调用父类的实现</strong>： 如果在子类中重写了父类的方法，并且还想保留父类方法的行为，可以在子类方法中使用 <code>super()</code> 调用父类的方法。</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello from Parent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().say_hello()  <span class="comment"># 调用父类的 say_hello 方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello from Child&quot;</span>)</span><br></pre></td></tr></table></figure></div><ol start="3"><li><strong>多重继承中解决方法解析顺序（Method Resolution Order, MRO）问题</strong>： 在使用多重继承时，<code>super()</code> 被用来确保每个父类都被适当地初始化或调用相应的方法。它按照方法解析顺序遍历所有的基类。</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Base init&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A init&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B init&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Child init&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>总之，<code>super()</code> 的使用有助于确保父类的适当初始化和方法调用，尤其是在有继承关系的类之间。这有助于减少代码重复，并确保继承体系中的逻辑一致性。</p>    </div>  </div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f05c1c2f-dd09-4bad-4b05-64b6268e2400/public"                                     >]]></content>
    
    
    <summary type="html">Python 面对像基础</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="基本语法" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    <category term="对象" scheme="https://www.yiuhangblog.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="面向对象编程" scheme="https://www.yiuhangblog.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    <category term="类" scheme="https://www.yiuhangblog.com/tags/%E7%B1%BB/"/>
    
    <category term="继承" scheme="https://www.yiuhangblog.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="多态" scheme="https://www.yiuhangblog.com/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="封装" scheme="https://www.yiuhangblog.com/tags/%E5%B0%81%E8%A3%85/"/>
    
    <category term="抽象" scheme="https://www.yiuhangblog.com/tags/%E6%8A%BD%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="https://www.yiuhangblog.com/2018/08/12/20180812%E5%87%BD%E6%95%B0/"/>
    <id>https://www.yiuhangblog.com/2018/08/12/20180812%E5%87%BD%E6%95%B0/</id>
    <published>2018-08-12T08:43:23.000Z</published>
    <updated>2024-02-28T10:49:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><p>函数是一段可重复使用的代码块，用于执行特定的任务</p><h3 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h3><ol><li>提高代码的可重用性: 使用函数可以将代码块组织成更小的可重用模块，减少代码的冗余。</li><li>提高代码的可读性: 使用函数可以使代码更加简洁和易于理解，也更容易进行调试和维护。</li><li>提高代码的模块化: 使用函数可以将程序分解成更小的模块，每个模块都可以处理特定的任务，这样程序的组织结构更加清晰。</li><li>提高代码的可扩展性: 使用函数可以使程序更易于扩展和修改，因为函数可以独立地编写和测试，而不会影响程序的其他部分。</li></ol>  <div class="note p-4 mb-4 rounded-small info icon-padding">    <i class="note-icon fa-solid fa-circle-info"></i><p>函数就是设计一个技能需要时自己调用，调用的方法本质上是个函数 。两者的区别是使用的方式不一样。</p>  </div><h3 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用def定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">User</span>():</span><br><span class="line">    内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数 必须顶格</span></span><br><span class="line">User()</span><br></pre></td></tr></table></figure></div><h2 id="函数的形参和实参"><a href="#函数的形参和实参" class="headerlink" title="函数的形参和实参"></a>函数的形参和实参</h2><ol><li>不传值给函数可以不带形参和实参</li><li>形参名字可以随意定义</li><li>形参和实参数量必须一致</li><li>实参对应形参</li><li>形参可以赋默认参数 没有传就以默认参数 传了就以实参</li><li>实参也可以指定形参</li><li>通过*形参名可以获取所有实参，通过索引获取对应实参</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用def定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">User</span>(<span class="params">形参</span>):</span><br><span class="line">    内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数 必须顶格</span></span><br><span class="line">User(实参)</span><br></pre></td></tr></table></figure></div><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 形参的默认参数</span></span><br><span class="line"><span class="comment"># 如果没有传就以默认参数 传了就以实参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user(<span class="number">13</span>, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13</span></span><br><span class="line"><span class="comment"># 14</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过*形参名可以获取所有实参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>(<span class="params">*item</span>):</span><br><span class="line">    <span class="comment"># 通过形参名索引获取对应实参</span></span><br><span class="line">    <span class="built_in">print</span>(item[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user(<span class="number">13</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13</span></span><br></pre></td></tr></table></figure></div><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>Python自带的一些函数，我们可以直接拿来使用</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 类型判断</span></span><br><span class="line"><span class="built_in">type</span>()</span><br><span class="line"><span class="comment"># 字符串、列表、元组、集合 的增删改查的方法</span></span><br></pre></td></tr></table></figure></div>  <div class="note p-4 mb-4 rounded-small primary icon-padding">    <i class="note-icon fa-solid fa-square-arrow-up-right"></i><p>字符串、列表、元组、集合 的增删改查的方法<a class="button " href='https://www.yiuhangblog.com/2018/07/23/20180723%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/' title='数值类型'><i class='fa-solid fa-play-circle'></i> 数值类型</a>，详细内容与调用方法跳转查阅</p>  </div><h2 id="函数的说明文档"><a href="#函数的说明文档" class="headerlink" title="函数的说明文档"></a>函数的说明文档</h2><ol><li>给函数中的代码做解释说明</li><li>让其他程序员知道函数的作用</li><li>函数里的注释</li></ol><h3 id="如何写说明文档"><a href="#如何写说明文档" class="headerlink" title="如何写说明文档"></a>如何写说明文档</h3><ul><li>三引号包裹</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">内容</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个函数用于计算两个数的和。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param a: 第一个加数</span></span><br><span class="line"><span class="string">    :param b: 第二个加数</span></span><br><span class="line"><span class="string">    :return: 两个数的和</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></div><h2 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h2><p>在函数内部调用其它函数</p><p>尽量不要嵌套太多层，不然就是屎山了</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.定义一个函数a</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是函数a&#x27;</span>)</span><br><span class="line">    <span class="comment"># 3.在函数a内部调用函数b</span></span><br><span class="line">    b()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义一个函数b</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是函数b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.调用函数a</span></span><br><span class="line">a() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 我是函数a</span></span><br><span class="line"><span class="comment"># 我是函数b</span></span><br></pre></td></tr></table></figure></div><h2 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a>函数的作用域</h2><p>Python 中的函数作用域分为两种: 全局作用域和局部作用域</p><ol><li>全局作用域指的是在模块(文件)中定义的变量和函数，可以在模块的任何地方被访问和使用</li><li>局部作用域指的是在函数内部定义的变量和函数，只能在该函数内部被访问和使用</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/a728cb1a-a479-43ab-1aa5-318e65e52f00/public"                      width="200"                ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量a 全局作用域</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 函数textA</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">textA</span>():</span><br><span class="line">    <span class="comment"># 变量b 局部作用域</span></span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为变量a在全局作用域 所以可以访问到</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># 100</span></span><br><span class="line"><span class="comment"># 因为变量b 在局部作用域 变量b 访问不到 所以会报错</span></span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment"># NameError: name &#x27;b&#x27; is not defined</span></span><br></pre></td></tr></table></figure></div><h3 id="global-关键字"><a href="#global-关键字" class="headerlink" title="global 关键字"></a>global 关键字</h3><p>使用 <code>global</code> 关键字 可以在函数内部声明变量为全局变量</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义两个变量 textA textB</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">textA</span>():</span><br><span class="line">    <span class="comment"># gLobal 声明 money 为全局变量</span></span><br><span class="line">    <span class="keyword">global</span> money</span><br><span class="line">    money = <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">textB</span>():</span><br><span class="line">    <span class="built_in">print</span>(money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">textA() <span class="comment"># 100</span></span><br><span class="line">textB() <span class="comment"># 100</span></span><br></pre></td></tr></table></figure></div><h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包 Closure"></a>闭包 Closure</h2><p>内部函数使用了外部函数的变量 </p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="comment"># 外部函数</span></span><br><span class="line">    <span class="comment"># 1. 变量a 是func函数的局部变量</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数func调用&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(): <span class="comment"># 内部函数</span></span><br><span class="line">        <span class="comment"># 2. 我们在func1这个内部函数里面 使用了 外部函数的变量a 这种现象就叫闭包，没有用到 变量 就不叫闭包</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func1  <span class="comment"># 3. 我们需要返回func1函数的本身给外部函数 才能看到闭包的效果 闭包不需要调用只需要返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo = func() <span class="comment"># 函数func调用</span></span><br><span class="line">demo() <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者func()()</span></span><br></pre></td></tr></table></figure></div><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>好处: 保存局部变量的状态 我们可以将相关的功能和数据绑定在一起，而不用担心数据被其他代码修改。</p><p>应用：想保存数据状态和不被污染 我们就可以使用闭包。很多框架底层 保存数据都是用的闭包</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> a  <span class="comment"># nonlocal 指向外部函数func的a 不会指向全局作用域 如果外部func没有a就会报错</span></span><br><span class="line">        a += <span class="number">1</span>  <span class="comment"># 累加，主要做逻辑处理，每次调用func1就会累加1</span></span><br><span class="line">        <span class="keyword">return</span> a  <span class="comment"># 将累加的结果返回出来给func1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func1  <span class="comment"># 返func1本身传递给func 覆盖原始a=0 我们才能看到闭包的效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目的调用func1 让a累加一次</span></span><br><span class="line"><span class="comment"># 需要调用看结果</span></span><br><span class="line">demo = func()</span><br><span class="line"><span class="comment"># 通过demo来调用里面的func1</span></span><br><span class="line"><span class="built_in">print</span>(demo())</span><br><span class="line"><span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(demo())</span><br><span class="line"><span class="comment"># 输出 2</span></span><br><span class="line"><span class="built_in">print</span>(demo())</span><br><span class="line"><span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure></div><ol><li>因此可以发现通过闭包，可以使得数据状态得到存储，例如存储累加的结果</li><li>且闭包的数据无法通过全局变量进行修改，保证数据完整性，因为是由子函数进行累加的</li><li>需要保存数据状态的时候就需要使用闭包</li><li>使用场景例如 第三方库 能够保存数据状态</li></ol>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;Global&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun_out</span>():</span><br><span class="line">    a = <span class="string">&quot;external_function&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fun_in</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo = fun_out()</span><br><span class="line">demo() <span class="comment"># external_function</span></span><br></pre></td></tr></table></figure></div><p>在 Python 中，变量的使用和修改遵循不同的规则，特别是在涉及嵌套函数时。这是因为 Python 对变量的查找（读取）和赋值（修改）有不同的作用域规则。</p><ol><li><strong>读取变量</strong>：当代码尝试读取一个变量的值时（如在 <code>print(a)</code> 中），Python 会遵循作用域查找规则。这意味着它会首先在当前函数的局部作用域查找该变量。如果在当前作用域找不到，它会在外围作用域中查找，一直查找到全局作用域，最后是内置作用域。这就是为什么在上面的例子中，即使没有使用 <code>nonlocal</code> 关键字，<code>fun_in</code> 也能访问 <code>fun_out</code> 中定义的 <code>a</code> 变量。</li><li><strong>修改变量</strong>：当尝试修改一个变量的值时，Python 的默认行为是在当前作用域创建或更新该变量。如果在一个嵌套的函数中不加声明地修改一个变量，Python 会认为这是一个新的局部变量，而不是一个外围作用域中的变量。<ul><li><strong>使用 <code>nonlocal</code> 关键字</strong>：当想在一个嵌套函数中修改外围函数的局部变量时，需要使用 <code>nonlocal</code> 关键字。这样做可以告诉 Python 想修改的是外围作用域中的变量，而不是创建一个新的局部变量。</li><li><strong>全局变量</strong>：如果想在一个函数中修改全局变量，而不是创建同名的局部变量，需要使用 <code>global</code> 关键字。</li></ul></li></ol><p>这种区分是为了避免意外修改外围作用域中的变量，这可能会导致难以追踪的错误。通过要求显式声明 <code>nonlocal</code> 或 <code>global</code>，Python 增强了代码的可读性和可维护性。</p>    </div>  </div><h3 id="闭包（Closure）和嵌套函数（Nested-Functions）的区别"><a href="#闭包（Closure）和嵌套函数（Nested-Functions）的区别" class="headerlink" title="闭包（Closure）和嵌套函数（Nested Functions）的区别"></a>闭包（Closure）和嵌套函数（Nested Functions）的区别</h3><p><strong>闭包（Closure）</strong></p><p>在编程中，闭包是指那些能够访问自己外部作用域中变量的函数。一个闭包至少由两部分组成：一个函数以及该函数引用的外部变量。Python 中闭包的一个关键特征是它保持了对其外部变量的引用，即使在外部函数已经结束执行之后。</p><p>在代码中，<code>fun_in</code> 是一个闭包，因为它是在 <code>fun_out</code> 内部定义的，并且引用了 <code>fun_out</code> 作用域内的变量 <code>a</code>。当 <code>fun_out</code> 被调用并返回 <code>fun_in</code> 时，尽管 <code>fun_out</code> 的执行已经结束，<code>fun_in</code> 依然保留了对变量 <code>a</code> 的引用。这样，即使是在 <code>fun_out</code> 执行完毕之后，<code>fun_in</code> 仍然可以访问并打印变量 <code>a</code> 的值。</p><p><strong>嵌套函数（Nested Functions）</strong></p><p>嵌套函数是在另一个函数内部定义的函数。虽然所有闭包都是嵌套函数，但并非所有嵌套函数都是闭包。一个嵌套函数只有在引用了其外部函数的变量时，它才构成一个闭包。</p><p><strong>总结</strong></p><p><code>fun_in</code> 作为一个闭包，即使在其外部函数 <code>fun_out</code> 执行完毕后，仍然可以访问并使用 <code>fun_out</code> 作用域中的变量 <code>a</code>。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数，通常在 Python 中通过 <code>lambda</code> 关键字来定义，是一种没有显式函数名的简短函数。它们在语法上是简洁的，通常用于编写小的、一次性的、不需要单独定义函数名的函数。</p><p>匿名函数是一个可以定义并立即使用的简洁函数形式。在 Python 中，匿名函数使用 <code>lambda</code> 关键字创建，其基本语法是：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数列表: 表达式</span><br></pre></td></tr></table></figure></div><p>这种函数通常用于简单的操作，比如简单的数学运算、字符串操作等。由于它们只是单个表达式，所以不能像普通函数那样执行复杂的操作</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lambda : 8 创建了一个匿名函数，这个函数没有参数，并且总是返回数字 8</span></span><br><span class="line"></span><br><span class="line">func = <span class="keyword">lambda</span> : <span class="number">8</span> <span class="comment"># lambda 关键字 代表匿名函数</span></span><br><span class="line"><span class="built_in">print</span>(func()) <span class="comment"># 输出: 8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数的一个限制是它只能包含一个表达式，不能包含多个独立的语句或复杂的逻辑。如果函数体较复杂，或者需要重复使用，那么定义一个普通函数会更合适。它与匿名函数执行相同的操作，但是更适合复杂逻辑或多次调用的情况。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>() :</span><br><span class="line"><span class="keyword">return</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func())</span><br></pre></td></tr></table></figure></div><h3 id="匿名函数的作用"><a href="#匿名函数的作用" class="headerlink" title="匿名函数的作用"></a>匿名函数的作用</h3><p>匿名函数的主要作用是简化代码，尤其是在需要小的函数作为参数时，例如在排序操作、高阶函数（如 <code>map()</code>、<code>filter()</code>）或任何需要函数对象的地方。由于它们不需要定义传统的函数结构，因此可以在代码中快速定义和使用。</p><h3 id="何时使用匿名函数"><a href="#何时使用匿名函数" class="headerlink" title="何时使用匿名函数"></a>何时使用匿名函数</h3><p>匿名函数通常在以下情况下使用：</p><ol><li><strong>简单的功能</strong>：当函数的功能非常简单，只需要一行代码就可以实现时，使用匿名函数是一个很好的选择。</li><li><strong>一次性使用</strong>：当有一个不会在代码的其他地方复用的小函数时，使用匿名函数可以减少不必要的函数定义。</li><li><strong>作为参数传递</strong>：当一个函数接受另一个函数作为参数时，如果这个参数函数非常简短，使用匿名函数可以使代码更加清晰。常见的例子包括 <code>map()</code>、<code>filter()</code> 和 <code>sorted()</code> 等函数。</li></ol>  <div class="note-large green">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-question"></i><p>QA</p>    </div>    <div class="notel-content">      <p><strong>问：</strong></p><p>函数通过function关键字定义吗？</p><p><strong>答：</strong></p><p>这个说法是错误的。在Python中，函数是通过 <code>def</code> 关键字来定义的，而不是 <code>function</code>。例如：<code>def my_function():</code>。</p><p><strong>问：</strong></p><p>调用函数使用函数名即可吗？</p><p><strong>答：</strong></p><p>这个说法是正确的。在Python中，函数通过其名称来调用，可能跟随一对圆括号和必要的参数。例如，如果有一个名为 <code>my_function</code> 的函数，可以通过 <code>my_function()</code> 来调用它。</p><p><strong>问：</strong></p><p>函数必须要有返回值return</p><p><strong>答：</strong></p><p>这个说法是错误的。函数不一定需要有 <code>return</code> 语句。如果没有 <code>return</code> 语句，函数默认返回 <code>None</code>。<code>return</code> 语句用于从函数中返回一个值。</p><p><strong>问：</strong></p><p>函数里面直接定义的变量外部不能访问</p><p><strong>答：</strong></p><p>这个说法是正确的，但需要一些澄清。在Python中，函数内部定义的变量是局部的，意味着它们只在函数内部可见。外部代码不能直接访问函数内部的局部变量。然而，如果需要在外部访问这些变量的值，可以通过函数返回这些值来实现。</p>    </div>  </div>]]></content>
    
    
    <summary type="html">Python 基础函数语法</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="嵌套" scheme="https://www.yiuhangblog.com/tags/%E5%B5%8C%E5%A5%97/"/>
    
    <category term="基本语法" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    <category term="内置函数" scheme="https://www.yiuhangblog.com/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    
    <category term="形参" scheme="https://www.yiuhangblog.com/tags/%E5%BD%A2%E5%8F%82/"/>
    
    <category term="实参" scheme="https://www.yiuhangblog.com/tags/%E5%AE%9E%E5%8F%82/"/>
    
    <category term="说明文档" scheme="https://www.yiuhangblog.com/tags/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"/>
    
    <category term="作用域" scheme="https://www.yiuhangblog.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    <category term="闭包" scheme="https://www.yiuhangblog.com/tags/%E9%97%AD%E5%8C%85/"/>
    
    <category term="匿名函数" scheme="https://www.yiuhangblog.com/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>控制流程</title>
    <link href="https://www.yiuhangblog.com/2018/08/02/20180802%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.yiuhangblog.com/2018/08/02/20180802%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2018-08-02T03:13:45.000Z</published>
    <updated>2024-02-28T10:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="前置知识：Input方法"><a href="#前置知识：Input方法" class="headerlink" title="前置知识：Input方法"></a>前置知识：Input方法</h3><p>在 Python 中，<code>input()</code>是一个内置函数，用于从标准输入中获取用户输入的数据</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>输入的值是字符串类型</li><li>如果想输入是整数 那就需要进行类型转换</li></ol><p><code>a = int(input(&quot;请输入想输入的内容&#39;))</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量a 就存储着用户输入的数据</span></span><br><span class="line">a = <span class="built_in">input</span>(<span class="string">&#x27;请输入想输入的内容 )</span></span><br><span class="line"><span class="string"># 当我们输入完后可以通过print将输入的内容打印出来</span></span><br><span class="line"><span class="string">print(a)</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c673f6f3-43db-4e16-3a3c-8ce974b1d800/public"                      width = "500"                ><h3 id="什么是条件判断"><a href="#什么是条件判断" class="headerlink" title="什么是条件判断"></a>什么是条件判断</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cc177145-641c-4827-32fb-f88801869300/public"                      width = "300"                ><p>条件判断是编程中一种非常常见的控制结构，它可以帮助我们根据不同的条件来执行不同的代码。可以把它想象成我们生活中的决策过程。</p><p>判断的过程中，比较的类型需要一样，例如都是数值类型</p><h4 id="1-语法："><a href="#1-语法：" class="headerlink" title="1. 语法："></a>1. 语法：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件:</span><br><span class="line"><span class="comment"># 执行语句....</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 执行语句....</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># if：如果</span></span><br><span class="line"><span class="comment"># else 否则</span></span><br><span class="line"><span class="comment"># if 可以单独存在，如果不满足就不会执行if里面的代码，但会继续执行if外面的代码</span></span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/9226266c-9c6b-4dca-5e80-73e0c572eb00/public"                      width = "500"                ><h4 id="2-案例-1"><a href="#2-案例-1" class="headerlink" title="2. 案例 1"></a>2. 案例 1</h4><p>假如天气晴朗，我就去打篮球，否则我就去看电影。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个a变量 存储今天的天气</span></span><br><span class="line">a = <span class="built_in">input</span>(<span class="string">&#x27;输入今天的天气:&#x27;</span>) </span><br><span class="line"><span class="keyword">if</span> a == <span class="string">&#x27;晴天&#x27;</span>: <span class="comment"># == 是否等于</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;今天是晴天,我要出去打篮球&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;今天是下雨天,我要去看电影&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c8c279d2-95e6-4b4e-a1ab-686a3bf08900/public"                      width = "500"                ><h4 id="3-案例-2"><a href="#3-案例-2" class="headerlink" title="3. 案例 2"></a>3. 案例 2</h4><p>随意输入0-100的整数，如果大于60 就在控制台返回  会当凌绝顶一览众山小 如果小于60就返回 三十年河东三十年河西 莫欺少年穷</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;随意输入0-100的整数:&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;会当凌绝顶一览众山小&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;三十年河东三十年河西 莫欺少年穷&#x27;</span>)</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/3676eea8-7f15-4bb8-d94a-c6cf8f1db600/public"                      width = "500"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/73f965d3-ea54-4b85-a67c-76ef7f266e00/public"                      width = "500"                ><h3 id="多个条件判断"><a href="#多个条件判断" class="headerlink" title="多个条件判断"></a>多个条件判断</h3><h4 id="1-什么是多个条件判断"><a href="#1-什么是多个条件判断" class="headerlink" title="1. 什么是多个条件判断"></a>1. 什么是多个条件判断</h4><p>有些时候，我们的判断语句不可能只有两个，有些时候需要多个，比如说大于等于 60 的为及格，那我们还要判断大于等于 90 的为优秀，在 80 到 90 之间的良好呢？</p><p>这时候需要用到 if 语句多个判断条件</p><h4 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line"><span class="comment"># 执行语句1.....</span></span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line"><span class="comment"># 执行语句2.....</span></span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line"><span class="comment"># 执行语句3.....</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 执行语句4.....</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if：如果</span></span><br><span class="line"><span class="comment"># elif:或者</span></span><br><span class="line"><span class="comment"># else 否则</span></span><br></pre></td></tr></table></figure></div><h4 id="3-案例-1"><a href="#3-案例-1" class="headerlink" title="3. 案例 1"></a>3. 案例 1</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入分数&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">90</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> a &gt;= <span class="number">80</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;良好&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> a &gt;= <span class="number">60</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;及格&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;恭喜 没有及格 )</span></span><br></pre></td></tr></table></figure></div><h4 id="4-案例-2"><a href="#4-案例-2" class="headerlink" title="4. 案例 2"></a>4. 案例 2</h4><p>有时候我们会遇到多个条件的时候该怎么操作呢？</p><p>比如说：学校举行一场考试，要求小明的python和java两门语言 都达到80分才算优秀。</p><ul><li>这时候我们可以结合 or 和 and 来使用。</li><li>or (或)表示两个条件有一个成立时判断条件成功</li><li>and (与)表示只有两个条件同时成立的情况下，判断条件才成功。</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入python分数&#x27;</span>))</span><br><span class="line">java = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入java分数&#x27;</span>))</span><br><span class="line"><span class="comment"># 当我们输入完 我们的变量python和java就分别存储着 python和java的分数</span></span><br><span class="line"><span class="keyword">if</span> python &gt;= <span class="number">80</span> <span class="keyword">and</span> java &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;不优秀&#x27;</span>)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入python分数&#x27;</span>))</span><br><span class="line">java = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入java分数&#x27;</span>))</span><br><span class="line"><span class="comment"># 当我们输入完 我们的变量python和java就分别存储着 python和java的分数</span></span><br><span class="line"><span class="comment"># 将and改为or 就意味着 只需要一个条件满足就是优秀</span></span><br><span class="line"><span class="keyword">if</span> python &gt;= <span class="number">80</span> <span class="keyword">or</span> java &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;不优秀&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><h4 id="1-嵌套是指什么"><a href="#1-嵌套是指什么" class="headerlink" title="1. 嵌套是指什么"></a>1. 嵌套是指什么</h4><p>就跟字面意思差不多，指 if 语句中可以嵌套 if 语句。</p><h4 id="2-案例-1-1"><a href="#2-案例-1-1" class="headerlink" title="2. 案例 1"></a>2. 案例 1</h4><p>小明，平时正常上班太累了，到了周末如果是晴天，那就出去打篮球，如果不是那就在家看电视</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量来保存今天是不是周末</span></span><br><span class="line"><span class="comment"># 定义一个变量b来保存今天的天气</span></span><br><span class="line">a = <span class="string">&#x27;周末&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;晴&#x27;</span></span><br><span class="line"><span class="keyword">if</span> a == <span class="string">&#x27;周末&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">&#x27;晴&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;今天是周末，又是晴天可以去打篮球&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;今天是周末，但是下雨在家乖乖看电视&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;乖乖上班&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="match…case"><a href="#match…case" class="headerlink" title="match…case"></a>match…case</h3><p>Python 3.10 引入了 <code>match...case</code> 语句，提供了一种更加结构化和可读性更强的方式来进行条件判断。这个新特性使得编写复杂的条件逻辑变得更加简单和直观，是 Python 对模式匹配功能的实现。以下是对 <code>match...case</code> 语句的使用方法和特点的详细解析。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><code>match...case</code> 语句的基本语法如下：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> subject:</span><br><span class="line">    <span class="keyword">case</span> 条件<span class="number">1</span>:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    <span class="keyword">case</span> 条件<span class="number">2</span>:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    <span class="keyword">case</span> 条件<span class="number">3</span>:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure></div><ul><li><strong><code>match</code></strong> 后面跟着的是要匹配的对象（subject）。</li><li><strong><code>case</code></strong> 后面定义了匹配的条件，如果 <code>subject</code> 满足某个条件，则执行该 <code>case</code> 下的代码块。</li><li>**<code>_</code>**（通配符）用于匹配所有未被前面的 <code>case</code> 匹配的情况。</li></ul><h4 id="多条件匹配"><a href="#多条件匹配" class="headerlink" title="多条件匹配"></a>多条件匹配</h4><p>一个 <code>case</code> 语句可以包含多个用管道符（<code>|</code>）隔开的匹配条件，如果 <code>subject</code> 与其中任何一个条件相匹配，则执行该 <code>case</code> 下的代码块。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> subject:</span><br><span class="line">    <span class="keyword">case</span> 条件<span class="number">1</span> | 条件<span class="number">2</span>:</span><br><span class="line">        &lt;action_1_2&gt;</span><br><span class="line">    <span class="keyword">case</span> 条件<span class="number">3</span>:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure></div><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>match...case</code> 语句适用于需要基于一个对象的值或类型进行多个条件判断的场景。它使得代码更加清晰易读，特别是在处理复杂的条件逻辑时，相比于传统的多层 <code>if-else</code> 语句，提供了更好的可读性和效率。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是一个使用 <code>match...case</code> 语句的示例，根据不同的水果名称打印相应的颜色：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fruit = <span class="string">&quot;apple&quot;</span></span><br><span class="line"><span class="keyword">match</span> fruit:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;banana&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;orange&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Unknown color&quot;</span>)</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <ul><li><code>match...case</code> 语句是 Python 3.10 及以后版本的新特性，在此之前的版本中不可用。</li><li>使用 <code>match...case</code> 时，需要确保 <code>case</code> 后的条件覆盖了所有可能的情况，或者使用通配符 <code>_</code> 来处理未匹配到的情况。</li></ul>    </div>  </div><h3 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h3><ol><li>也叫三元运算符，是一种简洁的条件语句表达式。它可以根据条件的成立与否来返回两个值中的一个。</li></ol><p>​<strong>作用</strong>：简化代码</p><ol start="2"><li>之前案例，今天学校期末数学考试(60分及格)，小明考了66分，请问小明是及格还是没有及格。</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量a 来保存小明的数学成绩</span></span><br><span class="line">a = <span class="number">66</span></span><br><span class="line"><span class="comment"># 三目运算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;及格&#x27;</span>) <span class="keyword">if</span> a &gt; <span class="number">6</span> <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&#x27;不及格&#x27;</span>)</span><br><span class="line"><span class="comment"># 普通的if判断</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;及格&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;不及格&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/24f0e2f3-68ec-41a8-feba-650fee02d600/public"                      width = "300"                ><p>Python 提供了 for 循环和 while 循环（在 Python 中没有 do..while 循环）:</p><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a class="link"   href="https://www.runoob.com/python/python-while-loop.html" >while 循环 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td align="left">在给定的判断条件为 true 时执行循环体，否则退出循环体。</td></tr><tr><td align="left"><a class="link"   href="https://www.runoob.com/python/python-for-loop.html" >for 循环 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td align="left">重复执行语句</td></tr><tr><td align="left"><a class="link"   href="https://www.runoob.com/python/python-nested-loops.html" >嵌套循环 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td align="left">你可以在while循环体中嵌套for循环</td></tr></tbody></table><hr><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：</p><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a class="link"   href="https://www.runoob.com/python/python-break-statement.html" >break 语句 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td align="left">在语句块执行过程中终止循环，并且跳出整个循环</td></tr><tr><td align="left"><a class="link"   href="https://www.runoob.com/python/python-continue-statement.html" >continue 语句 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td align="left">在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。</td></tr><tr><td align="left"><a class="link"   href="https://www.runoob.com/python/python-pass-statement.html" >pass 语句 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td align="left">pass是空语句，是为了保持程序结构的完整性。</td></tr></tbody></table><h4 id="1-什么是循环"><a href="#1-什么是循环" class="headerlink" title="1. 什么是循环"></a>1. 什么是循环</h4><p>可以让程序自动地执行多次相同或类似的任务，从而节省编写代码的时间和精力。</p><p>一共有两种循环：</p><ul><li>for循环</li><li>while循环</li></ul><h4 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/5c8d448b-5499-4a90-3b97-393396b85700/public"                      width = "300"                ><p>可以遍历一个序列或其他可迭代对象中的元素，并执行特定的代码块。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 形参 <span class="keyword">in</span> 遍历对象: </span><br><span class="line"><span class="built_in">print</span>(形参)</span><br></pre></td></tr></table></figure></div>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><strong>对象（Objects）</strong>：</p><p>在Python中，几乎所有东西都是对象。这包括数字、字符串、列表、函数，甚至是类和类型本身。每个对象都有三个特性：身份、类型和值。</p><ul><li>身份：每个对象都有一个唯一的身份，用于区分不同的对象。可以通过 <code>id()</code> 函数来查看对象的身份。</li><li>类型：对象的类型定义了它可以进行哪些操作或拥有哪些方法。类型可以通过 <code>type()</code> 函数查看。</li><li>值：对象表示的数据。</li></ul><p><strong>形参（Formal Parameters）</strong>：</p><p>当定义一个函数时，可以在函数定义中指定一些参数。这些参数被称为形式参数（形参），它们是函数内部的局部变量。当函数被调用时，形参会接收传递给函数的实际值。这些值被称为实参（实际参数）。</p><p>例如：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):  <span class="comment"># a 和 b 是形参</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>a</code> 和 <code>b</code> 是形参，它们在函数 <code>add</code> 被调用时接收实际的输入值。</p>    </div>  </div><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 案例: 将List的内容全部打印出来</span></span><br><span class="line"><span class="comment"># 定义一个列表List</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;梨子&#x27;</span>]</span><br><span class="line"><span class="comment"># 以前</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 如果List里面有1000 个值呢，是不是要写一干遍</span></span><br><span class="line"><span class="comment"># 我们学习for循环后</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></div><h5 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h5><p>Python 中的 <code>range()</code> 函数是一个非常有用的工具，用于生成一个不可变的数值序列。与 <code>for</code> 循环结合使用时，<code>range()</code> 使得遍历数字序列变得简单高效。这个函数在数据迭代、循环执行等多种场景下都有广泛应用。</p><h6 id="功能和用法"><a href="#功能和用法" class="headerlink" title="功能和用法"></a>功能和用法</h6><ul><li><strong>生成数字序列</strong>：<code>range()</code> 可以生成一个从起始值到终值（不包含终值），按照指定步长的数字序列。</li></ul><h6 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(stop)</span><br><span class="line"><span class="built_in">range</span>(start, stop[, step])</span><br></pre></td></tr></table></figure></div><ul><li>**<code>start</code>**：序列的起始值，默认为0。</li><li>**<code>stop</code>**：序列的终止值，生成的序列不包含此值。</li><li>**<code>step</code>**：序列中每个数之间的差（步长），默认为1。当步长为正时，序列按升序排列；步长为负时，序列按降序排列。</li></ul><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><ul><li><strong>基本遍历</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 输出 0 到 4</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>指定区间的值</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 输出 5 到 8</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>指定步长</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 输出 0, 2, 4, 6, 8</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>反方向迭代</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">8</span>, -<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 输出 0, -2, -4, -6</span></span><br></pre></td></tr></table></figure></div><h6 id="访问和转换"><a href="#访问和转换" class="headerlink" title="访问和转换"></a>访问和转换</h6><ul><li><strong>通过下标访问</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>])  <span class="comment"># 输出 1 2</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>转换为列表、元组、集合</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">8</span>, -<span class="number">2</span>))</span><br><span class="line">b = <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">8</span>, -<span class="number">2</span>))</span><br><span class="line">c = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">8</span>, -<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 [0, -2, -4, -6]</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出 (0, -2, -4, -6)</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出 &#123;0, -2, -4, -6&#125;</span></span><br></pre></td></tr></table></figure></div><h6 id="结合-len-遍历序列索引"><a href="#结合-len-遍历序列索引" class="headerlink" title="结合 len() 遍历序列索引"></a>结合 <code>len()</code> 遍历序列索引</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;QQ&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="built_in">print</span>(i, a[i])</span><br></pre></td></tr></table></figure></div><h5 id="列表、元组、集合、字典、字符串的for循环的使用案例"><a href="#列表、元组、集合、字典、字符串的for循环的使用案例" class="headerlink" title="列表、元组、集合、字典、字符串的for循环的使用案例"></a>列表、元组、集合、字典、字符串的for循环的使用案例</h5>  <div class="note p-4 mb-4 rounded-small primary icon-padding">    <i class="note-icon fa-solid fa-square-arrow-up-right"></i><p>列表、元组、集合、字典、字符串皆为<a class="button " href='https://www.yiuhangblog.com/2018/07/23/20180723%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/' title='数值类型'><i class='fa-solid fa-play-circle'></i> 数值类型</a>，详细内容与调用方法跳转查阅</p>  </div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表</span></span><br><span class="line">List_test = [<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;梨子&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> List_test:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># 香蕉</span></span><br><span class="line"><span class="comment"># 苹果</span></span><br><span class="line"><span class="comment"># 梨子</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 元组</span></span><br><span class="line">tuple_test = (<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;梨子&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> tuple_test:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># 香蕉</span></span><br><span class="line"><span class="comment"># 苹果</span></span><br><span class="line"><span class="comment"># 梨子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line">set_test = &#123;<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;梨子&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> set_test:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># 香蕉</span></span><br><span class="line"><span class="comment"># 苹果</span></span><br><span class="line"><span class="comment"># 梨子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典</span></span><br><span class="line">dict_test = &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dict_test:</span><br><span class="line">    <span class="comment"># 在字典中 item:key</span></span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="comment"># 如果想拿到vaLue的值 : List[item] </span></span><br><span class="line">    <span class="built_in">print</span>(item, dict_test[item])</span><br><span class="line"><span class="comment"># username</span></span><br><span class="line"><span class="comment"># username user</span></span><br><span class="line"><span class="comment"># age</span></span><br><span class="line"><span class="comment"># age 25</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#字符串</span></span><br><span class="line">str_test = <span class="string">&#x27;hello word&#x27;</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> str_test:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># h</span></span><br><span class="line"><span class="comment"># e</span></span><br><span class="line"><span class="comment"># l</span></span><br><span class="line"><span class="comment"># l</span></span><br><span class="line"><span class="comment"># o</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># w</span></span><br><span class="line"><span class="comment"># o</span></span><br><span class="line"><span class="comment"># r</span></span><br><span class="line"><span class="comment"># d</span></span><br></pre></td></tr></table></figure></div><h5 id="双层for循环"><a href="#双层for循环" class="headerlink" title="双层for循环"></a>双层for循环</h5><p>也可以用于遍历嵌套的数据结构</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表里面包字典，这是开发最常见的一种数据方式，我们需要把里面的数据给拿出来</span></span><br><span class="line">list_dic = [&#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;users1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;users2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span></span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一层for循环遍历出两个字典</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list_dic:</span><br><span class="line">    <span class="comment"># 第二层for循环遍历出字典里面的值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> item: <span class="comment"># 通过i形参就是传递出字典里的值</span></span><br><span class="line">        <span class="comment"># item就是字典本身，通过遍历item获取value</span></span><br><span class="line">        <span class="built_in">print</span>(i, item[i]) <span class="comment"># items 就是拿到了，item字典里面的key</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># username users1</span></span><br><span class="line"><span class="comment"># age 18</span></span><br><span class="line"><span class="comment"># username users2</span></span><br><span class="line"><span class="comment"># age 20</span></span><br></pre></td></tr></table></figure></div><h4 id="3-while循环"><a href="#3-while循环" class="headerlink" title="3. while循环"></a>3. while循环</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/c3671659-e5fe-44ab-5f17-2344ef1b5500/public"                      width = "300"                ><p>常见的循环结构，它可以在条件满足的情况下重复执行一段代码块，直到条件不再满足为止。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件: </span><br><span class="line">输出内容</span><br></pre></td></tr></table></figure></div><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">11</span></span><br><span class="line"><span class="keyword">while</span> a &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="comment"># 这样会陷入无尽的循环 因为a会一直大于 10 这个时候</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a大于10 这行代码就会一直运行&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span> <span class="comment">#我们可以用break来终止</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a大于10 这行代码就会一直运行</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">8</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="comment"># 可以在循环里面加改变条件的运算 让循环变成 有限循环 而不是无限循环</span></span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># aaaaaaa</span></span><br><span class="line"><span class="comment"># aaaaaaa</span></span><br></pre></td></tr></table></figure></div>  <div class="note-large green">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-question"></i><p>QA</p>    </div>    <div class="notel-content">      <p><strong>问：</strong></p><p><code>break</code>用于退出当前循环？</p><p><strong>答：</strong></p><p>在Python中，<code>break</code> 语句用于立即退出循环，无论是 <code>for</code> 循环还是 <code>while</code> 循环。一旦执行了 <code>break</code>，循环将完全终止。</p><p><strong>问：</strong></p><p><code>for</code>对可迭代对象进行遍历</p><p><strong>答：</strong></p><p><code>for</code> 循环在Python中用于遍历可迭代对象（如列表、字符串、元组等），对其中的每个元素执行循环体内的语句。</p><p><strong>问：</strong></p><p><code>break</code>和<code>continue</code>必须成对出现</p><p><strong>答：</strong></p><p>这个说法是错误的。<code>break</code> 和 <code>continue</code> 是两个不同的循环控制语句，它们可以独立使用。<code>break</code> 用于完全退出循环，而 <code>continue</code> 用于跳过当前循环的剩余部分并继续执行下一次循环迭代。它们没有必须成对出现的要求。</p><p><strong>问：</strong></p><p><code>continue</code>是退出当前循环，继续下一轮循环</p><p><strong>答：</strong></p><p>这个说法是正确的，但需要稍微澄清。<code>continue</code> 语句并不是退出整个循环，而是结束当前的循环迭代，并立即开始下一次的迭代。如果是在 <code>for</code> 循环中使用 <code>continue</code>，则会跳到循环的下一个元素；如果是在 <code>while</code> 循环中，会重新评估循环条件。</p>    </div>  </div>]]></content>
    
    
    <summary type="html">Python 基础逻辑语法</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="控制流程" scheme="https://www.yiuhangblog.com/tags/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    
    <category term="条件判断" scheme="https://www.yiuhangblog.com/tags/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"/>
    
    <category term="循环语句" scheme="https://www.yiuhangblog.com/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    
    <category term="嵌套" scheme="https://www.yiuhangblog.com/tags/%E5%B5%8C%E5%A5%97/"/>
    
    <category term="三目运算" scheme="https://www.yiuhangblog.com/tags/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>语法基础和数据类型</title>
    <link href="https://www.yiuhangblog.com/2018/07/23/20180723%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.yiuhangblog.com/2018/07/23/20180723%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/</id>
    <published>2018-07-23T07:34:56.000Z</published>
    <updated>2024-02-28T10:48:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在 Python 编程语言中，理解标识符和变量的概念对于编写高效、易读的代码至关重要。以下是关于标识符和变量的详细解析，旨在为初学者提供清晰的指南。</p><h3 id="标识符的基本规则"><a href="#标识符的基本规则" class="headerlink" title="标识符的基本规则"></a>标识符的基本规则</h3><ul><li><strong>组成</strong>：标识符可以由字母、数字以及下划线（_）组成。</li><li><strong>开头</strong>：标识符的第一个字符不能是数字，可以是字母或下划线。</li><li><strong>区分大小写</strong>：在 Python 中，标识符是区分大小写的。例如，<code>ABC</code> 和 <code>abc</code> 被视为两个不同的标识符。</li><li><strong>作用</strong>：标识符用作变量名、函数名、方法名等，是对程序中某些实体的命名。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的概念"><a href="#变量的概念" class="headerlink" title="变量的概念"></a>变量的概念</h3><ul><li><strong>定义</strong>：变量是程序中用于存储数据的标识符。Python 通过变量名访问这块存储单元。</li><li><strong>命名规则</strong>：变量名遵循标识符的命名规则，但不能使用 Python 的保留字（关键字）作为变量名。</li><li><strong>关键字查询</strong>：Python 的标准库提供了一个 <code>keyword</code> 模块，可以用来查看当前 Python 版本的所有关键字。</li></ul><h3 id="变量使用注意事项"><a href="#变量使用注意事项" class="headerlink" title="变量使用注意事项"></a>变量使用注意事项</h3><ol><li><strong>类型声明</strong>：Python 是动态类型语言，变量不需要事先声明类型。</li><li><strong>赋值前必须初始化</strong>：变量在使用前必须被赋值，变量的赋值操作同时也是变量声明的过程。</li><li><strong>值可变性</strong>：变量的值可以随时修改，Python 中的变量更像是数据的引用而非数据存储的实体。</li><li><strong>数据类型</strong>：变量的数据类型是根据赋值的数据类型自动确定的。</li><li><strong>赋值运算符</strong>：Python 使用 <code>=</code> 作为赋值运算符，赋值的顺序是从右向左。</li><li><strong>多变量赋值</strong>：Python 支持同时为多个变量赋值，例如 <code>a, b, c = 1, 2, &quot;python&quot;</code>。</li></ol><h3 id="实用示例"><a href="#实用示例" class="headerlink" title="实用示例"></a>实用示例</h3><ul><li><strong>查看所有关键字</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></table></figure></div><ul><li><strong>变量赋值与使用</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个变量赋值</span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多变量同时赋值</span></span><br><span class="line">a, b, c = <span class="number">5</span>, <span class="number">3.2</span>, <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交换两个变量的值</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure></div><ul><li><strong>避免与关键字冲突的命名</strong>：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误的命名，因为 if 是一个关键字</span></span><br><span class="line"><span class="keyword">if</span> = <span class="number">10</span>  <span class="comment"># 这将引发语法错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的命名</span></span><br><span class="line">if_condition = <span class="number">10</span></span><br></pre></td></tr></table></figure></div><p>在 Python 中，理解基础数据类型、输入输出操作以及代码的基本结构对于编写有效且易于理解的程序至关重要。以下是关于 Python 数据类型转换、输入输出操作、注释、缩进和导入模块等方面的专业整理。</p><h2 id="Python-数据类型转换"><a href="#Python-数据类型转换" class="headerlink" title="Python 数据类型转换"></a>Python 数据类型转换</h2><p>Python 支持多种数据类型的转换，使用以下内置函数：</p><ul><li><strong><code>int()</code></strong>: 将数据转换为整型 (<code>int</code>)，适用于字符串、浮点数等。</li><li><strong><code>str()</code></strong>: 将数据转换为字符串 (<code>str</code>) 类型，适用于数字等。</li><li><strong><code>float()</code></strong>: 将数据转换为浮点数 (<code>float</code>) 类型，适用于字符串、整数等。</li><li><strong><code>complex(x)</code></strong>: 将 <code>x</code> 转换为复数，实数部分为 <code>x</code>，虚数部分为 <code>0</code>。</li><li><strong><code>complex(x, y)</code></strong>: 将 <code>x</code> 和 <code>y</code> 转换为复数，实数部分为 <code>x</code>，虚数部分为 <code>y</code>。</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li><p>使用 <code>input(prompt)</code> 函数读取用户的键盘输入，返回值为字符串类型。</p></li><li><p>示例：创建一个简单的加法程序。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入一个数字: &quot;</span>)</span><br><span class="line">num2 = <span class="built_in">input</span>(<span class="string">&quot;请再输入一个数字: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(num1) + <span class="built_in">int</span>(num2))</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li><strong><code>print</code> 函数</strong>：用于在屏幕上显示文本、变量或其他类型的数据。</li><li>支持直接打印文本（中文需要加引号）、数学表达式、变量等。</li><li><strong>空格与连接</strong>：使用 <code>,</code> 会自动在变量间添加空格，使用 <code>+</code> 连接时不添加空格。</li><li><strong>英文大小写转换</strong>：<code>title()</code> 将字符串首字母大写，<code>upper()</code> 转换为全大写，<code>lower()</code> 转换为全小写。</li><li><strong>不换行输出</strong>：使用 <code>end</code> 参数指定结尾字符，默认为换行符 <code>\n</code>。</li><li><strong>指定分隔符</strong>：使用 <code>sep</code> 参数定义输出间的分隔符，默认为空格。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><strong>单行注释</strong>：以 <code>#</code> 开头。</li><li><strong>多行注释</strong>：使用三个单引号 <code>&#39;&#39;&#39;</code> 或三个双引号 <code>&quot;&quot;&quot;</code> 包裹。</li></ul><h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><ul><li>Python 使用缩进来定义代码块，而非大括号 <code>&#123;&#125;</code>。</li><li>同一代码块的语句必须具有相同的缩进空格数。</li><li>不一致的缩进会导致 <code>IndentationError</code>。</li></ul><h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><ul><li>多行语句可以使用反斜杠 <code>\</code> 实现。</li><li>在 <code>[]</code>、<code>&#123;&#125;</code>、<code>()</code> 中的语句不需要使用反斜杠。</li></ul><h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><ul><li>Python 允许在同一行中使用多条语句，语句之间使用分号 <code>;</code> 分割。</li></ul><h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><ul><li><strong>导入模块</strong>：使用 <code>import modulename</code> 或 <code>from modulename import functionname</code>。</li><li><strong>安装模块</strong>：如果需要安装外部模块，可以使用 <code>pip install modulename</code> 命令。</li></ul><p>Python 作为一门强大的编程语言，提供了丰富的数字运算能力，涵盖了从基本的算术运算到复杂的数学计算。本文档旨在全面概述 Python 中的数字运算，包括算术运算、位运算、比较运算，以及使用数学模块进行高级数学运算的方法。</p><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>Python 支持的基本算术运算符包括：</p><ul><li><strong>加法</strong> (<code>+</code>)</li><li><strong>减法</strong> (<code>-</code>)</li><li><strong>乘法</strong> (<code>*</code>)</li><li><strong>除法</strong> (<code>/</code>)</li><li><strong>整数除法</strong> (<code>//</code>)：返回除法运算结果的整数部分。</li><li><strong>取余</strong> (<code>%</code>)</li><li><strong>指数</strong> (<code>**</code>)：进行幂运算。</li></ul><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> + <span class="number">2</span>)  <span class="comment"># 加法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span> - <span class="number">5</span> * <span class="number">6</span>)  <span class="comment"># 减法</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">50</span> - <span class="number">5</span> * <span class="number">6</span>) / <span class="number">4</span>)  <span class="comment"># 除法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">8</span> / <span class="number">5</span>)  <span class="comment"># 除法总是返回一个浮点数</span></span><br></pre></td></tr></table></figure></div><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算符对整数在内存中的二进制位进行操作：</p><ul><li><strong>按位与</strong> (<code>&amp;</code>)</li><li><strong>按位或</strong> (<code>|</code>)</li><li><strong>按位异或</strong> (<code>^</code>)</li><li><strong>按位取反</strong> (<code>~</code>)</li><li><strong>左移</strong> (<code>&lt;&lt;</code>)</li><li><strong>右移</strong> (<code>&gt;&gt;</code>)</li></ul><h2 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h2><p>Python 中的比较运算符包括：</p><ul><li><strong>等于</strong> (<code>==</code>)</li><li><strong>不等于</strong> (<code>!=</code>)</li><li><strong>大于</strong> (<code>&gt;</code>)</li><li><strong>小于</strong> (<code>&lt;</code>)</li><li><strong>大于等于</strong> (<code>&gt;=</code>)</li><li><strong>小于等于</strong> (<code>&lt;=</code>)</li></ul><h2 id="数学模块-math"><a href="#数学模块-math" class="headerlink" title="数学模块 (math)"></a>数学模块 (<code>math</code>)</h2><p>Python 的标准库中的 <code>math</code> 模块提供了许多常见的数学函数和常量。</p><ul><li><strong>常量</strong>：如 <code>math.pi</code> (圆周率) 和 <code>math.e</code> (自然对数的底数)。</li><li><strong>函数</strong>：如 <code>math.sqrt(x)</code> (平方根)、<code>math.floor(x)</code> (向下取整)、<code>math.ceil(x)</code> (向上取整)、<code>math.exp(x)</code> (指数函数)、<code>math.log10(x)</code> (对数函数) 等。</li></ul><p>示例代码：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;圆周率：&quot;</span>, math.pi)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;自然对数的底数：&quot;</span>, math.e)</span><br><span class="line"></span><br><span class="line">x = <span class="number">2.5</span></span><br><span class="line">y = <span class="number">3.7</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x, <span class="string">&quot;的平方根：&quot;</span>, math.sqrt(x))</span><br><span class="line"><span class="built_in">print</span>(y, <span class="string">&quot;的向下取整值：&quot;</span>, math.floor(y))</span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <ul><li>浮点运算的结果可能会因机器而异，这是由于计算机内部对浮点数的表示和四舍五入误差有关。</li><li>整数和浮点数混合运算时，整数将被转换为浮点数。</li></ul>    </div>  </div><h2 id="给变量赋值"><a href="#给变量赋值" class="headerlink" title="给变量赋值"></a>给变量赋值</h2><ul><li>使用等号 (<code>=</code>) 对变量进行赋值。Python 中的变量不需要声明类型，解释器会根据赋值自动确定类型。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h3><p>以下假设变量： <strong>a&#x3D;10，b&#x3D;20</strong>：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除 - x除以y</td><td align="left">b &#x2F; a 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td align="left">&#x2F;&#x2F;</td><td align="left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table><h3 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a &#x3D;&#x3D; b) 返回 False。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a !&#x3D; b) 返回 True。</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于 - 比较两个对象是否不相等。<strong>python3 已废弃。</strong></td><td align="left">(a &lt;&gt; b) 返回 True。这个运算符类似 !&#x3D; 。</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量 True 和 False 等价。</td><td align="left">(a &lt; b) 返回 True。</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;&#x3D; b) 返回 False。</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;&#x3D; b) 返回 True。</td></tr></tbody></table><h3 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">简单的赋值运算符</td><td align="left">c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+&#x3D;</td><td align="left">加法赋值运算符</td><td align="left">c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td align="left">-&#x3D;</td><td align="left">减法赋值运算符</td><td align="left">c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td align="left">*&#x3D;</td><td align="left">乘法赋值运算符</td><td align="left">c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">除法赋值运算符</td><td align="left">c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td align="left">%&#x3D;</td><td align="left">取模赋值运算符</td><td align="left">c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td align="left">**&#x3D;</td><td align="left">幂赋值运算符</td><td align="left">c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td align="left">&#x2F;&#x2F;&#x3D;</td><td align="left">取整除赋值运算符</td><td align="left">c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr></tbody></table><h3 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h3><p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p><p>下表中变量 a 为 60，b 为 13，二进制格式如下：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = 0011 1100</span><br><span class="line"></span><br><span class="line">b = 0000 1101</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">a&amp;b = 0000 1100</span><br><span class="line"></span><br><span class="line">a|b = 0011 1101</span><br><span class="line"></span><br><span class="line">a^b = 0011 0001</span><br><span class="line"></span><br><span class="line">~a  = 1100 0011</span><br></pre></td></tr></table></figure></div><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td align="left">~</td><td align="left">按位取反运算符：将二进制表示中的每一位取反，0 变为 1，1 变为 0。**~x** 类似于 <strong>-x-1</strong></td><td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011 (以补码形式表示)，在一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移动运算符：运算数的各二进位全部左移若干位，由 <strong>&lt;&lt;</strong> 右边的数字指定了移动的位数，高位丢弃，低位补0。</td><td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，**&gt;&gt;** 右边的数字指定了移动的位数</td><td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table><h3 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h3 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h3><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) !&#x3D; id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p><a class="link"   href="https://www.runoob.com/python/python-func-id.html" >id() <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 函数用于获取对象内存地址。</p>    </div>  </div><h3 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">指数 (最高优先级)</td></tr><tr><td align="left">~ + -</td><td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td align="left">* &#x2F; % &#x2F;&#x2F;</td><td align="left">乘，除，取模和取整除</td></tr><tr><td align="left">+ -</td><td align="left">加法减法</td></tr><tr><td align="left">&gt;&gt; &lt;&lt;</td><td align="left">右移，左移运算符</td></tr><tr><td align="left">&amp;</td><td align="left">位 ‘AND’</td></tr><tr><td align="left">^ |</td><td align="left">位运算符</td></tr><tr><td align="left">&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td align="left">比较运算符</td></tr><tr><td align="left">&lt;&gt; &#x3D;&#x3D; !&#x3D;</td><td align="left">等于运算符</td></tr><tr><td align="left">&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td align="left">赋值运算符</td></tr><tr><td align="left">is is not</td><td align="left">身份运算符</td></tr><tr><td align="left">in not in</td><td align="left">成员运算符</td></tr><tr><td align="left">not and or</td><td align="left">逻辑运算符</td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Python数据类型分为 三大类：</p><ul><li>数值类型</li><li>序列类型</li><li>散列（映射）类型</li></ul><h3 id="一-数值类型"><a href="#一-数值类型" class="headerlink" title="一   数值类型"></a>一   数值类型</h3><p>这些类型都是不可变的。</p><h4 id="1-整数类型-int"><a href="#1-整数类型-int" class="headerlink" title="1. 整数类型 int"></a>1. 整数类型 int</h4><p>什么是整数？</p><ul><li>由0-9组成的数都叫整数</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">a = <span class="number">0</span></span><br></pre></td></tr></table></figure></div><h4 id="2-浮点数类型-float"><a href="#2-浮点数类型-float" class="headerlink" title="2. 浮点数类型 float"></a>2. 浮点数类型 float</h4><p>什么是浮点数？</p><ul><li>有小数点的数叫浮点数 也就是我们数学中说的小数</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10.1</span></span><br><span class="line"><span class="comment"># 10.0</span></span><br><span class="line"><span class="comment"># 10.25</span></span><br><span class="line">a = <span class="number">10.1</span></span><br></pre></td></tr></table></figure></div><h4 id="3-布尔类型-bool"><a href="#3-布尔类型-bool" class="headerlink" title="3. 布尔类型 bool"></a>3. 布尔类型 bool</h4><p>什么是布尔类型？</p><ul><li><p>布尔类型代表真假</p></li><li><p>只有两个值</p></li><li><p>布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。</p></li><li><p>布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。</p></li><li><p>布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。</p></li><li><p>在Python中，布尔类型实际上是整型（int）的子类，因此布尔值在某些情况下可以与数字进行操作，并被视为数字 <code>1</code>（True）和 <code>0</code>（False）。与其他数值类型一样，布尔类型也是不可变的，它有两个值：<code>True</code> 和 <code>False</code></p><ul><li><p>True 真</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line">a = <span class="literal">True</span><span class="comment"># 1</span></span><br></pre></td></tr></table></figure></div></li><li><p>False 假</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line">a = <span class="literal">False</span><span class="comment"># 0</span></span><br></pre></td></tr></table></figure></div></li></ul></li></ul>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <p>在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 <strong>0、空字符串、空列表、空元组</strong>等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。</p>    </div>  </div><h4 id="4-复数-complex"><a href="#4-复数-complex" class="headerlink" title="4. 复数 complex"></a>4. 复数 complex</h4><p>复数在Python中也是一种数值类型，用于表示具有实部和虚部的数。在数学中，复数通常写作 <code>a + bj</code>，其中 <code>a</code> 是实部，<code>b</code> 是虚部，而 <code>j</code>（在Python中用 <code>j</code> 或 <code>J</code> 表示）是虚数单位。</p><ul><li><strong>实部</strong>（Real Part）：这是复数中的常规数字部分，没有乘以虚数单位。</li><li><strong>虚部</strong>（Imaginary Part）：这部分乘以虚数单位 <code>j</code>。在数学上，<code>j</code> 是一个特殊的值，其平方等于 <code>-1</code>。</li></ul><p>在Python中，可以使用 <code>complex(real, imag)</code> 函数或直接用 <code>real + imagj</code> 表式来创建复数。例如</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 complex 函数</span></span><br><span class="line">c1 = <span class="built_in">complex</span>(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 创建复数 2 + 3j</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接定义</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3j</span>  <span class="comment"># 同样创建复数 2 + 3j</span></span><br></pre></td></tr></table></figure></div><h4 id="5-算术运算符"><a href="#5-算术运算符" class="headerlink" title="5. 算术运算符"></a>5. 算术运算符</h4><ol><li>加法运算符（+）：用于对两个数值或字符串进行相加操作。</li><li>减法运算符（-）：用于对两个数值进行相减操作。</li><li>乘法运算符（*）：用于对两个数值进行相乘操作。</li><li>除法运算符（&#x2F;）：用于对两个数值进行相除操作。</li></ol><h3 id="二-序列类型"><a href="#二-序列类型" class="headerlink" title="二   序列类型"></a>二   序列类型</h3><p>非常常见的一种数据类型，它表示一组按照一定顺序排列的值的集合</p><h4 id="序列类型的基本介绍"><a href="#序列类型的基本介绍" class="headerlink" title="序列类型的基本介绍"></a>序列类型的基本介绍</h4><h5 id="1-字符串-str"><a href="#1-字符串-str" class="headerlink" title="1. 字符串 str"></a>1. 字符串 str</h5><p>写在单引号、双引号的内容 被称为字符串类型。 可以随便写任何内容、小数、特殊符号、文字 不能修改里面的数据</p><ul><li><p>特点：可以存任意内容，不能修改</p></li><li><p>写法：</p><ul><li><p>单引号</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;我是字符串 随便写什么内容 @！123123&#x27;</span></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">a = <span class="string">&#x27;我是字符串 随便写什么内容 @！123123&#x27;</span></span><br></pre></td></tr></table></figure></div></li><li><p>双引号</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;我是字符串 随便写什么内容 @！123123&quot;</span></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">a = <span class="string">&quot;我是字符串 随便写什么内容 @！123123&quot;</span></span><br></pre></td></tr></table></figure></div></li><li><p>有没有区别？</p><ul><li>没有区别</li></ul></li></ul></li><li><p>反斜杠可以用来转义，使用 <strong>r</strong> 可以让反斜杠不发生转义。 如 <strong>r”this is a line with \n”</strong> 则 <strong>\n</strong> 会显示，并不是换行。</p></li><li><p>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong>。</p></li><li><p>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复。</p></li><li><p>Python 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</p></li><li><p>Python 中的字符串不能改变。</p></li><li><p>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p></li><li><p>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></p></li><li><p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/da316da0-0b8e-4165-fd0e-78af1513b100/public"                      width = "400"                ></li></ul><h6 id="Python字符串运算符"><a href="#Python字符串运算符" class="headerlink" title="Python字符串运算符"></a>Python字符串运算符</h6><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">字符串连接</td><td align="left">&gt;&gt;&gt;a + b ‘HelloPython’</td></tr><tr><td align="left">*</td><td align="left">重复输出字符串</td><td align="left">&gt;&gt;&gt;a * 2 ‘HelloHello’</td></tr><tr><td align="left">[]</td><td align="left">通过索引获取字符串中字符</td><td align="left">&gt;&gt;&gt;a[1] ‘e’</td></tr><tr><td align="left">[ : ]</td><td align="left">截取字符串中的一部分</td><td align="left">&gt;&gt;&gt;a[1:4] ‘ell’</td></tr><tr><td align="left">in</td><td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td><td align="left">&gt;&gt;&gt;”H” in a True</td></tr><tr><td align="left">not in</td><td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td align="left">&gt;&gt;&gt;”M” not in a True</td></tr><tr><td align="left">r&#x2F;R</td><td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td align="left">&gt;&gt;&gt;print r’\n’ \n &gt;&gt;&gt; print R’\n’ \n</td></tr></tbody></table><h5 id="2-列表-list"><a href="#2-列表-list" class="headerlink" title="2. 列表 list"></a>2. 列表 list</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/56391fbd-a569-49f9-dc1e-cbf4b06c3300/public"                      width = "600"                ><p>可以存储多个值，每个数据用<strong>逗号分隔</strong>可以修改存储的数据，<strong>数据是可以修改的</strong></p><ul><li>特点：存多个值、可修改</li><li>写法：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="string">&#x27;武松&#x27;</span>, <span class="number">12.3</span>, <span class="literal">True</span>]</span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="string">&#x27;武松&#x27;</span>, <span class="number">12.3</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure></div><h6 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h6><p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</p><p>如下所示：</p><table><thead><tr><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">len([1, 2, 3])</td><td align="left">3</td><td align="left">长度</td></tr><tr><td align="left">[1, 2, 3] + [4, 5, 6]</td><td align="left">[1, 2, 3, 4, 5, 6]</td><td align="left">组合</td></tr><tr><td align="left">[‘Hi!’] * 4</td><td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td align="left">重复</td></tr><tr><td align="left">3 in [1, 2, 3]</td><td align="left">True</td><td align="left">元素是否存在于列表中</td></tr><tr><td align="left">for x in [1, 2, 3]: print x,</td><td align="left">1 2 3</td><td align="left">迭代</td></tr></tbody></table><h6 id="Python列表截取"><a href="#Python列表截取" class="headerlink" title="Python列表截取"></a>Python列表截取</h6><p>描述：</p><table><thead><tr><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">L[2]</td><td align="left">‘Taobao’</td><td align="left">读取列表中第三个元素</td></tr><tr><td align="left">L[-2]</td><td align="left">‘Runoob’</td><td align="left">读取列表中倒数第二个元素</td></tr><tr><td align="left">L[1:]</td><td align="left">[‘Runoob’, ‘Taobao’]</td><td align="left">从第二个元素开始截取列表</td></tr></tbody></table><h5 id="3-元组-tuple"><a href="#3-元组-tuple" class="headerlink" title="3. 元组 tuple"></a>3. 元组 tuple</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/f1b6af52-b5eb-46c0-33a4-d6ba3d168a00/public"                      width = "600"                ><p>可以存储多个值，每个数据用<strong>逗号分隔</strong>，<strong>不可以修改里面的数据</strong></p><ul><li>特点：存多个值、不可以修改</li><li>写法：</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&#x27;武松&#x27;</span>, <span class="number">12.3</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">a = (<span class="number">1</span>, <span class="string">&#x27;武松&#x27;</span>, <span class="number">12.3</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h6 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h6><p>与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p><table><thead><tr><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">len((1, 2, 3))</td><td align="left">3</td><td align="left">计算元素个数</td></tr><tr><td align="left">(1, 2, 3) + (4, 5, 6)</td><td align="left">(1, 2, 3, 4, 5, 6)</td><td align="left">连接</td></tr><tr><td align="left">(‘Hi!’,) * 4</td><td align="left">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td align="left">复制</td></tr><tr><td align="left">3 in (1, 2, 3)</td><td align="left">True</td><td align="left">元素是否存在</td></tr><tr><td align="left">for x in (1, 2, 3): print x,</td><td align="left">1 2 3</td><td align="left">迭代</td></tr></tbody></table><hr><h6 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h6><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：</p><p>元组：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = (<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;Spam&#x27;</span>, <span class="string">&#x27;SPAM!&#x27;</span>)</span><br></pre></td></tr></table></figure></div><table><thead><tr><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">L[2]</td><td align="left">‘SPAM!’</td><td align="left">读取第三个元素</td></tr><tr><td align="left">L[-2]</td><td align="left">‘Spam’</td><td align="left">反向读取，读取倒数第二个元素</td></tr><tr><td align="left">L[1:]</td><td align="left">(‘Spam’, ‘SPAM!’)</td><td align="left">截取元素</td></tr></tbody></table><h4 id="序列类型的方法"><a href="#序列类型的方法" class="headerlink" title="序列类型的方法"></a>序列类型的方法</h4><h5 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">取序列类型的一个元素</span><br><span class="line">从左往右取值 从0开始：</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以变量a为例子</span></span><br><span class="line">a = <span class="string">&#x27;我真的很帅&#x27;</span></span><br></pre></td></tr></table></figure></div><table><thead><tr><th>字符</th><th>我</th><th>真</th><th>的</th><th>很</th><th>帅</th></tr></thead><tbody><tr><td>索引</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] <span class="comment"># 我</span></span><br><span class="line">a[<span class="number">1</span>] <span class="comment"># 真</span></span><br><span class="line">a[<span class="number">2</span>] <span class="comment"># 的</span></span><br><span class="line">a[<span class="number">3</span>] <span class="comment"># 很</span></span><br><span class="line">a[<span class="number">4</span>] <span class="comment"># 帅</span></span><br></pre></td></tr></table></figure></div><p>从右往左取值 从-1开始</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以变量a为例子</span></span><br><span class="line">a = <span class="string">&#x27;我真的很帅&#x27;</span></span><br></pre></td></tr></table></figure></div><table><thead><tr><th>字符</th><th>我</th><th>真</th><th>的</th><th>很</th><th>帅</th></tr></thead><tbody><tr><td>索引</td><td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td></tr></tbody></table><h5 id="2-切片"><a href="#2-切片" class="headerlink" title="2. 切片"></a>2. 切片</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">取序列类型的多个元素</span><br><span class="line">如何使用？</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[形参<span class="number">1</span>:形参<span class="number">2</span>:形参<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 形参1 是从索引几开始</span></span><br><span class="line"><span class="comment"># 形参2 是到索引几结束 但是不包含当前索引</span></span><br><span class="line"><span class="comment"># 形参3 是步长 根据索引每次走几步</span></span><br><span class="line">a = <span class="string">&#x27;我真的很帅&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:<span class="number">3</span>:<span class="number">1</span>]) <span class="comment"># 我真的</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:<span class="number">3</span>:<span class="number">2</span>])<span class="comment"># 我的</span></span><br></pre></td></tr></table></figure></div><h5 id="3-类型切换"><a href="#3-类型切换" class="headerlink" title="3. 类型切换"></a>3. 类型切换</h5><h6 id="列表转字符串"><a href="#列表转字符串" class="headerlink" title="列表转字符串"></a>列表转字符串</h6><p>假设有一个列表 <code>my_list</code>，可以使用 <code>join()</code> 函数将其元素连接成一个字符串。<code>join()</code> 函数需要一个字符串作为分隔符，用来连接列表中的元素。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>]</span><br><span class="line">my_string = <span class="string">&#x27;, &#x27;</span>.join(my_list)</span><br><span class="line"><span class="built_in">print</span>(my_string)  <span class="comment"># 输出: apple, banana, cherry</span></span><br></pre></td></tr></table></figure></div><p>使用字符串连接</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result_str = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">    result_str += <span class="built_in">str</span>(item)  <span class="comment"># 转换每个元素为字符串并连接</span></span><br></pre></td></tr></table></figure></div><p>使用列表推导和字符串连接</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result_str = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> lst])</span><br></pre></td></tr></table></figure></div><p>使用 <code>join</code> 和映射（map）</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result_str = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, lst))</span><br></pre></td></tr></table></figure></div><h6 id="元组转字符串"><a href="#元组转字符串" class="headerlink" title="元组转字符串"></a>元组转字符串</h6><p>对于元组，方法与列表类似。假设有一个元组 <code>my_tuple</code>，同样可以使用 <code>join()</code> 函数。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>)</span><br><span class="line">my_string = <span class="string">&#x27;, &#x27;</span>.join(my_tuple)</span><br><span class="line"><span class="built_in">print</span>(my_string)  <span class="comment"># 输出: apple, banana, cherry</span></span><br></pre></td></tr></table></figure></div><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li>如果列表或元组中包含非字符串类型（如整数或浮点数），则需要先将它们转换为字符串，然后才能使用 <code>join()</code> 函数。例如，对于一个整数列表 <code>my_list = [1, 2, 3]</code>，可以使用列表推导式 <code>[str(x) for x in my_list]</code> 将其转换为字符串列表，然后再使用 <code>join()</code>。</li><li><code>join()</code> 函数中的分隔符可以是任何字符串，包括空字符串。</li><li><code>str(my_list)</code>：提供列表的完整文本表示，包括方括号和元素引号。</li><li><code>str(my_tuple)</code>：提供元组的完整文本表示，包括圆括号和元素引号。</li><li><code>join()</code>：用于将列表或元组中的字符串元素连接成一个单一的、格式化的字符串，不包括列表的结构标记，如方括号。需要列表元素都是字符串类型。</li></ul><h6 id="字符串转列表"><a href="#字符串转列表" class="headerlink" title="字符串转列表"></a>字符串转列表</h6><p>使用 <code>split()</code> 方法可以将字符串分割成列表。需要指定一个分隔符，它将字符串在每个分隔符处分割。</p><p>例如，有一个以逗号分隔的字符串，可以这样将其转换为列表：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_string = <span class="string">&quot;apple, banana, cherry&quot;</span></span><br><span class="line">my_list = my_string.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span></span><br></pre></td></tr></table></figure></div><p>如果字符串没有明显的分隔符，<code>split()</code> 方法将默认以空格作为分隔符。</p><h6 id="字符串转元组"><a href="#字符串转元组" class="headerlink" title="字符串转元组"></a>字符串转元组</h6><p>将字符串转换为元组的过程与转换为列表类似，只是在分割字符串之后，需要将得到的列表转换为元组。这可以通过将列表作为参数传递给 <code>tuple()</code> 函数来实现。</p><p>例如：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_string = <span class="string">&quot;apple, banana, cherry&quot;</span></span><br><span class="line">my_list = my_string.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">my_tuple = <span class="built_in">tuple</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(my_tuple)  <span class="comment"># 输出: (&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;)</span></span><br></pre></td></tr></table></figure></div><h6 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li>如果字符串中包含特殊字符或格式复杂，可能需要使用更复杂的方法（如正则表达式）来正确分割字符串。</li><li>分隔符应根据字符串的实际内容选择。如果选择错误的分隔符，结果可能不会按预期分割。</li></ul>  <div class="note-large blue">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-info"></i><p>信息</p>    </div>    <div class="notel-content">      <p><code>.join()</code> 是 Python 中的一个字符串方法，用于将序列中的元素连接成一个新的字符串。这个方法是非常有用的，尤其是在需要将多个字符串元素组合成一个单一字符串的情况下。下面详细介绍这个方法的工作原理和使用方式。</p><p><strong>工作原理</strong></p><ul><li><code>.join()</code> 方法被调用的对象必须是一个字符串，这个字符串会成为元素之间的连接符。</li><li>它接受一个参数，这个参数是一个包含字符串元素的序列（如列表、元组、集合或任何可迭代对象）。</li><li>方法将序列中的每个元素合并成一个字符串，元素之间插入调用 <code>.join()</code> 的字符串。</li></ul><p><strong>基本用法</strong></p><p>假设有一个列表 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>，你想将其连接成一个字符串，每个元素之间用逗号分隔：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elements = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">result = <span class="string">&#x27;,&#x27;</span>.join(elements)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: a,b,c</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>.join()</code> 被逗号字符串 <code>&#39;,&#39;</code> 调用，因此它会在列表 <code>elements</code> 中的每个元素之间插入逗号。</p><p><strong>注意事项</strong></p><ul><li>序列中的元素必须是字符串。如果序列中包含任何非字符串类型（如整数或浮点数），则会引发 <code>TypeError</code>。在这种情况下，你需要先将元素转换为字符串，通常可以通过列表推导和 <code>str()</code> 函数实现。</li><li>如果序列为空，<code>.join()</code> 返回一个空字符串。</li></ul><p><strong>示例</strong></p><p>将数字列表转换为逗号分隔的字符串：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 将数字转换为字符串</span></span><br><span class="line">string_numbers = [<span class="built_in">str</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> numbers]</span><br><span class="line">result = <span class="string">&#x27;,&#x27;</span>.join(string_numbers)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></div><p>在这个例子中，我们首先使用列表推导将数字列表 <code>numbers</code> 转换为字符串列表 <code>string_numbers</code>。然后使用 <code>.join()</code> 方法来连接这些字符串。</p><p><strong>使用场景</strong></p><ul><li>连接日志文件的多行。</li><li>生成或解析CSV文件。</li><li>创建查询字符串或URL。</li></ul><p><code>.join()</code> 是一个非常实用的方法，尤其在处理字符串和文本处理时非常有用。它的效率通常比传统的字符串连接（使用 <code>+</code> 操作符）要高，尤其是在处理大量字符串时。</p>    </div>  </div><h3 id="三-序列类型方法"><a href="#三-序列类型方法" class="headerlink" title="三   序列类型方法"></a>三   序列类型方法</h3><h4 id="什么是方法？"><a href="#什么是方法？" class="headerlink" title="什么是方法？"></a>什么是方法？</h4><p>方法是对象的属性，是一种可以对对象进行操作的</p><p><strong>函数</strong></p><h4 id="为什么使用方法？"><a href="#为什么使用方法？" class="headerlink" title="为什么使用方法？"></a><strong>为什么使用方法？</strong></h4><p>使用方法可以让代码更加模块化和可复用。通过把一些操作封装在方法中，我们可以更方便地对数据进行处理，也可以避免代码的重复和冗余。同时，方法的使用也可以使代码更易读、易懂和易维护。</p><h4 id="列表、元组、字符串方法？"><a href="#列表、元组、字符串方法？" class="headerlink" title="列表、元组、字符串方法？"></a><strong>列表、元组、字符串方法？</strong></h4><p>用来对里面的数据进行增删改查</p><p>1.我们可以把</p><p><strong>列表</strong>、<strong>字符串</strong>和<strong>元组</strong>、分别理解为<strong>三个英雄</strong></p><p>2.它们都有</p><p><strong>对应的方法</strong>、方法也就是<strong>英雄的技能</strong>、</p><p>3.使用</p><p><strong>英雄的技能</strong>可以快速杀敌</p><p>4.使用方法能快速的进行数据的</p><p><strong>增删改查</strong></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/cc013f89-9e13-4b63-ba07-f238615b4200/public"                                     ><h5 id="1-增加示例"><a href="#1-增加示例" class="headerlink" title="1. 增加示例"></a>1. 增加示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;列&#x27;</span>, <span class="string">&#x27;表&#x27;</span>]<span class="comment"># 创建一个变量名a，这是一个列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置方法：</span></span><br><span class="line"><span class="comment"># 增加</span></span><br><span class="line"><span class="comment"># 1. append 方法 在列表末尾添加一个元素</span></span><br><span class="line"><span class="comment"># 添加 &#x27;这是添加物&#x27;</span></span><br><span class="line">a.append(<span class="string">&#x27;这是添加物&#x27;</span>) <span class="comment"># 通过append 这个方法 向 变量a 增加了 这是添加物</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;, &#x27;这是添加物&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. insert 方法 在列表指定位置插入元素</span></span><br><span class="line"><span class="comment"># 插入&#x27;这是插入物&#x27;</span></span><br><span class="line">a.insert(<span class="number">1</span>, <span class="string">&#x27;这是插入物&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># [&#x27;这&#x27;, &#x27;这是插入物&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;, &#x27;这是添加物&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. extend 方法 在列表末尾添加另一个列表的所有元素</span></span><br><span class="line"><span class="comment"># 添加列表</span></span><br><span class="line">b = [<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;另&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;列&#x27;</span>, <span class="string">&#x27;表&#x27;</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#[&#x27;这&#x27;, &#x27;这是插入物&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;, &#x27;这是添加物&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;另&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]</span></span><br></pre></td></tr></table></figure></div><h5 id="2-删除示例"><a href="#2-删除示例" class="headerlink" title="2. 删除示例"></a>2. 删除示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;列&#x27;</span>, <span class="string">&#x27;表&#x27;</span>]<span class="comment"># 创建一个变量名a，这是一个列表</span></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="comment"># 4. pop 方法 通过索引移除列表中的一个元素（默认最后一个），并返回该元素的值</span></span><br><span class="line">a.pop(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. remove 方法 通过元素移除列表中的一个元素</span></span><br><span class="line">a.remove(<span class="string">&#x27;一&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#[&#x27;这&#x27;, &#x27;是&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. clear 方法 移除列表的所有元素</span></span><br><span class="line">a.clear()</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#[]</span></span><br></pre></td></tr></table></figure></div><h5 id="3-修改示例"><a href="#3-修改示例" class="headerlink" title="3. 修改示例"></a>3. 修改示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;列&#x27;</span>, <span class="string">&#x27;表&#x27;</span>]<span class="comment"># 创建一个变量名a，这是一个列表</span></span><br><span class="line"><span class="comment"># 7. 直接在对于索引修改用 &#x27;=&#x27;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;不&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#[&#x27;不&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]</span></span><br></pre></td></tr></table></figure></div><h5 id="4-查询示例"><a href="#4-查询示例" class="headerlink" title="4. 查询示例"></a>4. 查询示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;列&#x27;</span>, <span class="string">&#x27;表&#x27;</span>]<span class="comment"># 创建一个变量名a，这是一个列表</span></span><br><span class="line"><span class="comment"># 8. index 方法 返回指定元素在列表第一次出现的索引位置</span></span><br><span class="line">result = a.index(<span class="string">&#x27;一&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. count 方法 返回指定元素在列表出现的次数</span></span><br><span class="line">result = a.count(<span class="string">&#x27;列&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></div><h5 id="5-其它示例"><a href="#5-其它示例" class="headerlink" title="5. 其它示例"></a>5. 其它示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;列&#x27;</span>, <span class="string">&#x27;表&#x27;</span>]<span class="comment"># 创建一个变量名a，这是一个列表</span></span><br><span class="line"><span class="comment"># 10. copy 方法 复制一份变量的内容</span></span><br><span class="line">result = a.copy()</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;列&#x27;, &#x27;表&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 11. reverse 方法 反转列表的元素</span></span><br><span class="line">a.reverse()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># [&#x27;表&#x27;, &#x27;列&#x27;, &#x27;个&#x27;, &#x27;一&#x27;, &#x27;是&#x27;, &#x27;这&#x27;]</span></span><br><span class="line"></span><br><span class="line">b = [<span class="number">89</span>, <span class="number">5</span>, <span class="number">43</span>, <span class="number">38</span>, <span class="number">34</span>, <span class="number">78</span>]<span class="comment"># 创建一个变量名b，存储列表用于排序</span></span><br><span class="line"><span class="comment"># 12. sort方法 从小到大排序列表</span></span><br><span class="line">b.sort()</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [5, 34, 38, 43, 78, 89]</span></span><br><span class="line"><span class="comment"># reverse = True 则从大到小 </span></span><br><span class="line">b.sort(reverse = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [89, 78, 43, 38, 34, 5]</span></span><br></pre></td></tr></table></figure></div>  <div class="note-large orange">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-exclamation"></i><p>注意</p>    </div>    <div class="notel-content">      <ul><li>1、List写在方括号之间，元素用逗号隔开。</li><li>2、和字符串一样，list可以被索引和切片。</li><li>3、List可以使用+操作符进行拼接。</li><li>4、List中的元素是可以改变的。</li></ul><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/0dabc641-4476-433f-494e-88eb1256c700/public"                      width = "600"                >    </div>  </div><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/211aefdd-3d66-45c4-27e8-7d284d936900/public"                                     ><h5 id="1-查询示例"><a href="#1-查询示例" class="headerlink" title="1. 查询示例"></a>1. 查询示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;元&#x27;</span>, <span class="string">&#x27;组&#x27;</span>)<span class="comment"># 创建一个变量名a，这是一个元组</span></span><br><span class="line"><span class="comment"># 1. count 方法 返回指定元素在元组出现的次数</span></span><br><span class="line">result = a.count(<span class="string">&#x27;列&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. index 方法 返回指定元素在元组第一次出现的索引位置</span></span><br><span class="line">result = a.index(<span class="string">&#x27;一&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. len 方法 返回元组中元素的个数</span></span><br><span class="line">result = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 6</span></span><br></pre></td></tr></table></figure></div><h5 id="2-添加示例"><a href="#2-添加示例" class="headerlink" title="2. 添加示例"></a>2. 添加示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;元&#x27;</span>, <span class="string">&#x27;组&#x27;</span>)<span class="comment"># 创建一个变量名a，这是一个元组</span></span><br><span class="line">b = (<span class="string">&#x27;这&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;另&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;个&#x27;</span>, <span class="string">&#x27;元&#x27;</span>, <span class="string">&#x27;组&#x27;</span>)<span class="comment"># 创建一个变量名b，这是另一个元组</span></span><br><span class="line"><span class="comment"># 4. 合并两个元组为一个元组</span></span><br><span class="line"><span class="built_in">print</span>(a + b) <span class="comment">#[&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;另&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 将元组重复指定次数</span></span><br><span class="line"><span class="built_in">print</span>(a * <span class="number">4</span>) <span class="comment"># [&#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;, &#x27;这&#x27;, &#x27;是&#x27;, &#x27;一&#x27;, &#x27;个&#x27;, &#x27;元&#x27;, &#x27;组&#x27;]</span></span><br></pre></td></tr></table></figure></div><h5 id="3-内置方法"><a href="#3-内置方法" class="headerlink" title="3. 内置方法"></a>3. 内置方法</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment"># 创建一个变量名c，1,2,3</span></span><br><span class="line"><span class="comment"># 6. max 方法 返回元组中元素的最大值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(c)) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. min 方法 返回元组中元素的最小值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(c)) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="comment"># 8. tuple 方法 将列表或者其它可迭代对象转成元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(d)) <span class="comment"># (&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;)</span></span><br></pre></td></tr></table></figure></div><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/8216ad40-bc2c-42c6-4493-26ad3bf76100/public"                                     ><h5 id="1-删除示例"><a href="#1-删除示例" class="headerlink" title="1. 删除示例"></a>1. 删除示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. replace 把对象中有的值放到第一个参数中替换成第二个参数</span></span><br><span class="line">a = <span class="string">&#x27;值1&#x27;</span></span><br><span class="line">b = a.replace(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># 值1, 字符串不允许被修改</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># 值2，修改结果存储到新的变量b</span></span><br></pre></td></tr></table></figure></div><h5 id="2-修改示例"><a href="#2-修改示例" class="headerlink" title="2. 修改示例"></a>2. 修改示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. upper 把所有字符串字母改成大写</span></span><br><span class="line">a = <span class="string">&#x27;asd&#x27;</span></span><br><span class="line">result = a.upper()</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># ASD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. lower 把所有字符串字母改成小写</span></span><br><span class="line">a = <span class="string">&#x27;ASD&#x27;</span></span><br><span class="line">result = a.lower()</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># asd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. strip 去除字符串首尾指定字符，不传参默认空格</span></span><br><span class="line">a = <span class="string">&#x27;AsAA&#x27;</span></span><br><span class="line">result = a.strip(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># s</span></span><br></pre></td></tr></table></figure></div><h5 id="3-查询示例"><a href="#3-查询示例" class="headerlink" title="3. 查询示例"></a>3. 查询示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;这是一个字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="comment"># 5. count 方法 返回指定元素在字符串出现的次数</span></span><br><span class="line">result = a.count(<span class="string">&#x27;一&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. find 方法 如果包含子字符串返回开始的索引值，否则返回-1</span></span><br><span class="line">result = a.find(<span class="string">&#x27;一&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. index 方法 返回指定元素在字符串第一次出现的索引位置，没有则报错</span></span><br><span class="line">result = a.index(<span class="string">&#x27;一&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></div><h5 id="4-转义示例"><a href="#4-转义示例" class="headerlink" title="4. 转义示例"></a>4. 转义示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. \n 换行</span></span><br><span class="line">a = <span class="string">&#x27;这是一个\n字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#这是一个</span></span><br><span class="line">       <span class="comment">#字符串</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 9.  \t 水平制表符/空格</span></span><br><span class="line">a = <span class="string">&#x27;这是一个\t字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#这是一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10. \b 退格</span></span><br><span class="line">a = <span class="string">&#x27;这是一个\b字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#这是一字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 11. \r 回车，当前位置回到开头，会把前面整个去掉</span></span><br><span class="line">a = <span class="string">&#x27;这是一个\r字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 12. \\ 反斜杠</span></span><br><span class="line">a = <span class="string">&#x27;这是一个\\字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#这是一个\字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 13. \&#x27; 单引号</span></span><br><span class="line">a = <span class="string">&#x27;这是一个\&#x27;字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#这是一个&#x27;字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 14. \0 空字符</span></span><br><span class="line">a = <span class="string">&#x27;这是一个\0字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#这是一个 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 15. \a 系统提示音</span></span><br><span class="line">a = <span class="string">&#x27;这是一个\a字符串&#x27;</span><span class="comment"># 创建一个变量名a，这是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#这是一个字符串</span></span><br></pre></td></tr></table></figure></div><h5 id="5-拼接示例"><a href="#5-拼接示例" class="headerlink" title="5. 拼接示例"></a>5. 拼接示例</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 16. + 拼接方法</span></span><br><span class="line">a = <span class="string">&#x27;这是&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a + b) <span class="comment"># 这是字符串 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 17. join 拼接方法</span></span><br><span class="line">a = [<span class="string">&#x27;2023&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;02&#x27;</span>] <span class="comment"># 列表</span></span><br><span class="line">result = <span class="string">&#x27;-&#x27;</span>.join(a)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 2023-12-02 结果会变为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 18. format 拼接方法</span></span><br><span class="line">a = <span class="string">&#x27;这是&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;一个&#x27;</span></span><br><span class="line">result = <span class="string">&#x27;&#123;&#125;&#123;&#125;字符串&#x27;</span>.<span class="built_in">format</span>(a, b) <span class="comment"># 插入多个值有顺序关系与&#123;&#125;一一对应</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 这是一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 19. f插值法</span></span><br><span class="line">a = <span class="string">&#x27;这是&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;一个&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a&#125;</span><span class="subst">&#123;b&#125;</span>字符串&quot;</span>) <span class="comment"># 这是一个字符串</span></span><br></pre></td></tr></table></figure></div><h5 id="6-编码和解码"><a href="#6-编码和解码" class="headerlink" title="6. 编码和解码"></a>6. 编码和解码</h5><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/050b31f8-fb58-46bb-0e1b-9580d3328800/public"                                     ><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编码</span></span><br><span class="line">name = <span class="string">&quot;字符串&quot;</span>  <span class="comment"># 定义一个变量叫name 存储字符串</span></span><br><span class="line">encode_result = name.encode(<span class="string">&quot;UTF-8&quot;</span>)  <span class="comment"># 通过encode进行编码为UTF-8</span></span><br><span class="line"><span class="built_in">print</span>(encode_result)  <span class="comment"># 结果为b&#x27;\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2&#x27;</span></span><br><span class="line"><span class="comment"># &quot;意味着字符串&quot;在utf8中为\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2,其中b是二进制的意思</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line">decode_result = encode_result.decode(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(decode_result) <span class="comment"># 字符串</span></span><br></pre></td></tr></table></figure></div><h3 id="四-散列（映射）类型"><a href="#四-散列（映射）类型" class="headerlink" title="四 散列（映射）类型"></a>四 散列（映射）类型</h3><h4 id="集合和字典"><a href="#集合和字典" class="headerlink" title="集合和字典"></a>集合和字典</h4><h5 id="集合、字典方法"><a href="#集合、字典方法" class="headerlink" title="集合、字典方法"></a>集合、字典方法</h5><p>用来对里面的数据进行增删改查</p><ol><li>我们可以把<strong>集合、字典</strong>、分别理解为<strong>二个英雄</strong></li><li>它们都有<strong>对应的方法</strong>、方法也就是<strong>英雄的技能</strong>、</li><li>使用<strong>英雄的技能</strong>可以快速杀敌</li><li>使用方法能快速的进行数据的<strong>增删改查</strong></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/712ac721-adea-4711-034f-415b7b4abb00/public"                                     ><h4 id="1-集合-set"><a href="#1-集合-set" class="headerlink" title="1. 集合 set"></a>1. 集合 set</h4><p>集合的特点：</p><ol><li>不重复</li><li>里面有字符串的话就是无规则排序</li><li>没有字符串则按照输入的顺序排序</li><li>集合不能取值，因为是无序的，因为索引只在序列类型不在散列类型</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;字符串2&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;字符串1&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># &#123;1, 2, 3, &#x27;字符串2&#x27;, &#x27;字符串1&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div><h6 id="增加："><a href="#增加：" class="headerlink" title="增加："></a>增加：</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;字符串2&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;字符串1&quot;</span>&#125; <span class="comment"># 变量d存储集合</span></span><br><span class="line"><span class="comment"># 1. add 方法 将元素无序添加到集合中去</span></span><br><span class="line">d.add(<span class="string">&#x27;添加的字符串&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># &#123;1, 2, 3, &#x27;字符串1&#x27;, &#x27;添加的字符串&#x27;, &#x27;字符串2&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div><h6 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;字符串2&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;字符串1&quot;</span>&#125; <span class="comment"># 变量d存储集合</span></span><br><span class="line"><span class="comment"># 2. pop 方法 随机删除一个元素</span></span><br><span class="line">result = d.pop()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;被删除的元素是：&quot;</span>, result) <span class="comment"># 被删除的元素是： 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;被删除后的集合结果：&quot;</span>, d) <span class="comment"># 被删除后的集合结果： &#123;2, 3, &#x27;字符串2&#x27;, &#x27;字符串1&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. remove 方法 删除指定元素，变量a里面没有的元素，就会报错</span></span><br><span class="line">d.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># &#123;1, 3, &#x27;字符串2&#x27;, &#x27;字符串1&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. update 方法 将另一个集合的元素随机且不重复添加到当前的集合中</span></span><br><span class="line">d = &#123;<span class="string">&quot;字符串2&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;字符串1&quot;</span>&#125; <span class="comment"># 变量d存储集合</span></span><br><span class="line">e = &#123;<span class="string">&quot;另外一个字符串3&quot;</span>, <span class="string">&quot;另外一个字符串4&quot;</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125; <span class="comment"># 变量d存储集合</span></span><br><span class="line">d.update(e)</span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># &#123;1, 2, 3, &#x27;字符串1&#x27;, 5, &#x27;另外一个字符串4&#x27;, 7, 8, &#x27;字符串2&#x27;, &#x27;另外一个字符串3&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div><h4 id="2-字典-dict"><a href="#2-字典-dict" class="headerlink" title="2. 字典 dict"></a>2. 字典 dict</h4><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/24a3bdfb-a597-4b15-8298-c88b26be6f00/public"                      width = "400"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4680be29-4408-40c7-a493-d5778937e800/public"                      width = "600"                ><p>字典的特点：</p><ol><li>存值的方式以键值对的方式存储</li><li>可以取值 不能用索引</li></ol><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 键值对</span></span><br><span class="line">a = &#123;</span><br><span class="line">    <span class="comment"># &#x27;key&#x27; 键 所有的键都要用引号</span></span><br><span class="line">    <span class="comment"># &#x27;value&#x27; 值 任意定义</span></span><br><span class="line">    <span class="comment"># 冒号 作用分割 左右两边</span></span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用key来取值</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;key1&#x27;</span>])  <span class="comment">#value1</span></span><br></pre></td></tr></table></figure></div><h6 id="增加：-1"><a href="#增加：-1" class="headerlink" title="增加："></a>增加：</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 键值对</span></span><br><span class="line">a = &#123;</span><br><span class="line">    <span class="comment"># &#x27;key&#x27; 键 所有的键都要用引号</span></span><br><span class="line">    <span class="comment"># &#x27;value&#x27; 值 任意定义</span></span><br><span class="line">    <span class="comment"># 冒号 作用分割 左右两边</span></span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#5. setdefault 有则查，无则增</span></span><br><span class="line">a.setdefault(<span class="string">&#x27;key3&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12, &#x27;key3&#x27;: &#x27;value2&#x27;&#125; 增加</span></span><br><span class="line"><span class="built_in">print</span>(a.setdefault(<span class="string">&#x27;key2&#x27;</span>)) <span class="comment"># 12 查询</span></span><br></pre></td></tr></table></figure></div><h6 id="删除：-1"><a href="#删除：-1" class="headerlink" title="删除："></a>删除：</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 键值对</span></span><br><span class="line">a = &#123;</span><br><span class="line">    <span class="comment"># &#x27;key&#x27; 键 所有的键都要用引号</span></span><br><span class="line">    <span class="comment"># &#x27;value&#x27; 值 任意定义</span></span><br><span class="line">    <span class="comment"># 冒号 作用分割 左右两边</span></span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#6. pop 删除指定key的键值对</span></span><br><span class="line">a.pop(<span class="string">&#x27;key1&#x27;</span>) <span class="comment"># 删除了变量a中的key1</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;key2&#x27;: 12&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. popitem 返回并删除字典中的最后一对键和值</span></span><br><span class="line">a.popitem() <span class="comment"># 删除了变量a中的key2</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;key1&#x27;: &#x27;value1&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div><h6 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 键值对</span></span><br><span class="line"><span class="comment"># 8. update 用于将一个字典中的键值对添加到另一个字典中</span></span><br><span class="line">a = &#123;</span><br><span class="line">    <span class="comment">#  &#x27;key&#x27; 键 所有的键都要用引号</span></span><br><span class="line">    <span class="comment">#  &#x27;value&#x27; 值 任意定义</span></span><br><span class="line">    <span class="comment">#  冒号 作用分割 左右两边</span></span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = &#123;</span><br><span class="line">    <span class="comment">#  &#x27;key&#x27; 键 所有的键都要用引号</span></span><br><span class="line">    <span class="comment">#  &#x27;value&#x27; 值 任意定义</span></span><br><span class="line">    <span class="comment">#  冒号 作用分割 左右两边</span></span><br><span class="line">    <span class="string">&#x27;key3&#x27;</span>: <span class="string">&#x27;value3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.update(b) <span class="comment"># 将字典b的值update 写到这个变量a中去</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: 12, &#x27;key3&#x27;: &#x27;value3&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div><h6 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;</span><br><span class="line">    <span class="comment">#      &#x27;key&#x27; 键 所有的键都要用引号</span></span><br><span class="line">    <span class="comment">#      &#x27;value&#x27; 值 任意定义</span></span><br><span class="line">    <span class="comment">#      冒号 作用分割 左右两边</span></span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. get 获取指定key对应的value，如果key不存在返回none</span></span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;key1&#x27;</span>)) <span class="comment"># value1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10. keys 取出所有的key</span></span><br><span class="line"><span class="built_in">print</span>(a.keys()) <span class="comment"># dict_keys([&#x27;key1&#x27;, &#x27;key2&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 11. values 取出所有的values</span></span><br><span class="line"><span class="built_in">print</span>(a.values()) <span class="comment"># dict_values([&#x27;value1&#x27;, 12])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 12. items 取出所有完整的键值对</span></span><br><span class="line"><span class="built_in">print</span>(a.items()) <span class="comment"># dict_items([(&#x27;key1&#x27;, &#x27;value1&#x27;), (&#x27;key2&#x27;, 12)])</span></span><br></pre></td></tr></table></figure></div><h4 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h4><ol><li>都是花括号，但是存值方式</li><li>集合 是一个一个存， 用逗号, 分割，无序不重复，不能取值</li><li>字典 以键值对的方式存储，应用场景更多，可以取值</li></ol><h4 id="冻结集合"><a href="#冻结集合" class="headerlink" title="冻结集合"></a>冻结集合</h4><p>冻结集合（Frozen Set）是Python中的一个内置类型，它与普通集合（Set）类似，但有一个关键的区别：冻结集合是不可变的。这意味着一旦创建了冻结集合，就不能再添加或删除其中的元素。这种特性使得冻结集合成为一种特殊的、不可更改的集合类型。</p><h5 id="特性和用途"><a href="#特性和用途" class="headerlink" title="特性和用途"></a>特性和用途</h5><ol><li><strong>不可变性（Immutability）</strong>：<ul><li>冻结集合一旦创建，其内容不能被更改。这包括不能添加新元素，也不能从集合中删除元素。</li></ul></li><li><strong>可哈希性（Hashability）</strong>：<ul><li>由于其不可变性，冻结集合是可哈希的（hashable），这意味着它们可以用作字典的键或另一个集合的元素。普通集合由于是可变的，不能被哈希，因此不能用在这些场景中。</li></ul></li><li><strong>支持集合操作</strong>：<ul><li>冻结集合支持普通集合的各种操作，如并集、交集、差集和对称差集等。</li></ul></li></ol><h5 id="创建冻结集合"><a href="#创建冻结集合" class="headerlink" title="创建冻结集合"></a>创建冻结集合</h5><p>冻结集合可以通过内置的 <code>frozenset()</code> 函数创建。例如：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空的冻结集合</span></span><br><span class="line">f_set = <span class="built_in">frozenset</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从现有集合创建冻结集合</span></span><br><span class="line">normal_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">f_set_from_normal = <span class="built_in">frozenset</span>(normal_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从其他可迭代对象创建冻结集合</span></span><br><span class="line">f_set_from_list = <span class="built_in">frozenset</span>([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure></div><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>由于其不可变性和可哈希性，冻结集合特别适用于以下场景：</p><ul><li>作为字典的键。</li><li>作为另一个集合的元素。</li><li>在需要保证集合内容不被更改的情况下使用。</li></ul><h5 id="与普通集合的比较"><a href="#与普通集合的比较" class="headerlink" title="与普通集合的比较"></a>与普通集合的比较</h5><ul><li><strong>普通集合</strong>：可变，支持添加和删除操作，不可哈希，不能用作字典的键或集合的元素。</li><li><strong>冻结集合</strong>：不可变，不支持添加和删除操作，可哈希，可以用作字典的键或集合的元素。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/4e4603d5-fbb2-4778-26e4-bf8e9d34c400/public"                                     ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imagedelivery.net/sodhLvOXTBoeXxRe03g_RA/85a96cc0-80c6-489b-92a6-83b3bac5c200/public"                                     >  <div class="note-large green">    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">      <i class="notel-icon fa-solid fa-circle-question"></i><p>QA</p>    </div>    <div class="notel-content">      <p><strong>问：</strong></p><p>哪种数据类型属于可变数据类型？</p><p><strong>答：</strong></p><p>在Python中，数据类型可以分为几种主要类别，如数值类型、序列类型和散列（映射）类型。在这些类别中，并不是只有列表是可变的。让我们逐一看看这些类型中的可变性：</p><ol><li><strong>数值类型（Numeric Types）</strong>:<ul><li>这些包括整型（int）、浮点型（float）和复数（complex）。这些类型都是不可变的。</li></ul></li><li><strong>序列类型（Sequence Types）</strong>:<ul><li><strong>列表（List）</strong>: 这是可变的。你可以在列表中添加、删除或更改元素。</li><li><strong>字符串（String）和元组（Tuple）</strong>: 这些是不可变的。一旦创建，你不能更改其内部的元素或字符。</li></ul></li><li><strong>散列类型（Mapping Types）</strong>:<ul><li><strong>字典（Dictionary）</strong>: 字典是可变的。你可以在字典中添加、删除或修改条目。</li></ul></li></ol><p>还有其他的类型，比如集合类型（Set Types），其中：</p><ul><li><strong>集合（Set）</strong> 是可变的，可以添加或删除元素。</li><li><strong>冻结集合（Frozen Set）</strong> 是不可变的。</li></ul><p>综上所述，在这些主要的数据类型中，列表、字典和集合是可变的，而数值类型、字符串、元组和冻结集合是不可变的。</p>    </div>  </div>]]></content>
    
    
    <summary type="html">Python语法基础和数据类型</summary>
    
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.yiuhangblog.com/tags/Python/"/>
    
    <category term="基础" scheme="https://www.yiuhangblog.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="理论" scheme="https://www.yiuhangblog.com/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="数据类型" scheme="https://www.yiuhangblog.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="序列类型" scheme="https://www.yiuhangblog.com/tags/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="方法" scheme="https://www.yiuhangblog.com/tags/%E6%96%B9%E6%B3%95/"/>
    
    <category term="编码和解码" scheme="https://www.yiuhangblog.com/tags/%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
</feed>
